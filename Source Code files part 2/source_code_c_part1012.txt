 // Description Block and build the ACPI Name Space.
    //
    status = AMLILoadDDB( table, &diffDataBlock );
    if (NT_SUCCESS(status) ) {

        //
        // Remember that we have loaded this table and that we have a
        // handle to it
        //
        RsdtInformation->Tables[Index].Flags |= RSDTELEMENT_LOADED;
        RsdtInformation->Tables[Index].Handle = diffDataBlock;

    } else {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitializeDDB: AMLILoadDDB failed 0x%8x\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitializeDDB: AMLILoadDDB failed to load DDB\n",
            0
            );

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            8,
            (ULONG_PTR) table,
            table->Header.CreatorRev
            );

    }
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitializeDDBs(
    VOID
    )
/*++

Routine Description:

    This function looks that the RsdtInformation and attemps to load
    all of the possible Dynamic Data Blocks

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       index;
    ULONG       numElements;

    PAGED_CODE();

    //
    // Get the number of elements to process
    //
    numElements = RsdtInformation->NumElements;
    if (numElements == 0) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPInitializeDDBs: No tables found in RSDT\n"
            ) );
        ASSERTMSG(
            "ACPIInitializeDDBs: No tables found in RSDT\n",
            numElements != 0
            );
        return STATUS_ACPI_INVALID_TABLE;

    }

    //
    // We would not be here unless we found a DSDT. So we assume that the
    // *LAST* entry in the table points to the DSDT that we will load. Make
    // sure that we can in fact load it, and then do so
    //
    index = numElements - 1;
    if ( !(RsdtInformation->Tables[index].Flags & RSDTELEMENT_MAPPED) ||
         !(RsdtInformation->Tables[index].Flags & RSDTELEMENT_LOADABLE) ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPInitializeDDB: DSDT not mapped or loadable\n"
            ) );
        ASSERTMSG(
            "ACPIInitializeDDB: DSDT not mapped\n",
            (RsdtInformation->Tables[index].Flags & RSDTELEMENT_MAPPED)
            );
        ASSERTMSG(
            "ACPIInitializeDDB: DSDT not loadable\n",
            (RsdtInformation->Tables[index].Flags & RSDTELEMENT_LOADABLE)
            );
        return STATUS_ACPI_INVALID_TABLE;

    }
    status = ACPIInitializeDDB( index );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // We have one fewer element to look at, so lets ignore the DSDT entry
    //
    numElements--;

    //
    // Loop for all elements in the table
    //
    for (index = 0; index < numElements; index++) {

        //
        // Is the entry mapped and loadable?
        //
        if ( (RsdtInformation->Tables[index].Flags & RSDTELEMENT_MAPPED) &&
             (RsdtInformation->Tables[index].Flags & RSDTELEMENT_LOADABLE) ) {

            //
            // Load the table
            //
            status = ACPIInitializeDDB( index );
            if (!NT_SUCCESS(status)) {

                return status;

            }

        }

    }

    //
    // If we got here, then everything is okay
    //
    return STATUS_SUCCESS;
}

ULONG
GetPBlkAddress(
    IN  UCHAR   Processor
    )
{
    ULONG           pblk;
    NTSTATUS        status;
    OBJDATA         data;
    PNSOBJ          pnsobj = NULL;
    PPROCESSOROBJ   pobj = NULL;

    if (Processor >= ACPI_SUPPORTED_PROCESSORS) {

        return 0;

    }

    if (!ProcessorList[Processor])  {

        return 0;

    }

    status = AMLIEvalNameSpaceObject(
        ProcessorList[Processor],
        &data,
        0,
        NULL
        );

    if ( !NT_SUCCESS(status) ) {

        ACPIBreakPoint ();
        return (0);

    }

    ASSERT (data.dwDataType == OBJTYPE_PROCESSOR);
    ASSERT (data.pbDataBuff != NULL);

    pblk = ((PROCESSOROBJ *)data.pbDataBuff)->dwPBlk;
    AMLIFreeDataBuffs(&data, 1);

    return (pblk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpilock.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpilock.h

Abstract:

    This moulde is the header for acpilock.c

Author:

Environment:

    NT Kernel Mode Driver Only

--*/

#ifndef _ACPILOCK_H_
#define _ACPILOCK_H_

    //
    // Global lock request structure is in acpiioct.h
    // Used only if the requestor must wait for the lock.
    // Cannot grow beyond 4 DWORDs
    //

    // An IRP is queued (LockContext == Irp)
    #define ACPI_GL_QTYPE_IRP       1
    // Internal, LockContext == CallBack
    #define ACPI_GL_QTYPE_INTERNAL  2

    typedef struct _ACPI_GLOBAL_LOCK {
        PVOID       LockContext;
        USHORT      Type;
        USHORT      Depth;
        LIST_ENTRY  ListEntry;
    } ACPI_GLOBAL_LOCK, *PACPI_GLOBAL_LOCK;

    //
    // Public interfaces
    //
    NTSTATUS
    EXPORT
    GlobalLockEventHandler(
        ULONG EventType,
        ULONG What,
        ULONG dwParam,
        PFNAA pfnCallBack,
        PVOID pvCtxt
        );

    //
    // Internal interfaces
    //
    NTSTATUS
    ACPIAsyncAcquireGlobalLock(
        PACPI_GLOBAL_LOCK   Request
        );

    NTSTATUS
    ACPIReleaseGlobalLock(
        PVOID               OwnerContext
        );

    //
    // Hardware Interfaces
    //
    BOOLEAN
    ACPIAcquireHardwareGlobalLock(
        PULONG GlobalLock
        );

    VOID
    ACPIReleaseHardwareGlobalLock(
        VOID
        );

    VOID
    ACPIHardwareGlobalLockReleased (
        VOID
        );

    //
    // Utility procedures
    //
    VOID
    ACPIStartNextGlobalLockRequest (
        VOID
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpiio.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiio.c

Abstract:

    ACPI OS Independent I/O routines

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Eric Nelson - Add Def[ault]Read/Write routines

--*/

#include "pch.h"

//
// This driver is not in alpha or beta stages any more --- we can save some
// CPU calls if we simply define the debug function to nothing
//
#define DebugTraceIO(Write, Port, Length, Value )
static UCHAR IOTrace = 0;

VOID
ACPIIoDebugTrace(
    BOOLEAN Write,
    PUSHORT Port,
    UCHAR Length,
    ULONG Value
    )
{
    if (IOTrace != 0) {

        ACPIPrint( (
           ACPI_PRINT_IO,
           "%x byte %s port 0x%x value %x\n",
           Length, Write ? "WRITE" : "READ", Port, Value
           ) );

    }

}

ULONG
ACPIIoReadPm1Status(
    VOID
    )
/*++

Routine Description:

    This routine reads the PM1 Status registers and masks off any bits that
    we don't care about. This is done because some of these bits are actually
    owned by the HAL

Arguments:

    None

Return Value:

    ULONG

--*/
{

    return READ_PM1_STATUS() &
        (AcpiInformation->pm1_en_bits | PM1_WAK_STS | PM1_TMR_STS | PM1_RTC_STS);
}


VOID
CLEAR_PM1_STATUS_BITS (
    USHORT BitMask
    )
{
    if (AcpiInformation->PM1a_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1a_STATUS, 0, BitMask);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            BitMask
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1b_STATUS, 0, BitMask);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            BitMask
            );

    }
}

VOID
CLEAR_PM1_STATUS_REGISTER (
    VOID
    )
{
    USHORT Value = 0;

    if (AcpiInformation->PM1a_BLK != 0)     {

        Value = READ_ACPI_REGISTER(PM1a_STATUS, 0);
        WRITE_ACPI_REGISTER(PM1a_STATUS, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            Value
            );

    }

    if (AcpiInformation->PM1b_BLK != 0) {

        Value = READ_ACPI_REGISTER(PM1b_STATUS, 0);
        WRITE_ACPI_REGISTER(PM1b_STATUS, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            Value
            );

    }
}

USHORT
READ_PM1_CONTROL(
    VOID
    )
{
    USHORT  pm1=0;

    if (AcpiInformation->PM1a_CTRL_BLK != 0) {

        pm1 = READ_ACPI_REGISTER(PM1a_CONTROL, 0);

    }
    if (AcpiInformation->PM1b_CTRL_BLK != 0) {

        pm1 |= READ_ACPI_REGISTER(PM1b_CONTROL, 0);

    }
    return (pm1);

}

USHORT
READ_PM1_ENABLE(
    VOID
    )
{
    USHORT  pm1=0;

    if (AcpiInformation->PM1a_BLK != 0) {

        pm1 = READ_ACPI_REGISTER(PM1a_ENABLE, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        pm1 |= READ_ACPI_REGISTER(PM1b_ENABLE, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    return (pm1);
}

USHORT
READ_PM1_STATUS(
    VOID
    )
{
    USHORT  pm1=0;

    if (AcpiInformation->PM1a_BLK != 0) {

        pm1 = READ_ACPI_REGISTER(PM1a_STATUS, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        pm1 |= READ_ACPI_REGISTER(PM1b_STATUS, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    return (pm1);
}

VOID
WRITE_PM1_CONTROL(
    USHORT Value,
    BOOLEAN Destructive,
    ULONG Flags
    )
{

    if (!Destructive) {

        USHORT  pm1;

        if ( (Flags & WRITE_REGISTER_A) && (AcpiInformation->PM1a_BLK != 0) ) {

            pm1 = READ_ACPI_REGISTER(PM1a_CONTROL, 0);
            pm1 |= Value;
            WRITE_ACPI_REGISTER(PM1a_CONTROL, 0, pm1);

        }
        if ( (Flags & WRITE_REGISTER_B) && (AcpiInformation->PM1b_BLK != 0) ) {

            pm1 = READ_ACPI_REGISTER(PM1b_CONTROL, 0);
            pm1 |= Value;
            WRITE_ACPI_REGISTER(PM1b_CONTROL, 0, pm1);

        }

    } else {

        //
        // clear this bit and the system dies
        // it is legit when called by the ACPI shutdown code
        // which will use the WRITE_SCI flag.
        //
        ASSERT ( (Flags & WRITE_SCI) || (Value & PM1_SCI_EN) );

        if ( (Flags & WRITE_REGISTER_A) && (AcpiInformation->PM1a_BLK != 0) ) {

            WRITE_ACPI_REGISTER(PM1a_CONTROL, 0, Value);

        }
        if ( (Flags & WRITE_REGISTER_B) && (AcpiInformation->PM1b_BLK != 0) ) {

            WRITE_ACPI_REGISTER(PM1b_CONTROL, 0, Value);

        }

    }
}

VOID
WRITE_PM1_ENABLE(
    USHORT Value
    )
{

    if (AcpiInformation->PM1a_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1a_ENABLE, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            Value
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1b_ENABLE, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            Value
            );

    }
}



USHORT
DefReadAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register
    )
/*++

Routine Description:

    Read from the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to read from.

    Register - Specifies which GP register to read from. Not used for PM1x
               registers.

Return Value:

    Value of the specified ACPI fixed register.

--*/
{
    switch (AcpiReg) {

        case PM1a_ENABLE:
            return READ_PORT_USHORT((PUSHORT)(AcpiInformation->PM1a_BLK +
                                              PM1_EN_OFFSET));
            break;

        case PM1b_ENABLE:
            return READ_PORT_USHORT((PUSHORT)(AcpiInformation->PM1b_BLK +
                                              PM1_EN_OFFSET));
            break;

        case PM1a_STATUS:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_BLK +
                                    PM1_STS_OFFSET);
            break;

        case PM1b_STATUS:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_BLK +
                                    PM1_STS_OFFSET);
            break;

        case PM1a_CONTROL:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_CTRL_BLK);
            break;

        case PM1b_CONTROL:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_CTRL_BLK);
            break;

        case GP_STATUS:
            if (Register < AcpiInformation->Gpe0Size) {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_BLK +
                                                Register));
            } else {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_BLK +
                                                Register -
                                                AcpiInformation->Gpe0Size));
            }
            break;

        case GP_ENABLE:
            if (Register < AcpiInformation->Gpe0Size) {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_ENABLE +
                                                Register));
            } else {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_ENABLE +
                                                Register -
                                                AcpiInformation->Gpe0Size));
            }
            break;

        case SMI_CMD:
            return READ_PORT_UCHAR((PUCHAR)AcpiInformation->SMI_CMD);
            break;

        default:
            break;
    }

    return (USHORT)-1;
}



VOID
DefWriteAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register,
    USHORT Value
    )
/*++

Routine Description:

    Write to the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to write to.

    Register - Specifies which GP register to write to. Not used for PM1x
               registers.

    Value - Data to write.

Return Value:

    None.

--*/
{
    switch (AcpiReg) {

        case PM1a_ENABLE:
            WRITE_PORT_USHORT((PUSHORT)(AcpiInformation->PM1a_BLK +
                                        PM1_EN_OFFSET), Value);
            break;

        case PM1b_ENABLE:
            WRITE_PORT_USHORT((PUSHORT)(AcpiInformation->PM1b_BLK +
                                        PM1_EN_OFFSET), Value);
            break;

        case PM1a_STATUS:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_BLK +
                              PM1_STS_OFFSET, Value);
            break;

        case PM1b_STATUS:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_BLK +
                              PM1_STS_OFFSET, Value);
            break;

        case PM1a_CONTROL:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_CTRL_BLK, Value);
            break;

        case PM1b_CONTROL:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_CTRL_BLK, Value);
            break;

        case GP_STATUS:
            if (Register < AcpiInformation->Gpe0Size) {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_BLK + Register),
                                 (UCHAR)Value);
            } else {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_BLK + Register -
                                          AcpiInformation->Gpe0Size),
                                 (UCHAR)Value);
            }
            break;

        case GP_ENABLE:
            if (Register < AcpiInformation->Gpe0Size) {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_ENABLE +
                                          Register),
                                 (UCHAR)Value);
            } else {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_ENABLE +
                                          Register -
                                          AcpiInformation->Gpe0Size),
                                 (UCHAR)Value);
            }
            break;

        case SMI_CMD:
            WRITE_PORT_UCHAR((PUCHAR)AcpiInformation->SMI_CMD, (UCHAR)Value);
            break;

        default:
            break;
    }
}

//
// READ/WRITE_ACPI_REGISTER macros are implemented via these
// function pointers
//
PREAD_ACPI_REGISTER  AcpiReadRegisterRoutine  = DefReadAcpiRegister;
PWRITE_ACPI_REGISTER AcpiWriteRegisterRoutine = DefWriteAcpiRegister;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpilock.c ===
/*
 *  ACPILOCK.C -- ACPI OS Independent functions for managing the ACPI Global Lock
 *
 */

#include "pch.h"

#define ACPI_LOCK_PENDING_BIT 0
#define ACPI_LOCK_OWNED_BIT   1

#define ACPI_LOCK_PENDING (1 << ACPI_LOCK_PENDING_BIT)
#define ACPI_LOCK_OWNED   (1 << ACPI_LOCK_OWNED_BIT)

NTSTATUS EXPORT
GlobalLockEventHandler (
    ULONG                   EventType,
    ULONG                   What,
    ULONG                   dwParam,
    PFNAA                   Callback,
    PVOID                   Context
    )
/*++

Routine Description:

    This is the internal front-end for global lock requests.

Arguments:

    EventType       - Only global lock acquire/release supported
    What            - Acquire or Release
    Param           - Not used
    Callback        - Async callback (acquire only)
    Context         - LockRequest struct and context for callback (must be same for acquire/release)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_GLOBAL_LOCK       LockRequest = Context;


    ASSERT (EventType == EVTYPE_ACQREL_GLOBALLOCK);

    switch (What) {

        case GLOBALLOCK_ACQUIRE:

            //
            // Fill out the lock request.  Internal requests have no Irp, just pass
            // in the address of the callback routine.
            //
            LockRequest->LockContext = Callback;
            LockRequest->Type = ACPI_GL_QTYPE_INTERNAL;

            status = ACPIAsyncAcquireGlobalLock (LockRequest);

            break;

        case GLOBALLOCK_RELEASE:

            status = ACPIReleaseGlobalLock (Context);
            break;

        default:

            ACPIBreakPoint ();
            status = STATUS_INVALID_PARAMETER;
    }

    return status;
}


NTSTATUS
ACPIAsyncAcquireGlobalLock(
    PACPI_GLOBAL_LOCK       Request
    )
/*++

Routine Description:

    Attempt to acquire the hardware Global Lock.  If the global lock is busy due to another NT thread
    or the BIOS, the request is queued.  The request will be satisfied when 1) All other requests in
    front of it on the queue have released the lock, and 2) The BIOS has released the lock.

Arguments:

    Request                 - Contains context and callback

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   OldIrql;
    PLIST_ENTRY             entry;
    PACPI_GLOBAL_LOCK       queuedRequest;


    ACPIDebugEnter("ACPIAsyncAcquireGlobalLock");
    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIAsyncAcquireGlobalLock: Entered with context %x\n",
        Request
        ) );

    //
    // If caller is the current owner, just increment the depth count
    //

    if (Request == AcpiInformation->GlobalLockOwnerContext) {

        AcpiInformation->GlobalLockOwnerDepth++;

        ACPIPrint( (
            ACPI_PRINT_IO,
            "ACPIAsyncAcquireGlobalLock: Recursive acquire by owner %x, new depth=%d\n",
            Request, AcpiInformation->GlobalLockOwnerDepth
            ) );

        return STATUS_SUCCESS;
    }

    //
    // Lock the Global Lock Queue.  We don't want any state changes while we examine
    // the queue and (possibly) attempt to get the hardware global lock.  For example,
    // if the list is empty, but the BIOS has the lock, we don't want to unlock the queue
    // until we have put the request on it -- so that the release interrupt will dispatch
    // the request.
    //

    KeAcquireSpinLock (&AcpiInformation->GlobalLockQueueLock, &OldIrql);

    //
    // Check if there are others in front of us.  If not, we can try to get the lock
    //

    if (IsListEmpty (&AcpiInformation->GlobalLockQueue)) {

        //
        // Try to grab the lock.  It will only be available if no other thread nor
        // the BIOS has it.
        //

        if (ACPIAcquireHardwareGlobalLock (AcpiInformation->GlobalLock)) {

            //
            // Got the lock.  Setup owner and unlock the queue
            //

            AcpiInformation->GlobalLockOwnerContext = Request;
            AcpiInformation->GlobalLockOwnerDepth = 1;

            KeReleaseSpinLock (&AcpiInformation->GlobalLockQueueLock, OldIrql);

            ACPIPrint( (
                ACPI_PRINT_IO,
                "ACPIAsyncAcquireGlobalLock: Got lock immediately, Context %x\n",
                Request
                ) );

            return STATUS_SUCCESS;
        }
    }


    //
    // We have to wait for the lock.
    //
    // First, check if context is already queued.
    //
    for (entry = AcpiInformation->GlobalLockQueue.Flink;
            entry != &AcpiInformation->GlobalLockQueue;
            entry = entry->Flink) {

        queuedRequest = CONTAINING_RECORD (entry, ACPI_GLOBAL_LOCK, ListEntry);

        if (queuedRequest == Request) {

            //
            // Already queued, we just increment the depth count and exit.
            //

            ACPIPrint( (
                ACPI_PRINT_IO,
                "ACPIAsyncAcquireGlobalLock: Waiting for lock <again>, Context %x depth %x\n",
                Request, Request->Depth
                ) );

            queuedRequest->Depth++;
            KeReleaseSpinLock (&AcpiInformation->GlobalLockQueueLock, OldIrql);

            return STATUS_PENDING;
        }
    }

    //
    // Put this request on the global lock queue
    //

    Request->Depth = 1;

    InsertTailList (
        &AcpiInformation->GlobalLockQueue,
        &Request->ListEntry
        );

    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIAsyncAcquireGlobalLock: Waiting for lock, Context %x\n",
        Request
        ) );

    KeReleaseSpinLock (&AcpiInformation->GlobalLockQueueLock, OldIrql);

    return STATUS_PENDING;


    ACPIDebugExit("ACPIAsyncAcquireGlobalLock");
}



NTSTATUS
ACPIReleaseGlobalLock(
    PVOID                   OwnerContext
    )
/*++

Routine Description:

    Release the global lock.  Caller must provide the owning context.  If there are any additional
    requests on the queue, re-acquire the global lock and dispatch the next owner.

    The hardware lock is released and re-acquired so that we don't starve the BIOS from the lock.

Arguments:

    OwnerContext        - Must be same context that was used to acquire the lock

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   OldIrql;

    ACPIDebugEnter("ACPIReleaseGlobalLock");

    //
    // Caller must be the current owner of the lock
    //

    if (OwnerContext != AcpiInformation->GlobalLockOwnerContext) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPIReleaseGlobalLock: Not owner, can't release!  Owner is %x Caller context is %x\n",
            AcpiInformation->GlobalLockOwnerContext, OwnerContext
            ) );

        return STATUS_ACPI_MUTEX_NOT_OWNER;
    }

    //
    // Only the current owner of the global lock gets here.
    // Release the lock when the depth count reaches 0
    //

    if (--AcpiInformation->GlobalLockOwnerDepth > 0) {

        ACPIPrint( (
            ACPI_PRINT_IO,
            "ACPIReleaseGlobalLock:  Recursively owned by context %x, depth remaining %d\n",
            AcpiInformation->GlobalLockOwnerContext, AcpiInformation->GlobalLockOwnerDepth
            ) );

        return STATUS_SUCCESS;
    }

    //
    // Mark lock not owned, and physically release the thing.
    // This allows the BIOS a chance at getting the lock.
    //

    AcpiInformation->GlobalLockOwnerContext = NULL;
    ACPIReleaseHardwareGlobalLock ();

    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIReleaseGlobalLock: Lock released by context %x\n",
        OwnerContext
        ) );

    //
    // It is our responsibility to hand off the lock to the next-in-line.
    // First, check if there is anything on the queue.
    //

    if (IsListEmpty (&AcpiInformation->GlobalLockQueue)) {

        return STATUS_SUCCESS;                  // Nope, all done, nothing else to do
    }

    //
    // The queue is not empty, we must get the lock back
    //

    if (!ACPIAcquireHardwareGlobalLock (AcpiInformation->GlobalLock)) {

        return STATUS_SUCCESS;                  // BIOS has the lock, just wait for interrupt
    }

    //
    // Got the lock, now dispatch the next owner
    //

    ACPIStartNextGlobalLockRequest ();

    ACPIDebugExit("ACPIReleaseGlobalLock");

    return STATUS_SUCCESS;
}



void
ACPIHardwareGlobalLockReleased (
    void
    )
/*++

Routine Description:

    Called from the ACPI interrupt DPC.  We get here only if an attempt to get the global lock has
    been made, but failed because the BIOS had the lock.  As a result, the lock was marked pending,
    and this interrupt has happened because the BIOS has released the lock.

    Therefore, this procedure must acquire the hardware lock and dispatch ownership to the next
    request on the queue.

Arguments:

    NONE

Return Value:

    NONE

--*/
{

    //
    // Attempt to get the global lock on behalf of the next request in the queue
    //

    if (!ACPIAcquireHardwareGlobalLock (AcpiInformation->GlobalLock)) {

        return;                                 // BIOS has the lock (again), just wait for next interrupt
    }

    //
    // Got the lock, now dispatch the next owner
    //

    ACPIStartNextGlobalLockRequest ();

}



void
ACPIStartNextGlobalLockRequest (
    void
    )
/*++

Routine Description:

    Get the next request off the queue, and give it the global lock.

    This routine can only be called by the thread that currently holds the hardware lock.  If
    the queue is empty, the lock is released.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    PLIST_ENTRY             link;
    PACPI_GLOBAL_LOCK       request;
    PFNAA                   callback;
    PIRP                    irp;

    //
    // Get next request from the queue.
    //

    link = ExInterlockedRemoveHeadList (
            &AcpiInformation->GlobalLockQueue,
            &AcpiInformation->GlobalLockQueueLock
            );

    //
    // If something failed after the original thread tried to get the lock, then
    // the queue might be empty.
    //
    if (link == NULL) {

        ACPIPrint( (
            ACPI_PRINT_IO,
            "ACPIStartNextGlobalLockRequest: Queue is empty, releasing lock\n"
            ) );

        ACPIReleaseHardwareGlobalLock ();
        return;
    }

    //
    // Complete the next global lock request
    //

    request = CONTAINING_RECORD (link, ACPI_GLOBAL_LOCK, ListEntry);

    //
    // Bookkeeping
    //

    AcpiInformation->GlobalLockOwnerContext = request;
    AcpiInformation->GlobalLockOwnerDepth = request->Depth;

    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIStartNextGlobalLockRequest: Dispatch new owner, ctxt %x callb %x\n",
        request, request->LockContext
        ) );

    //
    // Let the requestor know that it now has the lock
    //

    switch (request->Type) {

        case ACPI_GL_QTYPE_INTERNAL:

            //
            // Internal request - invoke the callback
            //
            callback = (PFNAA) request->LockContext;
            callback (request);

            break;

        case ACPI_GL_QTYPE_IRP:

            //
            // External request - complete the Irp
            //
            irp = (PIRP) request->LockContext;
            irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (irp, IO_NO_INCREMENT);

            break;

        default:        // Shouldn't happen...

            ACPIBreakPoint();
            break;
    }
}



BOOLEAN
ACPIAcquireHardwareGlobalLock(
    PULONG GlobalLock
    )
/*++

Routine Description:

    Attempt to obtain the hardware global lock.

Arguments:

    NONE

Return Value:

    TRUE if acquired, FALSE if pending.

--*/
{
    ULONG lockValue;
    ULONG oldLockValue;
    BOOLEAN owned;

    lockValue = *((ULONG volatile *)GlobalLock);
    do {

        //
        // Record the original state of the lock.  Shift the contents of
        // the ACPI_LOCK_OWNED bit to the ACPI_LOCK_PENDING bit, and set the
        // ACPI_LOCK_OWNED bit.
        //
        // Finally, update the new value atomically, and repeat the whole
        // process if someone else changed it under us.
        // 

        oldLockValue = lockValue;

        lockValue |= ACPI_LOCK_OWNED |
                     ((lockValue & ACPI_LOCK_OWNED) >>
                         (ACPI_LOCK_OWNED_BIT - ACPI_LOCK_PENDING_BIT));

        lockValue = InterlockedCompareExchange(GlobalLock,
                                               lockValue,
                                               oldLockValue);

    } while (lockValue != oldLockValue);

    //
    // If the lock owned bit was previously clear then we are the owner.
    //

    owned = ((lockValue & ACPI_LOCK_OWNED) == 0);
    return owned;
}


void
ACPIReleaseHardwareGlobalLock(
    void
    )
/*++

Routine Description:

    Release the hardware global lock.  If the BIOS is waiting for the lock (indicated by the
    pending bit), then set GBL_RLS to signal the BIOS.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    ULONG lockValue;
    ULONG oldLockValue;
    ULONG volatile *globalLock;

    globalLock = (ULONG volatile *)AcpiInformation->GlobalLock;
    lockValue = *globalLock;

    do {

        ASSERT((lockValue & ACPI_LOCK_OWNED) != 0);

        oldLockValue = lockValue;

        //
        // Clear the owned and pending bits in the lock, and atomically set
        // the new value.  If the cmpxchg fails, go around again.
        // 

        lockValue &= ~(ACPI_LOCK_OWNED | ACPI_LOCK_PENDING);
        lockValue = InterlockedCompareExchange(globalLock,
                                               lockValue,
                                               oldLockValue);

    } while (lockValue != oldLockValue);

    if ((lockValue & ACPI_LOCK_PENDING) != 0) {

        //
        // Signal to bios that the Lock has been released
        //      Set GBL_RLS
        //

        WRITE_PM1_CONTROL( (USHORT)PM1_GBL_RLS, FALSE, WRITE_REGISTER_A_AND_B);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpioprg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpioprg.h

Abstract:

    This module is the header for acpioprg.c

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver Only

--*/

#ifndef _ACPIOPRG_H_
#define _ACPIOPRG_H_

    typedef struct _OPREGIONHANDLER     {
        PFNHND          Handler;
        PVOID           HandlerContext;
        ULONG           AccessType;
        ULONG           RegionSpace;
    } OPREGIONHANDLER, *POPREGIONHANDLER;

    //
    // Public interfaces
    //
    NTSTATUS
    RegisterOperationRegionHandler (
        PNSOBJ          RegionParent,
        ULONG           AccessType,
        ULONG           RegionSpace,
        PFNHND          Handler,
        ULONG_PTR       Context,
        PVOID           *OperationRegion
        );

    NTSTATUS
    UnRegisterOperationRegionHandler  (
        IN PNSOBJ   RegionParent,
        IN PVOID    OperationRegionObject
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpintfy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    acpintfy.h

Abstract:

    This module contains that provides the header support for notifying
    interested parties of events

Author:

    Jason Clark
    Ken Reneris
    Stephane

Environment:

    NT Kernel Mode Driver only

--*/

#ifndef _ACPINTFY_H_
#define _ACPINTFY_H_

    extern KSPIN_LOCK           NotifyHandlerLock;

    NTSTATUS
    ACPIRegisterForDeviceNotifications (
        IN PDEVICE_OBJECT               DeviceObject,
        IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify,
        IN PVOID                        Context
        );

    VOID
    ACPIUnregisterForDeviceNotifications (
        IN PDEVICE_OBJECT               DeviceObject,
        IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify
        );

    NTSTATUS
    EXPORT
    NotifyHandler(
        ULONG dwEventType,
        ULONG dwEventData,
        PNSOBJ pnsObj,
        ULONG dwParam,
        PFNAA CompletionCallback,
        PVOID CallbackContext
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpintfy.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpintfy.c

Abstract:

    This modules contains code to deal with notifying interested parties
    of events

Author:

    Jason Clark
    Ken Reneris

Environment:

    NT Kernel Model Driver only
    Some changes are required to work in win9x model

--*/
#include "pch.h"

//
// For handler installation
//
KSPIN_LOCK           NotifyHandlerLock;

NTSTATUS
ACPIRegisterForDeviceNotifications (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify,
    IN PVOID                        Context
    )
/*++

Routine Description:

    Registers the DeviceNotify function as the function to receive device notify
    callbacks

Arguments:

    DeviceObject    - The device object to register a notification handler for
    DeviceNotify    - The handle for device specific notifications

Return Value

    Returns status

--*/
{
    PACPI_POWER_INFO    node;
    PVOID               previous;
    KIRQL               oldIrql;
    NTSTATUS            status;


    //
    // Find the Node associated with this device object (or DevNode)
    // Note: that for NT, the context field is the DeviceExtension of the
    // DeviceObject, since this is what is stored within the ACPI Name Space
    // object
    //
    node = OSPowerFindPowerInfoByContext( DeviceObject );
    if (node == NULL) {

        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // Apply the handler
    //
    KeAcquireSpinLock (&NotifyHandlerLock, &oldIrql);

    if (node->DeviceNotifyHandler != NULL) {

        //
        // A handler already present
        //
        status = STATUS_UNSUCCESSFUL;

    } else {

        node->DeviceNotifyHandler = DeviceNotify;
        node->HandlerContext = Context;
        status = STATUS_SUCCESS;

    }

    KeReleaseSpinLock (&NotifyHandlerLock, oldIrql);

    return status;
}


VOID
ACPIUnregisterForDeviceNotifications (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify
    )
/*++

Routine Description:

    Disconnects a handler from device notify event.

Arguments:

    DeviceObject        - The device object to register a notification handler for

    DeviceNotify        - The handle for device specific notifications

Return Value

    None

--*/
{
    PACPI_POWER_INFO    node;
    PVOID               previous;
    KIRQL               oldIrql;
    NTSTATUS            status;


    //
    // Find the Node associated with this device object (or DevNode)
    // Note: that for NT, the context field is the DeviceExtension of the
    // DeviceObject, since this is what is stored within the ACPI Name Space
    // object
    //
    node = OSPowerFindPowerInfoByContext( DeviceObject );
    if (node == NULL) {
        ASSERTMSG("ACPIUnregisterForDeviceNotifications failed.  "\
                  "Can't find ACPI_POWER_INFO for DeviceObject", FALSE);
        return;
    }

    //
    // Attempt to remove the handler/context from the node
    //
    KeAcquireSpinLock (&NotifyHandlerLock, &oldIrql);

    if (node->DeviceNotifyHandler != DeviceNotify) {

        //
        // Handler does not match
        //
        ASSERTMSG("ACPIUnregisterForDeviceNotifications failed.  "\
                  "Handler doesn't match.", FALSE);

    } else {

        node->DeviceNotifyHandler = NULL;
        node->HandlerContext = NULL;

    }

    KeReleaseSpinLock (&NotifyHandlerLock, oldIrql);

    return;
}


NTSTATUS EXPORT
NotifyHandler (
    ULONG           dwEventType,
    ULONG           dwEventData,
    PNSOBJ          pnsObj,
    ULONG           dwParam,
    PFNAA           CompletionCallback,
    PVOID           CallbackContext
    )
/*++

Routine Description:

    The master ACPI notify handler.

    The design philosophy here is that ACPI should process all notify requests
    that *ONLY* it can handle, namely, DeviceCheck, DeviceEject, and DeviceWake,
    and let *all* other notifies get handled by the driver associated with the
    object. The other driver will also get told about the ACPI handled events,
    but that is only as an FYI, the driver shouldn't do anything...

Arguments:

    dwEventType - The type of event that occured (this is EVTYPE_NOTIFY)
    dwEventData - The event code
    pnsObj      - The name space object that was notified
    dwParam     - The event code

Return Value

    NTSTATUS

--*/
{
    PACPI_POWER_INFO        node;
    KIRQL                   oldIrql;
    PDEVICE_NOTIFY_CALLBACK notifyHandler;
    PVOID                   notifyHandlerContext;

    ASSERT (dwEventType == EVTYPE_NOTIFY);

    ACPIPrint( (
        ACPI_PRINT_DPC,
        "ACPINotifyHandler: Notify on %x value %x, object type %x\n",
        pnsObj,
        dwEventData,
        NSGETOBJTYPE(pnsObj)
        ) );

    //
    // Any events which must be handled by ACPI and is common to all device
    // object types is handled here
    //
    switch (dwEventData) {
        case OPEVENT_DEVICE_ENUM:
            OSNotifyDeviceEnum( pnsObj );
            break;
        case OPEVENT_DEVICE_CHECK:
            OSNotifyDeviceCheck( pnsObj );
            break;
        case OPEVENT_DEVICE_WAKE:
            OSNotifyDeviceWake( pnsObj );
            break;
        case OPEVENT_DEVICE_EJECT:
            OSNotifyDeviceEject( pnsObj );
            break;
    }

    //
    // Look for handle for this node and dispatch it
    //
    node = OSPowerFindPowerInfo(pnsObj);
    if (node) {

        //
        // Get handler address/context with mutex
        //
        KeAcquireSpinLock (&NotifyHandlerLock, &oldIrql);

        notifyHandler = node->DeviceNotifyHandler;
        notifyHandlerContext = node->HandlerContext;

        KeReleaseSpinLock (&NotifyHandlerLock, oldIrql);

        //
        // If we got something, dispatch it
        //
        if (notifyHandler) {

            notifyHandler (notifyHandlerContext, dwEventData);

        }

    }
    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpisi.h ===
/*
 *  ACPISI.H - ACPI OS Independent System Indicator Routines
 *
 *  Notes:
 *
 *      This file provides OS independent functions for managing system indicators
 *
 */

typedef enum _SYSTEM_INDICATORS {

    SystemStatus,
    MessageWaiting

} SYSTEM_INDICATORS;


extern BOOLEAN SetSystemIndicator  (SYSTEM_INDICATORS  SystemIndicators, ULONG Value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpiterm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiterm.c

Abstract:

    This module contains functions to put an ACPI machine out of ACPI mode

Author:

    Jason Clark (jasoncl)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


VOID
ACPICleanUp(
    VOID
    )
/*++

Routine Description:

    Resets the machine state out of ACPI mode and frees data structures
    allocated by this part of the driver

Arguments:

    None

Return Value:

    None

--*/
{
     //
     // Free the ACPIInformation structure.
     //
     ACPIPrint( (
         ACPI_PRINT_WARNING,
         "ACPICleanUp: Cleaning Up --- ACPI Terminated\n"
         ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpisi.c ===
/*
 *  ACPISI.C - ACPI OS Independent System Indicator Routines
 *
 *  Notes:
 *
 *      This file provides OS independent functions for managing system indicators
 *
 */

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SetSystemIndicator)
#endif


BOOLEAN
SetSystemIndicator  (
    SYSTEM_INDICATORS  SystemIndicators,
    ULONG Value
    )
{
    PNSOBJ  pns = NULL, pnssi = NULL;
    OBJDATA Arg0,data;
    char    IndicatorName []= "_SST";

    PAGED_CODE();


    switch (SystemIndicators)   {

        case SystemStatus:
            // StrCpy (IndicatorName, "_SST",sizeof(IndicatorName));

            // init arg0 for the control method

            ACPIPrint( (
                ACPI_PRINT_POWER,
                "System Status Value = %x\n",
                Value
                ) );

            Arg0.dwfData = 0;
            Arg0.uipDataValue = Value;
            Arg0.dwDataType = OBJTYPE_INTDATA;
            Arg0.dwDataLen = 0;
            Arg0.pbDataBuff = NULL;

            break;

        case MessageWaiting:
            StrCpy (IndicatorName, "_MSG",sizeof(IndicatorName));

            // init arg0 for the control method

            ACPIPrint( (
                ACPI_PRINT_POWER,
                "Message Waiting Value = %x\n",
                Value
                ) );

            Arg0.dwfData = 0;
            Arg0.uipDataValue = Value;
            Arg0.dwDataType = OBJTYPE_INTDATA;
            Arg0.dwDataLen = 0;
            Arg0.pbDataBuff = NULL;

            break;

        default:
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "SetSystemIndicator: Unknown Indicator\n"
                ) );

            return FALSE;
    }

    if ( AMLIERR(AMLIGetNameSpaceObject ("\\_SI",NULL, &pnssi,0)) != AMLIERR_NONE )   {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "Could not GET \\_SI\n"
            ) );

        ACPIBreakPoint ();
        return FALSE;
    }

    if ( AMLIERR(AMLIGetNameSpaceObject (IndicatorName, pnssi, &pns,NSF_LOCAL_SCOPE)) == AMLIERR_NONE )    {

        if ( AMLIERR(AMLIEvalNameSpaceObject (pns,&data, 1, &Arg0)) == AMLIERR_NONE )   {

            AMLIFreeDataBuffs (&data,1);

        } else {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "Attempt to Eval %s %x failed using objdata %x\n",
                IndicatorName,pns,&Arg0
                ) );
            ACPIBreakPoint ();

        }

    } else {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "Attempt to GET %s failed\n",
            IndicatorName,pns,&Arg0
            ) );

    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpioprg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpioprg.c

Abstract:

    This module provides support for registering ACPI operation regions

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver Only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,RegisterOperationRegionHandler)
#endif

NTSTATUS
EXPORT
InternalRawAccessOpRegionHandler (
    IN ULONG dwAccType,
    IN PFIELDUNITOBJ FieldUnit,
    IN POBJDATA data,
    IN ULONG_PTR Context,
    IN PFNAA CompletionHandler,
    IN PVOID IntContext
    )
{
    NTSTATUS         status;
    PNSOBJ           HostDevice = NULL;
    PACPI_POWER_INFO DeviceNode;
    PVOID            DeviceHandle;

    //
    // Get the device
    //
    status = AMLIGetFieldUnitRegionObj( FieldUnit, &HostDevice );
    if ( AMLIERR( status ) != AMLIERR_NONE || HostDevice == NULL) {

        return (STATUS_UNSUCCESSFUL);

    }

    HostDevice = NSGETPARENT(HostDevice);
    ACPIPrint( (
        ACPI_PRINT_IO,
        "Raw OpRegion Access on field unit object %x device %x\n",
        FieldUnit, HostDevice
        ));
    if ( (!HostDevice) || (NSGETOBJTYPE(HostDevice)!=OBJTYPE_DEVICE) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceNode = OSPowerFindPowerInfo(HostDevice);
    if ( DeviceNode == NULL ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceHandle = DeviceNode->Context;
    ACPIPrint( (
        ACPI_PRINT_IO,
        "DeviceHandle %x\n",
        DeviceHandle
        ) );


    if ( !(POPREGIONHANDLER)Context || !(((POPREGIONHANDLER)Context)->Handler) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    return(
        (((POPREGIONHANDLER)Context)->Handler)(
            dwAccType,
            FieldUnit,
            data,
            ((POPREGIONHANDLER)Context)->HandlerContext,
            CompletionHandler,
            IntContext
            )
        );
}


NTSTATUS
EXPORT
InternalOpRegionHandler (
    IN ULONG dwAccType,
    IN PNSOBJ pnsOpRegion,
    IN ULONG dwAddr,
    IN ULONG dwSize,
    IN PULONG pdwData,
    IN ULONG_PTR Context,
    IN PFNAA CompletionHandler,
    IN PVOID IntContext
    )
{
    PNSOBJ HostDevice;
    PACPI_POWER_INFO DeviceNode;
    PVOID DeviceHandle;
    NTSTATUS status;


    HostDevice = NSGETPARENT(pnsOpRegion);

    ACPIPrint( (
        ACPI_PRINT_IO,
        "OpRegion Access on region %x device %x\n",
        pnsOpRegion, HostDevice
        ) );
    if ( (!HostDevice) || (NSGETOBJTYPE(HostDevice) != OBJTYPE_DEVICE) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceNode = OSPowerFindPowerInfo (HostDevice);
    if ( DeviceNode == NULL ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceHandle = DeviceNode->Context;
    ACPIPrint( (
        ACPI_PRINT_IO,
        "DeviceHandle %x\n",
        DeviceHandle
        ) );
    if ( !(POPREGIONHANDLER)Context || !(((POPREGIONHANDLER)Context)->Handler) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    status = (((POPREGIONHANDLER)Context)->Handler) (
        dwAccType,
        pnsOpRegion,
        dwAddr,
        dwSize,
        pdwData,
        ((POPREGIONHANDLER)Context)->HandlerContext,
        CompletionHandler,
        IntContext);
    ACPIPrint( (
        ACPI_PRINT_IO,
        "Return from OR handler - status %x\n",
        status
        ) );
    return (status);
}

//
// Register to receive accesses to the specified operation region
//
NTSTATUS
RegisterOperationRegionHandler  (
    IN PNSOBJ           RegionParent,
    IN ULONG            AccessType,
    IN ULONG            RegionSpace,
    IN PFNHND           Handler,
    IN ULONG_PTR        Context,
    OUT PVOID           *OperationRegionObject
    )
{
    NTSTATUS            status;
    OBJDATA             regArgs[2];
    POPREGIONHANDLER    HandlerNode;
    PNSOBJ              regObject;

    PAGED_CODE();

    *OperationRegionObject = NULL;
    status = STATUS_SUCCESS;

    //
    // Allocate a new Operation Region Object
    //
    HandlerNode = ExAllocatePool (NonPagedPool, sizeof(OPREGIONHANDLER));
    if ( !HandlerNode ) {

        return (STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Init the Operation Region Object
    //
    HandlerNode->Handler        = Handler;
    HandlerNode->HandlerContext = (PVOID)Context;
    HandlerNode->AccessType     = AccessType;
    HandlerNode->RegionSpace    = RegionSpace;

    //
    // Raw or Cooked access supported
    //
    switch ( AccessType ) {
    case EVTYPE_RS_COOKACCESS:

        status = AMLIRegEventHandler(
            AccessType,
            RegionSpace,
            InternalOpRegionHandler,
            (ULONG_PTR)HandlerNode
            );
        if ( AMLIERR(status) != AMLIERR_NONE ) {

            status = STATUS_UNSUCCESSFUL;

        }
        break;

    case EVTYPE_RS_RAWACCESS:

        status = AMLIRegEventHandler(
            AccessType,
            RegionSpace,
            InternalRawAccessOpRegionHandler,
            (ULONG_PTR)HandlerNode
            );
        if ( AMLIERR(status) != AMLIERR_NONE ) {

            status = STATUS_UNSUCCESSFUL;

        }
        break;

    default:

        status = STATUS_INVALID_PARAMETER;
        break;

    }

    //
    // Cleanup if needed
    //
    if ( !NT_SUCCESS (status) ) {

        ExFreePool (HandlerNode);
        return (status);

    }

    //
    // Remember the handler
    //
    *OperationRegionObject = HandlerNode;

    //
    // Can we find something?
    //
    if ( RegionParent == NULL ) {

        //
        // Do nothing
        //
        return (STATUS_SUCCESS);

    }

    //
    // see if there is a _REG object to run
    //
    status = AMLIGetNameSpaceObject(
        "_REG",
        RegionParent,
        &regObject,
        NSF_LOCAL_SCOPE
        );
    if ( !NT_SUCCESS(status) ) {

        //
        // Nothing to do
        //
        return (STATUS_SUCCESS);

    }

    //
    // Initialize the parameters
    //
    RtlZeroMemory( regArgs, sizeof(OBJDATA) * 2 );
    regArgs[0].dwDataType = OBJTYPE_INTDATA;
    regArgs[0].uipDataValue = RegionSpace;
    regArgs[1].dwDataType = OBJTYPE_INTDATA;
    regArgs[1].uipDataValue = 1;

    //
    // Eval the request. We can do this asynchronously since we don't actually
    // care when the registration is complete
    //
    AMLIAsyncEvalObject(
        regObject,
        NULL,
        2,
        regArgs,
        NULL,
        NULL
        );

    //
    // Done
    //
    return (STATUS_SUCCESS);
}



//
// UnRegister to receive accesses to the specified operation region
//
NTSTATUS
UnRegisterOperationRegionHandler  (
    IN PNSOBJ   RegionParent,
    IN PVOID    OperationRegionObject
    )
{
    NTSTATUS            status;
    OBJDATA             regArgs[2];
    PNSOBJ              regObject;
    POPREGIONHANDLER    HandlerNode = (POPREGIONHANDLER) OperationRegionObject;

    PAGED_CODE();

    //
    // Is there a _REG method that we should run?
    //
    if ( RegionParent != NULL ) {

        status = AMLIGetNameSpaceObject(
            "_REG",
            RegionParent,
            &regObject,
            NSF_LOCAL_SCOPE
            );
        if ( NT_SUCCESS(status) ) {

            //
            // Initialize the parameters
            //
            RtlZeroMemory( regArgs, sizeof(OBJDATA) * 2 );
            regArgs[0].dwDataType = OBJTYPE_INTDATA;
            regArgs[0].uipDataValue = HandlerNode->RegionSpace;
            regArgs[1].dwDataType = OBJTYPE_INTDATA;
            regArgs[1].uipDataValue = 0;

            //
            // Eval the request. We don't care what it returns, but we must do
            // it synchronously
            //
            AMLIEvalNameSpaceObject(
                regObject,
                NULL,
                2,
                regArgs
                );

        }

    }

    //
    // Call interpreter with null handler to remove the handler for this access/region
    //
    status = AMLIRegEventHandler(
        HandlerNode->AccessType,
        HandlerNode->RegionSpace,
        NULL,
        0
        );
    if ( AMLIERR(status) != AMLIERR_NONE ) {

        return (STATUS_UNSUCCESSFUL);

    }

    //
    // Cleanup
    //
    ExFreePool (HandlerNode);
    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpipriv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpipriv.h

Abstract:

    Internal definitions and structures for ACPI

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _ACPIPRIV_H_
#define _ACPIPRIV_H_

    //
    // This structure lets us know the state of one entry in the RSDT
    //
    typedef struct {

        //
        // Flags that indicate what options apply to this element
        //
        ULONG   Flags;

        //
        // The handle, if we need to unload
        //
        HANDLE  Handle;

        //
        // The address, if we need to unmap
        //
        PVOID   Address;

    } RSDTELEMENT, *PRSDTELEMENT;

    #define RSDTELEMENT_MAPPED      0x1
    #define RSDTELEMENT_LOADED      0x2
    #define RSDTELEMENT_LOADABLE    0x4
    #define RSDTELEMENT_OVERRIDEN   0x8

    //
    // This structure corresponds to the number of elements within the
    // RSDT. For each entry in the RSDT, there is a corresponding entry
    // here.
    //
    typedef struct _RSDTINFORMATION {

        //
        // How many elements are there in the table?
        //
        ULONG       NumElements;

        //
        // The table
        //
        RSDTELEMENT Tables[1];

    } RSDTINFORMATION, *PRSDTINFORMATION;

    typedef struct _DDBINFORMATION  {

        BOOLEAN DSDTNeedsUnload;
        BOOLEAN SSDTNeedsUnload;
        BOOLEAN PSDTNeedsUnload;
        HANDLE  DSDT;
        HANDLE  SSDT;
        HANDLE  PSDT;

    } DDBINFORMATION;


    //
    // ACPIInformation is a global structure which contains frequently needed
    // addresses and flags.  Filled in at initializtion time.
    //
    typedef struct _ACPIInformation {

        //
        // Linear address of Root System Description Table
        //
        PRSDT   RootSystemDescTable;

        //
        // Linear address of Fixed ACPI Description Table
        //
        PFADT FixedACPIDescTable;

        //
        // Linear address of the FACS
        //
        PFACS FirmwareACPIControlStructure;

        //
        // Linear address of Differentiated System Description Table
        //
        PDSDT   DiffSystemDescTable;

        //
        // Linear address of Mulitple APIC table
        //
        PMAPIC  MultipleApicTable;

        //
        // Linear address of GlobalLock ULONG_PTR (contained within Firmware ACPI control structure)
        //
        PULONG  GlobalLock;

        //
        // Queue used for waiting on release of the Global Lock.  Also, queue
        // lock and owner info.
        //
        LIST_ENTRY      GlobalLockQueue;
        KSPIN_LOCK      GlobalLockQueueLock;
        PVOID           GlobalLockOwnerContext;
        ULONG           GlobalLockOwnerDepth;

        //
        // Did we find SCI_EN set when we loaded ?
        //
        BOOLEAN ACPIOnly;

        //
        // I/O address of PM1a_BLK
        //
        ULONG_PTR   PM1a_BLK;

        //
        // I/O address of PM1b_BLK
        //
        ULONG_PTR   PM1b_BLK;

        //
        // I/O address of PM1a_CNT_BLK
        //
        ULONG_PTR   PM1a_CTRL_BLK;

        //
        // I/O address of PM1b_CNT_BLK
        //
        ULONG_PTR   PM1b_CTRL_BLK;

        //
        // I/O address of PM2_CNT_BLK
        //
        ULONG_PTR   PM2_CTRL_BLK;

        //
        // I/O address of PM_TMR
        //
        ULONG_PTR   PM_TMR;
        ULONG_PTR   GP0_BLK;
        ULONG_PTR   GP0_ENABLE;

        //
        // Length of GP0 register block (Total, status+enable regs)
        //
        UCHAR   GP0_LEN;

        //
        // Number of GP0 logical registers
        //
        USHORT  Gpe0Size;
        ULONG_PTR   GP1_BLK;
        ULONG_PTR   GP1_ENABLE;

        //
        // Length of GP1 register block
        //
        UCHAR   GP1_LEN;

        //
        // Number of GP1 logical registers
        //
        USHORT  Gpe1Size;
        USHORT  GP1_Base_Index;

        //
        // Total number of GPE logical registers
        //
        USHORT  GpeSize;

        //
        // I/O address of SMI_CMD
        //
        ULONG_PTR SMI_CMD;

        //
        // Bit mask of enabled PM1 events.
        //
        USHORT  pm1_en_bits;
        USHORT  pm1_wake_mask;
        USHORT  pm1_wake_status;
        USHORT  c2_latency;
        USHORT  c3_latency;

        //
        // see below for bit descriptions.
        //
        ULONG   ACPI_Flags;
        ULONG   ACPI_Capabilities;

        BOOLEAN Dockable;

    } ACPIInformation, *PACPIInformation;

    //
    // Value if GP1 is not supported
    //
    #define GP1_NOT_SUPPORTED       (USHORT) 0xFFFF

    //
    // descriptions of bits in ACPIInformation.ACPI_Flags
    //
    #define C2_SUPPORTED_BIT        3
    #define C2_SUPPORTED            (1 << C2_SUPPORTED_BIT)

    #define C3_SUPPORTED_BIT        4
    #define C3_SUPPORTED            (1 << C3_SUPPORTED_BIT)

    #define C3_PREFERRED_BIT        5
    #define C3_PREFERRED            (1 << C3_PREFERRED_BIT)

    //
    // descriptions of bits in ACPIInformation.ACPI_Capabilities
    //
    #define CSTATE_C1_BIT           4
    #define CSTATE_C1               (1 << CSTATE_C1_BIT)

    #define CSTATE_C2_BIT           5
    #define CSTATE_C2               (1 << CSTATE_C2_BIT)

    #define CSTATE_C3_BIT           6
    #define CSTATE_C3               (1 << CSTATE_C3_BIT)

    //
    // Define some useful pooltags
    //
    #define ACPI_SHARED_GPE_POOLTAG         'gpcA'
    #define ACPI_SHARED_INFORMATION_POOLTAG 'ipcA'
    #define ACPI_SHARED_TABLE_POOLTAG       'tpcA'

    //
    // Define how many processors we support...
    //
    #define ACPI_SUPPORTED_PROCESSORS   (sizeof(KAFFINITY) * 8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpiterm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiterm.h

Abstract:

    This module is the header for acpiterm.c

Author:

Environment:

    NT Kernel Mode Driver Only

--*/

#ifndef _ACPITERM_H_
#define _ACPITERM_H_

    VOID
    ACPICleanUp(
        VOID
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\loaddsdt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loaddsdt.c

Abstract:

    This handles loading the DSDT table and all steps leading up to it

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    02-Jun-97   Initial Revision

--*/

#ifndef _LOADDSDT_H_
#define _LOADDSDT_H_

    PRSDT
    ACPILoadFindRSDT(
        VOID
        );

    NTSTATUS
    ACPILoadProcessDSDT(
        ULONG_PTR   Address
        );

    NTSTATUS
    ACPILoadProcessFADT(
        PFADT       Fadt
        );

    NTSTATUS
    ACPILoadProcessFACS(
        ULONG_PTR   Address
        );

    NTSTATUS
    ACPILoadProcessRSDT(
        VOID
        );

    BOOLEAN
    ACPILoadTableCheckSum(
        PVOID   StartAddress,
        ULONG   Length
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\reg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reg.c

Abstract:

    These functions access the registry

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    03-Jun-97   Initial Revision

--*/

#include "pch.h"
#include "amlreg.h"
#include <stdio.h>

//
// This controls wether or not the various tables will be dumped to the
// registry
//
UCHAR                   DoAcpiTableDump = 0xFF;

#ifdef ALLOC_PRAGMA
#define alloc_text(PAGE,ACPIRegLocalCopyString)
#define alloc_text(PAGE,ACPIRegDumpAcpiTable)
#define alloc_text(PAGE,ACPIRegDumpAcpiTables)
#define alloc_text(PAGE,ACPIRegReadEntireAcpiTable)
#define alloc_text(PAGE,ACPIRegReadAMLRegistryEntry)
#endif


PUCHAR
ACPIRegLocalCopyString (
    PUCHAR  Destination,
    PUCHAR  Source,
    ULONG   MaxLength
    )
/*++

Routine Description:

    A little routine to copy short strings, since using sprintf here is
    like hitting a tack with a sledgehammer.  Terminates when a null or
    the max length is reached, whichever comes first.  Translates blanks
    to underscores, since everyone hates blanks embedded in registry keys.

Arguments:

    Destination     - Where to copy the string to
    Source          - Source string pointer
    MaxLength       - Max number of bytes to copy

Return Value:

    Returns the destination pointer incremented past the copied string

__*/
{
    ULONG               i;


    for (i = 0; i < MaxLength; i++) {

        if (Source[i] == 0) {
            break;

        } else if (Source[i] == ' ') {        // Translate blanks to underscores
            Destination [i] = '_';

        } else {
            Destination [i] = Source[i];
        }
    }

    Destination [i] = 0;
    return (Destination + i);
}

BOOLEAN
ACPIRegReadAMLRegistryEntry(
    IN  PVOID   *Table,
    IN  BOOLEAN MemoryMapped
    )
/*++

Routine Description:

    This reads a table from the registry

Arguments:

    Table   - Where to store the pointer to the table. If non-null, this
              contains a pointer to where the Original Table is stored
    MemorMapped - Indicates wether or not the table is memory mapped and should
              be unmapped once we are done with it

Return Value:

    TRUE - Success
    FALSE - Failure

__*/
{
    BOOLEAN             rc          = FALSE;
    HANDLE              revisionKey = NULL;
    HANDLE              tableIdKey  = NULL;
    NTSTATUS            status;
    PDESCRIPTION_HEADER header      = (PDESCRIPTION_HEADER) *Table;
    PUCHAR              key         = NULL; // ACPI_PARAMETERS_REGISTRY_KEY;
    PUCHAR              buffer;
    ULONG               action;
    ULONG               bytesRead;
    ULONG               baseSize;
    ULONG               totalSize;

    PAGED_CODE();

    //
    // Build a full path name to the thing we want in the registry
    //
    baseSize = strlen( ACPI_PARAMETERS_REGISTRY_KEY);
    totalSize = baseSize + ACPI_MAX_TABLE_STRINGS + 4;

    buffer = key = ExAllocatePool( PagedPool, totalSize );
    if (key == NULL) {

        return FALSE;

    }

    //
    // Generate the path name to the key. This avoids a costly sprintf
    //
    RtlZeroMemory( buffer, totalSize );
    RtlCopyMemory(
        buffer,
        ACPI_PARAMETERS_REGISTRY_KEY,
        baseSize
        );
    buffer += baseSize;
    *buffer++ = '\\';

    //
    // Table Signature (Up to 4 byte string)
    //
    buffer = ACPIRegLocalCopyString (buffer, (PUCHAR) &header->Signature, ACPI_MAX_SIGNATURE);
    *buffer++ = '\\';

    //
    // OEM ID field (Up to 6 byte string)
    //
    buffer = ACPIRegLocalCopyString (buffer, (PUCHAR) &header->OEMID, ACPI_MAX_OEM_ID);
    *buffer++ = '\\';

    //
    // OEM Table ID field (Up to 8 byte string)
    //
    buffer = ACPIRegLocalCopyString (buffer, (PUCHAR) &header->OEMTableID, ACPI_MAX_TABLE_ID);
    *buffer = 0;        // Terminate

    ACPIPrint ((
        ACPI_PRINT_REGISTRY,
        "ReadAMLRegistryEntry: opening key: %s\n",
        key));

    //
    // Open the <TableId>/OemId>/<OemTableId> key
    //
    status = OSOpenHandle(key, NULL, &tableIdKey);
    if ( !NT_SUCCESS(status) ) {

        ACPIPrint ((
            ACPI_PRINT_WARNING,
            "ReadAMLRegistryEntry: failed to open AML registry entry (rc=%x)\n",
            status));
        goto ReadAMLRegistryEntryExit;

    }

    //
    // Find the largest subkey that is equal or greater than the ROM
    // BIOS version of the table
    //
    status = OSOpenLargestSubkey(
        tableIdKey,
        &revisionKey,
        header->OEMRevision
        );
    if (!NT_SUCCESS(status)) {

       ACPIPrint ((
           ACPI_PRINT_WARNING,
           "ReadAMLRegistryEntry: no valid <OemRevision> key (rc=%#08lx)\n",
           status));
        goto ReadAMLRegistryEntryExit;

    }

    //
    // Get the Action value for this table, which tells us what to do with
    // the table
    //
    bytesRead = sizeof(action);
    status = OSReadRegValue(
        "Action",
        revisionKey,
        &action,
        &bytesRead
        );
    if (!NT_SUCCESS(status) || bytesRead != sizeof(action)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ReadAMLRegistryEntry: read action value = %#08lx. BytesRead=%d\n",
            status, bytesRead
            ) );
        action = ACTION_LOAD_TABLE; // Default action

    }

    //
    // Do the action
    //
    switch (action) {
    case ACTION_LOAD_TABLE:
        //
        // Overload entire ROM table
        //
        status = ACPIRegReadEntireAcpiTable(revisionKey, Table, MemoryMapped);
        if (NT_SUCCESS( status ) ) {

            rc = TRUE;

        }
        break;

    case ACTION_LOAD_ROM:
    case ACTION_LOAD_NOTHING:
        //
        // Nothing to do for these cases (return FALSE however);
        //
        break;

    default:
        //
        // Unsupported actions (return FALSE)
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ReadAMLRegistryEntry: Unsupported action value (action=%d)\n",
            action
            ) );
        break;

    }

    //
    // Always close the open keys
    //
ReadAMLRegistryEntryExit:
    if (key != NULL) {

        ExFreePool( key );

    }
    if (tableIdKey != NULL) {

        OSCloseHandle( tableIdKey );

    }
    if (revisionKey != NULL) {

        OSCloseHandle( revisionKey );


    }
    return rc;
}

NTSTATUS
ACPIRegReadEntireAcpiTable (
    IN  HANDLE  RevisionKey,
    IN  PVOID   *Table,
    IN  BOOLEAN MemoryMapped
    )
/*++

Routine Description:

    Reads the table from the registry into memory

Arguments:

    RevisionKey   - Handle to the key containing the table
    Table         - Pointer to the pointer to the table
    MemorymMapped - If True, indicates that we need to MmUnmapIo the table
                    otherwise, if False, we do no free the table (the
                    memory is static)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PUCHAR                  buffer;
    PVOID                   table;
    UCHAR                   value[9];
    ULONG                   bytesRead;
    ULONG                   index = 0;
    ULONG                   entry;
    PREGISTRY_HEADER        entryHeader;
    PDESCRIPTION_HEADER     descHeader = (PDESCRIPTION_HEADER) *Table;

    PAGED_CODE();

    //
    // We need an 8k buffer
    //
    buffer = ExAllocatePool( PagedPool, 8 * 1024 );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Repeat this forever
    //
    for (index = 0; ;index++) {

        //
        // This is the first data value
        //
        sprintf(value, "%08lx", index );

        //
        // Read the entry header to get the size of the table. This is stored
        // before the actual table
        //
        bytesRead = 8 * 1024;
        status = OSReadRegValue(
            value,
            RevisionKey,
            buffer,
            &bytesRead
            );
        if (!NT_SUCCESS(status) ) {

            //
            // Not being able to read the table isn't a failure case
            //
            status = STATUS_SUCCESS;
            break;

        } else if (bytesRead < sizeof(REGISTRY_HEADER) ) {

            //
            // Not being to read the proper number of bytes is
            //
            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ReadEntireAcpiTable: read registry header (bytes=%d)\n",
                bytesRead
                ) );
            return STATUS_UNSUCCESSFUL;

        }

        //
        // Loop while we still have bytes to process
        //
        for (entry = 0;
             entry < bytesRead;
             entry += (entryHeader->Length + sizeof(REGISTRY_HEADER) )
            ) {

            //
            // Grab a pointer to the entry record
            //
            entryHeader = (PREGISTRY_HEADER) &(buffer[entry]);

            //
            // Crack the record
            //
            if (entryHeader->Length == 0) {

                //
                // Special Case
                //
                if (entryHeader->Offset != descHeader->Length) {

                    //
                    // Must change the table size
                    //
                    table = ExAllocatePoolWithTag(
                        NonPagedPool,
                        entryHeader->Offset,
                        ACPI_SHARED_TABLE_POOLTAG
                        );
                    if (table == NULL) {

                        ExFreePool( buffer );
                        return STATUS_INSUFFICIENT_RESOURCES;

                    }

                    //
                    // How much do we have to copy?
                    //
                    RtlCopyMemory(
                        table,
                        *Table,
                        min( entryHeader->Offset, descHeader->Length )
                        );

                    //
                    // Free the old table based on wether or not its mm mapped
                    //
                    if (MemoryMapped) {

                        MmUnmapIoSpace(*Table, descHeader->Length);

                    } else {

                        ExFreePool( *Table );

                    }

                    //
                    // Remember the address of the new table
                    //
                    descHeader = (PDESCRIPTION_HEADER) *Table = table;

                }

                //
                // Done with this record
                //
                continue;

            }

            //
            // Patch the memory
            //
            ASSERT( entryHeader->Offset < descHeader->Length );
            RtlCopyMemory(
                ( (PUCHAR) *Table) + entryHeader->Offset,
                (PUCHAR) entryHeader + sizeof( REGISTRY_HEADER ),
                entryHeader->Length
                );
        }
    }

    //
    // Normal exit
    //
    if (buffer != NULL) {

        ExFreePool( buffer );
    }
    return status;

}

/****************************************************************************
 *
 *      DumpAcpiTable
 *              Write an ACPI Table to the registry
 *
 *      Not exported.
 *
 *      ENTRY:  pszName     - Name of the table to write (4 byte string)
 *              Table       - Pointer to table data
 *              Length      - of the table
 *              Header      - Pointer to the table header
 *
 *      EXIT:   NONE
 *
 ***************************************************************************/
VOID
ACPIRegDumpAcpiTable (
    PSZ                 pszName,
    PVOID               Table,
    ULONG               Length,
    PDESCRIPTION_HEADER Header
    )
{
    //NTSTATUS            status;
    UCHAR               buffer [80] = "\\Registry\\Machine\\Hardware\\ACPI";
    HANDLE              hSubKey;
    HANDLE              hPrefixKey;

    PAGED_CODE();

    //
    // Create /Registry/Machine/Hardware/ACPI subkey
    //
    if ( !NT_SUCCESS(OSCreateHandle (buffer, NULL, &hPrefixKey) ) ) {
        return;
    }

    //
    // Create table name subkey (DSDT, FACP, FACS, or RSDT) - 4 bytes
    //
    if ( !NT_SUCCESS(OSCreateHandle (pszName, hPrefixKey, &hSubKey) ) ) {
        goto DumpAcpiTableExit;
    }

    //
    // For tables with headers, add subkeys for
    // <OemId>/<OemTableID>/<OemRevision>
    //
    if (Header) {

        OSCloseHandle(hPrefixKey);
        hPrefixKey = hSubKey;

        //
        // OEM ID field (6 byte string)
        //
        ACPIRegLocalCopyString (buffer, Header->OEMID, ACPI_MAX_OEM_ID);
        if ( !NT_SUCCESS(OSCreateHandle (buffer, hPrefixKey, &hSubKey) ) ) {
            goto DumpAcpiTableExit;
        }

        OSCloseHandle (hPrefixKey);
        hPrefixKey = hSubKey;

        //
        // OEM Table ID field (8 byte string)
        //
        ACPIRegLocalCopyString (buffer, Header->OEMTableID, ACPI_MAX_TABLE_ID);
        if ( !NT_SUCCESS(OSCreateHandle (buffer, hPrefixKey, &hSubKey) ) ) {
            goto DumpAcpiTableExit;
        }

        OSCloseHandle (hPrefixKey);
        hPrefixKey = hSubKey;

        //
        // OEM Revision field  (4 byte number)
        //
        sprintf (buffer, "%.8x", Header->OEMRevision);
        if ( !NT_SUCCESS(OSCreateHandle (buffer, hPrefixKey, &hSubKey) ) ) {
            goto DumpAcpiTableExit;
        }
    }

    //
    // Finally, write the entire table
    //
    OSWriteRegValue ("00000000", hSubKey, Table, Length);

    //
    // Delete open handles
    //
    OSCloseHandle (hSubKey);
DumpAcpiTableExit:
    OSCloseHandle (hPrefixKey);

    return;
}


/****************************************************************************
 *
 *      DumpAcpiTables
 *              Write the ACPI Tables to the registry.  Should be called only
 *              after table pointers have been initialized.
 *
 *      Not exported.
 *
 *      ENTRY:  NONE
 *      EXIT:   NONE.
 *
 ***************************************************************************/
VOID
ACPIRegDumpAcpiTables (VOID)
{
    PDSDT       dsdt = AcpiInformation->DiffSystemDescTable;
    PFACS       facs = AcpiInformation->FirmwareACPIControlStructure;
    PFADT       fadt = AcpiInformation->FixedACPIDescTable;
    PRSDT       rsdt = AcpiInformation->RootSystemDescTable;


    if (DoAcpiTableDump) {

        ACPIPrint ((
            ACPI_PRINT_REGISTRY,
            "DumpAcpiTables: Writing DSDT/FACS/FADT/RSDT to registry\n"));

        if (dsdt) {

            ACPIRegDumpAcpiTable(
                "DSDT",
                dsdt,
                dsdt->Header.Length,
                &(dsdt->Header)
                );

        }

        if (facs) {

            ACPIRegDumpAcpiTable(
                "FACS",
                facs,
                facs->Length,
                NULL
                );

        }

        if (fadt) {

            ACPIRegDumpAcpiTable(
                "FADT",
                fadt,
                fadt->Header.Length,
                &(fadt->Header)
                );

        }

        if (rsdt) {

            ACPIRegDumpAcpiTable(
                "RSDT",
                rsdt,
                rsdt->Header.Length,
                &(rsdt->Header)
                );

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\reg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reg.h

Abstract:

    These functions access the registry

Author:

    Jason Clark (jasoncl)
    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    03-Jun-97   Initial Revision

--*/

#ifndef _REG_H_
#define _REG_H_

    PUCHAR
    ACPIRegLocalCopyString(
        IN  PUCHAR  Destination,
        IN  PUCHAR  Source,
        IN  ULONG   MaxLength
        );

    VOID
    ACPIRegDumpAcpiTable (
        PSZ                     pszName,
        PVOID                   Table,
        ULONG                   Length,
        PDESCRIPTION_HEADER     Header
        );

    VOID
    ACPIRegDumpAcpiTables(
        VOID
        );

    NTSTATUS
    ACPIRegReadEntireAcpiTable (
        IN  HANDLE  RevisionKey,
        IN  PVOID   *Table,
        IN  BOOLEAN MemoryMapped
        );

    BOOLEAN
    ACPIRegReadAMLRegistryEntry(
        IN  PVOID   *Table,
        IN  BOOLEAN Memorymapped
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI NT subtree

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#include <stdarg.h>
#include <stdio.h>
#include <ntos.h>
#include <pci.h>
#include <dockintf.h>

#ifndef SPEC_VER
    #define SPEC_VER 100
#endif

#ifndef FAR
    #define FAR
#endif

#include <poclass.h>
#include <wdmguid.h>
#include <zwapi.h>
#include <ntpoapi.h>

#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

//
// Interaces with the HAL
//
#include <ntacpi.h>

//
// These are the global include files for this project
//
#include "acpitabl.h"
#include "amli.h"
#include "aml.h"
#include "amlreg.h"
#include "hctioctl.h"
#include <devioctl.h>
#include "acpios.h"
#include "ospower.h"
#include "acpiregs.h"
#include <acpi.h>
#include <acpidbg.h>
#include <arbiter.h>
#include "strlib.h"

#include "acpierr.h"
#include "acpibs.h"
#include "acpipriv.h"
#include "acpiioct.h"
#include "acpimsft.h"

#include "acpienbl.h"
#include "acpictl.h"
#include "acpigpio.h"
#include "acpiinit.h"
#include "acpiio.h"
#include "acpilock.h"
#include "acpintfy.h"
#include "acpioprg.h"
#include "acpisi.h"
#include "acpiterm.h"
#include "loaddsdt.h"
#include "reg.h"

//
// Interfaces from the NT part of the driver
//
#include "acpiirp.h"
#include "acpilog.h"
#include "acpiosnt.h"
#include "amlisupp.h"
#include "acpidock.h"
#include "buildsrc.h"
#include "bus.h"
#include "button.h"
#include "cmbutton.h"
#include "dat.h"
#include "debug.h"
#include "detect.h"
#include "devpower.h"
#include "dispatch.h"
#include "errlog.h"
#include "extlist.h"
#include "filter.h"
#include "get.h"
#include "gpe.h"
#include "idevice.h"
#include "init.h"
#include "interfaces.h"
#include "internal.h"
#include "interupt.h"
#include "irqarb.h"
#include "msi.h"
#include "match.h"
#include "osnotify.h"
#include "pciopregion.h"
#include "rangesup.h"
#include "res_bios.h"
#include "res_cm.h"
#include "root.h"
#include "rtl.h"
#include "syspower.h"
#include "thermal.h"
#include "vector.h"
#include "wake.h"
#include "worker.h"

#ifdef ExAllocatePool
    #undef ExAllocatePool
#endif
#define ExAllocatePool(p,s) ExAllocatePoolWithTag(p,s,'ScpA')
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\eclowio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eclowio.c

Abstract:

    Interface module to ACPI driver functions.  It encapsulates the grungy Irp details.

Author:

    Bob Moore (Intel)

Environment:

Notes:


Revision History:

    00-Feb-15 [vincentg] - modified to use oprghdlr.sys to register/deregister
                           op region handler

--*/

#include "ecp.h"
#include "oprghdlr.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcpiEcGetAcpiInterfaces)
#pragma alloc_text(PAGE, AcpiEcGetGpeVector)
#pragma alloc_text(PAGE, AcpiEcInstallOpRegionHandler)
#pragma alloc_text(PAGE, AcpiEcRemoveOpRegionHandler)
#endif

NTSTATUS
AcpiEcGetAcpiInterfaces (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    KEVENT              event;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    //
    // Initialize an event to block on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build an irp
    //
    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        EcData->LowerDeviceObject,
        NULL,
        0,
        NULL,
        &event,
        &ioStatus
        );

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Get the the current irp location
    //
    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Use QUERY_INTERFACE to get the address of the direct-call
    // ACPI interfaces.
    //
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    irpSp->Parameters.QueryInterface.Version                = 1;
    irpSp->Parameters.QueryInterface.Size                   = sizeof (AcpiInterfaces);
    irpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) &AcpiInterfaces;
    irpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

    //
    // send the request down
    //
    status = IoCallDriver( EcData->LowerDeviceObject, irp );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
        status = ioStatus.Status;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
AcpiEcGetGpeVector (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Run the _GPE method (Under the EC device in the namespace) to get the
    GPE vector assigned to the EC.

    Note: This routine is called at PASSIVE_LEVEL

Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;

    PAGED_CODE();

    //
    // Initialize the event
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Initialize the input buffer
    //
    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = CM_GPE_METHOD;

    //
    // Initialize the output buffer
    //
    RtlZeroMemory( &outputBuffer, sizeof(ACPI_EVAL_OUTPUT_BUFFER ) );

    //
    // Initialize an IRP
    //
    irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_EVAL_METHOD,
        EcData->LowerDeviceObject,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        &outputBuffer,
        sizeof(ACPI_EVAL_OUTPUT_BUFFER),
        FALSE,
        &event,
        &ioStatus
        );

    //
    // Irp initialization failed?
    //
    if (!irp) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Send to ACPI driver
    //
    status = IoCallDriver (EcData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //
        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );

        //
        // Get the real status
        //
        status = ioStatus.Status;

    }

    //
    // Did we fail the request?
    //
    if (!NT_SUCCESS(status)) {

        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Sanity checks
    //
    ASSERT( ioStatus.Information >= sizeof(ACPI_EVAL_OUTPUT_BUFFER) );
    if (ioStatus.Information < sizeof(ACPI_EVAL_OUTPUT_BUFFER) ||
        outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer.Count == 0) {

        status = STATUS_UNSUCCESSFUL;
        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Crack the result
    //
    argument = &(outputBuffer.Argument[0]);

    //
    // We are expecting an integer
    //
    if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        status = STATUS_ACPI_INVALID_DATA;
        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Get the value
    //
    EcData->GpeVector  = (UCHAR) argument->Argument;

AcpiEcGetGpeVectorExit:

    //
    // Done
    //
    return status;
}

NTSTATUS
AcpiEcConnectGpeVector (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to connect the EC driver to a GPE vector


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{

    return (AcpiInterfaces.GpeConnectVector (
                AcpiInterfaces.Context,
                EcData->GpeVector,
                Latched,                            // Edge triggered
                FALSE,                              // Can't be shared
                AcpiEcGpeServiceRoutine,
                EcData,
                &EcData->GpeVectorObject));

}

NTSTATUS
AcpiEcDisconnectGpeVector (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to disconnect the EC driver from a GPE vector.  Called
    from device unload, stop.


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    NTSTATUS        status;

    if (EcData->GpeVectorObject) {

        status = AcpiInterfaces.GpeDisconnectVector (EcData->GpeVectorObject);
        EcData->GpeVectorObject = NULL;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;

}

NTSTATUS
AcpiEcInstallOpRegionHandler(
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to install the EC driver operation region handler


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE ();

    status = RegisterOpRegionHandler (EcData->LowerDeviceObject,
                                      ACPI_OPREGION_ACCESS_AS_COOKED,
                                      ACPI_OPREGION_REGION_SPACE_EC,
                                      (PACPI_OP_REGION_HANDLER) AcpiEcOpRegionHandler,
                                      EcData,
                                      0,
                                      &EcData->OperationRegionObject);
    return status;
}

NTSTATUS
AcpiEcRemoveOpRegionHandler (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to remove the EC driver operation region handler.
    Called from device unload, stop.


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE ();

    status = DeRegisterOpRegionHandler (EcData->LowerDeviceObject,
                                        EcData->OperationRegionObject);


    return status;
}

NTSTATUS
AcpiEcForwardIrpAndWait (
    IN PECDATA          EcData,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Utility routine to send an irp down, and wait for the result.


Arguments:

    EcData          - Pointer to the EC driver device extension
    Irp             - Irp to send and complete

Return Value:

    Status is returned.

--*/
{
    KEVENT              pdoStartedEvent;
    NTSTATUS            status;


    KeInitializeEvent (&pdoStartedEvent, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp, AcpiEcIoCompletion, &pdoStartedEvent,
                            TRUE, TRUE, TRUE);

    //
    // Always wait for the completion routine
    //

    status = IoCallDriver (EcData->LowerDeviceObject, Irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject (&pdoStartedEvent, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\loaddsdt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loaddsdt.c

Abstract:

    This handles loading the DSDT table and all steps leading up to it

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    02-Jun-97   Initial Revision

--*/

#include "pch.h"
#include "amlreg.h"
#include <stdio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPILoadFindRSDT)
#pragma alloc_text(PAGE,ACPILoadProcessDSDT)
#pragma alloc_text(PAGE,ACPILoadProcessFADT)
#pragma alloc_text(PAGE,ACPILoadProcessFACS)
#pragma alloc_text(PAGE,ACPILoadProcessRSDT)
#pragma alloc_text(PAGE,ACPILoadTableCheckSum)
#endif

#if DBG
BOOLEAN AcpiLoadSimulatorTable = TRUE;
#else
BOOLEAN AcpiLoadSimulatorTable = FALSE;
#endif


PRSDT
ACPILoadFindRSDT(
    VOID
    )
/*++

Routine Description:

    This routine looks at the registry to find the value stored there by
    ntdetect.com

Arguments:

    None

Return Value:

    Pointer to the RSDT

--*/
{
    NTSTATUS                        status;
    PACPI_BIOS_MULTI_NODE           rsdpMulti;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PHYSICAL_ADDRESS                PhysAddress = {0};
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  keyInfo;
    PRSDT                           rsdtBuffer = NULL;
    PRSDT                           rsdtPointer;
    ULONG                           MemSpace = 0;

    PAGED_CODE();

    //
    // Read the key for that AcpiConfigurationData
    //
    status = OSReadAcpiConfigurationData( &keyInfo );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRSDT: Cannot open Configuration Data - 0x%08lx\n",
            status
            ) );
        ACPIBreakPoint();
        return NULL;

    }

    //
    // Crack the structure
    //
    cmPartialList = (PCM_PARTIAL_RESOURCE_LIST) (keyInfo->Data);
    cmPartialDesc = &(cmPartialList->PartialDescriptors[0]);
    rsdpMulti = (PACPI_BIOS_MULTI_NODE) ( (PUCHAR) cmPartialDesc +
        sizeof(CM_PARTIAL_RESOURCE_LIST) );

    //
    // Read the Header part of the table
    //

    PhysAddress.QuadPart = rsdpMulti->RsdtAddress.QuadPart;
    rsdtPointer = MmMapIoSpace(
        PhysAddress,
        sizeof(DESCRIPTION_HEADER),
        MmCached
        );

    if (rsdtPointer == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRsdt: Cannot Map RSDT Pointer 0x%08lx\n",
            rsdpMulti->RsdtAddress.LowPart
            ) );
        ACPIBreakPoint();
        goto RsdtDone;

    } else if ((rsdtPointer->Header.Signature != RSDT_SIGNATURE) &&
               (rsdtPointer->Header.Signature != XSDT_SIGNATURE)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRsdt: RSDT 0x%08lx has invalid signature\n",
            rsdtPointer
            ) );
        ACPIBreakPoint();
        goto RsdtDone;

    }

    //
    // Read the entire RSDT
    //
    rsdtBuffer = MmMapIoSpace(
        PhysAddress,
        rsdtPointer->Header.Length,
        MmCached
        );

    //
    // Give back a PTE now that we're done with the rsdtPointer.
    //
    MmUnmapIoSpace(rsdtPointer, sizeof(DESCRIPTION_HEADER));

    //
    // did we find the right rsdt buffer?
    //
    if (rsdtBuffer == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRsdt: Cannot Map RSDT Pointer 0x%08lx\n",
            rsdpMulti->RsdtAddress.LowPart
            ) );
        ACPIBreakPoint();
        goto RsdtDone;

    }

RsdtDone:
    //
    // Done with these buffers
    //

    ExFreePool( keyInfo );

    //
    // return the RSDT
    //
    return rsdtBuffer;
}

NTSTATUS
ACPILoadProcessDSDT(
    ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine loads the DSDT (a pointer is stored in the FADT) and forces
    the interpreter to process it

Arguments:

    Address - Where the DSDT is located in memory

Return Value:

    NTSTATUS

--*/
{

    BOOLEAN     foundOverride;
    PDSDT       linAddress;
    ULONG       index;
    ULONG       length;
    ULONG                MemSpace = 0;
    PHYSICAL_ADDRESS     PhysAddress = {0};

    //
    // Map the header in virtual address space to get the length
    //
    PhysAddress.QuadPart = (ULONGLONG) Address;
    linAddress = MmMapIoSpace(
        PhysAddress,
        sizeof(DESCRIPTION_HEADER),
        MmCached
        );
    if (linAddress == NULL) {

        ASSERT (linAddress != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    if ( linAddress->Header.Signature != DSDT_SIGNATURE) {

        //
        // Signature should have matched DSDT but didn't !
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessDSDT: 0x%08lx does not have DSDT signature\n",
            linAddress
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    //
    // Determine the size of the DSDT
    //
    length = linAddress->Header.Length;

    //
    // Now map the whole thing.
    //
    MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));
    linAddress = MmMapIoSpace(
        PhysAddress,
        length,
        MmCached
        );
    if (linAddress == NULL) {

        ASSERT (linAddress != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Look at the RsdtInformation to determine the index of the last
    // element in the table. We know that we can use that space to store
    // the information about this table
    //
    index = RsdtInformation->NumElements;
    if (index == 0) {

        return STATUS_ACPI_NOT_INITIALIZED;

    }
    index--;

    //
    // Try to read the DSDT from the registry
    //
    foundOverride = ACPIRegReadAMLRegistryEntry( &linAddress, TRUE );
    if (foundOverride) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPILoadProcessDSDT: DSDT Overloaded from registry (0x%08lx)\n",
            linAddress
            ) );
        RsdtInformation->Tables[index].Flags |= RSDTELEMENT_OVERRIDEN;

    }

    //
    // Store a pointer to the DSDT
    //
    AcpiInformation->DiffSystemDescTable = linAddress;

    //
    // Remember this address and that we need to unmap it
    //
    RsdtInformation->Tables[index].Flags |=
        (RSDTELEMENT_MAPPED | RSDTELEMENT_LOADABLE);
    RsdtInformation->Tables[index].Address = linAddress;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPILoadProcessFACS(
    ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine handles the FACS

Arguments:

    Address - Where the FACS is located

Return Value:

    None

--*/
{
    PFACS               linAddress;
    ULONG               MemSpace = 0;
    PHYSICAL_ADDRESS    PhysAddress = {0};

    // Note: On Alpha, the FACS is optional.
    //
    // Return if FACS address is not valid.
    //
    if (!Address) {

        return STATUS_SUCCESS;

    }

    //
    // Map the FACS into virtual address space.
    //
    PhysAddress.QuadPart = (ULONGLONG) Address;
    linAddress = MmMapIoSpace(
        PhysAddress,
        sizeof(FACS),
        MmCached
        );
    if (linAddress == NULL) {

        ASSERT (linAddress != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    if (linAddress->Signature != FACS_SIGNATURE) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessFACS: 0x%08lx does not have FACS signature\n",
            linAddress
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    if (linAddress->Length != sizeof(FACS)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessFACS: 0x%08lx does not have correct FACS length\n",
            linAddress
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFACS: FACS located at 0x%8lx\n",
        linAddress
        ) );
    AcpiInformation->FirmwareACPIControlStructure = linAddress;

    //
    // And store the address of the GlobalLock structure that lives within
    // the FACS
    //
    AcpiInformation->GlobalLock = &(ULONG)(linAddress->GlobalLock);
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFACS: Initial GlobalLock state: 0x%8lx\n",
        *(AcpiInformation->GlobalLock)
        ) );

    //
    // At this point, we are successfull
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPILoadProcessFADT(
    PFADT   Fadt
    )
/*++

Routine Description:

    This reads the FADT and stores some useful information in the
    information structure

Arguments:

    Fadt    - Pointer to the Fadt

Return Value:

    None

--*/
{
    KAFFINITY   processors;
    NTSTATUS    status;
    PUCHAR      gpeTable;
    PDSDT       linAddress;
    ULONG       length;
    ULONG       totalSize;
    ULONG                MemSpace = 0;
    PHYSICAL_ADDRESS     PhysAddress = {0};

    PAGED_CODE();

    //
    // This is a 2.0-level FADT.
    //

    //
    // Handle the FACS part of the FADT.  We must do this before the DSDT
    // so that we have the global lock mapped and initialized.
    //
    status = ACPILoadProcessFACS( Fadt->facs );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Store the I/O addresses of PM1a_BLK, PM1b_BLK, PM1a_CNT, PM1b_CNT,
    // PM2_CNT, PM_TMR
    //

    AcpiInformation->PM1a_BLK       = Fadt->pm1a_evt_blk_io_port;
    AcpiInformation->PM1b_BLK       = Fadt->pm1b_evt_blk_io_port;
    AcpiInformation->PM1a_CTRL_BLK  = Fadt->pm1a_ctrl_blk_io_port;
    AcpiInformation->PM1b_CTRL_BLK  = Fadt->pm1b_ctrl_blk_io_port;
    AcpiInformation->PM2_CTRL_BLK   = Fadt->pm2_ctrl_blk_io_port;
    AcpiInformation->PM_TMR         = Fadt->pm_tmr_blk_io_port;
    AcpiInformation->SMI_CMD        = (ULONG_PTR) Fadt->smi_cmd_io_port;

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: PM1a_BLK located at port 0x%08lx\n"
        "ACPILoadProcessFADT: PM1b_BLK located at port 0x%08lx\n",
        AcpiInformation->PM1a_BLK,
        AcpiInformation->PM1b_BLK
        ) );
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: PM1a_CTRL_BLK located at port 0x%08lx\n"
        "ACPILoadProcessFADT: PM1b_CTRL_BLK located at port 0x%08lx\n",
        AcpiInformation->PM1a_CTRL_BLK,
        AcpiInformation->PM1b_CTRL_BLK
        ) );
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: PM2_CTRL_BLK located at port 0x%08lx\n"
        "ACPILoadProcessFADT: PM_TMR located at port 0x%08lx\n",
        AcpiInformation->PM2_CTRL_BLK,
        AcpiInformation->PM_TMR
        ) );

    //
    // Initialize the global GPE tables.
    //
    // If any of the GPn_BLK addresses are 0 leave GPn_LEN at it's initialized
    // value (0). That way later on we only have to check GPn_LEN to determine
    // the existence of a GP register.
    //

    //
    // Assume this is true until we find out otherwise
    //
    AcpiInformation->GP1_Base_Index = GP1_NOT_SUPPORTED;

    //
    // Crack the GP0 block
    //
    AcpiInformation->GP0_BLK = Fadt->gp0_blk_io_port;
    if (AcpiInformation->GP0_BLK != 0) {

        AcpiInformation->GP0_LEN = Fadt->gp0_blk_len;
        ACPISimpleFatalHardwareAssert(
            (Fadt->gp0_blk_len != 0),
            ACPI_I_GP_BLK_LEN_0
            );

    }

    //
    // Crack the GP1 Block
    //
    AcpiInformation->GP1_BLK = Fadt->gp1_blk_io_port;
    if (AcpiInformation->GP1_BLK != 0) {

        AcpiInformation->GP1_LEN = Fadt->gp1_blk_len;
        AcpiInformation->GP1_Base_Index = Fadt->gp1_base;
        ACPISimpleFatalHardwareAssert (
            (Fadt->gp1_blk_len != 0),
            ACPI_I_GP_BLK_LEN_1
            );

    }

    //
    // Compute sizes of the register blocks.  The first half of each block
    // contains status registers, the second half contains the enable registers.
    //
    AcpiInformation->Gpe0Size   = AcpiInformation->GP0_LEN / 2;
    AcpiInformation->Gpe1Size   = AcpiInformation->GP1_LEN / 2;
    AcpiInformation->GpeSize    = AcpiInformation->Gpe0Size +
        AcpiInformation->Gpe1Size;

    //
    // Addresses of the GPE Enable register blocks
    //
    AcpiInformation->GP0_ENABLE = AcpiInformation->GP0_BLK +
        AcpiInformation->Gpe0Size;
    AcpiInformation->GP1_ENABLE = AcpiInformation->GP1_BLK +
        AcpiInformation->Gpe1Size;

    //
    // Create all GPE bookeeping tables with a single allocate
    //
    if (AcpiInformation->GpeSize) {

        totalSize = (AcpiInformation->GpeSize * 12) +   // Twelve Bitmaps
                    (AcpiInformation->GpeSize * 8);     // One bytewide table
        gpeTable = (PUCHAR)ExAllocatePoolWithTag(
            NonPagedPool,
            totalSize,
            ACPI_SHARED_GPE_POOLTAG
            );
        if (gpeTable == NULL) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPILoadProcessFADT: Could not allocate GPE tables, "
                "size = 0x%8lx\n",
                totalSize
                ) );
            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory (gpeTable, totalSize);

        //
        // Setup the table pointers
        //
        GpeEnable           = gpeTable;
        GpeCurEnable        = GpeEnable         + AcpiInformation->GpeSize;
        GpeIsLevel          = GpeCurEnable      + AcpiInformation->GpeSize;
        GpeHandlerType      = GpeIsLevel        + AcpiInformation->GpeSize;
        GpeWakeEnable       = GpeHandlerType    + AcpiInformation->GpeSize;
        GpeWakeHandler      = GpeWakeEnable     + AcpiInformation->GpeSize;
        GpeSpecialHandler   = GpeWakeHandler    + AcpiInformation->GpeSize;
        GpePending          = GpeSpecialHandler + AcpiInformation->GpeSize;
        GpeRunMethod        = GpePending        + AcpiInformation->GpeSize;
        GpeComplete         = GpeRunMethod      + AcpiInformation->GpeSize;
        GpeSavedWakeMask    = GpeComplete       + AcpiInformation->GpeSize;
        GpeSavedWakeStatus  = GpeSavedWakeMask  + AcpiInformation->GpeSize;
        GpeMap              = GpeSavedWakeStatus+ AcpiInformation->GpeSize;

    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: GP0_BLK located at port 0x%08lx length 0x%08lx\n"
        "ACPILoadProcessFADT: GP1_BLK located at port 0x%08lx length 0x%08lx\n"
        "ACPILoadProcessFADT: GP1_Base_Index = 0x%x\n",
        AcpiInformation->GP0_BLK,
        AcpiInformation->GP0_LEN,
        AcpiInformation->GP1_BLK,
        AcpiInformation->GP1_LEN,
        AcpiInformation->GP1_Base_Index
        ) );

    //
    // At this point, we should know enough to be able to turn off and
    // clear all the GPE registers
    //
    ACPIGpeClearRegisters();
    ACPIGpeEnableDisableEvents( FALSE );

    AcpiInformation->ACPI_Flags = 0;
    AcpiInformation->ACPI_Capabilities = 0;

    //
    // Can we dock this machine?
    //
#if defined(_X86_)
    AcpiInformation->Dockable = (Fadt->flags & DCK_CAP) ? TRUE : FALSE;
#endif
    //
    // This code used to be executed from within InitializeAndEnableACPI,
    // however we need to know *while* processing the DSDT what the Enable
    // bits are. To start with, we always want the ACPI timer and GL events
    //
    AcpiInformation->pm1_en_bits = PM1_TMR_EN | PM1_GBL_EN;

    //
    // Is there a control method Power Button? If not, then there a fixed
    // power button
    //

    if ( !(Fadt->flags & PWR_BUTTON_GENERIC) ) {

        AcpiInformation->pm1_en_bits   |= PM1_PWRBTN_EN;
        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Power Button in Fixed Feature Space\n"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Power Button not fixed event or "
            "not present\n"
            ) );

    }

    //
    // Is there a control method Sleep Button? If not, then the fixed button
    // always doubles as a wake button
    //
    if ( !(Fadt->flags & SLEEP_BUTTON_GENERIC) ){

        AcpiInformation->pm1_en_bits |= PM1_SLEEPBTN_EN;
        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Sleep Button in Fixed Feature Space\n"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Sleep Button not fixed event or "
            "not present\n"
            ) );

    }

    //
    // Handle the DSDT part of the FADT. We handle this last because we
    // need to have the FADT fully parsed before we can load the name space
    // tree. A particular example is the Dockable bit you see directly above.
    //
#if defined(_IA64_)
    return ACPILoadProcessDSDT( (ULONG_PTR)Fadt->x_dsdt.QuadPart );
#else
    return ACPILoadProcessDSDT( Fadt->dsdt );
#endif
}

NTSTATUS
ACPILoadProcessRSDT(
    VOID
    )
/*++

Routine Description:

    Called by ACPIInitialize once ACPI has been detected on the machine.
    This walks the tables in the RSDT and fills in the information for the
    global data structure.

    This routine does *NOT* cause the xDSTs to start loading in the
    interpreter

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    //
    // Upon entry acpiinformation->RootSystemDescTable contains the linear
    // address of the RSDT walk through the array of the tables pointed to
    // by the RSDT and for each table (whose type we are familiar with)
    // store the linear base address of the table in the acpiinformation
    // structure
    //
    BOOLEAN             foundOverride   = FALSE;
    BOOLEAN             foundFADT       = FALSE;
    BOOLEAN             usingXSDT       = FALSE;
    PDESCRIPTION_HEADER header;
    PVOID               linAddress;
    ULONG               index;
    ULONG               length;
    ULONG               numTables;
    ULONG               MemSpace = 0;
    PHYSICAL_ADDRESS    PhysAddress = {0};

    PAGED_CODE();

    //
    // Get the number of tables
    //
    if (AcpiInformation->RootSystemDescTable->Header.Signature ==
        XSDT_SIGNATURE) {

        numTables = NumTableEntriesFromXSDTPointer(
             AcpiInformation->RootSystemDescTable
             );
        usingXSDT = TRUE;

    } else {

        numTables = NumTableEntriesFromRSDTPointer(
             AcpiInformation->RootSystemDescTable
             );
    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessRSDT: RSDT contains %u tables\n",
        numTables
        ) );
    if (numTables == 0) {

        return STATUS_ACPI_INVALID_TABLE;

    }

    //
    // Allocate the RSDTINFORMATION to hold an entry for each element
    // in the table.
    //
    // NOTENOTE: We are actually allocating space for numTables + 2
    // in the RSDT information. The reason for this is that the DSDT
    // is actually stored in the FADT, and so it does not have an entry
    // in the RSDT. We always, always store the DSDT as the last entry
    // in the RsdtInformation structure. In the 2nd to last entry we store
    // the dummy header that we use for the ACPI simulator
    //
    length = sizeof(RSDTINFORMATION) + ( (numTables + 1) * sizeof(RSDTELEMENT) );
    RsdtInformation = ExAllocatePoolWithTag(
        NonPagedPool,
        length,
        ACPI_SHARED_TABLE_POOLTAG
        );
    if (RsdtInformation == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( RsdtInformation, length );
    RsdtInformation->NumElements = (numTables + 2);

    //
    // Examine each table entry in the RSDT
    //
    for (index = 0;index < numTables; index++) {

        //
        // RSDT contains an array of physical pointers.
        //

        //
        // Get the linear address of the table
        //
        PhysAddress.QuadPart = usingXSDT ?
            (ULONGLONG) ((PXSDT)AcpiInformation->RootSystemDescTable)->Tables[index].QuadPart :
            (ULONGLONG) AcpiInformation->RootSystemDescTable->Tables[index];
        linAddress = MmMapIoSpace(
            PhysAddress,
            sizeof (DESCRIPTION_HEADER),
            MmCached
            );

        if (linAddress == NULL) {
            ASSERT (linAddress != NULL);
            return STATUS_ACPI_INVALID_TABLE;
        }

        //
        // Is this a known, but unused table?
        //
        header = (PDESCRIPTION_HEADER) linAddress;
        if (header->Signature == SBST_SIGNATURE) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPILoadProcessRSDT: SBST Found at 0x%08lx\n",
                linAddress
                ) );

            MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));

            continue;
        }

        //
        // Is this an unrecognized table?
        //
        if (header->Signature != FADT_SIGNATURE &&
            header->Signature != SSDT_SIGNATURE &&
            header->Signature != PSDT_SIGNATURE &&
            header->Signature != APIC_SIGNATURE) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPILoadProcessRSDT: Unrecognized table signature 0x%08lx\n",
                header->Signature
                ) );

            MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));

            continue;
        }

        //
        // At this point, we know that we need to bring the entire table
        // in. To do that, we need to remember the length
        //
        length = header->Length;

        //
        // map the entire table using the now known length
        //
        MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));
        linAddress = MmMapIoSpace(
            PhysAddress,
            length,
            MmCached
            );
        if (linAddress == NULL) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPILoadProcesRSDT: Could not load table at 0x%08lx\n",
                AcpiInformation->RootSystemDescTable->Tables[index]
                ) );
            return STATUS_ACPI_INVALID_TABLE;

        }

        //
        // Should we override the table?
        //
        foundOverride = ACPIRegReadAMLRegistryEntry( &linAddress, TRUE);
        if (foundOverride) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPILoadProcessRSDT: Table Overloaded from "
                "registry (0x%08lx)\n",
                linAddress
                ) );
            RsdtInformation->Tables[index].Flags |= RSDTELEMENT_OVERRIDEN;

        }

        //
        // Remember this address and that we need to unmap it
        //
        RsdtInformation->Tables[index].Flags |= RSDTELEMENT_MAPPED;
        RsdtInformation->Tables[index].Address = linAddress;

        //
        // Remember the new header
        //
        header = (PDESCRIPTION_HEADER) linAddress;

        //
        // At this point, we only need to do any kind of special processing
        // if the table is the FADT or if it is the MAPIC
        //
        if (header->Signature == FADT_SIGNATURE) {

            //
            // fill in the appropriate field in acpiinformation
            //
            AcpiInformation->FixedACPIDescTable = (PFADT) linAddress;

            //
            // Process the table. This does not cause the interpreter
            // to load anything
            //
            foundFADT = TRUE;
            ACPILoadProcessFADT( AcpiInformation->FixedACPIDescTable );

        } else if (header->Signature == APIC_SIGNATURE) {

            //
            // fill in the appropriate field in acpiinformation
            //
            AcpiInformation->MultipleApicTable = (PMAPIC)linAddress;

        } else {

            //
            // We can only reach this case if the table is one of the
            // xSDT variety. We need to remember that we will eventually
            // need to load it into the interpreter. If we start supporting
            // any more tables, we need to make sure that they don't fall
            // down here unless they really, really are supported
            //
            RsdtInformation->Tables[index].Flags |= RSDTELEMENT_LOADABLE;

        }

    }

    //
    // At this point, we need to make sure that the ACPI simulator table
    // gets loaded
    //
    header = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(DESCRIPTION_HEADER),
        ACPI_SHARED_TABLE_POOLTAG
        );
    if (header) {

        //
        // Initialize the header so that it can be passed into the overload
        // engine
        //
        RtlZeroMemory( header, sizeof(DESCRIPTION_HEADER) );
        header->Signature   = SSDT_SIGNATURE;
        header->Length      = sizeof(DESCRIPTION_HEADER),
        header->Revision    = 1;
        header->Checksum    = 0;
        header->OEMRevision = 1;
        header->CreatorRev  = 1;
        RtlCopyMemory( header->OEMID, "MSFT", 4 );
        RtlCopyMemory( header->OEMTableID, "simulatr", 8);
        RtlCopyMemory( header->CreatorID, "MSFT", 4);

        //
        // Should we override the table?
        //
        if (AcpiLoadSimulatorTable) {

            foundOverride = ACPIRegReadAMLRegistryEntry( &header, FALSE);

        }
        if (foundOverride) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPILoadProcessRSDT: Simulator Table Overloaded from "
                "registry (0x%08lx)\n",
                linAddress
                ) );

            //
            // Remember this address and that we need to unmap it
            //
            RsdtInformation->Tables[numTables].Flags   |= RSDTELEMENT_MAPPED;
            RsdtInformation->Tables[numTables].Flags   |= RSDTELEMENT_OVERRIDEN;
            RsdtInformation->Tables[numTables].Flags   |= RSDTELEMENT_LOADABLE;
            RsdtInformation->Tables[numTables].Address  = header;

        } else {

            //
            // If we have found an override, we don't need the dummy table
            //
            ExFreePool( header );

        }

    }
    //
    // Save whatever tables we found in the registry
    //
    ACPIRegDumpAcpiTables ();

    //
    // Did we find an FADT?
    //
    if (!foundFADT) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessRSDT: Did not find an FADT\n"
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    return STATUS_SUCCESS;
}

BOOLEAN
ACPILoadTableCheckSum(
    PVOID   StartAddress,
    ULONG   Length
    )
{
    PUCHAR  currentAddress;
    UCHAR   sum = 0;
    ULONG   i;

    PAGED_CODE();
    ASSERT (Length > 0);

    currentAddress = (PUCHAR)StartAddress;

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadTableCheckSum: Checking table 0x%p to 0x%p\n",
        StartAddress, (ULONG_PTR)StartAddress + Length - 1
        ) );

    for (i = 0; i < Length; i++, currentAddress++ ) {

        sum += *currentAddress;

    }

    ACPISimpleSoftwareAssert ( (sum == 0), ACPI_ERROR_INT_BAD_TABLE_CHECKSUM );

    if (sum) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadTableCheckSum: Checksum Failed!, table %p to %p\n",
            StartAddress, (ULONG_PTR) StartAddress + Length - 1
            ) );
        return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\acpiec.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    acpiec.c

Abstract:

    ACPI Embedded Controller Driver

Author:

    Ken Reneris

Environment:

    Kernel mode

Notes:


Revision History:
    13-Feb-97
        PnP/Power support - Bob Moore

--*/

#include "ecp.h"


//
// List of FDOs managed by this driver
//
PDEVICE_OBJECT  FdoList = NULL;

#if DEBUG
ULONG           ECDebug = EC_ERRORS;
#endif


//
// Prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );


NTSTATUS
AcpiEcPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
AcpiEcPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
AcpiEcAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

//
// ReadWrite and PowerDispatch should stay resident
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,AcpiEcUnload)
#pragma alloc_text(PAGE,AcpiEcOpenClose)
#pragma alloc_text(PAGE,AcpiEcInternalControl)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the ACPI Embedded Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.
    RegistryPath - Pointer to the Unicode name of the registry path for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]  = AcpiEcOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = AcpiEcOpenClose;
    DriverObject->MajorFunction[IRP_MJ_READ]    = AcpiEcReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]   = AcpiEcReadWrite;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = AcpiEcPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]     = AcpiEcPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AcpiEcForwardRequest;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = AcpiEcInternalControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AcpiEcForwardRequest;
    DriverObject->DriverExtension->AddDevice    = AcpiEcAddDevice;
    DriverObject->DriverUnload                  = AcpiEcUnload;

    return STATUS_SUCCESS;
}


VOID
AcpiEcUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine unloads the ACPI Embedded Controller Driver
    Note: The driver should be already disconnected from the GPE by this time.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    None.

--*/
{
    PVOID           LockPtr;
    KIRQL           OldIrql;
    PECDATA         EcData;

    EcPrint(EC_LOW, ("AcpiEcUnload: Entering\n" ));

    LockPtr = MmLockPagableCodeSection(AcpiEcUnload);

    while (DriverObject->DeviceObject) {

        EcData = DriverObject->DeviceObject->DeviceExtension;

        //
        // Device can only be active if initialization was completed
        //

        if (EcData->IsStarted) {

            //
            // Set state to determine when unload can occur, and issue a device service
            // call to get it unloaded now of the device is idle
            //

            ASSERT (EcData->DeviceState == EC_DEVICE_WORKING);
            EcData->DeviceState = EC_DEVICE_UNLOAD_PENDING;
            AcpiEcServiceDevice (EcData);

            //
            // Wait for device to cleanup
            //

            while (EcData->DeviceState != EC_DEVICE_UNLOAD_COMPLETE) {
                KeWaitForSingleObject (&EcData->Unload, Suspended, KernelMode, FALSE, NULL);
            }
        }

        //
        // Make sure caller signalling the unload is done
        //

        KeAcquireSpinLock (&EcData->Lock, &OldIrql);
        KeReleaseSpinLock (&EcData->Lock, OldIrql);

        //
        // Free resources
        //

        IoFreeIrp (EcData->QueryRequest);
        IoFreeIrp (EcData->MiscRequest);

        if (EcData->VectorTable) {
            ExFreePool (EcData->VectorTable);
        }

        IoDeleteDevice (EcData->DeviceObject);
    }

    //
    // Done
    //

    MmUnlockPagableImageSection(LockPtr);

    EcPrint(EC_LOW, ("AcpiEcUnload: Driver Unloaded\n"));
}


NTSTATUS
AcpiEcOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}


NTSTATUS
AcpiEcReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for read & write requests.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PECDATA             EcData;
    KIRQL               OldIrql;
    BOOLEAN             StartIo;
    NTSTATUS            Status;
#if DEBUG
    UCHAR               i;
#endif


    Status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = Status;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    EcData = DeviceObject->DeviceExtension;

    //
    // Verify offset is within Embedded Controller range
    //

    if (irpSp->Parameters.Read.ByteOffset.HighPart ||
        irpSp->Parameters.Read.ByteOffset.LowPart > 255 ||
        irpSp->Parameters.Read.ByteOffset.LowPart + irpSp->Parameters.Read.Length > 256) {

        Status = STATUS_END_OF_FILE;
        Irp->IoStatus.Status = Status;

    } else {

        //
        // Queue the transfer up
        //

        KeAcquireSpinLock (&EcData->Lock, &OldIrql);

        if (EcData->DeviceState > EC_DEVICE_UNLOAD_PENDING) {
            //
            // Device is unloading
            //

            Status = STATUS_NO_SUCH_DEVICE;
            Irp->IoStatus.Status = Status;

        } else {

#if DEBUG
            if ((irpSp->MajorFunction == IRP_MJ_WRITE) && (ECDebug & EC_TRANSACTION)) {
                EcPrint (EC_TRANSACTION, ("AcpiEcReadWrite: Write ("));
                for (i=0; i < irpSp->Parameters.Write.Length; i++) {
                    EcPrint (EC_TRANSACTION, ("%02x ", 
                                              ((PUCHAR)Irp->AssociatedIrp.SystemBuffer) [i]));

                }
                EcPrint (EC_TRANSACTION, (") to %02x length %02x\n", 
                                          (UCHAR)irpSp->Parameters.Write.ByteOffset.LowPart,
                                          (UCHAR)irpSp->Parameters.Write.Length));
            }
#endif
            Status = STATUS_PENDING;
            Irp->IoStatus.Status = Status;
            IoMarkIrpPending (Irp);
            InsertTailList (&EcData->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            StartIo = DeviceObject->CurrentIrp == NULL;
            AcpiEcLogAction (EcData, EC_ACTION_QUEUED_IO, StartIo);
        }

        KeReleaseSpinLock (&EcData->Lock, OldIrql);

    }

    //
    // Handle status
    //

    if (Status == STATUS_PENDING) {

        //
        // IO is queued, if device is not busy start it
        //

        if (StartIo) {
            AcpiEcServiceDevice (EcData);
        }

    } else {
        
        //
        // For opregion requests, there is no way to fail the request, so return -1
        //

        RtlFillMemory (Irp->AssociatedIrp.SystemBuffer, irpSp->Parameters.Read.Length, 0xff);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}


NTSTATUS
AcpiEcPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS    status;
    PECDATA     ecData = DeviceObject->DeviceExtension;

    //
    // Start the next power irp
    //
    PoStartNextPowerIrp( Irp );

    //
    // Handle the irp
    //
    if (ecData->LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( ecData->LowerDeviceObject, Irp );

    } else {

        //
        // Complete irp with the current code;
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}


NTSTATUS
AcpiEcInternalControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Internal IOCTL dispatch routine


Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PECDATA             EcData;
    NTSTATUS            Status;

    PAGED_CODE();

    Status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    EcData = DeviceObject->DeviceExtension;

    EcPrint (EC_NOTE, ("AcpiEcInternalControl: dispatch, code = %d\n",
                        IrpSp->Parameters.DeviceIoControl.IoControlCode));

    Status = STATUS_INVALID_PARAMETER;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case EC_CONNECT_QUERY_HANDLER:
            Status = AcpiEcConnectHandler (EcData, Irp);
            break;

        case EC_DISCONNECT_QUERY_HANDLER:
            Status = AcpiEcDisconnectHandler (EcData, Irp);
            break;
    }

    if (Status != STATUS_PENDING) {

        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return Status;

}


NTSTATUS
AcpiEcForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine forwards the irp down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PECDATA     ecData = DeviceObject->DeviceExtension;

    if (ecData->LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( ecData->LowerDeviceObject, Irp );

    } else {

        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\ecp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ecp.h

Abstract:

    Header file for ACPI EC Driver

Author:

Environment:

    NT Kernel Model Driver only

--*/

#include <wdm.h>
#include <ec.h>
#include <devioctl.h>
#include <acpiioct.h>
#include <acpimsft.h>
#include "errlog.h"

//
// Debugging
//
#define DEBUG DBG

#if DEBUG
    extern ULONG            ECDebug;

    #define EcPrint(l,m)    if(l & ECDebug) DbgPrint m
#else
    #define EcPrint(l,m)
#endif

#define EC_LOW          0x00000010
#define EC_NOTE         0x00000001
#define EC_WARN         0x00000002
#define EC_ERROR        0x00000004
#define EC_ERRORS       (EC_ERROR | EC_WARN)
#define EC_HANDLER      0x00000020
#define EC_IO           0x00000040
#define EC_OPREGION     0x00000080
#define EC_QUERY        0x00000200
#define EC_TRACE        0x00000400
#define EC_TRANSACTION  0x00000800

//
// Control methods used by EC
//
#define CM_GPE_METHOD   (ULONG) ('EPG_')    // control method "_GPE"

//
// Misc
//
extern ACPI_INTERFACE_STANDARD     AcpiInterfaces;

#define MAX_QUERY           255
#define BITS_PER_ULONG      (sizeof(ULONG)*8)
#define EVTBITS             ((MAX_QUERY+1)/BITS_PER_ULONG)

extern LARGE_INTEGER        AcpiEcWatchdogTimeout;

//
// Query vector
//
typedef struct {
    UCHAR               Next;
    UCHAR               Vector;
    PVECTOR_HANDLER     Handler;
    PVOID               Context;
} VECTOR_TABLE, *PVECTOR_TABLE;

//
// EC configuration information structure contains information
// about the embedded controller attached and its configuration.
//

typedef struct _ACPIEC_CONFIGURATION_INFORMATION {
    INTERFACE_TYPE                 InterfaceType;
    ULONG                          BusNumber;
    ULONG                          SlotNumber;
    PHYSICAL_ADDRESS               PortAddress;
    USHORT                         PortSize;
    USHORT                         UntranslatedPortAddress;
    CM_PARTIAL_RESOURCE_DESCRIPTOR Interrupt;
    //
    // For PCI-based controllers, indicates the pin number which we need
    // for programming the controller interrupt
    //
    UCHAR                          InterruptPin;
    BOOLEAN                        FloatingSave;
} ACPIEC_CONFIGURATION_INFORMATION, *PACPIEC_CONFIGURATION_INFORMATION;

//
// Definitions for keeping track of the last x actions taken by the EC driver.
//

#define ACPIEC_ACTION_COUNT 0x20
#define ACPIEC_ACTION_COUNT_MASK 0x1f

typedef struct {
    UCHAR               IoStateAction;  // EcData->IoState | EC_ACTION_???? (see definitions below)
    UCHAR               Data;           // Depends on event
    USHORT              Time;           // Delta time of first event of identical events
} ACPIEC_ACTION, *PACPIEC_ACTION;

#define EC_ACTION_MASK          0xf0

#define EC_ACTION_READ_STATUS   0x10
#define EC_ACTION_READ_DATA     0x20
#define EC_ACTION_WRITE_CMD     0x30
#define EC_ACTION_WRITE_DATA    0x40
#define EC_ACTION_INTERRUPT     0x50
#define EC_ACTION_DISABLE_GPE   0x60
#define EC_ACTION_ENABLE_GPE    0x70
#define EC_ACTION_CLEAR_GPE     0x80
#define EC_ACTION_QUEUED_IO     0x90
#define EC_ACTION_REPEATED      0xa0
#define EC_ACTION_MAX           0xb0


//
// ACPI Embedded Control Device object extenstion
//

typedef struct {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      NextFdo;
    PDEVICE_OBJECT      Pdo;                //Pdo corresponding to this fdo
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Static device information
    //

    PUCHAR              DataPort;           // EC Data port
    PUCHAR              StatusPort;         // EC Status port
    PUCHAR              CommandPort;        // EC Command port
    ULONG               MaxBurstStall;      // Max delay for EC reponse in burst mode
    ULONG               MaxNonBurstStall;   // Max delay for EC otherwise
    BOOLEAN             IsStarted;

    //
    // Gpe and Operation Region info
    //

    PVOID               EnableGpe;
    PVOID               DisableGpe;
    PVOID               ClearGpeStatus;
    PVOID               GpeVectorObject;        // Object representing attachment to the EC GPE vector
    ULONG               GpeVector;              // GPE vector assigned to the EC device

    PVOID               OperationRegionObject;  // Attachment to the EC operation region


    ACPIEC_CONFIGURATION_INFORMATION Configuration;

    //
    // Lock for device data
    //

    KSPIN_LOCK          Lock;               // Lock device data

    //
    // Device maintenance
    //

    KEVENT              Unload;             // Event to wait of for unload
    UCHAR               DeviceState;

    //
    // Query/vector operations
    //

    UCHAR               QueryState;
    UCHAR               VectorState;

    ULONG               QuerySet[EVTBITS];      // If pending or not
    ULONG               QueryType[EVTBITS];     // Type of Query or Vector
    PIRP                QueryRequest;           // IRP to execute query methods
    UCHAR               QueryMap[MAX_QUERY+1];  // Query pending list and vector table map
    UCHAR               QueryHead;              // List of pending queries
    UCHAR               VectorHead;             // List of pending vectors
    UCHAR               VectorFree;             // List of free vectors entries
    UCHAR               VectorTableSize;        // Sizeof vector table
    PVECTOR_TABLE       VectorTable;

    //
    // Device's work queue (owned by Lock owner)
    //

    BOOLEAN             InService;          // Serialize in service
    BOOLEAN             InServiceLoop;      // Flag when in service needs to loop
    BOOLEAN             InterruptEnabled;   // Masked or not
    LIST_ENTRY          WorkQueue;          // Queued IO IRPs to the device
    PIRP                MiscRequest;        // IRP for start/stop device

    //
    // Data IO (owned by InService owner)
    //

    UCHAR               IoState;            // Io state
    UCHAR               IoBurstState;       // Pushed state for burst enable
    UCHAR               IoTransferMode;     // read or write transfer

    UCHAR               IoAddress;          // Address in EC for transfer
    UCHAR               IoLength;           // Length of transfer
    UCHAR               IoRemain;           // Length remaining of transfer
    PUCHAR              IoBuffer;           // RAM location for transfer

    //
    // Watchdog Timer to catch hung and/or malfunctioning ECs
    //
    
    UCHAR               ConsecutiveFailures;// Count how many times watdog fired without making progress.
    UCHAR               LastAction;         // Index into RecentActions array.
    LARGE_INTEGER       PerformanceFrequency;
    KTIMER              WatchdogTimer;
    KDPC                WatchdogDpc;
    ACPIEC_ACTION       RecentActions [ACPIEC_ACTION_COUNT];

    //
    // Stats
    //

    ULONG               NonBurstTimeout;
    ULONG               BurstTimeout;
    ULONG               BurstComplete;
    ULONG               BurstAborted;
    ULONG               TotalBursts;
    ULONG               Errors;
    ULONG               MaxServiceLoop;

} ECDATA, *PECDATA;

//
// DeviceState
//

#define EC_DEVICE_WORKING               0
#define EC_DEVICE_UNLOAD_PENDING        1
#define EC_DEVICE_UNLOAD_CANCEL_TIMER   2
#define EC_DEVICE_UNLOAD_COMPLETE       3

//
// QueryState
//

#define EC_QUERY_IDLE                   0
#define EC_QUERY_DISPATCH               1
#define EC_QUERY_DISPATCH_WAITING       2
#define EC_QUERY_DISPATCH_COMPLETE      3

//
// Embedded Control read state
//

#define EC_IO_NONE              0           // Idle
#define EC_IO_READ_BYTE         1           // Read byte on OBF
#define EC_IO_READ_QUERY        2           // Query response on OBF
#define EC_IO_BURST_ACK         3           // Brust ACK on OBF
#define EC_IO_WRITE_BYTE        4           // Write byte on IBE
#define EC_IO_NEXT_BYTE         5           // Issue read/write on IBE
#define EC_IO_SEND_ADDRESS      6           // Send transfer address on IBE
#define EC_IO_UNKNOWN           7

//
// Status port definitions
//

#define EC_OUTPUT_FULL      0x01            // Output buffer full (data from EC to Host)
#define EC_INPUT_FULL       0x02            // Input buffer full (data from Host to EC)
#define EC_BURST            0x10            // In burst transfer
#define EC_QEVT_PENDING     0x20            // Query event is pending
#define EC_BUSY             0x80            // Device is busy

//
// Embedded controller commands
//

#define EC_READ_BYTE        0x80
#define EC_WRITE_BYTE       0x81
#define EC_BURST_TRANSFER   0x82
#define EC_CANCEL_BURST     0x83
#define EC_QUERY_EVENT      0x84

//
// Prototypes
//

NTSTATUS
AcpiEcSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

NTSTATUS
AcpiEcNewEc (
    IN PDEVICE_OBJECT       Fdo
    );

NTSTATUS
AcpiEcOpenClose(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcReadWrite(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcInternalControl(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
AcpiEcUnload(
    IN PDRIVER_OBJECT       DriverObject
    );


BOOLEAN
AcpiEcGpeServiceRoutine (
        IN PVOID                GpeVectorObject,
        IN PVOID                ServiceContext
    );

VOID
AcpiEcServiceDevice (
    IN PECDATA              EcData
    );

VOID
AcpiEcDispatchQueries (
    IN PECDATA              EcData
    );

VOID
AcpiEcUnloadPending (
    IN PECDATA              EcData
    );


NTSTATUS
AcpiEcConnectHandler (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcDisconnectHandler (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );


NTSTATUS
AcpiEcGetPdo (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );

NTSTATUS EXPORT
AcpiEcOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
AcpiEcGetAcpiInterfaces (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcGetGpeVector (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcConnectGpeVector (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcDisconnectGpeVector (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcInstallOpRegionHandler (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcRemoveOpRegionHandler (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcForwardIrpAndWait (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcIoCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              pdoIoCompletedEvent
    );

NTSTATUS
AcpiEcAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
AcpiEcStartDevice(
    IN PDEVICE_OBJECT       Fdo,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcStopDevice(
    IN PDEVICE_OBJECT       Fdo,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    OUT PDEVICE_OBJECT      *NewDeviceObject
    );

VOID
AcpiEcServiceIoLoop (
    IN PECDATA              EcData
    );

VOID
AcpiEcDispatchQueries (
    IN PECDATA              EcData
    );

VOID
AcpiEcWatchdogDpc(
    IN PKDPC   Dpc,
    IN PECDATA EcData,
    IN PVOID   SystemArgument1,
    IN PVOID   SystemArgument2
    );

VOID
AcpiEcLogAction (
    PECDATA EcData, 
    UCHAR Action, 
    UCHAR Data
    );

VOID
AcpiEcLogError (
    PECDATA EcData, 
    NTSTATUS ErrCode
    );
//
// Io extension macro to just pass on the Irp to a lower driver
//
#define AcpiEcCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\query.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    query.c

Abstract:

    ACPI Embedded Controller Driver - query dispatching

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/


#include "ecp.h"



NTSTATUS
AcpiEcCompleteQueryMethod (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,AcpiEcUnloadPending)
#pragma alloc_text(PAGE,AcpiEcConnectHandler)
#pragma alloc_text(PAGE,AcpiEcDisconnectHandler)
#endif

UCHAR   rgHexDigit[] = "0123456789ABCDEF";


NTSTATUS
AcpiEcRunQueryMethod (
    IN PECDATA          EcData,
    IN ULONG            QueryIndex
    )
/*++

Routine Description:

    This routine runs the query control method that corresponds to the QueryIndex.

Arguments:

    EcData      - Pointer to the EC extension
    QueryIndex  - The query to run

Return Value:

    Status

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    PIRP                    irp;

    ASSERT (QueryIndex <= MAX_QUERY);

    //
    // Note: because the ACPI control method is using INPUT data only and
    // this information is grabbed before STATUS_PENDING is returned, it is
    // safe to allocate the storage for this data on the stack.
    //
    // However, because this is a method that can be called at DISPATCH_LEVEL
    // and because we want to reuse the same irp over and over again, it is not
    // safe to call IoBuildDeviceIoControlRequest for this request
    //

    //
    // Initialize the input data
    //
    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = '00Q_';
    inputBuffer.MethodName[2] = rgHexDigit[ QueryIndex / 16];
    inputBuffer.MethodName[3] = rgHexDigit[ QueryIndex % 16];

    EcPrint(
        EC_NOTE,
        ("AcpiEcRunQueryMethod: Running query control method %.4s\n",
        inputBuffer.MethodName )
        );

    //
    // Setup the (pre-allocated) Irp
    //
    irp = EcData->QueryRequest;
    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Setup the call
    //
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_EVAL_INPUT_BUFFER);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irp->AssociatedIrp.SystemBuffer  = &inputBuffer;

    //
    // only matters if it is buffered
    //
    irp->Flags |= IRP_INPUT_OPERATION;

    //
    // We want to reuse this irp, so we need to set a completion routine.
    // This will also let us know when the irp is done
    //
    IoSetCompletionRoutine(
        irp,
        AcpiEcCompleteQueryMethod,
        EcData,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass request to Pdo (ACPI driver).  This is an asynchronous request
    //
    status = IoCallDriver(EcData->Pdo, irp);

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        EcPrint(
            EC_LOW,
            ("AcpiEcRunQueryMethod:  Query Control Method failed, status = %Lx\n",
             status )
            );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
AcpiEcCompleteQueryMethod (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This is the routine that is called after the ACPI driver has finished
    running the _Qxx method. This routine is here so that we can do the
    'correct' thing after the method is complete.

    Note: We cannot touch Irp->AssociatedIrp.SystemBuffer here because the
    stack that it might have been on has probably been reclaimed. If it becomes
    important to touch this data, then we must allocate the parameters as
    part of non-paged pool

Arguments:

    DeviceObject    - Us
    Irp             - Request that was completed
    Context         - EcData;

--*/
{
    KIRQL               OldIrql;
    PECDATA             EcData = (PECDATA) Context;
    BOOLEAN             ProcessQuery;

#if DEBUG
    //
    // What happened to the irp?
    //
    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        EcPrint(
            EC_LOW,
            ("AcpiEcCompleteQueryMethod: Query Method failed, status = %08x\n",
             Irp->IoStatus.Status )
            );

    } else {

        EcPrint(
            EC_NOTE,
            ("AcpiEcCompleteQueryMethod: QueryMethod succeeded.\n")
            );

    }
#endif

    ProcessQuery = FALSE;
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    switch  (EcData->QueryState) {
        case EC_QUERY_DISPATCH:
            EcData->QueryState = EC_QUERY_DISPATCH_COMPLETE;
            break;

        case EC_QUERY_DISPATCH_WAITING:
            EcData->QueryState = EC_QUERY_IDLE;
            ProcessQuery = TRUE;
            break;

        default:
            // internal error
            ASSERT (FALSE);
            break;
    }

    KeReleaseSpinLock (&EcData->Lock, OldIrql);

    if (ProcessQuery) {
        AcpiEcDispatchQueries(EcData);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}


VOID
AcpiEcDispatchQueries (
    IN PECDATA          EcData
    )
{
    KIRQL               OldIrql;
    ULONG               i, j;
    ULONG               Id, Vector;
    PVECTOR_HANDLER     Handler;
    PVOID               Context;


    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    //
    // Run the vector pending list
    //

    while (EcData->VectorHead) {

        Id = EcData->VectorHead;
        Vector = EcData->VectorTable[Id].Vector;
        i = Vector / BITS_PER_ULONG;
        j = 1 << (Vector % BITS_PER_ULONG);

        //
        // Remove vector from list
        //

        EcData->QuerySet[i] &= ~j;
        EcData->VectorHead = EcData->VectorTable[Id].Next;

        //
        // Dispatch it
        //

        Handler = EcData->VectorTable[Id].Handler;
        Context = EcData->VectorTable[Id].Context;
        KeReleaseSpinLock (&EcData->Lock, OldIrql);

        Handler (Vector, Context);

        KeAcquireSpinLock (&EcData->Lock, &OldIrql);
    }

    //
    // If QueryState is idle, start dispatching
    //

    if (EcData->QueryState == EC_QUERY_IDLE) {

        //
        // Run query pending list
        //

        while (EcData->QueryHead) {

            Id = EcData->QueryHead;
            i = Id / BITS_PER_ULONG;
            j = 1 << (Id % BITS_PER_ULONG);

            //
            // Remove query from list
            //

            EcData->QuerySet[i] &= ~j;
            EcData->QueryHead = EcData->QueryMap[Id];

            EcData->QueryState = EC_QUERY_DISPATCH;
            KeReleaseSpinLock (&EcData->Lock, OldIrql);

            //
            // Run control method for this event
            //

            EcPrint(EC_NOTE, ("AcpiEcDispatchQueries: Query %x\n", Id));
            AcpiEcRunQueryMethod (EcData, Id);


            //
            // If irp is complete the state will be dispatch_complete, loop
            // and process the next bit.  Else, wait for irp to return
            //

            KeAcquireSpinLock (&EcData->Lock, &OldIrql);
            if (EcData->QueryState == EC_QUERY_DISPATCH) {
                //
                // It's not complete, wait for it to complete
                //

                EcData->QueryState = EC_QUERY_DISPATCH_WAITING;
                KeReleaseSpinLock (&EcData->Lock, OldIrql);
                return ;
            }

        }

        //
        // No longer dispatching query events
        //

        EcData->QueryState = EC_QUERY_IDLE;

        //
        // If unload is pending, check to see if the device can be unloaded now
        //

        if (EcData->DeviceState == EC_DEVICE_UNLOAD_PENDING) {
            AcpiEcUnloadPending (EcData);
        }
    }

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
}

VOID
AcpiEcUnloadPending (
    IN PECDATA  EcData
    )
/*++

Routine Description:

    Called when state is unload pending and some portion of the state
    has gone idle.  If the entire device state is idle, the unload is
    stated.

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

--*/
{

    ASSERT (EcData->DeviceState == EC_DEVICE_UNLOAD_PENDING);

    //
    // Check if device is idle for unload operation
    //

    if (EcData->QueryState      == EC_QUERY_IDLE &&
        EcData->InService       == FALSE &&
        EcData->IoState         == EC_IO_NONE) {

        //
        // Promote unloading device state to next step (which
        // is to clean up the fake ISR timer)
        //

        EcData->DeviceState = EC_DEVICE_UNLOAD_CANCEL_TIMER;
    }
}


NTSTATUS
AcpiEcConnectHandler (
    IN PECDATA  EcData,
    IN PIRP     Irp
    )
/*++

Routine Description:

    This functions connects a specific handled to an Ec query vector

Arguments:

    EcData  - Pointer to embedded controller to service.

    Irp     - IOCTL conntain connect request

Return Value:

--*/
{
    KIRQL               OldIrql;
    PVOID               LockPtr;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpSp;
    PEC_HANDLER_REQUEST Req;
    PVECTOR_TABLE       Vector;
    ULONG               by, bi, i, j;
    ULONG               TableIndex;

    PAGED_CODE ();

    //
    // Get request
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Req   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(EC_HANDLER_REQUEST)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Setup data concerning request
    //

    by = Req->Vector / BITS_PER_ULONG;
    bi = 1 << (Req->Vector % BITS_PER_ULONG);

    //
    // Lock device
    //

    LockPtr = MmLockPagableCodeSection(AcpiEcConnectHandler);
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    //
    // If device handler already set, then fail the request
    //

    Status  = STATUS_UNSUCCESSFUL;
    if (!(EcData->QueryType[by] & bi)) {
        //
        // No handler set, allocate vector entry for it
        //

        EcData->QueryType[by] |= bi;
        if (!EcData->VectorFree) {
            //
            // No free entries on vector table, make some
            //

            i = EcData->VectorTableSize;
            Vector = ExAllocatePoolWithTag (
                        NonPagedPool,
                        sizeof (VECTOR_TABLE) * (i + 4),
                        'V_CE'
                        );

            if (!Vector) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto AcpiEcConnectHandlerExit;
            }

            if (EcData->VectorTable) {
                memcpy (Vector, EcData->VectorTable, sizeof (VECTOR_TABLE) * i);
                ExFreePool (EcData->VectorTable);
            }

            EcData->VectorTableSize += 4;
            EcData->VectorTable = Vector;

            for (j=0; j < 4; j++) {
                EcData->VectorTable[i+j].Next = EcData->VectorFree;
                EcData->VectorFree = (UCHAR) (i+j);
            }
        }

        TableIndex = EcData->VectorFree;
        Vector = &EcData->VectorTable[TableIndex];
        EcData->VectorFree = Vector->Next;

        //
        // Build mapping for the vector
        //

        if (EcData->QueryMap[Req->Vector]) {
            //
            // Vector is in query pending list, remove it
            //

            EcData->QuerySet[by] &= ~bi;
            for (i = EcData->QueryHead; i; i = EcData->QueryMap[i]) {
                if (EcData->QueryMap[i] == Req->Vector) {
                    EcData->QueryMap[i] = EcData->QueryMap[Req->Vector];
                    break;
                }
            }
        }

        EcData->QueryMap[Req->Vector] = (UCHAR) TableIndex;

        //
        // Initialize vector handler
        //

        Vector->Next = 0;
        Vector->Vector  = (UCHAR) Req->Vector;
        Vector->Handler = Req->Handler;
        Vector->Context = Req->Context;
        Req->AllocationHandle = (PVOID)((ULONG_PTR)TableIndex);
        Status = STATUS_SUCCESS;
    }

AcpiEcConnectHandlerExit:
    //
    // Unlock device and return status
    //

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    MmUnlockPagableImageSection(LockPtr);
    return Status;
}

NTSTATUS
AcpiEcDisconnectHandler (
    IN PECDATA  EcData,
    IN PIRP     Irp
    )
/*++

Routine Description:

    This functions disconnects a specific handled to an Ec query vector

Arguments:

    EcData  - Pointer to embedded controller to service.

    Irp     - IOCTL conntain connect request

Return Value:

--*/
{
    KIRQL               OldIrql;
    PVOID               LockPtr;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpSp;
    PEC_HANDLER_REQUEST Req;
    ULONG               by, bi, i;
    ULONG               TableIndex;

    PAGED_CODE ();

    //
    // Get request
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Req   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(EC_HANDLER_REQUEST)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Setup data concerning request
    //

    by = Req->Vector / BITS_PER_ULONG;
    bi = 1 << (Req->Vector % BITS_PER_ULONG);

    //
    // Lock device
    //

    LockPtr = MmLockPagableCodeSection(AcpiEcDisconnectHandler);
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    //
    // If device handler already set, then fail the request
    //

    Status  = STATUS_UNSUCCESSFUL;
    if (EcData->QueryType[by] & bi) {
        //
        // Clear handler
        //

        EcData->QueryType[by] &= ~bi;
        TableIndex = EcData->QueryMap[Req->Vector];
        ASSERT (Req->AllocationHandle == (PVOID)((ULONG_PTR)TableIndex));

        //
        // If pending, drop it
        //

        if (EcData->QuerySet[by] & bi) {
            EcData->QuerySet[by] &= ~bi;

            for (i = EcData->VectorHead; i; i = EcData->VectorTable[i].Next) {
                if (EcData->VectorTable[i].Next == TableIndex) {
                    EcData->VectorTable[i].Next = EcData->VectorTable[TableIndex].Next;
                    break;
                }
            }
        }

        //
        // Put onto free list
        //

        EcData->VectorTable[TableIndex].Next = EcData->VectorFree;
        EcData->VectorFree = (UCHAR) TableIndex;
        Status = STATUS_SUCCESS;
    }

    //
    // Unlock device and return status
    //

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    MmUnlockPagableImageSection(LockPtr);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\app\ec.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>


//
// global handles
//

UCHAR   Usage[] = "ec: r addr len\n    w addr value";
HANDLE  DriverHandle;
UCHAR   Buffer[256];


//
// Prototypes
//

BOOLEAN
InitDriver ();



int
__cdecl
main(USHORT argc, CHAR **argv)
{
    BOOLEAN         Write;
    ULONG           Offset, Value;
    ULONG           l, bw;

    //
    // Locate pentium perf driver
    //

    if (!InitDriver ()) {
        printf ("acpiec.sys is not installed\n");
        exit (1);
    }

    //
    // Check args
    //

    if (argc < 3) {
        printf (Usage);
        exit (1);
    }

    switch (argv[1][0]) {
        case 'r':   Write = FALSE;      break;
        case 'w':   Write = TRUE;       break;
        default:    printf (Usage);     exit(1);
    }

    Offset = atoi(argv[2]);
    if (Offset > 255) {
        printf ("ec: Offset must be 0-255\n");
        exit   (1);
    }

    Value  = atoi(argv[3]);
    if (Value > 255) {
        printf ("ec: len/value must be 0-255\n");
        exit   (1);
    }

    l = SetFilePointer (DriverHandle, Offset, NULL, FILE_BEGIN);
    if (l == -1) {
        printf ("ec: Could not set file pointer\n");
        exit (1);
    }

    if (Write) {
        if (!WriteFile(DriverHandle, &Value, 1, &bw, NULL)) {
            printf ("ec: Write error\n");
            exit (1);
        }
    } else {
        if (!ReadFile(DriverHandle, Buffer, Value, &bw, NULL)) {
            printf ("ec: Read error\n");
            exit (1);
        }

        for (l=0; l < Value; l++) {
            printf ("%3d: %d\n", Offset + l, Buffer[l]);
        }
    }

    return 0;
}

BOOLEAN
InitDriver ()
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    RtlInitUnicodeString(&DriverName, L"\\Device\\ACPIEC");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    return NT_SUCCESS(status) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\service.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    service.c

Abstract:

    ACPI Embedded Controller Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "ecp.h"

#define NTMS                10000L          // 1 millisecond is ten thousand 100ns
#define NTSEC               (NTMS * 1000L)
LARGE_INTEGER   AcpiEcWatchdogTimeout = {(NTSEC * -5L), -1};
LARGE_INTEGER   AcpiEcLastActionTime = {0,0};

PUCHAR AcpiEcActionDescription [EC_ACTION_MAX >> 4] = {
    "Invalid    ",
    "Read Status",
    "Read Data  ",
    "Write Cmd  ",
    "Write Data ",
    "Interrupt  ",
    "Disable GPE",
    "Enable GPE ",
    "Clear GPE  ",
    "Queued IO  ",
    "Repeated Last action this many times:"
};


VOID
AcpiEcServiceDevice (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    This routine starts or continues servicing the device's work queue

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

    None

--*/
{
    KIRQL               OldIrql;

    //
    // Even though the device is unloaded, there might still be a
    // service call which occurs until the timer is canceled
    //

    EcPrint(EC_TRACE, ("AcpiEcServiceDevice.\n"));

    if (EcData->DeviceState > EC_DEVICE_UNLOAD_PENDING) {
        return;
    }

    //
    // Acquire device lock and signal function was entered
    //

    KeAcquireSpinLock (&EcData->Lock, &OldIrql);
    EcData->InServiceLoop = TRUE;

    //
    // If not already in service, enter InService
    //

    if (!EcData->InService) {
        EcData->InService = TRUE;

        //
        // Disable the device's interrupt
        //

        if (EcData->InterruptEnabled) {
            EcData->InterruptEnabled = FALSE;

            //
            // Call ACPI to disable the device's interrupt
            //
            AcpiEcLogAction (EcData, EC_ACTION_DISABLE_GPE, 0);
            AcpiInterfaces.GpeDisableEvent (AcpiInterfaces.Context,
                                            EcData->GpeVectorObject);
        }

        //
        // While service invocation pending, loop
        //

        while (EcData->InServiceLoop) {
            EcData->InServiceLoop = FALSE;

            KeReleaseSpinLock (&EcData->Lock, OldIrql);

            //
            // Dispatch service handler
            //

            AcpiEcServiceIoLoop (EcData);

            //
            // Loop and re-service
            //

            KeAcquireSpinLock (&EcData->Lock, &OldIrql);

        }

        //
        // No longer in service loop
        //

        EcData->InService = FALSE;

        //
        // If unload is pending, check to see if the device can be unloaded now
        //

        if (EcData->DeviceState > EC_DEVICE_WORKING) {
            AcpiEcUnloadPending (EcData);
        }

        //
        // Enable the device's interrupt
        //

        if (!EcData->InterruptEnabled) {
            EcData->InterruptEnabled = TRUE;

            //
            // Call ACPI to enable the device's interrupt
            //
            AcpiEcLogAction (EcData, EC_ACTION_ENABLE_GPE, 0);
            AcpiInterfaces.GpeEnableEvent (AcpiInterfaces.Context,
                                            EcData->GpeVectorObject);
        }
    }

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
}

VOID
AcpiEcServiceIoLoop (
    IN PECDATA      EcData
    )
/*++

Routine Description:

    Main embedded controller device service loop.  Services EC events,
    and processes IO queue.  Terminate when the controller is busy (e.g.,
    wait for interrupt to continue) or when all servicing has been completed.

    N.B. Caller must be the owner of the device InService flag

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

    none

--*/
{
    PIO_STACK_LOCATION  IrpSp;
    PLIST_ENTRY         Link;
    PIRP                Irp;
    PUCHAR              WritePort;
    UCHAR               WriteData;
    UCHAR               Status;
    UCHAR               Data;
    BOOLEAN             EcBusy;
    BOOLEAN             BurstEnabled;
    BOOLEAN             ProcessQuery;
    ULONG               NoWorkStall;
    ULONG               StallAccumulator;
    PULONG              Timeout;
    KIRQL               OldIrql;
    LIST_ENTRY          CompleteQueue;
    ULONG               i, j;


    //
    // EcBusy flags that there may be work to do.  Initialized to TRUE every time
    // The service loop is entered, or when a timeout almost occured, but then some 
    // work was found.  It is set to FALSE when the IO queue is empty and there are 
    // no query events pending.
    //
    EcBusy = TRUE;

    //
    // Timeout points to the counter to be incremented as the loop exits.  It is 
    // also used as a flag to indicate that the loop should exit.  The loop won't
    // exit until Timeout != NULL.  When exiting because of idleness, it is set
    // to the local vailable i, so that we don't keep a permanent count of those 
    // timeout conditions.  We keep track of how many time we timeout waiting for
    // the EC.  If we do, we expect an interrupt when the EC is ready.
    //
    Timeout = NULL;

    //
    // This is set (along with WriteData) to have write a command or data to the 
    // EC at the appropriate point in the loop.
    //
    WritePort = NULL;

    //
    // NoWorkStall is incremented every time through the loop.  It is reset to 0
    // whenever any work is done.  If it gets too big, Timeout is set.  If it 
    // then gets cleared before the loop actually exits, Timeout is Cleared.
    //
    NoWorkStall = 0;
    
    //
    // BurstEnable keeps trakc of whethe we think Burst Mode is enabled.  If 
    // Burst Mode gets disabled automatically by the EC, we know that and pretend
    // that burst mode is enabled so that the driver can make forward progress.
    //
    BurstEnabled = FALSE;
    
    //
    // ProcessQuery is set if we need to go run some _Qxx methods as the loop exits.
    //
    ProcessQuery = FALSE;
    
    //
    // StallAccumulator counts how many ticks we've stalled for using 
    // KeStallExecutionProcessor during one complete run of the service loop.
    //
    StallAccumulator = 0;

    EcPrint(EC_TRACE, ("AcpiEcServiceIoLoop.\n"));

    InitializeListHead (&CompleteQueue);

    //
    // Loop while busy
    //

    for (; ;) {

        //
        // If there's outgoing data write it, issue the device required
        // stall and indicate work is being done (clear noworkstall)
        //

        if (WritePort) {
            EcPrint(EC_IO, ("AcpiEcServiceIO: Write = %x at %x\n", WriteData, WritePort));
            AcpiEcLogAction (EcData, 
                             (WritePort == EcData->CommandPort) ? 
                                    EC_ACTION_WRITE_CMD : EC_ACTION_WRITE_DATA, 
                             WriteData);
            WRITE_PORT_UCHAR (WritePort, WriteData);
            KeStallExecutionProcessor (1);
            StallAccumulator += 1;
            WritePort = NULL;
            NoWorkStall = 0;        // work was done
        }

        //
        // If work was done, clear pending timeout condition if it exists to
        // continue servicing the device
        //

        if (NoWorkStall == 0  &&  Timeout) {
            Timeout = NULL;
            EcBusy = TRUE;
        }

        //
        // If NoWorkStall is non-zero, then no work was performed.  Determine
        // if the type of delay to issue while waiting (spinning) for the device
        //

        if (NoWorkStall) {

            //
            // No work was done the last time around.
            // If its time to timeout, exit the service loop.
            //

            if (Timeout) {
                break;
            }

            //
            // If device is idle, setup as if a timeout is occuring.  This
            // will acquire the device lock, clear the gpe sts bit and terminate
            // the service loop (or if the device is now busy, continue)
            //

            if (!EcBusy) {

                if (Status & EC_BURST) {
                    //
                    // Before exiting, clear burst mode for embedded controller.
                    // Has no response, no need to wait for EC to read it.
                    //

                    EcPrint (EC_IO, ("AcpiEcServiceIO: Clear Burst mode - Write = %x at %x\n", EC_CANCEL_BURST, EcData->CommandPort));
                    AcpiEcLogAction (EcData, EC_ACTION_WRITE_CMD, EC_CANCEL_BURST);
                    WRITE_PORT_UCHAR (EcData->CommandPort, EC_CANCEL_BURST);
                    Timeout = &EcData->BurstComplete;

                } else {

                    Timeout = &i;

                }

            } else {

                //
                // Interject stalls while spinning on device
                //

                StallAccumulator += NoWorkStall;
                KeStallExecutionProcessor (NoWorkStall);

                //
                // If wait is over the limit, prepare for a timeout.
                //

                if (!(Status & EC_BURST)) {
                    if (NoWorkStall >= EcData->MaxNonBurstStall) {
                        Timeout = &EcData->NonBurstTimeout;
                    }
                } else {
                    if (NoWorkStall >= EcData->MaxBurstStall) {
                        Timeout = &EcData->BurstTimeout;
                    }
                }
            }

            if (Timeout) {

                //
                // Over time limit, clear the GPE status bit
                //
                AcpiEcLogAction (EcData, EC_ACTION_CLEAR_GPE, 0);
                AcpiInterfaces.GpeClearStatus (AcpiInterfaces.Context,
                                                EcData->GpeVectorObject);
            }
        }


        //
        // Increase stall time and indicate no work was done
        //

        NoWorkStall += 1;

        //
        // Check Status
        //

        Status = READ_PORT_UCHAR (EcData->StatusPort);
        AcpiEcLogAction (EcData, EC_ACTION_READ_STATUS, Status);
        EcPrint(EC_IO, ("AcpiEcServiceIO: Status Read = %x at %x\n", Status, EcData->StatusPort));

        //
        // Keep bursts dropped by the EC stat
        //

        if (BurstEnabled && !(Status & EC_BURST)) {
            EcData->BurstAborted += 1;
            BurstEnabled = FALSE;
            Status |= EC_BURST;     // move one char
        }

        //
        // If Embedded controller has data for us, process it
        //

        if (Status & EC_OUTPUT_FULL) {

            Data = READ_PORT_UCHAR (EcData->DataPort);
            AcpiEcLogAction (EcData, EC_ACTION_READ_DATA, Data);
            EcPrint(EC_IO, ("AcpiEcServiceIO: Data Read = %x at %x\n", Data, EcData->DataPort));

            switch (EcData->IoState) {

                case EC_IO_READ_QUERY:
                    //
                    // Response to a read query.  Get the query value and set it
                    //

                    EcPrint(EC_NOTE, ("AcpiEcServiceIO: Query %x\n", Data));

                    if (Data) {
                        //
                        // If not set, set pending bit
                        //

                        KeAcquireSpinLock (&EcData->Lock, &OldIrql);

                        i = Data / BITS_PER_ULONG;
                        j = 1 << (Data % BITS_PER_ULONG);
                        if (!(EcData->QuerySet[i] & j)) {
                            EcData->QuerySet[i] |= j;

                            //
                            // Queue the query or vector operation
                            //

                            if (EcData->QueryType[i] & j) {
                                //
                                // This is a vector, put it in the vector pending list
                                //

                                Data = EcData->QueryMap[Data];
                                EcData->VectorTable[Data].Next = EcData->VectorHead;
                                EcData->VectorHead = Data;

                            } else {
                                //
                                // This is a query, put in in the query pending list
                                //

                                EcData->QueryMap[Data] = EcData->QueryHead;
                                EcData->QueryHead = Data;
                            }
                        }

                        KeReleaseSpinLock (&EcData->Lock, OldIrql);
                        ProcessQuery = TRUE;
                    }

                    EcData->IoState = EC_IO_NONE;
                    
                    break;

                case EC_IO_READ_BYTE:
                    //
                    // Read transfer. Read the data byte
                    //

                    *EcData->IoBuffer = Data;
                    EcData->IoState   = EC_IO_NEXT_BYTE;

                    break;

                case EC_IO_BURST_ACK:
                    //
                    // Burst ACK byte
                    //

                    EcData->IoState      = EcData->IoBurstState;
                    EcData->IoBurstState = EC_IO_UNKNOWN;
                    EcData->TotalBursts += 1;
                    BurstEnabled = TRUE;
                    break;

                default:
                    EcPrint(EC_ERROR,
                            ("AcpiEcService: Spurious data received State = %x, Data = %x\n",
                             EcData->IoState, Data)
                          );
                    AcpiEcLogError (EcData, ACPIEC_ERR_SPURIOUS_DATA); 

                    EcData->Errors += 1;
                    break;
            }

            NoWorkStall = 0;
            continue;
        }

        if (Status & EC_INPUT_FULL) {
            //
            // The embedded controllers input buffer is full, wait
            //

            continue;
        }

        //
        // Embedded controller is ready to receive data, see if anything
        // is already being sent
        //

        switch (EcData->IoState) {

            case EC_IO_NEXT_BYTE:
                //
                // Data transfer.
                //

                if (EcData->IoRemain) {

                    if (!(Status & EC_BURST)) {
                        //
                        // Not in burst mode.  Write burst mode command
                        //

                        EcData->IoState      = EC_IO_BURST_ACK;
                        EcData->IoBurstState = EC_IO_NEXT_BYTE;

                        WritePort = EcData->CommandPort;
                        WriteData = EC_BURST_TRANSFER;

                    } else {
                        //
                        // Send command to transfer next byte
                        //

                        EcData->IoBuffer  += 1;
                        EcData->IoAddress += 1;
                        EcData->IoRemain  -= 1;
                        EcData->IoState   = EC_IO_SEND_ADDRESS;

                        WritePort = EcData->CommandPort;
                        WriteData = EcData->IoTransferMode;
                    }

                } else {
                    //
                    // Transfer complete
                    //

                    EcData->IoState  = EC_IO_NONE;
                    EcData->IoRemain = 0;

                    Irp = EcData->DeviceObject->CurrentIrp;
                    EcData->DeviceObject->CurrentIrp = NULL;

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = EcData->IoLength;

                    InsertTailList (&CompleteQueue, &Irp->Tail.Overlay.ListEntry);
                }
                break;

            case EC_IO_SEND_ADDRESS:
                //
                // Send address of transfer request
                //

                WritePort = EcData->DataPort;
                WriteData = EcData->IoAddress;


                //
                // Wait or send data byte next
                //

                if (EcData->IoTransferMode == EC_READ_BYTE) {
                    EcData->IoState = EC_IO_READ_BYTE;
                } else {
                    EcData->IoState = EC_IO_WRITE_BYTE;
                }
                break;

            case EC_IO_WRITE_BYTE:
                //
                // Write transfer - write the data byte
                //

                EcData->IoState = EC_IO_NEXT_BYTE;
                WritePort = EcData->DataPort;
                WriteData = *EcData->IoBuffer;
                break;
        }

        //
        // If something to write, loop and handle it
        //

        if (WritePort) {
            continue;
        }

        //
        // If state is NONE, then nothing is pending see what should be
        // initiated
        //

        if (EcData->IoState == EC_IO_NONE) {

            EcData->ConsecutiveFailures = 0;

            if (Status & EC_QEVT_PENDING) {

                //
                // Embedded Controller has some sort of event pending
                //

                EcPrint(EC_QUERY, ("AcpiEcServiceIO: Received Query Request.\n"));

                EcData->IoState = EC_IO_READ_QUERY;
                WritePort = EcData->CommandPort;
                WriteData = EC_QUERY_EVENT;

                //
                // Reset the watchdog timer
                //
                KeSetTimer (&EcData->WatchdogTimer,
                            AcpiEcWatchdogTimeout,
                            &EcData->WatchdogDpc);
            } else {

                //
                // Get next tranfer from IO queue
                //

                Link = ExInterlockedRemoveHeadList (&EcData->WorkQueue, &EcData->Lock);

                //
                // If there's a transfer initiate it
                //

                if (Link) {

                    EcPrint(EC_HANDLER, ("AcpiEcServiceIO: Got next work item %x\n", Link));

                    Irp = CONTAINING_RECORD (
                                Link,
                                IRP,
                                Tail.Overlay.ListEntry
                                );

                    IrpSp = IoGetCurrentIrpStackLocation(Irp);
                    
                    EcData->DeviceObject->CurrentIrp = Irp;
                    
                    EcData->IoBuffer  = Irp->AssociatedIrp.SystemBuffer;
                    EcData->IoAddress = (UCHAR) IrpSp->Parameters.Read.ByteOffset.LowPart;
                    EcData->IoLength  = (UCHAR) IrpSp->Parameters.Read.Length;
                    EcData->IoTransferMode =
                        IrpSp->MajorFunction == IRP_MJ_READ ? EC_READ_BYTE : EC_WRITE_BYTE;

                    //
                    // Set it up via EC_IO_NEXT_BYTE and back up one byte
                    //

                    EcData->IoBuffer  -= 1;
                    EcData->IoAddress -= 1;
                    EcData->IoRemain  = EcData->IoLength;
                    EcData->IoState   = EC_IO_NEXT_BYTE;

                    NoWorkStall = 0;
                    
                    //
                    // Reset the watchdog timer
                    //
                    KeSetTimer (&EcData->WatchdogTimer,
                                AcpiEcWatchdogTimeout,
                                &EcData->WatchdogDpc);

                } else {

                    //
                    // Nothing but nothing to do.
                    //

                    EcBusy = FALSE;
                    
                    //
                    // Clear the Watchdog timer
                    //
                    KeCancelTimer (&EcData->WatchdogTimer);
                }
            }
        }
    }

    //
    // Keep stat as to why service loop terminated
    //

    *Timeout += 1;

    //
    // Track maximum service loop stall accumulator
    //

    if (StallAccumulator > EcData->MaxServiceLoop) {
        EcData->MaxServiceLoop = StallAccumulator;
    }

    //
    // Complete processed io requests
    //

    while (!IsListEmpty(&CompleteQueue)) {
        Link = RemoveHeadList(&CompleteQueue);
        Irp = CONTAINING_RECORD (
                    Link,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        EcPrint(EC_IO, ("AcpiEcServiceIO: IOComplete: Irp=%Lx\n", Irp));
        
        
        #if DEBUG 
        if (ECDebug && EC_TRANSACTION) {
            IrpSp = IoGetCurrentIrpStackLocation(Irp);
            if (IrpSp->MajorFunction == IRP_MJ_READ) {
                EcPrint (EC_TRANSACTION, ("AcpiEcServiceIO: Read ("));
                for (i=0; i < IrpSp->Parameters.Read.Length; i++) {
                    EcPrint (EC_TRANSACTION, ("%02x ", 
                                              ((PUCHAR)Irp->AssociatedIrp.SystemBuffer) [i]));

                }
                EcPrint (EC_TRANSACTION, (") from %02x length %02x\n", 
                                          (UCHAR)IrpSp->Parameters.Read.ByteOffset.LowPart,
                                          (UCHAR)IrpSp->Parameters.Read.Length));
            }
        }
        #endif

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    //
    // If queries occured, dispatch them
    //

    if (ProcessQuery) {
        AcpiEcDispatchQueries (EcData);
    }
}



VOID
AcpiEcWatchdogDpc(
    IN PKDPC   Dpc,
    IN PECDATA EcData,
    IN PVOID   SystemArgument1,
    IN PVOID   SystemArgument2
    )
/*++

Routine Description:

    Gets called if EC doesn't respond within 5 seconds of request.

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

    None.

--*/
{
    UCHAR               ecStatus;
    PIRP                Irp;
    KIRQL               OldIrql;
#if DEBUG
    UCHAR               i;
#endif


    ecStatus = READ_PORT_UCHAR (EcData->StatusPort);
    AcpiEcLogAction (EcData, EC_ACTION_READ_STATUS, ecStatus);

    if (EcData->ConsecutiveFailures < 255) {
        EcData->ConsecutiveFailures++;
    }

    if (EcData->ConsecutiveFailures <= 5) {
        //
        // Only log an error for the first 5 consecutive failures.  After that just be quiet about it.
        //
        AcpiEcLogError(EcData, ACPIEC_ERR_WATCHDOG);
    }

    EcPrint (EC_ERROR, ("AcpiEcWatchdogDpc: EC error encountered.  \nAction History:\n"
                        "   D time  IoState  Action       Data\n"
                        "   *%3dns\n", (ULONG)(1000000000/EcData->PerformanceFrequency.QuadPart)));
    
#if DEBUG
    i = EcData->LastAction;
    do {
        i++;
        i &= ACPIEC_ACTION_COUNT_MASK;
        
        if ((EcData->RecentActions[i].IoStateAction & EC_ACTION_MASK) == 0) {
            continue;
        }

        EcPrint (EC_ERROR, ("   %04x    %01x        %s  0x%02x\n",
                            EcData->RecentActions[i].Time,
                            EcData->RecentActions[i].IoStateAction & ~EC_ACTION_MASK,
                            (EcData->RecentActions[i].IoStateAction & EC_ACTION_MASK) < EC_ACTION_MAX ? 
                                AcpiEcActionDescription [(EcData->RecentActions[i].IoStateAction & EC_ACTION_MASK) >> 4] : "",
                            EcData->RecentActions[i].Data));
    } while (i != EcData->LastAction);
#endif

    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    if (EcData->InService) {
        //
        // This is not likely to happen.
        // If the service loop is running, this should exit.
        // Reset the Watchdog Timer.  This may be set again or canceld by the service loop
        //

        KeSetTimer (&EcData->WatchdogTimer,
                    AcpiEcWatchdogTimeout,
                    &EcData->WatchdogDpc);
        
        KeReleaseSpinLock (&EcData->Lock, OldIrql);
        return;
    }
    //
    // Hold Spinlock throughout so we can guatantee there won't be a conflict in the IO queue.
    //
    
    EcData->InService = TRUE;
    
    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    
    switch (EcData->IoState) {
    case EC_IO_NONE:
        //
        // This shouldn't happen.  The watchdog should be shut off if the
        // driver isn't busy.
        //
        break;
    case EC_IO_READ_BYTE:
    case EC_IO_BURST_ACK:
        if (ecStatus & EC_OUTPUT_FULL) {
            //
            // EC appears to be ready.  Log an error and continue.
            //

        } else {
            //
            // If the embedded controller is not ready yet, somthing went wrong.
            // Retry the transaction.
            //

            if (EcData->IoState == EC_IO_READ_BYTE) {
                EcData->IoBuffer -= 1;
                EcData->IoAddress -= 1;
                EcData->IoRemain += 1;
            }

            EcData->IoState = EC_IO_NEXT_BYTE;
        }
        break;
    case EC_IO_READ_QUERY:
        if (ecStatus & EC_OUTPUT_FULL) {
            //
            // EC appears to be ready.  Log an error and continue.
            //

        } else {
            //
            // If the embedded controller is not ready yet, somthing went wrong.
            // This could mean that the query was lost.  If the Query bit is still set,
            // the driver will retry automatically.
            //

            EcData->IoState = EC_IO_NONE;
        }
        break;
    case EC_IO_WRITE_BYTE:
    case EC_IO_SEND_ADDRESS:
        //
        // This is just waiting for IBF==0.  If it took this long, chances are the 
        // state was lost.  Retry the transaction.
        //

        EcData->IoBuffer -= 1;
        EcData->IoAddress -= 1;
        EcData->IoRemain += 1;
        EcData->IoState = EC_IO_NEXT_BYTE;
        break;
    case EC_IO_NEXT_BYTE:
        //
        // This could happen if IBF is still set
        //
        
        if (ecStatus & EC_INPUT_FULL) {
            //
            // Try thwaking it to see if it will wake up.
            //

            EcPrint (EC_IO, ("AcpiEcWatchDog: Clear Burst mode - Write = %x at %x\n", EC_CANCEL_BURST, EcData->CommandPort));
            AcpiEcLogAction (EcData, EC_ACTION_WRITE_CMD, EC_CANCEL_BURST);
            WRITE_PORT_UCHAR (EcData->CommandPort, EC_CANCEL_BURST);
        }

    }
    
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);
    EcData->InService = FALSE;
    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    
    //
    // Set the timer.  The ServiceIoLoop won't reset the timer, until some forward progress is made.
    //
    KeSetTimer (&EcData->WatchdogTimer,
                AcpiEcWatchdogTimeout,
                &EcData->WatchdogDpc);

    AcpiEcServiceDevice(EcData);
}

VOID
AcpiEcLogAction (
    PECDATA EcData, 
    UCHAR Action, 
    UCHAR Data
    )

{
    UCHAR i, j;
    LARGE_INTEGER   time, temp;
    i = EcData->LastAction;
    j = (i-1)&ACPIEC_ACTION_COUNT_MASK;
    if (    ((EcData->RecentActions [i].IoStateAction & EC_ACTION_MASK) == EC_ACTION_REPEATED) &&
            (EcData->RecentActions [j].IoStateAction == (EcData->IoState | Action)) &&
            (EcData->RecentActions [j].Data == Data)) {
        //
        // If we already have a repeated action, increment the count on the repeated action 
        // then update the time on the latest one.  We only care about the time of the first and last one.
        //
        EcData->RecentActions [i].Data++;
        if (EcData->RecentActions [i].Data == 0) {
            //
            // If we've logged 255 repeats, don't roll over to 0.
            //

            EcData->RecentActions [i].Data = 0xff;
        }
        time = KeQueryPerformanceCounter (NULL);
        temp.QuadPart = time.QuadPart - AcpiEcLastActionTime.QuadPart;
        temp.QuadPart = temp.QuadPart + EcData->RecentActions[i].Time;
        if (temp.QuadPart > ((USHORT) -1)) {
            temp.QuadPart = (USHORT) -1;
        }
        EcData->RecentActions[i].Time = (USHORT) temp.LowPart;
    } else if ((EcData->RecentActions [i].IoStateAction == (EcData->IoState | Action)) &&
               (EcData->RecentActions [i].Data == Data)) {
        //
        // This is the same action as the last one.  list as a repeated action
        //
        EcData->LastAction++;
        EcData->LastAction &= ACPIEC_ACTION_COUNT_MASK;
        EcData->RecentActions[EcData->LastAction].Data = 1;
        time = KeQueryPerformanceCounter (NULL);
        temp.QuadPart = time.QuadPart - AcpiEcLastActionTime.QuadPart;
        if (temp.QuadPart > ((USHORT) -1)) {
            temp.QuadPart = (USHORT) -1;
        }
        EcData->RecentActions[EcData->LastAction].Time = (USHORT) temp.LowPart;
        AcpiEcLastActionTime = time;
        // Set this last since it is the key to saying that an entry is complete.
        EcData->RecentActions[EcData->LastAction].IoStateAction = EC_ACTION_REPEATED | EcData->IoState;
    } else {
        EcData->LastAction++;
        EcData->LastAction &= ACPIEC_ACTION_COUNT_MASK;
        EcData->RecentActions[EcData->LastAction].Data = Data;
        time = KeQueryPerformanceCounter (NULL);
        temp.QuadPart = time.QuadPart - AcpiEcLastActionTime.QuadPart;
        if (temp.QuadPart > ((USHORT) -1)) {
            temp.QuadPart = (USHORT) -1;
        }
        EcData->RecentActions[EcData->LastAction].Time = (USHORT) temp.LowPart;
        AcpiEcLastActionTime = time;
        // Set this last since it is the key to saying that an entry is complete.
        EcData->RecentActions[EcData->LastAction].IoStateAction = Action | EcData->IoState;
    }

}

VOID
AcpiEcLogError (
    PECDATA EcData,
    NTSTATUS ErrCode
    )
{
    PIO_ERROR_LOG_PACKET    logEntry = NULL;
    PACPIEC_ACTION          action;
    ULONG                   size;
    UCHAR                   i;


    logEntry = IoAllocateErrorLogEntry(EcData->DeviceObject,
                                       ERROR_LOG_MAXIMUM_SIZE);

    if (!logEntry) {
        EcPrint (EC_ERROR, ("AcpiEcLogError: Couldn't write error to errorlog\n"));
        return;
    }

    RtlZeroMemory(logEntry, ERROR_LOG_MAXIMUM_SIZE);

    //
    // Fill out the packet
    //
    logEntry->DumpDataSize          = (USHORT) ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET);
    logEntry->NumberOfStrings       = 0;
    logEntry->ErrorCode             = ErrCode;

    //
    // Fill in data
    //
    logEntry->DumpData[0] = EcData->PerformanceFrequency.LowPart;
    action = (PACPIEC_ACTION) (&logEntry->DumpData[1]);
    size = sizeof(IO_ERROR_LOG_PACKET) + sizeof(logEntry->DumpData[0]) + sizeof(ACPIEC_ACTION);

    i = EcData->LastAction;
    while (size <= ERROR_LOG_MAXIMUM_SIZE) {
        RtlCopyMemory (action, &EcData->RecentActions[i], sizeof(ACPIEC_ACTION)); 

        i--;
        i &= ACPIEC_ACTION_COUNT_MASK;
        if (i == EcData->LastAction) {
            break;
        }
        action++;
        size += sizeof(ACPIEC_ACTION);
    }
    //
    // Submit error log packet
    //
    IoWriteErrorLogEntry(logEntry);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\handlers.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    handlers.c

Abstract:

    GPE and Operation Region handlers for the ACPI Embedded Controller Driver

Author:

    Bob Moore (Intel)

Environment:

Notes:


Revision History:

--*/

#include "ecp.h"

NTSTATUS
AcpiEcOpRegionCompletion (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    This routine starts or continues servicing the device's work queue

Arguments:

    DeviceObject    - EC device object
    Irp             - Completing Irp
    Context         - Not Used

Return Value:

    Status

--*/
{
    PACPI_OPREGION_CALLBACK completionHandler;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVOID                   completionContext;

    //
    // Grab the arguments from the irp
    //
    completionHandler = (PACPI_OPREGION_CALLBACK) irpSp->Parameters.Others.Argument1;
    completionContext = (PVOID) irpSp->Parameters.Others.Argument2;

    EcPrint(
        EC_HANDLER,
        ("AcpiEcOpRegionCompletion: Callback: %08lx Context: %08lx\n",
         completionHandler, completionContext )
        );

    //
    // What happened?
    //
    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        EcPrint(
            EC_ERROR,
            ("AcpiEcOpRegionCompletion: region IO failed: %x\n",
             Irp->IoStatus.Status)
            );

    }

    //
    // Invoke the AML interpreter's callback
    //
    (completionHandler)( completionContext );

    //
    // We are done with this irp and the irp
    //
    IoFreeIrp( Irp );

    //
    // Return always return this --- because had to free the irp
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
EXPORT
AcpiEcOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

    This routine handles requests to service the EC operation region

Arguments:

    AccessType          - Read or Write data
    OpRegion            - Operation region object
    Address             - Address within the EC address space
    Size                - Number of bytes to transfer
    Data                - Data buffer to transfer to/from
    Context             - EcData
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler

Return Value:

    Status

Notes:

    Optimization 1: Queue the IRP directly.
    Optimization 2: Queue the context, modify service loop handle it

--*/
{
    LARGE_INTEGER       startingOffset;
    NTSTATUS            status;
    PECDATA             ecData = (PECDATA) Context;
    PIO_STACK_LOCATION  irpSp;
    PIRP                irp;

    EcPrint(
        (EC_HANDLER | EC_OPREGION),
        ("AcpiEcOpRegionHandler: %s Addr=%x Data = %x EcData=%x, Irql=%x\n",
         (AccessType == ACPI_OPREGION_READ ? "read" : "write"),
         Address, *Data, ecData, KeGetCurrentIrql() )
        );

    //
    // Parameter validation will be done in AcpiEcReadWrite
    //

    //
    // Determine where the read will occur
    //
    startingOffset.LowPart = Address;
    startingOffset.HighPart = 0;

    //
    // Allocate an IRP for ourselves. Since we are going to send this
    // irp to ourselves, we know that we only need 1 stack location for it
    // However, to make life easier for ourselves, we will allocate a
    // second one as well and store some data on it.
    //
    irp = IoAllocateIrp( 2, FALSE );
    if (!irp) {

        EcPrint(EC_ERROR, ("AcpiEcOpRegionHandler: Couldn't allocate Irp\n"));
        
        //
        // Retun -1 for data
        //
        RtlFillMemory (Data, Size, 0xff);
        CompletionHandler( CompletionContext );

        //
        // Always return STATUS_PENDING because ACPI interpreter doesn't handle errors.
        //
        return STATUS_PENDING;

    }

    //
    // Fill in the top location so that we can use it ourselves
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.Others.Argument1 = (PVOID) CompletionHandler;
    irpSp->Parameters.Others.Argument2 = (PVOID) CompletionContext;
    IoSetNextIrpStackLocation( irp );

    //
    // Fill out the irp with the request info
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (AccessType == ACPI_OPREGION_READ ? IRP_MJ_READ : IRP_MJ_WRITE);
    irpSp->Parameters.Read.ByteOffset.HighPart = 0;
    irpSp->Parameters.Read.ByteOffset.LowPart = Address;
    irpSp->Parameters.Read.Length = Size;
    irp->AssociatedIrp.SystemBuffer = Data;

    //
    // Set a completion routine
    //
    IoSetCompletionRoutine(
        irp,
        AcpiEcOpRegionCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Send to the front-end of the EC driver as a normal I/O request
    //
    status = IoCallDriver( ecData->DeviceObject, irp);
    EcPrint(
        EC_HANDLER,
        ("AcpiEcOpRegionHandler: Exiting - Data=%08lx Status=%08lx\n",
         (UCHAR) *Data, status)
        );

    return STATUS_PENDING;
    //
    // Always return STATUS_PENDING since actual status has been returned
    // by the calback function.
    //
}



BOOLEAN
AcpiEcGpeServiceRoutine (
        IN PVOID GpeVectorObject,
        IN PVOID ServiceContext
    )
/*++

Routine Description:

    Routine to service the EC based on a General Purpose Event

Arguments:

    GpeVectorObject     - Object associated with this GPE
    ServiceContext      - EcData

Return Value:

    TRUE, since we always handle this GPE

--*/
{

    PECDATA EcData = (PECDATA) ServiceContext;

    EcPrint (EC_HANDLER, ("AcpiEcGpeServiceRoutine: Vobj=%Lx, EcData=%Lx\n",
                        GpeVectorObject, EcData));

    AcpiEcLogAction (EcData, EC_ACTION_INTERRUPT, 0);
    AcpiEcServiceDevice (EcData);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\cbattery.h ===
#ifndef _CBATTERY_H
#define _CBATTERY_H

/*
 * title:      cbattery.h
 *
 * purpose:    header for wdm kernel battery object
 *
 */



// HID USAGE PAGE NUMBERS
#define POWER_PAGE                      0x84
#define BATTERY_PAGE                    0x85

// HID USAGE NUMBERS (Power Page)
#define PRESENT_STATUS_ID               0x02
#define UPS_ID                          0x04
#define POWER_SUMMARY_ID                0x24
#define VOLTAGE_ID                      0x30
#define CURRENT_ID                      0x31
#define CONFIG_VOLTAGE_ID               0x40
#define CONFIG_CURRENT_ID               0x41
#define DELAY_BEFORE_SHUTDOWN_ID        0x57
#define SHUTDOWN_IMMINENT_ID            0x69
#define MANUFACTURER_ID                 0xfd
#define PRODUCT_ID                      0xfe
#define SERIAL_NUMBER_ID                0xff

// HID USAGE NUMBERS (Battery Page)
#define REMAINING_CAPACITY_LIMIT_ID     0x29
#define CAPACITY_MODE_ID                0x2c
#define BELOW_REMAINING_CAPACITY_ID     0x42
#define CHARGING_ID                     0x44
#define DISCHARGING_ID                  0x45
#define REMAINING_CAPACITY_ID           0x66
#define FULL_CHARGED_CAPACITY_ID        0x67
#define RUNTIME_TO_EMPTY_ID             0x68
#define DESIGN_CAPACITY_ID              0x83
#define MANUFACTURE_DATE_ID             0x85
#define ICHEMISTRY_ID                   0x89
#define WARNING_CAPACITY_LIMIT_ID       0x8c
#define GRANULARITY1_ID                 0x8d
#define GRANULARITY2_ID                 0x8e
#define OEM_INFO_ID                     0x8f
#define AC_PRESENT_ID                   0xd0


typedef enum {
    PRESENT_STATUS_INDEX,           // 0
    UPS_INDEX,                      // 1
    POWER_SUMMARY_INDEX,            // 2
    VOLTAGE_INDEX,                  // 3
    CURRENT_INDEX,                  // 4
    CONFIG_VOLTAGE_INDEX,           // 5
    CONFIG_CURRENT_INDEX,           // 6
    DELAY_BEFORE_SHUTDOWN_INDEX,    // 7
    SHUTDOWN_IMMINENT_INDEX,        // 8
    MANUFACTURER_INDEX,             // 9
    PRODUCT_INDEX,                  // a
    SERIAL_NUMBER_INDEX,            // b
    REMAINING_CAPACITY_LIMIT_INDEX, // c
    CAPACITY_MODE_INDEX,            // d
    BELOW_REMAINING_CAPACITY_INDEX, // e
    CHARGING_INDEX,                 // f
    DISCHARGING_INDEX,              // 10
    REMAINING_CAPACITY_INDEX,       // 11
    FULL_CHARGED_CAPACITY_INDEX,    // 12
    RUNTIME_TO_EMPTY_INDEX,         // 13
    DESIGN_CAPACITY_INDEX,          // 14
    MANUFACTURE_DATE_INDEX,         // 15
    CHEMISTRY_INDEX,                // 16
    WARNING_CAPACITY_LIMIT_INDEX,   // 17
    GRANULARITY1_INDEX,             // 18
    GRANULARITY2_INDEX,             // 19
    OEM_INFO_INDEX,                 // 1a
    AC_PRESENT_INDEX,               // 1b
    MAX_USAGE_INDEXS                // 1c
} USAGE_INDEX;

typedef struct {
    USAGE       Page;
    USAGE       UsageID;
} USAGE_ENTRY;

extern USAGE_ENTRY UsageArray[];


class CBattery
{

public:  // accessors
    CBattery(CHidDevice *);
    ~CBattery();
    NTSTATUS        RefreshStatus();
    bool            InitValues();                    // initialize static values from device
    bool            GetSetValue(USAGE_INDEX, PULONG, bool);
    CUString *      GetCUString(USAGE_INDEX);
    ULONG           GetUnit(USAGE_INDEX);
    SHORT           GetExponent(USAGE_INDEX);
    CUsage *        GetUsage(USAGE_INDEX);
public: // members
    PVOID           m_pBatteryClass;         // Battery Class handle
    CHidDevice *    m_pCHidDevice;           // the hid device for this battery
    BOOLEAN         m_bIsCacheValid;         // Is cached battery info currently valid?

    //
    // Battery
    //
    BOOLEAN                     m_bRelative;    // indicates capacity in percent or absolute values
    ULONGLONG                   m_RefreshTime;
    BATTERY_STATUS              m_BatteryStatus;
    BATTERY_INFORMATION         m_BatteryInfo;
    PBATTERY_NOTIFY             m_pBatteryNotify;
    USHORT                      m_Tag;
    CUString *                  m_pSerialNumber;
    CUString *                  m_pOEMInformation;
    CUString *                  m_pProduct;
    CUString *                  m_pManufacturer;
    BATTERY_MANUFACTURE_DATE    m_ManufactureDate;
};

#endif // cbattery.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\cbattery.cpp ===
/*
 * title:      cbattery.cpp
 *
 * purpose:    wdm kernel implementation for battery object classes
 *
 * initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * windows 98 support
 *
 */
#include "hidbatt.h"

static USHORT gBatteryTag = 0;

USAGE_ENTRY UsageArray[MAX_USAGE_INDEXS] = {
    { POWER_PAGE, PRESENT_STATUS_ID},
    { POWER_PAGE, UPS_ID },
    { POWER_PAGE, POWER_SUMMARY_ID },
    { POWER_PAGE, VOLTAGE_ID },
    { POWER_PAGE, CURRENT_ID },
    { POWER_PAGE, CONFIG_VOLTAGE_ID },
    { POWER_PAGE, CONFIG_CURRENT_ID },
    { POWER_PAGE, DELAY_BEFORE_SHUTDOWN_ID },
    { POWER_PAGE, SHUTDOWN_IMMINENT_ID },
    { POWER_PAGE, MANUFACTURER_ID },
    { POWER_PAGE, PRODUCT_ID },
    { POWER_PAGE, SERIAL_NUMBER_ID },
    { BATTERY_PAGE, REMAINING_CAPACITY_LIMIT_ID },
    { BATTERY_PAGE, CAPACITY_MODE_ID},
    { BATTERY_PAGE, BELOW_REMAINING_CAPACITY_ID },
    { BATTERY_PAGE, CHARGING_ID },
    { BATTERY_PAGE, DISCHARGING_ID },
    { BATTERY_PAGE, REMAINING_CAPACITY_ID },
    { BATTERY_PAGE, FULL_CHARGED_CAPACITY_ID },
    { BATTERY_PAGE, RUNTIME_TO_EMPTY_ID},
    { BATTERY_PAGE, DESIGN_CAPACITY_ID },
    { BATTERY_PAGE, MANUFACTURE_DATE_ID },
    { BATTERY_PAGE, ICHEMISTRY_ID },
    { BATTERY_PAGE, WARNING_CAPACITY_LIMIT_ID },
    { BATTERY_PAGE, GRANULARITY1_ID },
    { BATTERY_PAGE, GRANULARITY2_ID },
    { BATTERY_PAGE, OEM_INFO_ID },
    { BATTERY_PAGE, AC_PRESENT_ID }
};




CBattery::CBattery(CHidDevice *)
{
    RtlZeroMemory(&m_BatteryStatus, sizeof(BATTERY_STATUS));
    RtlZeroMemory(&m_BatteryInfo,sizeof(BATTERY_INFORMATION));
    m_pBatteryClass = NULL;
    m_Tag = ++gBatteryTag;
    m_RefreshTime = 0;
    m_bRelative = FALSE;
}

CBattery::~CBattery()
{
    // delete hid device if present
    if(m_pCHidDevice) {
        delete m_pCHidDevice;
        m_pCHidDevice = NULL;
    }
    if(m_pSerialNumber) {
        delete m_pSerialNumber;
        m_pSerialNumber = NULL;
    }
    if(m_pOEMInformation) {
        delete m_pOEMInformation;
        m_pOEMInformation = NULL;
    }
    if(m_pProduct) {
        delete m_pProduct;
        m_pProduct = NULL;
    }
    if(m_pManufacturer) {
        delete m_pManufacturer;
        m_pManufacturer = NULL;
    }
}

bool CBattery::InitValues()
{
    bool     bResult;
    ULONG    ulReturnValue = 0;
    ULONG    ulValue;
    CUString *    pChemString;
    NTSTATUS ntStatus;
    SHORT     sExponent;

    // initialize the static data structures
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    // Init Values
    // start with the info structure
    m_BatteryInfo.Capabilities = BATTERY_SYSTEM_BATTERY |
                                 BATTERY_IS_SHORT_TERM;
    // get CapacityMode, find out what style of reporting is used
    bResult = GetSetValue(CAPACITY_MODE_INDEX,&ulReturnValue,FALSE);
    if (ulReturnValue == 2) {
        m_BatteryInfo.Capabilities |= BATTERY_CAPACITY_RELATIVE;
        m_bRelative = TRUE;
    }

    // now get voltage for use in amperage to watt calculations
    // get voltage
    bResult = GetSetValue(VOLTAGE_INDEX, &ulValue,FALSE);
    if(!bResult)
    {
        bResult = GetSetValue(CONFIG_VOLTAGE_INDEX,&ulValue,FALSE);
        sExponent = GetExponent(CONFIG_VOLTAGE_INDEX);
        if(!bResult) {
            ulValue = 24;
            sExponent = 0;
        }
    } else
    {
        sExponent = GetExponent(VOLTAGE_INDEX);
    }

    ULONG ulNewValue = CorrectExponent(ulValue,sExponent, 4); // HID exponent for millivolts is 4
    m_BatteryStatus.Voltage = ulNewValue;

    // HID unit is typically Volt
    // designed capacity
    bResult = GetSetValue(DESIGN_CAPACITY_INDEX, &ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : BATTERY_UNKNOWN_VOLTAGE;
    if (m_bRelative) {
        m_BatteryInfo.DesignedCapacity = ulValue;  // in percent
    } else {
        // must convert to millwatts from centiAmp
        sExponent = GetExponent(DESIGN_CAPACITY_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        m_BatteryInfo.DesignedCapacity = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    // Technology
    m_BatteryInfo.Technology = 1; // secondary, rechargeable battery
    // init static strings from device
    // Chemistry
    pChemString = GetCUString(CHEMISTRY_INDEX);
    if (pChemString) {
        // make into ascii
        char * pCString;
        ntStatus = pChemString->ToCString(&pCString);
        if (NT_ERROR(ntStatus)) {
            RtlZeroMemory(&m_BatteryInfo.Chemistry,sizeof(m_BatteryInfo.Chemistry));
        } else {
            RtlCopyMemory(&m_BatteryInfo.Chemistry, pCString,sizeof(m_BatteryInfo.Chemistry));
            ExFreePool(pCString);
        }
    } else {
        RtlZeroMemory(&m_BatteryInfo.Chemistry,sizeof(m_BatteryInfo.Chemistry));
    }
    delete pChemString;

    // serial number string
    m_pSerialNumber = GetCUString(SERIAL_NUMBER_INDEX);
    HidBattPrint (HIDBATT_TRACE, ("GetCUString (Serial Number) returned - Serial = %08x\n", m_pSerialNumber));
    if (m_pSerialNumber) {
        HidBattPrint (HIDBATT_TRACE, ("     Serial # = %s\n", m_pSerialNumber));
    }

    // OEMInformation
    m_pOEMInformation = GetCUString(OEM_INFO_INDEX);

    m_pProduct = GetCUString(PRODUCT_INDEX);

    m_pManufacturer = GetCUString(MANUFACTURER_INDEX);

    bResult = GetSetValue(MANUFACTURE_DATE_INDEX, &ulReturnValue,FALSE);
    if (bResult) {
        // make conformant date
        m_ManufactureDate.Day = (UCHAR) ulReturnValue & 0x1f; // low nibble is day
        m_ManufactureDate.Month = (UCHAR) ((ulReturnValue & 0x1e0) >> 5); // high nibble is month
        m_ManufactureDate.Year = (USHORT) ((ulReturnValue & 0xfffe00) >> 9) + 1980; // high byte is year
    } else {
        // set mfr date to zeros
        m_ManufactureDate.Day = m_ManufactureDate.Month = 0;
        m_ManufactureDate.Year = 0;
    }
    // FullChargedCapacity
    bResult = GetSetValue(FULL_CHARGED_CAPACITY_INDEX,&ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : m_BatteryInfo.DesignedCapacity;

    // if absolute must convert from ampsecs to millwatts
    if (!m_bRelative) {
        sExponent = GetExponent(FULL_CHARGED_CAPACITY_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    m_BatteryInfo.FullChargedCapacity = ulValue;


    BOOLEAN warningCapacityValid;
    BOOLEAN remainingCapacityValid;

    // DefaultAlert2
    bResult = GetSetValue(WARNING_CAPACITY_LIMIT_INDEX, &ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : 0;
    warningCapacityValid = bResult;
    if (!m_bRelative) {
        sExponent = GetExponent(WARNING_CAPACITY_LIMIT_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    m_BatteryInfo.DefaultAlert2 = ulValue; // also in ampsecs (millwatts?)


    // DefaultAlert1
    bResult = GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,&ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : 0; // also in ampsecs (millwatts?)
    remainingCapacityValid = bResult;

    //
    // Hack to allow STOP_DEVICE
    // Since Default Alert 1 is only valid initially, after the device is
    // stopped and restarted this data from the device is invalid, so we
    // must use cached data.
    //
    if (((CBatteryDevExt *) m_pCHidDevice->m_pDeviceObject->DeviceExtension)->m_ulDefaultAlert1 == (ULONG)-1) {
        ((CBatteryDevExt *) m_pCHidDevice->m_pDeviceObject->DeviceExtension)->m_ulDefaultAlert1 = ulValue;
    } else {
        ulValue = ((CBatteryDevExt *) m_pCHidDevice->m_pDeviceObject->DeviceExtension)->m_ulDefaultAlert1;
    }

    if (!m_bRelative) {
        sExponent = GetExponent(REMAINING_CAPACITY_LIMIT_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    m_BatteryInfo.DefaultAlert1 = ulValue;

    if (warningCapacityValid && !remainingCapacityValid) {
        m_BatteryInfo.DefaultAlert1 = m_BatteryInfo.DefaultAlert2;
    } else if (!warningCapacityValid && remainingCapacityValid) {
        m_BatteryInfo.DefaultAlert2 = m_BatteryInfo.DefaultAlert1;
    }

    // pro forma initialization for unsupported members
    m_BatteryInfo.CriticalBias = 0;
    m_BatteryInfo.CycleCount = 0;
    return TRUE;

}

#define REFRESH_INTERVAL 80000000 // 10 million ticks per sec with 100 nanosec tics * 5 secs
// 8 seconds is my best guess for a reasonable interval - djk

NTSTATUS CBattery::RefreshStatus()
{
    ULONG     ulValue;
    ULONG     ulPowerState;
    bool      bResult;
    ULONGLONG CurrTime;
    SHORT     sExponent;
    ULONG      ulScaledValue,ulNewValue;
    LONG      ulMillWatts;
    ULONG     ulUnit;
    // insure that the values in the Battery Status are fresh for delivery

    // first get power state
    // build battery state mask
    //  or online, discharging,charging,and critical

    CurrTime = KeQueryInterruptTime();
    if(((CurrTime - m_RefreshTime) < REFRESH_INTERVAL) && m_bIsCacheValid)
    {
        return STATUS_SUCCESS;
    }

    m_bIsCacheValid = TRUE;
    m_RefreshTime = CurrTime;


    bResult = GetSetValue(AC_PRESENT_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading AC_PRESENT\n" ));
    }
    ulPowerState = ulValue ? BATTERY_POWER_ON_LINE : 0;

    bResult = GetSetValue(CURRENT_INDEX, &ulValue,FALSE);
    if (!bResult) {
        ulMillWatts = BATTERY_UNKNOWN_RATE;
    } else {
        // convert from amps to watts
        // must convert to millwatts from centiAmp
        sExponent = GetExponent(CURRENT_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,0);
        ulMillWatts = ulNewValue * m_BatteryStatus.Voltage;
        // now have millwatts
    }

    bResult = GetSetValue(DISCHARGING_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading DISCHARGING\n" ));
    }
    if(ulValue) // discharging
    {
        ulPowerState |= BATTERY_DISCHARGING;
        //This assumes that CURRENT is always positive and that
        //it's the right value to begin with.  Need to double check.

        if (ulMillWatts != BATTERY_UNKNOWN_RATE) {
            ulMillWatts = -ulMillWatts;
        }
        m_BatteryStatus.Rate = ulMillWatts;
        //m_BatteryStatus.Rate = BATTERY_UNKNOWN_RATE;
    } else
    {
        m_BatteryStatus.Rate = ulMillWatts;
        //m_BatteryStatus.Rate = BATTERY_UNKNOWN_RATE; // not discharging
    }

    bResult = GetSetValue(CHARGING_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading CHARGING\n" ));
    }
    ulPowerState |= ulValue ? BATTERY_CHARGING : 0;

    bResult = GetSetValue(SHUTDOWN_IMMINENT_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading SHUTDOWN_IMMINENT\n" ));
    }
    ulPowerState |= ulValue ? BATTERY_CRITICAL : 0;

    m_BatteryStatus.PowerState = ulPowerState;

    // next capacity
    bResult = GetSetValue(REMAINING_CAPACITY_INDEX,&ulValue,FALSE);
    // check if relative or absolute
    if(!m_bRelative && bResult && m_BatteryStatus.Voltage)
    {
        sExponent = GetExponent(REMAINING_CAPACITY_INDEX);
        ulValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulValue,m_BatteryStatus.Voltage);

    }

    m_BatteryStatus.Capacity = bResult ? ulValue : BATTERY_UNKNOWN_CAPACITY;


    return STATUS_SUCCESS;
}

CUString * CBattery::GetCUString(USAGE_INDEX eUsageIndex)
{
    NTSTATUS ntStatus;
    ULONG    ulBytesReturned;
    USHORT    usBuffLen = 100; // arbitary size to pick up battery strings
    // build path to to power summary usage
    CUsagePath * pThisPath = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[UPS_INDEX].Page,
                        UsageArray[UPS_INDEX].UsageID);
    if(!pThisPath) return NULL;

    pThisPath->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[POWER_SUMMARY_INDEX].Page,
                        UsageArray[POWER_SUMMARY_INDEX].UsageID);
    if(!pThisPath->m_pNextEntry) return NULL;

    // is this one of the values in presentstatus ?
    pThisPath->m_pNextEntry->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[eUsageIndex].Page,
                        UsageArray[eUsageIndex].UsageID);
    if(!pThisPath->m_pNextEntry->m_pNextEntry) return NULL;

    CUsage *  pThisUsage = m_pCHidDevice->FindUsage(pThisPath, READABLE);
    delete pThisPath; // clean up
    if(!pThisUsage) return NULL;
    PVOID pBuffer = ExAllocatePoolWithTag(NonPagedPool, usBuffLen, HidBattTag);  // allocate a scratch buffer rather than consume stack
    if(!pBuffer) return NULL;
    ntStatus = pThisUsage->GetString((char *) pBuffer, usBuffLen, &ulBytesReturned);
    if(!NT_SUCCESS(ntStatus)) {
        ExFreePool(pBuffer);
        return NULL;
    }
    // create a custring to return
    CUString * pTheString = new (NonPagedPool, HidBattTag) CUString((PWSTR) pBuffer);
    if(!pTheString) return NULL;

    // free our temp buffer
    ExFreePool(pBuffer);
    return pTheString;
}

SHORT CBattery::GetExponent(USAGE_INDEX eUsageIndex)
{
    SHORT exponent;

    CUsage * pThisUsage = GetUsage(eUsageIndex);
    if(!pThisUsage) return 0;

    exponent = pThisUsage->GetExponent();
    HidBattPrint (HIDBATT_DATA, ("HidBattGetExponent: Exponent for USAGE_INDEX_0x%x = 0x%08x\n", eUsageIndex, exponent));

    return exponent;
}

CUsage * CBattery::GetUsage(USAGE_INDEX eUsageIndex)
{
    CUsagePath * pCurrEntry;
    bool bResult;
// build path to to power summary usage
    CUsagePath * pThisPath = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[UPS_INDEX].Page,
                        UsageArray[UPS_INDEX].UsageID);
    if (!pThisPath) return NULL;

    pThisPath->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[POWER_SUMMARY_INDEX].Page,
                        UsageArray[POWER_SUMMARY_INDEX].UsageID);
    if (!pThisPath->m_pNextEntry) return NULL;

    pCurrEntry = pThisPath->m_pNextEntry;
    // check if need to tack on presentstatus collection to path
    if(eUsageIndex == AC_PRESENT_INDEX ||
        eUsageIndex == DISCHARGING_INDEX ||
        eUsageIndex == CHARGING_INDEX ||
        eUsageIndex == BELOW_REMAINING_CAPACITY_INDEX ||
        eUsageIndex == CURRENT_INDEX)
    {
        pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag)
                CUsagePath(UsageArray[PRESENT_STATUS_INDEX].Page,
                            UsageArray[PRESENT_STATUS_INDEX].UsageID);
       if (!pCurrEntry->m_pNextEntry) return NULL;

     pCurrEntry = pCurrEntry->m_pNextEntry;
    }

    pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[eUsageIndex].Page,
                        UsageArray[eUsageIndex].UsageID);
    if (!pCurrEntry->m_pNextEntry) return NULL;

    CUsage *  pThisUsage = m_pCHidDevice->FindUsage(pThisPath, READABLE);
    delete pThisPath; // clean up
    return pThisUsage;
}

ULONG CBattery::GetUnit(USAGE_INDEX eUsageIndex)
{
    CUsage * pThisUsage = GetUsage(eUsageIndex);
    if(!pThisUsage) return 0;
    return pThisUsage->GetUnit();
}

bool CBattery::GetSetValue(USAGE_INDEX eUsageIndex, PULONG ulResult, bool bWriteFlag)
{
    bool    bResult;
    CUsagePath * pCurrEntry;

// build path to to power summary usage
    CUsagePath * pThisPath = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[UPS_INDEX].Page,
                        UsageArray[UPS_INDEX].UsageID);
    if (!pThisPath) return FALSE;

    pThisPath->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[POWER_SUMMARY_INDEX].Page,
                        UsageArray[POWER_SUMMARY_INDEX].UsageID);
    if (!pThisPath->m_pNextEntry) return FALSE;

    pCurrEntry = pThisPath->m_pNextEntry;
    // check if need to tack on presentstatus collection to path
    if(eUsageIndex == AC_PRESENT_INDEX ||
        eUsageIndex == DISCHARGING_INDEX ||
        eUsageIndex == CHARGING_INDEX ||
        eUsageIndex == BELOW_REMAINING_CAPACITY_INDEX ||
        eUsageIndex == CURRENT_INDEX ||
        eUsageIndex == SHUTDOWN_IMMINENT_INDEX)
    {
        pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag)
                CUsagePath(UsageArray[PRESENT_STATUS_INDEX].Page,
                            UsageArray[PRESENT_STATUS_INDEX].UsageID);
        if (!pCurrEntry->m_pNextEntry) return FALSE;

        pCurrEntry = pCurrEntry->m_pNextEntry;
    }

    pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[eUsageIndex].Page,
                        UsageArray[eUsageIndex].UsageID);
    if (!pCurrEntry->m_pNextEntry) return FALSE;

    CUsage *  pThisUsage = m_pCHidDevice->FindUsage(pThisPath, READABLE);
    delete pThisPath; // clean up
    if(!pThisUsage) return FALSE;
    if(bWriteFlag) // this is a write
    {
        bResult = pThisUsage->SetValue(*ulResult);
        if(!bResult) return bResult;
    } else
    {
        // this is a read
        bResult = pThisUsage->GetValue();
        if(!bResult) return bResult;
        *ulResult = pThisUsage->m_Value;

        HidBattPrint (HIDBATT_DATA, ("HidBattGetSetValue: Got USAGE_INDEX_0x%x = 0x%08x\n", eUsageIndex, *ulResult ));

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\ec\ecpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ecpnp.c

Abstract:

    ACPI Embedded Controller Driver, Plug and Play support

Author:

    Bob Moore (Intel)

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "ecp.h"

//
// List of FDOs managed by this driver
//
extern PDEVICE_OBJECT       FdoList;

//
// Table of direct-call interfaces into the ACPI driver
//
ACPI_INTERFACE_STANDARD     AcpiInterfaces;



NTSTATUS
AcpiEcIoCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pdoIoCompletedEvent
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent be this driver.
    Context is the event to set.

--*/
{

   KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
AcpiEcAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each AcpiEc controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject       - a pointer to the object for this driver
    NewDeviceObject    - a pointer to where the FDO is placed

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT  fdo = NULL;
    PDEVICE_OBJECT  ownerDevice = NULL;
    PDEVICE_OBJECT  lowerDevice = NULL;
    PECDATA         EcData;
    NTSTATUS        status;


    PAGED_CODE();

    EcPrint(EC_LOW, ("AcpiEcAddDevice: Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        EcPrint(EC_LOW, ("AcpiEcAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Create and initialize the new functional device object
    //

    status = AcpiEcCreateFdo(DriverObject, &fdo);

    if (!NT_SUCCESS(status)) {

        EcPrint(EC_LOW, ("AcpiEcAddDevice - error creating Fdo\n"));
        return status;
    }

    //
    // Layer our FDO on top of the PDO
    //

    lowerDevice = IoAttachDeviceToDeviceStack(fdo,Pdo);

    //
    // No status. Do the best we can.
    //
    ASSERT(lowerDevice);

    EcData = fdo->DeviceExtension;
    EcData->LowerDeviceObject = lowerDevice;
    EcData->Pdo = Pdo;

    //
    // Allocate and hold an IRP for Query notifications and miscellaneous
    //
    EcData->QueryRequest    = IoAllocateIrp (EcData->LowerDeviceObject->StackSize, FALSE);
    EcData->MiscRequest     = IoAllocateIrp (EcData->LowerDeviceObject->StackSize, FALSE);

    if ((!EcData->QueryRequest) || (!EcData->MiscRequest)) {
        //
        // NOTE: This failure case and other failure cases below should do
        // cleanup of all previous allocations, etc performed in this function.
        //

        EcPrint(EC_ERROR, ("AcpiEcAddDevice: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Link this fdo to the list of fdo's managed by the driver
    // (Probably overkill since there will be only one FDO)
    //
    //
    EcPrint(EC_LOW, ("AcpiEcAddDevice: linking fdo to list\n"));
    EcData->NextFdo = FdoList;
    InterlockedExchangePointer((PVOID *) &FdoList, fdo);

    //
    // Initialize the Timeout DPC
    //

    KeInitializeTimer(&EcData->WatchdogTimer);
    KeInitializeDpc(&EcData->WatchdogDpc, AcpiEcWatchdogDpc, EcData);
    
    //
    // Get the GPE vector assigned to this device
    //

    status = AcpiEcGetGpeVector (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_LOW, ("AcpiEcAddDevice: Could not get GPE vector, status = %Lx\n", status));
        return status;
    }

    //
    // Get the direct-call ACPI interfaces.
    //

    status = AcpiEcGetAcpiInterfaces (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_LOW, ("AcpiEcAddDevice: Could not get ACPI driver interfaces, status = %Lx\n", status));
        return status;
    }

    //
    // Final flags
    //

    fdo->Flags &= ~DO_DEVICE_INITIALIZING;
    fdo->Flags |= DO_POWER_PAGABLE;             // Don't want power Irps at irql 2

    return STATUS_SUCCESS;
}



NTSTATUS
AcpiEcCreateFdo(
    IN PDRIVER_OBJECT   DriverObject,
    OUT PDEVICE_OBJECT  *NewDeviceObject
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Embedded controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    DeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    UNICODE_STRING  unicodeString;
    PDEVICE_OBJECT  deviceObject;
    NTSTATUS        Status;
    PECDATA         EcData;

    PAGED_CODE();

    EcPrint(EC_LOW, ("AcpiEcCreateFdo: Entry\n") );

    RtlInitUnicodeString(&unicodeString, L"\\Device\\ACPIEC");

    Status = IoCreateDevice(
                DriverObject,
                sizeof (ECDATA),
                &unicodeString,
                FILE_DEVICE_UNKNOWN,    // DeviceType
                0,
                FALSE,
                &deviceObject
                );

    if (Status != STATUS_SUCCESS) {
        EcPrint(EC_LOW, ("AcpiEcCreateFdo: unable to create device object: %X\n", Status));
        return(Status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;
    deviceObject->StackSize = 1;

    //
    // Initialize EC device extension data
    //

    EcData = (PECDATA) deviceObject->DeviceExtension;
    EcData->DeviceObject        = deviceObject;
    EcData->DeviceState         = EC_DEVICE_WORKING;
    EcData->QueryState          = EC_QUERY_IDLE;
    EcData->IoState             = EC_IO_NONE;
    EcData->IsStarted           = FALSE;
    EcData->MaxBurstStall       = 50;
    EcData->MaxNonBurstStall    = 10;
    EcData->InterruptEnabled    = TRUE;
    EcData->ConsecutiveFailures = 0;
    KeQueryPerformanceCounter (&EcData->PerformanceFrequency);
    RtlFillMemory (EcData->RecentActions, ACPIEC_ACTION_COUNT * sizeof(ACPIEC_ACTION), 0);

    //
    // Initialize EC global synchronization objects
    //

    InitializeListHead (&EcData->WorkQueue);
    KeInitializeEvent (&EcData->Unload, NotificationEvent, FALSE);
    KeInitializeSpinLock (&EcData->Lock);


    *NewDeviceObject = deviceObject;
    return STATUS_SUCCESS;

}



NTSTATUS
AcpiEcPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PECDATA             EcData;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    EcData = DeviceObject->DeviceExtension;

    EcPrint (EC_NOTE, ("AcpiEcPnpDispatch: PnP dispatch, minor = %d\n",
                        irpStack->MinorFunction));

    //
    // Dispatch minor function
    //

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE: {
            status = AcpiEcStartDevice (DeviceObject, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

    //
    // We will never allow the EC driver to stop once it is started.
    //
    // Note:  Stop and remove device should be implemented so that the driver
    // can be unloaded without reboot.  Even if the device can't be removed, it
    // will get an IRP_MN_REMOVE_DEVICE if somthing goes wrong trying to start
    // the device.
    //
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_REMOVE_DEVICE:

        status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:
        Irp->IoStatus.Status = STATUS_SUCCESS;
        AcpiEcCallLowerDriver(status, EcData->LowerDeviceObject, Irp);
        break;

#if 0
    case IRP_MN_STOP_DEVICE: {
            status = AcpiEcStopDevice(DeviceObject, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }
#endif
    case IRP_MN_QUERY_DEVICE_RELATIONS: {

            EcPrint(EC_LOW, ("AcpiEcPnp: IRP_MJ_QUERY_DEVICE_RELATIONS  Type:  %d\n",
                        irpStack->Parameters.QueryDeviceRelations.Type));

            //
            // Just pass it down to ACPI
            //

            AcpiEcCallLowerDriver(status, EcData->LowerDeviceObject, Irp);
            break;
        }

    default: {

            //
            // Unimplemented minor, Pass this down to ACPI
            //

            EcPrint(EC_LOW, ("AcpiEcPnp: Unimplemented PNP minor code %d, forwarding\n",
                    irpStack->MinorFunction));

            AcpiEcCallLowerDriver(status, EcData->LowerDeviceObject, Irp);
            break;
        }
    }


    return status;
}


NTSTATUS
AcpiEcGetResources(
    IN PCM_RESOURCE_LIST    ResourceList,
    IN PECDATA              EcData
    )
/*++

Routine Description:
    Get the resources already allocated and pointed to by the PDO.

Arguments:

    ResourceList    - Pointer to the resource list.
    EcData          - Pointer to the extension.

Return Value:

    Status is returned.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDesc;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
    ULONG                           i;
    PUCHAR                          port[2] = {NULL, NULL};


    PAGED_CODE();


    if (ResourceList == NULL) {
        EcPrint(EC_LOW, ("AcpiEcGetResources: Null resource pointer\n"));

        return STATUS_NO_MORE_ENTRIES;
    }

    if (ResourceList->Count <= 0 ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Traverse the resource list
    //

    fullResourceDesc=&ResourceList->List[0];
    partialResourceList = &fullResourceDesc->PartialResourceList;
    partialResourceDesc = partialResourceList->PartialDescriptors;

    for (i=0; i<partialResourceList->Count; i++, partialResourceDesc++) {

        if (partialResourceDesc->Type == CmResourceTypePort) {

            port[i] = (PUCHAR)((ULONG_PTR)partialResourceDesc->u.Port.Start.LowPart);
        }
    }

    //
    // Get the important things
    //

    EcData->StatusPort  = port[1];          // Status port same as Command port
    EcData->CommandPort = port[1];
    EcData->DataPort    = port[0];

    EcPrint(EC_LOW, ("AcpiEcGetResources: Status/Command port %x, Data port %x\n", port[1], port[0]));

    return STATUS_SUCCESS;
 }


NTSTATUS
AcpiEcStartDevice(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
    )
/*++

Routine Description:
    Start a device

Arguments:

    Fdo    - Pointer to the Functional Device Object.
    Irp    - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS            status;
    PECDATA             EcData = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);


    EcPrint(EC_LOW, ("AcpiEcStartDevice: Entered with fdo %x\n", Fdo));

    //
    // Always send this down to the PDO first
    //

    status = AcpiEcForwardIrpAndWait (EcData, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (EcData->IsStarted) {

        //
        // Device is already started
        //

        EcPrint(EC_WARN, ("AcpiEcStartDevice: Fdo %x already started\n", Fdo));
        return STATUS_SUCCESS;
    }

    //
    // Parse AllocatedResources.
    //

    status = AcpiEcGetResources (irpStack->Parameters.StartDevice.AllocatedResources, EcData);
    if (!NT_SUCCESS(status)) {
        EcPrint(EC_ERROR, ("AcpiEcStartDevice: Could not get resources, status = %x\n", status));
        return status;
    }

    //
    // Connect to the dedicated embedded controller GPE
    //

    status = AcpiEcConnectGpeVector (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_ERROR, ("AcpiEcStartDevice: Could not attach to GPE vector, status = %Lx\n", status));
        return status;
    }
    EcPrint(EC_NOTE, ("AcpiEcStartDevice: Attached to GPE vector %d\n", EcData->GpeVector));

    //
    // Install the Operation Region handler
    //

    status = AcpiEcInstallOpRegionHandler (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_ERROR, ("AcpiEcStartDevice: Could not install Op region handler, status = %Lx\n", status));
        return status;
    }

    EcData->IsStarted = TRUE;
    return STATUS_SUCCESS;
}


NTSTATUS
AcpiEcStopDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description:
    Stop a device

Arguments:

    Fdo    - Pointer to the Functional Device Object.
    Irp    - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PECDATA             EcData = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;


    EcPrint(EC_LOW, ("AcpiEcStopDevice: Entered with fdo %x\n", Fdo));

    //
    // Always send this down to the PDO
    //

    status = AcpiEcForwardIrpAndWait (EcData, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!EcData->IsStarted) {
        //
        // Already stopped
        //

        return STATUS_SUCCESS;
    }

    //
    // Must disconnect from GPE
    //

    status = AcpiEcDisconnectGpeVector (EcData);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Must de-install Operation Region Handler
    //

    status = AcpiEcRemoveOpRegionHandler (EcData);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    EcPrint(EC_LOW, ("AcpiEcStopDevice: Detached from GPE and Op Region\n"));

    //
    // Now the device is stopped.
    //

    EcData->IsStarted = FALSE;          // Mark device stopped
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\ckhid.cpp ===
/*
 * title:      chid.cpp
 *
 * purpose:    wdm kernel implementation of a hid device class
 *
 */

// local prototypes

#include "hidbatt.h"

extern CHidDevice * pGlobalHidDevice[];

bool GetNextUsage(
        CHidDevice * pThisDevice,
        SHORT CollectionID,
        USHORT NodeIndex,
        USHORT usUsageIndex,
        CUsage ** Usage)

{

    int i;
    int UsageCounter = 0;
    // cycle through all the called out usages from the pHid structure


    // get feature usages
    for(i = 0; i < pThisDevice->m_pCaps->NumberFeatureValueCaps; i++)
    {
        if(pThisDevice->m_pHidDevice->FeatureValueCaps[i].LinkCollection == NodeIndex)    // cardinal
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag) CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pValueCaps = &pThisDevice->m_pHidDevice->FeatureValueCaps[i];
                pThisUsage->m_eType = eFeatureValue;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

    // ditto feature buttons
    for(i = 0; i < pThisDevice->m_pCaps->NumberFeatureButtonCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->FeatureButtonCaps[i].LinkCollection == NodeIndex    )
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag) CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pButtonCaps = &pThisDevice->m_pHidDevice->FeatureButtonCaps[i];
                pThisUsage->m_eType = eFeatureButton;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

     // ditto input values
    for(i = 0; i < pThisDevice->m_pCaps->NumberInputValueCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->InputValueCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag) CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pValueCaps = &pThisDevice->m_pHidDevice->InputValueCaps[i];
                pThisUsage->m_eType = eInputValue;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

      // ditto input buttons
    for(i = 0; i < pThisDevice->m_pCaps->NumberInputButtonCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->InputButtonCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag)  CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pButtonCaps = &pThisDevice->m_pHidDevice->InputButtonCaps[i];
                pThisUsage->m_eType = eInputButton;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

    // ditto Output values
    for(i = 0; i < pThisDevice->m_pCaps->NumberOutputValueCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->OutputValueCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag)  CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pValueCaps = &pThisDevice->m_pHidDevice->OutputValueCaps[i];
                pThisUsage->m_eType = eOutputValue;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

      // ditto Output buttons
    for(i = 0; i < pThisDevice->m_pCaps->NumberOutputButtonCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->OutputButtonCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag)  CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pButtonCaps = &pThisDevice->m_pHidDevice->OutputButtonCaps[i];
                pThisUsage->m_eType = eOutputButton;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }
    return FALSE;
}

CTypeMask::CTypeMask()
{
    // set members to zero
    ReportType = 0;
    bWriteable = 0;
    bIsString = 0;
    bIsNumber = 0;
    bAlertable = 0;
    bVolatile = 0;
}


CProperties::CProperties(CUsage * pUsage)
{
    PHIDP_BUTTON_CAPS pButtCaps;     // fill in the properties for this usage
    PHIDP_VALUE_CAPS pValueCaps;
    switch( pUsage->m_eType)
    {
        case eFeatureButton:
        case eInputButton:
        case eOutputButton:
            pButtCaps = pUsage->m_pButtonCaps;
            m_UnitExponent = 0; // no exponents on buttons
            m_Unit = 0; // buttons don't have units
            m_LogicalMin = 0; // ditto for max and min pCaps->LogicalMin;
            m_LogicalMax = 0; // pCaps->LogicalMax;
            m_LinkCollection = pButtCaps->LinkCollection;
            m_ReportID = pButtCaps->ReportID;
            m_Usage = pButtCaps->NotRange.Usage;
            m_UsagePage = pButtCaps->UsagePage;
            break;
        case eFeatureValue:
        case eInputValue:
        case eOutputValue:
            pValueCaps = pUsage->m_pValueCaps;
            m_Unit = pValueCaps->Units;
            m_UnitExponent = (SHORT) pValueCaps->UnitsExp;
            m_LogicalMin = pValueCaps->LogicalMin;
            m_LogicalMax = pValueCaps->LogicalMax;
            m_LinkCollection = pValueCaps->LinkCollection;
            m_ReportID = pValueCaps->ReportID;
            m_Usage = pValueCaps->NotRange.Usage;
            m_UsagePage = pValueCaps->UsagePage;
            break;
    }
    // setup type mask
    m_pType = new (NonPagedPool, HidBattTag)  CTypeMask();
    if (m_pType) {
      if(pUsage->m_eType == eInputButton || pUsage->m_eType == eInputValue)
      {
          m_pType->SetAlertable();
      }

      // set writability


      if( pUsage->m_eType == eFeatureButton || pUsage->m_eType == eOutputButton)
      {
          if(pButtCaps->BitField & 0x01)
          {
              m_pType->SetIsWriteable();
          }
      } else if(pUsage->m_eType == eFeatureValue || pUsage->m_eType == eOutputValue)
      {
          if(pValueCaps->BitField & 0x01)
          {
              m_pType->SetIsWriteable();
          }
      }

      // set volatility
      if(pUsage->m_eType == eFeatureValue)
      {
          if(pValueCaps->BitField & 0x80)
          {
              m_pType->SetVolatile();
          }
      }
      if(pUsage->m_eType == eFeatureButton)
      {
          if(pButtCaps->BitField & 0x80)
          {
              m_pType->SetVolatile();
          }
      }
    
      switch(pUsage->m_eType)
      {
          case eFeatureButton:
          case eFeatureValue:
              m_pType->SetReportType(FeatureType);
              break;
          case eInputButton:
          case eInputValue:
              m_pType->SetReportType(InputType);
              break;
          case eOutputButton:
          case eOutputValue:
              m_pType->SetReportType(OutputType);
      }
      // set value to to number until I figure out how to do strings
      m_pType->SetIsNumber();
    }
}

CProperties::~CProperties()
{
    if (m_pType) {
        delete m_pType;
        m_pType = NULL;
    }
    return;
}

CUsagePath::CUsagePath(USAGE UsagePage, USAGE UsageID, CUsage * pThisUsage)
{
    // init members
    m_UsagePage = UsagePage;
    m_UsageNumber    = UsageID;
    m_pUsage = pThisUsage;
    m_pNextEntry = NULL;
    return;
}


CHidDevice::CHidDevice()
{

    // clear out usage arrays
    for(int i = 0; i<MAXREPORTID; i++)
    {
        m_InputUsageArrays[i] = NULL;
        m_FeatureBuffer[i] = NULL;
        m_ReportIdArray[i] = 0;
    }
    m_pThreadObject = NULL;
    m_pReadBuffer = NULL;
    m_pEventHandler = 0;
}


bool CHidDevice::OpenHidDevice(PDEVICE_OBJECT pDeviceObject)
{
    NTSTATUS                    ntStatus;
    ULONG                       ulNodeCount;
    bool                        bResult;
    HID_COLLECTION_INFORMATION  collectionInformation;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint(HIDBATT_TRACE,("CHidDevice::OpenHidDevice\n"));

    // first get collection information for this device

    ntStatus = DoIoctl(
                pDeviceObject,
                IOCTL_HID_GET_COLLECTION_INFORMATION,
                NULL,
                0,
                &collectionInformation,
                sizeof(HID_COLLECTION_INFORMATION),
                (CHidDevice *) NULL
                );

    if(NT_ERROR(ntStatus))
    {
        return FALSE;
    }

    m_pPreparsedData = (PHIDP_PREPARSED_DATA)
                ExAllocatePoolWithTag(NonPagedPool,
                                      collectionInformation.DescriptorSize,
                                      HidBattTag);
    if(!m_pPreparsedData)
    {
        return FALSE;
    }

    ntStatus = DoIoctl(
                pDeviceObject,
                IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                NULL,
                0,
                m_pPreparsedData,
                collectionInformation.DescriptorSize,
                (CHidDevice *) NULL
                );

    if(NT_ERROR(ntStatus))
    {
        ExFreePool(m_pPreparsedData);
        return FALSE;
    }

    // init the caps structure

    m_pCaps = (PHIDP_CAPS) ExAllocatePoolWithTag (NonPagedPool,
                                                  sizeof(HIDP_CAPS),
                                                  HidBattTag);
    if(!m_pCaps)
    {
        ExFreePool(m_pPreparsedData);
        return FALSE;
    }
    RtlZeroMemory(m_pCaps,sizeof(HIDP_CAPS));

    ntStatus = HidP_GetCaps (m_pPreparsedData, m_pCaps);
    if (NT_ERROR(ntStatus))
    {
        ExFreePool(m_pPreparsedData);
        ExFreePool(m_pCaps);
        return FALSE;
    }

    // set usage page and usage for application level
    m_UsagePage = m_pCaps->UsagePage;
    m_UsageID = m_pCaps->Usage;
    // init the collection array
    ulNodeCount = m_pCaps->NumberLinkCollectionNodes;

    HIDP_LINK_COLLECTION_NODE * pLinkNodes = (HIDP_LINK_COLLECTION_NODE*)
                ExAllocatePoolWithTag (NonPagedPool,
                                       sizeof(HIDP_LINK_COLLECTION_NODE) * ulNodeCount,
                                       HidBattTag);

    if(!pLinkNodes) return FALSE;

    RtlZeroMemory(pLinkNodes,sizeof(HIDP_LINK_COLLECTION_NODE) * ulNodeCount );

    ntStatus = HidP_GetLinkCollectionNodes(
                    pLinkNodes,
                    &ulNodeCount,
                    m_pPreparsedData
                    );

    if(ntStatus != HIDP_STATUS_SUCCESS)
    {
        ExFreePool( m_pPreparsedData);
        ExFreePool(m_pCaps);
        ExFreePool(pLinkNodes);
        return FALSE;
    }


    // the following call will init all the collections in the device
    CCollectionArray * ThisArray = new (NonPagedPool, HidBattTag)  CCollectionArray(pLinkNodes,(USHORT)  ulNodeCount, -1);
    if (!ThisArray) {
      // Creation of the collection failed, return failure
      return FALSE;
    }

    m_CollectionArray = ThisArray;
    // have each collection fill in its usage array

    // this call uses KR's methods to access and setup his original hid structures.
    // ... This data is then used to populate the the hid device class structures

    m_pHidDevice = SetupHidData(
                  m_pPreparsedData,
                  m_pCaps,
                  pLinkNodes);

    for(int i = 0; i < ThisArray->m_CollectionCount; i++)
    {
        ThisArray->m_pCollections[i]->InitUsages(this);
    }

    ExFreePool(pLinkNodes);

    return TRUE;

}

CHidDevice::~CHidDevice()
{

    ULONG i;

    // release any allocated memory and cleanup

    if (m_pHidDevice) {
        if (m_pHidDevice->InputButtonCaps) {
            ExFreePool (m_pHidDevice->InputButtonCaps);
        }

        if (m_pHidDevice->InputValueCaps) {
            ExFreePool (m_pHidDevice->InputValueCaps);
        }

        if (m_pHidDevice->OutputButtonCaps) {
            ExFreePool (m_pHidDevice->OutputButtonCaps);
        }

        if (m_pHidDevice->OutputValueCaps) {
            ExFreePool (m_pHidDevice->OutputValueCaps);
        }

        if (m_pHidDevice->FeatureButtonCaps) {
            ExFreePool (m_pHidDevice->FeatureButtonCaps);
        }

        if (m_pHidDevice->FeatureValueCaps) {
            ExFreePool (m_pHidDevice->FeatureValueCaps);
        }

        ExFreePool (m_pHidDevice);
    }


    if(m_CollectionArray) {
        delete m_CollectionArray;
        m_CollectionArray = NULL;
    }

    for (i = 0; i < MAXREPORTID; i++) {
        if(m_InputUsageArrays[i]) {

            if (m_InputUsageArrays[i]->m_pUsages) {
                ExFreePool (m_InputUsageArrays[i]->m_pUsages);
            }

            ExFreePool (m_InputUsageArrays[i]);

            m_InputUsageArrays[i] = NULL;
        }
    }

    if(m_pReadBuffer) {
        ExFreePool (m_pReadBuffer);
        m_pReadBuffer = NULL;
    }

    for (i = 0; i < MAXREPORTID; i++) {
        if(m_FeatureBuffer[i]) {
            ExFreePool (m_FeatureBuffer[i]);
            m_FeatureBuffer[i] = NULL;
        }
    }

    if (m_pPreparsedData) {
        ExFreePool (m_pPreparsedData);
    }
    if (m_pCaps) {
        ExFreePool (m_pCaps);
    }

    return;
}


CUsage * CHidDevice::FindUsage(CUsagePath * PathToUsage, USHORT usType)
{
    int i = 0;
    CCollection * pActiveCollection = (CCollection *) NULL;
    CCollectionArray * pCurrentCArray = m_CollectionArray;
    // Index into collection array by usage page : usage id
    while(PathToUsage->m_pNextEntry)
    {
        // traversing a collection
        while( pCurrentCArray && i < pCurrentCArray->m_CollectionCount)
        {
            if(pCurrentCArray->m_pCollections[i]->m_UsagePage == PathToUsage->m_UsagePage &&
                pCurrentCArray->m_pCollections[i]->m_CollectionID == PathToUsage->m_UsageNumber)
            {
                // found a node, go down a level
                pActiveCollection = pCurrentCArray->m_pCollections[i];
                pCurrentCArray = pCurrentCArray->m_pCollections[i]->m_CollectionArray;

                i = 0;
                break;
            }
        i++;
        }
        if(i) return (CUsage *) NULL; // not found
        PathToUsage = PathToUsage->m_pNextEntry;

    }
    if(!pActiveCollection) return (CUsage *) NULL; // no collection found, shouldn't get here
    // got to the collection, check its usages
    CUsageArray * pCurrentUArray = pActiveCollection->m_UsageArray;
    if(!pCurrentUArray) return (CUsage *) NULL;
    // interate usage array
    for(i = 0; i < pCurrentUArray->m_UsageCount; i++)
    {

        if(pCurrentUArray->m_pUsages[i]->m_pProperties->m_Usage == PathToUsage->m_UsageNumber &&
                pCurrentUArray->m_pUsages[i]->m_pProperties->m_UsagePage == PathToUsage->m_UsagePage)
        {
            // got it !
            if(usType == WRITEABLE)    // writable returns feature and output usages
                if(pCurrentUArray->m_pUsages[i]->m_eType  == eFeatureValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eOutputValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eFeatureButton ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eOutputButton)
                    // return writeable usage !
                        return pCurrentUArray->m_pUsages[i];
            if(usType == READABLE)    // returns input and feature types
                if(pCurrentUArray->m_pUsages[i]->m_eType  == eFeatureValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eInputValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eFeatureButton ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eInputButton)

                    // return readable usage !
                        return pCurrentUArray->m_pUsages[i];
        }
    }
    return (CUsage *) NULL;
}

NTSTATUS CHidDevice::ActivateInput()
{
    NTSTATUS ntStatus;
    // init notification elements
    HidBattPrint(HIDBATT_TRACE, ("ActivateInput entered\n"));
    if(!m_pReadBuffer)
    {
        if (!m_pCaps->InputReportByteLength) {
            HidBattPrint(HIDBATT_ERROR, ("ActivateInput: InputReportByteLength = %08x; NumberInputButtonCaps = %08x; NumberInputValueCaps = %08x\n",
                         m_pCaps->InputReportByteLength,
                         m_pCaps->NumberInputButtonCaps,
                         m_pCaps->NumberInputValueCaps));

            //
            // This just means that the battery doesn't give notifications.
            //
            return STATUS_SUCCESS;
        }

        m_pReadBuffer = (PBYTE) ExAllocatePoolWithTag (NonPagedPool,
                                                       m_pCaps->InputReportByteLength,
                                                       HidBattTag);
        if(!m_pReadBuffer)
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    // init read event
    KeInitializeEvent(&m_kReadEvent,NotificationEvent,FALSE);

    ntStatus =  PsCreateSystemThread(
                OUT &m_hReadThread,
                IN THREAD_ALL_ACCESS,
                IN NULL,                // POBJECT_ATTRIBUTES  ObjectAttributes
                IN NULL,                // HANDLE  ProcessHandle
                OUT NULL,                // PCLIENT_ID  ClientId
                IN ReadThread,
                IN this
                );

    if(NT_ERROR(ntStatus))
    {
        // kill refresh loop, then break
        HidBattPrint(HIDBATT_TRACE, ("ActivateInput error, exiting - Status = %x\n",ntStatus));
        ExFreePool(m_pReadBuffer);
        m_pReadBuffer = NULL;
    }
    HidBattPrint(HIDBATT_TRACE, ("ActivateInput exiting = Status = %x\n",ntStatus));

    ntStatus = ObReferenceObjectByHandle (
            m_hReadThread,
            THREAD_ALL_ACCESS,
            NULL,
            KernelMode,
            &m_pThreadObject,
            NULL
            );

    if (!NT_SUCCESS (ntStatus)) {
        HidBattPrint(HIDBATT_ERROR, ("ActivateInput can't get thread object\n",ntStatus));
    }


    return ntStatus;
}

NTSTATUS ReadCompletionRoutine(PDEVICE_OBJECT pDO, PIRP pIrp,PVOID pContext)
{
    CHidDevice * pHidDevice = (CHidDevice *) pContext;
    HidBattPrint(HIDBATT_TRACE,("Read Completed, IO Status = %x\n",pIrp->IoStatus.Status));

    KeSetEvent(&pHidDevice->m_kReadEvent,0,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

void _stdcall ReadThread(PVOID pContext)
{


    USHORT usFailureCount = 0;
    // build a read irp for hid class
    USHORT              usEventIndex = 0;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PVOID               EventArray[2];
    PIO_STACK_LOCATION  pNewStack;
    CBatteryDevExt *    pDevExt;
    PMDL                mdl;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint(HIDBATT_TRACE,("Read Thread entered\n"));

    //
    // first get our "this"
    //
    CHidDevice * pHidDev = (CHidDevice *) pContext;

    pDevExt = (CBatteryDevExt *) pHidDev->m_pEventContext;

    //
    // Hold the remove lock so the remove routine doesn't cancel the irp while
    // we are playing with it.
    //
    if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
        goto ReadThreadCleanup1; // fail
    }

    //
    // Allocate Irp to be used and re-used
    //
    pHidDev->m_pReadIrp = IoAllocateIrp (pHidDev->m_pLowerDeviceObject->StackSize, FALSE);

    if(!pHidDev->m_pReadIrp) {
        goto ReadThreadCleanup1; // fail
    }

    //
    // Create MDL
    //
    mdl = IoAllocateMdl( pHidDev->m_pReadBuffer,
                        pHidDev->m_pCaps->InputReportByteLength,
                        FALSE,
                        FALSE,
                        (PIRP) NULL );
    if (!mdl) {
        goto ReadThreadCleanup2;
    }

    //
    // Lock IO buffer
    //
    __try {
        MmProbeAndLockPages( mdl,
                            KernelMode,
                            (LOCK_OPERATION) IoWriteAccess );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(ntStatus)) {
        goto ReadThreadCleanup3;
    }

    while (TRUE) {
        IoReuseIrp (pHidDev->m_pReadIrp, STATUS_SUCCESS);

        pHidDev->m_pReadIrp->Tail.Overlay.Thread = PsGetCurrentThread();
        pHidDev->m_pReadIrp->MdlAddress = mdl;

        IoSetCompletionRoutine(pHidDev->m_pReadIrp,ReadCompletionRoutine,pHidDev,TRUE,TRUE,TRUE);
        pNewStack= IoGetNextIrpStackLocation(pHidDev->m_pReadIrp);
        pNewStack->FileObject = pHidDev->m_pFCB;
        pNewStack->MajorFunction = IRP_MJ_READ;
        pNewStack->Parameters.Read.Length = pHidDev->m_pCaps->InputReportByteLength;
        pNewStack->Parameters.Read.ByteOffset.QuadPart = 0;

        KeResetEvent(&pHidDev->m_kReadEvent);

        ntStatus = IoCallDriver(pHidDev->m_pLowerDeviceObject,pHidDev->m_pReadIrp);

        //
        // Don't hold the lock while we are waiting for the IRP to complete.
        // The remove routine will cancel the irp if needed.
        //
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

        if (ntStatus == STATUS_PENDING)
        {
            KeWaitForSingleObject(
                        &pHidDev->m_kReadEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
            ntStatus = pHidDev->m_pReadIrp->IoStatus.Status;
        }

        // we awoke on a read completion
        HidBattPrint(HIDBATT_TRACE,("Read woke: status = 0x%08x\n", ntStatus));

        if(ntStatus != STATUS_SUCCESS)
        {
            if(ntStatus == STATUS_DEVICE_NOT_CONNECTED
                || ntStatus == STATUS_CANCELLED)
            {
                HidBattPrint(HIDBATT_ERROR,("Read Failure - Status = %x\n",ntStatus));
                break;
            }
            usFailureCount++;
            if(usFailureCount++ == 10)
            {
                // stop trying
                HidBattPrint(HIDBATT_ERROR,("Read Failure - More than 10 retries\nStatus = %x\n",pHidDev->m_pReadIrp->IoStatus.Status));
                break;
            }

            //
            // Hold the lock while playing with the IRP
            // If we are being removed, we need to break out.
            //
            if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
                break;
            }
            continue;
        }
        usFailureCount = 0;

        //
        // Hold the lock while playing with the IRP
        // If we are being removed, we need to break out.
        //
        if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
            break;
        }

        // process input buffer
        USHORT usReportId = pHidDev->m_pReadBuffer[0];
        USHORT usIndex = pHidDev->GetIndexFromReportId(usReportId);
        if(usIndex == MAXREPORTID)  // is this a report we recognize
        {
            HidBattPrint(HIDBATT_TRACE,("Read: don't recognize report: usIndex = 0x%08x\n", usIndex));
            continue; // we don't recognize this report
        }
        CUsageArray *pThisInputArray = pHidDev->m_InputUsageArrays[usIndex];
        if(!pThisInputArray)
        {
            HidBattPrint(HIDBATT_TRACE,("Read: nothing to update\n"));
            continue; // nothing to update
        }
        for(int i=0; i< pThisInputArray->m_UsageCount; i++)
        {
            HidBattPrint(HIDBATT_TRACE,("Read: Getting value\n"));
            pThisInputArray->m_pUsages[i]->GetValue();
        }
    }  //while

    //
    // Cleanup
    //
    MmUnlockPages( mdl );

ReadThreadCleanup3:

    IoFreeMdl(mdl);

ReadThreadCleanup2:

    // Irp will be freed by Query remove/stop device thread after read thread has terminated.

ReadThreadCleanup1:

    pDevExt->m_pBattery->m_Tag = BATTERY_TAG_INVALID;
    PsTerminateSystemThread(STATUS_SUCCESS);
    HidBattPrint(HIDBATT_ERROR,("Read thread terminated: Why am I seeing this?\n"));
}

// collectionarray methods

CCollectionArray::CCollectionArray(PHIDP_LINK_COLLECTION_NODE pTheNodes, USHORT usNodeCount, SHORT sParentIndex)
{

    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    USHORT i;
    m_pCollections = 0;
    m_CollectionCount = 0;

    if(sParentIndex == -1) // exception processing for application level collection
    {
        m_pCollections = (CCollection **)
                    ExAllocatePoolWithTag (NonPagedPool,
                                           sizeof(CCollection *),
                                           HidBattTag);
        if(!m_pCollections) return;
        RtlZeroMemory(m_pCollections,sizeof(CCollection *));
        m_pCollections[0] = new (NonPagedPool, HidBattTag)  CCollection(pTheNodes,usNodeCount, 0); // get my children
        m_CollectionCount = 1;
    } else {

        for( i = 1; i < usNodeCount; i++) {

            PHIDP_LINK_COLLECTION_NODE pThisNode = &pTheNodes[i];

            if( (pTheNodes[i].Parent == sParentIndex) ) {
                m_CollectionCount++; // inc collection count
                if(!m_pCollections) {
                    m_pCollections = (CCollection **)
                                ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(CCollection *),
                                                       HidBattTag);
                    if(!m_pCollections) return;
                    RtlZeroMemory(m_pCollections,sizeof(CCollection *));
                } else {
                    // make the array bigger
                    //m_Collections = (CCollection **) realloc(m_Collections,(m_CollectionCount * sizeof(CCollection *)));
                    CCollection ** pTemp = m_pCollections;
                    m_pCollections = (CCollection **)
                                ExAllocatePoolWithTag (NonPagedPool,
                                                       m_CollectionCount * sizeof(CCollection *),
                                                       HidBattTag);

                    if (!m_pCollections) {
                      // Re-allocation failure, print error and revert to previous state and return
                      HidBattPrint(HIDBATT_ERROR, ("CCollectionArray: Could not resize CCollection"));
                      m_pCollections = pTemp;
                      m_CollectionCount--;
                      return;
                    }

                    RtlCopyMemory(m_pCollections,pTemp,(m_CollectionCount -1) * sizeof(CCollection *));
                    ExFreePool(pTemp);
                }

                // add collection to array
                CCollection * TempCollection = new  (NonPagedPool, HidBattTag) CCollection(pTheNodes,usNodeCount,i);

                if (!TempCollection) {
                  // Could not allocate new CCollection, print debug message and return
                  HidBattPrint(HIDBATT_ERROR, ("CCollectionArray: Could not allocate new CCollection"));

                  return;
                }
                m_pCollections[m_CollectionCount-1] = TempCollection;
            }
        }
    }
}

CCollectionArray::~CCollectionArray()
{
    while(m_CollectionCount) {
        delete m_pCollections[--m_CollectionCount];
    }
    if (m_pCollections) {
        ExFreePool (m_pCollections);
    }
    return;
}


CCollection::CCollection(PHIDP_LINK_COLLECTION_NODE pTheNodes, USHORT usNodeCount,USHORT usNodeIndex)
{
    m_UsageArray        =    (CUsageArray *) NULL;
    m_CollectionArray    =    (CCollectionArray *) NULL; // init vars

    // setup this collection
    CCollectionArray * ThisArray = new  (NonPagedPool, HidBattTag) CCollectionArray(pTheNodes,usNodeCount,usNodeIndex);
    if(!ThisArray->m_CollectionCount) {// any child collections
        delete ThisArray;
    } else {
        m_CollectionArray = ThisArray;
    }
    // set the info in this collection
    m_CollectionID = pTheNodes[usNodeIndex].LinkUsage;
    m_UsagePage = pTheNodes[usNodeIndex].LinkUsagePage;
    m_NodeIndex = usNodeIndex;

}

CCollection::~CCollection()
{
        // delete all usages in the usage array
    if(m_UsageArray)
    {
        delete m_UsageArray;
    }
    // delete all the sub collections
    if(m_CollectionArray)
    {
        delete m_CollectionArray;
    }
}

void CCollection::InitUsages(CHidDevice * ThisDevice)
{
    bool        bResult =    FALSE;
    USHORT        usUsageIndex = 0;
    CUsage *    pThisUsage ;
    USHORT        usInputIndex;
    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    while( bResult = GetNextUsage(ThisDevice,m_CollectionID,m_NodeIndex,usUsageIndex,&pThisUsage))
    {

        if(!m_UsageArray) // if first usage
        {
            m_UsageArray = new (NonPagedPool, HidBattTag)  CUsageArray();
            if (!m_UsageArray) return;
        }
        pThisUsage->SetCapabilities();
        pThisUsage->m_pHidDevice = ThisDevice; // store this usage's device pointer
        if(pThisUsage->m_eType == eInputButton ||
                pThisUsage->m_eType == eInputValue)
        {
            // get input array index
            usInputIndex = ThisDevice->AssignIndexToReportId(pThisUsage->m_pProperties->m_ReportID);
            if(!ThisDevice->m_InputUsageArrays[usInputIndex])
            {
                // no array in this report position yet, create
                ThisDevice->m_InputUsageArrays[usInputIndex] = new  (NonPagedPool, HidBattTag) CUsageArray();
                if (!(ThisDevice->m_InputUsageArrays[usInputIndex])) return;
            }
            ThisDevice->m_InputUsageArrays[usInputIndex]->AddUsage(pThisUsage);    // add input usages to refresh stack
        }

        usUsageIndex++;
        m_UsageArray->AddUsage(pThisUsage);
    }
    // also init all my collections
    if(!m_CollectionArray) return;
    for(int i = 0; i < m_CollectionArray->m_CollectionCount; i++)
    {
        m_CollectionArray->m_pCollections[i]->InitUsages(ThisDevice);
    }
}



USHORT CHidDevice::AssignIndexToReportId(USHORT usReportId)
{
    USHORT i;
    HidBattPrint(HIDBATT_TRACE,("AssignIndexToReportId: ReportId = %x -- ", usReportId));
    for(i = 0;i < MAXREPORTID; i++)
    {
        if(!m_ReportIdArray[i]) {
            HidBattPrint(HIDBATT_TRACE,("Assigning to %x\n", i));
            m_ReportIdArray[i] = usReportId;
            return i;
        }
        if(m_ReportIdArray[i] == usReportId) {
            HidBattPrint(HIDBATT_TRACE,("Already assigned to %x\n", i));
            return i;
        }
    }

    //
    // It would be really nice if we could dynamically allocate more
    // since there isn't a small limit set to the number of report IDs.
    //
    ASSERTMSG("MAXREPORTID exceeded.\n", FALSE);

    return 0;

}

USHORT CHidDevice::GetIndexFromReportId(USHORT usReportId)
{
    USHORT i;

    HidBattPrint(HIDBATT_TRACE,("GetIndexFromReportId: ReportId = %x\n", usReportId));
    for(i = 0; i< MAXREPORTID; i++) {
        if(m_ReportIdArray[i] == usReportId) {
            return i;
        }
    }
    HidBattPrint(HIDBATT_TRACE,("GetIndexFromReportId: Failed\n", usReportId));
    return i;  // error return is MAXREPORTIDS
}

CUsagePath * CCollection::FindIndexedUsage(USHORT * pCurrentIndex, USHORT TargetIndex)
{
    CUsagePath * ThisPath;
    CUsagePath * NewPath;
    if(m_UsageArray)
    {
        if(m_UsageArray->m_UsageCount + *pCurrentIndex > TargetIndex)
        {
            // do the arithmetic to get the current index
            int ThisIndex = TargetIndex - *pCurrentIndex;
            // found it, construct usage path
            ThisPath = new  (NonPagedPool, HidBattTag) CUsagePath(
                                            m_UsagePage,
                                            m_CollectionID,
                                            m_UsageArray->m_pUsages[ThisIndex]
                                            );
            return ThisPath;
        }
    // didn't find it, inc current index
        *pCurrentIndex += m_UsageArray->m_UsageCount;
    }

    if(!m_CollectionArray) return NULL; // nothing more, quit

    // call out the sub collections

    for(int i = 0; i < m_CollectionArray->m_CollectionCount; i++)
    {
        ThisPath = m_CollectionArray->m_pCollections[i]->FindIndexedUsage(pCurrentIndex, TargetIndex);
        if(ThisPath)
        {
            // one of our subcollections had the usage, add us to the path
            NewPath = new (NonPagedPool, HidBattTag)  CUsagePath(
                                m_UsagePage,
                                m_CollectionID,
                                NULL
                                );

            if (!NewPath) return NULL;

            NewPath->m_pNextEntry = ThisPath;
            return NewPath;
        }
    }
    return NULL;
}

CUsagePath::~CUsagePath()
{
    CUsagePath  *   tempNextEntry;
    tempNextEntry = m_pNextEntry;
    m_pNextEntry = NULL;
    if (tempNextEntry) {
        delete tempNextEntry;
    }

    return;
}

CUsage::CUsage()
{
    // do member init
    m_pProperties   =    (CProperties      *) NULL;
    m_pButtonCaps   =    (HIDP_BUTTON_CAPS *) NULL;
    m_pValueCaps    =    (HIDP_VALUE_CAPS  *)NULL;
    m_eType         =    (eHidType) 0;
    m_Value         =    0;
    m_String        =    (char *)NULL;

    return;
}

CUsage::~CUsage()
{
    // free all associated objects

    if(m_pProperties) {
        delete m_pProperties;
    }

    return;
}

bool CUsage::GetValue()
{
    NTSTATUS    ntStatus;
    ULONG       ulResult;
    bool        bResult;
    BYTE        ReportID;
    USHORT      usDummy;

    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    switch(m_eType)
    {
        case eFeatureValue:
        case eFeatureButton:

            ReportID = (BYTE) m_pProperties->m_ReportID;
            // do we have the report that contains this data?

            if(!m_pHidDevice->m_FeatureBuffer[ReportID])
            {
                // must first create and fill buffer from getfeature

                // allocate memory
                m_pHidDevice->m_FeatureBuffer[ReportID] =
                    (PBYTE) ExAllocatePoolWithTag (NonPagedPool,
                                           m_pHidDevice->m_pCaps->FeatureReportByteLength+1,
                                           HidBattTag);
                RtlZeroMemory(m_pHidDevice->m_FeatureBuffer[ReportID],
                                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1);


                // setup first byte of buffer to report id
                *m_pHidDevice->m_FeatureBuffer[ReportID] = ReportID;
                // now read in report
                HIDDebugBreak(HIDBATT_BREAK_DEBUG);
                HidBattPrint(HIDBATT_TRACE,("GetFeature\n"));
                ntStatus = DoIoctl(
                        m_pHidDevice->m_pLowerDeviceObject,
                        IOCTL_HID_GET_FEATURE,
                        NULL,
                        0,
                        m_pHidDevice->m_FeatureBuffer[ReportID],
                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1,
                        m_pHidDevice
                        );
                if (!NT_SUCCESS (ntStatus)) {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - IOCTL_HID_GET_FEATURE 0x%08x\n", ntStatus));
                }
            }
            if(m_pProperties->m_pType->IsVolatile())
            {
                // this is a volatile value, refresh report
                RtlZeroMemory(m_pHidDevice->m_FeatureBuffer[ReportID],
                                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1);


                // setup first byte of buffer to report id
                *m_pHidDevice->m_FeatureBuffer[ReportID] = ReportID;
                // now read in report
                HIDDebugBreak(HIDBATT_BREAK_NEVER);
                HidBattPrint(HIDBATT_TRACE,("GetFeature - Refresh\n"));
                ntStatus = DoIoctl(
                        m_pHidDevice->m_pLowerDeviceObject,
                        IOCTL_HID_GET_FEATURE,
                        NULL,
                        0,
                        m_pHidDevice->m_FeatureBuffer[ReportID],
                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1,
                        m_pHidDevice
                        );
                if (!NT_SUCCESS (ntStatus)) {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - (volitile) IOCTL_HID_GET_FEATURE 0x%08x\n", ntStatus));

					// return error, fixes bug #357483
					return FALSE;
                }
            }


            if(m_eType == eFeatureValue)
            {
                ntStatus = HidP_GetUsageValue(
                                HidP_Feature,
                                m_pProperties->m_UsagePage,
                                m_pProperties->m_LinkCollection,
                                m_pProperties->m_Usage,
                                &ulResult,
                                m_pHidDevice->m_pPreparsedData,
                                (char *) m_pHidDevice->m_FeatureBuffer[ReportID],
                                m_pHidDevice->m_pCaps->FeatureReportByteLength
                                );
                if(!NT_SUCCESS(ntStatus))
                {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - HidP_GetUsageValue 0x%08x\n", ntStatus));
                    // return error
                    return FALSE;
                }
            } else
            {
                // must get button data
                ULONG Buttons, BufferSize;
                    PUSAGE pButtonBuffer;
                    Buttons = HidP_MaxUsageListLength (HidP_Feature, 0, m_pHidDevice->m_pPreparsedData);
                    BufferSize = Buttons * sizeof(USAGE);
                    pButtonBuffer = (PUSAGE) ExAllocatePoolWithTag (NonPagedPool,
                                                                    BufferSize,
                                                                    HidBattTag);

                    if (pButtonBuffer==NULL) { 
                        HidBattPrint(HIDBATT_DATA,("GetFeature - ExAllocatePoolWithTag returned NULL."));
                        // return error
                        return FALSE;
                    }
                    else {
                      RtlZeroMemory(pButtonBuffer,BufferSize);
                      ntStatus = HidP_GetButtons(
                                      HidP_Feature,
                                      m_pProperties->m_UsagePage,
                                      m_pProperties->m_LinkCollection,
                                      (PUSAGE) pButtonBuffer,
                                      &Buttons,
                                      m_pHidDevice->m_pPreparsedData,
                                      (char *) m_pHidDevice->m_FeatureBuffer[ReportID],
                                      m_pHidDevice->m_pCaps->FeatureReportByteLength
                                      );
                    }

                    if(!NT_SUCCESS(ntStatus))
                    {
                        HidBattPrint(HIDBATT_DATA,("GetFeature - HidP_GetButtons 0x%08x\n", ntStatus));
                        // return error
                        return FALSE;
                    }
                    // get the value for the requested button
                    PUSAGE pUsage = (PUSAGE) pButtonBuffer;
                    ulResult = 0; // set to not found value
                    for(int i = 0; i < (long) Buttons; i++)
                    {
                        if(pUsage[i] == m_pProperties->m_Usage)
                        {
                            ulResult = 1;
                            break;
                        }
                    }
                    ExFreePool(pButtonBuffer);
            }

            m_Value = ulResult;
            return TRUE;
            break;

        case eInputValue:
        case eInputButton:

            // have we had input data ?
            if(!m_pHidDevice->m_pReadBuffer) break; // nope, leave

            // do we have the report that contains this data?
            ReportID = (BYTE) m_pProperties->m_ReportID;

            if(!*m_pHidDevice->m_pReadBuffer == ReportID) break; // not us

            if(m_eType == eInputValue)
            {
                ntStatus = HidP_GetUsageValue(
                                HidP_Input,
                                m_pProperties->m_UsagePage,
                                m_pProperties->m_LinkCollection,
                                m_pProperties->m_Usage,
                                &ulResult,
                                m_pHidDevice->m_pPreparsedData,
                                (char *)m_pHidDevice->m_pReadBuffer,
                                m_pHidDevice->m_pCaps->InputReportByteLength
                                );
                if(NT_ERROR(ntStatus)) {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - (Button) HidP_GetUsageValue 0x%08x\n", ntStatus));
                    return FALSE;
                }
            } else
            {
                // handle button
                // must get button data
                ULONG Buttons, BufferSize;
                    PUSAGE_AND_PAGE pButtonBuffer;
                    Buttons = HidP_MaxUsageListLength (HidP_Input, 0, m_pHidDevice->m_pPreparsedData);
                    BufferSize = Buttons * sizeof(USAGE_AND_PAGE);
                    pButtonBuffer = (PUSAGE_AND_PAGE)
                                ExAllocatePoolWithTag (NonPagedPool,
                                                       BufferSize,
                                                       HidBattTag);
                    RtlZeroMemory(pButtonBuffer,BufferSize);
                    ntStatus = HidP_GetButtons(
                                    HidP_Input,
                                    m_pProperties->m_UsagePage,
                                    m_pProperties->m_LinkCollection,
                                    (PUSAGE) pButtonBuffer,
                                    &Buttons,
                                    m_pHidDevice->m_pPreparsedData,
                                    (char *) m_pHidDevice->m_pReadBuffer,
                                    m_pHidDevice->m_pCaps->InputReportByteLength
                                    );
                    if(!NT_SUCCESS(ntStatus))
                    {
                        HidBattPrint(HIDBATT_DATA,("GetFeature - (Button) HidP_GetButton 0x%08x\n", ntStatus));
                        // return error
                        return FALSE;
                    }
                    // get the value for the requested button
                    USAGE_AND_PAGE * UsagePage = (USAGE_AND_PAGE *) pButtonBuffer;
                    ulResult = 0; // set to not found value
                    for(int i = 0; i < (long) Buttons; i++)
                    {
                        if(UsagePage[i].Usage == m_pProperties->m_Usage)
                            // don't need to check usage page, because it was specified
                            //     && UsagePage[i].UsagePage == m_pProperties->m_UsagePage)
                        {
                            ulResult = 1;
                            break;
                        }
                    }
                    ExFreePool(pButtonBuffer);
            }
            if(m_Value != ulResult)
            {
                m_Value = ulResult;

                // there's been a change, check if this needs alerting

                if(m_pProperties->m_pType->IsAlertable())
                {
                    // call registered notification callback with
                    // ... passing the notificable usage object
                    if(m_pHidDevice->m_pEventHandler)
                    {
                        (*m_pHidDevice->m_pEventHandler)(
                                        m_pHidDevice->m_pEventContext,
                                        this);
                    }
                }
            }

            return TRUE;
            break;

    }

 return FALSE;
}

void CUsage::SetCapabilities()
{
    // init capabilites from value caps and set properties for this usage
    m_pProperties = new (NonPagedPool, HidBattTag)  CProperties(this);

}

ULONG CUsage::GetUnit()
{
    return m_pProperties->m_Unit;
}

SHORT CUsage::GetExponent()
{
    return m_pProperties->m_UnitExponent;
}

NTSTATUS CUsage::GetString(char * pBuffer, USHORT buffLen, PULONG pBytesReturned)
{
    char cBuffer[4];
    ULONG StringIndex;
    NTSTATUS ntStatus;
    ULONG ulBytesWritten = 0;
    bool bResult;
    // first must update this usages value


    bResult = GetValue();
    if(!bResult) return STATUS_UNSUCCESSFUL;
    RtlCopyMemory(cBuffer,&m_Value,sizeof(ULONG));
    ntStatus = DoIoctl(
                m_pHidDevice->m_pLowerDeviceObject,
                IOCTL_HID_GET_INDEXED_STRING,
                cBuffer,
                4,
                pBuffer,
                buffLen,
                m_pHidDevice);


    return ntStatus;
}


// utility to do writefile for output reports
NTSTATUS HidWriteFile(
            CHidDevice *    pHidDevice,
            PVOID            pOutputBuffer,
            USHORT            usBufferLen,
            PULONG            pulBytesWritten
            )
{
    KEVENT                WrittenEvent;
    IO_STATUS_BLOCK        IoStatusBlock;
    PIO_STACK_LOCATION    pNewStack;

    return STATUS_SUCCESS;
    KeInitializeEvent(&WrittenEvent,NotificationEvent,FALSE);
    // allocate write irp
    PIRP pIrp = IoBuildSynchronousFsdRequest(
            IRP_MJ_WRITE,
            pHidDevice->m_pLowerDeviceObject,
            pOutputBuffer,
            usBufferLen,
            0,
            &WrittenEvent,
            &IoStatusBlock
            );

    if(!pIrp) return STATUS_INSUFFICIENT_RESOURCES;
    pNewStack= IoGetNextIrpStackLocation(pIrp);
    pNewStack->FileObject = pHidDevice->m_pFCB;

    NTSTATUS ntStatus = IoCallDriver(pHidDevice->m_pLowerDeviceObject,pIrp);
    if(NT_ERROR(ntStatus))
    {
        IoFreeIrp(pIrp);
        return ntStatus;
    }
    ntStatus = KeWaitForSingleObject(
                            &WrittenEvent,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL
                            );
    IoFreeIrp(pIrp); // done with Irp
    if(NT_ERROR(ntStatus))
    {
        return ntStatus;
    }
    *pulBytesWritten = (ULONG)IoStatusBlock.Information;
    return IoStatusBlock.Status;
}


bool CUsage::SetValue(ULONG ulValue)
{
    NTSTATUS ntStatus;
    USHORT ThisType;
    char * pOutputBuffer;
    USHORT usBufferLen;
    bool bResult;
    ULONG  ulBytesWritten;

    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    // first check that this is an output or feature report
    if(m_eType == eInputButton ||
        m_eType == eInputValue)
    {
        // if this is an input usage, reject update
         return FALSE;
    }

    if(m_eType == eOutputButton ||
        m_eType == eOutputValue)
    {
        ThisType = HidP_Output;
        usBufferLen = m_pHidDevice->m_pCaps->OutputReportByteLength;

    } else
    {
        ThisType = HidP_Feature;
        usBufferLen = m_pHidDevice->m_pCaps->FeatureReportByteLength + 1; // for report id
    }

    pOutputBuffer = (char *) ExAllocatePoolWithTag (NonPagedPool,
                                                    usBufferLen+1,
                                                    HidBattTag);

    if (!pOutputBuffer) {
      // Allocation failed
      return FALSE;
    }

    pOutputBuffer[0] = (char) m_pProperties->m_ReportID;

    // setup buffer for write
    ntStatus = HidP_SetUsageValue(
                (HIDP_REPORT_TYPE) ThisType,        // either feature or output
                m_pProperties->m_UsagePage,
                m_pProperties->m_LinkCollection,
                m_pProperties->m_Usage,
                ulValue,
                m_pHidDevice->m_pPreparsedData,
                pOutputBuffer,
                usBufferLen-1
                );


    if(ThisType == HidP_Output)
    {
        ntStatus = HidWriteFile(
            m_pHidDevice,
            pOutputBuffer,
            usBufferLen,
            &ulBytesWritten
            );
    } else
    {
        ntStatus = DoIoctl(
                m_pHidDevice->m_pLowerDeviceObject,
                IOCTL_HID_SET_FEATURE,
                pOutputBuffer,  //NULL,
                usBufferLen, //0,
                pOutputBuffer,
                usBufferLen,
                m_pHidDevice
                );
    }

    ExFreePool (pOutputBuffer);

    return ntStatus ? FALSE:TRUE;
}



// Usage Array Class
CUsageArray::CUsageArray()
{
    m_UsageCount = 0;
    m_pUsages = (CUsage **) NULL;
    return;
}

CUsageArray::~CUsageArray()
{
    while(m_UsageCount) {
        delete m_pUsages[--m_UsageCount];
    }
    if (m_pUsages) {
        ExFreePool (m_pUsages);
    }
    return;
}


void CUsageArray::AddUsage(CUsage * pNewUsage)
{
    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    if(!m_pUsages)
    {
        m_pUsages = (CUsage **) ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(CUsage *),
                                                       HidBattTag);
    } else
    {
        CUsage ** pTemp = m_pUsages;
        m_pUsages = (CUsage **) ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(CUsage *) * (m_UsageCount + 1),
                                                       HidBattTag);

        if (m_pUsages) {
          memcpy(m_pUsages,pTemp,sizeof(CUsage *) * m_UsageCount);
          ExFreePool(pTemp);
        }
    }

	if (m_pUsages) {
		m_pUsages[m_UsageCount] = pNewUsage;
		m_UsageCount++;
	}
	// else - no way to report allocation failure.  The only indication is that
	//        m_UsageCount is not increamented.  (v-stebe)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\devext.h ===
#ifndef _DEVEXT_H
#define _DEVEXT_H

//
// Class device extension.
//

#define REGPATHMAX 100

typedef enum {
    eBaseDevice = 1,
    eBatteryDevice,
    eAdaptorDevice
} EXTENSION_TYPE;



typedef struct _CBatteryDevExt {
    CUString *          m_pBatteryName;
    UNICODE_STRING      m_RegistryPath;         // will be converted to a unicode string
    WCHAR               m_RegistryBuffer[REGPATHMAX];
    PDEVICE_OBJECT      m_pHidPdo;

    PDEVICE_OBJECT      m_pBatteryFdo;          // Functional Device Object
    PDEVICE_OBJECT      m_pLowerDeviceObject;   // Detected at AddDevice time
    PFILE_OBJECT        m_pHidFileObject;
    CBattery *          m_pBattery;
    ULONG               m_ulTagCount;           // Tag for next battery
    BOOLEAN             m_bIsStarted;           // if non zero, the device is started
    BOOLEAN             m_bFirstStart;          // Need to differentiate between
                                                // first and second start IRP.
    BOOLEAN             m_bJustStarted;         // If set, will open handle on next
                                                // IRP_MN_QUERY_PNP_DEVICE_STATE
    ULONG               m_ulDefaultAlert1;      // Cache DefaultAlert1 accross stop device.
    PVOID               m_pSelector;            // Selector for battery
    EXTENSION_TYPE      m_eExtType;
    PDEVICE_OBJECT      m_pOpenedDeviceObject;
    PKTHREAD            m_OpeningThread;
    IO_REMOVE_LOCK      m_RemoveLock;
    IO_REMOVE_LOCK      m_StopLock;
    ULONG               m_iHibernateDelay;
    ULONG               m_iShutdownDelay;
} CBatteryDevExt;

#endif // devext.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\ckutils.h ===
/*
 * title:      ckutils.cpp
 *
 * purpose:    misc utils headers
 *
 */

struct USAGE_PROPERTIES {
	BYTE *		m_Unit;
	BYTE		m_UnitLength;
	BYTE		m_Exponent;
	TYPEMASK	m_Type; // feature, input, or output, writeable, alertable, etc.
};

struct USAGE_PATH {
	USAGE               UsagePage;
	USAGE               Usage;
	USAGE_PATH       *  pNextUsage;
	USAGE_PROPERTIES *  UsageProperties;
};

BOOL GetUsage(PHID_DEVICE, char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\hid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hidexe.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user more client sample driver.

Environment:

    Kernel & user mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#ifndef HIDEXE_H
#define HIDEXE_H

#include <hidpddi.h>

//
//

#define DIGCF_FUNCTION  0x00000010
#define DIOD_FUNCTION   0x00000008
#define DIREG_FUNCTION  0x00000008


//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage; // The usage page for which we are looking.
   ULONG       Status; // The last status returned from the accessor function
                       // when updating this field.
   union {
      struct {
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages; // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
 //  HANDLE               HidDevice; // A file handle to the hid device.
 //  PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
 //  HIDP_CAPS            Caps; // The Capabilities of this hid device.

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.
   PHIDP_BUTTON_CAPS    InputButtonCaps;
   PHIDP_VALUE_CAPS     InputValueCaps;

   PCHAR                OutputReportBuffer;
   PHID_DATA            OutputData;
   ULONG                OutputDataLength;
   PHIDP_BUTTON_CAPS    OutputButtonCaps;
   PHIDP_VALUE_CAPS     OutputValueCaps;

   PCHAR                FeatureReportBuffer;
   PHID_DATA            FeatureData;
   ULONG                FeatureDataLength;
   PHIDP_BUTTON_CAPS    FeatureButtonCaps;
   PHIDP_VALUE_CAPS     FeatureValueCaps;
} HID_DEVICE, *PHID_DEVICE;



BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
CloseHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\ckhid.h ===
#ifndef _CKHID_H
#define _CKHID_H

/*
 * title:      hidpwr.h
 *
 * purpose:    header for wdm kernel hid interface class
 *
 */

#define READABLE        0x01
#define WRITEABLE       0x02

#define UsagePowerPage  0x84
#define UsageUPS        0x04

// objectification of hid class structures
#define FeatureType     0x01
#define InputType       0x02
#define OutputType      0x03


class CTypeMask  {
public:
    int         GetReportType()     { return ReportType; };
    bool        IsWriteable()       { return bWriteable;};
    bool        IsString()          { return bIsString;};
    bool        IsVolatile()        { return bVolatile;};
    bool        IsNumber()          { return bIsNumber;};
    bool        IsAlertable()       { return bAlertable;};
    void        SetIsWriteable()    { bWriteable = 1; };
    void        SetAlertable()      { bAlertable = 1; };
    void        SetIsString()       { bIsString = 1;};
    void        SetIsNumber()       { bIsNumber = 1;};
    void        SetVolatile()       { bVolatile = 1;};
    void        SetReportType(int iType) { ReportType = iType;};
    CTypeMask();
protected:
    unsigned    ReportType  : 2;
    unsigned    bWriteable  : 1;
    unsigned    bIsString   : 1;
    unsigned    bIsNumber   : 1;
    unsigned    bAlertable  : 1;
    unsigned    bVolatile   : 1;
    unsigned    Pad         : 1;
};


typedef enum {
    eFeatureValue = 1,
    eFeatureButton,
    eInputValue,
    eInputButton,
    eOutputValue,
    eOutputButton
} eHidType;

// forward declarations

class CCollectionArray;
class CHidDevice;
class CUsage;

class CProperties {
public:
    LONG        m_Unit;
    SHORT       m_UnitExponent;
    LONG        m_LogicalMin;
    LONG        m_LogicalMax;
    USHORT      m_LinkCollection;
    USHORT      m_ReportID;
    USHORT      m_Usage;
    USHORT      m_UsagePage;
    CTypeMask * m_pType; // feature, input, or output, writeable, alertable, etc.
// methods
    CProperties(CUsage *);
    ~CProperties();
};

class CUsage {
public: // public members
    CProperties      *  m_pProperties;
    HIDP_BUTTON_CAPS *  m_pButtonCaps;
    HIDP_VALUE_CAPS  *  m_pValueCaps;
    eHidType            m_eType;
    union
    {
        ULONG           m_Value;
        char         *  m_String;
    };
    CHidDevice *        m_pHidDevice;
public: // public methods
    CUsage();
    ~CUsage();
    bool GetValue();
    NTSTATUS GetString(char * pBuffer,USHORT usBuffLen,PULONG BytesReturned);
    void SetCapabilities();
    bool SetValue(ULONG);
    short GetExponent();
    ULONG GetUnit();

};

class CUsagePath {
public: // public members
    USAGE           m_UsagePage;
    USAGE           m_UsageNumber;
    CUsage      *   m_pUsage;
    CUsagePath  *   m_pNextEntry;
public: // public methods
    CUsagePath(USAGE UsagePage, USAGE UsageID, CUsage * pUsage = NULL);
    ~CUsagePath();
};



class CUsageArray {
public: // members
    CUsage                **  m_pUsages;
    USHORT                    m_UsageCount;
public: // methods
    CUsageArray();
    ~CUsageArray();
    void AddUsage(CUsage * pNewUsage);
};

class CCollection {
public: // public methods
    USAGE                   m_CollectionID;
    USAGE                   m_UsagePage;
    CUsageArray         *   m_UsageArray;
    CCollectionArray    *   m_CollectionArray;
    USHORT                  m_NodeIndex;
    CHidDevice *            m_HidDevice;
public: // methods and constructors
    CCollection(PHIDP_LINK_COLLECTION_NODE TheNodes, USHORT usNodeCount,USHORT usParentIndex);
    ~CCollection();
    void InitUsages(CHidDevice *);
    CUsagePath * FindIndexedUsage(USHORT *pCurrIndex, USHORT TargetIndex);
};


class CCollectionArray {
public: // members
    CCollection **        m_pCollections;
    USHORT                m_CollectionCount;

public: // methods
    CCollectionArray(PHIDP_LINK_COLLECTION_NODE TheNodes, USHORT usNodeCount,SHORT sParentIndex);
    ~CCollectionArray();

};

#define MAXREPORTID 256

typedef void (*EVENT_HANDLER)(
                IN PVOID                Context,
                IN CUsage *             pUsage
);

// prototypes for callbacks and completion routines used by CHidDevice class

void _stdcall    ReadThread(PVOID);
NTSTATUS _stdcall ReadCompletionRoutine(
                            PDEVICE_OBJECT,
                            PIRP,
                            PVOID);
class CHidDevice
{
public:
    PHID_DEVICE                 m_pHidDevice;
    PDEVICE_OBJECT              m_pDeviceObject;
    PDEVICE_OBJECT              m_pLowerDeviceObject;
    PDEVICE_OBJECT              m_pOpenedDeviceObject;
    USHORT                      m_UsagePage;
    USHORT                      m_UsageID;
    CCollectionArray *          m_CollectionArray;
    CUsageArray      *          m_InputUsageArrays[MAXREPORTID]; // allowing for 10 input reports
    PBYTE                       m_pReadBuffer;
    PBYTE                       m_FeatureBuffer[MAXREPORTID];
    HANDLE                      m_hReadThread;
    PVOID                       m_pThreadObject;
    KEVENT                      m_kReadEvent;
    KEVENT                      m_kAbortEvent;
    PHIDP_PREPARSED_DATA        m_pPreparsedData;
    PHIDP_CAPS                  m_pCaps;
    EVENT_HANDLER               m_pEventHandler;
    PVOID                       m_pEventContext;
    PFILE_OBJECT                m_pFCB;                    // file control block for hid class read/write i/o
    PIRP                        m_pReadIrp;

private:
    HANDLE                      m_hEventMutex;
    PBYTE                       m_InputBuffer;
    USHORT                      m_ReportIdArray[MAXREPORTID];

public:
    CHidDevice();
    ~CHidDevice();
    bool            OpenHidDevice(PDEVICE_OBJECT pDeviceObject);
    CUsage *        FindUsage(CUsagePath * Path, USHORT usType);
    NTSTATUS        ActivateInput();
    USHORT          GetIndexFromReportId(USHORT ReportId);
    USHORT          AssignIndexToReportId(USHORT ReportId);

private:
};

#endif // CKHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\hidbatt.cpp ===
/*
 * title:      hidbatt.c
 *
 * purpose:    wdm kernel client interface between HID class and power class
 *
 * Initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * windows 98 support
 *
 */

#include "hidbatt.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif


// Global
ULONG       HidBattDebug        = HIDBATT_PRINT_NEVER;
USHORT      HidBreakFlag        = HIDBATT_BREAK_NEVER;
USHORT      gusInstance         = 0;
//
// Device Names
//
#define     HidBattDeviceName   L"\\Device\\HIDBattery"


// local protos
NTSTATUS
HidBattSystemControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{


    NTSTATUS status;

    HidBattPrint (HIDBATT_TRACE, ("HidBatt:DriverEntry\n"));
    HIDDebugBreak(HIDBATT_BREAK_FULL);
    /************************************************************************************/
    /*                                                                                    */
    /*   fill in the slots for the functions in                                            */
    /*   the Driver object.                                                                */
    /*                                                                                    */
    /************************************************************************************/

    DriverObject->MajorFunction[IRP_MJ_CREATE]          = HidBattOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = HidBattClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = HidBattIoControl;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = HidBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = HidBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = HidBattSystemControl;  // pass down to hid class
    DriverObject->DriverUnload                          = HidBattUnload; // this is unloadable with current rev of battery class
    DriverObject->DriverExtension->AddDevice            = HidBattAddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
HidBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       pHidPdo
    )
{

    BOOL bResult;
    PUNICODE_STRING         unicodeString;
    PDEVICE_OBJECT          pBatteryFdo = NULL;
    NTSTATUS                ntStatus;
    CBatteryDevExt *        pDevExt;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];
    CUString    *            pBatteryName;
    // enters here with pdo of hidclass - power class object

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint (HIDBATT_TRACE, ("HidBattAddDevice\n"));


/* sberard - Removed due to changes in hidclass.sys (bug #274422)

    HID_COLLECTION_INFORMATION HidInfo;


    RtlZeroMemory(&HidInfo,sizeof(HID_COLLECTION_INFORMATION));

    ntStatus = DoIoctl(
                pHidPdo,
                IOCTL_HID_GET_COLLECTION_INFORMATION,
                NULL,
                0,
                &HidInfo,
                sizeof(HID_COLLECTION_INFORMATION),
                (CHidDevice *) NULL
                );

    if(NT_ERROR(ntStatus))
    {
        HidBattPrint (HIDBATT_ERROR_ONLY, ("HidBattAddDevice: IOCTL_HID_GET_COLLECTION_INFORMATION failed 0x%08x\n", ntStatus));
        return STATUS_UNSUCCESSFUL;
    }
*/
    // too early to communicate with device, stash hid pdo and complete
    pBatteryName = new (NonPagedPool, HidBattTag) CUString(HidBattDeviceName);

    if (!pBatteryName) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }



    // Create the UPS PDO device name based on the battery instance
    //
    CUString * pInstanceNumber = new (NonPagedPool, HidBattTag) CUString(++gusInstance,10);
    if (!pInstanceNumber) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pBatteryName->Append(&pInstanceNumber->m_String);
    delete pInstanceNumber;
    ntStatus = IoCreateDevice(
                DriverObject,
                sizeof (CBatteryDevExt),
                &pBatteryName->m_String,
                FILE_DEVICE_BATTERY,
                0,
                FALSE,
                &pBatteryFdo
                );

    if (ntStatus != STATUS_SUCCESS) {
        HidBattPrint(HIDBATT_ERROR, ("HidBattCreateFdo: error (0x%x) creating device object\n", ntStatus));
        delete pBatteryName;
        --gusInstance; // reflect loss of device to instance
        return(ntStatus);
    }


//    pBatteryFdo->DeviceExtension = new (NonPagedPool, HidBattTag) CBatteryDevExt;


//    pBatteryFdo->StackSize++; // add one stack entry for battery class
    // layer the battery pdo to the hid class pdo
    // so that we begin to receive the device irps
    PDEVICE_OBJECT pHidDeviceObject = IoAttachDeviceToDeviceStack(pBatteryFdo,pHidPdo);

    pDevExt = (CBatteryDevExt *) pBatteryFdo->DeviceExtension;
    pDevExt->m_RegistryPath.Length = 0;
    pDevExt->m_RegistryPath.MaximumLength = sizeof(pDevExt->m_RegistryBuffer);
    RtlZeroMemory(&pDevExt->m_RegistryBuffer, sizeof(pDevExt->m_RegistryBuffer));
    pDevExt->m_RegistryPath.Buffer = &pDevExt->m_RegistryBuffer[0]; // set buffer pointer
    pDevExt->m_pBattery = NULL;

    pBatteryFdo->Flags              |=  DO_BUFFERED_IO | DO_POWER_PAGABLE;
    pBatteryFdo->Flags              &=  ~DO_DEVICE_INITIALIZING;
    pDevExt->m_pHidPdo              =   pHidPdo;
    pDevExt->m_pBatteryFdo          =   pBatteryFdo;
    pDevExt->m_pLowerDeviceObject   =   pHidDeviceObject;
    pDevExt->m_eExtType             =   eBatteryDevice;
    pDevExt->m_bFirstStart          =   TRUE;
    pDevExt->m_bJustStarted         =   FALSE;
    pDevExt->m_ulDefaultAlert1      =   (ULONG)-1;
    pDevExt->m_pBatteryName         =   pBatteryName;

    IoInitializeRemoveLock (&pDevExt->m_RemoveLock, HidBattTag, 10, 20);
    IoInitializeRemoveLock (&pDevExt->m_StopLock, HidBattTag, 10, 20);
    IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
    IoReleaseRemoveLockAndWait (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return STATUS_SUCCESS;

}


NTSTATUS
HidBattOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp;


    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint (HIDBATT_TRACE, ("HidBattOpen\n"));
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    if (NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag))) {
        IoSkipCurrentIrpStackLocation (pIrp);
        ntStatus = IoCallDriver(pDevExt->m_pLowerDeviceObject, pIrp);

        HidBattPrint (HIDBATT_NOTE, ("HidBattOpen: lower driver returned 0x%08x\n", ntStatus));

        IoReleaseRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);
    } else {
        ntStatus = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }

    return ntStatus;
}



NTSTATUS
HidBattClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp;

    HidBattPrint (HIDBATT_TRACE, ("HidBattClose\n"));
     // get the device extension
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    HidBattCallLowerDriver(ntStatus, pDevExt->m_pLowerDeviceObject, pIrp);
    HidBattPrint (HIDBATT_NOTE, ("HidBattClose: lower driver returned 0x%08x\n", ntStatus));

    return ntStatus;

}


NTSTATUS
HidBattSystemControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP pIrp
    )
{
    HidBattPrint (HIDBATT_TRACE, ("HidBattSystemControl\n"));
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    // all system control calls are passed down for now.
    NTSTATUS ntStatus = STATUS_SUCCESS;
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;
    HidBattCallLowerDriver(ntStatus,pDevExt->m_pLowerDeviceObject,pIrp);
    return ntStatus;
}


VOID
HidBattUnload(
    IN PDRIVER_OBJECT   pDriverObject
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
// we can just return, no driver-only (non-device) resources were allocated
    return;
}


NTSTATUS
HidBattPnpDispatch(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP                pIrp
    )
{

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    PIO_STACK_LOCATION          pIrpStack;
    CBatteryDevExt *            pDevExt;
    NTSTATUS                    ntStatus;
    BOOLEAN                     lockReleased = FALSE;

//    PAGED_CODE();


    ntStatus = STATUS_NOT_SUPPORTED;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    IoAcquireRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);

    //
    // Dispatch minor function
    //
    switch (pIrpStack->MinorFunction)
    {

        case IRP_MN_STOP_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_STOP_DEVICE\n"));
            ntStatus = HidBattStopDevice(pDeviceObject, pIrp);
            break;
        }   // IRP_MN_STOP_DEVICE

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_DEVICE_RELATIONS - type (%d)\n",
                        pIrpStack->Parameters.QueryDeviceRelations.Type));

            break;
        }   //  IRP_MN_QUERY_DEVICE_RELATIONS

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_FILTER_RESOURCE_REQUIREMENTS - type (%d)\n",
                        pIrpStack->Parameters.QueryDeviceRelations.Type));

            break;
        }   //  IRP_MN_FILTER_RESOURCE_REQUIREMENTS

        case IRP_MN_REMOVE_DEVICE:

        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_REMOVE_DEVICE\n"));

            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: Waiting to remove\n"));
            IoReleaseRemoveLockAndWait (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);
            lockReleased = TRUE;

            // then remove device from device stack
            IoDetachDevice(pDevExt->m_pLowerDeviceObject);

            // delete our device
            IoDeleteDevice(pDeviceObject);

            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_REMOVE_DEVICE

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_QUERY_REMOVE_DEVICE:

        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_REMOVE_DEVICE\n"));

            ntStatus = HidBattStopDevice(pDeviceObject, pIrp);

            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_QUERY_REMOVE_DEVICE

        case IRP_MN_START_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_START_DEVICE\n"));
            if (pDevExt->m_bFirstStart) {
                pDevExt->m_bJustStarted = TRUE;
                pDevExt->m_bFirstStart = FALSE;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            // else fall through and do the same thing as the cancel remove.

        }   // IRP_MN_START_DEVICE

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE\n"));

            KEVENT cancelRemoveComplete;

            KeInitializeEvent(&cancelRemoveComplete, SynchronizationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext (pIrp);
            IoSetCompletionRoutine (pIrp, HidBattIoCompletion, &cancelRemoveComplete, TRUE, TRUE, TRUE);
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            ntStatus = IoCallDriver (pDevExt->m_pLowerDeviceObject, pIrp);
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE, Lower driver status: %08x\n", ntStatus));

            if (ntStatus == STATUS_PENDING) {
                KeWaitForSingleObject (&cancelRemoveComplete, Executive, KernelMode, FALSE, NULL);
                ntStatus = pIrp->IoStatus.Status;
                HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE, Lower driver 2nd status: %08x\n", ntStatus));
            }

            if (NT_SUCCESS (ntStatus)) {
                ntStatus = HidBattInitializeDevice (pDeviceObject, pIrp);
                HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE, Our status: %08x\n", ntStatus));
            }

            pIrp->IoStatus.Status = ntStatus;

            IoCompleteRequest (pIrp, IO_NO_INCREMENT);

            IoReleaseRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);

            return ntStatus;
        }   //  IRP_MN_CANCEL_REMOVE_DEVICE

        case IRP_MN_QUERY_STOP_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_STOP_DEVICE\n"));
            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_QUERY_STOP_DEVICE

        case IRP_MN_CANCEL_STOP_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_STOP_DEVICE\n"));
            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_CANCEL_STOP_DEVICE

        case IRP_MN_QUERY_RESOURCES:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_RESOURCES\n"));
            break;
        }   //  IRP_MN_QUERY_RESOURCES

        case IRP_MN_READ_CONFIG:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_READ_CONFIG\n"));
            break;
        }   //  IRP_MN_READ_CONFIG

        case IRP_MN_WRITE_CONFIG:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_WRITE_CONFIG\n"));
            break;
        }   //  IRP_MN_WRITE_CONFIG

        case IRP_MN_EJECT:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_EJECT\n"));
            break;
        }   //  IRP_MN_EJECT

        case IRP_MN_SET_LOCK:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_SET_LOCK\n"));
            break;
        }   //  IRP_MN_SET_LOCK

        case IRP_MN_QUERY_ID:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_ID\n"));
            break;
        }   //  IRP_MN_QUERY_ID

        case IRP_MN_QUERY_CAPABILITIES:
        {
            PDEVICE_CAPABILITIES    deviceCaps;
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES\n"));

            deviceCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;
            deviceCaps->Removable = TRUE;
            deviceCaps->SurpriseRemovalOK = TRUE;

            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_QUERY_CAPABILITIES

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_PNP_DEVICE_STATE\n"));

            if (pDevExt->m_bJustStarted == TRUE) {

                pDevExt->m_bJustStarted = FALSE;

                ntStatus = HidBattInitializeDevice (pDeviceObject, pIrp);
            }

            if (!NT_SUCCESS (ntStatus)) {
                HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: HidBattInitializeDevice failed %0x\n", ntStatus));
                pIrp->IoStatus.Information |= PNP_DEVICE_FAILED;
                pIrp->IoStatus.Status = STATUS_SUCCESS;
            }

            break;
        }   //  IRP_MN_PNP_DEVICE_STATE

        default:
        {
            HidBattPrint (HIDBATT_PNP,
                    ("HidBattPnpDispatch: Unimplemented minor %0x\n",
                    pIrpStack->MinorFunction));
            break;
        }
    }

    if (ntStatus != STATUS_NOT_SUPPORTED) {
        pIrp->IoStatus.Status = ntStatus;
    }

    if (NT_SUCCESS(ntStatus) || (ntStatus == STATUS_NOT_SUPPORTED)) {
        HidBattCallLowerDriver (ntStatus, pDevExt->m_pLowerDeviceObject, pIrp);

    } else {
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }

    if (lockReleased == FALSE) {
        IoReleaseRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);
    }

    return ntStatus;
}


NTSTATUS
HidBattPowerDispatch(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP                pIrp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION            pIrpStack;
    CBatteryDevExt *        pDevExt;
    NTSTATUS                    ntStatus;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

//    PAGED_CODE();

    HidBattPrint ((HIDBATT_TRACE | HIDBATT_POWER), ("HidBattPowerDispatch\n"));

    //
    // Never fail a power IRP, even if we don't do anything.
    //

    ntStatus = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    // this switch currently does no dispatches, and is expanded only for
    // documentary purposes
    switch (pIrpStack->MinorFunction) {

    case IRP_MN_WAIT_WAKE: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_WAIT_WAKE\n"));
            break;
        }

    case IRP_MN_POWER_SEQUENCE: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_POWER_SEQUENCE\n"));
            break;
        }

    case IRP_MN_SET_POWER: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_SET_POWER\n"));
            if (pIrpStack->Parameters.Power.Type == SystemPowerState &&
                pIrpStack->Parameters.Power.State.SystemState >= PowerSystemShutdown) {

                if (NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
                {
                    //
                    // Write default RemainingCapcitylimit back to UPS so when the system reboots,
                    // the data returned by the device will be correct.
                    //
                    pDevExt->m_pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,
                                                     &pDevExt->m_ulDefaultAlert1,TRUE);
                    
                    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
                }
            }
            break;
        }

    case IRP_MN_QUERY_POWER: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_QUERY_POWER\n"));
            break;
        }

    default: {

            HidBattPrint(HIDBATT_LOW, ("HidBattPowerDispatch: minor %d\n",
                    pIrpStack->MinorFunction));

            break;
        }
    }

    PoStartNextPowerIrp(pIrp); // inform system we are done with this irp
    IoSkipCurrentIrpStackLocation(pIrp);
    ntStatus = PoCallDriver(pDevExt->m_pLowerDeviceObject,pIrp);

    return ntStatus;
}

NTSTATUS HidBattSetInformation(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL Level,
    IN PVOID Buffer OPTIONAL
    )

{
/*
 Routine Description:

    Called by the class driver to set the battery's charge/discharge state.
    The smart battery does not support the critical bias function of this
    call.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    Level           - Action being asked for

Return Value:

    NTSTATUS

--*/
    // charge and discharge forcing not supported for UPS's
    HidBattPrint (HIDBATT_TRACE, ("HidBattSetInformation\n"));
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\ckutils.cpp ===
/*
 * title:      ckUtils.cpp
 *
 * purpose:   misc c-style utility functions
 *
*/

#include "hidbatt.h"

// utils

NTSTATUS
HidBattDoIoctlCompletion(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pDoIoCompletedEvent
    )
{

    KeSetEvent((KEVENT *) pDoIoCompletedEvent,0, FALSE);
    return pIrp->IoStatus.Status;

}

ULONG CentiAmpSecsToMilliWattHours(ULONG CentiAmps,ULONG MilliVolts)
{
    // conversion from Centiampsec to millWattHours
    // formula = (amps * volts / 3600) ^ (exponent correction)
    ULONG milliWattHours = CentiAmps;
    milliWattHours /= 100;        // now have ampsec
    milliWattHours *= MilliVolts; // now have milliwattsec
    milliWattHours /= 3600;       // milliwatthours

    HidBattPrint (HIDBATT_DATA, ("CentiAmpSecsToMilliWhatHours: CAs = 0x%08x, mV = 0x%08x, mWH = 0x%08x \n",
                                 CentiAmps, MilliVolts, milliWattHours ));
    return milliWattHours;
}

ULONG milliWattHoursToCentiAmpSecs(ULONG mwHours, ULONG MilliVolts)
{
    // inverse of formula above

    ULONG AmpSecs = mwHours;
    AmpSecs *= 3600;
    AmpSecs /= MilliVolts;
    AmpSecs *= 100;

    HidBattPrint (HIDBATT_DATA, ("MilliWattHoursToCentiAmpSecs: mWH = 0x%08x, mV = 0x%08x, CAs = 0x%08x \n",
                                 mwHours, MilliVolts, AmpSecs ));
    return AmpSecs;
}


// subroutine to take a value, it's exponent and the desired exponent and correct the value
ULONG CorrectExponent(ULONG ulBaseValue, SHORT sCurrExponent, SHORT sTargetExponent)
{
    SHORT sCorrection;
    if(!ulBaseValue) return 0; // done all I can with zero
    sCorrection = sCurrExponent - sTargetExponent;
    if(!sCorrection) return ulBaseValue; // no correction
    if(sCorrection < 0)
    {
        for (; sCorrection < 0; sCorrection++) {
            ulBaseValue /= 10;
        }
        return ulBaseValue;
    } else {
        for (; sCorrection > 0; sCorrection--) {
            ulBaseValue *= 10;
        }
        return ulBaseValue;
    }
}



NTSTATUS
DoIoctl(
            PDEVICE_OBJECT pDeviceObject,
            ULONG ulIOCTL,
            PVOID pInputBuffer,
            ULONG ulInputBufferLength,
            PVOID pOutputBuffer,
            ULONG ulOutputBufferLength,
            CHidDevice * pHidDevice)
{
    IO_STATUS_BLOCK StatusBlock;
    NTSTATUS ntStatus;
    PIRP pIrp = NULL;
    PIO_STACK_LOCATION pNewStack;
    KEVENT IOCTLEvent;

    HIDDebugBreak(HIDBATT_BREAK_DEBUG);
    //CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    KeInitializeEvent(&IOCTLEvent , NotificationEvent, FALSE);
    pIrp = IoBuildDeviceIoControlRequest(
                        ulIOCTL,
                        pDeviceObject,
                        pInputBuffer,
                        ulInputBufferLength,
                        pOutputBuffer,
                        ulOutputBufferLength,
                        FALSE,
                        &IOCTLEvent,
                        &StatusBlock
                        );

    if(!pIrp) return STATUS_NO_MEMORY;
    // stuff file control block if requested (non-null hid device ptr)
    if(pHidDevice)
    {
        pNewStack = IoGetNextIrpStackLocation(pIrp);
        pNewStack->FileObject = pHidDevice->m_pFCB;
    }

    ntStatus = IoCallDriver(pDeviceObject,pIrp);
    if(ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&IOCTLEvent, Executive, KernelMode, FALSE, NULL);
    } else
        if(NT_ERROR(ntStatus)) return ntStatus;

    return StatusBlock.Status;
}

// This is a direct adaption of Ken Ray's function to populate the hid inforation structures

PHID_DEVICE SetupHidData(
                  IN        PHIDP_PREPARSED_DATA pPreparsedData,
                  IN OUT    PHIDP_CAPS pCaps,
                  PHIDP_LINK_COLLECTION_NODE pLinkNodes)
{
    PHID_DEVICE         pHidDevice;
    PHIDP_BUTTON_CAPS   pButtonCaps;
    PHIDP_VALUE_CAPS    pValueCaps;
    PHID_DATA           pHidData;
    int                 iNumValues,i;
    USAGE               usage;


    pHidDevice = (PHID_DEVICE) ExAllocatePoolWithTag(NonPagedPool,sizeof(HID_DEVICE),HidBattTag);
    if(!pHidDevice) return NULL;
    RtlZeroMemory(pHidDevice,sizeof(HID_DEVICE));
    //
    // At this point the client has a choice.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we look for all of the usages in the device.
    //



    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    if(pCaps->NumberInputButtonCaps)
    {
        pHidDevice->InputButtonCaps = pButtonCaps = (PHIDP_BUTTON_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberInputButtonCaps * sizeof (HIDP_BUTTON_CAPS),HidBattTag);
        
        if (pButtonCaps) {
          RtlZeroMemory(pButtonCaps,pCaps->NumberInputButtonCaps * sizeof(HIDP_BUTTON_CAPS));
        }
    }
    if(pCaps->NumberInputValueCaps)
    {
        pHidDevice->InputValueCaps = pValueCaps = (PHIDP_VALUE_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberInputValueCaps * sizeof (HIDP_VALUE_CAPS),HidBattTag);

        if (pValueCaps) {
          RtlZeroMemory(pValueCaps, pCaps->NumberInputValueCaps * sizeof (HIDP_VALUE_CAPS));
        }
    }

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    if(pButtonCaps)
    {
        HidP_GetButtonCaps (HidP_Input,
                        pButtonCaps,
                        &pCaps->NumberInputButtonCaps,
                        pPreparsedData);
    }

    if(pValueCaps)
    {
        HidP_GetValueCaps (HidP_Input,
                       pValueCaps,
                       &pCaps->NumberInputValueCaps,
                       pPreparsedData);
    }


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    iNumValues = 0;
    for (i = 0; i < pCaps->NumberInputValueCaps; i++, pValueCaps++) {
        if ((pValueCaps) && (pValueCaps->IsRange)) {
            iNumValues += pValueCaps->Range.UsageMax - pValueCaps->Range.UsageMin + 1;
        } else {
            iNumValues++;
        }
    }


    //
    // setup Output Data buffers.
    //

    if(pCaps->NumberOutputButtonCaps)
    {
        pHidDevice->OutputButtonCaps = pButtonCaps = (PHIDP_BUTTON_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberOutputButtonCaps * sizeof (HIDP_BUTTON_CAPS),HidBattTag);
        HidP_GetButtonCaps (HidP_Output,
                            pButtonCaps,
                            &pCaps->NumberOutputButtonCaps,
                            pPreparsedData);
    }
    iNumValues = 0;

    if(pCaps->NumberOutputValueCaps)
    {
        pHidDevice->OutputValueCaps = pValueCaps = (PHIDP_VALUE_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberOutputValueCaps * sizeof (HIDP_VALUE_CAPS),HidBattTag);
        HidP_GetValueCaps (HidP_Output,
                       pValueCaps,
                       &pCaps->NumberOutputValueCaps,
                       pPreparsedData);
        for (i = 0; i < pCaps->NumberOutputValueCaps; i++, pValueCaps++) {
            if (pValueCaps->IsRange) {
                iNumValues += pValueCaps->Range.UsageMax
                           - pValueCaps->Range.UsageMin + 1;
            } else {
                iNumValues++;
            }
        }
    }


    //
    // setup Feature Data buffers.
    //


    if(pCaps->NumberFeatureButtonCaps)
    {
        pHidDevice->FeatureButtonCaps = pButtonCaps = (PHIDP_BUTTON_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberFeatureButtonCaps * sizeof (HIDP_BUTTON_CAPS),HidBattTag);
        RtlZeroMemory(pButtonCaps, pCaps->NumberFeatureButtonCaps * sizeof(HIDP_BUTTON_CAPS));
        HidP_GetButtonCaps (HidP_Feature,
                            pButtonCaps,
                            &pCaps->NumberFeatureButtonCaps,
                            pPreparsedData);
    }
    if(pCaps->NumberFeatureValueCaps)
    {
        pHidDevice->FeatureValueCaps = pValueCaps = (PHIDP_VALUE_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberFeatureValueCaps * sizeof (HIDP_VALUE_CAPS),HidBattTag);
        RtlZeroMemory(pValueCaps, pCaps->NumberFeatureValueCaps * sizeof (HIDP_VALUE_CAPS));
        HidP_GetValueCaps (HidP_Feature,
                           pValueCaps,
                           &pCaps->NumberFeatureValueCaps,
                           pPreparsedData);

    }


    iNumValues = 0;
    for (i = 0; i < pCaps->NumberFeatureValueCaps; i++, pValueCaps++) {
        if (pValueCaps->IsRange) {
            iNumValues += pValueCaps->Range.UsageMax
                       - pValueCaps->Range.UsageMin + 1;
        } else {
            iNumValues++;
        }
    }


    return pHidDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\drvclass.cpp ===
/*
 * title:      drvclass.cpp
 *
 * purpose:    Implement C++ utilities
 *
 *
 */

extern "C"
{

#include <ntddk.h>

}

#define BOOL BOOLEAN
#define BYTE unsigned char
#define PBYTE unsigned char *

#include "drvclass.h"

#define HidBattTag 'HtaB'

extern "C" NTSTATUS DriverEntry (DRIVER_OBJECT *, UNICODE_STRING *);

void * __cdecl operator new(size_t nSize, POOL_TYPE iType, ULONG iPoolTag)
{
    return ExAllocatePoolWithTag(iType,nSize,iPoolTag);
};

void __cdecl operator delete(void* p)
{
    ExFreePool(p);
};

// CUString::CUString()
//
// Default constructor.  Creates an empty string.
//
CUString :: CUString()
{

    m_String.MaximumLength = 0;
    m_String.Length = 0;
    m_String.Buffer = NULL;

    m_bType = TYPE_SYSTEM_ALLOCATED;
    m_status = STATUS_SUCCESS;

}

//
// CUString::CUString( CUString& )
//
// Copy constructor
//
CUString :: CUString( CUString * pNewString )
{

/*
    RtlInitUnicodeString( &m_String, NULL );

    m_String.MaximumLength = NewString.m_String.MaximumLength;
    m_String.Length = 0;
    m_String.Buffer = ( unsigned short* )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );

    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    RtlZeroMemory( m_String.Buffer, m_String.MaximumLength );
    RtlAppendUnicodeStringToString( &m_String, &NewString.m_String );

    m_bType = TYPE_CLASS_ALLOCATED;
    m_status = STATUS_SUCCESS;
    m_String.Buffer[ m_String.Length ] = NULL;
*/
    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_status                = STATUS_SUCCESS;
    m_String.MaximumLength  = pNewString->m_String.MaximumLength;
    m_String.Length            = pNewString->m_String.Length;
    m_String.Buffer            = ( PWSTR )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();
    memcpy( m_String.Buffer, pNewString->m_String.Buffer, m_String.MaximumLength );

}

//
// CUString::CUString( UNICODE_STRING& )
//
// Copy constructor for UNICODE_STRING objects
//
CUString :: CUString( UNICODE_STRING * NewString )
{

/*
    RtlInitUnicodeString( &m_String, NULL );

    m_bType = TYPE_CLASS_ALLOCATED;
    m_String.MaximumLength = NewString.MaximumLength + sizeof( WCHAR );
    m_String.Length = 0;
    m_String.Buffer = ( unsigned short* )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );

    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    RtlCopyUnicodeString( &m_String, &NewString );

    m_status = STATUS_SUCCESS;
    m_String.Buffer[ m_String.Length ] = NULL;
*/

    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_status                = STATUS_SUCCESS;
    m_String.MaximumLength    = NewString->Length + sizeof( WCHAR );
    m_String.Length            = NewString->Length;
    m_String.Buffer            = ( PWSTR )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();

    memcpy( m_String.Buffer, NewString->Buffer, m_String.Length );

}

//
// CUString::CUString( PWCHAR )
//
// Copy constructor for WCHAR pointer objects
//
CUString :: CUString( PWCHAR NewString )
{


    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_status                = STATUS_SUCCESS;
    m_String.Length            = ( unsigned short )( Length( NewString ) * sizeof( WCHAR ) );
    m_String.MaximumLength    = m_String.Length + sizeof( WCHAR );
    m_String.Buffer            = ( PWSTR )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();

    memcpy( m_String.Buffer, NewString, m_String.Length );

}

//
// CUString::CUString( int )
//
// Constructor which creates an empty string but
// allocates a string buffer of the given size of characters
//
CUString :: CUString( int nSize )
{

    ASSERT( nSize >= 0 );

    m_bType = TYPE_CLASS_ALLOCATED;
    m_String.MaximumLength    = 0;
    m_String.Length            = 0;
    m_String.Buffer            = NULL;

    if( nSize > 0 )
    {

        m_String.MaximumLength = (USHORT)(( nSize + 1 ) * sizeof( WCHAR ));

        if( nSize )
        {

            m_String.Buffer = (PWSTR)ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
            if( !m_String.Buffer )
            {

                m_status = STATUS_INSUFFICIENT_RESOURCES;
                return;

            }

            ZeroBuffer();

        }

    }

    m_status = STATUS_SUCCESS;

}

//
// CUString::CUString( UNICODE_STRING& )
//
// Constructor with creates a string that is a representation
// of the given integer and radix.
//
CUString :: CUString( int iVal, int iBase )
{

    m_status                = STATUS_INSUFFICIENT_RESOURCES;
    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_String.Length            = 0;
    m_String.MaximumLength    = 0;
    m_String.Buffer            = NULL;

    int iSize = 1;
    int iValCopy = ( !iVal ) ? 1 : iVal;

    while( iValCopy >= 1 )
    {

        iValCopy /= iBase;
        iSize++;

    };

    //
    // iSize is the number of digits in number, max length of string
    // is iSize plus the null terminator
    //
    m_String.MaximumLength = (USHORT)(( iSize + 1 ) * sizeof( WCHAR ));

    m_String.Buffer = (PWSTR)ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    ASSERT( m_String.Buffer );

    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();

    m_status = RtlIntegerToUnicodeString(iVal, iBase, &m_String);

}

//
// CUString::~CUString()
//
// Destructor which frees the string buffer if:
//    1. It exists,
//     and
//  2. It was allocated by the class
//
CUString :: ~CUString()
{

    //
    // If the buffer exists and was allocated by the class, free it.
    //
    if( ( m_bType == TYPE_CLASS_ALLOCATED ) && m_String.Buffer )
    {

        ExFreePool(m_String.Buffer);

    }

}

//
// CUString::Append( CUString& )
//
// Append the given string to the object
//
void CUString :: Append( CUString * Append )
{

    UNICODE_STRING NewString;

    //
    // Determine the length of the new string ( including a null ) and allocate its memory
    //
    NewString.MaximumLength = m_String.Length + Append->m_String.Length + sizeof( WCHAR );
    NewString.Length = 0;
    NewString.Buffer = (PWSTR)ExAllocatePoolWithTag( PagedPool, NewString.MaximumLength, HidBattTag );

    ASSERT( NewString.Buffer );

    //
    // Check for allocation failure.
    //
    if( !NewString.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    RtlZeroMemory( NewString.Buffer, NewString.MaximumLength );

    //
    // Copy the original string into the new string
    //
    RtlCopyUnicodeString( &NewString, &m_String );

    //
    // Append the 'append' string onto the new string
    //
    NTSTATUS Status = RtlAppendUnicodeStringToString( &NewString, &Append->m_String );

    //
    // If we allocated the original string, free it
    //
    if( m_bType == TYPE_CLASS_ALLOCATED && m_String.Buffer )
    {

        ExFreePool( m_String.Buffer );

    }

    //
    // Copy the new string into the original strings place
    //
    m_String.MaximumLength    = NewString.MaximumLength;
    m_String.Length            = NewString.Length;
    m_String.Buffer            = NewString.Buffer;
    m_bType                    = TYPE_CLASS_ALLOCATED;

    m_status = Status;

}

//
// CUString::Append( UNICODE_STRING* )
//
// Append the given string to the object
//
void CUString :: Append( UNICODE_STRING* pAppendString )
{

    ASSERT( pAppendString );

    if( !pAppendString )
        return;

    CUString AppendString( pAppendString );

    Append( &AppendString );

}
/*
//
// operator + ( UNICODE_STRING&, ULONG& )
//
CUString operator + ( UNICODE_STRING * pUCS, ULONG dwValue )
{

    // This routine is broken for now...don't use...
    ASSERT( 0 );

    CUString ReturnString( pUCS );
    CUString ValueString( dwValue, 10 );

    ReturnString.Append( ValueString );

    return ReturnString;

}

//
// operator + ( CUString&, CUString& )
//
CUString operator + ( CUString& l, CUString& r )
{

    CUString ReturnString( l );
    ReturnString.Append( r );

    return ReturnString;

}

//
// operator + ( UNICODE_STRING&, UNICODE_STRING& )
//
CUString operator + ( UNICODE_STRING& l, UNICODE_STRING& r )
{

    CUString ReturnValue( l );
    CUString Right( r );

    ReturnValue.Append( Right );

    return ReturnValue;

}
*/

//
// operator = ( CUString )
//
void CUString :: operator = ( CUString str )
{

    m_String.Length            = str.m_String.Length;
    m_String.MaximumLength    = str.m_String.MaximumLength;
    m_String.Buffer            = NULL;

    //
    // If the source string has a non-zero length buffer make a buffer of
    // equal size in the destination.
    //
    if( str.m_String.MaximumLength > 0 )
    {

        m_String.Buffer    = (PWSTR)ExAllocatePoolWithTag( PagedPool, str.m_String.MaximumLength, HidBattTag );
        if( !m_String.Buffer )
        {

            m_status = STATUS_INSUFFICIENT_RESOURCES;
            return;

        }

        ZeroBuffer();

        //
        // If the source string has a non-zero length, copy it into the dest string.
        //
        if( str.m_String.Length > 0 )
        {

            memcpy( m_String.Buffer, str.m_String.Buffer, str.m_String.Length );

        }

    }

    m_bType = TYPE_CLASS_ALLOCATED;
    m_status = STATUS_SUCCESS;

}

NTSTATUS CUString :: ToCString( char** pString )
{

    ULONG dwLength = m_String.Length >> 1;

    *pString = ( char* )ExAllocatePoolWithTag( PagedPool, dwLength + 1, HidBattTag );
    if(    !*pString )
        return STATUS_UNSUCCESSFUL;

    char* pDst = *pString;
    char* pSrc = ( char* )m_String.Buffer;

    while( *pSrc )
    {

        *pDst++ = *pSrc;

        pSrc += sizeof( WCHAR );

    }

    *pDst = 0x0;

    return STATUS_SUCCESS;

}

void CUString :: Dump()
{

    char* pString;

    ToCString( &pString );

    KdPrint( ( pString ) );
    KdPrint( ( "\n" ) );

    ExFreePool( pString );

}

ULONG CUString :: Length( PWCHAR String )
{

    ULONG dwLength = 0;

    while( *String++ )
    {

        dwLength++;

    }

    return dwLength;

}

// the registry access class

CRegistry::CRegistry(int iSize)
{ m_status = STATUS_INSUFFICIENT_RESOURCES;
  m_pTable = (PRTL_QUERY_REGISTRY_TABLE)
        ExAllocatePoolWithTag(NonPagedPool,sizeof(RTL_QUERY_REGISTRY_TABLE)*(iSize+1),HidBattTag);
  if(m_pTable)
   {
    m_status = STATUS_SUCCESS;
    RtlZeroMemory(m_pTable,sizeof(RTL_QUERY_REGISTRY_TABLE)*(iSize+1)); //this will terminate the table
   };                                                                  // appropriately

};
CRegistry::~CRegistry()
{
 if (m_pTable) ExFreePool(m_pTable);
};


BOOL CRegistry::QueryDirect(CUString *location,CUString *key, void **pReceiveBuffer, ULONG uType)
{
   ULONG zero = 0;

m_pTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
m_pTable[0].Name = key->m_String.Buffer;
m_pTable[0].EntryContext = *pReceiveBuffer;
m_pTable[0].DefaultType = uType;
m_pTable[0].DefaultData = &zero;
m_pTable[0].DefaultLength = sizeof(ULONG); // there must be something here, but we need to know what...
KdPrint( ( "RegClass QueryDirect:  to retrieve Reg name...\n" ) );
location->Dump();
key->Dump();

if (STATUS_SUCCESS!=
    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,location->m_String.Buffer,m_pTable,NULL,NULL))
  return FALSE;
return TRUE;
};

/*NTSTATUS CRegistry::QueryMustExist( CUString* pwzLocation, CUString* pwzKey, void **pReceiveBuffer )
{
    m_pTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_REQUIRED;
    m_pTable[0].Name         = pwzKey->m_String.Buffer;
    m_pTable[0].EntryContext = *pReceiveBuffer;

    KdPrint( ( "RegClass QueryMustExist(): to retriee Reg name...\n" ) );
    pwzLocation->Dump();
    pwzKey->Dump();

    return RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE, pwzLocation->m_String.Buffer, m_pTable, NULL, NULL );
}
*/

BOOL CRegistry::QueryWithCallback(PRTL_QUERY_REGISTRY_ROUTINE callback,ULONG RelativeTo,PWSTR Path,PVOID Context, PVOID Environment)
{
m_pTable[0].QueryRoutine = callback;
m_pTable[0].Name = NULL;
m_status = RtlQueryRegistryValues(RelativeTo|RTL_REGISTRY_OPTIONAL,Path,m_pTable,Context,Environment);
return NT_SUCCESS(m_status);
};

BOOL CRegistry::WriteString(ULONG relativeTo, CUString *pBuffer, CUString *pPath, CUString *pKey)
{
 return NT_SUCCESS(RtlWriteRegistryValue(relativeTo, pPath->GetString(), pKey->GetString(),REG_SZ,pBuffer->GetString(),pBuffer->GetLength()+sizeof(UNICODE_NULL)));
};

BOOL CRegistry::WriteDWord(ULONG relativeTo, void *pBuffer,CUString *pPath,CUString *pKey)
{
 return NT_SUCCESS(RtlWriteRegistryValue(relativeTo, pPath->GetString(), pKey->GetString(),REG_DWORD,pBuffer,sizeof(REG_DWORD)));
};

NTSTATUS CRegistry::zwOpenKey(HANDLE * pKeyHandle,HANDLE hRoot,ACCESS_MASK DesiredAccess,CUString * pPath)
{
    OBJECT_ATTRIBUTES  ThisObject;
    NTSTATUS status;
    CUString ThisNull(NULL);
    // setup target object for call

    InitializeObjectAttributes( &ThisObject,
                            &(pPath->m_String),
                            OBJ_CASE_INSENSITIVE,
                            hRoot,
                            NULL);

    KdPrint( ( "RESMAN: Opening registry key: " ) );
    pPath->Dump();

    status = ZwOpenKey( pKeyHandle,
                        DesiredAccess,
                        &ThisObject );

    return status;
}

/*
NTSTATUS CRegistry::DeleteKey(HANDLE hTheKey)
{
    return ZwDeleteKey(hTheKey);
}
*/

NTSTATUS CRegistry::zwCreateKey(HANDLE * pKeyHandle,HANDLE hRoot,ACCESS_MASK DesiredAccess,CUString * pPath,ULONG CreateOptions)
{
    OBJECT_ATTRIBUTES  ThisObject;
    NTSTATUS status;
    // setup target object for call

    InitializeObjectAttributes( &ThisObject,
                            &(pPath->m_String),
                            OBJ_CASE_INSENSITIVE,
                            hRoot,
                            NULL);

    KdPrint( ( "RESMAN: Creating registry key:  " ) );
    pPath->Dump();

    status = ZwCreateKey(pKeyHandle,
                            DesiredAccess,
                            &ThisObject,
                            0,
                            NULL,
                            CreateOptions,
                            (ULONG*)&m_lDisposition);
    return status;
}

BOOL CRegistry::zwCloseKey(HANDLE TheKey)
{
    return NT_SUCCESS(ZwClose(TheKey));
}

NTSTATUS CRegistry::zwWriteValue(HANDLE hTheKey,CUString * ValueName,ULONG lType,PVOID pData,ULONG lSize)
{
    NTSTATUS status;
    status  = ZwSetValueKey(hTheKey,
            &ValueName->m_String,
            0,
            lType,
            pData,
            lSize);
    return status;
}

NTSTATUS CRegistry::CheckKey(ULONG RelativeTo ,PUNICODE_STRING puRegKey)
{

//    return (RtlCheckRegistryKey( RelativeTo,(PWSTR)puRegKey));
    return FALSE;
}

// error logging methods
/*
CErrorLogEntry::CErrorLogEntry(PVOID pSource, ULONG errorCode, USHORT dumpDataSize, ULONG uniqueErrorValue,
                    NTSTATUS status, ULONG *dumpData, UCHAR FunctionCode)
{
m_pPacket = (PIO_ERROR_LOG_PACKET)
    IoAllocateErrorLogEntry(pSource, (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)+
                                              (dumpDataSize * sizeof(ULONG))));
if (!m_pPacket) return;
int i;
m_pPacket->ErrorCode = errorCode;
m_pPacket->DumpDataSize = dumpDataSize * sizeof(ULONG);
m_pPacket->SequenceNumber = 0;
m_pPacket->MajorFunctionCode = FunctionCode;
m_pPacket->IoControlCode = 0;
m_pPacket->RetryCount = 0;
m_pPacket->UniqueErrorValue = uniqueErrorValue;
m_pPacket->FinalStatus = status;
for (i = 0; i < dumpDataSize; i++)
   m_pPacket->DumpData[i] = dumpData[i];
IoWriteErrorLogEntry(m_pPacket);
};


CErrorLogEntry::~CErrorLogEntry()
{
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\drvclass.h ===
#ifndef _DRVCLASS_H
#define _DRVCLASS_H

/*
 * title:      drvclass.h
 *
 * purpose:    header for wdm kernel device support class
 *
 */


#define FALSE 0
#define BOOL BOOLEAN
#define BYTE unsigned char
#define PBYTE unsigned char *

//
// CPacket
//
// A ringbuffer "node" class
//
class CPacket
{

// Methods
public:

    USHORT&     Function()  { return m_Function; }
    USHORT&     Socket()    { return m_Socket; }

// Instance variables
private:

    USHORT m_Function;
    USHORT m_Socket;

};

//
// CRingBuffer
//
// A ringbuffer class
//
class CRingBuffer
{

// Construction
public:

    CRingBuffer( ULONG dwSize = 32, POOL_TYPE PoolType = PagedPool );
    ~CRingBuffer();

// Methods
public:
    
    void    Insert( CPacket& APacket );
    BOOL    Remove( CPacket* APacket );
    BOOL    IsEmpty();
    BOOL    IsValid() const { return ( m_pBuffer && m_pListMutex ); }

// Restricted Access Methods
protected:

    void    Lock();
    void    Unlock();

// Instance Variables
private:

    ULONG       m_Producer;
    ULONG       m_Consumer;
    CPacket*    m_pBuffer;

    PKMUTEX     m_pListMutex;
    ULONG       m_dwSize;
        
};

//
// CUString
//
// A class that encapsulates the functionality of
// unicode strings.
//
// Revised on 03-May-96 - JohnT
//
#define OK_ALLOCATED(obj) \
   ((obj!=(void *)0) && NT_SUCCESS((obj)->m_status))

void * __cdecl operator new(size_t nSize, POOL_TYPE iType, ULONG iPoolTag);

void __cdecl operator delete(void* p);

class CUString
{

// Construction
public:

    // new CUString()
    CUString();

    // new CUString( ExistingCUString )
    CUString( CUString * );

    // new CUString( ExistingUnicodeString )
    CUString( UNICODE_STRING *);

    // new CUString( L"String" );
    CUString( PWCHAR );

    // new CUString( nNewLength );
    CUString( int );

    // new CUString( 105, 10 );
    CUString( int, int );

    // Standard destructor
    ~CUString();

// Methods
public:

    // String appending.  Argument is appended to object
    void    Append( CUString * );
    void    Append( UNICODE_STRING* );
                                
    void    CopyTo( CUString* pTarget );

    BOOL    operator == ( CUString& );

    void    operator = ( CUString );

    int     GetLength() const   { return m_String.Length; }
    PWCHAR  GetString()         { return m_String.Buffer; }
    void    SetLength( USHORT i )   { m_String.Length = i; }

    NTSTATUS    ToCString( char** );
    static ULONG        Length( PWCHAR );
    void    Dump();

// Class Methods
protected:

    void    NullTerminate()
    { m_String.Buffer[ m_String.Length / sizeof( WCHAR ) ] = ( WCHAR )NULL; }

    void    ZeroBuffer()
    { ASSERT( m_String.Buffer ); RtlZeroMemory( m_String.Buffer, m_String.MaximumLength ); }

// Enums
public:

    enum
    {
        TYPE_SYSTEM_ALLOCATED = 0,
        TYPE_CLASS_ALLOCATED,
    };


// Instance Variables
public:
    
    UNICODE_STRING  m_String;
    NTSTATUS        m_status;
    unsigned char   m_bType;

};


class CRegistry
{
  private: PRTL_QUERY_REGISTRY_TABLE m_pTable;
  public: NTSTATUS m_status;
          signed long m_lDisposition;
  public: CRegistry(int iSize);
          ~CRegistry();
          BOOL QueryDirect(CUString *location,CUString *key, void **pReceiveBuffer, ULONG uType);
          BOOL QueryWithCallback(PRTL_QUERY_REGISTRY_ROUTINE callback,ULONG RelativeTo,PWSTR Path,PVOID Context, PVOID Environment);
          BOOL WriteString(ULONG relativeTo, CUString *pBuffer, CUString *pPath, CUString *pKey);
          BOOL WriteDWord(ULONG relativeTo, void *pBuffer,CUString *pPath,CUString *pKey);
          NTSTATUS zwCreateKey(HANDLE * pKeyHandle,HANDLE root,ACCESS_MASK DesiredAccess,CUString * pPath,ULONG CreateOptions);
          NTSTATUS zwOpenKey(HANDLE * pKeyHandle, HANDLE root, ACCESS_MASK DesiredAccess,CUString * pPath);
          BOOL zwCloseKey(HANDLE KeyHandle);
          NTSTATUS zwWriteValue(HANDLE hTheKey,CUString * ValueName,ULONG lType,PVOID pData,ULONG lSize);
          NTSTATUS CheckKey(ULONG RelativePath,PUNICODE_STRING path);
};


class CErrorLogEntry
{
  private: PIO_ERROR_LOG_PACKET m_pPacket;
  public: CErrorLogEntry(PVOID,ULONG,USHORT,ULONG,NTSTATUS,ULONG *,UCHAR);
          ~CErrorLogEntry();
};

#endif //drvclass.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\inc\ec.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ec.h

Abstract:

    Embedded Controller Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/


//
// Internal ioctls to EC driver
//

#define EC_CONNECT_QUERY_HANDLER    CTL_CODE(FILE_DEVICE_UNKNOWN, 5, METHOD_NEITHER, FILE_ANY_ACCESS)
#define EC_DISCONNECT_QUERY_HANDLER CTL_CODE(FILE_DEVICE_UNKNOWN, 6, METHOD_NEITHER, FILE_ANY_ACCESS)
#define EC_GET_PDO                  CTL_CODE(FILE_DEVICE_UNKNOWN, 7, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef
VOID
(*PVECTOR_HANDLER) (
    IN ULONG            QueryVector,
    IN PVOID            Context
    );

typedef struct {
    ULONG               Vector;
    PVECTOR_HANDLER     Handler;
    PVOID               Context;
    PVOID               AllocationHandle;
} EC_HANDLER_REQUEST, *PEC_HANDLER_REQUEST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\hidbattpnp.cpp ===
/*
 * title:      hidbattpnp.cpp
 *
 * purpose:    support for plug and play routines
 *
 * Initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * Windows 98 support
 *
 */


#include "hidbatt.h"

NTSTATUS HidBattInitializeDevice (PDEVICE_OBJECT pBatteryFdo, PIRP pIrp)
{

    NTSTATUS            ntStatus;
    CBatteryDevExt *    pDevExt = (CBatteryDevExt *) pBatteryFdo->DeviceExtension;
    PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    ULONG               ulBatteryStatus;
    bool                bResult;
    BATTERY_MINIPORT_INFO   BattInit;
    UNICODE_STRING      Name;
    ULONG               ulBufferLength = 0;
    PWCHAR              pBuffer = NULL;
    CBattery *          pBattery;
    PFILE_OBJECT        fileObject;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              fileHandle;
    IO_STATUS_BLOCK     ioStatus;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    HidBattPrint (HIDBATT_PNP, ("HidBattInitializeDevice: Sending Irp (0x%x) to Pdo\n", pIrp));

    // now get file object using KenRay's method from mouclass
    ntStatus = IoGetDeviceProperty (
                     pDevExt->m_pHidPdo,
                     DevicePropertyPhysicalDeviceObjectName,
                     ulBufferLength,
                     pBuffer,
                     &ulBufferLength);
    if(ntStatus != STATUS_BUFFER_TOO_SMALL)
    {
        // only thing we expect with a zero buffer is this error,
        // any other error must be fatal
        return STATUS_UNSUCCESSFUL;
    }


    pBuffer = (PWCHAR) ExAllocatePoolWithTag (NonPagedPool, ulBufferLength, HidBattTag);

    if (NULL == pBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ntStatus =  IoGetDeviceProperty (
                  pDevExt->m_pHidPdo,
                  DevicePropertyPhysicalDeviceObjectName,
                  ulBufferLength,
                  pBuffer,
                  &ulBufferLength);

    if(NT_ERROR(ntStatus))
    {
        ExFreePool(pBuffer);
        return ntStatus;

    }


    Name.MaximumLength = (USHORT) ulBufferLength;
    Name.Length = (USHORT) ulBufferLength - sizeof (UNICODE_NULL);
    Name.Buffer = pBuffer;

    pDevExt->m_OpeningThread = KeGetCurrentThread();

    //
    // Initialize the object attributes to open the device.
    //

    InitializeObjectAttributes( &objectAttributes,
                                &Name,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    ntStatus = ZwOpenFile( &fileHandle,
                         FILE_ALL_ACCESS,
                         &objectAttributes,
                         &ioStatus,
                         FILE_SHARE_WRITE | FILE_SHARE_READ, 
                         FILE_NON_DIRECTORY_FILE );

    ExFreePool (pBuffer);

    if (NT_SUCCESS( ntStatus )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        ntStatus = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pDevExt->m_pHidFileObject,
                                            NULL );

        ZwClose( fileHandle );
    }

    pDevExt->m_OpeningThread = NULL;
    if(NT_ERROR(ntStatus))
    {
        return ntStatus;
    }

    // now init new hid deviceclass object for this device
    CHidDevice * pHidDevice = new (NonPagedPool, HidBattTag) CHidDevice;  // setup a new hid device

    if (!pHidDevice) {
      HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error allocating CHidDevice"));
      return STATUS_UNSUCCESSFUL;
    }

    pHidDevice->m_pFCB = pDevExt->m_pHidFileObject; // put usable file object into hid device
    pHidDevice->m_pLowerDeviceObject = pDevExt->m_pLowerDeviceObject;
    pHidDevice->m_pDeviceObject = pDevExt->m_pBatteryFdo;
    pHidDevice->m_pReadIrp = NULL;
    bResult = pHidDevice->OpenHidDevice(pDevExt->m_pHidPdo); // initialize the members of this device

    if(!bResult)
    {
        delete pHidDevice;
        return STATUS_UNSUCCESSFUL;
    }

    // check if this has a power page, ups application collection

    if(pHidDevice->m_UsagePage != UsagePowerPage || pHidDevice->m_UsageID != UsageUPS)
    {
        delete pHidDevice;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize Fdo device extension data
    //

    // create the battery object
    pBattery            = new (NonPagedPool, HidBattTag) CBattery(pHidDevice);

    if (!pBattery){
      HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error allocating CBattery"));
      return STATUS_UNSUCCESSFUL;
    }
    
    // and initialize battery values
    // now init in both new and replug states
    pBattery->m_pCHidDevice    = pHidDevice;  // save init'ed hid device object
    bResult = pBattery->InitValues();
    if(!bResult)
    {
        return STATUS_UNSUCCESSFUL;
    }

    // Attach to the Class Driver
    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = pDevExt;
    BattInit.QueryTag            = HidBattQueryTag;
    BattInit.QueryInformation    = HidBattQueryInformation;
    BattInit.SetInformation      = HidBattSetInformation;
    BattInit.QueryStatus         = HidBattQueryStatus;
    BattInit.SetStatusNotify     = HidBattSetStatusNotify;
    BattInit.DisableStatusNotify = HidBattDisableStatusNotify;

    BattInit.Pdo                 = pDevExt->m_pHidPdo;
    BattInit.DeviceName          = &pDevExt->m_pBatteryName->m_String;

    pHidDevice->m_pEventHandler = HidBattNotifyHandler;
    pHidDevice->m_pEventContext = (PVOID) pDevExt;

    //
    // save battery in device extension
    // This indicates that we are ready for IO.
    //
    pDevExt->m_pBattery = pBattery;

    //
    // Initialize stop lock
    //
    IoInitializeRemoveLock (&pDevExt->m_StopLock, HidBattTag, 10, 20);

    // and finally we can now start actively polling the device
    // start the read/notification process
    ntStatus = pBattery->m_pCHidDevice->ActivateInput();
    if(!NT_SUCCESS(ntStatus))
    {
        delete pHidDevice;
        HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error (0x%x) in ActivateInput.\n", ntStatus));
        return ntStatus;
    }

    ntStatus = BatteryClassInitializeDevice (&BattInit, &pBattery->m_pBatteryClass);
    if (!NT_SUCCESS(ntStatus))
    {
        //
        //  if we can't attach to class driver we're toast
        //
        delete pHidDevice;
        HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error (0x%x) registering with class\n", ntStatus));
        return ntStatus;
    }

    HidBattPrint(HIDBATT_TRACE, ("HidBattInitializeDevice: returned ok\n"));
    return ntStatus;
}



NTSTATUS
HidBattStopDevice(
    IN PDEVICE_OBJECT pBatteryFdo,
    IN PIRP           pIrp
    )
/*++

Routine Description:

    This routine is called when we receive a IRP_MN_STOP_DEVICE. It just sends the
    request down the chain of drivers to the Pdo and waits for a response.

Arguments:

    Fdo - a pointer to the fdo for this driver
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pBatteryFdo->DeviceExtension;
    KEVENT              pdoStoppedEvent;
    PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    NTSTATUS            ntStatus;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint ((HIDBATT_TRACE | HIDBATT_PNP), ("HidBattStopDevice\n"));

    if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
        //
        // Don't release twice.
        //
        return STATUS_SUCCESS;
    }

    pDevExt->m_bJustStarted = FALSE;

    HidBattPrint (HIDBATT_PNP, ("HidBattStopDevice: Waiting to remove\n"));
    IoReleaseRemoveLockAndWait (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pBatteryClass) {
        BatteryClassUnload(pDevExt->m_pBattery->m_pBatteryClass);
    }

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pCHidDevice &&
        pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp) {
        IoCancelIrp (pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp);
    }

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pCHidDevice &&
        pDevExt->m_pBattery->m_pCHidDevice->m_pThreadObject) {

        //
        // Clean up worker thread.
        //

        KeWaitForSingleObject (
               pDevExt->m_pBattery->m_pCHidDevice->m_pThreadObject,
               Executive,
               KernelMode,
               FALSE,
               NULL
               );
        HidBattPrint (HIDBATT_PNP, ("HidBattStopDevice: Done Waiting to remove\n"));

        ObDereferenceObject (pDevExt->m_pBattery->m_pCHidDevice->m_pThreadObject);
    }

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pCHidDevice &&
        pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp) {
        IoFreeIrp(pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp); // clean up irp
        pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp = NULL;
    }

    //
    // Write default RemainingCapcitylimit back to UPS so the next time we enumerate
    // the device, we'll read back the right data.
    //
    pDevExt->m_pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,
                                     &pDevExt->m_ulDefaultAlert1,TRUE);

    // dereference our file object, if present
    if(pDevExt->m_pHidFileObject) {
        ObDereferenceObject(pDevExt->m_pHidFileObject);
        pDevExt->m_pBattery->m_pCHidDevice->m_pFCB = NULL;
    }


    if (pDevExt->m_pBatteryName) {
        delete pDevExt->m_pBatteryName;
        pDevExt->m_pBatteryName = NULL;
    }

    if (pDevExt->m_pBattery) {
        delete pDevExt->m_pBattery;
        pDevExt->m_pBattery = NULL;
    }

    ntStatus = STATUS_SUCCESS;

    pDevExt->m_bIsStarted = FALSE;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\inc\acpimsft.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpimsft

Abstract:

    This module controls all of the Microsoft specific (ie: not exported to
    anyone outside the company) structures, IOCTLS, and Defines.

    This file is included after acpiioct.h

Author:

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ACPIMSFT_H_
#define _ACPIMSFT_H_

#ifndef _ACPIIOCT_H_
#error Need to include ACPIIOCT.H before ACPIMSFT.H
#endif

//
// IRP_MJ_INTERNAL_DEVICE_CONTROL CODES
//
#define IOCTL_ACPI_REGISTER_OPREGION_HANDLER    CTL_CODE(FILE_DEVICE_ACPI, 0x2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER  CTL_CODE(FILE_DEVICE_ACPI, 0x3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Make sure that we define the right calling convention
//
#ifdef EXPORT
  #undef EXPORT
#endif
#define EXPORT  __cdecl

//
// Data structures used for IOCTL_ACPI_REGISTER_OPREGION
//                          IOCTL_ACPI_UNREGISTER_OPREGION
//
typedef NTSTATUS (EXPORT *PACPI_OPREGION_HANDLER)();
typedef VOID (EXPORT *PACPI_OPREGION_CALLBACK)();

typedef struct _ACPI_REGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    ULONG                   AccessType;
    ULONG                   RegionSpace;
    PACPI_OPREGION_HANDLER  Handler;
    PVOID                   Context;
} ACPI_REGISTER_OPREGION_HANDLER_BUFFER, *PACPI_REGISTER_OPREGION_HANDLER_BUFFER;

typedef struct _ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    PVOID                   OperationRegionObject;
} ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER,*PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER;

//
// Signatures for Register, Unregister of OpRegions
//
#define ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE     'HorA'
#define ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE   'HouA'

//
// Access types for OpRegions
//
#define ACPI_OPREGION_ACCESS_AS_RAW                         0x1
#define ACPI_OPREGION_ACCESS_AS_COOKED                      0x2

//
// Allowable region spaces
//
#define ACPI_OPREGION_REGION_SPACE_MEMORY                   0x0
#define ACPI_OPREGION_REGION_SPACE_IO                       0x1
#define ACPI_OPREGION_REGION_SPACE_PCI_CONFIG               0x2
#define ACPI_OPREGION_REGION_SPACE_EC                       0x3
#define ACPI_OPREGION_REGION_SPACE_SMB                      0x4
#define ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG              0x5
#define ACPI_OPREGION_REGION_SPACE_PCIBARTARGET             0x6

//
// Operation to perform on region
//
#define ACPI_OPREGION_READ                                  0x0
#define ACPI_OPREGION_WRITE                                 0x1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\hidbatt.h ===
#ifndef _HIDBATT_H
#define _HIDBATT_H

/*
 * title:      hidpwr.h
 *
 * purpose:    header for wdm kernel client interface between HID class and power class
 *
 */

extern "C"
{
#include <ntddk.h>
#include <batclass.h>
#include <hidpddi.h>
#include <hidclass.h>
}
#define BOOL BOOLEAN
#define BYTE unsigned char
#define PBYTE unsigned char *
extern "C"
{
#include "hid.h"
//#include "hidport.h"
}

#include "drvclass.h"
#include "ckhid.h"
#include "cbattery.h"
#include "devext.h"

extern USHORT gusInstance;
extern USHORT gBatteryTag;

//
// Debug
//
#if DBG
    extern ULONG HidBattDebug;
    extern USHORT HidBreakFlag;
    #define HidBattPrint(l,m)    if(l & HidBattDebug) DbgPrint m
    #define HIDDebugBreak(l) if((l & HidBreakFlag) ) DbgBreakPoint()
#else
    #define HidBattPrint(l,m)
    #define HIDDebugBreak(l)
#endif

#define HidBattTag 'HtaB'

#define PrintIoctl(ioctlCode) \
        DbgPrint( "DevType %x, Access %x, Function %x, Method %x\n", \
            (ioctlCode >> 16), \
            ((ioctlCode & 0xc0) >> 12), \
            ((ioctlCode & 0x1fc) >> 2), \
            (ioctlCode & 0x03) \
            )

#define MGE_VENDOR_ID    0x0463
#define APC_VENDOR_ID    0x051D  // per Jurang Huang



#define HIDBATT_LOW          0x00000001
#define HIDBATT_NOTE         0x00000002
#define HIDBATT_WARN         0x00000004
#define HIDBATT_ERROR_ONLY   0x00000008
#define HIDBATT_ERROR        (HIDBATT_ERROR_ONLY | HIDBATT_WARN)
#define HIDBATT_POWER        0x00000010
#define HIDBATT_PNP          0x00000020
#define HIDBATT_HID_EXE      0x00000040
#define HIDBATT_DATA         0x00000100
#define HIDBATT_TRACE        0x00000200
#define HIDBATT_DEBUG        0x80000000
#define HIDBATT_PRINT_ALWAYS 0xffffffff
#define HIDBATT_PRINT_NEVER  0x0

#define HIDBATT_BREAK_DEBUG  0x0001
#define HIDBATT_BREAK_FULL   0X0002
#define HIDBATT_BREAK_ALWAYS 0xffff
#define HIDBATT_BREAK_NEVER  0x0000

typedef struct {
    ULONG                   Granularity;
    ULONG                   Capacity;

} BATTERY_REMAINING_SCALE, *PBATTERY_REMAINING_SCALE;

//
// Use the IoSkipCurrentIrpStackLocation routine because the we
// don't need to change arguments, or a completion routine
//
#define HidBattCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }


#define GetTid() PsGetCurrentThread()

//
// Prototypes
//

NTSTATUS DoIoctl(
            PDEVICE_OBJECT pDev,
            ULONG ulIOCTL,
            PVOID pInputBuffer,
            ULONG ulInputBufferLength,
            PVOID pOutputBuffer,
            ULONG ulOutputBufferLength,
            CHidDevice * pHidDevice);




PHID_DEVICE
SetupHidData(
      PHIDP_PREPARSED_DATA pPreparsedData,
      PHIDP_CAPS pCaps,
      PHIDP_LINK_COLLECTION_NODE pLinkNodes);

ULONG CentiAmpSecsToMilliWattHours(ULONG Amps,ULONG Volts);

ULONG milliWattHoursToCentiAmpSecs(ULONG mwHours, ULONG Volts);

// convert a given value from one exponent to another
ULONG CorrectExponent(ULONG ulBaseValue, SHORT sCurrExponent, SHORT sTargetExponent);


extern "C"
{
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
HidBattOpen(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
HidBattClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidBattIoCompletion(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID              pdoIoCompletedEvent
    );

NTSTATUS
HidBattInitializeDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidBattStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidBattIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
HidBattUnload(
    IN PDRIVER_OBJECT   DriverObject
    );



NTSTATUS
HidBattSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

VOID
HidBattAlarm (
    IN PVOID                Context,
    IN UCHAR                Address,
    IN USHORT               Data
    );


NTSTATUS
HidBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
HidBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
HidBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
HidBattQueryTag (
    IN PVOID                Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
HidBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
HidBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
HidBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );


NTSTATUS
HidBattSetInformation (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL Level,
    IN PVOID Buffer OPTIONAL
    );

VOID
HidBattNotifyHandler (
    IN PVOID                Context,
    IN CUsage *             pUsage
    );

VOID
HidBattPowerNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    );

NTSTATUS
HidBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    );

} // extern "C"

#endif // hidbatt_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\hidbatt\hidbattio.cpp ===
/*
 * title:      HidBattIOCT.cpp
 *
 * purpose:    Contains misc ioctl handlers for status and query info mainly
 *
 * Initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * Windows 98 support
 *
 */


#include "hidbatt.h"


/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    Status of request

--*/
NTSTATUS
HidBattIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
{
    NTSTATUS            ntStatus = STATUS_NOT_SUPPORTED;
    CBatteryDevExt *    pDevExt;
    PIO_STACK_LOCATION  irpSp;
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    irpSp = IoGetCurrentIrpStackLocation(pIrp);
    HidBattPrint (HIDBATT_TRACE, ("HidBattIoctl = %x\n", irpSp->Parameters.DeviceIoControl.IoControlCode));

//    PrintIoctl(irpSp->Parameters.DeviceIoControl.IoControlCode);

    pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)))
    {
        if (pDevExt->m_pBattery &&
            pDevExt->m_pBattery->m_pBatteryClass) {
            ntStatus = BatteryClassIoctl (pDevExt->m_pBattery->m_pBatteryClass, pIrp);
        }
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
    } else {
        ntStatus = STATUS_DEVICE_REMOVED;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    }

    if (ntStatus == STATUS_NOT_SUPPORTED)
    {
        HidBattCallLowerDriver(ntStatus, pDevExt->m_pLowerDeviceObject, pIrp);
    }

    return ntStatus;
}

VOID
HidBattNotifyHandler (
    IN PVOID        pContext,
    IN CUsage *        pUsage
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    NTSTATUS ntStatus;
    ULONG ulCapacityLimit = BATTERY_UNKNOWN_CAPACITY;
    BOOL bResult;

    HidBattPrint (HIDBATT_TRACE, ("HidBattNotifyHandler\n"));
    // called by input routine whenever a value change is noted to
    // a notificable usage
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;

    HidBattPrint (HIDBATT_DATA, ("HidBattNotifyHandler: Usage: %x\n", pUsage->m_pProperties->m_Usage));
    switch (pUsage->m_pProperties->m_Usage)
    {
        case    REMAINING_CAPACITY_ID:

          bResult = pDevExt->m_pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,&ulCapacityLimit,FALSE);
          // Only send notification when capacity drops below notify level.
          if ((bResult) && (ulCapacityLimit != BATTERY_UNKNOWN_CAPACITY) && (pUsage->m_Value != BATTERY_UNKNOWN_CAPACITY)
              && (pUsage->m_Value > ulCapacityLimit)) {
               HidBattPrint (HIDBATT_TRACE, ("HidBattNotifyHandler:Suppressing notify\n"));
               break;
          }

        case    AC_PRESENT_ID:            // check for battery off/on line
        case    DISCHARGING_ID:
        case    CHARGING_ID:
        case    BELOW_REMAINING_CAPACITY_ID:
        case    SHUTDOWN_IMMINENT_ID:
        {
            pDevExt->m_pBattery->m_bIsCacheValid=FALSE;

            if (NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
                ntStatus = BatteryClassStatusNotify(
                        pDevExt->m_pBattery->m_pBatteryClass);
                IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
            }
            break;
        }
        default:  // nothing to notify
            break;
    }


    return;
}

NTSTATUS
HidBattQueryTag (
    IN PVOID                pContext,
    OUT PULONG              pulBatteryTag
    )
{

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;

    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    *pulBatteryTag =     pDevExt->m_pBattery->m_Tag;

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
    return STATUS_SUCCESS;
}


NTSTATUS
HidBattSetStatusNotify (
    IN PVOID                pContext,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      pBatteryNotify
    )
{
    bool bResult;
    ULONG CentiAmpSec;
    ULONG ulValue;
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint (HIDBATT_TRACE, ("HidBattSetStatusNotify \n"));
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;
    CBattery * pBattery = pDevExt->m_pBattery;


    HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify->PowerState   = %x\n", pBatteryNotify->PowerState));    
    HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify->LowCapacity  = %x\n", pBatteryNotify->LowCapacity));    
    HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify->HighCapacity = %x\n", pBatteryNotify->HighCapacity));    

    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)))
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    if (pBattery->m_Tag != BatteryTag) {
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((pBatteryNotify->HighCapacity == BATTERY_UNKNOWN_CAPACITY) ||
        (pBatteryNotify->LowCapacity == BATTERY_UNKNOWN_CAPACITY)) {
        HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify failing because of BATTERY_UNKNOWN_CAPACITY.\n"));
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
        return STATUS_NOT_SUPPORTED;
    }

    // first check for relative or absolute
    if(pBattery->m_bRelative)
    {
        ulValue = pBatteryNotify->LowCapacity; // done
    } else
    {
        // first check if setting to zero so that can skip below formula
        if(pBatteryNotify->LowCapacity == 0)
        {
            ulValue = 0;
        } else
        {
            // first must covert value to whatever is being used by this HID device.
            // currently we assume either MilliVolts consistant with battery class or
            // AmpSecs consistant with power spec
            ULONG ulUnit = pBattery->GetUnit(REMAINING_CAPACITY_INDEX);
            if(ulUnit)
            {
                short    sExponent;
                ULONG    lMilliVolts;
                long     milliWattHours,CentiWattHours,CentiWattSecs;

                sExponent = pBattery->GetExponent(REMAINING_CAPACITY_INDEX);

                // conversion from millWattHours to AmpSecs
                // formula = mWHs / 1000 / 3600 / volts ^ exponent correction
                lMilliVolts =  pBattery->m_BatteryStatus.Voltage; // stored as MilliVolts

                if (lMilliVolts == 0) {
                    HidBattPrint (HIDBATT_ERROR,
                                  ("HidBattSetStatusNotify: Error: voltage = 0, fudging with 24V.\n"));
                    lMilliVolts = 24000;
                }
                milliWattHours = pBatteryNotify->LowCapacity;
                CentiWattHours = milliWattHours /10;
                CentiWattSecs = CentiWattHours / 3600;
                CentiAmpSec = (CentiWattSecs *1000)/ lMilliVolts;
                ulValue = CorrectExponent(CentiAmpSec,-2,sExponent);
            } else
            {
                ulValue = pBatteryNotify->LowCapacity;
            }
        } // end if LowCapacity
    }  // end if relative
    // now set low
    bResult = pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,&ulValue,TRUE);

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return bResult ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

NTSTATUS
HidBattDisableStatusNotify (
    IN PVOID pContext
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;
    pDevExt->m_pBattery->m_pBatteryNotify = NULL;  // remove notify procedure
    return STATUS_SUCCESS;
}


/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/

NTSTATUS
HidBattQueryStatus (
    IN PVOID                pContext,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     pBatteryStatus
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    CBatteryDevExt *   pDevExt = (CBatteryDevExt *) pContext;
    NTSTATUS    ntStatus;

    HidBattPrint (HIDBATT_TRACE, ("HidBattQueryStatus - Tag (%d)\n",
                    BatteryTag));

    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((BatteryTag == BATTERY_TAG_INVALID) || (pDevExt->m_pBattery->m_Tag == BATTERY_TAG_INVALID)) {
        ntStatus = STATUS_NO_SUCH_DEVICE;
    } else {

        RtlZeroMemory (pBatteryStatus, sizeof(BATTERY_STATUS));
        ntStatus = pDevExt->m_pBattery->RefreshStatus();
        if (NT_SUCCESS(ntStatus)) {
            RtlCopyMemory (pBatteryStatus, &pDevExt->m_pBattery->m_BatteryStatus, sizeof(BATTERY_STATUS));
            HidBattPrint (HIDBATT_DATA, ("HidBattQueryStatus - Data (%08x)(%08x)(%08x)(%08x)\n",
                                         pBatteryStatus->PowerState,
                                         pBatteryStatus->Capacity,
                                         pBatteryStatus->Rate,
                                         pBatteryStatus->Voltage ));

        } else {
            ntStatus = STATUS_NO_SUCH_DEVICE;
            HidBattPrint (HIDBATT_DATA, ("HidBattQueryStatus - Error\n" ));
        }
    }

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return ntStatus;

}


/*++

Routine Description:

    Called by the class driver to retrieve battery information

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

    We return invalid parameter when we can't handle a request for a
    specific level of information.  This is defined in the battery class spec.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    Level           - type of information required
    AtRate          - Optional Parameter
    Buffer          - Location for the information
    BufferLength    - Length in bytes of the buffer
    ReturnedLength  - Length in bytes of the returned data

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/

NTSTATUS
HidBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
{

    CBatteryDevExt * pDevExt = (CBatteryDevExt *) Context;
    ULONG               ulResult;
    NTSTATUS            ntStatus;
    PVOID               pReturnBuffer;
    ULONG               ulReturnBufferLength;
    WCHAR               scratchBuffer[MAX_BATTERY_STRING_SIZE];
    WCHAR               buffer2[MAX_BATTERY_STRING_SIZE];
    UNICODE_STRING      tmpUnicodeString;
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;
    bool                bResult;
    BATTERY_REMAINING_SCALE     ScalePtr[2];
    ULONG                ulReturn,ulNewValue;
    ULONG                ulEstTimeStub = 5;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Tag (%d)\n",
                    BatteryTag));


    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // If caller has the wrong ID give an error
    //

    if (BatteryTag == BATTERY_TAG_INVALID ||
        pDevExt->m_pBattery->m_Tag == BATTERY_TAG_INVALID ||
        BatteryTag != pDevExt->m_pBattery->m_Tag)
    {
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
        return STATUS_NO_SUCH_DEVICE;
    }

    ulResult = 0;
    pReturnBuffer = NULL;
    ulReturnBufferLength = 0;
    ntStatus = STATUS_SUCCESS;
    CUString cUniqueID;
    SHORT    sExponent;
    char * pTemp;
    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:
            //
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Battery Info\n"));
            pReturnBuffer = (PVOID) &pDevExt->m_pBattery->m_BatteryInfo;
            ulReturnBufferLength = sizeof (pDevExt->m_pBattery->m_BatteryInfo);
            break;

        case BatteryGranularityInformation:
            //
            //  Get the granularity from the static info structure
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            {
                HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Granularity\n"));
                bResult = pDevExt->m_pBattery->GetSetValue(GRANULARITY1_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(GRANULARITY1_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }

                ScalePtr[0].Granularity = bResult ? ulReturn : 0;
                bResult = pDevExt->m_pBattery->GetSetValue(GRANULARITY2_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(GRANULARITY2_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }
                ScalePtr[1].Granularity = bResult ? ulReturn : 0;
                bResult = pDevExt->m_pBattery->GetSetValue(WARNING_CAPACITY_LIMIT_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(WARNING_CAPACITY_LIMIT_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }
                ScalePtr[0].Capacity = bResult ? ulReturn : 0;
                bResult = pDevExt->m_pBattery->GetSetValue(DESIGN_CAPACITY_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(DESIGN_CAPACITY_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }
                ScalePtr[1].Capacity = bResult ? ulReturn : 0;

                pReturnBuffer        = ScalePtr;
                ulReturnBufferLength  = 2 * sizeof (BATTERY_REMAINING_SCALE);
            }
            break;

        case BatteryTemperature:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Temperature\n"));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BatteryEstimatedTime:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Estimated time\n"));
            bResult = pDevExt->m_pBattery->GetSetValue(RUNTIME_TO_EMPTY_INDEX, &ulReturn,FALSE);

            if(!bResult)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            } else
            {
                SHORT exponent;

                exponent = pDevExt->m_pBattery->GetExponent(RUNTIME_TO_EMPTY_INDEX);
                ulReturn = CorrectExponent (ulReturn, exponent, 0);

                pReturnBuffer = &ulReturn;
                ulReturnBufferLength = sizeof (ULONG);
            }
            break;

        case BatteryDeviceName:
            //
            // Model Number must be returned as a wide string
            //
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Device Name\n"));
            if(pDevExt->m_pBattery->m_pProduct)
            {
                pReturnBuffer = pDevExt->m_pBattery->m_pProduct->m_String.Buffer;
                ulReturnBufferLength = pDevExt->m_pBattery->m_pProduct->m_String.Length;
            }
            break;

        case BatteryManufactureDate:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Mfr Date\n"));
            if(!pDevExt->m_pBattery->m_ManufactureDate.Day)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            pReturnBuffer = &pDevExt->m_pBattery->m_ManufactureDate;
            ulReturnBufferLength = sizeof(pDevExt->m_pBattery->m_ManufactureDate);
            break;

        case BatteryManufactureName:
            //
            // Oem Info must be returned as wide string
            //
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Mfr Name\n"));
            if(pDevExt->m_pBattery->m_pManufacturer)
            {
                pReturnBuffer = pDevExt->m_pBattery->m_pManufacturer->m_String.Buffer;
                ulReturnBufferLength = pDevExt->m_pBattery->m_pManufacturer->m_String.Length;
            }

            break;

        case BatteryUniqueID:
            //
            //  Concatenate the serial #, manufacturer name, and Product           //



             // start off with serial number
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Unique ID\n"));
            if(pDevExt->m_pBattery->m_pSerialNumber) {
                HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Serial = %s\n", pDevExt->m_pBattery->m_pSerialNumber));

                cUniqueID.Append(pDevExt->m_pBattery->m_pSerialNumber);
            } else {
                HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Serial = NULL\n"));
                CUString * pSTemp = new (NonPagedPool, HidBattTag) CUString(L"1000");
                if (pSTemp) {
                  cUniqueID.Append(pSTemp);
                  delete pSTemp;
                }
            }
            if(pDevExt->m_pBattery->m_pManufacturer)
                cUniqueID.Append(pDevExt->m_pBattery->m_pManufacturer); // add mfr name
            else
            {
                CUString * pSTemp = new (NonPagedPool, HidBattTag) CUString(L"Mfr");
                if (pSTemp) {
                  cUniqueID.Append(pSTemp);
                  delete pSTemp;
                }
            }
            if(pDevExt->m_pBattery->m_pProduct)
                cUniqueID.Append(pDevExt->m_pBattery->m_pProduct); // add Product
            else
            {
                CUString * pSTemp = new (NonPagedPool, HidBattTag) CUString(L"Prod");
                if (pSTemp) {
                  cUniqueID.Append(pSTemp);
                  delete pSTemp;
                }
            }
            pReturnBuffer = cUniqueID.m_String.Buffer;
            ulReturnBufferLength = cUniqueID.m_String.Length;
            break;
        default:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Default\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Done, return buffer if needed
    //

    *ReturnedLength = ulReturnBufferLength;
    if (BufferLength < ulReturnBufferLength) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(ntStatus) && pReturnBuffer) {
        RtlCopyMemory (Buffer, pReturnBuffer, ulReturnBufferLength);   // Copy what's needed
    }


    HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Status = %08x  Buffer = %08x\n", ntStatus, *(PULONG)Buffer));

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return ntStatus;
}



NTSTATUS
HidBattIoCompletion(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pdoIoCompletedEvent
    )
{
    HidBattPrint (HIDBATT_TRACE, ("HidBattIoCompletion\n"));
    KeSetEvent((KEVENT *) pdoIoCompletedEvent,0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\inc\batt.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    batt.h

Abstract:

    Battery Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

//
// Initialization structure
//

typedef
NTSTATUS
(*BCLASS_QUERY_TAG)(
    IN PVOID Context,
    OUT PULONG BatteryTag
    );

typedef
NTSTATUS
(*BCLASS_QUERY_INFORMATION)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN ULONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
    );

typedef
NTSTATUS
(*BCLASS_QUERY_STATUS)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    );

typedef
NTSTATUS
(*BCLASS_SET_STATUS_NOTIFY)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
    );

typedef
NTSTATUS
(*BCLASS_DISABLE_STATUS_NOTIFY)(
    IN PVOID Context
    );

#define BATTERY_CLASS_MAJOR_VERSION     0x0001
#define BATTERY_CLASS_MINOR_VERSION     0x0000


//
// Class driver functions
//

#if !defined(BATTERYCLASS)
    #define BATTERYCLASSAPI DECLSPEC_IMPORT
#else
    #define BATTERYCLASSAPI
#endif


NTSTATUS
BATTERYCLASSAPI
BatteryClassInitializeDevice (
    IN PBATTERY_MINIPORT_INFO MiniportInfo,
    IN PVOID *ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassUnload (
    IN PVOID ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassIoctl (
    IN PVOID ClassData,
    IN PIRP Irp
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassStatusNotify (
    IN PVOID ClassData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\inc\hctioctl.h ===
/****************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hctioctl.h

Abstract:

	This header file is used both by ring3 app and ring0 driver.

Environment:

    Kernel & user mode

Revision History:

    8-20-96 : created

****************************************************************************/


//
//Values for IOCTL_ACPI_GET_CAPABILITIES
//
#define		SYSTEM_S1_BIT		0
#define		SYSTEM_S1			(1 << SYSTEM_S1_BIT)

#define		SYSTEM_S2_BIT		1
#define		SYSTEM_S2			(1 << SYSTEM_S2_BIT)

#define		SYSTEM_S3_BIT		2
#define		SYSTEM_S3			(1 << SYSTEM_S3_BIT)

#define   CPU_C1_BIT      3
#define   CPU_C1        (1 << CPU_C1_BIN)

#define		CPU_C2_BIT			4
#define		CPU_C2				(1 << CPU_C2_BIT)

#define		CPU_C3_BIT			5
#define		CPU_C3				(1 << CPU_C3_BIT)


//
//Processor States
//
#define		CPU_STATE_C1				1
#define		CPU_STATE_C2				2
#define		CPU_STATE_C3				3


//
//Fan States
//
#define		FAN_OFF							0
#define		FAN_ON							1



//
// IOCTL info
//
	
#define ACPIHCT_IOCTL_INDEX  80


//
//The input buffer must contain a ULONG pointer to one of the
//  SYSTEM_POWER_STATE enum values.
//
#define IOCTL_ACPI_SET_SYSTEM_STATE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+0,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The input buffer must contain a ULONG pointer to one of the
//	Processor States.
//
#define IOCTL_ACPI_SET_PROCESSOR_STATE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+1,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The input buffer must contain a ULONG pointer to on of the Fan
//	States.
//
#define IOCTL_ACPI_SET_FAN_STATE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+2,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The output buffer must contain a ULONG pointer.  The ACPI driver will
//	fill this buffer with the capabilities of the machine.
//
#define IOCTL_ACPI_GET_CAPABILITIES CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+3,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The input buffer must contain a ULONG pointer to a percentage (a
//	number between 1 and 100).
//
#define IOCTL_ACPI_SET_CPU_DUTY_CYCLE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+4,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)



//
//The input buffer must contain a point to a TIME_FIELDS structure
//
#define IOCTL_ACPI_SET_RTC_WAKE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+5,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The output buffer points to a structure that will receive a 
//  TIME_FIELDS structure
//
#define IOCTL_ACPI_GET_RTC_WAKE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+6,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)
                                    
#define IOCTL_ACPI_GET_TEMPERATURE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	    ACPIHCT_IOCTL_INDEX+7,  \
                               	        METHOD_BUFFERED,     \
                                   	    FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\inc\smb.h ===
// Warning, this file is going away.
// It has been replaced with smbus.h which has been added to the DDK

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smb.h

Abstract:

    SMBus Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

//
// SMB Request packet
//

#define SMB_MAX_DATA_SIZE   32

typedef struct {
    UCHAR       Status;             // Completion status
    UCHAR       Protocol;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       BlockLength;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

//
// Protocol values
//

#define SMB_WRITE_QUICK                 0x00    // Issue quick command data bit = 0
#define SMB_READ_QUICK                  0x01    // Issue quick command data bit = 1
#define SMB_SEND_BYTE                   0x02
#define SMB_RECEIVE_BYTE                0x03
#define SMB_WRITE_BYTE                  0x04
#define SMB_READ_BYTE                   0x05
#define SMB_WRITE_WORD                  0x06
#define SMB_READ_WORD                   0x07
#define SMB_WRITE_BLOCK                 0x08
#define SMB_READ_BLOCK                  0x09
#define SMB_PROCESS_CALL                0x0A
#define SMB_MAXIMUM_PROTOCOL            0x0A

//
// SMB Bus Status codes
//

#define SMB_STATUS_OK                   0x00
#define SMB_UNKNOWN_FAILURE             0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED    0x10
#define SMB_DEVICE_ERROR                0x11
#define SMB_COMMAND_ACCESS_DENIED       0x12
#define SMB_UNKNOWN_ERROR               0x13
#define SMB_DEVICE_ACCESS_DENIED        0x17
#define SMB_TIMEOUT                     0x18
#define SMB_UNSUPPORTED_PROTOCOL        0x19
#define SMB_BUS_BUSY                    0x1A

//
// Alarm register/deregister requests
//

typedef
VOID
(*SMB_ALARM_NOTIFY) (
    PVOID       Context,
    UCHAR       Address,
    USHORT      Data
    );

// input buffer is SMB_REGISTER_ALARM.  output buffer is PVOID handle for registration.
// PVOID is passed in via DEREGISTER request to free registration

typedef struct {
    UCHAR               MinAddress;     // Min address for notifications
    UCHAR               MaxAddress;     // Max address for notifications
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;
} SMB_REGISTER_ALARM, *PSMB_REGISTER_ALARM;

//
// Internal ioctls to SMB class driver
//

#define SMB_BUS_REQUEST             CTL_CODE(FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_REGISTER_ALARM_NOTIFY   CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_DEREGISTER_ALARM_NOTIFY CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Shared SMB Class / Miniport driver structure
//

typedef
NTSTATUS
(*SMB_RESET_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
VOID
(*SMB_START_IO)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
NTSTATUS
(*SMB_STOP_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );



typedef struct _SMB_CLASS {
    USHORT              MajorVersion;
    USHORT              MinorVersion;

    PVOID               Miniport;           // Miniport extension data

    PDEVICE_OBJECT      DeviceObject;       // Device object for this miniport
    PDEVICE_OBJECT      PDO;                // PDO for this miniport
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Current IO
    //

    PIRP                CurrentIrp;         // current request
    PSMB_REQUEST        CurrentSmb;         // pointer to SMB_REQUEST in the CurrentIrp

    //
    // Miniport functions
    //

    SMB_RESET_DEVICE    ResetDevice;        // Initialize/Reset, start device
    SMB_START_IO        StartIo;            // Perform IO
    SMB_STOP_DEVICE     StopDevice;         // Stop device

} SMB_CLASS, *PSMB_CLASS;

#define SMB_CLASS_MAJOR_VERSION     0x0001
#define SMB_CLASS_MINOR_VERSION     0x0000

//
// Class driver initializtion functions
//

#if !defined(SMBCLASS)
    #define SMBCLASSAPI DECLSPEC_IMPORT
#else
    #define SMBCLASSAPI
#endif


typedef
NTSTATUS
(*PSMB_INITIALIZE_MINIPORT) (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SMBCLASSAPI
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SMBCLASSAPI
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

//
// Class driver interface functions for use by the miniport
//

VOID
SMBCLASSAPI
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    );


VOID
SMBCLASSAPI
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    );


VOID
SMBCLASSAPI
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    );

VOID
SMBCLASSAPI
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbali\smbali.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smbali.c

Abstract:

    SMB Host Controller Driver for ALI chipset

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/

#include "smbalip.h"

#if DBG
    ULONG SmbAliDebug = SMB_ERROR|SMB_ALARM;
    ULONG DbgSuccess = 0;
    
    ULONG DbgFailure = 0;
    ULONG DbgAddrNotAck   = 0;
    ULONG DbgTimeOut      = 0;
    ULONG DbgOtherErr     = 0;
#endif

LARGE_INTEGER SmbIoPollRate = {-20*MILLISECONDS, -1}; // 20 millisecond poll rate. Relative time, so has to be negative
ULONG SmbIoInitTimeOut = 15;                          // 15 IoPollRate intervals before timeout
ULONG SmbIoCompleteTimeOut = 20;                      // 20 IoPollRate intervals before timeout


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the SMBus Host Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.
    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    NTSTATUS    status;

//    DbgBreakPoint();

    status = SmbClassInitializeDevice (
        SMB_ALI_MAJOR_VERSION,
        SMB_ALI_MINOR_VERSION,
        DriverObject
        );
    DriverObject->DriverExtension->AddDevice = SmbAliAddDevice;

    return status;
}

NTSTATUS
SmbAliInitializeMiniport (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    )
/*++

Routine Description:

    This routine Initializes miniport data, and sets up communication with
    lower device objects.

Arguments:

    DriverObject - Pointer to driver object created by system.
    Pdo - Pointer to physical device object

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) MiniportExtension;
    NTSTATUS                status = STATUS_SUCCESS;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    KEVENT                  syncEvent;


    AliData->IoState = SmbIoIdle;

    //
    // Fill in SmbClass info
    //

    SmbClass->StartIo     = SmbAliStartIo;
    SmbClass->ResetDevice = SmbAliResetDevice;
    SmbClass->StopDevice  = SmbAliStopDevice;

    //
    // Get Acpi Interfaces
    //

    //
    // Allocate an IRP for below
    //
    irp = IoAllocateIrp (SmbClass->LowerDeviceObject->StackSize, FALSE);

    if (!irp) {
        SmbPrint((SMB_ERROR),
            ("SmbAliInitializeMiniport: Failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
    //
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    irpSp->Parameters.QueryInterface.Version                = 1;
    irpSp->Parameters.QueryInterface.Size                   = sizeof (AliData->AcpiInterfaces);
    irpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) &AliData->AcpiInterfaces;
    irpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

    //
    // Initialize an event so this will be a syncronous call.
    //

    KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine (irp, SmbAliSyncronousIrpCompletion, &syncEvent, TRUE, TRUE, TRUE);

    //
    // Call ACPI
    //

    status = IoCallDriver (SmbClass->LowerDeviceObject, irp);

    //
    // Wait if necessary, then clean up.
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
        status = irp->IoStatus.Status;
    }

    IoFreeIrp (irp);

    if (!NT_SUCCESS(status)) {

        SmbPrint(SMB_ERROR,
           ("SmbAliInitializeMiniport: Could not get ACPI driver interfaces, status = %x\n", status));
    }

    //
    // Initiaize worker thread
    //
    AliData->WorkItem = IoAllocateWorkItem (SmbClass->LowerDeviceObject);

    return status;
}

NTSTATUS
SmbAliAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine calls SMBClassCreateFdo to create the FDO

Arguments:

    DriverObject - Pointer to driver object created by system.
    Pdo - Pointer to physical device object

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      fdo = NULL;


    PAGED_CODE();

    SmbPrint(SMB_TRACE, ("SmbAliAddDevice Entered with pdo %x\n", Pdo));


    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        SmbPrint(SMB_ERROR, ("SmbHcAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Create and initialize the new functional device object
    //

    status = SmbClassCreateFdo(
                DriverObject,
                Pdo,
                sizeof (SMB_ALI_DATA),
                SmbAliInitializeMiniport,
                NULL,
                &fdo
                );

    if (!NT_SUCCESS(status) || fdo == NULL) {
        SmbPrint(SMB_ERROR, ("SmbAliAddDevice - error creating Fdo. Status = %08x\n", status));
    }

    return status;


}

NTSTATUS
SmbAliResetDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SmbMiniport
    )
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDesc;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
    ULONG                           i;
    PIO_STACK_LOCATION              irpStack;

    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) SmbMiniport;

    PAGED_CODE();


    if (SmbClass->CurrentIrp == NULL) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Null CurrentIrp.  Can't get Alloocated Resources.\n"));

        return STATUS_NO_MORE_ENTRIES;
    }
    irpStack = IoGetCurrentIrpStackLocation(SmbClass->CurrentIrp);

    if (irpStack->Parameters.StartDevice.AllocatedResources == NULL) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Null resource pointer\n"));

        return STATUS_NO_MORE_ENTRIES;
    }

    if (irpStack->Parameters.StartDevice.AllocatedResources->Count <= 0 ) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Count <= 0\n"));

        return status;
    }

    //
    // Traverse the resource list
    //

    AliData->SmbBaseIo = NULL;

    fullResourceDesc=&irpStack->Parameters.StartDevice.AllocatedResources->List[0];
    partialResourceList = &fullResourceDesc->PartialResourceList;
    partialResourceDesc = partialResourceList->PartialDescriptors;

    for (i=0; i<partialResourceList->Count; i++, partialResourceDesc++) {

        if (partialResourceDesc->Type == CmResourceTypePort) {

            if (AliData->SmbBaseIo == NULL) {
                AliData->SmbBaseIo = (PUCHAR)((ULONG_PTR)partialResourceDesc->u.Port.Start.LowPart);
                if (partialResourceDesc->u.Port.Length != SMB_ALI_IO_RESOURCE_LENGTH) {
                    SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Wrong Resource length = 0x%08x\n", partialResourceDesc->u.Port.Length));
                    DbgBreakPoint();
                }
                status = STATUS_SUCCESS;
            } else {
                SmbPrint(SMB_ERROR, ("SmbAliResetDevice: More than 1 IO resource.  Resources = 0x%08x\n", irpStack->Parameters.StartDevice.AllocatedResources));
                DbgBreakPoint();
            }
        }
    }

    if (!NT_SUCCESS (status)) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: IO resource error.  Resources = 0x%08x\n", irpStack->Parameters.StartDevice.AllocatedResources));
        DbgBreakPoint();
    }

    SmbPrint(SMB_TRACE, ("SmbAliResetDevice: IO Address = 0x%08x\n", AliData->SmbBaseIo));

    //
    // Register for device notification
    //
    // But this device can't seem to notify so never mind for now
    //status = AliData->AcpiInterfaces.RegisterForDeviceNotifications (
    //            AliData->AcpiInterfaces.Context,
    //            SmbAliNotifyHandler,
    //            AliData);
    //
    //if (!NT_SUCCESS(status)) {
    //    SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Failed RegisterForDeviceNotification. 0x%08x\n", status));
    //}

    KeInitializeTimer (&AliData->InitTimer);
    KeInitializeDpc (&AliData->InitDpc,
                     SmbAliInitTransactionDpc,
                     SmbClass);
    AliData->InitWorker = IoAllocateWorkItem (SmbClass->DeviceObject);

    KeInitializeTimer (&AliData->CompleteTimer);
    KeInitializeDpc (&AliData->CompleteDpc,
                     SmbAliCompleteTransactionDpc,
                     SmbClass);
    AliData->CompleteWorker = IoAllocateWorkItem (SmbClass->DeviceObject);

    SmbAliStartDevicePolling (SmbClass);

    return status;

}

NTSTATUS
SmbAliStopDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    )
{
    SmbAliStopDevicePolling (SmbClass);

    AliData->SmbBaseIo = NULL;
    return STATUS_SUCCESS;
}


VOID
SmbAliStartIo (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    )

{
    SmbPrint (SMB_TRACE, ("SmbAliStartIo: \n"));

    SmbPrint (SMB_IO_REQUEST, ("  Prtcl = %02x Addr = %02x Cmd = %02x BlkLen = %02x Data[0] = %02x\n",
                               SmbClass->CurrentSmb->Protocol,
                               SmbClass->CurrentSmb->Address,
                               SmbClass->CurrentSmb->Command,
                               SmbClass->CurrentSmb->BlockLength,
                               SmbClass->CurrentSmb->Data[0]));
//    KeSetTimer (&AliData->InitTimer,
//                Smb100ns,
//                &AliData->InitDpc);

    AliData->InternalRetries = 0;
    
    AliData->InitTimeOut = SmbIoInitTimeOut;
    IoQueueWorkItem (AliData->InitWorker, 
                     SmbAliInitTransactionWorker, 
                     DelayedWorkQueue, 
                     SmbClass);

}

VOID
SmbAliInitTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    IoQueueWorkItem (AliData->InitWorker, 
                     SmbAliInitTransactionWorker, 
                     DelayedWorkQueue, 
                     SmbClass);
}

VOID
SmbAliInitTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    UCHAR address;
    UCHAR protocol;

    SmbPrint (SMB_TRACE, ("SmbAliInitTransaction: Entered \n"));

    if (SmbClass->CurrentSmb->Protocol >= SMB_MAXIMUM_PROTOCOL) {
        SmbClass->CurrentSmb->Status = SMB_UNSUPPORTED_PROTOCOL;
        // REVIEW: Shouldn't this complete the request?  jimmat
        return;
    }

    if (SmbAliHostBusy(AliData)) {
        if (AliData->InitTimeOut == 4) {
            // Time out.  Issue kill command.  If that fixes it, good, otherwise 
            // issue bus timeout command next time.
            SmbAliResetHost (AliData);
        }
        if (AliData->InitTimeOut == 0) {
            // Time out.  Issue Bus timeout and kill command to reset host.
            SmbAliResetBus (AliData);
            
            AliData->InitTimeOut = SmbIoInitTimeOut;
        } else {
            SmbPrint (SMB_TRACE, ("SmbAliInitTransaction: Waiting (%d) \n", AliData->InitTimeOut));
            AliData->InitTimeOut--;
        }
        KeSetTimer (&AliData->InitTimer,
                    SmbIoPollRate,
                    &AliData->InitDpc);
        return;
    }

    //
    // Ready to go
    //

    // Set Address and read/write bit
    address = SmbClass->CurrentSmb->Address << 1 | (SmbClass->CurrentSmb->Protocol & 1);
    SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write DEV_ADDR = 0x%02x \n", address));
    WRITE_PORT_UCHAR (DEV_ADDR_REG, address);

    SMBDELAY;
    
    // Set transaction type: Inserts bits 3-1 of protocol into bits 6-4 of SMB_TYP
    // protocol = READ_PORT_UCHAR (SMB_TYP_REG);
    // SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO read SMB_TYP = 0x%02x \n", protocol));
    protocol = /*(protocol & ~SMB_TYP_MASK) |*/
               ((SmbClass->CurrentSmb->Protocol << 3) & SMB_TYP_MASK);
    SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write SMB_TYP = 0x%02x, Protocol = 0x%02x \n", protocol,SmbClass->CurrentSmb->Protocol));
    WRITE_PORT_UCHAR (SMB_TYP_REG, protocol);
    SMBDELAY;

    // Set SMBus Device Command value
    if (SmbClass->CurrentSmb->Protocol >= SMB_WRITE_BYTE) {
        SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write SMB_CMD = 0x%02x \n", SmbClass->CurrentSmb->Command));
        WRITE_PORT_UCHAR (SMB_CMD_REG, SmbClass->CurrentSmb->Command);
        SMBDELAY;
    }

    switch (SmbClass->CurrentSmb->Protocol) {
    case SMB_WRITE_WORD:
    case SMB_PROCESS_CALL:

        // Set Data
        SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write DEV_DATA1 = 0x%02x \n", SmbClass->CurrentSmb->Data[1]));
        WRITE_PORT_UCHAR (DEV_DATA1_REG, SmbClass->CurrentSmb->Data[1]);
        SMBDELAY;

        // Fall through to set low byte of word
    case SMB_SEND_BYTE:
    case SMB_WRITE_BYTE:

        // Set Data
        SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write DEV_DATA0 = 0x%02x \n", SmbClass->CurrentSmb->Data[0]));
        WRITE_PORT_UCHAR (DEV_DATA0_REG, SmbClass->CurrentSmb->Data[0]);
        SMBDELAY;

        break;
    case SMB_WRITE_BLOCK:
        // BUGBUG: not yet implemented.
        SmbPrint (SMB_ERROR, ("SmbAliInitTransaction: Write Block not implemented.  press 'g' to write random data.\n"));
        DbgBreakPoint();
        break;
    }

    // Initiate Transaction
    SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write STR_PORT = 0x%02x \n", STR_PORT_START));
    WRITE_PORT_UCHAR (STR_PORT_REG, STR_PORT_START);

    AliData->CompleteTimeOut = SmbIoCompleteTimeOut;

    KeSetTimer (&AliData->CompleteTimer,
                SmbIoPollRate,
                &AliData->CompleteDpc);


}

VOID
SmbAliCompleteTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    IoQueueWorkItem (AliData->CompleteWorker, 
                     SmbAliCompleteTransactionWorker, 
                     DelayedWorkQueue, 
                     SmbClass);
}

VOID
SmbAliCompleteTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    UCHAR           i, smb_sts;
    UCHAR           smbStatus;

    SmbPrint (SMB_TRACE, ("SmbAliCompleteTransactionWorker: Entered \n"));

    smbStatus = SMB_STATUS_OK;

    if (!SmbAliTransactionComplete(AliData, &smbStatus)) {
        //
        // Timeout
        //

        if (AliData->CompleteTimeOut == 0) {
            SmbPrint (SMB_TRACE, ("SmbAliCompleteTransactionWorker: Transation timed out.  Resetting host. \n"));
            SmbAliResetHost (AliData);

            smbStatus = SMB_TIMEOUT;

        } else {
            SmbPrint (SMB_TRACE, ("SmbAliCompleteTransactionWorker: Not complete.  Waiting (%d)... \n", AliData->CompleteTimeOut));
            AliData->CompleteTimeOut--;
            KeSetTimer (&AliData->CompleteTimer,
                        SmbIoPollRate,
                        &AliData->CompleteDpc);
            return;
        }

    }

    if (smbStatus == SMB_STATUS_OK) {
        //
        // If transaction was successful, read data.
        //

        switch (SmbClass->CurrentSmb->Protocol) {
        case SMB_READ_WORD:
        case SMB_PROCESS_CALL:

            // Read High byte
            SmbClass->CurrentSmb->Data[1] = READ_PORT_UCHAR (DEV_DATA1_REG);
            SMBDELAY;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read DEV_DATA1 = 0x%02x \n", SmbClass->CurrentSmb->Data[1]));

            // Fall through to set low byte of word
        case SMB_RECEIVE_BYTE:
        case SMB_READ_BYTE:

            // Read Low Byte
            SmbClass->CurrentSmb->Data[0] = READ_PORT_UCHAR (DEV_DATA0_REG);
            SMBDELAY;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read DEV_DATA0 = 0x%02x \n", SmbClass->CurrentSmb->Data[0]));
            break;
        case SMB_READ_BLOCK:
            // Read Block Count
            SmbClass->CurrentSmb->BlockLength = READ_PORT_UCHAR (DEV_DATA0_REG);
            SMBDELAY;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read DEV_DATA0 (block length)= 0x%02x \n", SmbClass->CurrentSmb->BlockLength));
            if (SmbClass->CurrentSmb->BlockLength >= 32) {
                DbgBreakPoint();
                SmbClass->CurrentSmb->BlockLength = 0;
            }

            // Reset Data pointer
    //        smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
  //          SMBDELAY;
//            SmbPrint (SMB_IO, ("SmbAliCompleteTransaction: IO read SMB_STS = 0x%02x \n", smb_sts));
            smb_sts = SMB_STS_SMB_IDX_CLR;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO write SMB_STS = 0x%02x \n", smb_sts));
            WRITE_PORT_UCHAR (SMB_STS_REG, smb_sts);
            SMBDELAY;

            // Read data
            for (i = 0; i < SmbClass->CurrentSmb->BlockLength; i++) {
                SmbClass->CurrentSmb->Data[i] = READ_PORT_UCHAR (BLK_DATA_REG);
                SMBDELAY;
                SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read BLK_DATA_REG (i = %d) = 0x%02x \n", i, SmbClass->CurrentSmb->Data[i]));
            }
            break;
        }
    }
    else    // smbStatus != SMB_STATUS_OK
    {
        //
        // Retry the transaction up to 5 times before returning to the caller.
        // REVIEW: Only do this for certain devices, commands, or error status results?
        //
        
        if (AliData->InternalRetries < 5)
        {
            //SmbPrint (SMB_IO_RESULT, (" SMBus Transaction status: %02x, retrying...\n", smbStatus));
            AliData->InternalRetries += 1;

            // Send the work item back to the init worker
            AliData->InitTimeOut = SmbIoInitTimeOut;
            KeSetTimer (&AliData->InitTimer,
                        SmbIoPollRate,
                        &AliData->InitDpc);
            return;
        }
    }
    
    // Clear any previous status.
    //SmbPrint (SMB_IO, ("SmbAliCompleteTransaction: IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
    //WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
//    SMBDELAY;

    SmbClass->CurrentSmb->Status = smbStatus;
    SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: SMB Status = 0x%x\n", smbStatus));
    SmbClass->CurrentIrp->IoStatus.Status = STATUS_SUCCESS;
    SmbClass->CurrentIrp->IoStatus.Information = sizeof(SMB_REQUEST);

    SmbPrint (SMB_IO_RESULT, (" Prtcl = %02x Addr = %02x Cmd = %02x BL = %02x Data[0,1] = %02x %02x Sts = %02x Rty = %02x\n",
                              SmbClass->CurrentSmb->Protocol,
                              SmbClass->CurrentSmb->Address,
                              SmbClass->CurrentSmb->Command,
                              SmbClass->CurrentSmb->BlockLength,
                              SmbClass->CurrentSmb->Data[0],
                              (SMB_READ_WORD == SmbClass->CurrentSmb->Protocol ||
                               SMB_WRITE_WORD == SmbClass->CurrentSmb->Protocol ||
                               (SMB_READ_BLOCK == SmbClass->CurrentSmb->Protocol &&
                                SmbClass->CurrentSmb->BlockLength >= 2)) ? 
                               SmbClass->CurrentSmb->Data[1] : 0xFF,
                              SmbClass->CurrentSmb->Status,
                              AliData->InternalRetries));
                              
    SmbClassLockDevice (SmbClass);
    SmbClassCompleteRequest (SmbClass);
    SmbClassUnlockDevice (SmbClass);

#if DBG
    //
    // Track the # of successful transactions, and if not successful,
    // the types of errors encountered.
    //
    if (SMB_STATUS_OK == smbStatus)
        DbgSuccess += 1;
    else
    {
        DbgFailure += 1;
        if (SMB_TIMEOUT == smbStatus)
            DbgTimeOut += 1;
        else if (SMB_ADDRESS_NOT_ACKNOWLEDGED == smbStatus)
            DbgAddrNotAck += 1;
        else
            DbgOtherErr += 1;
    }

    if ((DbgSuccess + DbgFailure) % 100 == 0)
        SmbPrint(SMB_STATS, ("SmbAliCompleteTransactionWorker: Stats:\n"
                             "    Success: %d, Failure: %d, %%: %d\n"
                             "    TimeOut: %d, AddrNotAck: %d, Other: %d\n",
                             DbgSuccess, DbgFailure, DbgSuccess * 100 / (DbgSuccess + DbgFailure),
                             DbgTimeOut, DbgAddrNotAck, DbgOtherErr));
#endif
}

VOID
SmbAliNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) Context;
    ULONG           address;
    ULONG           data;
    UCHAR           smb_sts;

    SmbPrint (SMB_TRACE, ("SmbAliNotifyHandler: Entered"));

    smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
    SMBDELAY;
    SmbPrint (SMB_TRACE, ("SmbAliNotifyHandler: SMB_STS = %02x", smb_sts));

    if (smb_sts & (SMB_STS_ALERT_STS || SMB_STS_SCI_I_STS)) {
        //
        // Alert Reponse
        //

    } else if (smb_sts & SMB_STS_SCI_I_STS) {
        //
        // Last Transaction completed
        //

    } else {
        //
        // Check for errors, etc.
        //
    }

    IoQueueWorkItem (AliData->WorkItem,
                     SmbAliWorkerThread,
                     DelayedWorkQueue,
                     AliData);

}

VOID
SmbAliWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) Context;

    SmbPrint (SMB_TRACE, ("SmbAliIrpCompletionWorker: Entered"));
    //
    // Complete Irps here
    //
}


NTSTATUS
SmbAliSyncronousIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the lower driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


BOOLEAN
SmbAliTransactionComplete (
    PSMB_ALI_DATA AliData,
    PUCHAR SmbStatus
    )
/*++

Routine Description:

    This routine checks to see if there is the last transation was completed.

Arguments:

    AliData - minidriver device extension.

    SmbStatus - Status being returned.

Return Value:

    True if transaction completed or had an error.
    False if it is still waiting.

--*/

{
    UCHAR           smb_sts;

    smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
    SMBDELAY;
    SmbPrint (SMB_IO, ("SmbAliTransactionComplete: IO read SMB_STS = 0x%02x \n", smb_sts));
    if (smb_sts & SMB_STS_HOST_BSY) {
		SmbPrint (SMB_IO, ("SmbAliTransactionComplete: Transaction Not Complete:  HOST BUSY\n"));
        return FALSE;
    }
    if (!(smb_sts & SMB_STS_IDLE_STS)) {
	    SmbPrint (SMB_IO, ("SmbAliTransactionComplete: Transaction Not Complete: Idle Not Indicated\n"));
        return FALSE;
    }

    if (smb_sts & SMB_STS_SCI_I_STS) {
        //
        // Transaction is complete
        //
        *SmbStatus = SMB_STATUS_OK;
        return TRUE;
    }
    if (smb_sts & SMB_STS_FAILED) {
        *SmbStatus = SMB_UNKNOWN_FAILURE;
    } else if (smb_sts & SMB_STS_BUS_ERR) {
        *SmbStatus = SMB_ADDRESS_NOT_ACKNOWLEDGED;
    } else if (smb_sts & SMB_STS_DRV_ERR) {
        *SmbStatus = SMB_TIMEOUT;
    } else {
        //
        // This state really shouldn't be reached.
        // Reset the SMBus host
        //
        SmbPrint (SMB_BUS_ERROR, ("SmbAliTransactionComplete: Invalid SMBus host state.\n"));

        *SmbStatus = SMB_UNKNOWN_ERROR;
    }
    //
    // For the three know error tpes we want to reset the bus
    //
    SmbPrint (SMB_BUS_ERROR, ("SmbAliTransactionComplete: SMBus error: 0x%x \n", *SmbStatus));

	// Don't reset the bus etc. if this is a Bus Collision error
    if ( *SmbStatus == SMB_ADDRESS_NOT_ACKNOWLEDGED )
	{
		// Should we clear the bits, lets try it
		SmbPrint (SMB_IO, ("SmbAliCompleteTransaction: Clearing Error Bits. IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
		WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
        SMBDELAY;
	}
	else
	{
		SmbAliResetHost (AliData);
		SmbAliResetBus (AliData);
	}

    return TRUE;
}

BOOLEAN
SmbAliHostBusy (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This routine checks to see if the Host controller is free to start a
    new transaction.

Arguments:

    AliData - minidriver device extension.

Return Value:

    True if The host is busy.
    False if it free for use.

--*/

{

    UCHAR           smb_sts;

    SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Entered \n"));

    smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
    SMBDELAY;
    SmbPrint (SMB_IO, ("SmbAliHostBusy: IO read SMB_STS = 0x%02x \n", smb_sts));

    if (smb_sts & SMB_STS_ALERT_STS) {
        SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Alert Detected \n"));
        DbgBreakPoint();
        SmbAliHandleAlert (AliData);

        //
        // Say device is still busy for now. BUGBUG
        return TRUE;
    }

	if ( smb_sts == SMB_STS_LAST_CMD_COMPLETED )
	{
		//
		// Clear the done bit
        SmbPrint (SMB_IO, ("SmbAliHostBusy: IO write SMB_TYP = 0x%02x \n", SMB_STS_CLEAR_DONE));
        WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR_DONE);
        SMBDELAY;
		return FALSE;
	}

    if ( smb_sts == SMB_STS_IDLE_STS ) 
	{
        //
        // No bits are set, Host is not busy
        //
        SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Not busy \n"));
        return FALSE;
    }

    if ( smb_sts & SMB_STS_ERRORS ) {
        //
        // Clear it.
        // Wait a cycle before continuing.
        //
        SmbPrint (SMB_IO, ("SmbAliHostBusy: IO write SMB_TYP = 0x%02x \n", SMB_STS_CLEAR));
        WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
        SMBDELAY;
        return TRUE;
    }

    if ((smb_sts & SMB_STS_HOST_BSY) || !(smb_sts & SMB_STS_IDLE_STS)) {
        //
        // Host is busy
        //

        SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Host Busy \n"));
        return TRUE;
    }

    SmbPrint (SMB_ERROR, ("SmbAliHostBusy: Exiting (Why?) \n"));
    return TRUE;
}

VOID
SmbAliHandleAlert (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This routine reads the alert data and sends notification to SMB class.

Arguments:

    AliData - minidriver device extension.

Return Value:

    None

--*/

{

    //BUGBUG not yet implemented

    return;
}

VOID
SmbAliResetBus (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This resets the bus by sending the timeout command.

Arguments:

    AliData - minidriver device extension.

Return Value:

--*/
{
    UCHAR           smb_sts;
    
    smb_sts = SMB_TYP_T_OUT_CMD;
    SmbPrint (SMB_IO, ("SmbAliResetBus: IO write SMB_TYP = 0x%02x \n", smb_sts));
    WRITE_PORT_UCHAR (SMB_TYP_REG, smb_sts);
    SMBDELAY;

    SmbPrint (SMB_IO, ("SmbAliResetBus: IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
    WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);  
    SMBDELAY;
}

VOID
SmbAliResetHost (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This resets the host by sending the kill command.

Arguments:

    AliData - minidriver device extension.

Return Value:

--*/
{
    UCHAR           smb_sts;
    UCHAR           timeout = 5;
    
    smb_sts = SMB_TYP_KILL;
    SmbPrint (SMB_IO, ("SmbAliResetHost: IO write SMB_TYP = 0x%02x \n", smb_sts));
    WRITE_PORT_UCHAR (SMB_TYP_REG, smb_sts);
    SMBDELAY;

	SmbPrint (SMB_IO, ("SmbAliResetHost: IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
    WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
    SMBDELAY;

    do {
        KeDelayExecutionThread (KernelMode, FALSE, &SmbIoPollRate);
        smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
        SmbPrint (SMB_IO, ("SmbAliResetHost: IO read SMB_STS = 0x%02x \n", smb_sts));

        if (! (timeout--)) {
            break;
        }
    } while (smb_sts & SMB_STS_FAILED);
}

#ifdef USE_IO_DELAY

LARGE_INTEGER DbgDelay = {-1,-1};
VOID SmbDelay(VOID)
{
    KeDelayExecutionThread (KernelMode, FALSE, &DbgDelay);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbali\smbpoll.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smbpoll.c

Abstract:

    Device polling for
    SMB Host Controller Driver for ALI chipset

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/

#include "smbalip.h"

VOID
SmbAliPollDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbAliPollWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    );



//LARGE_INTEGER SmbAlertPollRate  = {-1*SECONDS, -1};  // 1 second poll rate
LARGE_INTEGER SmbDevicePollRate   = {-5*SECONDS, -1};  // 5 second poll rate
LONG    SmbDevicePollPeriod       = 5000; // 5000 ms = 5 sec

// address, command, protocol, valid_data, last_data
SMB_ALI_POLL_ENTRY SmbDevicePollList [2] = {
    {0x0b, 0x16, SMB_READ_WORD, FALSE, 0},          // battery, BatteryStatus()
    {0x09, 0x13, SMB_READ_WORD, FALSE, 0}           // charger, ChargerStatus()
};


    
VOID
SmbAliStartDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    AliData->PollList = SmbDevicePollList;
    AliData->PollListCount = sizeof (SmbDevicePollList)/sizeof(SMB_ALI_POLL_ENTRY);
    AliData->PollWorker = IoAllocateWorkItem (SmbClass->DeviceObject);

    KeInitializeTimer (&AliData->PollTimer);
    KeInitializeDpc (&AliData->PollDpc,
                     SmbAliPollDpc,
                     SmbClass);
    KeInitializeEvent (&AliData->PollWorkerActive, NotificationEvent, TRUE);
    KeSetTimerEx (&AliData->PollTimer, 
                  SmbDevicePollRate, 
                  SmbDevicePollPeriod, 
                  &AliData->PollDpc);
}

VOID
SmbAliStopDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    
    KeCancelTimer (&AliData->PollTimer);
    if (KeResetEvent(&AliData->PollWorkerActive) == 0) {
        KeWaitForSingleObject (&AliData->PollWorkerActive, 
                               Executive, KernelMode, FALSE, NULL);
    }
}

VOID
SmbAliPollDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    if (KeResetEvent(&AliData->PollWorkerActive) != 0) {
        IoQueueWorkItem (AliData->PollWorker, SmbAliPollWorker, DelayedWorkQueue, SmbClass);
    }
}

VOID
SmbAliPollWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    PIRP             irp;
    SMB_REQUEST     smbRequest;
    IO_STATUS_BLOCK ioStatus;
    KEVENT          event;
    ULONG           i;

    KeInitializeEvent (&event, SynchronizationEvent, FALSE);

    SmbPrint(SMB_TRACE, ("SmbAliPollWorker: Entered\n"));

    for (i = 0; i < AliData->PollListCount; i++) {
        smbRequest.Protocol = AliData->PollList[i].Protocol;
        smbRequest.Address = AliData->PollList[i].Address;
        smbRequest.Command = AliData->PollList[i].Command;
        
        irp = IoBuildDeviceIoControlRequest (
            SMB_BUS_REQUEST,
            SmbClass->DeviceObject,
            &smbRequest,
            sizeof (smbRequest),
            &smbRequest,
            sizeof (smbRequest),
            TRUE,
            &event,
            &ioStatus);

        if (!irp) {
            continue;
        }

        IoCallDriver (SmbClass->DeviceObject, irp);

        KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

        if (!NT_SUCCESS(ioStatus.Status)) {
            continue;
        }
        if (smbRequest.Status != SMB_STATUS_OK) {
            if (AliData->PollList[i].ValidData) {
                AliData->PollList[i].ValidData = FALSE;
            }
        } else {
            //BUGBUG: only supports word protocols
            if ((!AliData->PollList[i].ValidData) ||
                (AliData->PollList[i].LastData != *((PUSHORT)smbRequest.Data))) {
                AliData->PollList[i].ValidData = TRUE;
                AliData->PollList[i].LastData = *((PUSHORT)smbRequest.Data);
                
                SmbPrint(SMB_TRACE, ("SmbAliPollWorker: Alarm: Address 0x%02x Data 0x%04x\n", AliData->PollList[i].Address, AliData->PollList[i].LastData));
                SmbClassLockDevice (SmbClass);
                SmbClassAlarm (SmbClass,
                               AliData->PollList[i].Address, 
                               AliData->PollList[i].LastData); 
                SmbClassUnlockDevice (SmbClass);
            }
            SmbPrint(SMB_TRACE, ("SmbAliPollWorker: AlarmData: Address 0x%02x Data 0x%04x\n", AliData->PollList[i].Address, AliData->PollList[i].LastData));
        }
    }

    KeSetEvent (&AliData->PollWorkerActive, 0, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbbatt\pnppower.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pnppower.c

Abstract:

    SMBus Smart Battery Subsystem Miniport Driver
    (Selector, Battery, Charger) Plug and Play and
    Power Management IRP dispatch routines.

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

    Chris Windle    1/27/98     Bug Fixes

--*/

#include "smbbattp.h"
#include <devioctl.h>
#include <acpiioct.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbBattPnpDispatch)
#pragma alloc_text(PAGE,SmbBattPowerDispatch)
#pragma alloc_text(PAGE,SmbBattRegisterForAlarm)
#pragma alloc_text(PAGE,SmbBattUnregisterForAlarm)
#pragma alloc_text(PAGE,SmbGetSBS)
#pragma alloc_text(PAGE,SmbGetGLK)
#pragma alloc_text(PAGE,SmbBattCreatePdos)
#pragma alloc_text(PAGE,SmbBattBuildDeviceRelations)
#pragma alloc_text(PAGE,SmbBattQueryDeviceRelations)
#pragma alloc_text(PAGE,SmbBattRemoveDevice)
#pragma alloc_text(PAGE,SmbBattQueryId)
#pragma alloc_text(PAGE,SmbBattQueryCapabilities)
#pragma alloc_text(PAGE,SmbBattBuildSelectorStruct)
#endif



NTSTATUS
SmbBattPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
    PSMB_BATT               smbBatt;

    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    BOOLEAN                 complete        = TRUE;
    KEVENT                  syncEvent;

    //
    // This routine handles PnP IRPs for three different types of device objects:
    // the battery subsystem FDO, each battery PDO and each battery PDO.  The
    // subsystem PDO creates children since each battery in the system must have
    // it's own device object, so this driver is essential two device drivers in
    // one: the smart battery selector bus driver (It is actually it's own bus
    // because the selector arbitrates between the two batteries.) and the
    // battery function driver.  The two drivers are integrated because it would
    // not make sense to replace one and not the other, and having separate
    // drivers would require additional defined interfaces between them.
    //
    // The device extensions for the three device types are different structures.
    //

    PSMB_BATT_SUBSYSTEM     subsystemExt    =
            (PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension;
    PSMB_NP_BATT            batteryExt      =
            (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PDEVICE_OBJECT      lowerDevice = NULL;

    PAGED_CODE();

    status = IoAcquireRemoveLock (&batteryExt->RemoveLock, Irp);

    if (NT_SUCCESS(status)) {
        status = STATUS_NOT_SUPPORTED;

        if (batteryExt->SmbBattFdoType == SmbTypeSubsystem) {
            lowerDevice = subsystemExt->LowerDevice;
        } else if (batteryExt->SmbBattFdoType == SmbTypeBattery) {
            lowerDevice = batteryExt->LowerDevice;
        } else {
            // Assuming (batteryExt->SmbBattFdoType == SmbTypePdo)
            ASSERT (batteryExt->SmbBattFdoType == SmbTypePdo);
            lowerDevice = NULL;
        }

        switch (irpStack->MinorFunction) {

            case IRP_MN_QUERY_DEVICE_RELATIONS: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_QUERY_DEVICE_RELATIONS, "
                     "type = %x\n",
                     irpStack->Parameters.QueryDeviceRelations.Type)
                );

                status = SmbBattQueryDeviceRelations (DeviceObject, Irp);

                break;
            }


            case IRP_MN_QUERY_CAPABILITIES: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_QUERY_CAPABILITIES for device %x\n",
                    DeviceObject)
                );

                status = SmbBattQueryCapabilities (DeviceObject, Irp);
                break;
            }


            case IRP_MN_START_DEVICE: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_START_DEVICE for %x\n",
                    DeviceObject)
                );

                if (subsystemExt->SmbBattFdoType == SmbTypeSubsystem) {

                    //
                    // Get the SMB host controller FDO
                    //

                    subsystemExt->SmbHcFdo = subsystemExt->LowerDevice;
                    status = STATUS_SUCCESS;

                } else if (subsystemExt->SmbBattFdoType == SmbTypeBattery) {

                    //
                    // This is a battery.  Just get the SMB host controller FDO.
                    //

                    smbBatt = batteryExt->Batt;
                    smbBatt->SmbHcFdo =
                        ((PSMB_BATT_SUBSYSTEM)(((PSMB_BATT_PDO)
                                                (smbBatt->PDO->DeviceExtension))->
                                               SubsystemFdo->DeviceExtension))->
                        LowerDevice;
                    status = STATUS_SUCCESS;
                } else if (subsystemExt->SmbBattFdoType == SmbTypePdo) {
                    status = STATUS_SUCCESS;
                }

                break;
            }


            case IRP_MN_STOP_DEVICE: {
                status = STATUS_SUCCESS;

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_STOP_DEVICE\n"));

                break;
            }


            case IRP_MN_QUERY_REMOVE_DEVICE: {

                status = STATUS_SUCCESS;
                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_QUERY_REMOVE_DEVICE\n"));
                break;
            }


            case IRP_MN_CANCEL_REMOVE_DEVICE: {
                status = STATUS_SUCCESS;

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_CANCEL_REMOVE_DEVICE\n"));

                break;
            }


            case IRP_MN_SURPRISE_REMOVAL: {
                status = STATUS_SUCCESS;

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_SURPRISE_REMOVAL\n"));

                break;
            }


            case IRP_MN_REMOVE_DEVICE: {
                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_REMOVE_DEVICE\n"));

                status = SmbBattRemoveDevice (DeviceObject, Irp);

                return status;

                break;
            }


            case IRP_MN_QUERY_ID: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_QUERY_ID for %x, query type is - %x\n",
                    DeviceObject,
                    irpStack->Parameters.QueryId.IdType)
                );

                if (batteryExt->SmbBattFdoType == SmbTypePdo) {
                    status = SmbBattQueryId (DeviceObject, Irp);
                }
                break;
            }


            case IRP_MN_QUERY_PNP_DEVICE_STATE: {

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_PNP_DEVICE_STATE\n"));

                if (subsystemExt->SmbBattFdoType == SmbTypeSubsystem) {
                    IoCopyCurrentIrpStackLocationToNext (Irp);

                    KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

                    IoSetCompletionRoutine(Irp, SmbBattSynchronousRequest, &syncEvent, TRUE, TRUE, TRUE);

                    status = IoCallDriver(lowerDevice, Irp);

                    if (status == STATUS_PENDING) {
                        KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                        status = Irp->IoStatus.Status;
                    }

                    Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

                    IoCompleteRequest(Irp, IO_NO_INCREMENT);

                    IoReleaseRemoveLock (&batteryExt->RemoveLock, Irp);

                    return status;
                }

                break;
            }

        }   // switch (irpStack->MinorFunction)

        IoReleaseRemoveLock (&batteryExt->RemoveLock, Irp);

    }

    //
    // Only set status if we have something to add
    //
    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status ;

    }

    //
    // Do we need to send it down?
    //
    if ((NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) && (lowerDevice != NULL)) {

        //
        // Forward request
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(lowerDevice,Irp);

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }

    return status;
}





NTSTATUS
SmbBattPowerDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{

    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_NOT_SUPPORTED;
    PSMB_NP_BATT        batteryExt = (PSMB_NP_BATT) Fdo->DeviceExtension;
    PSMB_BATT_SUBSYSTEM subsystemExt = (PSMB_BATT_SUBSYSTEM) Fdo->DeviceExtension;
    PDEVICE_OBJECT      lowerDevice;

    PAGED_CODE();

    //
    // Not using Remove lock in this function because this function doesn't use
    // any resoureces that the remove lock protects.
    //

    if (batteryExt->SmbBattFdoType == SmbTypeSubsystem) {
        lowerDevice = subsystemExt->LowerDevice;
    } else if (batteryExt->SmbBattFdoType == SmbTypeBattery) {
        lowerDevice = batteryExt->LowerDevice;
    } else {
        // Assuming (batteryExt->SmbBattFdoType == SmbTypePdo)
        ASSERT (batteryExt->SmbBattFdoType == SmbTypePdo);
        lowerDevice = NULL;
        status = STATUS_SUCCESS;
    }

    switch (irpStack->MinorFunction) {

        case IRP_MN_WAIT_WAKE: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_WAIT_WAKE\n"));
            
            //
            // Smart batteries can't wake the system.
            //

            status = STATUS_NOT_SUPPORTED;
            break;
        }

        case IRP_MN_POWER_SEQUENCE: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_POWER_SEQUENCE\n"));
            break;
        }

        case IRP_MN_SET_POWER: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_SET_POWER\n"));
            break;
        }

        case IRP_MN_QUERY_POWER: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_QUERY_POWER\n"));
            break;
        }

        default: {
            status = STATUS_NOT_SUPPORTED;
        }

    }   // switch (irpStack->MinorFunction)

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    }

    PoStartNextPowerIrp( Irp );
    if ((NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) && (lowerDevice != NULL)) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( lowerDevice, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}



NTSTATUS
SmbBattRegisterForAlarm(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine register with the SmbHc for alarm notifications.  This
    is only done when smart battery subsystem FDO is started.

Arguments:

    Fdo - Pointer to the Fdo for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    SMB_REGISTER_ALARM      registerAlarm;
    KEVENT                  event;
    NTSTATUS                status;

    PSMB_BATT_SUBSYSTEM     subsystemExtension  =
            (PSMB_BATT_SUBSYSTEM) Fdo->DeviceExtension;

    PAGED_CODE();

    //
    // Register for alarm notifications
    //

    registerAlarm.MinAddress        = SMB_CHARGER_ADDRESS;
    registerAlarm.MaxAddress        = SMB_BATTERY_ADDRESS;
    registerAlarm.NotifyFunction    = SmbBattAlarm;
    registerAlarm.NotifyContext     = subsystemExtension;

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (subsystemExtension->SmbHcFdo->StackSize, FALSE);

    if (!irp) {
        BattPrint(BAT_ERROR, ("SmbBattRegisterForAlarm: couldn't allocate irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack                    = IoGetNextIrpStackLocation(irp);
    irp->UserBuffer             = &subsystemExtension->SmbAlarmHandle;
    irpStack->MajorFunction     = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpStack->Parameters.DeviceIoControl.IoControlCode      = SMB_REGISTER_ALARM_NOTIFY;
    irpStack->Parameters.DeviceIoControl.InputBufferLength  = sizeof(registerAlarm);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer   = &registerAlarm;
    irpStack->Parameters.DeviceIoControl.OutputBufferLength = sizeof(subsystemExtension->SmbAlarmHandle);

    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);
    IoCallDriver (subsystemExtension->SmbHcFdo, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattRegisterForAlarm: couldn't register for alarms - %x\n", status));
    }

    IoFreeIrp (irp);

    return status;

}



NTSTATUS
SmbBattUnregisterForAlarm(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine unregisters with the SmbHc for alarm notifications.  This
    is only done when smart battery subsystem FDO is stopped or unloaded.

Arguments:

    Fdo - Pointer to the Fdo for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    KEVENT                  event;
    NTSTATUS                status;

    PSMB_BATT_SUBSYSTEM     subsystemExtension  = (PSMB_BATT_SUBSYSTEM) Fdo->DeviceExtension;

    PAGED_CODE();

    //
    // DeRegister for alarm notifications
    //

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (subsystemExtension->SmbHcFdo->StackSize, FALSE);

    if (!irp) {
        BattPrint(BAT_ERROR, ("SmbBattUnregisterForAlarm: couldn't allocate irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack                    = IoGetNextIrpStackLocation(irp);
    irp->UserBuffer             = NULL;
    irpStack->MajorFunction     = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpStack->Parameters.DeviceIoControl.IoControlCode      = SMB_DEREGISTER_ALARM_NOTIFY;
    irpStack->Parameters.DeviceIoControl.InputBufferLength  = sizeof(subsystemExtension->SmbAlarmHandle);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer   = &subsystemExtension->SmbAlarmHandle;
    irpStack->Parameters.DeviceIoControl.OutputBufferLength = 0;

    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);
    IoCallDriver (subsystemExtension->SmbHcFdo, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattUnregisterForAlarm: couldn't unregister for alarms - %x\n", status));
    }

    IoFreeIrp (irp);

    return status;

}



NTSTATUS
SmbGetSBS (
    IN PULONG           NumberOfBatteries,
    IN PBOOLEAN         SelectorPresent,
    IN PDEVICE_OBJECT   LowerDevice
    )
/*++

Routine Description:

    This routine has the ACPI driver run the control method _SBS for the smart battery
    subsystem.  This control method returns a value that tells the driver how many
    batteries are supported and whether or not the system contains a selector.

Arguments:

    NumberOfBatteries   - pointer to return the number of batteries

    SelectorPresent     - Pointer to return whether a selector is present (TRUE)

    LowerDevice         - device object to call

Return Value:

    Status of the IOCTL to the ACPI driver.

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;

    PAGED_CODE();

    BattPrint (BAT_TRACE, ("SmbGetSBS: Entering\n"));

    //
    //  Initialize the input structure
    //

    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.MethodNameAsUlong = SMBATT_SBS_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(
       IOCTL_ACPI_ASYNC_EVAL_METHOD,
       LowerDevice,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER),
       FALSE,
       &event,
       &ioStatusBlock
    );

    if (irp == NULL) {
        BattPrint (BAT_ERROR, ("SmbGetSBS: couldn't create Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver (LowerDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    //
    // Sanity check the data
    //
    if (outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer.Count == 0) {

        status = STATUS_ACPI_INVALID_DATA;
    }

    *SelectorPresent = FALSE;
    *NumberOfBatteries = 0;

    if (!NT_SUCCESS(status)) {
        BattPrint (BAT_BIOS_ERROR | BAT_ERROR, ("SmbGetSBS: Irp failed - %x\n", status));
    } else {

        argument = outputBuffer.Argument;
        if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            return STATUS_ACPI_INVALID_DATA;
        }

        switch (argument->Argument) {
            case 0:
                BattPrint(BAT_DATA, ("SmbGetSBS: Number of batteries = 1, no selector\n"));
                *NumberOfBatteries = 1;
                break;

            case 1:
            case 2:
            case 3:
            case 4:
                BattPrint(BAT_DATA, ("SmbGetSBS: Number of batteries found - %x\n", argument->Argument));
                *SelectorPresent = TRUE;
                *NumberOfBatteries = argument->Argument;
                break;

            default:
                BattPrint(BAT_ERROR, ("SmbGetSBS: Invalid number of batteries - %x\n", argument->Argument));
                return STATUS_NO_SUCH_DEVICE;
        }
    }

    return status;
}




NTSTATUS
SmbGetGLK (
    IN PBOOLEAN         GlobalLockRequired,
    IN PDEVICE_OBJECT   LowerDevice
    )
/*++

Routine Description:

    This routine has the ACPI driver run the control method _SBS for the smart battery
    subsystem.  This control method returns a value that tells the driver how many
    batteries are supported and whether or not the system contains a selector.

Arguments:

    GlobalLockRequired  - Pointer to return whether lock acquisition is needed

    LowerDevice         - device object to call

Return Value:

    Status of the IOCTL to the ACPI driver.

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;

    PAGED_CODE();

    BattPrint (BAT_TRACE, ("SmbGetGLK: Entering\n"));

    //
    //  Initialize the input structure
    //

    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.MethodNameAsUlong = SMBATT_GLK_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(
       IOCTL_ACPI_ASYNC_EVAL_METHOD,
       LowerDevice,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER),
       FALSE,
       &event,
       &ioStatusBlock
    );

    if (irp == NULL) {
        BattPrint (BAT_ERROR, ("SmbGetGLK: couldn't create Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver (LowerDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
            *GlobalLockRequired = FALSE;
            BattPrint (BAT_NOTE, ("SmbGetGLK: _GLK not found assuming lock is not needed.\n"));
        } else {
            BattPrint (BAT_ERROR, ("SmbGetGLK: Irp failed - %x\n", status));
        }
    } else {

        //
        // Sanity check the data
        //
        if (outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
            outputBuffer.Count == 0) {

            return STATUS_ACPI_INVALID_DATA;
        }

        argument = outputBuffer.Argument;
        if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            return STATUS_ACPI_INVALID_DATA;
        }

        if (argument->Argument == 0) {
            *GlobalLockRequired = FALSE;
        } else if (argument->Argument == 1) {
            *GlobalLockRequired = TRUE;
        } else {
            BattPrint(BAT_BIOS_ERROR, ("SmbGetGLK: Invalid value returned - %x\n", argument->Argument));
            status = STATUS_UNSUCCESSFUL;
        }
    }

    BattPrint (BAT_DATA, ("SmbGetGLK: Returning %x GLK = %d\n", status, SmbBattUseGlobalLock));
    return status;
}




NTSTATUS
SmbBattCreatePdos(
    IN PDEVICE_OBJECT SubsystemFdo
    )
/*++

Routine Description:

    This routine creates a PDO for each battery supported by the system and puts
    it into a list kept with the FDO for the smart battery subsystem.

Arguments:

    SubsystemFdo    - Fdo for the smart battery subsystem

Return Value:

    Status for creation of battery PDO.
--*/
{
    ULONG                   i;
    NTSTATUS                status;
    PSMB_BATT_PDO           batteryPdoExt;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];
    PDEVICE_OBJECT          pdo;

    PSMB_BATT_SUBSYSTEM     subsystemExt        = (PSMB_BATT_SUBSYSTEM) SubsystemFdo->DeviceExtension;
    BOOLEAN                 selectorPresent     = FALSE;

    PAGED_CODE();

    //
    // Find out if there are multiple batteries and a selector on this machine.
    //

    status = SmbGetSBS (
        &subsystemExt->NumberOfBatteries,
        &subsystemExt->SelectorPresent,
        subsystemExt->LowerDevice
    );


    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattCreatePdos: error reading SBS\n"));
        return status;
    }

    status = SmbGetGLK (
        &SmbBattUseGlobalLock,
        subsystemExt->LowerDevice
    );


    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattCreatePdos: error reading GLK\n"));
        //
        // If this failed, ignore the failure and continue.  This is not critical.
        //
    }

    //
    // Build the selector information structure
    //

    // Adjust Number of Batteries to Match SelectorInfo Supported Batteries
    // Just in case the ACPI information is incorrect
    status = SmbBattBuildSelectorStruct (SubsystemFdo);

    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattCreatePdos: couldn't talk to the selector\n"));
        return status;
    }

    //
    // Build device object for each battery
    //

    for (i = 0; i < subsystemExt->NumberOfBatteries; i++) {

        //
        // Create the device object
        //

        status = IoCreateDevice(
            SubsystemFdo->DriverObject,
            sizeof (SMB_BATT_PDO),
            NULL,
            FILE_DEVICE_BATTERY,
            FILE_DEVICE_SECURE_OPEN|FILE_AUTOGENERATED_DEVICE_NAME,
            FALSE,
            &pdo
        );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattCreatePdos: error creating battery pdo %x\n", status));

            //
            // Make sure we don't later try to use devices that weren't created.
            //
            subsystemExt->NumberOfBatteries = i;

            return(status);
        }

        //
        // Initialize the Pdo
        //

        pdo->Flags      |= DO_BUFFERED_IO;
        pdo->Flags      |= DO_POWER_PAGABLE;
        
        //
        // Save the PDO in the subsystem FDO PDO list
        //

        subsystemExt->BatteryPdoList[i] = pdo;

        //
        // Initialize the PDO extension
        //

        batteryPdoExt = (PSMB_BATT_PDO) pdo->DeviceExtension;

        batteryPdoExt->SmbBattFdoType   = SmbTypePdo;
        batteryPdoExt->DeviceObject     = pdo;
        batteryPdoExt->BatteryNumber    = i;
        batteryPdoExt->SubsystemFdo     = SubsystemFdo;
        IoInitializeRemoveLock (&batteryPdoExt->RemoveLock,
                                SMB_BATTERY_TAG,
                                REMOVE_LOCK_MAX_LOCKED_MINUTES,
                                REMOVE_LOCK_HIGH_WATER_MARK);

        //
        // Device is ready for use
        //
        
        pdo->Flags      &= ~DO_DEVICE_INITIALIZING;

    }  // for (i = 0; i < subsystemExt->NumberOfBatteries; i++)

    return STATUS_SUCCESS;

}





NTSTATUS
SmbBattBuildDeviceRelations(
    IN  PSMB_BATT_SUBSYSTEM SubsystemExt,
    IN  PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine is checks the device relations structure for existing device
    relations, calculates how big a new device relations structure has to be,
    allocates it, and fills it with the PDOs created for the batteries.

Arguments:

    SubsystemExt        - Device extension for the smart battery subsystem FDO

    DeviceRelations     - The Current DeviceRelations for the device...

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_RELATIONS   newDeviceRelations;
    ULONG               i, j;
    ULONG               newDeviceRelationsSize;
    NTSTATUS            status;

    ULONG               existingPdos            = 0;
    ULONG               deviceRelationsSize     = 0;
    ULONG               numberOfPdos            = 0;

    PAGED_CODE();

    //
    // Calculate the size the new device relations structure has to be
    //

    if (*DeviceRelations != NULL && (*DeviceRelations)->Count > 0) {

        //
        // There are existing device relations to be copied
        //

        existingPdos = (*DeviceRelations)->Count;
        deviceRelationsSize = sizeof (ULONG) + (sizeof (PDEVICE_OBJECT) * existingPdos);
    }


    //
    // Calculate the size needed for the new device relations structure and allocate it
    //

    numberOfPdos = existingPdos + SubsystemExt->NumberOfBatteries;
    newDeviceRelationsSize = sizeof (ULONG) + (sizeof (PDEVICE_OBJECT) * numberOfPdos);

    newDeviceRelations = ExAllocatePoolWithTag (PagedPool, newDeviceRelationsSize, 'StaB');

    if (!newDeviceRelations) {
        BattPrint (BAT_ERROR, ("SmbBattBuildDeviceRelations:  couldn't allocate device relations buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // If there are existing device relations copy them to the new device
    // relations structure and free the old one.
    //

    if (existingPdos) {
        RtlCopyMemory (newDeviceRelations, *DeviceRelations, deviceRelationsSize);
    }

    if (*DeviceRelations) {   // Could be a zero length list, but still need freeing
        ExFreePool (*DeviceRelations);
    }


    //
    // Now add the battery PDOs to the end of the list and reference it
    //

    for (i = existingPdos, j = 0; i < numberOfPdos; i ++, j ++) {
        newDeviceRelations->Objects[i] = SubsystemExt->BatteryPdoList[j];

        status = ObReferenceObjectByPointer(
            SubsystemExt->BatteryPdoList[j],
            0,
            NULL,
            KernelMode
        );

        if (!NT_SUCCESS(status) ) {

            //
            // This should theoretically never happen...
            //
            BattPrint(BAT_ERROR, ("SmbBattBuildDeviceRelations: error referencing battery pdo %x\n", status));
            return status;
        }
    }

    newDeviceRelations->Count = numberOfPdos;
    *DeviceRelations = newDeviceRelations;

    return STATUS_SUCCESS;
}



NTSTATUS
SmbBattQueryDeviceRelations(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_DEVICE_RELATIONS.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{

    PSMB_NP_BATT            SmbNPBatt       = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PSMB_BATT_PDO           PdoExt          = (PSMB_BATT_PDO) DeviceObject->DeviceExtension;
    PSMB_BATT_SUBSYSTEM     SubsystemExt    = (PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension;
    PDEVICE_OBJECT          pdo;
    PIO_STACK_LOCATION      IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;
    ULONG                   i;
    PDEVICE_RELATIONS   deviceRelations =
        (PDEVICE_RELATIONS) Irp->IoStatus.Information;


    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattQueryDeviceRelations: ENTERING\n"));

    switch (SmbNPBatt->SmbBattFdoType) {
        case SmbTypeSubsystem: {
            if (IrpSp->Parameters.QueryDeviceRelations.Type == BusRelations) {
                BattPrint(
                    BAT_IRPS,
                    ("SmbBattQueryDeviceRelations: Handling Bus relations request\n")
                );

                if (SubsystemExt->NumberOfBatteries != 0) {
                    //
                    // We've already found our batteries, so we don't need to
                    // look again since smart batteries are static.
                    // Just rebuild the return structure.
                    //

                    status = SmbBattBuildDeviceRelations (SubsystemExt, &deviceRelations);
                } else {
                    status = SmbBattCreatePdos (DeviceObject);

                    if (NT_SUCCESS (status)) {
                        status = SmbBattBuildDeviceRelations (SubsystemExt, &deviceRelations);
                    }

                    if (NT_SUCCESS (status)) {

                        //
                        // Now register for alarms
                        // (Used to register during START_DEVICE,
                        // but don't need notifications until after the batteries
                        // are here. This avoids some other problems too.)

                        status = SmbBattRegisterForAlarm (DeviceObject);
                    }
                }
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

            }

            break;
        }
        case SmbTypeBattery: {
            status = STATUS_NOT_SUPPORTED;

            break;
        }
        case SmbTypePdo: {
            if (IrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation ) {
                BattPrint(
                    BAT_IRPS,
                    ("SmbBattQueryDeviceRelations: Handling TargetDeviceRelation request\n")
                );
                deviceRelations = ExAllocatePoolWithTag (PagedPool,
                                                         sizeof(DEVICE_RELATIONS),
                                                         SMB_BATTERY_TAG);
                if (!deviceRelations) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                status = ObReferenceObjectByPointer(DeviceObject,
                                                    0,
                                                    NULL,
                                                    KernelMode);
                if (!NT_SUCCESS(status)) {
                    ExFreePool(deviceRelations);
                    return status;
                }
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            } else {
                status = STATUS_NOT_SUPPORTED;
            }

            break;
        }
        default: {

            ASSERT (FALSE);
        }
    }

    return status;
}




NTSTATUS
SmbBattRemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_REMOVE_DEVICE.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{

    PSMB_NP_BATT            SmbNPBatt       = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PSMB_BATT_PDO           PdoExt          = (PSMB_BATT_PDO) DeviceObject->DeviceExtension;
    PSMB_BATT_SUBSYSTEM     SubsystemExt    = (PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension;
    PDEVICE_OBJECT          pdo;
    PIO_STACK_LOCATION      IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;
    ULONG                   i;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattRemoveDevice: ENTERING\n"));

    switch (SmbNPBatt->SmbBattFdoType) {
        case SmbTypeSubsystem: {
            BattPrint(BAT_IRPS, ("SmbBattRemoveDevice: Removing Subsystem FDO.\n"));

            //
            // De-register for notifications
            //

            SmbBattUnregisterForAlarm (DeviceObject);

            IoFreeWorkItem (SubsystemExt->WorkerThread);

            //
            // Remove PDOs
            //

            for (i = 0; i < SubsystemExt->NumberOfBatteries; i++) {
                pdo = SubsystemExt->BatteryPdoList[i];
                if (pdo) {
                    PdoExt = (PSMB_BATT_PDO) pdo->DeviceExtension;
                    status = IoAcquireRemoveLock (&PdoExt->RemoveLock, Irp);
                    IoReleaseRemoveLockAndWait (&PdoExt->RemoveLock, Irp);
                    SubsystemExt->BatteryPdoList[i] = NULL;
                    IoDeleteDevice (pdo);
                }
            }

            if ((SubsystemExt->SelectorPresent) && (SubsystemExt->Selector)) {
                ExFreePool (SubsystemExt->Selector);
            }

            IoSkipCurrentIrpStackLocation (Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = IoCallDriver (SubsystemExt->LowerDevice, Irp);

            IoDetachDevice (SubsystemExt->LowerDevice);
            IoDeleteDevice (DeviceObject);

            break;
        }
        case SmbTypeBattery: {

            BattPrint(BAT_IRPS, ("SmbBattRemoveDevice: Removing Battery FDO\n"));
            IoReleaseRemoveLockAndWait (&SmbNPBatt->RemoveLock, Irp);

            //
            // Unregister as a WMI Provider.
            //
            SmbBattWmiDeRegistration(SmbNPBatt);
            
            //
            //  Tell the class driver we are going away
            //
            status = BatteryClassUnload (SmbNPBatt->Class);
            ASSERT (NT_SUCCESS(status));

            ExFreePool (SmbNPBatt->Batt);

            ((PSMB_BATT_PDO) SmbNPBatt->LowerDevice->DeviceExtension)->Fdo = NULL;
            
            IoSkipCurrentIrpStackLocation (Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = IoCallDriver (SmbNPBatt->LowerDevice, Irp);

            IoDetachDevice (SmbNPBatt->LowerDevice);
            IoDeleteDevice (DeviceObject);

            break;
        }
        case SmbTypePdo: {
            BattPrint(BAT_IRPS, ("SmbBattRemoveDevice: Remove for Battery PDO (doing nothing)\n"));
            //
            // Don't delete the device until it is physically removed.
            // Usually, the battery subsystem can't be physically removed...
            //

            //
            // Need to release Remove lock, since PnP dispatch won't...
            //
            IoReleaseRemoveLock (&PdoExt->RemoveLock, Irp);

            status = STATUS_SUCCESS;

            //
            // Complete the request with the current status
            //
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            break;
        }
        default: {

            ASSERT (FALSE);
        }
    }

    BattPrint(BAT_TRACE, ("SmbBattRemoveDevice: EXITING\n"));

    return status;
}




NTSTATUS
SmbBattQueryId(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_ID for the newly created battery PDOs.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{
    UNICODE_STRING          unicodeString;
    WCHAR                   unicodeBuffer[MAX_DEVICE_NAME_LENGTH];
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];

    PSMB_BATT_PDO           pdoExt          = (PSMB_BATT_PDO) Pdo->DeviceExtension;
    NTSTATUS                status          = STATUS_SUCCESS;
    PWCHAR                  idString        = NULL;
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattQueryId: ENTERING\n"));

    RtlZeroMemory (unicodeBuffer, MAX_DEVICE_NAME_LENGTH);
    unicodeString.MaximumLength = MAX_DEVICE_NAME_LENGTH;
    unicodeString.Length        = 0;
    unicodeString.Buffer        = unicodeBuffer;


    switch (irpStack->Parameters.QueryId.IdType) {

    case BusQueryDeviceID:

        //
        // This string has to have the form BUS\DEVICE.
        //
        // Use SMB as bus and SBS as device
        //

        RtlAppendUnicodeToString  (&unicodeString, SubSystemIdentifier);
        break;

    case BusQueryInstanceID:

        //
        // Return the string "Batteryxx" where xx is the battery number
        //

        numberString.MaximumLength = 10;
        numberString.Buffer = &numberBuffer[0];

        RtlIntegerToUnicodeString (pdoExt->BatteryNumber, 10, &numberString);
        RtlAppendUnicodeToString  (&unicodeString, BatteryInstance);
        RtlAppendUnicodeToString  (&unicodeString, &numberString.Buffer[0]);
        break;

    case BusQueryHardwareIDs:

        //
        // This is the Pnp ID for the smart battery subsystem "ACPI0002".
        // Make new hardware ID SMB\SBS, SmartBattery as a MULTIZ string
        // so we have to add a NULL string to terminate.
        //

        RtlAppendUnicodeToString  (&unicodeString, HidSmartBattery);
        unicodeString.Length += sizeof (WCHAR);
        break;

    default:

        //
        // Unknown Query Type
        //

        status = STATUS_NOT_SUPPORTED;

    }


    if (status != STATUS_NOT_SUPPORTED) {
        //
        // If we created a string, allocate a buffer for it and copy it into the buffer.
        // We need to make sure that we also copy the NULL terminator.
        //

        if (unicodeString.Length) {
            idString = ExAllocatePoolWithTag (PagedPool, unicodeString.Length + sizeof (WCHAR), 'StaB');

            if (!idString) {
                BattPrint (BAT_ERROR, ("SmbBattQueryId:  couldn't allocate id string buffer\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory (idString, unicodeString.Length + sizeof (WCHAR));
            RtlCopyMemory (idString, unicodeString.Buffer, unicodeString.Length);
        }

        Irp->IoStatus.Status = status;

        Irp->IoStatus.Information = (ULONG_PTR) idString;
    }

    BattPrint(BAT_DATA, ("SmbBattQueryId: returning ID = %x\n", idString));

    return status;
}




NTSTATUS
SmbBattQueryCapabilities(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_CAPABILITIES for the newly created
    battery PDOs.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{

    PDEVICE_CAPABILITIES    deviceCaps;
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    deviceCaps = irpStack->Parameters.DeviceCapabilities.Capabilities;

    if (deviceCaps->Version != 1) {
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Now set up the bits for the capabilities.
    //

    //All bits are initialized to false.  Only set bits that we support
    deviceCaps->SilentInstall   = TRUE;

    //
    // Now fill in the po manager information.
    //

    deviceCaps->SystemWake      = PowerSystemUnspecified;
    deviceCaps->DeviceWake      = PowerDeviceUnspecified;
    deviceCaps->D1Latency       = 1;
    deviceCaps->D2Latency       = 1;
    deviceCaps->D3Latency       = 1;

    return STATUS_SUCCESS;
}




SmbBattBuildSelectorStruct(
    IN PDEVICE_OBJECT SubsystemFdo
    )
/*++

Routine Description:

    This routine determines that address of the selector (whether it is a stand
    alone selector of part of the charger) and builds a selector structure with
    this information.  It also reads the initial selector information and
    caches this in the structure.  This structure will be passed out to all of
    the smart batteries in the system.

Arguments:

    SubsystemFdo    - Fdo for the smart battery subsystem

Return Value:

    NTSTATUS

--*/
{
    ULONG                   result;
    UCHAR                   smbStatus;

    PBATTERY_SELECTOR       selector     = NULL;
    PSMB_BATT_SUBSYSTEM     subsystemExt = (PSMB_BATT_SUBSYSTEM) SubsystemFdo->DeviceExtension;
    ULONG                   numberOfBatteries;

    PAGED_CODE();

    if (subsystemExt->SelectorPresent) {

        //
        // Allocate the selector structure.  This has to be from non-paged pool because
        // it will be accessed as part of the alarm processing.
        //

        selector = ExAllocatePoolWithTag (NonPagedPool, sizeof (BATTERY_SELECTOR), 'StaB');

        if (!selector) {
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't allocate selector structure\n"));
            
            //
            // Force Selector Not Present if allocation fails
            //

            subsystemExt->Selector = NULL;
            subsystemExt->SelectorPresent = FALSE;
            subsystemExt->NumberOfBatteries = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // See if the selector is part of the charger.  We do this by reading
        // directly from the selector first.  If this fails, then we verify
        // the charger is implementing the selector.
        //

        smbStatus = SmbBattGenericRW (
            subsystemExt->SmbHcFdo,
            SMB_SELECTOR_ADDRESS,
            SELECTOR_SELECTOR_STATE,
            &result
        );

        if (smbStatus == SMB_STATUS_OK) {

            //
            // We have a stand alone selector
            //

            selector->SelectorAddress       = SMB_SELECTOR_ADDRESS;
            selector->SelectorStateCommand  = SELECTOR_SELECTOR_STATE;
            selector->SelectorPresetsCommand= SELECTOR_SELECTOR_PRESETS;
            selector->SelectorInfoCommand   = SELECTOR_SELECTOR_INFO;

            BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: The selector is standalone\n"));

        } else {

            //
            // Read the Charger Spec Info to check Selector Implemented Bit
            // NOTE: We're doing this for verification and information purposes
            //

            smbStatus = SmbBattGenericRW (
                subsystemExt->SmbHcFdo,
                SMB_CHARGER_ADDRESS,
                CHARGER_SPEC_INFO,
                &result
            );

            if (smbStatus == SMB_STATUS_OK) {
                if (result & CHARGER_SELECTOR_SUPPORT_BIT) {
                    // If Selector Support Bit is present, then Selector implemented in Charger
                    BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: ChargerSpecInfo indicates charger implementing selector\n"));

                } else {
                    // If Charger says it doesn't implement Selector, let's double-check anyway
                    BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: ChargerSpecInfo indicates charger does not implement selector\n"));
                }
            } else {
                // If it returns an error, let's double-check anyway
                BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read ChargerSpecInfo - %x\n", smbStatus));
            }

            //
            // Read SelectorState for Cache
            //

            smbStatus = SmbBattGenericRW (
                subsystemExt->SmbHcFdo,
                SMB_CHARGER_ADDRESS,
                CHARGER_SELECTOR_STATE,
                &result
            );

            if (smbStatus == SMB_STATUS_OK) {
                BattPrint (BAT_DATA, ("SmbBattBuildSelectorStruct: Selector state %x\n", result));

            } else {

                BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read charger selector state - %x\n", smbStatus));
                goto SelectorErrorExit;
            }

            //
            // The charger is implementing the selector
            //

            selector->SelectorAddress       = SMB_CHARGER_ADDRESS;
            selector->SelectorStateCommand  = CHARGER_SELECTOR_STATE;
            selector->SelectorPresetsCommand= CHARGER_SELECTOR_PRESETS;
            selector->SelectorInfoCommand   = CHARGER_SELECTOR_INFO;

            BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: Charger implements the selector\n"));

        }

        //
        // Initialize the selector mutex
        //

        ExInitializeFastMutex (&selector->Mutex);

        //
        // Store SelectorState in Cache
        //

        selector->SelectorState = result;

        //
        // Read SelectorPresets for Cache
        //

        smbStatus = SmbBattGenericRW (
            subsystemExt->SmbHcFdo,
            selector->SelectorAddress,
            selector->SelectorPresetsCommand,
            &selector->SelectorPresets
        );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read selector presets - %x\n", smbStatus));
            
            //
            // Should we really fail the whole thing, because of an error reading SelectorPresets?
            // Let's Emulate the Information (Ok To Use All, Use Next A if available)
            //

            selector->SelectorPresets = (selector->SelectorState & SELECTOR_PRESETS_OKTOUSE_MASK);
            if (selector->SelectorPresets & BATTERY_A_PRESENT) {
                selector->SelectorPresets |= (BATTERY_A_PRESENT << SELECTOR_SHIFT_USENEXT);
            }
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Emulating Selector Presets - %x\n", selector->SelectorPresets));

        } else {
            BattPrint (BAT_DATA, ("SmbBattBuildSelectorStruct: Selector presets %x\n", selector->SelectorPresets));
        }

        //
        // Read Selector Info for Cache
        //

        smbStatus = SmbBattGenericRW (
            subsystemExt->SmbHcFdo,
            selector->SelectorAddress,
            selector->SelectorInfoCommand,
            &selector->SelectorInfo
        );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read selector info - %x\n", smbStatus));
            //
            // Should we really fail the whole thing, because of an error reading SelectorInfo?
            // Let's Emulate the Information (Specification 1.0, No Charge Indicator)
            //

            selector->SelectorInfo = 0x0010;
            if (subsystemExt->NumberOfBatteries > 0) {
                selector->SelectorInfo |= BATTERY_A_PRESENT;
            }
            if (subsystemExt->NumberOfBatteries > 1) {
                selector->SelectorInfo |= BATTERY_B_PRESENT;
            }
            if (subsystemExt->NumberOfBatteries > 2) {
                selector->SelectorInfo |= BATTERY_C_PRESENT;
            }
            if (subsystemExt->NumberOfBatteries > 3) {
                selector->SelectorInfo |= BATTERY_D_PRESENT;
            }
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Emulating Selector Info - %x\n", selector->SelectorInfo));

        } else {

            BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: Selector info %x\n", selector->SelectorInfo));

            // Verify the Number of Batteries against the SelectorInfo
            numberOfBatteries = 0;
            result = (selector->SelectorInfo & SELECTOR_INFO_SUPPORT_MASK);
            if (result & BATTERY_A_PRESENT) numberOfBatteries++;
            if (result & BATTERY_B_PRESENT) numberOfBatteries++;
            if (result & BATTERY_C_PRESENT) numberOfBatteries++;
            if (result & BATTERY_D_PRESENT) numberOfBatteries++;

            // Should we always override ACPI??
            // Proposed Solution: if Selector supports less batteries than
            // ACPI says, then Override ACPI with selector support.  If
            // Selector supports more than ACPI says, then don't override,
            // unless ACPI was invalid and the # of batteries = 1

            if (subsystemExt->NumberOfBatteries > numberOfBatteries) {
                subsystemExt->NumberOfBatteries = numberOfBatteries;
            } else if ((subsystemExt->NumberOfBatteries == 1) && (numberOfBatteries > 1)) {
                subsystemExt->NumberOfBatteries = numberOfBatteries;
            } else if (subsystemExt->NumberOfBatteries < numberOfBatteries) {
                //subsystemExt->NumberOfBatteries = numberOfBatteries;
            }

        }

    }   // if (subsystemFdo->SelectorPresent)

    //
    // Everything was OK
    //

    subsystemExt->Selector = selector;
    return STATUS_SUCCESS;

SelectorErrorExit:

    //
    // If a failure occurs, free the selector structure and don't creat any batery devices.
    //

    ExFreePool (selector);
    subsystemExt->Selector = NULL;
    subsystemExt->SelectorPresent = FALSE;
    subsystemExt->NumberOfBatteries = 0;

    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\oprghdlr\oprghdlr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    oprghdlr.c

Abstract:

    This module contains the code that implements ACPI op region 
    registration DLL

Author:

    Vincent Geglia (vincentg) 09-Feb-2000

Environment:

    Kernel mode

Notes:

    
Revision History:


--*/

//
// Standard includes
//

#include "stdarg.h"
#include "stdio.h"
#include "wdm.h"

//
// Oprghdlr dll specific includes
//

#include "oprghdlr.h"

//
// Definitions / static definitions
//

#define DEBUG_INFO      1
#define DEBUG_WARN      2
#define DEBUG_ERROR     4

static const UCHAR DebugPrepend[] = {'O', 'P', 'R', 'G', 'H', 'D', 'L', 'R', ':'};

//
// IRP_MJ_INTERNAL_DEVICE_CONTROL CODES
//

#define IOCTL_ACPI_REGISTER_OPREGION_HANDLER    CTL_CODE(FILE_DEVICE_ACPI, 0x2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER  CTL_CODE(FILE_DEVICE_ACPI, 0x3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Signatures for Register, Unregister of OpRegions
//

#define ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE     'HorA'
#define ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE   'HouA'

//
// Globals / Externals
//

extern ULONG OprghdlrDebugLevel = 0;

//
// Structures / type definitions
//

typedef struct _ACPI_REGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    ULONG                   AccessType;
    ULONG                   RegionSpace;
    PACPI_OP_REGION_HANDLER  Handler;
    PVOID                   Context;
} ACPI_REGISTER_OPREGION_HANDLER_BUFFER, *PACPI_REGISTER_OPREGION_HANDLER_BUFFER;

typedef struct _ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    PVOID                   OperationRegionObject;
} ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER,*PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER;

//
// Define the local routines used by this driver module.
//

VOID
DebugPrint (
            IN ULONG DebugLevel,
            IN PUCHAR DebugMessage,
            ...
            );

NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

//
// Function code
//

NTSTATUS
RegisterOpRegionHandler (
                         IN PDEVICE_OBJECT DeviceObject,
                         IN ULONG AccessType,
                         IN ULONG RegionSpace,
                         IN PACPI_OP_REGION_HANDLER Handler,
                         IN PVOID Context,
                         IN ULONG Flags,
                         IN OUT PVOID *OperationRegionObject
                         )

/*++

Routine Description:

    This is the operation region registration routine.  It builds the appropriate 
    IOCTL, and sends it to ACPI to register the op region handler.
        
Arguments:

    DeviceObject - Pointer to device object for ACPI PDO
    AccessType - Specifies accesstype for which to register the op region handler
                 (see oprghdlr.h)
    RegionSpace - Specifies the region space type for which the op region handler should
                  be called for
    Handler - Pointer to a function that will handle the op region accesses
    Context - Context passed to handler when op region access occurs
    OperationRegionObject - Contains a pointer to the op region object returned by ACPI
    

Return Value:

    STATUS_SUCCESS if sucessful, otherwise error status.

--*/

{
    ACPI_REGISTER_OPREGION_HANDLER_BUFFER   inputData;
    ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER outputData;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status = STATUS_SUCCESS;
    PIRP irp;

    DebugPrint (DEBUG_INFO,
                "Entering RegisterOpRegionHandler\n");
    
    //
    // Zero out IOCTL buffers
    //

    RtlZeroMemory (&inputData, sizeof (inputData));
    RtlZeroMemory (&outputData, sizeof (outputData));

    //
    // Init our synchronization event
    //
    
    KeInitializeEvent (&event, SynchronizationEvent, FALSE);

    //
    // Set up the IOCTL buffer
    //
    
    inputData.Signature = ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE;
    inputData.AccessType = AccessType;
    inputData.RegionSpace = RegionSpace;
    inputData.Handler = Handler;
    inputData.Context = Context;

    //
    // Build the IOCTL
    //
    
    irp = IoBuildDeviceIoControlRequest (IOCTL_ACPI_REGISTER_OPREGION_HANDLER,
                                         DeviceObject,
                                         &inputData,
                                         sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER),
                                         &outputData,
                                         sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER),
                                         FALSE,
                                         &event,
                                         &ioStatus);

    if (!irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send to ACPI driver
    //
    
    status = IoCallDriver (DeviceObject, irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //
        
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        //
        // Get the real status
        //
        
        status = ioStatus.Status;
    }

    //
    // Check the status code
    //

    if (!NT_SUCCESS(status)) {

        DebugPrint (DEBUG_ERROR,
                    "Registration IRP was failed by ACPI (%lx)\n",
                    status);
        
        return status;
    }

    //
    // Check the signature
    //
    
    if (outputData.Signature != ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE) {

        status = STATUS_ACPI_INVALID_DATA;

        DebugPrint (DEBUG_ERROR,
                    "Signature returned from ACPI is invalid.  Registration failed.\n");

        return status;

    }
    
    *OperationRegionObject = outputData.OperationRegionObject;
    
    return status;

}

NTSTATUS
DeRegisterOpRegionHandler (
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PVOID OperationRegionObject
                           )

/*++

Routine Description:

    This is the operation region deregistration routine.  It builds the appropriate 
    IOCTL, and sends it to ACPI to deregister the op region handler.
        
Arguments:

    DeviceObject - Pointer to device object for ACPI PDO
    OperationRegionObject - Contains a pointer to the op region object returned
                            during registration
    

Return Value:

    STATUS_SUCCESS if sucessful, otherwise error status.

--*/
{
    ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER inputData;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    
    DebugPrint (DEBUG_INFO,
                "Entering DeRegisterOpRegionHandler\n");

    //
    // Zero out IOCTL buffer
    //

    RtlZeroMemory (&inputData, sizeof (inputData));

    //
    // Init our synchronization event
    //
    
    KeInitializeEvent (&event, SynchronizationEvent, FALSE);

    //
    // Set up the IOCTL buffer
    //
    
    inputData.Signature = ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE;
    inputData.OperationRegionObject = OperationRegionObject;

    //
    // Build the IOCTL
    //
    
    irp = IoBuildDeviceIoControlRequest (IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER,
                                         DeviceObject,
                                         &inputData,
                                         sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER),
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatus);

    if (!irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send to ACPI driver
    //
    
    status = IoCallDriver (DeviceObject, irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //
        
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        //
        // Get the real status
        //
        
        status = ioStatus.Status;
    }

    //
    // Check the status code
    //

    if (!NT_SUCCESS(status)) {

        DebugPrint (DEBUG_ERROR,
                    "Deregistration IRP was failed by ACPI (%lx)\n",
                    status);
        
    }
    
    return status;
}

VOID
DebugPrint (
            IN ULONG DebugLevel,
            IN PUCHAR DebugMessage,
            ...
            )

/*++

Routine Description:

    This is the general debug printing routine.
    
Arguments:

    DebugLevel - Debug level for which this message should be printed
    DebugMessage - Pointer to a buffer for the message to be printed    
    ... - Variable length argument list

Return Value:

    None

--*/
{
    UCHAR Text[200];
    va_list va;

    RtlCopyMemory (&Text, DebugPrepend, sizeof (DebugPrepend));

    va_start (va, DebugMessage);
    vsprintf ((PVOID) ((ULONG_PTR) &Text + sizeof (DebugPrepend)), DebugMessage, va);
    va_end (va);

    if (OprghdlrDebugLevel & DebugLevel) {
        DbgPrint (Text);
    }
} 

/*++

Routine Description:

    Required DriverEntry routine.  Not used as this is an EXPORT_DRIVER type.
    
Arguments:

    DriverObject - Address of DriverObject
    RegistryPath - Address of the registry path
    
Return Value:

    STATUS_SUCCESS, always

--*/

NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbali\smbalip.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smbali.c

Abstract:

    SMB Host Controller Driver for ALI chipset

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/
#include <wdm.h>
#include <smbus.h>
#include <devioctl.h>
#include <acpiioct.h>
#include <initguid.h>
#include <wdmguid.h>


//
// Debuging
//
#if DBG
    extern ULONG SmbAliDebug;
    #define SmbPrint(l,m) if(l & SmbAliDebug) DbgPrint m
#else
    #define SmbPrint(l,m)
#endif

#define SMB_IO_RESULT   0x00002000
#define SMB_STATS       0x00001000
#define SMB_ALARM       0x00000800
#define SMB_IO_REQUEST  0x00000400
#define SMB_DATA        0x00000200
#define SMB_IO          0x00000100
#define SMB_TRACE       0x00000010
#define SMB_BUS_ERROR   0x00000002
#define SMB_ERROR       0x00000001

//#define USE_IO_DELAY

#ifdef USE_IO_DELAY
    VOID SmbDelay(VOID);
    #define SMBDELAY SmbDelay ()
#else
    #define SMBDELAY
#endif

// The follow constants are based on 10,000,000 / sec <OR> 100ns time units.
#define MICROSECONDS    (10)
#define MILLISECONDS    (1000*MICROSECONDS)
#define SECONDS         (1000*MILLISECONDS)


#define SMB_ALI_MAJOR_VERSION 1
#define SMB_ALI_MINOR_VERSION 1

extern LARGE_INTEGER SmbIoPollRate;
extern ULONG SmbIoInitTimeOut;
extern ULONG SmbIoCompleteTimeOut;
extern LARGE_INTEGER SmbAlertPollRate;

typedef enum {
    SmbIoIdle,
    SmbIoComplete
} SMB_ALI_IO_STATE;

#define SMB_ALI_IO_RESOURCE_LENGTH 0x40

typedef struct {
    UCHAR   Address;
    UCHAR   Command;
    UCHAR   Protocol;
    BOOLEAN ValidData;
    USHORT   LastData;
} SMB_ALI_POLL_ENTRY, *PSMB_ALI_POL_ENTRY;

typedef struct {

    PUCHAR SmbBaseIo;  // Base IoAddress

    SMB_ALI_IO_STATE IoState;
    ACPI_INTERFACE_STANDARD AcpiInterfaces;
    PIO_WORKITEM    WorkItem;

    PIO_WORKITEM    InitWorker;
    KDPC            InitDpc;
    KTIMER          InitTimer;
    ULONG           InitTimeOut;

    PIO_WORKITEM    CompleteWorker;
    KDPC            CompleteDpc;
    KTIMER          CompleteTimer;
    ULONG           CompleteTimeOut;

    PIO_WORKITEM    PollWorker;
    KEVENT          PollWorkerActive;
    KDPC            PollDpc;
    KTIMER          PollTimer;
    PSMB_ALI_POL_ENTRY  PollList;
    ULONG           PollListCount;

    ULONG           InternalRetries;

} SMB_ALI_DATA, *PSMB_ALI_DATA;

//
// ALI SMBus control registers and bits
//

#define SMB_STS_REG (AliData->SmbBaseIo + 0)
#define SMB_STS_ALERT_STS	0x01	//(1 << 0)
#define SMB_STS_IDLE_STS	0x04	//(1 << 2) // Bus is idle
#define SMB_STS_SMB_IDX_CLR 0x04	//(1 << 2) // Write SMB Index clear.
#define SMB_STS_HOST_BSY	0x08	//(1 << 3) // Bus is busy - do not issue another bus cycle if this is set
#define SMB_STS_SCI_I_STS	0x10	//(1 << 4) // command completed
#define SMB_STS_DRV_ERR		0x20	//(1<<5)
#define SMB_STS_BUS_ERR		0x40	//(1<<6)
#define SMB_STS_FAILED		0x80	//(1<<7)
#define SMB_STS_CLEAR		0xf1
#define SMB_STS_ERRORS		0xe0

#define SMB_STS_LAST_CMD_COMPLETED 0x14
#define SMB_STS_CLEAR_DONE	0x11

#define SMB_TYP_REG (AliData->SmbBaseIo + 1)
#define SMB_TYP_MASK 0x70
#define SMB_TYP_QUICK 0x00
#define SMB_TYP_SEND 0x10
#define SMB_TYP_BYTE 0x20
#define SMB_TYP_WORD 0x30
#define SMB_TYP_BLOCK 0x40
#define SMB_TYP_PROCESS 0x50
#define SMB_TYP_I2C 0x60
#define SMB_TYP_KILL (1<<2)
#define SMB_TYP_T_OUT_CMD (1<<3)


#define STR_PORT_REG (AliData->SmbBaseIo + 2)
#define STR_PORT_START 0xff

#define DEV_ADDR_REG (AliData->SmbBaseIo + 3)
#define DEV_DATA0_REG (AliData->SmbBaseIo + 4)
#define DEV_DATA1_REG (AliData->SmbBaseIo + 5)
#define BLK_DATA_REG (AliData->SmbBaseIo + 6)
#define SMB_CMD_REG (AliData->SmbBaseIo + 7)



NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SmbAliInitializeMiniport (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SmbAliAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SmbAliResetDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SmbMiniport
    );

VOID
SmbAliStartIo (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    );

VOID
SmbAliInitTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbAliInitTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    );

VOID
SmbAliCompleteTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbAliCompleteTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    );

NTSTATUS
SmbAliStopDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    );

VOID
SmbAliNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    );

VOID
SmbAliWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
SmbAliSyncronousIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
SmbAliTransactionComplete (
    PSMB_ALI_DATA AliData,
    PUCHAR SmbStatus
    );

BOOLEAN
SmbAliHostBusy (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliHandleAlert (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliResetBus (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliResetHost (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliStartDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    );

VOID
SmbAliStopDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbbatt\smbbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbbatt.c

Abstract:

    SMBus Smart Battery Subsystem Miniport Driver
    (Selector, Battery, Charger)

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

    Chris Windle    1/27/98     Bug Fixes

--*/

#include "smbbattp.h"

#include <initguid.h>
#include <batclass.h>



#if DEBUG
ULONG   SMBBattDebug = BAT_WARN | BAT_ERROR | BAT_BIOS_ERROR;
#endif

// Global
BOOLEAN   SmbBattUseGlobalLock = TRUE;
UNICODE_STRING GlobalRegistryPath;

//
// Prototypes
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
SmbBattNewDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PDO
);

NTSTATUS
SmbBattQueryTag (
    IN PVOID Context,
    OUT PULONG BatteryTag
);

NTSTATUS
SmbBattQueryInformation (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN LONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
);

NTSTATUS
SmbBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
);

NTSTATUS
SmbBattDisableStatusNotify (
    IN PVOID Context
);

NTSTATUS
SmbBattQueryStatus (
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
);

NTSTATUS
SmbBattCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
SmbBattClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
SmbBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
SmbBattUnload(
    IN PDRIVER_OBJECT DriverObject
);

VOID
SmbBattProcessSelectorAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OldSelectorState,
    IN ULONG                NewSelectorState
);

NTSTATUS
SmbBattGetPowerState (
    IN PSMB_BATT        SmbBatt,
    OUT PULONG          PowerState,
    OUT PLONG           Current
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,SmbBattNewDevice)
#pragma alloc_text(PAGE,SmbBattUnload)
#pragma alloc_text(PAGE,SmbBattCreate)
#pragma alloc_text(PAGE,SmbBattClose)
#pragma alloc_text(PAGE,SmbBattIoctl)
#pragma alloc_text(PAGE,SmbBattQueryTag)
#pragma alloc_text(PAGE,SmbBattQueryInformation)
#pragma alloc_text(PAGE,SmbBattSetInformation)
#pragma alloc_text(PAGE,SmbBattGetPowerState)
#pragma alloc_text(PAGE,SmbBattQueryStatus)
#pragma alloc_text(PAGE,SmbBattSetStatusNotify)
#pragma alloc_text(PAGE,SmbBattDisableStatusNotify)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the Smart Battery Driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    OBJECT_ATTRIBUTES   objAttributes;

    BattPrint(BAT_TRACE, ("SmbBatt: DriverEntry\n"));

    //
    // Save the RegistryPath.
    //

    GlobalRegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    GlobalRegistryPath.Length = RegistryPath->Length;
    GlobalRegistryPath.Buffer = ExAllocatePoolWithTag (
                                       PagedPool,
                                       GlobalRegistryPath.MaximumLength,
                                       'StaB');

    if (!GlobalRegistryPath.Buffer) {

        BattPrint ((BAT_ERROR),("SmbBatt: Couldn't allocate pool for registry path."));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&GlobalRegistryPath, RegistryPath);

    BattPrint (BAT_TRACE, ("SmbBatt DriverEntry - Obj (%08x) Path \"%ws\"\n",
                                 DriverObject, RegistryPath->Buffer));
    
    
    DriverObject->DriverUnload                          = SmbBattUnload;
    DriverObject->DriverExtension->AddDevice            = SmbBattNewDevice;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SmbBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = SmbBattCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SmbBattClose;

    DriverObject->MajorFunction[IRP_MJ_PNP]             = SmbBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = SmbBattPowerDispatch;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = SmbBattSystemControl;
    return STATUS_SUCCESS;
}



NTSTATUS
SmbBattNewDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PDO
    )

/*++

Routine Description:

    This creates a smb smart battery functional device objects.  The first
    object created will be the one for the "smart battery subsystem" which will
    have a PDO from ACPI.  This will receive a START Irp, then a
    QUERY_DEVICE_RELATIONS Irp.  In the QUERY it will create PDOs for the
    batteries that are supported by the system and eventually they will end
    up here for FDOs to be created and attached to them.

Arguments:

    DriverObject - Pointer to driver object created by system.

    PDO          - PDO for the new device(s)

Return Value:

    Status

--*/
{
    PDEVICE_OBJECT          fdo;
    PSMB_BATT_SUBSYSTEM     subsystemExt;
    PSMB_BATT_PDO           pdoExt;

    PSMB_NP_BATT            SmbNPBatt;
    PSMB_BATT               SmbBatt;
    BATTERY_MINIPORT_INFO   BattInit;

    NTSTATUS                status              = STATUS_UNSUCCESSFUL;
    BOOLEAN                 selectorPresent     = FALSE;

    PAGED_CODE();

    BattPrint(BAT_IRPS, ("SmbBattNewDevice: AddDevice for device %x\n", PDO));

    //
    // Check to see if we are being asked to enumerate ourself
    //

    if (PDO == NULL) {
        BattPrint(BAT_ERROR, ("SmbBattNewDevice: Being asked to enumerate\n"));
        return STATUS_NOT_IMPLEMENTED;
    }


    //
    // Check to see if the PDO is the battery subsystem PDO or a battery PDO.  This will be
    // determined by the PDO's DeviceType.
    //
    // FILE_DEVICE_ACPI     This PDO is from ACPI and belongs to battery subsystem
    // FILE_DEVICE_BATTERY  This PDO is a battery PDO
    //

    if (PDO->DeviceType == FILE_DEVICE_ACPI) {

        //
        // Create the device object
        //

        status = IoCreateDevice(
                    DriverObject,
                    sizeof (SMB_BATT_SUBSYSTEM),
                    NULL,
                    FILE_DEVICE_BATTERY,
                    0,
                    FALSE,
                    &fdo
                );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error creating Fdo for battery subsystem %x\n", status));
            return(status);
        }


        //
        // Initialize the Fdo
        //

        fdo->Flags |= DO_BUFFERED_IO;
        fdo->Flags |= DO_POWER_PAGABLE;

        //
        // Initialize the extension
        //

        subsystemExt = (PSMB_BATT_SUBSYSTEM)fdo->DeviceExtension;
        RtlZeroMemory (subsystemExt, sizeof (PSMB_BATT_SUBSYSTEM));

        subsystemExt->DeviceObject = fdo;
        subsystemExt->SmbBattFdoType = SmbTypeSubsystem;
        IoInitializeRemoveLock (&subsystemExt->RemoveLock,
                                SMB_BATTERY_TAG,
                                REMOVE_LOCK_MAX_LOCKED_MINUTES,
                                REMOVE_LOCK_HIGH_WATER_MARK);

        //
        // These fields are implicitly initialize by zeroing the extension
        //
        //         subsystemExt->NumberOfBatteries = 0;
        //         subsystemExt->SelectorPresent   = FALSE;
        //         subsystemExt->Selector          = NULL;
        //         subsystemExt->WorkerActive      = 0;


        KeInitializeSpinLock (&subsystemExt->AlarmListLock);
        InitializeListHead (&subsystemExt->AlarmList);
        subsystemExt->WorkerThread = IoAllocateWorkItem (fdo);


        //
        // Layer our FDO on top of the ACPI PDO.
        //

        subsystemExt->LowerDevice = IoAttachDeviceToDeviceStack (fdo,PDO);
        
        if (!subsystemExt->LowerDevice) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: Error attaching subsystem to device stack.\n"));

            IoDeleteDevice (fdo);

            return(status);

        }


        //
        // Zero out the battery PDO list
        //  This is already zeroed by the RtlZeroMemory above.
        //
        //  RtlZeroMemory(
        //      &subsystemExt->BatteryPdoList[0],
        //      sizeof(PDEVICE_OBJECT) * MAX_SMART_BATTERIES_SUPPORTED
        //  );


        //
        // Device is ready for use
        //
        
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;


    } else {

        //
        // This is a battery PDO.  Create the FDO to layer on top of it.
        //

        pdoExt       = (PSMB_BATT_PDO) PDO->DeviceExtension;
        subsystemExt = (PSMB_BATT_SUBSYSTEM) pdoExt->SubsystemFdo->DeviceExtension;

        //
        // Allocate space for the paged portion of the device extension
        //

        SmbBatt = ExAllocatePoolWithTag (PagedPool, sizeof(SMB_BATT), SMB_BATTERY_TAG);
        if (!SmbBatt) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: Can't allocate Smart Battery data\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (SmbBatt, sizeof(SMB_BATT));


        //
        // Create the device object
        //

        status = IoCreateDevice(
                    DriverObject,
                    sizeof (SMB_NP_BATT),
                    NULL,
                    FILE_DEVICE_BATTERY,
                    0,
                    FALSE,
                    &fdo
                 );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error creating Fdo: %x\n", status));

            ExFreePool (SmbBatt);
            return(status);
        }


        //
        // Initialize the Fdo
        //

        fdo->Flags |= DO_BUFFERED_IO;
        fdo->Flags |= DO_POWER_PAGABLE;
        
        
        //
        // Layer our FDO on top of the PDO.
        //

        SmbNPBatt = (PSMB_NP_BATT) fdo->DeviceExtension;
        SmbNPBatt->LowerDevice = IoAttachDeviceToDeviceStack (fdo,PDO);

        if (!SmbNPBatt->LowerDevice) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error attaching to device stack\n"));

            ExFreePool (SmbBatt);

            IoDeleteDevice (fdo);

            return(status);
        }


        //
        // Fill in privates
        //

        SmbNPBatt->Batt             = SmbBatt;
        SmbNPBatt->SmbBattFdoType   = SmbTypeBattery;
        IoInitializeRemoveLock (&SmbNPBatt->RemoveLock,
                                SMB_BATTERY_TAG,
                                REMOVE_LOCK_MAX_LOCKED_MINUTES,
                                REMOVE_LOCK_HIGH_WATER_MARK);

        ExInitializeFastMutex (&SmbNPBatt->Mutex);

        SmbBatt->NP                 = SmbNPBatt;
        SmbBatt->PDO                = PDO;
        SmbBatt->DeviceObject       = fdo;
        SmbBatt->SelectorPresent    = subsystemExt->SelectorPresent;
        SmbBatt->Selector           = subsystemExt->Selector;

        pdoExt->Fdo                 = fdo;

        //
        // Precalculate this batteries SMB_x bit position in the selector status register.
        //
        // Just move it into the lower nibble and any function that needs
        // the bit can shift it left 4 = charger, 8 = power, 12 = smb
        //

        SmbBatt->SelectorBitPosition = 1;
        if (pdoExt->BatteryNumber > 0) {
            SmbBatt->SelectorBitPosition <<= pdoExt->BatteryNumber;
        }


        //
        // Have class driver allocate a new SMB miniport device
        //

        RtlZeroMemory (&BattInit, sizeof(BattInit));
        BattInit.MajorVersion        = SMB_BATTERY_MAJOR_VERSION;
        BattInit.MinorVersion        = SMB_BATTERY_MINOR_VERSION;
        BattInit.Context             = SmbBatt;
        BattInit.QueryTag            = SmbBattQueryTag;
        BattInit.QueryInformation    = SmbBattQueryInformation;
        BattInit.SetInformation      = SmbBattSetInformation;
        BattInit.QueryStatus         = SmbBattQueryStatus;
        BattInit.SetStatusNotify     = SmbBattSetStatusNotify;
        BattInit.DisableStatusNotify = SmbBattDisableStatusNotify;

        BattInit.Pdo                 = PDO;
        BattInit.DeviceName          = NULL;

        status = BatteryClassInitializeDevice (
                    &BattInit,
                    &SmbNPBatt->Class
                 );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error initializing battery: %x\n", status));

            ExFreePool (SmbBatt);

            IoDetachDevice (SmbNPBatt->LowerDevice);
            IoDeleteDevice (fdo);

            return(status);
        }
        
        //
        // Register WMI support.
        //
        status = SmbBattWmiRegistration(SmbNPBatt);

        if (!NT_SUCCESS(status)) {
            //
            // WMI support is not critical to operation.  Just log an error.
            //

            BattPrint(BAT_ERROR,
                ("SmbBattNewDevice: Could not register as a WMI provider, status = %Lx\n", status));
        }


        //
        // Device is ready for use
        //
        
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;



    }   // else (we have a battery PDO)


    return status;
}



VOID
SmbBattUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Cleanup all devices and unload the driver

Arguments:

    DriverObject - Driver object for unload

Return Value:

    Status

--*/
{

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattUnload: ENTERING\n"));

    //
    // Should check here to make sure all DO's are gone.
    //

    ExFreePool (GlobalRegistryPath.Buffer);
    // This is listed as an error so I'll always see when it is unloaded...
    BattPrint(BAT_ERROR, ("SmbBattUnload: Smbbatt.sys unloaded successfully.\n"));

}



NTSTATUS
SmbBattCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSMB_NP_BATT        SmbNPBatt   = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  IrpSp       = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattCreate: ENTERING\n"));


    status = IoAcquireRemoveLock (&SmbNPBatt->RemoveLock, IrpSp->FileObject);

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BattPrint(BAT_TRACE, ("SmbBattCreate: EXITING (status = 0x%08x\n", status));
    return(status);
}



NTSTATUS
SmbBattClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSMB_NP_BATT        SmbNPBatt   = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  IrpSp       = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattClose: ENTERING\n"));

    IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, IrpSp->FileObject);

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BattPrint(BAT_TRACE, ("SmbBattClose: EXITING\n"));
    return(STATUS_SUCCESS);
}



NTSTATUS
SmbBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PSMB_NP_BATT            SmbNPBatt;
    PSMB_BATT               SmbBatt;
    ULONG                   InputLen, OutputLen;
    PVOID                   IOBuffer;
    PIO_STACK_LOCATION      IrpSp;

    BOOLEAN                 complete        = TRUE;
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattIoctl: ENTERING\n"));

    IrpSp       = IoGetCurrentIrpStackLocation(Irp);
    SmbNPBatt   = (PSMB_NP_BATT) DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&SmbNPBatt->RemoveLock, Irp);

    if (NT_SUCCESS(status)) {
        if (SmbNPBatt->SmbBattFdoType == SmbTypePdo) {
            status = STATUS_NOT_SUPPORTED;
        } else if (SmbNPBatt->SmbBattFdoType == SmbTypeSubsystem) {
            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SMBBATT_DATA) {

                //
                // Direct Access Irp
                //

                IOBuffer    = Irp->AssociatedIrp.SystemBuffer;
                InputLen    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                OutputLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                status = SmbBattDirectDataAccess (
                    (PSMB_NP_BATT) DeviceObject->DeviceExtension,
                    (PSMBBATT_DATA_STRUCT) IOBuffer,
                    InputLen,
                    OutputLen
                );

                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information = OutputLen;
                } else {
                    Irp->IoStatus.Information = 0;
                }

            } else {
                status = STATUS_NOT_SUPPORTED;
            }
        } else {
            ASSERT (SmbNPBatt->SmbBattFdoType == SmbTypeBattery);

            //
            // Check to see if this is one of the private Ioctls we handle
            //

            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
            case IOCTL_SMBBATT_DATA:
                IOBuffer    = Irp->AssociatedIrp.SystemBuffer;
                InputLen    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                OutputLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // This one is only handled by the battery subsystem
                //

                status = SmbBattDirectDataAccess (
                    (PSMB_NP_BATT) DeviceObject->DeviceExtension,
                    (PSMBBATT_DATA_STRUCT) IOBuffer,
                    InputLen,
                    OutputLen
                );

                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information = OutputLen;
                } else {
                    Irp->IoStatus.Information = 0;
                }
                break;
            default:
                //
                // Not IOCTL for us, see if it's for the battery
                //

                SmbBatt = SmbNPBatt->Batt;
                status  = BatteryClassIoctl (SmbNPBatt->Class, Irp);

                if (NT_SUCCESS(status)) {
                    //
                    // The Irp was completed by the batery class.  Don't
                    // touch the Irp.  Simply release the lock and return.
                    //

                    IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, Irp);
                    BattPrint(BAT_TRACE, ("SmbBattIoctl: EXITING (was battery IOCTL)\n", status));
                    return status;
                }

                break;

            }   // switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
        }

        IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    BattPrint(BAT_TRACE, ("SmbBattIoctl: EXITING (status = 0x%08x)\n", status));
    return status;
}



NTSTATUS
SmbBattQueryTag (
    IN  PVOID Context,
    OUT PULONG BatteryTag
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current tag value

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Pointer to return current tag


Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    //PSMB_BATT_SUBSYSTEM subsystemExt;
    NTSTATUS            status;
    PSMB_BATT           SmbBatt;
    ULONG               oldSelectorState;

    PAGED_CODE();
    BattPrint(BAT_TRACE, ("SmbBattQueryTag: ENTERING\n"));

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;
    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattQueryTag: can't set selector communications path\n"));
    } else {

        //
        // If the tag is not valid, check for one
        //

        if (SmbBatt->Info.Tag == BATTERY_TAG_INVALID) {
            SmbBatt->Info.Valid = 0;
        }

        //
        // Insure the static information regarding the battery up to date
        //

        SmbBattVerifyStaticInfo (SmbBatt, 0);

        //
        // If theres a battery return it's tag
        //

        if (SmbBatt->Info.Tag != BATTERY_TAG_INVALID) {
            *BatteryTag = SmbBatt->Info.Tag;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_NO_SUCH_DEVICE;
        }
    }


    //
    // Done, unlock the device and reset the selector state
    //

    if (NT_SUCCESS (status)) {
        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattQueryTag: can't reset selector communications path\n"));
        }
    } else {
        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }


    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattQueryTag: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattQueryInformation (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN LONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
    )
{
    PSMB_BATT           SmbBatt;
    ULONG               ResultData;
    BOOLEAN             IoCheck;
    NTSTATUS            status, st;
    PVOID               ReturnBuffer;
    ULONG               ReturnBufferLength;
    WCHAR               scratchBuffer[SMB_MAX_DATA_SIZE+1]; // +1 for UNICODE_NULL
    UNICODE_STRING      unicodeString;
    UNICODE_STRING      tmpUnicodeString;
    ANSI_STRING         ansiString;
    ULONG               oldSelectorState;
    BATTERY_REPORTING_SCALE granularity;

    PAGED_CODE();
    BattPrint(BAT_TRACE, ("SmbBattQueryInformation: ENTERING\n"));


    if (BatteryTag == BATTERY_TAG_INVALID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;
    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattQueryInformation: can't set selector communications path\n"));
    } else {

        do {
            ResultData = 0;
            ReturnBuffer = NULL;
            ReturnBufferLength = 0;
            status = STATUS_SUCCESS;


            //
            // If no device, or caller has the wrong ID give an error
            //

            if (BatteryTag != SmbBatt->Info.Tag) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }


            //
            // Get the info requested
            //

            switch (Level) {
                case BatteryInformation:
                    ReturnBuffer = &SmbBatt->Info.Info;
                    ReturnBufferLength = sizeof (SmbBatt->Info.Info);
                    break;

                case BatteryGranularityInformation:
                    SmbBattRW(SmbBatt, BAT_FULL_CHARGE_CAPACITY, &granularity.Capacity);
                    granularity.Capacity *= SmbBatt->Info.PowerScale;
                    granularity.Granularity = SmbBatt->Info.PowerScale;
                    ReturnBuffer = &granularity;
                    ReturnBufferLength  = sizeof (granularity);
                    break;

                case BatteryTemperature:
                    SmbBattRW(SmbBatt, BAT_TEMPERATURE, &ResultData);
                    ReturnBuffer = &ResultData;
                    ReturnBufferLength = sizeof(ULONG);
                    break;

                case BatteryEstimatedTime:

                    //
                    // If an AtRate has been specified, then we will use the AtRate
                    // functions to get this information (AtRateTimeToEmpty()).
                    // Otherwise, we will return the AVERAGE_TIME_TO_EMPTY.
                    //

                    BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AtRate: %08x\n", AtRate));

                    if (AtRate != 0) {
                        //
                        // Currently we only support the time to empty functions.
                        //

                        ASSERT (AtRate < 0);

                        //
                        // The smart battery input value for AtRate is in 10mW increments
                        //

                        AtRate /= (LONG)SmbBatt->Info.PowerScale;
                        BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AtRate scaled to: %08x\n", AtRate));
                        SmbBattWW(SmbBatt, BAT_AT_RATE, AtRate);
                        SmbBattRW(SmbBatt, BAT_RATE_TIME_TO_EMPTY, &ResultData);
                        BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AT_RATE_TIME_TO_EMPTY: %08x\n", ResultData));

                    } else {

                        SmbBattRW(SmbBatt, BAT_AVERAGE_TIME_TO_EMPTY, &ResultData);
                        BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AVERAGE_TIME_TO_EMPTY: %08x\n", ResultData));
                    }

                    if (ResultData == 0xffff) {
                        ResultData = BATTERY_UNKNOWN_TIME;
                    } else {
                        ResultData *= 60;
                    }
                    BattPrint(BAT_DATA, ("SmbBattQueryInformation: (%01x) EstimatedTime: %08x seconds\n", SmbBatt->SelectorBitPosition, ResultData));

                    ReturnBuffer = &ResultData;
                    ReturnBufferLength = sizeof(ULONG);
                    break;

                case BatteryDeviceName:
                    //
                    // This has to be returned as a WCHAR string but is kept internally
                    // as a character string.  Have to convert it.
                    //

                    unicodeString.Buffer        = Buffer;
                    unicodeString.MaximumLength = BufferLength > (USHORT)-1 ? (USHORT) -1 : (USHORT)BufferLength;

                    ansiString.Length = SmbBatt->Info.DeviceNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.DeviceName);
                    ansiString.Buffer = SmbBatt->Info.DeviceName;
                    status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);
                    if (NT_SUCCESS(status)) {
                        ReturnBuffer       = Buffer;
                        ReturnBufferLength = unicodeString.Length;
                    }
                    break;

                case BatteryManufactureDate:
                    ReturnBuffer = &SmbBatt->Info.ManufacturerDate;
                    ReturnBufferLength = sizeof (SmbBatt->Info.ManufacturerDate);
                    break;

                case BatteryManufactureName:
                    //
                    // This has to be returned as a WCHAR string but is kept internally
                    // as a character string.  Have to convert it.
                    //

                    unicodeString.Buffer        = Buffer;
                    unicodeString.MaximumLength = BufferLength > (USHORT)-1 ? (USHORT) -1 : (USHORT)BufferLength;

                    ansiString.Length = SmbBatt->Info.ManufacturerNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.ManufacturerName);
                    ansiString.Buffer = SmbBatt->Info.ManufacturerName;
                    status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);
                    if (NT_SUCCESS(status)) {
                        ReturnBuffer        = Buffer;
                        ReturnBufferLength = unicodeString.Length;
                    }
                    break;
                    
                case BatteryUniqueID:
                    //
                    // The unique ID is a character string consisting of the serial
                    // number, the manufacturer name, and the device name.
                    //

                    unicodeString.Buffer        = Buffer;
                    unicodeString.MaximumLength = BufferLength > (USHORT)-1 ? (USHORT) -1 : (USHORT)BufferLength;

                    tmpUnicodeString.Buffer         = scratchBuffer;
                    tmpUnicodeString.MaximumLength  = sizeof (scratchBuffer);

                    RtlIntegerToUnicodeString(SmbBatt->Info.SerialNumber, 10, &unicodeString);

                    ansiString.Length = SmbBatt->Info.ManufacturerNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.ManufacturerName);
                    ansiString.Buffer = SmbBatt->Info.ManufacturerName;
                    status = RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                    if (!NT_SUCCESS(status)) break;
                    status = RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);
                    if (!NT_SUCCESS(status)) break;

                    ansiString.Length = SmbBatt->Info.DeviceNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.DeviceName);
                    ansiString.Buffer = SmbBatt->Info.DeviceName;
                    status = RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                    if (!NT_SUCCESS(status)) break;
                    status = RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);
                    if (!NT_SUCCESS(status)) break;

                    ReturnBuffer        = Buffer;
                    ReturnBufferLength = unicodeString.Length;
                    break;

            }

            //
            // Re-verify static info in case there's been an IO error
            //

            //IoCheck = SmbBattVerifyStaticInfo (SmbBatt, BatteryTag);
            IoCheck = FALSE;

        } while (IoCheck);

    }


    if (NT_SUCCESS (status)) {
        //
        // Done, return buffer if needed
        //

        *ReturnedLength = ReturnBufferLength;
        
        if (ReturnBuffer != Buffer) {
            // ReturnBuffer == Buffer indicates that data is already copied.
            //
            if (BufferLength < ReturnBufferLength) {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            if (NT_SUCCESS(status) && ReturnBuffer) {
                memcpy (Buffer, ReturnBuffer, ReturnBufferLength);
            }
        }

        //
        // Unlock the device and reset the selector state
        //

        st = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (st)) {
            BattPrint(BAT_ERROR, ("SmbBattQueryInformation: can't reset selector communications path\n"));
            status = st;
        }
    } else {
        *ReturnedLength = 0;

        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }

    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattQueryInformation: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattSetInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL    Level,
    IN PVOID Buffer                     OPTIONAL
    )
/*++

Routine Description:

    Called by the class driver to set the battery's charge/discharge state.
    The smart battery does not support the critical bias function of this
    call.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    Level           - Action being asked for

Return Value:

    NTSTATUS

--*/
{
    PSMB_BATT           SmbBatt;
    ULONG               newSelectorState;
    ULONG               selectorState;
    UCHAR               smbStatus;
    ULONG               tmp;

    NTSTATUS            status  = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattSetInformation: ENTERING\n"));


    SmbBatt = (PSMB_BATT) Context;

    //
    // See if this is for our battery
    //

    if ((BatteryTag == BATTERY_TAG_INVALID) || (BatteryTag != SmbBatt->Info.Tag)) {
        return STATUS_NO_SUCH_DEVICE;
    }


    //
    // We can only do this if there is a selector in the system
    //

    if ((SmbBatt->SelectorPresent) && (SmbBatt->Selector)) {

        //
        // Get a lock on the selector
        //

        SmbBattLockSelector (SmbBatt->Selector);

        switch (Level) {

            case BatteryCharge:
                BattPrint(BAT_IRPS, ("SmbBattSetInformation: Got SetInformation for BatteryCharge\n"));

                //
                // Set the appropriate bit in the selector state charge nibble
                //

                newSelectorState = SELECTOR_SET_CHARGE_MASK;
                newSelectorState |= (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_CHARGE);

                //
                // Write the new selector state, then read it back.  The system
                // may or may not let us do this.
                //

                smbStatus = SmbBattGenericWW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                newSelectorState
                            );

                if (smbStatus != SMB_STATUS_OK) {
                    BattPrint(BAT_ERROR,
                         ("SmbBattSetInformation:  couldn't write selector state - %x\n",
                         smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                smbStatus = SmbBattGenericRW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                &selectorState
                            );

                if ((smbStatus != SMB_STATUS_OK)) {
                    BattPrint(BAT_ERROR,
                        ("SmbBattSetInformation:  couldn't read selector state - %x\n",
                        smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }


                //
                // Check the status that was read versus what we wrote
                // to see if the operation was successful
                //

                // To support simultaneous charging of more than one battery,
                // we can't check the charge nibble to see if it is equal to
                // what we wrote, but we can check to see if the battery
                // we specified to charge is now set to charge.

                tmp = (selectorState & SELECTOR_STATE_CHARGE_MASK) >> SELECTOR_SHIFT_CHARGE;
                if (SmbBattReverseLogic(SmbBatt->Selector, tmp)) {
                    tmp ^= SELECTOR_STATE_PRESENT_MASK;
                }

                if (tmp & SmbBatt->SelectorBitPosition) {

                    BattPrint(BAT_IRPS, ("SmbBattSetInformation: successfully set charging battery\n"));

                    //
                    // Success!  Save the new selector state in the cache
                    //

                    SmbBatt->Selector->SelectorState = selectorState;
                    status = STATUS_SUCCESS;

                } else {
                    BattPrint(BAT_ERROR, ("SmbBattSetInformation:  couldn't set charging battery\n"));
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

            case BatteryDischarge:

                BattPrint(BAT_IRPS, ("SmbBattSetInformation: Got SetInformation for BatteryDischarge\n"));

                //
                // Set the appropriate bit in the selector state power by nibble
                //

                newSelectorState = SELECTOR_SET_POWER_BY_MASK;
                newSelectorState |= (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_POWER);

                //
                // Write the new selector state, then read it back.  The system
                // may or may not let us do this.
                //

                smbStatus = SmbBattGenericWW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                newSelectorState
                            );

                if (smbStatus != SMB_STATUS_OK) {
                    BattPrint(BAT_ERROR,
                             ("SmbBattSetInformation:  couldn't write selector state - %x\n",
                             smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                smbStatus = SmbBattGenericRW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                &selectorState
                            );

                if ((smbStatus != SMB_STATUS_OK)) {
                    BattPrint(BAT_ERROR,
                             ("SmbBattSetInformation:  couldn't read selector state - %x\n",
                             smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }


                //
                // Check the status that was read versus what we wrote
                // to see if the operation was successful
                //

                // To support simultaneous powering of more than one battery,
                // we can't check the power nibble to see if it is equal to
                // what we wrote, but we can check to see if the battery
                // we specified to power by is now set to power the system.

                tmp = (selectorState & SELECTOR_STATE_POWER_BY_MASK) >> SELECTOR_SHIFT_POWER;
                if (SmbBattReverseLogic(SmbBatt->Selector, tmp)) {
                    tmp ^= SELECTOR_STATE_PRESENT_MASK;
                }

                if (tmp & SmbBatt->SelectorBitPosition) {

                    BattPrint(BAT_IRPS, ("SmbBattSetInformation: successfully set powering battery\n"));

                    //
                    // Success!  Save the new selector state in the cache
                    //

                    SmbBatt->Selector->SelectorState = selectorState;
                    status = STATUS_SUCCESS;

                } else {
                    BattPrint(BAT_ERROR, ("SmbBattSetInformation:  couldn't set powering battery\n"));
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

        }   // switch (Level)

        //
        // Release the lock on the selector
        //

        SmbBattUnlockSelector (SmbBatt->Selector);

    }   // if (SmbBatt->Selector->SelectorPresent)

    BattPrint(BAT_TRACE, ("SmbBattSetInformation: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattGetPowerState (
    IN PSMB_BATT        SmbBatt,
    OUT PULONG          PowerState,
    OUT PLONG           Current
    )
/*++

Routine Description:

    Returns the current state of AC power.  There are several cases which
    make this far more complex than it really ought to be.

    NOTE: the selector must be locked before entering this routine.

Arguments:

    SmbBatt         - Miniport context value for battery

    AcConnected     - Pointer to a boolean where the AC status is returned

Return Value:

    NTSTATUS

--*/
{
    ULONG               tmp;
    ULONG               chargeBattery;
    ULONG               powerBattery;
    NTSTATUS            status;
    UCHAR               smbStatus;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    *PowerState = 0;

    //
    // Is there a selector in the system?  if not, go read directly from the charger
    //

    if ((SmbBatt->SelectorPresent) && (SmbBatt->Selector)) {

        //
        // There is a selector, we will examine the CHARGE nibble of the state register
        //

        SmbBattGenericRW(
                SmbBatt->SmbHcFdo,
                SMB_SELECTOR_ADDRESS,
                SELECTOR_SELECTOR_STATE,
                &SmbBatt->Selector->SelectorState);

        chargeBattery  = (SmbBatt->Selector->SelectorState & SELECTOR_STATE_CHARGE_MASK) >> SELECTOR_SHIFT_CHARGE;
        powerBattery  = (SmbBatt->Selector->SelectorState & SELECTOR_STATE_POWER_BY_MASK) >> SELECTOR_SHIFT_POWER;


        //
        // If the bits in the CHARGE_X nibble of the selector state register are in the
        // reverse logic state, then AC is connected, otherwise AC is not connected.
        //
        // NOTE: This code depends on every selector implementing this.  If it turns out
        // that this is optional, we can no longer depend on this, and must enable the
        // code below it.
        //

        if (SmbBattReverseLogic(SmbBatt->Selector, chargeBattery)) {
            *PowerState |= BATTERY_POWER_ON_LINE;
        }

        //
        // Look at Charge Indicator if it is supported
        //

        if (*PowerState & BATTERY_POWER_ON_LINE) {

            if (SmbBatt->Selector->SelectorInfo & SELECTOR_INFO_CHARGING_INDICATOR_BIT) {
                if (SmbBattReverseLogic(SmbBatt->Selector, powerBattery)) {
                    *PowerState |= BATTERY_CHARGING;
                }
            }

            if (*Current > 0) {
                *PowerState |= BATTERY_CHARGING;

            }

        } else {

            if (*Current <= 0) {

                //
                // There is some small leakage on some systems, even when AC
                // is present.  So, if AC is present, and the draw
                // is below this "noise" level we will not report as discharging
                // and zero this out.
                //

                if (*Current < -25) {
                    *PowerState |= BATTERY_DISCHARGING;

                } else {
                    *Current = 0;

                }
            }

            //else {
            //    *PowerState |= BATTERY_CHARGING;
            //
            //}

            // If we don't report as discharging, then the AC adapter removal
            // might cause a PowerState of 0 to return, which PowerMeter assumes
            // means, don't change anything

            *PowerState |= BATTERY_DISCHARGING;

        }

    } else {

        //
        // There is no selector, so we'll try to read from the charger.
        //

        smbStatus = SmbBattGenericRW (
                        SmbBatt->SmbHcFdo,
                        SMB_CHARGER_ADDRESS,
                        CHARGER_STATUS,
                        &tmp
                    );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (
                BAT_ERROR,
                ("SmbBattGetPowerState: Trying to get charging info, couldn't read from charger at %x, status %x\n",
                SMB_CHARGER_ADDRESS,
                smbStatus)
            );

            *PowerState = 0;

            status = STATUS_UNSUCCESSFUL;
        }

        // Read Charger Successful

        else {

            if (tmp & CHARGER_STATUS_AC_PRESENT_BIT) {
                *PowerState = BATTERY_POWER_ON_LINE;

                if (*Current > 0) {
                    *PowerState |= BATTERY_CHARGING;
                }


            } else {

                if (*Current <= 0) {

                    //
                    // There is some small leakage on some systems, even when AC
                    // is present.  So, if AC is present, and the draw
                    // is below this "noise" level we will not report as discharging
                    // and zero this out.
                    //

                    if (*Current < -25) {
                        *PowerState |= BATTERY_DISCHARGING;
                    } else {
                        *Current = 0;
                    }
                }

                // If we don't report as discharging, then the AC adapter removal
                // might cause a PowerState of 0 to return, which PowerMeter assumes
                // means, don't change anything
                *PowerState |= BATTERY_DISCHARGING;

            }
        }
    }

    return status;
}



NTSTATUS
SmbBattQueryStatus (
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status

    N.B. the battery class driver will serialize all requests it issues to
    the miniport for a given battery.  However, this miniport implements
    a lock on the battery device as it needs to serialize to the smb
    battery selector device as well.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PSMB_BATT           SmbBatt;
    NTSTATUS            status;
    BOOLEAN             IoCheck;
    LONG                Current;
    ULONG               oldSelectorState;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattQueryStatus: ENTERING\n"));


    if (BatteryTag == BATTERY_TAG_INVALID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    status = STATUS_SUCCESS;

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;
    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattQueryStatus: can't set selector communications path\n"));
    } else {

        do {
            if (BatteryTag != SmbBatt->Info.Tag) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            SmbBattRW(SmbBatt, BAT_VOLTAGE, &BatteryStatus->Voltage);
            BatteryStatus->Voltage *= SmbBatt->Info.VoltageScale;

            SmbBattRW(SmbBatt, BAT_REMAINING_CAPACITY, &BatteryStatus->Capacity);
            BatteryStatus->Capacity *= SmbBatt->Info.PowerScale;

            SmbBattRSW(SmbBatt, BAT_CURRENT, &Current);
            Current *= SmbBatt->Info.CurrentScale;

            BattPrint(BAT_DATA,
                ("SmbBattQueryStatus: (%01x)\n"
                "-------  Remaining Capacity - %x\n"
                "-------  Voltage            - %x\n"
                "-------  Current            - %x\n",
                SmbBatt->SelectorBitPosition,
                BatteryStatus->Capacity,
                BatteryStatus->Voltage,
                Current)
            );

            BatteryStatus->Rate = (Current * ((LONG)BatteryStatus->Voltage))/1000;

            //
            // Check to see if we are currently connected to AC.
            //

            status = SmbBattGetPowerState (SmbBatt, &BatteryStatus->PowerState, &Current);
            if (!NT_SUCCESS (status)) {

                BatteryStatus->PowerState = 0;
            }

            //
            // Re-verify static info in case there's been an IO error
            //

            IoCheck = SmbBattVerifyStaticInfo (SmbBatt, BatteryTag);

        } while (IoCheck);

    }


    if (NT_SUCCESS (status)) {
        //
        // Set batteries current power state & capacity
        //

        SmbBatt->Info.PowerState = BatteryStatus->PowerState;
        SmbBatt->Info.Capacity = BatteryStatus->Capacity;

        //
        // Done, unlock the device and reset the selector state
        //

        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattQueryStatus: can't reset selector communications path\n"));
        }
    } else {
        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }

    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattQueryStatus: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattSetStatusNotify (
    IN PVOID            Context,
    IN ULONG            BatteryTag,
    IN PBATTERY_NOTIFY  Notify
    )
/*++

Routine Description:

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.

    The class driver will always set the notification level it needs
    after each call to BatteryClassStatusNotify.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    PSMB_BATT           SmbBatt;
    NTSTATUS            status;
    BOOLEAN             UpdateAlarm;
    ULONG               Target, NewAlarm;
    LONG                DeltaAdjustment, Attempt, i;
    ULONG               oldSelectorState;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattSetStatusNotify: ENTERING\n"));

    if (BatteryTag == BATTERY_TAG_INVALID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((Notify->HighCapacity == BATTERY_UNKNOWN_CAPACITY) ||
        (Notify->LowCapacity == BATTERY_UNKNOWN_CAPACITY)) {
        BattPrint(BAT_WARN, ("SmbBattSetStatusNotify: Failing because of BATTERY_UNKNOWN_CAPACITY.\n"));
        return STATUS_NOT_SUPPORTED;
    }

    status = STATUS_SUCCESS;

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;

    BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x): Called with LowCapacity = %08x\n",
            SmbBatt->SelectorBitPosition, Notify->LowCapacity));

    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattSetStatusNotify: can't set selector communications path\n"));

    } else {

        // Target (10*PS*mWh) = Lowcapacity (mWh) / 10*PS (1/(10*PS))
        Target = Notify->LowCapacity / SmbBatt->Info.PowerScale;
        DeltaAdjustment = 0;

        BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x): Last set to: %08x\n",
                SmbBatt->SelectorBitPosition, SmbBatt->AlarmLow.Setting));

        //
        // Some batteries are messed up and won't just take an alarm setting.  Fortunately,
        // the error is off in some linear fashion, so this code attempts to hone in on the
        // adjustment needed to get the proper setting, along with an "allowable fudge value",
        // since sometimes the desired setting can never be obtained.
        //

        for (; ;) {
            if (BatteryTag != SmbBatt->Info.Tag) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            //
            // If the status is charging we can't detect.  Let the OS poll
            //

            if (SmbBatt->Info.PowerState & (BATTERY_CHARGING | BATTERY_POWER_ON_LINE)) {
                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // If the current capacity is below the target, fire an alarm and we're done
            //

            if (SmbBatt->Info.Capacity < Target) {
                BatteryClassStatusNotify (SmbBatt->NP->Class);
                break;
            }

            //
            // If the target setting is the Skip value then there was an error attempting
            // this value last time.
            //

            if (Target == SmbBatt->AlarmLow.Skip) {
                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // If the current setting is above the current capacity then we need to
            // program the alarm
            //

            UpdateAlarm = FALSE;
            if (Target < SmbBatt->AlarmLow.Setting) {
                UpdateAlarm = TRUE;
            }

            //
            // If the target alarm is above the current setting, and the current setting
            // is off by more then AllowedFudge then it needs updated
            //

            if (Target > SmbBatt->AlarmLow.Setting &&
                Target - SmbBatt->AlarmLow.Setting > (ULONG) SmbBatt->AlarmLow.AllowedFudge) {

                UpdateAlarm = TRUE;
            }

            //
            // If alarm doesn't need updated, done
            //

            if (!UpdateAlarm) {
                BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x) NOT Updating Alarm.\n", SmbBatt->SelectorBitPosition));
                break;
            }
            BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x) Updating Alarm.\n", SmbBatt->SelectorBitPosition));

            //
            // If this is not the first time, then delta is not good enough.  Let's start
            // adjusting it
            //

            if (DeltaAdjustment) {

                //
                // If delta is positive subtract off 1/2 of fudge
                //

                if (DeltaAdjustment > 0) {
                    DeltaAdjustment -= SmbBatt->AlarmLow.AllowedFudge / 2 + (SmbBatt->AlarmLow.AllowedFudge & 1);
                    // too much - don't handle it
                    if (DeltaAdjustment > 50) {
                        status = STATUS_NOT_SUPPORTED;
                        break;
                    }
                } else {
                    // too much - don't handle it
                    if (DeltaAdjustment < -50) {
                        status = STATUS_NOT_SUPPORTED;
                        break;
                    }
                }

                SmbBatt->AlarmLow.Delta += DeltaAdjustment;
            }

            //
            // If attempt is less then 1, then we can't set it
            //

            Attempt = Target + SmbBatt->AlarmLow.Delta;
            if (Attempt < 1) {
                // battery class driver needs to poll for it
                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Perform IOs to update & read back the alarm.  Use VerifyStaticInfo after
            // IOs in case there's an IO error and the state is lost.
            //

            SmbBattWW(SmbBatt, BAT_REMAINING_CAPACITY_ALARM, Attempt);

            // verify in case there was an IO error

            //if (SmbBattVerifyStaticInfo (SmbBatt, BatteryTag)) {
            //  DeltaAdjustment = 0;
            //  continue;
            //}

            SmbBattRW(SmbBatt, BAT_REMAINING_CAPACITY_ALARM, &NewAlarm);

            // verify in case there was an IO error

            //if (SmbBattVerifyStaticInfo (SmbBatt, BatteryTag)) {
            //  DeltaAdjustment = 0;
            //  continue;
            //}

            BattPrint(BAT_DATA,
                ("SmbBattSetStatusNotify: (%01x) Want %X, Had %X, Got %X, CurrentCap %X, Delta %d, Fudge %d\n",
                SmbBatt->SelectorBitPosition,
                Target,
                SmbBatt->AlarmLow.Setting,
                NewAlarm,
                SmbBatt->Info.Capacity / SmbBatt->Info.PowerScale,
                SmbBatt->AlarmLow.Delta,
                SmbBatt->AlarmLow.AllowedFudge
            ));

            //
            // If DeltaAdjustment was applied to Delta but the setting
            // moved by more then DeltaAdjustment, then increase the
            // allowed fudge.
            //

            if (DeltaAdjustment) {
                i = NewAlarm - SmbBatt->AlarmLow.Setting - DeltaAdjustment;
                if (DeltaAdjustment < 0) {
                    DeltaAdjustment = -DeltaAdjustment;
                    i = -i;
                }
                if (i > SmbBatt->AlarmLow.AllowedFudge) {
                    SmbBatt->AlarmLow.AllowedFudge = i;
                    BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: Fudge increased to %x\n", SmbBatt->AlarmLow.AllowedFudge));
                }
            }

            //
            // Current setting
            //

            SmbBatt->AlarmLow.Setting = NewAlarm;

            //
            // Compute next delta adjustment
            //

            DeltaAdjustment = Target - SmbBatt->AlarmLow.Setting;
        }

        //
        // If there was an attempt to set the alarm but it failed, set the
        // skip value so we don't keep trying to set an alarm for this value
        // which isn't working
        //

        if (!NT_SUCCESS(status)  &&  DeltaAdjustment) {
            SmbBatt->AlarmLow.Skip = Target;
        }
    }

    //
    // Done, unlock the device and reset the selector state
    //

    if (NT_SUCCESS (status)) {
        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattSetStatusNotify: can't reset selector communications path\n"));
        }
    } else {
        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }

    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);


    BattPrint(BAT_TRACE, ("SmbBattSetStatusNotify: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to SmbBattSetStatusNotify.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    NTSTATUS    status;
    PSMB_BATT   SmbBatt;
    ULONG       oldSelectorState;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattDisableStatusNotify: ENTERING\n"));

    SmbBatt = (PSMB_BATT) Context;

    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattDisableStatusNotify: can't set selector communications path\n"));

    } else {

        SmbBatt->AlarmLow.Setting = 0;
        SmbBattWW(SmbBatt, BAT_REMAINING_CAPACITY_ALARM, 0);

        //
        // Done, reset the selector state.
        //
        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattDisableStatusNotify: can't reset selector communications path\n"));
        }
    }

    //
    // Done, unlock the device
    //


    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattDisableStatusNotify: EXITING\n"));
    return STATUS_SUCCESS;
}



BOOLEAN
SmbBattVerifyStaticInfo (
    IN PSMB_BATT        SmbBatt,
    IN ULONG            BatteryTag
    )
/*++

Routine Description:

    Reads any non-valid cached battery info and set Info.Valid accordingly.
    Performs a serial number check after reading in battery info in order
    to detect verify the data is from the same battery.  If the value does
    not match what is expect, the cached info is reset and the function
    iterates until a consistent snapshot is obtained.

Arguments:

    SmbBatt         - Battery to read

    BatteryTag      - Tag of battery as expected by the caller

Return Value:

    Returns a boolean to indicate to the caller that IO was performed.
    This allows the caller to iterate on changes it may be making until
    the battery state is correct.

--*/
{
    ULONG               BatteryMode;
    ULONG               ManufacturerDate;
    UCHAR               Buffer[SMB_MAX_DATA_SIZE];
    UCHAR               BufferLength;
    BOOLEAN             IoCheck;
    STATIC_BAT_INFO     NewInfo;
    ULONG               tmp;

    BattPrint(BAT_TRACE, ("SmbBattVerifyStaticInfo: ENTERING\n"));

    IoCheck = FALSE;

    //
    // Loop until state doesn't change
    //

    do {

        //
        // If device name and serial # not known, get them.
        //

        if (!(SmbBatt->Info.Valid & VALID_TAG_DATA)) {

            IoCheck = TRUE;
            SmbBatt->Info.Valid |= VALID_TAG_DATA;

            RtlZeroMemory (&NewInfo, sizeof(NewInfo));
            SmbBattRW(SmbBatt, BAT_SERIAL_NUMBER, &NewInfo.SerialNumber);
            BattPrint(BAT_DATA,
                ("SmbBattVerifyStaticInfo: serial number = %x\n",
                NewInfo.SerialNumber)
            );

            //
            // If SerialNumber was read without a problem, read the rest
            //

            if (SmbBatt->Info.Valid & VALID_TAG_DATA) {


                BattPrint(BAT_IRPS, ("SmbBattVerifyStaticInfo: reading manufacturer name\n"));
                SmbBattRB (
                    SmbBatt,
                    BAT_MANUFACTURER_NAME,
                    NewInfo.ManufacturerName,
                    &NewInfo.ManufacturerNameLength
                );

                BattPrint(BAT_IRPS, ("SmbBattVerifyStaticInfo: reading device name\n"));
                SmbBattRB (
                    SmbBatt,
                    BAT_DEVICE_NAME,
                    NewInfo.DeviceName,
                    &NewInfo.DeviceNameLength
                );

                //
                // See if battery ID has changed
                //

                if (SmbBatt->Info.SerialNumber != NewInfo.SerialNumber ||
                    SmbBatt->Info.ManufacturerNameLength != NewInfo.ManufacturerNameLength ||
                    memcmp (SmbBatt->Info.ManufacturerName, NewInfo.ManufacturerName, NewInfo.ManufacturerNameLength) ||
                    SmbBatt->Info.DeviceNameLength != NewInfo.DeviceNameLength ||
                    memcmp (SmbBatt->Info.DeviceName, NewInfo.DeviceName, NewInfo.DeviceNameLength)) {

                    //
                    // This is a new battery, reread all information
                    //

                    SmbBatt->Info.Valid = VALID_TAG_DATA;

                    //
                    // Pickup ID info
                    //

                    SmbBatt->Info.SerialNumber = NewInfo.SerialNumber;
                    SmbBatt->Info.ManufacturerNameLength = NewInfo.ManufacturerNameLength;
                    memcpy (SmbBatt->Info.ManufacturerName, NewInfo.ManufacturerName, NewInfo.ManufacturerNameLength);
                    SmbBatt->Info.DeviceNameLength = NewInfo.DeviceNameLength;
                    memcpy (SmbBatt->Info.DeviceName, NewInfo.DeviceName, NewInfo.DeviceNameLength);
                }
            } else {

                //
                // No battery, set cached info for no battery
                //

                SmbBatt->Info.Valid = VALID_TAG | VALID_TAG_DATA;
                SmbBatt->Info.Tag   = BATTERY_TAG_INVALID;
            }
        }

        //
        // If the battery tag is valid, and it's NO_BATTERY there is no other
        // cached info to read
        //

        if (SmbBatt->Info.Valid & VALID_TAG  &&  SmbBatt->Info.Tag == BATTERY_TAG_INVALID) {
            break;
        }

        //
        // If the mode has not been verified, do it now
        //

        if (!(SmbBatt->Info.Valid & VALID_MODE)) {

            SmbBatt->Info.Valid |= VALID_MODE;
            SmbBattRW(SmbBatt, BAT_BATTERY_MODE, &BatteryMode);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo:(%01x) Was set to report in %s (BatteryMode = %04x)\n",
                    SmbBatt->SelectorBitPosition,
                    (BatteryMode & CAPACITY_WATTS_MODE)? "10mWH" : "mAH", BatteryMode));

            if (!(BatteryMode & CAPACITY_WATTS_MODE)) {

                //
                // Battery not in watts mode, clear valid_mode bit and
                // set the battery into watts mode now
                //

                BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo:(%01x) Setting battery to report in 10mWh\n",
                            SmbBatt->SelectorBitPosition));

                SmbBatt->Info.Valid &= ~VALID_MODE;
                BatteryMode |= CAPACITY_WATTS_MODE;
                SmbBattWW(SmbBatt, BAT_BATTERY_MODE, BatteryMode);
                continue;       // re-read mode
            }
        }

        //
        // If other static manufacturer info not known, get it
        //

        if (!(SmbBatt->Info.Valid & VALID_OTHER)) {
            IoCheck = TRUE;
            SmbBatt->Info.Valid |= VALID_OTHER;

            SmbBatt->Info.Info.Capabilities = (BATTERY_SYSTEM_BATTERY |
                                    BATTERY_SET_CHARGE_SUPPORTED |
                                    BATTERY_SET_DISCHARGE_SUPPORTED);
            SmbBatt->Info.Info.Technology = 1;  // secondary cell type

            // Read chemistry
            SmbBattRB (SmbBatt, BAT_CHEMISTRY, Buffer, &BufferLength);
            if (BufferLength > MAX_CHEMISTRY_LENGTH) {
                ASSERT (BufferLength > MAX_CHEMISTRY_LENGTH);
                BufferLength = MAX_CHEMISTRY_LENGTH;
            }
            RtlZeroMemory (SmbBatt->Info.Info.Chemistry, MAX_CHEMISTRY_LENGTH);
            memcpy (SmbBatt->Info.Info.Chemistry, Buffer, BufferLength);

            //
            // Voltage and Current scaling information
            //

            SmbBattRW (SmbBatt, BAT_SPECITICATION_INFO, &tmp);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo: (%04x) specification info = %x\n",
                            SmbBatt->SelectorBitPosition, tmp));

            switch ((tmp & BATTERY_VSCALE_MASK) >> BATTERY_VSCALE_SHIFT) {

                case 1:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_1;
                    break;

                case 2:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_2;
                    break;

                case 3:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_3;
                    break;

                case 0:
                default:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_0;
                    break;
            }

            switch ((tmp & BATTERY_IPSCALE_MASK) >> BATTERY_IPSCALE_SHIFT) {
                case 1:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_1;
                    break;

                case 2:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_2;
                    break;

                case 3:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_3;
                    break;

                case 0:
                default:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_0;
                    break;
            }

            SmbBatt->Info.PowerScale = SmbBatt->Info.CurrentScale * SmbBatt->Info.VoltageScale * 10;

            //
            // Read DesignCapacity & FullChargeCapacity and multiply them by the
            // scaling factor
            //

            SmbBattRW(SmbBatt, BAT_DESIGN_CAPACITY, &SmbBatt->Info.Info.DesignedCapacity);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo: (%01x) DesignCapacity = %04x ... PowerScale = %08x\n",
                        SmbBatt->SelectorBitPosition, SmbBatt->Info.Info.DesignedCapacity, SmbBatt->Info.PowerScale));
            SmbBatt->Info.Info.DesignedCapacity *= SmbBatt->Info.PowerScale;

            SmbBattRW(SmbBatt, BAT_FULL_CHARGE_CAPACITY, &SmbBatt->Info.Info.FullChargedCapacity);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo: (%01x) FullChargedCapacity = %04x ... PowerScale = %08x\n",
                        SmbBatt->SelectorBitPosition, SmbBatt->Info.Info.FullChargedCapacity, SmbBatt->Info.PowerScale));
            SmbBatt->Info.Info.FullChargedCapacity *= SmbBatt->Info.PowerScale;


            //
            // Smart batteries have no Use the RemainingCapacityAlarm from the smart battery for the alert values
            //

            SmbBatt->Info.Info.DefaultAlert1 = 0;
            SmbBatt->Info.Info.DefaultAlert2 = 0;

            // Critical bias is 0 for smart batteries.
            SmbBatt->Info.Info.CriticalBias = 0;

            // Manufacturer date
            SmbBattRW (SmbBatt, BAT_MANUFACTURER_DATE, &ManufacturerDate);
            SmbBatt->Info.ManufacturerDate.Day      = (UCHAR) ManufacturerDate & 0x1f;        // day
            SmbBatt->Info.ManufacturerDate.Month    = (UCHAR) (ManufacturerDate >> 5) & 0xf;  // month
            SmbBatt->Info.ManufacturerDate.Year     = (USHORT) (ManufacturerDate >> 9) + 1980;
        }

        //
        // If cycle count is not known, read it
        //

        if (!(SmbBatt->Info.Valid & VALID_CYCLE_COUNT)) {
            IoCheck = TRUE;
            SmbBatt->Info.Valid |= VALID_CYCLE_COUNT;

            SmbBattRW(SmbBatt, BAT_CYCLE_COUNT, &SmbBatt->Info.Info.CycleCount);
        }

        //
        // If redundant serial # read hasn't been done, do it now
        //

        if (!(SmbBatt->Info.Valid & VALID_SANITY_CHECK)) {
            SmbBatt->Info.Valid |= VALID_SANITY_CHECK;
            SmbBattRW(SmbBatt, BAT_SERIAL_NUMBER, &NewInfo.SerialNumber);
            if (SmbBatt->Info.SerialNumber != NewInfo.SerialNumber) {
                SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
            }
        }

        //
        // If cached info isn't complete, loop
        //

    } while ((SmbBatt->Info.Valid & VALID_ALL) != VALID_ALL) ;

    //
    // If the tag isn't assigned, assign it
    //

    if (!(SmbBatt->Info.Valid & VALID_TAG)) {
        SmbBatt->TagCount += 1;
        SmbBatt->Info.Tag  = SmbBatt->TagCount;
        SmbBatt->Info.Valid |= VALID_TAG;
        SmbBatt->AlarmLow.Setting = 0;      // assume not set
        SmbBatt->AlarmLow.Skip = 0;
        SmbBatt->AlarmLow.Delta = 0;
        SmbBatt->AlarmLow.AllowedFudge = 0;
    }

    //
    // If callers BatteryTag does not match current tag, let caller know
    //

    if (SmbBatt->Info.Tag != BatteryTag) {
        IoCheck = TRUE;
    }

    //
    // Let caller know if there's been an IoCheck
    //

    BattPrint(BAT_TRACE, ("SmbBattVerifyStaticInfo: EXITING\n"));
    return IoCheck;
}



VOID
SmbBattInvalidateTag (
    PSMB_BATT_SUBSYSTEM SubsystemExt,
    ULONG BatteryIndex,
    BOOLEAN NotifyClient
)
/*++

Routine Description:

    This routine processes battery insertion/removal by invalidating the
    tag information and then notifies the client of the change.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    BatteryIndex            - Index of Battery to Process Changes for
                - Power and Charge

    NotifyClient             - Whether or not to Notify Client

Return Value:

    None
--*/

{
    PDEVICE_OBJECT      batteryPdo;
    PSMB_BATT_PDO       batteryPdoExt;
    PDEVICE_OBJECT      batteryFdo;
    PSMB_NP_BATT        smbNpBatt;
    PSMB_BATT           smbBatt;

    BattPrint(BAT_TRACE, ("SmbBattInvalidateTag: ENTERING for battery %x\n", BatteryIndex));

    batteryPdo = SubsystemExt->BatteryPdoList[BatteryIndex];

    if (batteryPdo) {
        batteryPdoExt   = (PSMB_BATT_PDO) batteryPdo->DeviceExtension;
        batteryFdo      = batteryPdoExt->Fdo;

        if (batteryFdo) {

            //
            // Invalidate this battery's tag data
            //

            BattPrint (
                BAT_ALARM,
                ("SmbBattInvalidateTag: Battery present status change, invalidating battery %x\n",
                BatteryIndex)
            );

            smbNpBatt   = (PSMB_NP_BATT) batteryFdo->DeviceExtension;
            smbBatt     = smbNpBatt->Batt;

            SmbBattLockDevice (smbBatt);

            smbBatt->Info.Valid = 0;
            smbBatt->Info.Tag   = BATTERY_TAG_INVALID;

            SmbBattUnlockDevice (smbBatt);

            //
            // Notify the class driver
            //

            if (NotifyClient) {
                BattPrint(BAT_ALARM, ("SmbBattInvalidateTag: Status Change notification for battery %x\n", BatteryIndex));
                SmbBattNotifyClassDriver (SubsystemExt, BatteryIndex);
            }
        }
    }

    BattPrint(BAT_TRACE, ("SmbBattInvalidateTag: EXITING\n"));
}



VOID
SmbBattAlarm (
    IN PVOID    Context,
    IN UCHAR    Address,
    IN USHORT   Data
    )
{
    PSMB_ALARM_ENTRY        newAlarmEntry;
    ULONG                   compState;

    PSMB_BATT_SUBSYSTEM     subsystemExt    = (PSMB_BATT_SUBSYSTEM) Context;

    BattPrint(BAT_TRACE, ("SmbBattAlarm: ENTERING\n"));
    BattPrint(BAT_DATA, ("SmbBattAlarm: Alarm - Address %x, Data %x\n", Address, Data));

    // If we have a selector and the message is from the address that
    // implements the selector, then handle it.  If there is no selector
    // and the message is from the charger, then process it. Or, if the
    // message is from the battery, then process it.  Or, in other words,
    // if the message is from the charger and we have a stand-alone selector,
    // then ignore the message.

    if (Address != SMB_BATTERY_ADDRESS) {
        if ((subsystemExt->SelectorPresent) && (subsystemExt->Selector)) {

            // If a Selector is implemented and the Alarm Message came from
            // something besides the Selector or a Battery, then ignore it.

            if (Address != subsystemExt->Selector->SelectorAddress) {
                return;
            }
        }
    }

    //
    // Allocate a new alarm list structure.  This has to be from non-paged pool
    // because we are being called at Dispatch level.
    //

    newAlarmEntry = ExAllocatePoolWithTag (NonPagedPool, sizeof (SMB_ALARM_ENTRY), 'StaB');
    if (!newAlarmEntry) {
        BattPrint (BAT_ERROR, ("SmbBattAlarm:  couldn't allocate alarm structure\n"));
        return;
    }

    newAlarmEntry->Data     = Data;
    newAlarmEntry->Address  = Address;

    //
    // Add this alarm to the alarm queue
    //

    ExInterlockedInsertTailList(
        &subsystemExt->AlarmList,
        &newAlarmEntry->Alarms,
        &subsystemExt->AlarmListLock
    );

    //
    // Add 1 to the WorkerActive value, if this is the first count
    // queue a worker thread
    //

    if (InterlockedIncrement(&subsystemExt->WorkerActive) == 1) {
        IoQueueWorkItem (subsystemExt->WorkerThread, SmbBattWorkerThread, DelayedWorkQueue, subsystemExt);
    }

    BattPrint(BAT_TRACE, ("SmbBattAlarm: EXITING\n"));
}



VOID
SmbBattWorkerThread (
    IN PDEVICE_OBJECT   Fdo,
    IN PVOID            Context
    )
/*++

Routine Description:

    This routine handles the alarms for the batteries.

Arguments:

    Context         - Non-paged extension for the battery subsystem FDO

Return Value:

    None
--*/
{
    PSMB_ALARM_ENTRY        alarmEntry;
    PLIST_ENTRY             nextEntry;
    ULONG                   selectorState;
    ULONG                   batteryIndex;

    BOOLEAN                 charging = FALSE;
    BOOLEAN                 acOn = FALSE;

    PSMB_BATT_SUBSYSTEM     subsystemExt = (PSMB_BATT_SUBSYSTEM) Context;


    BattPrint(BAT_TRACE, ("SmbBattWorkerThread: ENTERING\n"));

    do {

        //
        // Check to see if we have more alarms to process.  If so retrieve
        // the next one and decrement the worker active count.
        //

        nextEntry = ExInterlockedRemoveHeadList(
                        &subsystemExt->AlarmList,
                        &subsystemExt->AlarmListLock
                    );

        //
        //It should only get here if there is an entry in the list
        //
        ASSERT (nextEntry != NULL);

        alarmEntry = CONTAINING_RECORD (nextEntry, SMB_ALARM_ENTRY, Alarms);

        BattPrint(
            BAT_ALARM,
            ("SmbBattWorkerThread: processing alarm, address = %x, data = %x\n",
            alarmEntry->Address,
            alarmEntry->Data)
        );

        //
        // Get last Selector State Cached Value (update cache with new value)
        //

        if (subsystemExt->SelectorPresent) {
            if (subsystemExt->Selector) {
                selectorState = subsystemExt->Selector->SelectorState;
            } else {
                // We're not initialized enough to handle a message
                break;
            }
        }

        // Determine Source of Alarm Message and then Process it

        switch (alarmEntry->Address) {

            case SMB_CHARGER_ADDRESS:

                //
                // Handle Charger Message - If Charger/Selector Combo, then
                // fall through and handle it as a Selector.  If no Selector,
                // then attempt processing as a Charger. Ignore Charger messages
                // if Selector is present.
                //

                if (!subsystemExt->SelectorPresent) {

                    SmbBattProcessChargerAlarm (subsystemExt, alarmEntry->Data);
                    break;

                } else {

                    // If SelectorPresent, but no Selector Structure, Ignore message
                    if (!subsystemExt->Selector) {
                        break;
                    } else {
                        if (subsystemExt->Selector->SelectorAddress != SMB_CHARGER_ADDRESS) {

                            break;
                        }
                    }
                }


                //
                // Fall through to Selector Procesing for integrated Charger/Selector
                //

            case SMB_SELECTOR_ADDRESS:

                if (!subsystemExt->SelectorPresent) {
                    BattPrint (
                        BAT_BIOS_ERROR,
                        ("SmbBattProcessSelectorAlarm: Received alarm from selector address, but BIOS reports no selector is present.\n")
                    );
                    break;
                }

                //
                // This is a selector alarm indicating a change in the selector state.
                // There are four different areas that could change: SMB, POWER_BY,
                // CHARGE, PRESENT. First try to determine which ones changed.
                //

                SmbBattLockSelector (subsystemExt->Selector);
                BattPrint (
                    BAT_DATA,
                    ("SmbBattProcessSelectorAlarm: New SelectorState being written as - %x\n",
                    alarmEntry->Data)
                );
                subsystemExt->Selector->SelectorState = alarmEntry->Data;
                SmbBattUnlockSelector (subsystemExt->Selector);

                SmbBattProcessSelectorAlarm (subsystemExt, selectorState, alarmEntry->Data);
                break;

            case SMB_BATTERY_ADDRESS:

                //
                // Send notifications to all batteries.
                // It seems we get notifications even for batteries not currently selected.
                //

                for (batteryIndex = 0; batteryIndex < subsystemExt->NumberOfBatteries; batteryIndex++) {
                    BattPrint(BAT_ALARM, ("SmbBattWorkerThread: Notification to battery %x\n", batteryIndex));
                    SmbBattNotifyClassDriver (subsystemExt, batteryIndex);
                }
                break;

        } //  switch (alarmEntry->Address)

        //
        // Free the alarm structure
        //

        ExFreePool (alarmEntry);

    } while (InterlockedDecrement (&subsystemExt->WorkerActive) != 0);

    BattPrint(BAT_TRACE, ("SmbBattWorkerThread: EXITING\n"));
}



VOID
SmbBattProcessSelectorAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OldSelectorState,
    IN ULONG                NewSelectorState
    )
/*++

Routine Description:

    This routine process alarms generated by the selector.  We will only get
    here is there is a change in the SelectorState for one or more of the
    following state changes:

    - PowerBy nibble change caused by the power source changing to a different
      battery or to AC adapter.

    - PowerBy nbble change caused by optional Charge Indicator state change
      when the charger starts or stops charging a battery.

    - ChargeWhich nibble change caused by a change in the current battery
      connected to the Charger.

    - ChargeWhich nibble change caused by AC adapter insertion/removal.

    - BatteryPresent nibble change caused by insertion/removal of 1 or more batteries.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    NewSelectorState        - Data value sent by the selector alarm, which is
                              New SelectorState.

Return Value:

    None
--*/
{
    ULONG   tmp;
    ULONG   BatteryMask;
    ULONG   NotifyMask;
    ULONG   ChangeSelector;
    ULONG   index;

    BattPrint(BAT_TRACE, ("SmbBattProcessSelectorAlarm: ENTERING\n"));

    //
    // Determine SelectorState changes and combine them together
    //

    ChangeSelector = NewSelectorState ^ OldSelectorState;

    if (!(ChangeSelector & ~SELECTOR_STATE_SMB_MASK)) {
        //
        // If the only change is in SMB nibble, no nothing.
        //
        return;
    }

    //
    // Check for change to Batteries Present nibble. Invalidate and Notify
    // each battery that changes state.
    //
    BatteryMask = ChangeSelector & SELECTOR_STATE_PRESENT_MASK;
    NotifyMask = BatteryMask;

    //
    // Check for change to Charge Which nibble. If all bits set, then the nibble
    // just inverted state indicating an AC adapter Insertion/Removal.  Notify
    // all batteries of change.  If only one or two bits changed, notify just
    // the batteries that changed status.
    //

    tmp = (ChangeSelector >> SELECTOR_SHIFT_CHARGE) & SELECTOR_STATE_PRESENT_MASK;
    if (tmp) {

        // If nibble inverted state, then the AC Adapter changed state

        if (tmp == SELECTOR_STATE_PRESENT_MASK) {

            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: AC Adapter was inserted/removed\n"));
            NotifyMask |= tmp;

        // Battery Charge Which changed

        } else {
            //if (SmbBattReverseLogic(SubsystemExt->Selector, tmp)) {
            //    tmp ^= SELECTOR_STATE_PRESENT_MASK;
            //}

            // Let's just notify all batteries to be safe

            tmp = SELECTOR_STATE_PRESENT_MASK;
            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Charger Nibble changed status\n"));
            NotifyMask |= tmp;
        }
    }

    //
    // Check for change in Power By nibble. Notify all batteries of any change.
    //

    tmp = (ChangeSelector >> SELECTOR_SHIFT_POWER) & SELECTOR_STATE_PRESENT_MASK;
    if (tmp) {

        // If nibble inverted state, then the check for Charge Indicator change
        // and notify the battery that started/stopped charging

        if (tmp == SELECTOR_STATE_PRESENT_MASK) {
            if (SubsystemExt->Selector->SelectorInfo & SELECTOR_INFO_CHARGING_INDICATOR_BIT) {
                tmp = (NewSelectorState >> SELECTOR_SHIFT_CHARGE) & SELECTOR_STATE_PRESENT_MASK;
                if (SmbBattReverseLogic(SubsystemExt->Selector, tmp)) {
                    tmp ^= SELECTOR_STATE_PRESENT_MASK;
                }
                BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Charging Indicator changed status\n"));
                NotifyMask |= tmp;
            } else {
                // If not Charging Indicator, then all battery power by nibbles inverted
                BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Power By inverted state, without supporting Charge Indication\n"));
                NotifyMask |= SELECTOR_STATE_PRESENT_MASK;
            }

        } else {

            // Let's notify all batteries if the Power By nibble changes

            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Power By Nibble changed status\n"));
            NotifyMask |= SELECTOR_STATE_PRESENT_MASK;
        }
    }

    //
    // Notify all batteries of change in Present Status
    //

    tmp = BATTERY_A_PRESENT;
    for (index = 0; index < SubsystemExt->NumberOfBatteries; index++) {
        if (BatteryMask & tmp) {
            if (!(NewSelectorState & tmp)) {
                BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Invalidating battery %x\n", index));
                SmbBattInvalidateTag (SubsystemExt, index, FALSE);
            }
        }
        tmp <<= 1;
    }

    // Don't notify batteries already notified
    //NotifyMask &= ~BatteryMask;

    //
    // Process Notifications Now for changes to SelectorState for Power, Charge, etc.
    //

    tmp = BATTERY_A_PRESENT;
    for (index = 0; index < SubsystemExt->NumberOfBatteries; index++) {
        if (NotifyMask & tmp) {
            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Status Change notification for battery %x\n", index));
            SmbBattNotifyClassDriver (SubsystemExt, index);
        }
        tmp <<= 1;
    }

    BattPrint(BAT_TRACE, ("SmbBattProcessSelectorAlarm: EXITING\n"));
}



VOID
SmbBattProcessChargerAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                ChargerStatus
    )
/*++

Routine Description:

    This routine process alarms generated by the charger.  We will only get
    here is there is no selector in the system and the alarm is the one to
    tell us when AC and batteries come and go.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    ChargerStatus           - Data value sent by the charger alarm, which is
                              charger status register

Return Value:

    None
--*/
{
    BattPrint(BAT_TRACE, ("SmbBattProcessChargeAlarm: ENTERING\n"));

    //
    // There should only be two reasons we get called: a change in AC, or
    // a change in the battery present.  We are really only interested in
    // whether or not there is a battery in the system.  If there isn't, we
    // will invalidate battery 0.  If it was already gone this re-invalidation
    // won't matter.
    //

    if (!(ChargerStatus & CHARGER_STATUS_BATTERY_PRESENT_BIT)) {
        SmbBattInvalidateTag (SubsystemExt, BATTERY_A, TRUE);
    }

    // Notify Change

    SmbBattNotifyClassDriver (SubsystemExt, 0);

    BattPrint(BAT_TRACE, ("SmbBattProcessChargerAlarm: EXITING\n"));
}




VOID
SmbBattNotifyClassDriver (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                BatteryIndex
    )
/*++

Routine Description:

    This routine gets the FDO for the battery indicated by index from the
    smart battery subsystem and notifies the class driver there has been
    a status change.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    BatteryIndex            - Index for the battery in the subsystem battery
                              list

Return Value:

    None
--*/
{
    PDEVICE_OBJECT      batteryPdo;
    PSMB_BATT_PDO       batteryPdoExt;
    PDEVICE_OBJECT      batteryFdo;
    PSMB_NP_BATT        smbNpBatt;


    BattPrint(BAT_TRACE, ("SmbBattNotifyClassDriver: ENTERING\n"));

    batteryPdo      = SubsystemExt->BatteryPdoList[BatteryIndex];
    if (batteryPdo) {
        batteryPdoExt   = (PSMB_BATT_PDO) batteryPdo->DeviceExtension;
        batteryFdo      = batteryPdoExt->Fdo;

        if (batteryFdo) {
            BattPrint (
                BAT_IRPS,
                ("SmbBattNotifyClassDriver: Calling BatteryClassNotify for battery - %x\n",
                batteryFdo)
            );

            smbNpBatt = (PSMB_NP_BATT) batteryFdo->DeviceExtension;

            BatteryClassStatusNotify (smbNpBatt->Class);
        }
    } else {
        BattPrint (
            BAT_ERROR,
            ("SmbBattNotifyClassDriver: No PDO for device.\n")
        );
    }

    BattPrint(BAT_TRACE, ("SmbBattNotifyClassDriver: EXITING\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbbatt\smbbattp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    smbbattp.h

Abstract:

    Smart Battery Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:


--*/

#ifndef FAR
#define FAR
#endif

#include <ntddk.h>
#include <wmilib.h>
#include <batclass.h>
#include <acpiioct.h>
#include <smbus.h>

//
// Debugging
//

#define DEBUG   DBG

#if DEBUG
    extern ULONG SMBBattDebug;

    #define BattPrint(l,m)    if(l & SMBBattDebug) DbgPrint m
#else
    #define BattPrint(l,m)
#endif

#define BAT_TRACE       0x00000400
#define BAT_STATE       0x00000200
#define BAT_IRPS        0x00000100

#define BAT_IO          0x00000040
#define BAT_DATA        0x00000020
#define BAT_ALARM       0x00000010

#define BAT_NOTE        0x00000008
#define BAT_WARN        0x00000004
#define BAT_ERROR       0x00000002
#define BAT_BIOS_ERROR  0x00000001


//
// Driver supports the following class driver version
//

#define SMB_BATTERY_MAJOR_VERSION           0x0001
#define SMB_BATTERY_MINOR_VERSION           0x0000

//
// Smart battery device driver tag for memory allocations: "BatS"
//

#define SMB_BATTERY_TAG 'StaB'

//
// Globals
//
extern UNICODE_STRING GlobalRegistryPath;

//
// Remove Lock parameters for checked builds
//

#define REMOVE_LOCK_MAX_LOCKED_MINUTES 1
#define REMOVE_LOCK_HIGH_WATER_MARK 64


//
// Driver Device Names (FDO)
//
#define         BatterySubsystemName    L"\\Device\\SmartBatterySubsystem"
#define         SmbBattDeviceName       L"\\Device\\SmartBattery"

//
// Query ID Names
//

#define         SubSystemIdentifier     L"SMBUS\\SMBBATT"
#define         BatteryInstance         L"Battery"

#define         HidSmartBattery         L"SMBBATT\\SMART_BATTERY"


//
// Structure for input from private Ioctls to read from devices on smbus
//

typedef struct {
    UCHAR       Address;
    UCHAR       Command;
    union {
        USHORT      Block [2];
        ULONG       Ulong;
    } Data;
} SMBBATT_DATA_STRUCT, *PSMBBATT_DATA_STRUCT;

typedef union {
    USHORT Block [2];
    ULONG Ulong;
} _SMBBATT_DATA_STRUCT_UNION;

#define SMBBATT_DATA_STRUCT_SIZE sizeof (SMBBATT_DATA_STRUCT) - sizeof (_SMBBATT_DATA_STRUCT_UNION)

//
// Private Ioctls for test engines
//

#define IOCTL_SMBBATT_DATA      \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x100, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


//
// Definitions for the selector state lookup table
//

typedef struct  {
    UCHAR       BatteryIndex;
    BOOLEAN     ReverseLogic;

} SELECTOR_STATE_LOOKUP;


extern const SELECTOR_STATE_LOOKUP SelectorBits [];
extern const SELECTOR_STATE_LOOKUP SelectorBits4 [];


//
// Definitions for control method names neede by the smart battery
//

#define SMBATT_SBS_METHOD   (ULONG) ('SBS_')    // control method "_SBS"
#define SMBATT_GLK_METHOD   (ULONG) ('KLG_')    // control method "_GLK"


//
// Definitions for some string lengths
//

#define MAX_DEVICE_NAME_LENGTH  100
#define MAX_CHEMISTRY_LENGTH    4


//
// Maximum number of smart batteries supported by this driver
//

#define MAX_SMART_BATTERIES_SUPPORTED   4


//
// Types for the FDOs hnadled by this driver:
//  Smart battery subsystem FDO
//  Smart Battery FDO
//  Smart battery PDO
//

typedef enum {
    SmbTypeSubsystem,
    SmbTypeBattery,
    SmbTypePdo
} SMB_FDO_TYPE;


//
// SMB Host Controller Device object extenstion
//

//
// Cached battery info
//

typedef struct {
    ULONG                       Tag;
    UCHAR                       Valid;
    BATTERY_INFORMATION         Info;
    UCHAR                       ManufacturerNameLength;
    UCHAR                       ManufacturerName[SMB_MAX_DATA_SIZE];
    UCHAR                       DeviceNameLength;
    UCHAR                       DeviceName[SMB_MAX_DATA_SIZE];
    BATTERY_MANUFACTURE_DATE    ManufacturerDate;
    ULONG                       SerialNumber;

    ULONG                       PowerState;
    ULONG                       Capacity;
    ULONG                       VoltageScale;
    ULONG                       CurrentScale;
    ULONG                       PowerScale;
} STATIC_BAT_INFO, *PSTATIC_BAT_INFO;

#define VALID_TAG_DATA      0x01            // manufacturer, device, serial #
#define VALID_MODE          0x02
#define VALID_OTHER         0x04
#define VALID_CYCLE_COUNT   0x08
#define VALID_SANITY_CHECK  0x10
#define VALID_TAG           0x80

#define VALID_ALL           0x1F            // (does not include tag)


//
// Selector information structure
//

typedef struct _BATTERY_SELECTOR {
    //
    // Addressing and command information.  This can change based whether or
    // not the selector is stand alone or part of the charger.
    //

    UCHAR               SelectorAddress;
    UCHAR               SelectorStateCommand;
    UCHAR               SelectorPresetsCommand;
    UCHAR               SelectorInfoCommand;

    //
    // Mutex to keep only one person talking with the selector at a time
    //

    FAST_MUTEX          Mutex;

    //
    // Cached information.  We will get notifications when these change.
    //

    ULONG               SelectorState;
    ULONG               SelectorPresets;
    ULONG               SelectorInfo;
} BATTERY_SELECTOR, *PBATTERY_SELECTOR;



typedef struct {
    ULONG               Setting;
    ULONG               Skip;
    LONG                Delta;
    LONG                AllowedFudge;
} BAT_ALARM_INFO, *PBAT_ALARM_INFO;


typedef struct {
    UCHAR               Address;
    USHORT              Data;
    LIST_ENTRY          Alarms;
} SMB_ALARM_ENTRY, *PSMB_ALARM_ENTRY;


//
// Non-pagable device extension for smart battery FDO
// (Created by IoCreateDevice SMB_NP_BATT for each battery)
//

typedef struct {
    SMB_FDO_TYPE        SmbBattFdoType;     // Device object type
    IO_REMOVE_LOCK      RemoveLock;

    //
    // All elements above this point must be identical in
    // SMB_NP_BATT, SMB_BATT_SUBSYSTEM, and SMB_BATT_PDO structures.
    //

    FAST_MUTEX          Mutex;              // lets either battery OR subsystem
                                            //   have access to batt
    PVOID               Class;              // Battery Class handle
    struct _SMB_BATT    *Batt;              // Battery pageable extension
    PDEVICE_OBJECT      LowerDevice;        // Battery Subsystem PDO
    WMILIB_CONTEXT      WmiLibContext;
} SMB_NP_BATT, *PSMB_NP_BATT;

//
// Pagable device extension for smart battery FDO
// (Allocated Extra Memory for device information)
//

typedef struct _SMB_BATT {

    //
    //
    //

    PSMB_NP_BATT        NP;                 // Battery device object extension
    PDEVICE_OBJECT      DeviceObject;       // Battery Fdo
    PDEVICE_OBJECT      PDO;                // Battery Pdo


    // SMB host controller

    PDEVICE_OBJECT      SmbHcFdo;           // SM bus Fdo

    //
    // Selector
    //

    PBATTERY_SELECTOR   Selector;           // Selector for battery

    //
    // For handling multiple batteries
    //

    BOOLEAN             SelectorPresent;
    ULONG               SelectorBitPosition;

    //
    // Battery
    //

    ULONG               TagCount;           // Tag for next battery
    STATIC_BAT_INFO     Info;
    BAT_ALARM_INFO      AlarmLow;
} SMB_BATT, *PSMB_BATT;


//
// Device extension for the smart battery subsystem FDO
// (Created by first AddDevice command from ACPI PDO)
//

typedef struct _SMB_BATT_SUBSYSTEM {
    SMB_FDO_TYPE        SmbBattFdoType;     // Device object type
    IO_REMOVE_LOCK      RemoveLock;

    //
    // All elements above this point must be identical in
    // SMB_NP_BATT, SMB_BATT_SUBSYSTEM, and SMB_BATT_PDO structures.
    //

    PVOID               SmbAlarmHandle;     // handle for SmbAlarm registration

    PDEVICE_OBJECT      LowerDevice;        // Subsystem PDO
    PDEVICE_OBJECT      DeviceObject;       // Subsystem FDO
    PDEVICE_OBJECT      SmbHcFdo;           // SMBus Fdo

    ULONG               NumberOfBatteries;  // Number of batteries supported
    BOOLEAN             SelectorPresent;    // Is there a selector present

    PBATTERY_SELECTOR   Selector;           // Selector specific info

    //
    // Stuff for handling the SMB alarms for the smart battery subsystem
    //

    LIST_ENTRY          AlarmList;
    KSPIN_LOCK          AlarmListLock;
    PIO_WORKITEM        WorkerThread;       // WORK_QUEUE to get worker thread
    ULONG               WorkerActive;

    //
    // Keep a list of the battery PDOs I "discover"
    //

    PDEVICE_OBJECT      BatteryPdoList[MAX_SMART_BATTERIES_SUPPORTED];
} SMB_BATT_SUBSYSTEM, *PSMB_BATT_SUBSYSTEM;


//
// Device extension for the smart battery PDOs
// (Created by IoCreateDevice SMB_BATT_PDO for each battery)
//

typedef struct _SMB_BATT_PDO {
    SMB_FDO_TYPE        SmbBattFdoType;     // Device object type
    IO_REMOVE_LOCK      RemoveLock;

    //
    // All elements above this point must be identical in
    // SMB_NP_BATT, SMB_BATT_SUBSYSTEM, and SMB_BATT_PDO structures.
    //

    PDEVICE_OBJECT      DeviceObject;       // Battery PDO
    PDEVICE_OBJECT      Fdo;                // Battery FDO layered on top of PDO
    PDEVICE_OBJECT      SubsystemFdo;       // Smart Battery subsystem FDO
    ULONG               BatteryNumber;      // Used by subsystem during battery
                                            //   FDO init
} SMB_BATT_PDO, *PSMB_BATT_PDO;


//
// SMBus Smart battery addresses and registers
//

#define SMB_HOST_ADDRESS     0x8            // Address on bus (10H)
#define SMB_CHARGER_ADDRESS  0x9            // Address on bus (12H)
#define SMB_SELECTOR_ADDRESS 0xa            // Address on bus (14H)
#define SMB_BATTERY_ADDRESS  0xb            // Address on bus (16H)
#define SMB_ALERT_ADDRESS    0xc            // Address on bus (18H)

//
// Smart Battery command codes
//

#define BAT_REMAINING_CAPACITY_ALARM        0x01        // word
#define BAT_REMAINING_TIME_ALARM            0x02        // word
#define BAT_BATTERY_MODE                    0x03        // word
#define BAT_AT_RATE                         0x04        // word
#define BAT_RATE_TIME_TO_FULL               0x05        // word
#define BAT_RATE_TIME_TO_EMPTY              0x06        // word
#define BAT_RATE_OK                         0x07        // word
#define BAT_TEMPERATURE                     0x08        // word
#define BAT_VOLTAGE                         0x09        // word
#define BAT_CURRENT                         0x0a        // word
#define BAT_AVERAGE_CURRENT                 0x0b        // word
#define BAT_MAX_ERROR                       0x0c        // word
#define BAT_RELATIVE_STATE_OF_CHARGE        0x0d        // word
#define BAT_ABSOLUTE_STATE_OF_CHARGE        0x0e        // word
#define BAT_REMAINING_CAPACITY              0x0f        // word
#define BAT_FULL_CHARGE_CAPACITY            0x10        // word
#define BAT_RUN_TO_EMPTY                    0x11        // word
#define BAT_AVERAGE_TIME_TO_EMPTY           0x12        // word
#define BAT_AVERAGE_TIME_TO_FULL            0x13        // word
#define BAT_STATUS                          0x16        // word
#define BAT_CYCLE_COUNT                     0x17        // word
#define BAT_DESIGN_CAPACITY                 0x18        // word
#define BAT_DESIGN_VOLTAGE                  0x19        // word
#define BAT_SPECITICATION_INFO              0x1a        // word
#define BAT_MANUFACTURER_DATE               0x1b        // word
#define BAT_SERIAL_NUMBER                   0x1c        // word
#define BAT_MANUFACTURER_NAME               0x20        // block
#define BAT_DEVICE_NAME                     0x21        // block
#define BAT_CHEMISTRY                       0x22        // block
#define BAT_MANUFACTURER_DATA               0x23        // block

//
// Battery Mode Definitions
//

#define CAPACITY_WATTS_MODE                 0x8000

//
// Battery Scale Factors
//

#define BSCALE_FACTOR_0         1
#define BSCALE_FACTOR_1         10
#define BSCALE_FACTOR_2         100
#define BSCALE_FACTOR_3         1000

#define BATTERY_VSCALE_MASK     0x0f00
#define BATTERY_IPSCALE_MASK    0xf000

#define BATTERY_VSCALE_SHIFT    8
#define BATTERY_IPSCALE_SHIFT   12


//
// Selector command codes
//

#define SELECTOR_SELECTOR_STATE             0x01        // word
#define SELECTOR_SELECTOR_PRESETS           0x02        // word
#define SELECTOR_SELECTOR_INFO              0x04        // word

//
// Selector Equates
//

#define SELECTOR_SHIFT_CHARGE                   4
#define SELECTOR_SHIFT_POWER                    8
#define SELECTOR_SHIFT_COM                      12

#define SELECTOR_STATE_PRESENT_MASK             0x000F
#define SELECTOR_STATE_CHARGE_MASK              0x00F0
#define SELECTOR_STATE_POWER_BY_MASK            0x0F00
#define SELECTOR_STATE_SMB_MASK                 0xF000

#define SELECTOR_SET_COM_MASK                   0x0FFF
#define SELECTOR_SET_POWER_BY_MASK              0xF0FF
#define SELECTOR_SET_CHARGE_MASK                0xFF0F

#define BATTERY_A_PRESENT                       0x0001
#define BATTERY_B_PRESENT                       0x0002
#define BATTERY_C_PRESENT                       0x0004
#define BATTERY_D_PRESENT                       0x0008

#define SELECTOR_STATE_PRESENT_CHANGE           0x1
#define SELECTOR_STATE_CHARGE_CHANGE            0x2
#define SELECTOR_STATE_POWER_BY_CHANGE          0x4
#define SELECTOR_STATE_SMB_CHANGE               0x8

#define SELECTOR_PRESETS_OKTOUSE_MASK           0x000F
#define SELECTOR_PRESETS_USENEXT_MASK           0x00F0

#define SELECTOR_SHIFT_USENEXT                  4

#define SELECTOR_INFO_SUPPORT_MASK              0x000F
#define SELECTOR_INFO_SPEC_REVISION_MASK        0x00F0
#define SELECTOR_INFO_CHARGING_INDICATOR_BIT    0x0100

#define SELECTOR_SHIFT_REVISION                 4

//
// Charger command codes
//

#define CHARGER_SPEC_INFO                   0x11        // word
#define CHARGER_MODE                        0x12        // word
#define CHARGER_STATUS                      0x13        // word
#define CHARGER_CHARGING_CURRENT            0x14        // word
#define CHARGER_CHARGING_VOLTAGE            0x15        // word
#define CHARGER_ALARM_WARNING               0x16        // word

#define CHARGER_SELECTOR_COMMANDS           0x20

#define CHARGER_SELECTOR_STATE              CHARGER_SELECTOR_COMMANDS | \
                                            SELECTOR_SELECTOR_STATE
#define CHARGER_SELECTOR_PRESETS            CHARGER_SELECTOR_COMMANDS | \
                                            SELECTOR_SELECTOR_PRESETS
#define CHARGER_SELECTOR_INFO               CHARGER_SELECTOR_COMMANDS | \
                                            SELECTOR_SELECTOR_INFO

//
// Charger Status Definitions
//

#define CHARGER_STATUS_BATTERY_PRESENT_BIT  0x4000
#define CHARGER_STATUS_AC_PRESENT_BIT       0x8000

//
// Charger Specification Info Definitions
//

#define CHARGER_SELECTOR_SUPPORT_BIT        0x0010

//
// SelectorState ReverseLogic Equates
//

#define INVALID         0xFF


#define BATTERY_A       0x00
#define BATTERY_B       0x01
#define BATTERY_C       0x02
#define BATTERY_D       0x03

#define MULTIBATT_AB    0x04
#define MULTIBATT_AC    0x08
#define MULTIBATT_BC    0x09
#define MULTIBATT_ABC   0x24

#define BATTERY_NONE    0xFF

// word to byte helpers

#define WORD_MSB_SHIFT  8
#define WORD_LSB_MASK   0xFF


//
// Function Prototypes
//

VOID
SmbBattLockDevice (
    IN PSMB_BATT        SmbBatt
);


VOID
SmbBattUnlockDevice (
    IN PSMB_BATT        SmbBatt
);


VOID
SmbBattRequest (
    IN PSMB_BATT        SmbBatt,
    IN PSMB_REQUEST     SmbReq
);


NTSTATUS
SmbBattSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
);


VOID
SmbBattRB(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    OUT PUCHAR          Buffer,
    OUT PUCHAR          BufferLength
);


VOID
SmbBattRW(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    OUT PULONG          Result
);


VOID
SmbBattRSW(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    OUT PLONG           Result
);


VOID
SmbBattWW(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    IN ULONG            Data
);


UCHAR
SmbBattGenericRW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    OUT PULONG          Result
);


UCHAR
SmbBattGenericWW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    IN ULONG            Data
);


VOID
SmbBattGenericRequest (
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN PSMB_REQUEST     SmbReq
);


VOID
SmbBattAlarm (
    IN PVOID            Context,
    IN UCHAR            Address,
    IN USHORT           Data
);


BOOLEAN
SmbBattVerifyStaticInfo (
    IN PSMB_BATT        SmbBatt,
    IN ULONG            BatteryTag
);


NTSTATUS
SmbBattPowerDispatch(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
);


NTSTATUS
SmbBattPnpDispatch(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
);


NTSTATUS
SmbBattRegisterForAlarm(
    IN PDEVICE_OBJECT   Fdo
);


NTSTATUS
SmbBattUnregisterForAlarm(
    IN PDEVICE_OBJECT   Fdo
);


NTSTATUS
SmbBattSetSelectorComm (
    IN  PSMB_BATT   SmbBatt,
    OUT PULONG      OldSelectorState
);


NTSTATUS
SmbBattResetSelectorComm (
    IN PSMB_BATT    SmbBatt,
    IN ULONG        OldSelectorState
);


NTSTATUS
SmbGetSBS (
    IN PULONG           NumberOfBatteries,
    IN PBOOLEAN         SelectorPresent,
    IN PDEVICE_OBJECT   LowerDevice
);


NTSTATUS
SmbGetGLK (
    IN PBOOLEAN         GlobalLockRequired,
    IN PDEVICE_OBJECT   LowerDevice
);


NTSTATUS
SmbBattCreatePdos(
    IN PDEVICE_OBJECT   SubsystemFdo
);


NTSTATUS
SmbBattBuildDeviceRelations(
    IN  PSMB_BATT_SUBSYSTEM SubsystemExt,
    IN  PDEVICE_RELATIONS   *DeviceRelations
);


NTSTATUS
SmbBattQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);


NTSTATUS
SmbBattRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);


NTSTATUS
SmbBattQueryId(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
);


NTSTATUS
SmbBattQueryCapabilities(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
);


SmbBattBuildSelectorStruct(
    IN PDEVICE_OBJECT   SubsystemFdo
);


VOID
SmbBattWorkerThread (
    IN PDEVICE_OBJECT   Fdo,
    IN PVOID            Context
);


VOID
SmbBattLockSelector (
    IN PBATTERY_SELECTOR    Selector
);


VOID
SmbBattUnlockSelector (
    IN PBATTERY_SELECTOR    Selector
);


ULONG
SmbBattGetSelectorDeltas (
    IN ULONG            OriginalSelectorState,
    IN ULONG            NewSelectorState
);


VOID
SmbBattProcessPresentChanges (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OriginalSelectorState,
    IN ULONG                NewSelectorState
);

VOID
SmbBattProcessChargeChange (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OriginalSelectorState,
    IN ULONG                NewSelectorState
);


VOID
SmbBattProcessPowerByChange (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OriginalSelectorState,
    IN ULONG                NewSelectorState
);


VOID
SmbBattNotifyClassDriver (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                BatteryIndex
);


NTSTATUS
SmbBattDirectDataAccess (
    IN PSMB_NP_BATT         DeviceExtension,
    IN PSMBBATT_DATA_STRUCT IoBuffer,
    IN ULONG                InputLen,
    IN ULONG                OutputLen
);


VOID
SmbBattProcessChargerAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                ChargerStatus
);

NTSTATUS
SmbBattSetInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL    Level,
    IN PVOID Buffer                     OPTIONAL
);


UCHAR
SmbBattIndex (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble,
    IN UCHAR                SimultaneousIndex
);

BOOLEAN
SmbBattReverseLogic (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble
);

extern BOOLEAN   SmbBattUseGlobalLock;

NTSTATUS
SmbBattAcquireGlobalLock (
    IN  PDEVICE_OBJECT LowerDeviceObject,
    OUT PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
);

NTSTATUS
SmbBattReleaseGlobalLock (
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
);

NTSTATUS
SmbBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

NTSTATUS
SmbBattWmiRegistration(
    PSMB_NP_BATT SmbNPBatt
);

NTSTATUS
SmbBattWmiDeRegistration(
    PSMB_NP_BATT SmbNPBatt
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbbatt\smbmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbmisc.c

Abstract:

    SMBus handler functions

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

    Chris Windle    1/27/98     Bug Fixes

--*/

#include "smbbattp.h"


//
// Make the SelectorBit table pageable
//

//#ifdef ALLOC_DATA_PRAGMA
//#pragma data_seg("PAGE")
//#endif

//
// Lookup table for the battery that corresponds to bit positions and
// whether or not reverse logic is being used (to indicate charging or
// discharging).
//
// NOTE: To support Simultaneous Charging and Powering, this table
// has been modified to account for multiple bits.  Also, it can't be
// used for battery index lookup since it assumes one bit set maximum.
// Instead, use special indexes for multiple batteries as follows:
//
// 1st Battery = Index & 0x03
// 2nd Battery = (Index >> 2) & 0x03 (Battery A not allowed)
// 3rd Battery = (Index >> 4) & 0x03 (Battery A not allowed)
//
// In < 4 battery systems the Battery D bit can be used to determine
// the nibbles that are inverted, and it allows the following combinations:
//
//          Battery A & B
//          Battery A & C
//          Battery B & C
//          Battery A, B, & C
//

const SELECTOR_STATE_LOOKUP SelectorBits [16] = {
    {BATTERY_NONE,  FALSE},         // Bit Pattern: 0000
    {BATTERY_A,     FALSE},         //              0001
    {BATTERY_B,     FALSE},         //              0010
    {MULTIBATT_AB,  FALSE},         //              0011
    {BATTERY_C,     FALSE},         //              0100
    {MULTIBATT_AC,  FALSE},         //              0101
    {MULTIBATT_BC,  FALSE},         //              0110
    {MULTIBATT_ABC, FALSE},         //              0111
    {MULTIBATT_ABC, TRUE},          //              1000
    {MULTIBATT_BC,  TRUE},          //              1001
    {MULTIBATT_AC,  TRUE},          //              1010
    {BATTERY_C,     TRUE},          //              1011
    {MULTIBATT_AB,  TRUE},          //              1100
    {BATTERY_B,     TRUE},          //              1101
    {BATTERY_A,     TRUE},          //              1110
    {BATTERY_NONE,  TRUE}           //              1111
};

//
// Note: For 4-Battery Systems to support Simultaneous Capability
// properly, the following two assumptions must be made:
//      - Battery D can never be used simultaneously.
//      - Three batteries can not be used simultaneously.
//
// This allows for only the following possible battery combinations:
//
//          Battery A & B
//          Battery A & C
//          Battery B & C
//
// The following table is used for 4-battery lookup
//

const SELECTOR_STATE_LOOKUP SelectorBits4 [16] = {
    {BATTERY_NONE,  FALSE},         // Bit Pattern: 0000
    {BATTERY_A,     FALSE},         //              0001
    {BATTERY_B,     FALSE},         //              0010
    {MULTIBATT_AB,  FALSE},         //              0011
    {BATTERY_C,     FALSE},         //              0100
    {MULTIBATT_AC,  FALSE},         //              0101
    {MULTIBATT_BC,  FALSE},         //              0110
    {BATTERY_D,     TRUE},          //              0111
    {BATTERY_D,     FALSE},         //              1000
    {MULTIBATT_BC,  TRUE},          //              1001
    {MULTIBATT_AC,  TRUE},          //              1010
    {BATTERY_C,     TRUE},          //              1011
    {MULTIBATT_AB,  TRUE},          //              1100
    {BATTERY_B,     TRUE},          //              1101
    {BATTERY_A,     TRUE},          //              1110
    {BATTERY_NONE,  TRUE}           //              1111
};


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbBattLockDevice)
#pragma alloc_text(PAGE,SmbBattUnlockDevice)
#pragma alloc_text(PAGE,SmbBattLockSelector)
#pragma alloc_text(PAGE,SmbBattUnlockSelector)
#pragma alloc_text(PAGE,SmbBattRequest)
#pragma alloc_text(PAGE,SmbBattRB)
#pragma alloc_text(PAGE,SmbBattRW)
#pragma alloc_text(PAGE,SmbBattRSW)
#pragma alloc_text(PAGE,SmbBattWW)
#pragma alloc_text(PAGE,SmbBattGenericRW)
#pragma alloc_text(PAGE,SmbBattGenericWW)
#pragma alloc_text(PAGE,SmbBattGenericRequest)
#pragma alloc_text(PAGE,SmbBattSetSelectorComm)
#pragma alloc_text(PAGE,SmbBattResetSelectorComm)
#pragma alloc_text(PAGE,SmbBattDirectDataAccess)
#pragma alloc_text(PAGE,SmbBattIndex)
#pragma alloc_text(PAGE,SmbBattReverseLogic)
#pragma alloc_text(PAGE,SmbBattAcquireGlobalLock)
#pragma alloc_text(PAGE,SmbBattReleaseGlobalLock)
#endif



VOID
SmbBattLockDevice (
    IN PSMB_BATT    SmbBatt
    )
{
    PAGED_CODE();

    //
    // Get device lock on the battery
    //

    ExAcquireFastMutex (&SmbBatt->NP->Mutex);
}



VOID
SmbBattUnlockDevice (
    IN PSMB_BATT    SmbBatt
    )
{
    PAGED_CODE();

    //
    // Release device lock on the battery
    //

    ExReleaseFastMutex (&SmbBatt->NP->Mutex);
}



VOID
SmbBattLockSelector (
    IN PBATTERY_SELECTOR    Selector
    )
{
    PAGED_CODE();

    //
    // Get device lock on the selector
    //

    if (Selector) {
        ExAcquireFastMutex (&Selector->Mutex);
    }
}



VOID
SmbBattUnlockSelector (
    IN PBATTERY_SELECTOR    Selector
    )
{
    PAGED_CODE();

    //
    // Release device lock on the selector
    //

    if (Selector) {
        ExReleaseFastMutex (&Selector->Mutex);
    }
}



NTSTATUS
SmbBattSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    Context is the event to set

--*/
{
    PKEVENT         Event;

    Event = (PKEVENT) Context;
    KeSetEvent (Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
SmbBattRequest (
    IN PSMB_BATT    SmbBatt,
    IN PSMB_REQUEST SmbReq
    )
// function to issue SMBus request
{
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    BOOLEAN             useLock = SmbBattUseGlobalLock;
    ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER globalLock;

    PAGED_CODE();

    //
    // Build Io Control for SMB bus driver for this request
    //

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    if (!SmbBatt->SmbHcFdo) {
        //
        // The SMB host controller either hasn't been opened yet (in start device) or
        // there was an error opening it and we did not get deleted somehow.
        //

        BattPrint(BAT_ERROR, ("SmbBattRequest: SmbHc hasn't been opened yet \n"));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }

    Irp = IoAllocateIrp (SmbBatt->SmbHcFdo->StackSize, FALSE);
    if (!Irp) {
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = SMB_BUS_REQUEST;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SMB_REQUEST);
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = SmbReq;
    IoSetCompletionRoutine (Irp, SmbBattSynchronousRequest, &Event, TRUE, TRUE, TRUE);

    //
    // Issue it
    //

    //
    // Note: uselock is a cached value of the global variable, so in case the
    // value changes, we won't aquire and not release etc.
    //
    if (useLock) {
        if (!NT_SUCCESS (SmbBattAcquireGlobalLock (SmbBatt->SmbHcFdo, &globalLock))) {
            useLock = FALSE;
        }
    }

    IoCallDriver (SmbBatt->SmbHcFdo, Irp);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    Status = Irp->IoStatus.Status;
    IoFreeIrp (Irp);

    if (useLock) {
        SmbBattReleaseGlobalLock (SmbBatt->SmbHcFdo, &globalLock);
    }

    //
    // Check result code
    //

    if (!NT_SUCCESS(Status)) {
        BattPrint(BAT_ERROR, ("SmbBattRequest: error in SmbHc request - %x\n", Status));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
    }
}



VOID
SmbBattRB(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    OUT PUCHAR      Buffer,
    OUT PUCHAR      BufferLength
    )
// function to read-block from the battery
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_READ_BLOCK;
    SmbReq.Address  = SMB_BATTERY_ADDRESS;
    SmbReq.Command  = SmbCmd;
    SmbBattRequest (SmbBatt, &SmbReq);

    if (SmbReq.Status == SMB_STATUS_OK) {
        ASSERT (SmbReq.BlockLength < SMB_MAX_DATA_SIZE);
        memcpy (Buffer, SmbReq.Data, SmbReq.BlockLength);
        *BufferLength = SmbReq.BlockLength;
    } else {
        // some sort of failure, check tag data for cache validity
        SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
    }
}



VOID
SmbBattRW(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    OUT PULONG      Result
    )
// function to read-word from the battery
// N.B. word is returned as a ULONG
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_READ_WORD;
    SmbReq.Address  = SMB_BATTERY_ADDRESS;
    SmbReq.Command  = SmbCmd;
    SmbBattRequest (SmbBatt, &SmbReq);

    if (SmbReq.Status != SMB_STATUS_OK) {
        // some sort of failure, check tag data for cache validity
        SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
    }

    *Result = SmbReq.Data[0] | SmbReq.Data[1] << WORD_MSB_SHIFT;
    BattPrint(BAT_IO, ("SmbBattRW: Command: %02x == %04x\n", SmbCmd, *Result));
}


VOID
SmbBattRSW(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    OUT PLONG       Result
    )
// function to read-signed-word from the battery
// N.B. word is returned as a LONG
{
    ULONG           i;

    PAGED_CODE();

    SmbBattRW(SmbBatt, SmbCmd, &i);
    *Result = ((SHORT) i);
}


VOID
SmbBattWW(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    IN ULONG        Data
    )
// function to write-word to the battery
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_WRITE_WORD;
    SmbReq.Address  = SMB_BATTERY_ADDRESS;
    SmbReq.Command  = SmbCmd;
    SmbReq.Data[0]  = (UCHAR) (Data & WORD_LSB_MASK);
    SmbReq.Data[1]  = (UCHAR) (Data >> WORD_MSB_SHIFT) & WORD_LSB_MASK;
    BattPrint(BAT_IO, ("SmbBattWW: Command: %02x = %04x\n", SmbCmd, Data));
    SmbBattRequest (SmbBatt, &SmbReq);

    if (SmbReq.Status != SMB_STATUS_OK) {
        // some sort of failure, check tag data for cache validity
        SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
    }
}



UCHAR
SmbBattGenericRW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    OUT PULONG          Result
    )
// function to read-word from the SMB device (charger or selector)
// N.B. word is returned as a ULONG
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_READ_WORD;
    SmbReq.Address  = Address;
    SmbReq.Command  = SmbCmd;
    SmbBattGenericRequest (SmbHcFdo, &SmbReq);

    *Result = SmbReq.Data[0] | (SmbReq.Data[1] << WORD_MSB_SHIFT);
    BattPrint(BAT_IO, ("SmbBattGenericRW: Address: %02x:%02x == %04x\n", Address, SmbCmd, *Result));
    return SmbReq.Status;
}


UCHAR
SmbBattGenericWW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    IN ULONG            Data
    )
// function to write-word to SMB device (charger or selector)
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_WRITE_WORD;
    SmbReq.Address  = Address;
    SmbReq.Command  = SmbCmd;
    SmbReq.Data[0]  = (UCHAR) (Data & WORD_LSB_MASK);
    SmbReq.Data[1]  = (UCHAR) (Data >> WORD_MSB_SHIFT) & WORD_LSB_MASK;

    BattPrint(BAT_IO, ("SmbBattGenericWW: Address: %02x:%02x = %04x\n", Address, SmbCmd, Data));
    SmbBattGenericRequest (SmbHcFdo, &SmbReq);
    return SmbReq.Status;

}



VOID
SmbBattGenericRequest (
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN PSMB_REQUEST     SmbReq
    )
// function to issue SMBus request
{
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    BOOLEAN             useLock = SmbBattUseGlobalLock;
    ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER globalLock;

    PAGED_CODE();


    //
    // Build Io Control for SMB bus driver for this request
    //

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    if (!SmbHcFdo) {
        //
        // The SMB host controller either hasn't been opened yet (in start device) or
        // there was an error opening it and we did not get deleted somehow.
        //

        BattPrint(BAT_ERROR, ("SmbBattGenericRequest: SmbHc hasn't been opened yet \n"));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }


    Irp = IoAllocateIrp (SmbHcFdo->StackSize, FALSE);
    if (!Irp) {
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = SMB_BUS_REQUEST;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SMB_REQUEST);
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = SmbReq;
    IoSetCompletionRoutine (Irp, SmbBattSynchronousRequest, &Event, TRUE, TRUE, TRUE);

    //
    // Issue it
    //

    //
    // Note: uselock is a cached value of the global variable, so in case the
    // value changes, we won't acquire and not release etc.
    //
    if (useLock) {
        if (!NT_SUCCESS (SmbBattAcquireGlobalLock (SmbHcFdo, &globalLock))) {
            useLock = FALSE;
        }
    }

    IoCallDriver (SmbHcFdo, Irp);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    Status = Irp->IoStatus.Status;
    IoFreeIrp (Irp);

    if (useLock) {
        SmbBattReleaseGlobalLock (SmbHcFdo, &globalLock);
    }

    //
    // Check result code
    //

    if (!NT_SUCCESS(Status)) {
        BattPrint(BAT_ERROR, ("SmbBattGenericRequest: error in SmbHc request - %x\n", Status));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
    }
}



NTSTATUS
SmbBattSetSelectorComm (
    IN  PSMB_BATT   SmbBatt,
    OUT PULONG      OldSelectorState
    )
/*++

Routine Description:

    This routine sets the communication path through the selector to the calling
    battery.  It returns the original selector state in the variable provided.

    NOTE:   It is assumed that the caller already has acquired the device lock on the
            selector before calling us.

    NOTE:   This function should always be called in a pair with SmbBattResetSelectorComm

Arguments:

    SmbBatt             - Nonpaged extension for current battery

    OldSelectorState    - Original selector state at start of this function

Return Value:

    NTSTATUS

--*/
{
    PBATTERY_SELECTOR       selector;
    UCHAR                   smbStatus;
    ULONG                   requestData;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattSetSelectorComm: ENTERING\n"));

    //
    // We only need to do this if there is a selector in the system.
    //

    if (SmbBatt->SelectorPresent) {

        selector            = SmbBatt->Selector;
        *OldSelectorState   = selector->SelectorState;

        //
        // If the battery isn't present, fail the request.
        //
        if (!(selector->SelectorState & SmbBatt->SelectorBitPosition)) {
            return STATUS_NO_SUCH_DEVICE;
        }

        //
        // See if we are already set up to talk with the requesting battery.
        // We will check against the cached information in the selector struct.
        //

        if (selector->SelectorState & (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_COM)) {
            return STATUS_SUCCESS;
        }

        //
        // Build the data word to change the selector communications.  This will
        // look like the following:
        //
        // PRESENT field        0xf     we don't want to change anything here
        // CHARGE field         0xf     we don't want to change anything here
        // POWER BY field       0xf     we don't want to change anything here
        // SMB field            0x_     the bit set according to the battery number
        //

        requestData = (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_COM) | SELECTOR_SET_COM_MASK;

        smbStatus = SmbBattGenericWW (
                        SmbBatt->SmbHcFdo,
                        selector->SelectorAddress,
                        selector->SelectorStateCommand,
                        requestData
                    );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (BAT_ERROR, ("SmbBattSetSelectorComm:  couldn't write selector state - %x\n", smbStatus));
            return STATUS_UNSUCCESSFUL;
        } else {
            selector->SelectorState |= SELECTOR_STATE_SMB_MASK;
            selector->SelectorState &= requestData;

            BattPrint (BAT_IO, ("SmbBattSetSelectorComm: state after write -  %x\n", selector->SelectorState));
        }

    }   // if (subsystemExt->SelectorPresent)

    BattPrint(BAT_TRACE, ("SmbBattSetSelectorComm: EXITING\n"));
    return STATUS_SUCCESS;
}



NTSTATUS
SmbBattResetSelectorComm (
    IN PSMB_BATT    SmbBatt,
    IN ULONG        OldSelectorState
    )
/*++

Routine Description:

    This routine resets the communication path through the selector to the its
    original state.  It returns the original selector state in the variable provided.

    NOTE:   It is assumed that the caller already has acquired the device lock on the
            selector before calling us.

    NOTE:   This function should always be called in a pair with SmbBattSetSelectorComm

Arguments:

    SmbBatt             - Nonpaged extension for current battery

    OldSelectorState    - Original selector state to be restored

Return Value:

    NTSTATUS

--*/
{
    PBATTERY_SELECTOR       selector;
    UCHAR                   smbStatus;
    ULONG                   tmpState;

    NTSTATUS                status      = STATUS_SUCCESS;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattResetSelectorComm: ENTERING\n"));

    //
    // We only need to do this if there is a selector in the system.
    //

    if (SmbBatt->SelectorPresent) {

        selector = SmbBatt->Selector;

        //
        // See if we were already set up to talk with the requesting battery.
        // We will check against the cached information in the selector struct.
        //

        if ((OldSelectorState & selector->SelectorState) & SELECTOR_STATE_SMB_MASK) {
            return STATUS_SUCCESS;
        }

        //
        // Change the selector communications back.  The SMB field is the only
        // that we will write.
        //

        tmpState  = SELECTOR_SET_COM_MASK;
        tmpState |= OldSelectorState & SELECTOR_STATE_SMB_MASK;

        smbStatus = SmbBattGenericWW (
                        SmbBatt->SmbHcFdo,
                        selector->SelectorAddress,
                        selector->SelectorStateCommand,
                        tmpState
                    );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (
                BAT_ERROR,
                ("SmbBattResetSelectorComm: couldn't write selector state - %x\n",
                smbStatus)
            );
            status = STATUS_UNSUCCESSFUL;
        } else {
            selector->SelectorState |= SELECTOR_STATE_SMB_MASK;
            selector->SelectorState &= tmpState;
            BattPrint (
                BAT_IO,
                ("SmbBattResetSelectorComm: state after write -  %x\n",
                selector->SelectorState)
            );
        }

    }   // if (subsystemExt->SelectorPresent)

    BattPrint(BAT_TRACE, ("SmbBattResetSelectorComm: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattDirectDataAccess (
    IN PSMB_NP_BATT         DeviceExtension,
    IN PSMBBATT_DATA_STRUCT IoBuffer,
    IN ULONG                InputLen,
    IN ULONG                OutputLen
    )
/*++

Routine Description:

    This routine is used to handle IOCTLs acessing the SMBBatt commands directly.

Arguments:

    DeviceExtension         - Device extension for the smart battery subsystem

    IoBuffer                - Buffer that contains the input structure and will
                              contain the results of the read.

Return Value:

    NTSTATUS
--*/
{
    PSMB_BATT_SUBSYSTEM     SubsystemExt;
    PSMB_BATT               SmbBatt;

    UCHAR                   address;
    UCHAR                   command;
    UCHAR                   smbStatus;
    ULONG                   oldSelectorState;
    ULONG                   ReturnBufferLength;
    UCHAR               strLength;
    UCHAR               strBuffer[SMB_MAX_DATA_SIZE+1]; // +1 extra char to hold NULL
    UCHAR               strBuffer2[SMB_MAX_DATA_SIZE+1];
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;
    UCHAR               tempFlags;

    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();

    if ((DeviceExtension->SmbBattFdoType == SmbTypeBattery)
            && (IoBuffer->Address == SMB_BATTERY_ADDRESS)) {
        // This is a battery data request
        SmbBatt = DeviceExtension->Batt;
        SmbBattLockSelector (SmbBatt->Selector);
        SmbBattLockDevice (SmbBatt);
        status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
        if (NT_SUCCESS (status)) {
            if ((InputLen >= sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen == 0)) {
                // This is a write command
                status = STATUS_NOT_IMPLEMENTED;
            } else if ((InputLen == sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen > 0)){
                // This is a Read command

                if ((IoBuffer->Command >= BAT_REMAINING_CAPACITY_ALARM) &&
                    (IoBuffer->Command <= BAT_SERIAL_NUMBER)) {

                    // ReadWord Commands
                    if (OutputLen == sizeof(SMBBATT_DATA_STRUCT)) {
                        tempFlags = SmbBatt->Info.Valid;
                        SmbBatt->Info.Valid |= VALID_TAG_DATA;
                        SmbBattRW(SmbBatt, IoBuffer->Command, &IoBuffer->Data.Ulong);
                        if (SmbBatt->Info.Valid & VALID_TAG_DATA) {
                            ReturnBufferLength = sizeof(ULONG);
                        } else {
                            status = STATUS_DATA_ERROR;
                        }
                        SmbBatt->Info.Valid = tempFlags;
                    } else {
                        status = STATUS_INVALID_BUFFER_SIZE;
                    }

                } else if ((IoBuffer->Command >= BAT_MANUFACTURER_NAME) &&
                    (IoBuffer->Command <= BAT_MANUFACTURER_DATA)) {

                    // ReadBlock Commands
                    if (OutputLen == (SMBBATT_DATA_STRUCT_SIZE)+(SMB_MAX_DATA_SIZE*2)) {
                        memset (&IoBuffer->Data.Block[0], 0, (SMB_MAX_DATA_SIZE*2));
                        unicodeString.Buffer        = &IoBuffer->Data.Block[0];
                        unicodeString.MaximumLength = SMB_MAX_DATA_SIZE*2;
                        unicodeString.Length        = 0;

                        memset (strBuffer, 0, sizeof(strBuffer));
                        memset (strBuffer2, 0, sizeof(strBuffer2));
                        do {
                            SmbBattRB (
                                SmbBatt,
                                IoBuffer->Command,
                                strBuffer,
                                &strLength
                            );

                            SmbBattRB (
                                SmbBatt,
                                IoBuffer->Command,
                                strBuffer2,
                                &strLength
                            );
                        } while (strcmp (strBuffer, strBuffer2));

                        RtlInitAnsiString (&ansiString, strBuffer);
                        RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

                        ReturnBufferLength  = unicodeString.Length;


                    } else {
                        status = STATUS_INVALID_BUFFER_SIZE;
                    }
                } else {
                    // Unsupported Commands
                    status = STATUS_INVALID_PARAMETER;
                }
            }

        }

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        SmbBattUnlockDevice (SmbBatt);
        SmbBattUnlockSelector (SmbBatt->Selector);
    } else if (DeviceExtension->SmbBattFdoType == SmbTypeSubsystem) {
        // This is a battery subsystem
        SubsystemExt = (PSMB_BATT_SUBSYSTEM) DeviceExtension;
        SmbBattLockSelector (SubsystemExt->Selector);

        if ((InputLen >= sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen == 0)) {
            // This is a write command
            status = STATUS_NOT_IMPLEMENTED;
        } else if ((InputLen == sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen > 0)){
            // This is a Read command

            switch (IoBuffer->Address) {

                case SMB_SELECTOR_ADDRESS:

                    //
                    // We have to do some translation for selector requests depending
                    // on whether the selector is stand alone or implemented in the
                    // charger.
                    //

                    if ((SubsystemExt->SelectorPresent) && (SubsystemExt->Selector)) {

                        address = SubsystemExt->Selector->SelectorAddress;
                        command = IoBuffer->Command;

                        // Map to Charger if Selector is implemented in the Charger
                        if (address == SMB_CHARGER_ADDRESS) {
                            switch (command) {
                                case SELECTOR_SELECTOR_STATE:
                                case SELECTOR_SELECTOR_PRESETS:
                                case SELECTOR_SELECTOR_INFO:
                                    command |= CHARGER_SELECTOR_COMMANDS;
                                    break;

                                default:
                                    status = STATUS_NOT_SUPPORTED;
                                    break;
                            }
                        }

                    } else {
                        status = STATUS_NO_SUCH_DEVICE;
                    }

                    break;

                case SMB_CHARGER_ADDRESS:

                    //
                    // For this one we currently only support the ChargerStatus and
                    // ChargerSpecInfo commands.
                    //
                    // Other commands are not currently supported.
                    //

                    address = IoBuffer->Address;

                    switch (IoBuffer->Command) {
                        case CHARGER_SPEC_INFO:
                        case CHARGER_STATUS:

                            command = IoBuffer->Command;
                            break;

                        default:
                            status = STATUS_NOT_SUPPORTED;
                            break;

                    }

                    break;


                default:
                    status = STATUS_NOT_SUPPORTED;
                    break;

            }   // switch (readStruct->Address)

            if (status == STATUS_SUCCESS) {
                //
                // Do the read command
                //

                smbStatus = SmbBattGenericRW (
                                SubsystemExt->SmbHcFdo,
                                address,
                                command,
                                &IoBuffer->Data.Ulong
                            );

                if (smbStatus != SMB_STATUS_OK) {
                    BattPrint (
                        BAT_ERROR,
                        ("SmbBattDirectDataAccess:  Couldn't read from - %x, status - %x\n",
                        address,
                        smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;

                }
            }

        }

        SmbBattUnlockSelector (SubsystemExt->Selector);
    } else {
        status=STATUS_INVALID_DEVICE_REQUEST;
        BattPrint (
            BAT_ERROR,
            ("SmbBattDirectDataAccess: Invalid SmbBattFdoType")
        );
    }

    return status;
}



UCHAR
SmbBattIndex (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble,
    IN UCHAR                SimultaneousIndex
)
/*++

Routine Description:

    This routine is provided as a helper routine to determine which
    battery is selected in a given selector nibble, based on the number
    of batteries supported in the system.

Arguments:

    Selector            - Structure defining selector address and commands

    SelectorNibble      - The nibble of the SelectorState, moved to the low
                          order 4 bits, to check reverse logic on.

    SimultaneousIndex   - Which batteryindex is requested in simultaneous-
                          battery situations (0, 1, or 2)

Return Value:

    BatteryIndex =  0 - Battery A
                    1 - Battery B
                    2 - Battery C
                    3 - Battery D
                   FF - No Battery

--*/
{
    UCHAR   batteryIndex;

    PAGED_CODE();

    // Assume if SelectorInfo supports 4 batteries, use SelectorBits4 table
    if (Selector->SelectorInfo & BATTERY_D_PRESENT) {
        batteryIndex = SelectorBits4[SelectorNibble].BatteryIndex;
    } else {
        batteryIndex = SelectorBits[SelectorNibble].BatteryIndex;
    }

    // If it's valid
    if (batteryIndex != BATTERY_NONE) {

        // return index for First Battery
        if (SimultaneousIndex == 0) {
            return (batteryIndex & 3);

        // return index for Second Battery
        } else if (SimultaneousIndex == 1) {
            batteryIndex = (batteryIndex >> 2) & 3;
            if (batteryIndex != BATTERY_A) {
                return (batteryIndex);
            }

        // return index for Third Battery
        } else if (SimultaneousIndex == 2) {
            batteryIndex = (batteryIndex >> 2) & 3;
            if (batteryIndex != BATTERY_A) {
                return (batteryIndex);
            }
        }
    }

    // return no battery index
    return (BATTERY_NONE);
}



BOOLEAN
SmbBattReverseLogic (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble
)
/*++

Routine Description:

    This routine is provided as a helper routine to determine the reverse
    logic on a given selector nibble, based on the number of batteries
    supported in the system.

Arguments:

    Selector            - Structure defining selector address and commands

    SelectorNibble      - The nibble of the SelectorState, moved to the low
                          order 4 bits, to check reverse logic on.

Return Value:

    FALSE if the nibble is normal
    TRUE if the nibble is inverted

--*/
{

    PAGED_CODE();

    // Assume if SelectorInfo supports 4 batteries, use SelectorBits4 table
    if (Selector->SelectorInfo & BATTERY_D_PRESENT) {
        return (SelectorBits4[SelectorNibble].ReverseLogic);
    } else {
        return (SelectorBits[SelectorNibble].ReverseLogic);
    }
}



NTSTATUS
SmbBattAcquireGlobalLock (
    IN  PDEVICE_OBJECT LowerDeviceObject,
    OUT PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
)
/*++

Routine Description:

    Call ACPI driver to obtain the global lock

    Note: This routine can be called at dispatch level

Arguments:

    LowerDeviceObject - The FDO to pass the request to.

Return Value:

    Return Value from IOCTL.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    KEVENT              event;

    BattPrint (BAT_TRACE, ("SmbBattAcquireGlobalLock: Entering\n"));

    //
    // We wish to acquire the lock
    //
    GlobalLock->Signature = ACPI_ACQUIRE_GLOBAL_LOCK_SIGNATURE;
    GlobalLock->LockObject = NULL;

    //
    // setup the irp
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (LowerDeviceObject->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ACQUIRE_GLOBAL_LOCK;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irp->AssociatedIrp.SystemBuffer = GlobalLock;
    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);

    //
    // Send to ACPI driver
    //
    IoCallDriver (LowerDeviceObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = irp->IoStatus.Status;
    IoFreeIrp (irp);

    if (!NT_SUCCESS(status)) {
        BattPrint(
            BAT_ERROR,
            ("SmbBattAcquireGlobalLock: Acquire Lock failed, status = %08x\n",
             status )
            );
        DbgBreakPoint ();
    }

    BattPrint (BAT_TRACE, ("SmbBattAcquireGlobalLock: Returning %x\n", status));

    return status;
}



NTSTATUS
SmbBattReleaseGlobalLock (
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
)
/*++

Routine Description:

    Call ACPI driver to release the global lock

Arguments:

    LowerDeviceObject - The FDO to pass the request to.

Return Value:

    Return Value from IOCTL.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    KEVENT              event;

    BattPrint (BAT_TRACE, ("SmbBattReleaseGlobalLock: Entering\n"));

    //
    // We wish to acquire the lock
    //
    GlobalLock->Signature = ACPI_RELEASE_GLOBAL_LOCK_SIGNATURE;

    //
    // setup the irp
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (LowerDeviceObject->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_RELEASE_GLOBAL_LOCK;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irp->AssociatedIrp.SystemBuffer = GlobalLock;
    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);

    //
    // Send to ACPI driver
    //
    IoCallDriver (LowerDeviceObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = irp->IoStatus.Status;
    IoFreeIrp (irp);

    if (!NT_SUCCESS(status)) {
        BattPrint(
            BAT_ERROR,
            ("SmbBattReleaseGlobalLock: Acquire Lock failed, status = %08x\n",
             status )
            );
    }

    BattPrint (BAT_TRACE, ("SmbBattReleaseGlobalLock: Returning %x\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbbatt\smbwmi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SmbWmi.c

Abstract:

    Wmi section for Smart Battery Miniport Driver

Author:

    Michael Hills

Environment:

    Kernel mode

Revision History:

--*/

#include "SmbBattp.h"
#include <initguid.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>

NTSTATUS
SmbBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
SmbBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

#if DEBUG
PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
);
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbBattWmiRegistration)
#pragma alloc_text(PAGE,SmbBattWmiDeRegistration)
#pragma alloc_text(PAGE,SmbBattSystemControl)
#pragma alloc_text(PAGE,SmbBattQueryWmiRegInfo)
#endif


NTSTATUS
SmbBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine passes the request down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PSMB_NP_BATT            SmbNPBatt;
    PIO_STACK_LOCATION      stack;
    PDEVICE_OBJECT          lowerDevice;
    SYSCTL_IRP_DISPOSITION  disposition = IrpForward;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation (Irp);

    BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: %s\n",
                WMIMinorFunctionString(stack->MinorFunction)));

    SmbNPBatt = (PSMB_NP_BATT) DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //
    status = IoAcquireRemoveLock (&SmbNPBatt->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    if (SmbNPBatt->SmbBattFdoType == SmbTypeBattery) {
        lowerDevice = SmbNPBatt->LowerDevice;
        status = BatteryClassSystemControl(SmbNPBatt->Class,
                                           &SmbNPBatt->WmiLibContext,
                                           DeviceObject,
                                           Irp,
                                           &disposition);
    } else if (SmbNPBatt->SmbBattFdoType == SmbTypeSubsystem) {
        lowerDevice = ((PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension)->LowerDevice;
    } else {
        //
        // There is no lower device.  Just complete the IRP.
        //
        lowerDevice = NULL;
        disposition = IrpNotCompleted;
        status = Irp->IoStatus.Status;
    }

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: Irp Processed\n"));

            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: Irp Not Completed.\n"));
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: Irp Forward.\n"));
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (lowerDevice, Irp);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (lowerDevice, Irp);
            break;
        }
    }

    //
    // Release Removal Lock
    //
    IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, Irp);

    return status;
}


NTSTATUS
SmbBattWmiRegistration(
    PSMB_NP_BATT SmbNPBatt
)
/*++
Routine Description

    Registers with WMI as a data provider for this
    instance of the device

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // This is essentially blank since smbbatt.sys doesn't have any
    // data to handle other than the default battery class data which is handled
    // by the battery class driver.
    // If there were driver specific data, such as Device Wake Enable controls, 
    // it would be listed here.
    // 

    SmbNPBatt->WmiLibContext.GuidCount = 0;
    SmbNPBatt->WmiLibContext.GuidList = NULL;
    SmbNPBatt->WmiLibContext.QueryWmiRegInfo = SmbBattQueryWmiRegInfo;
    SmbNPBatt->WmiLibContext.QueryWmiDataBlock = SmbBattQueryWmiDataBlock;
    SmbNPBatt->WmiLibContext.SetWmiDataBlock = NULL;
    SmbNPBatt->WmiLibContext.SetWmiDataItem = NULL;
    SmbNPBatt->WmiLibContext.ExecuteWmiMethod = NULL;
    SmbNPBatt->WmiLibContext.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //

    status = IoWMIRegistrationControl(SmbNPBatt->Batt->DeviceObject,
                             WMIREG_ACTION_REGISTER
                             );

    return status;

}

NTSTATUS
SmbBattWmiDeRegistration(
    PSMB_NP_BATT SmbNPBatt
)
/*++
Routine Description

     Inform WMI to remove this DeviceObject from its
     list of providers. This function also
     decrements the reference count of the deviceobject.

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(SmbNPBatt->Batt->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER
                                 );

}

//
// WMI System Call back functions
//

NTSTATUS
SmbBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PSMB_NP_BATT SmbNPBatt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    BattPrint ((BAT_TRACE), ("SmbBatt: Entered SmbBattQueryWmiRegInfo\n"));


    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &GlobalRegistryPath;
    *Pdo = SmbNPBatt->Batt->PDO;

    return STATUS_SUCCESS;
}

NTSTATUS
SmbBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PSMB_NP_BATT    SmbNPBatt = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    NTSTATUS        status;

    PAGED_CODE();

    BattPrint ((BAT_TRACE), ("Entered SmbBattQueryWmiDataBlock\n"));

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    status = BatteryClassQueryWmiDataBlock(
        SmbNPBatt->Class,
        DeviceObject,
        Irp,
        GuidIndex,
        InstanceLengthArray,
        OutBufferSize,
        Buffer);

    if (status != STATUS_WMI_GUID_NOT_FOUND) {
        BattPrint ((BAT_TRACE), ("SmbBattQueryWmiDataBlock: Handled by Battery Class.\n"));
        return status;
    }

    //
    // Fail Request: Smart battery has no other GUIDs
    //

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  STATUS_WMI_GUID_NOT_FOUND,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}


#if DEBUG

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE";
        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM";
        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION";
        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS";
        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION";
        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS";
        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD";
        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA";
        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE";
        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO";
        default:
            return "IRP_MN_?????";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbclass\smbcalrm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcsrv.c

Abstract:

    SMBus class driver service functions

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"

VOID
SmbCCheckAlarmDelete (
    IN PSMBDATA         Smb,
    IN PSMB_ALARM   SmbAlarm
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbCCheckAlarmDelete)
#pragma alloc_text(PAGE,SmbCRegisterAlarm)
#pragma alloc_text(PAGE,SmbCDeregisterAlarm)
#endif

UCHAR gHexDigits [] = "0123456789ABCDEF";


NTSTATUS
SmbCRunAlarmMethodCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    SmbPrint(SMB_ALARMS, ("SmbCRunAlarmMethodCompletionRoutine: Done running Control Method.  Status=0x%08x\n", Irp->IoStatus.Status));
    
    ExFreePool (Irp->AssociatedIrp.SystemBuffer);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SmbCRunAlarmMethod (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    )
/*++

Routine Description:

    Run _Rxx for the alarm

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER inputBuffer;

    SmbPrint(SMB_ALARMS, ("SmbCRunAlarmMethod: Running Control method _R%02x\n", Address));
    
    inputBuffer = ExAllocatePoolWithTag (
        NonPagedPool,
        sizeof (ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
        'AbmS'
        );
    RtlZeroMemory( inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER) );
    inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer->MethodNameAsUlong = '00Q_';
    inputBuffer->MethodName[2] = gHexDigits[ Address / 16];
    inputBuffer->MethodName[3] = gHexDigits[ Address % 16];
    inputBuffer->IntegerArgument = Data;

    irp = IoAllocateIrp (SmbClass->LowerDeviceObject->StackSize, FALSE);
    if (!irp) {
        return;
    }
    
    irp->AssociatedIrp.SystemBuffer = inputBuffer;

    ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
    irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

    irp->UserBuffer = NULL;

    IoSetCompletionRoutine(
        irp,
        SmbCRunAlarmMethodCompletionRoutine,
        NULL, // No Context  This just frees the IRP
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(SmbClass->LowerDeviceObject, irp);

}


VOID
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    )
/*++

Routine Description:

    Miniport has an alarm input

--*/
{
    PSMBDATA            Smb;
    PSMB_ALARM      SmbAlarm;
    PLIST_ENTRY     Entry, NextEntry;
    BOOLEAN         AlarmRegistered = FALSE;

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
    ASSERT_DEVICE_LOCKED (Smb);

    Entry = Smb->Alarms.Flink;
    while (Entry != &Smb->Alarms) {
        SmbAlarm = CONTAINING_RECORD (Entry, SMB_ALARM, Link);

        //
        // If notification is for this address, issue it
        //

        if (Address >= SmbAlarm->MinAddress && Address <= SmbAlarm->MaxAddress) {

            //
            // A driver has registered for this notification.  Don't call the BIOS.
            //
            AlarmRegistered = TRUE;

            //
            // Raise reference count before calling notifcation function
            //

            SmbAlarm->Reference += 1;
            ASSERT (SmbAlarm->Reference != 0);
            SmbClassUnlockDevice (SmbClass);

            //
            // Issue notification
            //

            SmbAlarm->NotifyFunction (SmbAlarm->NotifyContext, Address, Data);

            //
            // Continue
            //

            SmbClassLockDevice (SmbClass);
            SmbAlarm->Reference -= 1;
        }

        //
        // Get next entry
        //

        NextEntry = Entry->Flink;

        //
        // If entry is pending delete, hand it to deleting thread
        //

        if (SmbAlarm->Flag & SMBC_ALARM_DELETE_PENDING) {
            SmbCCheckAlarmDelete (Smb, SmbAlarm);

        }

        //
        // Move on
        //

        Entry = NextEntry;
    }

    //
    // If no one registered for this alarm, call the _Rxx control method
    //
    if (!AlarmRegistered) {
        
        SmbCRunAlarmMethod (SmbClass, Address, Data);

    }
}

VOID
SmbCCheckAlarmDelete (
    IN PSMBDATA         Smb,
    IN PSMB_ALARM   SmbAlarm
    )
{
    //
    // If alarm structure is referenced, wait somemore
    //

    if (SmbAlarm->Reference) {
        return ;
    }


    //
    // Time to free it.  Remove it from the notification list, clear
    // the pending flag and set the event to let waiting threads know
    // that some entry was removed
    //

    RemoveEntryList (&SmbAlarm->Link);
    SmbAlarm->Flag &= ~SMBC_ALARM_DELETE_PENDING;
    KeSetEvent (&Smb->AlarmEvent, 0, FALSE);
}

NTSTATUS
SmbCRegisterAlarm (
    PSMBDATA        Smb,
    PIRP        Irp
    )
/*++

Routine Description:

    Called to register for an alarm event

--*/
{
    PVOID               LockPtr;
    PSMB_ALARM          SmbAlarm, *Result;
    PSMB_REGISTER_ALARM RegAlarm;
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (ExGetPreviousMode() != KernelMode ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SMB_REGISTER_ALARM) ||
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PSMB_ALARM) ) {

        return STATUS_INVALID_PARAMETER;
    }

    RegAlarm = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    SmbAlarm = ExAllocatePoolWithTag (
                    NonPagedPool,
                    sizeof (SMB_ALARM),
                    'AbmS'
                    );

    if (!SmbAlarm) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SmbAlarm->Flag = 0;
    SmbAlarm->Reference = 0;
    SmbAlarm->MinAddress     = RegAlarm->MinAddress;
    SmbAlarm->MaxAddress     = RegAlarm->MaxAddress;
    SmbAlarm->NotifyFunction = RegAlarm->NotifyFunction;
    SmbAlarm->NotifyContext  = RegAlarm->NotifyContext;


    //
    // Add it to the alarm notification list
    //

    LockPtr = MmLockPagableCodeSection(SmbCRegisterAlarm);
    SmbClassLockDevice (&Smb->Class);
    InsertTailList (&Smb->Alarms, &SmbAlarm->Link);
    SmbClassUnlockDevice (&Smb->Class);
    MmUnlockPagableImageSection(LockPtr);

    //
    // Return value caller needs to deregister with
    //

    Result  = (PSMB_ALARM *) Irp->UserBuffer;
    *Result = SmbAlarm;
    Irp->IoStatus.Information = sizeof(PSMB_ALARM);

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCDeregisterAlarm (
    PSMBDATA        Smb,
    PIRP        Irp
    )
/*++

Routine Description:

    Called to register for an alarm event

--*/
{
    PVOID               LockPtr;
    PSMB_ALARM          SmbAlarm;
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (ExGetPreviousMode() != KernelMode ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PSMB_ALARM) ) {
        return STATUS_INVALID_PARAMETER;
    }

    SmbAlarm = * (PSMB_ALARM *) IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    LockPtr = MmLockPagableCodeSection(SmbCDeregisterAlarm);
    SmbClassLockDevice (&Smb->Class);

    //
    // Flag alarm structure as delete pending
    //


    SmbAlarm->Flag |= SMBC_ALARM_DELETE_PENDING;

    //
    // While delete is pending wait
    //

    while (SmbAlarm->Flag & SMBC_ALARM_DELETE_PENDING) {

        //
        // Issue bogus alarm to generate freeing
        //

        KeResetEvent (&Smb->AlarmEvent);
        SmbClassAlarm (&Smb->Class, 0xFF, 0);

        //
        // Wait for alarm structure to get freed, then check if it
        // was ours
        //

        SmbClassUnlockDevice (&Smb->Class);
        KeWaitForSingleObject (
            &Smb->AlarmEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        SmbClassLockDevice (&Smb->Class);
    }

    //
    // It's been removed, free the memory
    //

    SmbClassUnlockDevice (&Smb->Class);
    MmUnlockPagableImageSection(LockPtr);

    ExFreePool (SmbAlarm);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbclass\smbclass.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbclass.c

Abstract:

    SMBus Class Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:
    27-Feb-97
        Pnp support - Bob Moore

--*/

#include "smbc.h"



ULONG   SMBCDebug = SMB_ERRORS;

//
// Prototypes
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SmbClassDeviceInitialize (
    PSMB_CLASS      SmbClass
    );

VOID
SmbCUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SmbCOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCInternalIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,SmbClassInitializeDevice)
#pragma alloc_text(PAGE,SmbCOpenClose)
#pragma alloc_text(PAGE,SmbCUnload)
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{

    return STATUS_SUCCESS;
}


NTSTATUS
SmbClassInitializeDevice (
    IN ULONG            MajorVersion,
    IN ULONG            MinorVersion,
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    This function is called by the SM bus miniport driver/DriverEntry
    to perform class specific initialization

Arguments:

    MajorVersion    - Version #
    MinorVersion    - Version #
    DriverObject    - From miniport DriverEntry

Return Value:

    Status

--*/
{

    if (MajorVersion != SMB_CLASS_MAJOR_VERSION) {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverUnload                  = SmbCUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE]  = SmbCOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = SmbCOpenClose;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = SmbCPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]     = SmbCPnpDispatch;

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = SmbCInternalIoctl;

//    DriverObject->MajorFunction[IRP_MJ_READ]    = SmbCForwardRequest;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SmbCForwardRequest;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SmbCForwardRequest;

    //
    // Miniport will set up the AddDevice entry
    //

    return STATUS_SUCCESS;

}



VOID
SmbCUnload(
    IN PDRIVER_OBJECT   DriverObject
    )
{
    SmbPrint (SMB_NOTE, ("SmBCUnLoad: \n"));

    if (DriverObject->DeviceObject != NULL) {
        SmbPrint (SMB_ERROR, ("SmBCUnLoad: Unload called before all devices removed.\n"));
    }
}


NTSTATUS
SmbCOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}


NTSTATUS
SmbCPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for power requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PSMBDATA            SmbData;
    NTSTATUS            status;

    SmbData = DeviceObject->DeviceExtension;

    //
    // What do we do with the irp?
    //
    PoStartNextPowerIrp( Irp );
    if (SmbData->Class.LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( SmbData->Class.LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}


NTSTATUS
SmbCInternalIoctl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal IOCTLs.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PSMB_REQUEST        SmbReq;
    PSMBDATA                Smb;
    NTSTATUS            Status;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    Status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Information = 0;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Smb = (PSMBDATA) DeviceObject->DeviceExtension;


    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case SMB_BUS_REQUEST:

            //
            // Verify bus request is valid
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SMB_REQUEST)) {

                // Invalid buffer length
                SmbPrint(SMB_NOTE, ("SmbCIoctl: Invalid bus_req length\n"));
                Status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(SMB_REQUEST);
                break;
            }

            SmbReq = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            if (SmbReq->Protocol > SMB_MAXIMUM_PROTOCOL ||
                SmbReq->Address  > 0x7F ||
                (SmbReq->Protocol == SMB_WRITE_BLOCK &&
                 SmbReq->BlockLength > SMB_MAX_DATA_SIZE)) {

                // Invalid param in request
                SmbPrint(SMB_NOTE, ("SmbCIoctl: Invalid bus_req\n"));
                break;
            }

            //
            // Mark request pending and queue it to the service queue
            //

            Status = STATUS_PENDING;
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending (Irp);

            SmbClassLockDevice (&Smb->Class);
            InsertTailList (&Smb->WorkQueue, &Irp->Tail.Overlay.ListEntry);

            //
            // Start IO if needed
            //

            SmbClassStartIo (Smb);
            SmbClassUnlockDevice (&Smb->Class);
            break;

        case SMB_REGISTER_ALARM_NOTIFY:

            //
            // Registry for alarm notifications
            //

            Status = SmbCRegisterAlarm (Smb, Irp);
            break;

        case SMB_DEREGISTER_ALARM_NOTIFY:

            //
            // Deregister for alarm notifications
            //

            Status = SmbCDeregisterAlarm (Smb, Irp);
            break;

        default:
            // complete with invalid parameter
            break;
    }


    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
SmbCForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine forwards the irp down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    Status;
    PSMBDATA    Smb = (PSMBDATA) DeviceObject->DeviceExtension;

    if (Smb->Class.LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        Status = IoCallDriver( Smb->Class.LowerDeviceObject, Irp );

    } else {

        Status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbclass\smbcoprg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcpnp.c

Abstract:

    SMBus Class Driver Plug and Play support

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"


NTSTATUS
SmbCRawOpRegionCompletion (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    This routine starts or continues servicing the device's work queue

Arguments:

    DeviceObject    - EC device object
    Irp             - Completing Irp
    Context         - Note used

Return Value:

    Status

--*/
{
    PACPI_OPREGION_CALLBACK completionHandler;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVOID                   completionContext;
    PFIELDUNITOBJ           FieldUnit;
    POBJDATA                Data;
    PBUFFERACC_BUFFER       dataBuffer;
    PSMB_REQUEST            request;
    ULONG                   i;

    //
    // Grab the arguments from the irp
    //
    completionHandler = (PACPI_OPREGION_CALLBACK) irpSp->Parameters.Others.Argument1;
    completionContext = (PVOID) irpSp->Parameters.Others.Argument2;
    FieldUnit = (PFIELDUNITOBJ) irpSp->Parameters.Others.Argument3;
    Data = (POBJDATA) irpSp->Parameters.Others.Argument4;

    SmbPrint(
        SMB_HANDLER,
        ("SmbCRawOpRegionCompletion: Callback: %08lx Context: %08lx "
         "Status: %08lx\n",
         completionHandler, completionContext, Irp->IoStatus.Status )
        );

    //
    // Copy the results into the buffer for a read.
    //

    request = (PSMB_REQUEST) Data->uipDataValue;
    Data->uipDataValue = 0;
    dataBuffer = (PBUFFERACC_BUFFER) Data->pbDataBuff;

    
    dataBuffer->Status = request->Status;
    switch (request->Protocol) {
    case SMB_RECEIVE_BYTE:
    case SMB_READ_BYTE:
    case SMB_READ_WORD:
    case SMB_READ_BLOCK:
    case SMB_PROCESS_CALL:
    case SMB_BLOCK_PROCESS_CALL:

        //
        // There is data to return
        //

        if (request->Status != SMB_STATUS_OK) {
            SmbPrint(SMB_ERROR, ("SmbCRawOpRegionCompletion: SMBus error %x\n", request->Status));
            dataBuffer->Length = 0xff;
            RtlFillMemory (dataBuffer->Data, 32, 0xff);
        } else {
            if ((request->Protocol == SMB_READ_BLOCK) || (request->Protocol == SMB_BLOCK_PROCESS_CALL)) {

                RtlCopyMemory (dataBuffer->Data, request->Data, request->BlockLength); 
                dataBuffer->Length = request->BlockLength;
            } else {
                *(PULONG)dataBuffer->Data = *((PULONG)(request->Data));
                dataBuffer->Length = 0xff;
                // This field is reseved for all but block accesses
            }
        }
    }

    //
    // Invoke the AML interpreter's callback
    //
    (completionHandler)( completionContext);

    //
    // We are done with this irp
    //

    ExFreePool (request);

    IoFreeIrp (Irp);

    //
    // Return this always --- we had to free the irp ourselves
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS EXPORT
SmbCRawOpRegionHandler (
    ULONG                   AccessType,
    PFIELDUNITOBJ           FieldUnit,
    POBJDATA                Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

    This routine handles requests to service the EC operation region

Arguments:

    AccessType          - Read or Write data
    FieldUnit           - Opregion field info (address, command, protocol, etc.)
    Data                - Data Buffer
    Context             - SMBDATA
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler

Return Value:

    Status

Notes:

    Could this be optimized by bypassing some of the IO subsystem?

--*/
{
    NTSTATUS            status;
    PIRP                irp = NULL;
    PIO_STACK_LOCATION  irpSp;
    PSMBDATA            smbData = (PSMBDATA) Context;
    PSMB_REQUEST        request = NULL;

    PNSOBJ              opRegion;
    PBUFFERACC_BUFFER   dataBuffer;

    ULONG               accType = FieldUnit->FieldDesc.dwFieldFlags & ACCTYPE_MASK;
    ULONG               i;

//    DbgBreakPoint ();

    SmbPrint(
        SMB_HANDLER,
        ("SmbCRawOpRegionHandler: Entered - NSObj(%08x) ByteOfs(%08x) Start(%08x)"
         " Num(%08x) Flags(%08x)\n",
         FieldUnit->pnsFieldParent,
         FieldUnit->FieldDesc.dwByteOffset,
         FieldUnit->FieldDesc.dwStartBitPos,
         FieldUnit->FieldDesc.dwNumBits,
         FieldUnit->FieldDesc.dwFieldFlags)
        );

    //
    // Parameter validation
    //

    if (accType != ACCTYPE_BUFFER) {
        SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid Access type = 0x%08x should be ACCTYPE_BUFFER\n", accType) );
        goto SmbCOpRegionHandlerError;
    }
    
    if (AccessType == ACPI_OPREGION_WRITE) {
        if (Data->dwDataType != OBJTYPE_BUFFDATA) {
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid dwDataType = 0x%08x should be OBJTYPE_BUFFDATA\n", Data->dwDataType) );
            goto SmbCOpRegionHandlerError;
        }
        if (Data->dwDataLen != sizeof(BUFFERACC_BUFFER)) {
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid dwDataLen = 0x%08x should be 0x%08x\n", Data->dwDataLen, sizeof(BUFFERACC_BUFFER)) );
            goto SmbCOpRegionHandlerError;
        }
    } else if (AccessType == ACPI_OPREGION_READ) {
        if ((Data->dwDataType != OBJTYPE_BUFFDATA) || (Data->pbDataBuff == NULL)) {
            Data->dwDataType = OBJTYPE_INTDATA;
            Data->dwDataValue = sizeof(BUFFERACC_BUFFER);

            return STATUS_BUFFER_TOO_SMALL;
        }
        if (Data->dwDataLen != sizeof(BUFFERACC_BUFFER)) {
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid dwDataLen = 0x%08x should be 0x%08x\n", Data->dwDataLen, sizeof(BUFFERACC_BUFFER)) );
            goto SmbCOpRegionHandlerError;
        }
    } else {
        SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid AccessType = 0x%08x\n", AccessType) );
        goto SmbCOpRegionHandlerError;
    }
    

    //
    // Allocate an IRP for below. Allocate one extra stack location to store
    // some data in.
    //

    irp = IoAllocateIrp((CCHAR)(smbData->Class.DeviceObject->StackSize + 1),
                        FALSE
                        );

    request = ExAllocatePoolWithTag (NonPagedPool, sizeof (SMB_REQUEST), 'CbmS');

    if (!irp || !request) {
        SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Cannot allocate irp\n") );

        goto SmbCOpRegionHandlerError;
    }

    //
    // Fill in the top location so that we can use it ourselves
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.Others.Argument1 = (PVOID) CompletionHandler;
    irpSp->Parameters.Others.Argument2 = (PVOID) CompletionContext;
    irpSp->Parameters.Others.Argument3 = (PVOID) FieldUnit;
    irpSp->Parameters.Others.Argument4 = (PVOID) Data;
    IoSetNextIrpStackLocation( irp );

    //
    // Fill out the irp with the request info
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = SMB_BUS_REQUEST;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SMB_REQUEST);
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = request;

    request->Status = 0;

    //
    // Translate between Opregion Protocols and smbus protocols
    // and fill copy data.
    //

    
    //
    // Copy data into data buffer for writes.
    //
    dataBuffer = (PBUFFERACC_BUFFER)Data->pbDataBuff;
    
    if (AccessType == ACPI_OPREGION_WRITE) {
        switch ((FieldUnit->FieldDesc.dwFieldFlags & FDF_ACCATTRIB_MASK) >> 8) {
        case SMB_QUICK:
            break;
        case SMB_SEND_RECEIVE:
        case SMB_BYTE:
            *((PUCHAR) (request->Data)) = *((PUCHAR) (dataBuffer->Data));

            break;
        case SMB_WORD:
        case SMB_PROCESS:
            *((PUSHORT) (request->Data)) = *((PUSHORT) (dataBuffer->Data));
            break;
        case SMB_BLOCK:
        case SMB_BLOCK_PROCESS:
            dataBuffer = (PBUFFERACC_BUFFER)Data->pbDataBuff;
            for (i = 0; i < dataBuffer->Length; i++) {
                request->Data[i] = dataBuffer->Data[i];
            }

            request->BlockLength = (UCHAR) dataBuffer->Length;
            break;
        default:
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid AccessAs: FieldFlags = 0x%08x\n", FieldUnit->FieldDesc.dwFieldFlags) );
            goto SmbCOpRegionHandlerError;
        }
    }

    //
    // Determine protocol
    //

    request->Protocol = (UCHAR) ((FieldUnit->FieldDesc.dwFieldFlags & FDF_ACCATTRIB_MASK) >> 8);
    if ((request->Protocol < SMB_QUICK) || (request->Protocol > SMB_BLOCK_PROCESS)) {
        SmbPrint (SMB_ERROR, ("SmbCRawOpRegionHandler: BIOS BUG Unknown Protocol (access attribute) 0x%02x.\n", request->Protocol));
        ASSERTMSG ("SmbCRawOpRegionHandler:  Access type DWordAcc is not suported for SMB opregions.\n", FALSE);
        goto SmbCOpRegionHandlerError;
    } 
    if (request->Protocol <= SMB_BLOCK) {
        request->Protocol -= (AccessType == ACPI_OPREGION_READ) ? 1 : 2;
    } else {
        request->Protocol -= 2;
    }
    SmbPrint(SMB_HANDLER, 
             ("SmbCRawOpRegionHandler: request->Protocol = %08x\n", request->Protocol)); 



    //
    // Find the Slave address nd Command value (not used for all protocols)
    //
    request->Address = (UCHAR) ((FieldUnit->FieldDesc.dwByteOffset >> 8) & 0xff);
    request->Command = (UCHAR) (FieldUnit->FieldDesc.dwByteOffset & 0xff);


    //
    // Pass Pointer to request in the data structure because
    // there is not enough space in the irp stack.
    // If this is a write, the data has already been copied out.
    // If this is a read, we will read the value of request before 
    // copying the result data.
    //
    Data->uipDataValue = (ULONG_PTR) request;

    //
    // Set a completion routine
    //
    IoSetCompletionRoutine(
        irp,
        SmbCRawOpRegionCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Send to the front-end of the SMB driver as a normal I/O request
    //
    status = IoCallDriver (smbData->Class.DeviceObject, irp);

    if (!NT_SUCCESS(status)) {
        SmbPrint (SMB_ERROR, ("SmbCRawOpRegionHandler: Irp failed with status %08x\n", status));
        goto SmbCOpRegionHandlerError;
    }

    SmbPrint(
        SMB_HANDLER,
        ("SmbCRawOpRegionHandler: Exiting - Data=%x Status=%x\n",
         Data->uipDataValue, status)
        );


    return status;

SmbCOpRegionHandlerError:
    if (irp) {
        IoFreeIrp (irp);
    }
    if (request) {
        ExFreePool (request);
    }

    Data->uipDataValue = 0xffffffff;
    Data->dwDataLen = 0;
    CompletionHandler( CompletionContext );

    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbclass\smbc.h ===
#define SMBCLASS    1

#include <wdm.h>
#include <smbus.h>
#include <devioctl.h>
#include <acpiioct.h>
#include <acpimsft.h>

#define _INC_NSOBJ_ONLY
#include <amli.h>
#include <aml.h>

#if DBG
#define DEBUG   1
#else
#define DEBUG   0
#endif

//
// Debug
//

extern ULONG SMBCDebug;

#if DEBUG
    #define SmbPrint(l,m)               if(l & SMBCDebug) DbgPrint m
    #define ASSERT_DEVICE_LOCKED(a)     ASSERT(a->SpinLockAcquired);
#else
    #define SmbPrint(l,m)
    #define ASSERT_DEVICE_LOCKED(a)
#endif

#define SMB_LOW         0x00000010
#define SMB_STATE       0x00000020
#define SMB_HANDLER     0x00000040
#define SMB_ALARMS      0x00000080
#define SMB_NOTE        0x00000001
#define SMB_WARN        0x00000002
#define SMB_ERROR       0x00000004
#define SMB_ERRORS      (SMB_ERROR | SMB_WARN)
#define SMB_TRANSACTION 0x00000100


//
// Internal SMB class data
//


#define MAX_RETRIES     5
#define RETRY_TIME      -800000             // Delay 80ms

//typedef
//VOID
//(*SMB_ALARM_NOTIFY)(
//    IN PVOID            Context,
//    IN USHORT           AlarmData
//    );

typedef struct {
    LIST_ENTRY          Link;               // List of all alarm notifies
    UCHAR               Flag;
    UCHAR               Reference;
    UCHAR               MinAddress;         // Min address on bus
    UCHAR               MaxAddress;         // Max address
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;

} SMB_ALARM, *PSMB_ALARM;

#define SMBC_ALARM_DELETE_PENDING     0x01


typedef struct {
    SMB_CLASS           Class;              // Shared Class/Miniport data

    KSPIN_LOCK          SpinLock;           // Lock device data
    KIRQL               SpinLockIrql;       // Irql spinlock acquired at
    BOOLEAN             SpinLockAcquired;   // Debug only

    //
    // Alarm notifies
    //

    LIST_ENTRY          Alarms;             // List of all Alarm notifies
    KEVENT              AlarmEvent;         // Used to delete alarms

    //
    // IO
    //

    LIST_ENTRY          WorkQueue;          // Queued IO IRPs to the device
    BOOLEAN             InService;          // Irp
    UCHAR               IoState;

    //
    // Current IO request
    //

    UCHAR               RetryCount;
    KTIMER              RetryTimer;
    KDPC                RetryDpc;

    //
    // Operation Region
    //

    PVOID               RawOperationRegionObject;

} SMBDATA, *PSMBDATA;

//
// IoState
//

#define SMBC_IDLE                       0
#define SMBC_START_REQUEST              1
#define SMBC_WAITING_FOR_REQUEST        2
#define SMBC_COMPLETE_REQUEST           3
#define SMBC_COMPLETING_REQUEST         4
#define SMBC_WAITING_FOR_RETRY          5


//
// ACPI SMBus opregion details
//

typedef struct {
    UCHAR        Status;
    UCHAR        Length;
    UCHAR        Data [32];
} BUFFERACC_BUFFER, *PBUFFERACC_BUFFER;

#define SMB_QUICK 0x02
#define SMB_SEND_RECEIVE 0x04
#define SMB_BYTE 0x06
#define SMB_WORD 0x08
#define SMB_BLOCK 0x0a
#define SMB_PROCESS 0x0c
#define SMB_BLOCK_PROCESS 0x0d

//
// Prototypes
//

VOID
SmbClassStartIo (
    IN PSMBDATA             Smb
    );

VOID
SmbCRetry (
    IN struct _KDPC         *Dpc,
    IN PVOID                DeferredContext,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    );


NTSTATUS
SmbCRegisterAlarm (
    PSMBDATA                Smb,
    PIRP                    Irp
    );

NTSTATUS
SmbCDeregisterAlarm (
    PSMBDATA                Smb,
    PIRP                    Irp
    );

NTSTATUS EXPORT
SmbCRawOpRegionHandler (
    ULONG                   AccessType,
    PFIELDUNITOBJ           FieldUnit,
    POBJDATA                Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
SmbCRawOpRegionCompletion (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

NTSTATUS
SmbCSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              IoCompletionEvent
    );

//
// Io extension macro to just pass on the Irp to a lower driver
//

#define SmbCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbclass\smbcsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcsrv.c

Abstract:

    SMBus class driver service functions

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"


VOID
SmbCRetry (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    Handles retry timer

--*/
{
    PSMBDATA    Smb;

    Smb = (PSMBDATA) DeferredContext;
    SmbClassLockDevice (&Smb->Class);

    //
    // State is waiting for retry, move it to send request
    //
    ASSERT (Smb->IoState == SMBC_WAITING_FOR_RETRY);
    Smb->IoState = SMBC_START_REQUEST;
    SmbClassStartIo (Smb);

    SmbClassUnlockDevice (&Smb->Class);
}

VOID
SmbClassStartIo (
    IN PSMBDATA         Smb
    )
/*++

Routine Description:

    Main class driver state loop

    N.B. device lock is held by caller.
    N.B. device lock may be released and re-acquired during call

--*/
{
    PLIST_ENTRY         Entry;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    PSMB_REQUEST        SmbReq;
    LARGE_INTEGER       duetime;

    //
    // If already servicing the device, done
    //

    if (Smb->InService) {
        return ;
    }


    //
    // Service the device
    //

    Smb->InService = TRUE;
    while (Smb->InService) {
        ASSERT_DEVICE_LOCKED (Smb);

        switch (Smb->IoState) {
            case SMBC_IDLE:
                //
                // Check if there is a request to give to the miniport
                //

                ASSERT (!Smb->Class.CurrentIrp);
                if (IsListEmpty(&Smb->WorkQueue)) {
                    // nothing to do, stop servicing the device
                    Smb->InService = FALSE;
                    break;
                }

                //
                // Get the next IRP
                //

                Entry = RemoveHeadList(&Smb->WorkQueue);
                Irp = CONTAINING_RECORD (
                            Entry,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

                //
                // Make it the current request
                //

                Smb->RetryCount = 0;
                Smb->Class.DeviceObject->CurrentIrp = Irp;

                Smb->IoState = SMBC_START_REQUEST;
                break;

            case SMBC_START_REQUEST:
                //
                // Tell miniport to start on this request
                //

                Irp = Smb->Class.DeviceObject->CurrentIrp;
                IrpSp = IoGetCurrentIrpStackLocation(Irp);
                Smb->Class.CurrentIrp = Irp;
                Smb->Class.CurrentSmb = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                Smb->IoState = SMBC_WAITING_FOR_REQUEST;
                
                #if DEBUG 
                if (SMBCDebug & SMB_TRANSACTION) {
                    PUCHAR protocols [SMB_MAXIMUM_PROTOCOL+1] = {
                        "SMB_WRITE_QUICK",
                        "SMB_READ_QUICK",
                        "SMB_SEND_BYTE",
                        "SMB_RECEIVE_BYTE",
                        "SMB_WRITE_BYTE",
                        "SMB_READ_BYTE",
                        "SMB_WRITE_WORD",
                        "SMB_READ_WORD",
                        "SMB_WRITE_BLOCK",
                        "SMB_READ_BLOCK",
                        "SMB_PROCESS_CALL",
                        "SMB_BLOCK_PROCESS_CALL"};
                    UCHAR i;
                    
                    SmbPrint (SMB_TRANSACTION, ("SmbClassStartIo: started %s (%02x) Add: %02x", 
                                                (Smb->Class.CurrentSmb->Protocol <= SMB_MAXIMUM_PROTOCOL) ?
                                                    protocols[Smb->Class.CurrentSmb->Protocol] : "BAD PROTOCOL",
                                                Smb->Class.CurrentSmb->Protocol, Smb->Class.CurrentSmb->Address));
                    switch (Smb->Class.CurrentSmb->Protocol) {
                    case SMB_WRITE_QUICK:
                    case SMB_READ_QUICK:
                    case SMB_RECEIVE_BYTE:
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                        break;
                    case SMB_SEND_BYTE:
                        SmbPrint (SMB_TRANSACTION, (", Data: %02x\n", Smb->Class.CurrentSmb->Data[0]));
                        break;
                    case SMB_WRITE_BYTE:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %02x\n", 
                                                    Smb->Class.CurrentSmb->Command, Smb->Class.CurrentSmb->Data[0]));
                        break;
                    case SMB_READ_BYTE:
                    case SMB_READ_WORD:
                    case SMB_READ_BLOCK:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x\n",
                                                    Smb->Class.CurrentSmb->Command));
                        break;
                    case SMB_WRITE_WORD:
                    case SMB_PROCESS_CALL:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %04x\n", 
                                                    Smb->Class.CurrentSmb->Command, *((PUSHORT)Smb->Class.CurrentSmb->Data)));
                        break;
                    case SMB_WRITE_BLOCK:
                    case SMB_BLOCK_PROCESS_CALL:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x, Len: %02x, Data:", 
                                                    Smb->Class.CurrentSmb->Command, Smb->Class.CurrentSmb->BlockLength));
                        for (i=0; i < Smb->Class.CurrentSmb->BlockLength; i++) {
                            SmbPrint (SMB_TRANSACTION, (" %02x", Smb->Class.CurrentSmb->Data[i]));

                        }
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                        break;
                    default:
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                    }
                }
                #endif

                Smb->Class.StartIo (&Smb->Class, Smb->Class.Miniport);
                break;

            case SMBC_WAITING_FOR_REQUEST:
                //
                // Waiting for miniport, just keep waiting
                //

                Smb->InService = FALSE;
                break;

            case SMBC_COMPLETE_REQUEST:
                //
                // Miniport has returned the request
                //

                Irp = Smb->Class.DeviceObject->CurrentIrp;
                IrpSp = IoGetCurrentIrpStackLocation(Irp);
                SmbReq = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                #if DEBUG 
                if (SMBCDebug & SMB_TRANSACTION) {
                    PUCHAR protocols [SMB_MAXIMUM_PROTOCOL+1] = {
                        "SMB_WRITE_QUICK",
                        "SMB_READ_QUICK",
                        "SMB_SEND_BYTE",
                        "SMB_RECEIVE_BYTE",
                        "SMB_WRITE_BYTE",
                        "SMB_READ_BYTE",
                        "SMB_WRITE_WORD",
                        "SMB_READ_WORD",
                        "SMB_WRITE_BLOCK",
                        "SMB_READ_BLOCK",
                        "SMB_PROCESS_CALL",
                        "SMB_BLOCK_PROCESS_CALL"};
                    UCHAR i;
                    
                    SmbPrint (SMB_TRANSACTION, ("SmbClassStartIo: finished %s (%02x) Status: %02x, Add: %02x", 
                                                (SmbReq->Protocol <= SMB_MAXIMUM_PROTOCOL) ?
                                                    protocols[SmbReq->Protocol] : "BAD PROTOCOL",
                                                SmbReq->Protocol, SmbReq->Status, SmbReq->Address));
                    if (SmbReq->Status != SMB_STATUS_OK) {
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                    } else {
                        switch (SmbReq->Protocol) {
                        case SMB_WRITE_QUICK:
                        case SMB_READ_QUICK:
                        case SMB_SEND_BYTE:
                            SmbPrint (SMB_TRANSACTION, ("\n"));
                            break;
                        case SMB_RECEIVE_BYTE:
                            SmbPrint (SMB_TRANSACTION, (", Data: %02x\n", SmbReq->Data[0]));
                            break;
                        case SMB_READ_BYTE:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %02x\n", 
                                                        SmbReq->Command, SmbReq->Data[0]));
                            break;
                        case SMB_WRITE_BYTE:
                        case SMB_WRITE_WORD:
                        case SMB_WRITE_BLOCK:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x\n",
                                                        SmbReq->Command));
                            break;
                        case SMB_READ_WORD:
                        case SMB_PROCESS_CALL:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %04x\n", 
                                                        SmbReq->Command, *((PUSHORT)SmbReq->Data)));
                            break;
                        case SMB_READ_BLOCK:
                        case SMB_BLOCK_PROCESS_CALL:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x, Len: %02x, Data:", 
                                                        SmbReq->Command, SmbReq->BlockLength));
                            for (i=0; i < SmbReq->BlockLength; i++) {
                                SmbPrint (SMB_TRANSACTION, (" %02x", SmbReq->Data[i]));

                            }
                            SmbPrint (SMB_TRANSACTION, ("\n"));
                            break;
                        default:
                            SmbPrint (SMB_TRANSACTION, ("\n"));
                        }
                    }
                }
                #endif


                if (SmbReq->Status != SMB_STATUS_OK) {

                    //
                    // SMB request had an error, check for a retry
                    //

                    SmbPrint (SMB_WARN, ("SmbCStartIo: smb request error %x\n", SmbReq->Status));
                    if (Smb->RetryCount < MAX_RETRIES) {
                        Smb->RetryCount += 1;
                        Smb->IoState = SMBC_WAITING_FOR_RETRY;

                        duetime.QuadPart = RETRY_TIME;
                        KeSetTimer (&Smb->RetryTimer, duetime, &Smb->RetryDpc);
                        break;
                    }

                }

                //
                // Complete the request
                //

                Smb->Class.DeviceObject->CurrentIrp = NULL;
                Smb->IoState = SMBC_COMPLETING_REQUEST;
                SmbClassUnlockDevice (&Smb->Class);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
                SmbClassLockDevice (&Smb->Class);

                //
                // Now idle
                //

                Smb->IoState = SMBC_IDLE;
                break;

            case SMBC_WAITING_FOR_RETRY:
                //
                // Waiting to retry, just keep waiting
                //

                Smb->InService = FALSE;
                break;

            default:
                SmbPrint(SMB_ERROR, ("SmbCStartIo: unknown state\n"));
                Smb->IoState = SMBC_IDLE;
                Smb->InService = FALSE;
                break;
        }
    }

    return ;
}

VOID
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    )
/*++

Routine Description:

    Called by the miniport to complete the request it was given

    N.B. device lock is held by caller.
    N.B. device lock may be released and re-acquired during call

--*/
{
    PSMBDATA        Smb;

    //
    // Device must be locked, and waiting for a request to compelte
    //

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
    ASSERT_DEVICE_LOCKED (Smb);
    ASSERT (Smb->IoState == SMBC_WAITING_FOR_REQUEST);

    //
    // No irp at miniport
    //

    SmbClass->CurrentIrp = NULL;
    SmbClass->CurrentSmb = NULL;

    //
    // Update state to complete it and handle it
    //

    Smb->IoState = SMBC_COMPLETE_REQUEST;
    SmbClassStartIo (Smb);
}

VOID
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    )
/*++

Routine Description:

    Called to acquire the device lock

--*/
{
    PSMBDATA        Smb;

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
    KeAcquireSpinLock (&Smb->SpinLock, &Smb->SpinLockIrql);
#if DEBUG
    ASSERT (!Smb->SpinLockAcquired);
    Smb->SpinLockAcquired = TRUE;
#endif
}


VOID
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    )
/*++

Routine Description:

    Called to release the device lock

--*/
{
    PSMBDATA        Smb;

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
#if DEBUG
    ASSERT_DEVICE_LOCKED (Smb);
    Smb->SpinLockAcquired = FALSE;
#endif
    KeReleaseSpinLock (&Smb->SpinLock, Smb->SpinLockIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbclass\smbcpnp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcpnp.c

Abstract:

    SMBus Class Driver Plug and Play support

Author:

    Bob Moore (Intel)

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"
#include "oprghdlr.h"


#define SMBHC_DEVICE_NAME       L"\\Device\\SmbHc"
extern ULONG   SMBCDebug;

//
// Prototypes
//

NTSTATUS
SmbCPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
SmbCStartDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    );

NTSTATUS
SmbCStopDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    );

NTSTATUS
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbCPnpDispatch)
#pragma alloc_text(PAGE,SmbCStartDevice)
#pragma alloc_text(PAGE,SmbClassCreateFdo)
#endif


NTSTATUS
SmbCPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatcher for plug and play requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PSMBDATA            SmbData;
    KEVENT              syncEvent;
    NTSTATUS            status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    SmbData = (PSMBDATA) DeviceObject->DeviceExtension;

    SmbPrint (SMB_NOTE, ("SmbCPnpDispatch: PnP dispatch, minor = %d\n",
                        irpStack->MinorFunction));

    //
    // Dispatch minor function
    //

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:
            IoCopyCurrentIrpStackLocationToNext (Irp);

            KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

            IoSetCompletionRoutine(Irp, SmbCSynchronousRequest, &syncEvent, TRUE, TRUE, TRUE);

            status = IoCallDriver(SmbData->Class.LowerDeviceObject, Irp);

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                status = Irp->IoStatus.Status;
            }
            
            status = SmbCStartDevice (DeviceObject, Irp);
            
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
            return status;


    case IRP_MN_STOP_DEVICE:
            status = SmbCStopDevice(DeviceObject, Irp);
            break;


    case IRP_MN_QUERY_STOP_DEVICE:

            SmbPrint(SMB_LOW, ("SmbCPnp: IRP_MN_QUERY_STOP_DEVICE\n"));

            status = STATUS_SUCCESS;
            break;


    case IRP_MN_CANCEL_STOP_DEVICE:

            SmbPrint(SMB_LOW, ("SmbCPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));

            status = STATUS_SUCCESS;
            break;


    default:
            SmbPrint(SMB_LOW, ("SmbCPnp: Unimplemented PNP minor code %d\n",
                    irpStack->MinorFunction));
    }

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;
    }

    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver(SmbData->Class.LowerDeviceObject, Irp) ;

    } else {

        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    }

    return status;
}



NTSTATUS
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *OutFDO
    )
/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a SMBus Host controller PDO.  It is called from the miniport
    AddDevice routine.

Arguments:

    DriverObject            - a pointer to the driver object this is created under
    PDO                     - a pointer to the SMBus HC PDO
    MiniportExtensionSize   - Extension size required by the miniport
    MiniportInitialize      - a pointer to the miniport init routine
    MiniportContext         - Miniport-defined context info
    OutFDO                  - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    PDEVICE_OBJECT      FDO;
    PDEVICE_OBJECT      lowerDevice = NULL;
    PSMBDATA                SmbData;

    //
    // Allocate a device object for this miniport
    //

    RtlInitUnicodeString(&UnicodeString, SMBHC_DEVICE_NAME);

    Status = IoCreateDevice(
                DriverObject,
                sizeof (SMBDATA) + MiniportExtensionSize,
                &UnicodeString,
                FILE_DEVICE_UNKNOWN,    // DeviceType
                0,
                FALSE,
                &FDO
                );

    if (Status != STATUS_SUCCESS) {
        SmbPrint(SMB_LOW, ("SmbC: unable to create device object: %X\n", Status ));
        return(Status);
    }

    //
    // Initialize class data
    //

    FDO->Flags |= DO_BUFFERED_IO;

    //
    // Layer our FDO on top of the PDO
    //

    lowerDevice = IoAttachDeviceToDeviceStack(FDO,PDO);

    //
    // No status. Do the best we can.
    //
    ASSERT(lowerDevice);

    //
    // Fill out class data
    //

    SmbData = (PSMBDATA) FDO->DeviceExtension;
    SmbData->Class.MajorVersion         = SMB_CLASS_MAJOR_VERSION;
    SmbData->Class.MinorVersion         = SMB_CLASS_MINOR_VERSION;
    SmbData->Class.Miniport             = SmbData + 1;
    SmbData->Class.DeviceObject         = FDO;
    SmbData->Class.LowerDeviceObject    = lowerDevice;
    SmbData->Class.PDO                  = PDO;
    SmbData->Class.CurrentIrp           = NULL;
    SmbData->Class.CurrentSmb           = NULL;

    KeInitializeEvent (&SmbData->AlarmEvent, NotificationEvent, FALSE);
    KeInitializeSpinLock (&SmbData->SpinLock);
    InitializeListHead (&SmbData->WorkQueue);
    InitializeListHead (&SmbData->Alarms);

    KeInitializeTimer (&SmbData->RetryTimer);
    KeInitializeDpc (&SmbData->RetryDpc, SmbCRetry, SmbData);

    //
    // Miniport initialization
    //

    Status = MiniportInitialize (&SmbData->Class, SmbData->Class.Miniport, MiniportContext);
    FDO->Flags |= DO_POWER_PAGABLE;
    FDO->Flags &= ~DO_DEVICE_INITIALIZING;

    if (!NT_SUCCESS(Status)) {
        IoDeleteDevice (FDO);
        return Status;
    }

    *OutFDO = FDO;
    return Status;
}


NTSTATUS
SmbCStartDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    )
{
    NTSTATUS            Status;
    PSMBDATA            SmbData;


    SmbPrint(SMB_LOW, ("SmbCStartDevice Entered with fdo %x\n", FDO));

    SmbData = (PSMBDATA) FDO->DeviceExtension;
    
    //
    // Initialize the Miniclass driver.
    //
    SmbData->Class.CurrentIrp = Irp;

    Status = SmbData->Class.ResetDevice (
                    &SmbData->Class,
                    SmbData->Class.Miniport
                    );

    SmbData->Class.CurrentIrp = NULL;
    
    if (!NT_SUCCESS(Status)) {

        SmbPrint(SMB_ERROR,
            ("SmbCStartDevice: Class.ResetDevice failed. = %Lx\n",
            Status));

        return Status;
    }
    
    //
    // Install the Operation Region handlers
    //

    Status = RegisterOpRegionHandler (SmbData->Class.LowerDeviceObject,
                                      ACPI_OPREGION_ACCESS_AS_RAW,
                                      ACPI_OPREGION_REGION_SPACE_SMB,
                                      (PACPI_OP_REGION_HANDLER)SmbCRawOpRegionHandler,
                                      SmbData,
                                      0,
                                      &SmbData->RawOperationRegionObject);
    if (!NT_SUCCESS(Status)) {

        SmbPrint(SMB_ERROR,
            ("SmbCStartDevice: Could not install raw Op region handler, status = %Lx\n",
            Status));
        
        //
        // Failure to register opregion handler is not critical.  It just reduces functionality
        //
        SmbData->RawOperationRegionObject = NULL;
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
SmbCStopDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    )
{
    NTSTATUS            Status;
    PSMBDATA                SmbData;


    SmbPrint(SMB_LOW, ("SmbCStopDevice Entered with fdo %x\n", FDO));


    SmbData = (PSMBDATA) FDO->DeviceExtension;

    //
    // Stop handling operation regions before turning off driver.
    //
    if (SmbData->RawOperationRegionObject) {
        DeRegisterOpRegionHandler (SmbData->Class.LowerDeviceObject,
                                   SmbData->RawOperationRegionObject);
    }

    //
    // Stop the device
    //

    SmbData->Class.CurrentIrp = Irp;
    
    Status = SmbData->Class.StopDevice (
                    &SmbData->Class,
                    SmbData->Class.Miniport
                    );

    SmbData->Class.CurrentIrp = NULL;

    return Status;
}



NTSTATUS
SmbCSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          IoCompletionEvent
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    No event.

--*/
{
    KeSetEvent(IoCompletionEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbhc\smbhc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbhc.c

Abstract:

    SMB Host Controller Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbhcp.h"


ULONG           SMBHCDebug  = 0x0;


//
// Prototypes
//


typedef struct {
    ULONG               Base;
    ULONG               Query;
} NEW_HC_DEVICE, *PNEW_HC_DEVICE;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SmbHcAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SmbHcNewHc (
    IN PSMB_CLASS SmbClass,
    IN PVOID Extension,
    IN PVOID Context
    );

NTSTATUS
SmbHcSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

NTSTATUS
SmbHcResetDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

NTSTATUS
SmbHcStopDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,SmbHcAddDevice)
#pragma alloc_text(PAGE,SmbHcResetDevice)
#pragma alloc_text(PAGE,SmbHcStopDevice)
#pragma alloc_text(PAGE,SmbHcNewHc)
#pragma alloc_text(PAGE,SmbHcSynchronousRequest)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the SM Bus Host Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.
    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS        Status;


    //
    // Have class driver allocate a new SMB miniport device
    //

    Status = SmbClassInitializeDevice (
                SMB_HC_MAJOR_VERSION,
                SMB_HC_MINOR_VERSION,
                DriverObject
                );

    //
    // AddDevice comes directly to this miniport
    //
    DriverObject->DriverExtension->AddDevice = SmbHcAddDevice;

    return (Status);
}

NTSTATUS
SmbHcAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each SmbHc controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    NTSTATUS            status;
    PDEVICE_OBJECT      fdo = NULL;


    PAGED_CODE();

    SmbPrint(SMB_LOW, ("SmbHcAddDevice Entered with pdo %x\n", Pdo));


    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        SmbPrint(SMB_LOW, ("SmbHcAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Create and initialize the new functional device object
    //

    status = SmbClassCreateFdo(
                DriverObject,
                Pdo,
                sizeof (SMB_DATA),
                SmbHcNewHc,
                NULL,
                &fdo
                );

    if (!NT_SUCCESS(status) || fdo == NULL) {
        SmbPrint(SMB_LOW, ("SmbHcAddDevice - error creating Fdo. Status = %08x\n", status));
    }

    return status;
}



NTSTATUS
SmbHcNewHc (
    IN PSMB_CLASS SmbClass,
    IN PVOID Extension,
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called by the smb bus class driver for the
    miniport to perform miniport specific initialization

Arguments:

    SmbClass    - Shared class driver & miniport structure.
    Extension   - Buffer for miniport specific storage
    Context     - Passed through class driver

Return Value:

    Status

--*/

{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    IO_STATUS_BLOCK         ioStatusBlock;
    KEVENT                  event;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;
    PSMB_DATA               smbData;
    ULONG                   cmReturn;


    PAGED_CODE();

    SmbPrint(SMB_LOW, ("SmbHcNewHc: Entry\n") );

    smbData = (PSMB_DATA) Extension;

    //
    // Fill in SmbClass info
    //

    SmbClass->StartIo     = SmbHcStartIo;
    SmbClass->ResetDevice = SmbHcResetDevice;
    SmbClass->StopDevice  = SmbHcStopDevice;

    //
    // Lower device is the EC driver, but we will use the ACPI PDO, since
    // the ACPI filter driver will pass it thru.
    //

    smbData->Pdo = SmbClass->PDO;
    smbData->LowerDeviceObject = SmbClass->LowerDeviceObject;     // ACPI filter will handle it

    //
    // Initialize the input parameters
    //
    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.MethodNameAsUlong = CM_EC_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Initialize the even to wait on
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE);

    //
    // Build the synchronouxe request
    //
    irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_ASYNC_EVAL_METHOD,
        SmbClass->LowerDeviceObject,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        &outputBuffer,
        sizeof(ACPI_EVAL_OUTPUT_BUFFER),
        FALSE,
        &event,
        &ioStatusBlock
        );
    if (!irp) {

        SmbPrint(SMB_ERROR, ("SmbHcNewHc: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Send to ACPI driver
    //
    status = IoCallDriver (smbData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;

    }

    argument = outputBuffer.Argument;
    if (!NT_SUCCESS(status) ||
        outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer.Count == 0 ||
        argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        SmbPrint(SMB_LOW, ("SmbHcNewHc: _EC Control Method failed, status = %Lx\n", status));
        return status;

    }

    //
    // Remember the result
    //
    cmReturn = argument->Argument;

    //
    // Fill in miniport info
    //
    smbData->Class      = SmbClass;
    smbData->IoState    = SMB_IO_IDLE;
    smbData->EcQuery    = (UCHAR) cmReturn;        // Per ACPI Spec, LSB=Query
    smbData->EcBase     = (UCHAR) (cmReturn >> 8); // Per ACPI Spec, MSB=Base


    SmbPrint(SMB_LOW, ("SmbHcNewHc: Exit\n"));
    return status;
}


NTSTATUS
SmbHcSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    Context is the event to set

--*/
{
    PAGED_CODE();
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SmbHcResetDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    )
{
    EC_HANDLER_REQUEST      queryConnect;
    PSMB_DATA               smbData;
    KEVENT                  event;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    PIRP                    irp;

    SmbPrint(SMB_LOW, ("SmbHcResetDevice: Entry\n") );

    PAGED_CODE();

    smbData = (PSMB_DATA) SmbMiniport;

    //
    // Initialize the even to wait on
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE);

    //
    // Build the input data to the EC
    //
    queryConnect.Vector  = smbData->EcQuery;
    queryConnect.Handler = SmbHcQueryEvent;
    queryConnect.Context = smbData;

    //
    // Connect Query notify with EC driver
    //
    irp = IoBuildDeviceIoControlRequest(
        EC_CONNECT_QUERY_HANDLER,
        smbData->LowerDeviceObject,
        &queryConnect,
        sizeof(EC_HANDLER_REQUEST),
        NULL,
        0,
        TRUE,
        &event,
        &ioStatusBlock
        );

    if (!irp) {

        SmbPrint(SMB_ERROR, ("SmbHcResetDevice: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Send off to EC driver
    //
    status = IoCallDriver (smbData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;

    }

    if (!NT_SUCCESS(status)) {

        SmbPrint(SMB_LOW, ("SmbHcResetDevice: Connect query failed, status = %Lx\n", status));

    }

    SmbPrint(SMB_LOW, ("SmbHcResetDevice: Exit\n"));
    return status;
}


NTSTATUS
SmbHcStopDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    )
{
    EC_HANDLER_REQUEST      queryConnect;
    PSMB_DATA               smbData;
    KEVENT                  event;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    PIRP                    irp;

    SmbPrint(SMB_LOW, ("SmbHcStopDevice: Entry\n") );

    //
    // There is currently no way to test this code path.
    // Leaving untested code for potential future use/development
    //

    DbgPrint("SmbHcStopDevice: Encountered previously untested code.\n"
             "enter 'g' to continue, or contact the appropriate developer.\n");
    DbgBreakPoint();

    // Cutting code to reduce file size (see above comment)
#if 0
    PAGED_CODE();

    smbData = (PSMB_DATA) SmbMiniport;

    //
    // Initialize the even to wait on
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE);

    //
    // Build the input data to the EC
    //
    queryConnect.Vector  = smbData->EcQuery;
    queryConnect.Handler = SmbHcQueryEvent;
    queryConnect.Context = smbData;

    //
    // Connect Query notify with EC driver
    //
    irp = IoBuildDeviceIoControlRequest(
        EC_DISCONNECT_QUERY_HANDLER,
        smbData->LowerDeviceObject,
        &queryConnect,
        sizeof(EC_HANDLER_REQUEST),
        NULL,
        0,
        TRUE,
        &event,
        &ioStatusBlock
        );

    if (!irp) {

        SmbPrint(SMB_ERROR, ("SmbHcStopDevice: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Send off to EC driver
    //
    status = IoCallDriver (smbData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;

    }

    if (!NT_SUCCESS(status)) {

        SmbPrint(SMB_LOW, ("SmbHcStopDevice: Connect query failed, status = %Lx\n", status));

    }

    SmbPrint(SMB_LOW, ("SmbHcStopDevice: Exit\n"));
    return status;
#endif
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpiload\makefile.inc ===
$(O)\acpiload.res: acpiload.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\a5parse\a5parse.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    A5Parse.c

Abstract:

    This module contains the code that implements ACPI bugcheck parsing
    mechanism.

Author:

    Vincent Geglia (vincentg) 13-Dec-1999

Environment:

    Kernel mode

Notes:

    
Revision History:


--*/

#include "ntddk.h"
#include "stdarg.h"
#include "stdio.h"
#include "inbv.h"
#include "acpidbg.h"

// Definitions

#define ATTRIB_BLACK    0
#define ATTRIB_RED      1
#define ATTRIB_GREEN    2
#define ATTRIB_YELLOW   3
#define ATTRIB_BLUE     4
#define ATTRIB_MAGENTA  5
#define ATTRIB_CYAN     6
#define ATTRIB_WHITE    7
#define ATTRIB_BRIGHT   8
#define A5PARSE_VERSION "1.0"
#define HEADER          ATTRIB_WHITE + ATTRIB_BRIGHT
#define BODY            ATTRIB_YELLOW + ATTRIB_BRIGHT

// Globals

KBUGCHECK_CALLBACK_RECORD A5ParseCallbackRecord;
BOOLEAN VideoAvailable = FALSE;
extern ULONG *KiBugCheckData;

//
// Define driver entry routine.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// Define the local routines used by this driver module.
//

VOID
A5ParseBugcheckHandler (
    IN PVOID Buffer,
    IN ULONG Length
    );

VOID
A5ParseBugcheckParams (
                       ULONG ArrayIndex
                       );

VOID
A5ParseStallSystem (
                    ULONG NumberOfSeconds
                    );

BOOLEAN
A5ParseCheckBootVid (
                     UCHAR Attribute
                     );

VOID
A5ParseWriteToScreen (
                      UCHAR Attribute,
                      UCHAR *Text,
                      ...
                      );

VOID
A5ParseAcpiRootResourcesFailure (
                                 VOID
                                 );

VOID
A5ParseAcpiRootPciResourcesFailure (
                                    VOID
                                    );

NTSTATUS
A5ParseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

// Structures / type definitions

typedef
VOID
(*PKA5PARSE_ROUTINE) (
                      VOID
                      );

typedef struct _A5MESSAGE {

    ULONG ErrorCode;
    UCHAR ErrorTitle[80];
    UCHAR ErrorMessage[320];
    UCHAR InformationSource[160];
    PKA5PARSE_ROUTINE ParserFunction;
} A5MESSAGE, *PA5MESSAGE;

A5MESSAGE A5Messages[] = {
    ACPI_ROOT_RESOURCES_FAILURE, "ACPI Root Resources Failure", "ACPI cannot find the SCI Interrupt vector in the resources handed to it when\nACPI is started.", "(none)", A5ParseAcpiRootResourcesFailure,
    ACPI_ROOT_PCI_RESOURCE_FAILURE, "ACPI Root PCI Resources Failure", "ACPI could not process the resource list for the PCI root buses (_CRS method).", "See http://www.microsoft.com/hwdev/onnow for the _CRS whitepaper.", A5ParseAcpiRootPciResourcesFailure,
    ACPI_FAILED_MUST_SUCCEED_METHOD, "A Critical ACPI method could not be evaluated", "ACPI attempted to execute a control method while creating device extensions to\nrepresent the ACPI namespace, but was unable to.", "ACPI 1.0b", NULL,
    ACPI_PRW_PACKAGE_EXPECTED_INTEGER, "_PRW returned non-integer value", "ACPI evaluated a _PRW package, and expected an integer, but was returned a\ndifferent data type.", "ACPI 1.0b, section 7.2.1, page 154-155", NULL, 
    ACPI_PRW_PACKAGE_TOO_SMALL, "_PRW package too small", "ACPI evaluated a _PRW pacakge, and expected at least two integers, but received less.", "ACPI 1.0b, section 7.2.1, page 154-155", NULL,
    ACPI_PRX_CANNOT_FIND_OBJECT, "_PRx package referenced an object that could not be found.", "ACPI found a _PRx method that referenced an object that was not found in the\nACPI namespace.", "ACPI 1.0b, section 7.2.2, page 155", NULL,
    ACPI_EXPECTED_BUFFER, "Object evaluated to unexpected data type", "ACPI evaluated a control method, and expected a data buffer to be returned, but received something else.", "ACPI 1.0b", NULL,
    ACPI_EXPECTED_INTEGER, "Object evaluated to unexpected data type", "ACPI evaluated a control method, and expected a data type of 'integer' to be\nreturned, but received something else.", "ACPI 1.0b", NULL,
    ACPI_EXPECTED_PACKAGE, "Object evaluated to unexpected data type", "ACPI evaluated a control method, and expected a data type of 'package' to be\nreturned, but received something else.", "ACPI 1.0b", NULL,
    ACPI_EXPECTED_STRING, "Object evaluated to unexpected data type", "ACPI evaluated a control method, and expected a data type of 'string' to be\nreturned, but received something else.", "ACPI 1.0b", NULL,
    ACPI_EJD_CANNOT_FIND_OBJECT, "_EJD method referenced a non-existent device", "ACPI evaluated an _EJD method, which returns the name of a namespace object, but that object could not be found.", "ACPI 1.0b, section 6.3.1, page 126", NULL,
    ACPI_CLAIMS_BOGUS_DOCK_SUPPORT, "Inconsistent/incomplete docking station information", "While enumerating the ACPI namespace, the OS found control methods indicating\nthe system is dockable, but other control methods were missing, or provided\nincorrect informatoin", "ACPI 1.0b, section 6.3, page 125-128", NULL,
    ACPI_REQUIRED_METHOD_NOT_PRESENT, "Missing _HID or _ADR method", "Physical devices described in the ACPI namespace must be identified using either a _HID or _ADR.", "ACPI 1.0b, section 6.1, page 119-121", NULL,
    ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT, "Missing _ON, _OFF, and/or _STA method", "Power resources must have an _ON, _OFF, and _STA method.", "ACPI 1.0b, section 7.4, page 157-158", NULL,
    ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL, "Unable to parse resource descriptors (_CRS/_PRS)", "The ACPI driver was unable to process a resource descriptor, which usually\nindicates an improperly formed resource descriptor returned by _CRS or _PRS.", "ACPI 1.0b, section 6.2/6.4, page 121-125, 128-150", NULL,
    ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES, "Unable to map Sx to Dx states", "The ACPI driver was unable to determine correct power state (Sx-->Dx) mappings\ndue to a method (_PRx/_PRW) referencing a non-supported Sx state, or the lack\nof Dx support on a particular device.", "ACPI 1.0b, section 7.2, page 154-157\nSee also http://www.microsoft.com/hwdev/onnow for a whitepaper on this topic.", NULL,
    ACPI_SYSTEM_CANNOT_START_ACPI, "Unable to transition into ACPI mode", "The ACPI driver was unable to transition the system from non-ACPI mode to ACPI\nmode.", "ACPI 1.0b", NULL,
    ACPI_FAILED_PIC_METHOD, "Unable to evaluate _PIC method", "A required method for APIC/PIC capable machines, _PIC, could not be evaluated\nby the ACPI driver.", "See http://www.microsoft.com/hwdev/onnow for the 'PCI IRQ Routing on a\nMultiprocessor ACPI System' whitepaper.", NULL,
    ACPI_CANNOT_ROUTE_INTERRUPTS, "Unable to configure interrupt routing", "The ACPI driver attempted to configure IRQ routing on this system, but was\nunsuccessful.", "ACPI 1.0b", NULL,
    ACPI_PRT_CANNOT_FIND_LINK_NODE, "Unable to find IRQ routing link node", "The _PRT method referenced an IRQ routine link node that could not be located\nin the ACPI namespace.", "ACPI 1.0b, section 6.2.3, page 122-123", NULL,
    ACPI_PRT_CANNOT_FIND_DEVICE_ENTRY, "Unable to find entry in _PRT for PCI device", "The PCI bus driver enumerated a device for which there was no entry in the PCI\nbus _PRT method.  Every PCI device using an interrupt must have an entry in\nthe _PRT.", "ACPI 1.0b, section 6.2.3, page 122-123", NULL,
    ACPI_PRT_HAS_INVALID_FUNCTION_NUMBERS, "_PRT did not comply with xxxxFFFF format for device address entry", "Windows 2000 / Windows 98 requires _PRT entries to include all function numbers when describing IRQ routine entries (e.g. 0007FFFF).", "(none)", NULL,
    ACPI_LINK_NODE_CANNOT_BE_DISABLED, "An IRQ routine link node could not be disabled", "The ACPI driver must be able to disable an IRQ routing link node in order to\nreprogram it - it was unable to do so.", "ACPI 1.0b", NULL,
    0, "Unknown error", "ACPI called KeBugCheckEx with unknown parameters.", "(none)", NULL
};

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine.  It basically registers a bugcheck callback,
    nothing else.
    
Arguments:

    DriverObject - Pointer to driver object created by the system.
    RegistryPath - Pointer to the registry path string

Return Value:

    STATUS_SUCCESS if bugcheck callback registration successful, otherwise
    STATUS_UNSUCCESSFUL.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    BOOLEAN success = FALSE;

    //
    // Initialize the driver object with this device driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = A5ParseDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = A5ParseDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ]   = A5ParseDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = A5ParseDispatch;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = A5ParseDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]  = A5ParseDispatch;
    
    // Register bugcheck callback

    KeInitializeCallbackRecord (&A5ParseCallbackRecord);

    success = KeRegisterBugCheckCallback (&A5ParseCallbackRecord,
                                          (PVOID) A5ParseBugcheckHandler,
                                          NULL,
                                          0,
                                          "A5PARSE");

    if (success == FALSE) {

        ASSERT (success);
        DbgPrint ("KeRegisterBugCheckCallback failed.\n");
        return STATUS_UNSUCCESSFUL;
    }

/*    KeBugCheckEx (0xA5, 
                  ACPI_ROOT_PCI_RESOURCE_FAILURE,
                  0,
                  0x81200023,
                  0);*/
    
    return STATUS_SUCCESS;
}

VOID
A5ParseBugcheckHandler (
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This is the bugcheck handler.  It determines if the bugcheck is A5, and if so,
    modifies the bugcheck screen to display its message.    

Arguments:

    Buffer - Supplies a pointer to the bug check buffer (not used).
    Length - Supplies the length of the bug check buffer in bytes (not used).

Return Value:

    None.

--*/

{
    char TextBuffer[2000];
    UCHAR count = 0;
    
    // We only parse bugcheck 0xA5
    
    if (KiBugCheckData[0] != 0xA5) {

        return;
    }
    
    // Set up video to display bugcheck text
    
    VideoAvailable = A5ParseCheckBootVid (ATTRIB_CYAN);

    // Show our banner
    
    A5ParseWriteToScreen (ATTRIB_WHITE + ATTRIB_BRIGHT,
                          "** A5PARSE v%s, Copyright (C) Microsoft Corporation 1999-2000 **\n\n",
                          A5PARSE_VERSION);

    count = 0;

    while (count < (sizeof(A5Messages) / sizeof (A5MESSAGE))) {

        if (A5Messages[count].ErrorCode == KiBugCheckData[1]) {
       // if (1) {
        
            A5ParseBugcheckParams(count);
            //_asm int 3;
            //A5ParseCheckBootVid (ATTRIB_CYAN);
            return;
        }

        count ++;
    } 

    // Unknown (unhandled) error code - show unknown message

    A5ParseBugcheckParams (count-1);
    
    return;
}

VOID
A5ParseStallSystem (
                    ULONG NumberOfSeconds
                    )

/*++

Routine Description:

    Stalls the system for a certain amount of time.  Used to keep the bugcheck
    screen up on the system.
    
Arguments:

    NumberOfSeconds - Number of seconds to wait.

Return Value:

    None.

--*/
{
    while (NumberOfSeconds) {
    
        KeStallExecutionProcessor (1000000);
        NumberOfSeconds --;
    }
}

VOID
A5ParseBugcheckParams (
                       ULONG ArrayIndex
                       )

/*++

Routine Description:

    Parses the A5 bugcheck codes and prints a meaningful message.  Also calls any
    custom parsing function.
    
Arguments:

    ArrayIndex - Index into message structure.

Return Value:

    None.

--*/

{
    A5ParseWriteToScreen (ATTRIB_WHITE + ATTRIB_BRIGHT,
                          "The system has crashed with a STOP 0xA5 (ACPI_BIOS_ERROR).\nA5PARSE will give additional information regarding this failure.\n\n");

    A5ParseWriteToScreen (HEADER,
                          "Error code (ACPIDBG.H):");
    
    A5ParseWriteToScreen (BODY,
                          "0x%08lX\n",
                          A5Messages[ArrayIndex].ErrorCode);

    A5ParseWriteToScreen (HEADER,
                          "Error title:");

    A5ParseWriteToScreen (BODY,
                          "%s\n\n",
                          A5Messages[ArrayIndex].ErrorTitle);

    A5ParseWriteToScreen (HEADER,
                          "Error Description:\n");

    A5ParseWriteToScreen (BODY,
                          "%s\n\n",
                          A5Messages[ArrayIndex].ErrorMessage);

    A5ParseWriteToScreen (HEADER,
                          "Additional Information can be found at:\n");

    A5ParseWriteToScreen (BODY,
                          "%s\n\n",
                          A5Messages[ArrayIndex].InformationSource);

    A5ParseWriteToScreen (HEADER,
                          "Additional debug information:\n");

    if (A5Messages[ArrayIndex].ParserFunction) {

        (A5Messages[ArrayIndex].ParserFunction) ();
    }

    // Stall the system for 600 seconds.
    
    A5ParseStallSystem (600);

    return;
}

BOOLEAN
A5ParseCheckBootVid (
                     UCHAR Attribute
                     )

/*++

Routine Description:

    Verifies the system screen is accessible and acquires ownership, sets the
    window size, and paints the background color.
    
Arguments:

    Attribute - Text attribute for the background screen color.

Return Value:

    TRUE if successful, FALSE if not successful.

--*/

{
    if (InbvIsBootDriverInstalled()) {

        InbvAcquireDisplayOwnership();
        
        InbvSolidColorFill(0,0,639,479,Attribute);
        InbvSetTextColor(15);
        InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
        InbvEnableDisplayString(TRUE);     
        InbvSetScrollRegion(0,0,639,479);  

        return TRUE;
    }

    return FALSE;
}

VOID
A5ParseWriteToScreen (UCHAR Attribute,
                      UCHAR *Text,
                      ...
                      )

/*++

Routine Description:

    Writes text to the console using the attribute specified.
    
Arguments:

    Attribute - Text attribute to use to write text to the screen.
    Text - Pointer to the buffer containing the text to write to the screen.

Return Value:

    None.

--*/

{
    UCHAR TextOut[2000];
    
    va_list va;
    va_start (va, Text);
    vsprintf (TextOut, Text, va);
    va_end (va);

    InbvSetTextColor(Attribute);
    InbvDisplayString (TextOut);
    DbgPrint (TextOut);
}

VOID
A5ParseAcpiRootResourcesFailure(
                                VOID
                                )

{
    if (!KiBugCheckData[3]) {

        A5ParseWriteToScreen (BODY,
                              "No resource list provided to ACPI driver.  This is likely caused by missing, or\nnon-compliant ACPI FADT/RSDT tables.  Check to make sure the fixed tables are\ncorrect (see ACPI 1.0b chapters 4 and 5).\n\n");
    } else {

        A5ParseWriteToScreen (BODY,
                              "A resource list was provided to the ACPI driver, but it did not contain an\ninterrupt vector.  This could be cause by missing or non-compliant ACPI FADT/RSDT tables.\nCheck to make sure the fixed tables are correct (see ACPI 1.0b chapters 4\nand 5).\n\n");
        A5ParseWriteToScreen (BODY,
                              "In the kernel debugger, type '!cmreslist %lx' to dump the resource\ndescriptor missing the interrupt resource.\n",
                              KiBugCheckData[3]);
    }
    
    return;
}

VOID
A5ParseAcpiRootPciResourcesFailure (
                                    VOID
                                    )
{
    if (KiBugCheckData[3] == 2 && !KiBugCheckData[4]) {

        A5ParseWriteToScreen (BODY,
                              "No resource list for the root PCI bus was provided to the ACPI driver.  This is\ncaused by a missing, or non-compliant _CRS method for the root PCI bus.\n");

        return;
    }

    if (KiBugCheckData[3] == 3) {

        A5ParseWriteToScreen (BODY,
                              "The current bus number was not found in the _CRS method for the root PCI bus.\nSee ACPI 1.0b, section 6.4.1, pg 128 for information on reporting bus numbering.\n");
        
        return;
    }

    if (KiBugCheckData[3] > 3) {

        A5ParseWriteToScreen (BODY,
                              "The _CRS for the root PCI bus is incorrectly formed.  Typically this means the\n_CRS claimed to decode memory that overlaps with system memory, which would\nindicate the _CRS is incorrect.\n");

        A5ParseWriteToScreen (BODY,
                              "\nThere were %ld errors found in the _CRS.\n",
                              KiBugCheckData[4]);

        A5ParseWriteToScreen (BODY,
                              "\nThe resource list of the _CRS can be examined via the kernel debugger using the\ncommand '!ioreslist %lx'.\n",
                              KiBugCheckData[3]);

    }

    return;
}


NTSTATUS
A5ParseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Stub function for device driver entry points.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    STATUS_NOT_SUPPORTED


--*/

{
    
    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbhc\smbhcp.h ===
#include <wdm.h>
#include <smbus.h>
#include <ec.h>

#include <devioctl.h>
#include <acpiioct.h>

#define DEBUG   1

//
// Debuging
//


extern ULONG SMBHCDebug;


#if DEBUG
    #define SmbPrint(l,m)    if(l & SMBHCDebug) DbgPrint m
#else
    #define SmbPrint(l,m)
#endif


//
// Control methods used by EC
//
#define CM_EC_METHOD   (ULONG) (0,'CE_')


#define SMB_LOW         0x00000010
#define SMB_STATE       0x00000020
#define SMB_NOTE        0x00000001
#define SMB_WARN        0x00000002
#define SMB_ERROR       0x00000004


//
// SMB Host Controller interface definitions
//

typedef struct {
    UCHAR       Protocol;
    UCHAR       Status;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
    UCHAR       BlockLength;
    UCHAR       AlarmAddress;
    UCHAR       AlarmData[2];
} SMB_HC, *PSMB_HC;

//
// Protocol values
//

#define SMB_HC_NOT_BUSY             0x00
#define SMB_HC_WRITE_QUICK          0x02    // quick cmd with data bit = 0
#define SMB_HC_READ_QUICK           0x03    // quick cmd with data bit = 1
#define SMB_HC_SEND_BYTE            0x04
#define SMB_HC_RECEIVE_BYTE         0x05
#define SMB_HC_WRITE_BYTE           0x06
#define SMB_HC_READ_BYTE            0x07
#define SMB_HC_WRITE_WORD           0x08
#define SMB_HC_READ_WORD            0x09
#define SMB_HC_WRITE_BLOCK          0x0A
#define SMB_HC_READ_BLOCK           0x0B
#define SMB_HC_PROCESS_CALL         0x0C

//
// Status field masks
//

#define SMB_DONE                    0x80
#define SMB_ALRM                    0x40
#define SMB_STATUS_MASK             0x1F

//
// SMB Host Controller Device object extenstion
//

typedef struct {
    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      NextFdo;
    PDEVICE_OBJECT      Pdo;         //Pdo corresponding to this fdo
    PDEVICE_OBJECT      LowerDeviceObject;
    PSMB_CLASS          Class;              // Shared class data

    //
    // Configuration information
    //

    UCHAR               EcQuery;            // EC Query value
    UCHAR               EcBase;             // EC Base value

    //
    // Miniport data
    //

    PIRP                StatusIrp;          // IRP in progress to read status without user irp

    UCHAR               IoState;            // Io state
    UCHAR               IoWaitingState;     // Io state once register read/write completed
    UCHAR               IoStatusState;      // Io state to revert to if idle status

    UCHAR               IoReadData;         // Size of data buffer read after complete status

    SMB_HC              HcState;            // Current host controller registers

} SMB_DATA, *PSMB_DATA;

//
// IoState, IoWaitingState, IoStatusState, StatusState,
//

#define SMB_IO_INVALID                      0
#define SMB_IO_IDLE                         1
#define SMB_IO_CHECK_IDLE                   2
#define SMB_IO_WAITING_FOR_HC_REG_IO        3
#define SMB_IO_WAITING_FOR_STATUS           4
#define SMB_IO_START_TRANSFER               5
#define SMB_IO_READ_STATUS                  6
#define SMB_IO_CHECK_STATUS                 7
#define SMB_IO_COMPLETE_REQUEST             8
#define SMB_IO_COMPLETE_REG_IO              9
#define SMB_IO_CHECK_ALARM                  10
#define SMB_IO_START_PROTOCOL               11

//
// Driver supports the following class driver version
//

#define SMB_HC_MAJOR_VERSION                0x0001
#define SMB_HC_MINOR_VERSION                0x0000


//
// Prototypes
//

VOID
SmbHcStartIo (
    IN PSMB_CLASS   SmbClass,
    IN PVOID        SmbMiniport
    );

VOID
SmbHcQueryEvent (
    IN ULONG        QueryVector,
    IN PSMB_DATA    SmbData
    );

VOID
SmbHcServiceIoLoop (
    IN PSMB_CLASS   SmbClass,
    IN PSMB_DATA    SmbData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\smbus\smbhc\smbsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    service.c

Abstract:

    ACPI Embedded Controller Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbhcp.h"

//
// Transfer information based on protocol
//

struct {
    UCHAR       SetupSize;
    UCHAR       ReturnSize;
    UCHAR       Protocol;
} SmbTransfer[] = {
    0,      0,      SMB_HC_WRITE_QUICK,     // 0
    0,      0,      SMB_HC_READ_QUICK,      // 1
    2,      0,      SMB_HC_SEND_BYTE,       // 2
    1,      1,      SMB_HC_RECEIVE_BYTE,    // 3
    3,      0,      SMB_HC_WRITE_BYTE,      // 4
    2,      1,      SMB_HC_READ_BYTE,       // 5
    4,      0,      SMB_HC_WRITE_WORD,      // 6
    2,      2,      SMB_HC_READ_WORD,       // 7
    35,     0,      SMB_HC_WRITE_BLOCK,     // 8
    2,     33,      SMB_HC_READ_BLOCK,      // 9
    4,      2,      SMB_HC_PROCESS_CALL     // A
} ;

VOID
SmbHcStartIo (
    IN PSMB_CLASS   SmbClass,
    IN PVOID        SmbMiniport
    )
/*++

Routine Description:

    This routine is called by the class driver when a new request has been
    given to the device.   If the device is not being processed, then IO is
    started; else, nothing is done as the context processing the device will
    handle it

Arguments:

    SmbClass    - SMB class data

    SmbMiniport - Miniport context

Return Value:

    None

--*/
{
    PSMB_DATA   SmbData;


    SmbData = (PSMB_DATA) SmbMiniport;
    switch (SmbData->IoState) {
        case SMB_IO_IDLE:
            //
            // Device is idle, go check it
            //

            SmbData->IoState = SMB_IO_CHECK_IDLE;
            SmbHcServiceIoLoop (SmbClass, SmbData);
            break;

        case SMB_IO_CHECK_IDLE:
        case SMB_IO_CHECK_ALARM:
        case SMB_IO_WAITING_FOR_HC_REG_IO:
        case SMB_IO_WAITING_FOR_STATUS:
            //
            // Device i/o is in process which will check for a CurrentIrp
            //

            break;

        default:
            SmbPrint (SMB_ERROR, ("SmbHcStartIo: Unexpected state\n"));
            break;
    }
}



VOID
SmbHcQueryEvent (
    IN ULONG        QueryVector,
    IN PSMB_DATA    SmbData
    )
/*++

Routine Description:

    This routine is called by the embedded controller driver when the
    smb controller has signalled for servicing.  This function sets
    the miniport state to ensure the STATUS register is read and checked
    and if needed starts the device processing to check it

--*/
{
    PSMB_CLASS          SmbClass;

    SmbPrint (SMB_STATE, ("SmbHcQueryEvent\n"));

    //
    // Check status of device.
    //

    SmbClass = SmbData->Class;
    SmbClassLockDevice (SmbClass);

    switch (SmbData->IoState) {
        case SMB_IO_CHECK_IDLE:
        case SMB_IO_IDLE:
            //
            // Device is idle.  Read status and check for an alarm
            //

            SmbData->IoState = SMB_IO_READ_STATUS;
            SmbData->IoStatusState = SMB_IO_CHECK_IDLE;
            SmbHcServiceIoLoop (SmbClass, SmbData);
            break;

        case SMB_IO_WAITING_FOR_STATUS:
            //
            // Waiting for completion status, read status now to see if alarm is set
            //

            SmbData->IoState = SMB_IO_READ_STATUS;
            SmbData->IoStatusState = SMB_IO_WAITING_FOR_STATUS;
            SmbHcServiceIoLoop (SmbClass, SmbData);
            break;

        case SMB_IO_CHECK_ALARM:
            //
            // Status is read after alarm is processed so state is OK
            //

            break;

        case SMB_IO_WAITING_FOR_HC_REG_IO:

            //
            // Waiting for register transfer to/from host controller interface,
            // check the waiting state
            //

            switch (SmbData->IoWaitingState) {
                case SMB_IO_CHECK_ALARM:
                case SMB_IO_START_PROTOCOL:
                case SMB_IO_READ_STATUS:
                    //
                    // Status will be read, so state is OK
                    //

                    break;

                case SMB_IO_CHECK_STATUS:
                    //
                    // Back check status up and re-read the status before
                    // the check status
                    //

                    SmbData->IoWaitingState = SMB_IO_READ_STATUS;
                    break;

                case SMB_IO_WAITING_FOR_STATUS:
                    //
                    // Going to wait for completion status, read status once
                    // hc i/o has completed
                    //

                    SmbData->IoWaitingState = SMB_IO_READ_STATUS;
                    SmbData->IoStatusState = SMB_IO_WAITING_FOR_STATUS;
                    break;

                default:
                    SmbPrint (SMB_ERROR, ("SmbHcQuery: Unknown IoWaitingState %d\n", SmbData->IoWaitingState));
                    break;
            }
            break;

        default:
            SmbPrint (SMB_ERROR, ("SmbHcQuery: Unknown IoState %d\n", SmbData->IoState));
            break;
    }

    SmbClassUnlockDevice (SmbClass);
}

NTSTATUS
SmbHcRegIoComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    Completion function for IRPs sent to the embedded control for EC io.

--*/
{
    PSMB_DATA   SmbData;
    PSMB_CLASS  SmbClass;

    SmbPrint (SMB_STATE, ("SmbHcRegIoComplete: Enter.  Irp %x\n", Irp));

    SmbData = (PSMB_DATA) Context;
    SmbClass = SmbData->Class;
    SmbClassLockDevice (SmbClass);

    //
    // Move state to IoWaitingState and continue
    //

    ASSERT (SmbData->IoState == SMB_IO_WAITING_FOR_HC_REG_IO);
    SmbData->IoState = SMB_IO_COMPLETE_REG_IO;
    SmbHcServiceIoLoop (SmbClass, SmbData);

    SmbClassUnlockDevice (SmbClass);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
SmbHcServiceIoLoop (
    IN PSMB_CLASS   SmbClass,
    IN PSMB_DATA    SmbData
    )
/*++

Routine Description:

    Main host controller interface service loop.

    N.B. device lock is held by caller.
    N.B. device lock may be released and re-acquired during call

--*/
{
    PIRP                Irp;
    PUCHAR              IoBuffer;
    UCHAR               IoWaitingState;
    UCHAR               ErrorCode;
    BOOLEAN             IoWrite;
    ULONG               IoLength;
    PSMB_REQUEST        SmbReq;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;

    IoWrite = FALSE;
    IoBuffer = NULL;
    IoWaitingState = SMB_IO_IDLE;

    SmbPrint (SMB_STATE, ("SmbService: Enter - SmbData %x\n", SmbData));

    do {
        switch (SmbData->IoState) {

            case SMB_IO_CHECK_IDLE:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_CHECK_IDLE\n"));

                //
                // Fallthrough to SMB_IO_IDLE.
                //

                SmbData->IoState = SMB_IO_IDLE;
            case SMB_IO_IDLE:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_IDLE\n"));

                //
                // If there's an alarm pending, read and clear it
                //

                if (SmbData->HcState.Status & SMB_ALRM) {
                    IoBuffer = &SmbData->HcState.AlarmAddress;
                    IoLength = 3;
                    IoWaitingState = SMB_IO_CHECK_ALARM;
                    break;
                }

                //
                // If there's an IRP, lets start it
                //

                if (SmbClass->CurrentIrp) {
                    SmbData->IoState = SMB_IO_START_TRANSFER;
                    break;
                }
                break;

            case SMB_IO_START_TRANSFER:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_START_TRANSFER\n"));

                //
                // Begin CurrentIrp transfer
                //

                Irp = SmbClass->CurrentIrp;
                SmbReq = SmbClass->CurrentSmb;
                SmbData->HcState.Protocol = SmbTransfer[SmbReq->Protocol].Protocol;
                SmbData->HcState.Address  = SmbReq->Address << 1;
                SmbData->HcState.Command  = SmbReq->Command;
                SmbData->HcState.BlockLength = SmbReq->BlockLength;

                //
                // Write HC registers
                //

                IoWrite  = TRUE;
                IoBuffer = &SmbData->HcState.Address;
                IoLength = SmbTransfer[SmbReq->Protocol].SetupSize;
                IoBuffer = &SmbData->HcState.Address;
                IoWaitingState = SMB_IO_START_PROTOCOL;

                //
                // Move data bytes (after address & command byte)
                //

                if (IoLength > 2) {
                   memcpy (SmbData->HcState.Data, SmbReq->Data, IoLength-2);
                }

                //
                // Setup for result length once command completes
                //

                SmbData->IoReadData = SmbTransfer[SmbReq->Protocol].ReturnSize;

                //
                // Handle HC specific protocol mappings
                //

                switch (SmbData->HcState.Protocol) {
                    case SMB_HC_WRITE_QUICK:
                    case SMB_HC_READ_QUICK:
                        //
                        // Host controller wants quick data bit in bit 0
                        // of address
                        //

                        SmbData->HcState.Address |=
                            (SmbData->HcState.Protocol & 1);
                        break;

                    case SMB_HC_SEND_BYTE:
                        //
                        // Host controller wants SEND_BYTE byte in the command
                        // register
                        //

                        SmbData->HcState.Command = SmbReq->Data[0];
                        break;
                }
                break;

            case SMB_IO_START_PROTOCOL:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_START_PROTOCOL\n"));

                //
                // Transfer registers have been setup.  Initiate the protocol
                //

                IoWrite  = TRUE;
                IoBuffer = &SmbData->HcState.Protocol;
                IoLength = 1;
                IoWaitingState = SMB_IO_WAITING_FOR_STATUS;
                break;

            case SMB_IO_WAITING_FOR_STATUS:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_WAITING_FOR_STATUS\n"));

                //
                // Transfer is in progress, just waiting for a status to
                // indicate its complete
                //

                SmbData->IoState = SMB_IO_READ_STATUS;
                SmbData->IoStatusState = SMB_IO_WAITING_FOR_STATUS;
                break;

            case SMB_IO_READ_STATUS:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_READ_STATUS\n"));

                //
                // Read status+protocol and then check it (IoStatusState already set)
                //

                IoBuffer = &SmbData->HcState.Protocol;
                IoLength = 2;   // read protocol & status bytes
                IoWaitingState = SMB_IO_CHECK_STATUS;
                break;

            case SMB_IO_CHECK_STATUS:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_CHECK_STATUS\n"));

                Irp = SmbClass->CurrentIrp;

                //
                // If there's an Irp
                //

                if (SmbData->IoStatusState == SMB_IO_WAITING_FOR_STATUS  &&
                    SmbData->HcState.Protocol == 0) {

                    SmbReq = SmbClass->CurrentSmb;

                    //
                    // If there's an error set handle it
                    //

                    if (SmbData->HcState.Status & SMB_STATUS_MASK) {
                        ErrorCode = SmbData->HcState.Status & SMB_STATUS_MASK;

                        //
                        // Complete/abort the IO with the error
                        //

                        SmbReq->Status = ErrorCode;
                        SmbData->IoState = SMB_IO_COMPLETE_REQUEST;
                        break;
                    }



                    //
                    // If the done is set continue the IO
                    //

                    if (SmbData->HcState.Status & SMB_DONE) {
                        //
                        // Get any return data registers then complete it
                        //

                        SmbReq->Status = SMB_STATUS_OK;
                        IoBuffer = SmbData->HcState.Data;
                        IoLength = SmbData->IoReadData;
                        IoWaitingState = SMB_IO_COMPLETE_REQUEST;
                        break;
                    }
                }

                //
                // Current status didn't have any effect
                //

                SmbData->IoState = SmbData->IoStatusState;
                break;

            case SMB_IO_COMPLETE_REQUEST:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_COMPLETE_REQUEST\n"));

                Irp = SmbClass->CurrentIrp;
                SmbReq = SmbClass->CurrentSmb;

                SmbData->IoState = SMB_IO_CHECK_IDLE;
                SmbData->IoStatusState = SMB_IO_INVALID;

                //
                // Return any read data if needed
                //

                memcpy (SmbReq->Data, SmbData->HcState.Data, SMB_MAX_DATA_SIZE);
                SmbReq->BlockLength = SmbData->HcState.BlockLength;
                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(SMB_REQUEST);

                //
                // Note SmbClass driver will drop the lock during this call
                //

                SmbClassCompleteRequest (SmbClass);
                break;

            case SMB_IO_CHECK_ALARM:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_CHECK_ALARM\n"));

                //
                // HC alarm values read, check them
                //

                SmbPrint (SMB_NOTE, ("SmbHcService: Process Alarm Data %x %x %x\n",
                    SmbData->HcState.AlarmAddress,
                    SmbData->HcState.AlarmData[0],
                    SmbData->HcState.AlarmData[1]
                    ));

                //
                // Inform the class driver of the event.
                //

                SmbClassAlarm (
                    SmbClass,
                    (UCHAR)  (SmbData->HcState.AlarmAddress >> 1),
                    (USHORT) (SmbData->HcState.AlarmData[0] | (SmbData->HcState.AlarmData[1] << 8))
                    );

                //
                // Clear the alarm bit in the status value, and then check
                // for idle state
                //

                SmbData->HcState.Status = 0;
                IoBuffer = &SmbData->HcState.Status;
                IoLength = 1;
                IoWrite  = TRUE;
                IoWaitingState = SMB_IO_READ_STATUS;
                SmbData->IoStatusState = SMB_IO_CHECK_IDLE;
                break;

            case SMB_IO_COMPLETE_REG_IO:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_COMPLETE_REQ_IO\n"));

                //
                // Irp for HC reg IO is complete, check it
                //

                Irp = SmbClass->CurrentIrp;

                if (!Irp) {
                    //
                    // No current irp - check for status irp
                    //

                    Irp = SmbData->StatusIrp;

                    if (Irp) {
                        // just reading status
                        IoFreeIrp (Irp);
                        SmbData->StatusIrp = NULL;
                    } else {
                        SmbPrint (SMB_WARN, ("SmbHcServiceIoLoop: HC Reg Io for what?\n"));
                    }

                } else {

                    //
                    // Check for error on register access
                    //

                    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
                        SmbPrint (SMB_WARN, ("SmbHcServiceIoLoop: HC Reg Io request failed\n"));

                        //
                        // Condition is likely fatal, give it up
                        //

                        SmbData->HcState.Protocol = 0;
                        SmbData->HcState.Status = SMB_UNKNOWN_ERROR;
                    }
                }

                //
                // Continue to next state
                //

                SmbData->IoState = SmbData->IoWaitingState;
                SmbPrint (SMB_STATE, ("SmbService: Next state: %x\n", SmbData->IoState));
                break;

            default:
                SmbPrint (SMB_ERROR, ("SmbHcServiceIoLoop: Invalid state: %x\n", SmbData->IoState));
                SmbData->IoState = SMB_IO_CHECK_IDLE;
                break;
        }

        //
        // If there's an IO operation to the HC registers required, dispatch it
        //

        if (IoWaitingState != SMB_IO_IDLE) {
            SmbPrint (SMB_STATE, ("SmbService: IoWaitingState %d\n", IoWaitingState));

            if (IoLength) {
                //
                // There's an Io operation dispatch. Set status as REG IO pending,
                // and drop the device lock
                //

                SmbData->IoWaitingState = IoWaitingState;
                SmbData->IoState = SMB_IO_WAITING_FOR_HC_REG_IO;
                SmbClassUnlockDevice(SmbClass);

                //
                // Setup IRP to perform the register IO to the HC
                //

                Status = STATUS_INSUFFICIENT_RESOURCES;
                Irp = SmbClass->CurrentIrp;
                if (!Irp) {
                    Irp = IoAllocateIrp (SmbClass->DeviceObject->StackSize, FALSE);
                    SmbData->StatusIrp = Irp;
                }

                if (Irp) {

                    //
                    // Fill in register transfer request
                    //

                    IrpSp = IoGetNextIrpStackLocation (Irp);
                    IrpSp->MajorFunction = IoWrite ? IRP_MJ_WRITE : IRP_MJ_READ;
                    IrpSp->Parameters.Read.Length = IoLength;
                    IrpSp->Parameters.Read.Key    = 0;
                    IrpSp->Parameters.Read.ByteOffset.HighPart = 0;
                    IrpSp->Parameters.Read.ByteOffset.LowPart =
                            (ULONG) ((PUCHAR) IoBuffer - (PUCHAR) &SmbData->HcState) +
                            SmbData->EcBase;

                    Irp->AssociatedIrp.SystemBuffer = IoBuffer;

                    //
                    // Setup completion routine
                    //

                    IoSetCompletionRoutine (
                        Irp,
                        SmbHcRegIoComplete,
                        SmbData,
                        TRUE,
                        TRUE,
                        TRUE
                        );

                    SmbPrint (SMB_STATE, ("SmbService: IRP=%x, IrpSp=%x\n", Irp, IrpSp));
                    SmbPrint (SMB_STATE, ("SmbService: %s Off=%x, Len=%x, Buffer=%x\n",
                        IoWrite ? "write" : "read",
                        IrpSp->Parameters.Read.ByteOffset.LowPart,
                        IoLength,
                        IoBuffer
                        ));


                    //
                    // Call lower FDO to perform the IO
                    //

                    Status = IoCallDriver (SmbData->LowerDeviceObject, Irp);
                }

                //
                // If the request is not pending, complete it
                //

                SmbClassLockDevice(SmbClass);
                if (Status != STATUS_PENDING) {
                    SmbData->IoState = SMB_IO_COMPLETE_REG_IO;
                }

            } else {
                // no data to transfer continue with next state
                SmbData->IoState = IoWaitingState;
            }

            IoWaitingState = SMB_IO_IDLE;       // was: SMB_IO_CHEC_IDLE
            IoBuffer = NULL;
            IoWrite  = FALSE;
        }


        //
        // Loop unless state requires some asynchronous to exit
        //

    } while (SmbData->IoState != SMB_IO_IDLE   &&
             SmbData->IoState != SMB_IO_WAITING_FOR_HC_REG_IO   &&
             SmbData->IoState != SMB_IO_WAITING_FOR_STATUS) ;


    SmbPrint (SMB_STATE, ("SmbService: Exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpiload\acpiload.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiload.c

Abstract:

    This program installs an AML file into the NT registry

Author:

    Ken Reneris

Environment:

    Command-line.

Revision History:

2-23-2000 - mmurph - Added support for images besides DSDTs
2-23-2000 - mmurph - Added support to force load for unknown image type

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <amlreg.h>
//#include <varargs.h>

#define SIGNATURES {'TDSD', 'TDSR', 'TDSS', 'TDSP', 'CIPA', 'PCAF', 'SCAF', 'TSBS'}

#define DATA_SIZE   7*1024      // max value to write into registry

typedef struct {
   ULONG       Signature;
   ULONG       Length;
   UCHAR       Revision;
   UCHAR       Checksum;
   UCHAR       OemID[6];
   UCHAR       OemTableID[8];
   ULONG       OemRevision;
   UCHAR       CreatorID[4];
   UCHAR       CreatorRevision[4];
} DSDT, *PDSDT;


IFILE       Update;                     // Image of updated aml file
IFILE       Orig;                       // Image of original aml file
BOOLEAN     Verbose;
BOOLEAN     DeleteUpdate;
BOOLEAN     Force;
BOOLEAN     ArgsParsed;
BOOLEAN     RegInProgress;
HKEY        RegKey;

ULONG       RegDataSequence;
ULONG       RegDataSize;
UCHAR       RegDataBuffer[DATA_SIZE];
UCHAR       s[500];                     // Registry path
PUCHAR signa;

//
// Internal prototypes
//

VOID
ParseArgs (
          IN int  argc,
          IN char *argv[]
          );

VOID
CheckImageHeader (
                 IN PIFILE   File
                 );

VOID
GetRegistryKey (
               IN PIFILE   Image
               );

VOID
FAbort (
       PUCHAR  Text,
       PIFILE  File
       );

VOID
Abort (
      VOID
      );

VOID
BuildUpdate (
            VOID
            );

VOID
AddRun (
       IN ULONG    Offset,
       IN ULONG    Length
       );

VOID
FlushRun (
         VOID
         );

VOID
DeleteRegistryNode (
                   IN HKEY Handle
                   );

PUCHAR
FixString (
          IN PUCHAR   Str,
          IN ULONG    Len
          );

int
__cdecl
main(
    IN int  argc,
    IN char *argv[]
    ) {
   //
   // Init globals
   //

   Update.Desc = "update image";
   Orig.Desc   = "original image";

   //
   // Parse args
   //

   ParseArgs(argc, argv);

   //
   // Parse image headers
   //

   CheckImageHeader (&Update);
   if (Orig.Opened) {
      CheckImageHeader (&Orig);

      // verify oem info
      if (strcmp (Update.OemID, Orig.OemID)) {
         printf ("OEM id in update image mis-matches original image\n");
         Abort ();
      }

      if (strcmp (Update.OemTableID, Orig.OemTableID)) {
         printf ("OEM table id in update image mis-matches original image\n");
         Abort ();
      }

      if (Update.OemRevision != Orig.OemRevision) {
         printf ("OEM revision in update image revision does not match\n");
         Abort ();
      }
   }

   //
   // Open/create proper registry location
   //

   GetRegistryKey (&Update);

   //
   // Delete any existing stuff
   //

   DeleteRegistryNode (RegKey);
   if (DeleteUpdate) {
      printf ("Registry data deleted\n");
      exit (1);
   }

   //
   // For now hardcoded to "update" action
   //
   BuildUpdate ();

   return 0;
}

VOID
BuildUpdate (
            VOID
            ) {
   LONG        Status;
   ULONG       i, Len, Offs, RunLen, match;

   RegDataSequence = 0;
   RegDataSize     = 0;
   RegInProgress   = TRUE;

   //
   // If there's no original image, just write the new one
   //

   if (!Orig.Opened) {
      AddRun (Update.FileSize, 0);
      AddRun (0, Update.FileSize);
   } else {
      if (Update.FileSize != Orig.FileSize) {
         AddRun (Update.FileSize, 0);
      }

      Len = Update.FileSize;
      if (Orig.FileSize < Update.FileSize) {
         Len = Orig.FileSize;
      }

      Offs=0;
      while (Offs < Len) {
         //
         // Skip matching bytes
         //
         if (Update.Image[Offs] == Orig.Image[Offs]) {
            Offs += 1;
            continue;
         }

         //
         // Count mismatching bytes
         //
         match = 0;
         for (RunLen=1; Offs+RunLen < Len; RunLen++) {
            if (Update.Image[Offs+RunLen] == Orig.Image[Offs+RunLen]) {
               match += 1;
               if (match > 8) {
                  break;
               }
            } else {
               match = 0;
            }
         }

         RunLen -= match;
         AddRun (Offs, RunLen);
         Offs += RunLen;
      }

      //
      // If there's more at the end add it
      //

      if (Len < Update.FileSize) {
         AddRun (Len, Update.FileSize - Len);
      }

   }

   FlushRun();
   if (RegDataSequence) {
      if (Verbose) {
         printf ("SetValue Action\n");
      }

      i = 0;      // BUGBUG: values need defined
      Status = RegSetValueEx (RegKey, "Action", 0L, REG_DWORD,(PUCHAR) &i, sizeof(i));
   }

   RegInProgress = FALSE;

   if (Verbose) {
      printf ("Registry path:\n%s\n", s);
   }

}


VOID
AddRun (
       IN ULONG    Offset,
       IN ULONG    Length
       ) {
   PREGISTRY_HEADER    regHdr;
   ULONG               RunLength;


   do {
      if (RegDataSize + sizeof(REGISTRY_HEADER) > DATA_SIZE - 128) {
         FlushRun ();
      }

      regHdr = (PREGISTRY_HEADER) (RegDataBuffer + RegDataSize);
      RegDataSize += sizeof(REGISTRY_HEADER);

      if (DATA_SIZE - RegDataSize < Length) {
         RunLength = DATA_SIZE - RegDataSize;
      } else {
         RunLength = Length;
      }

      //printf ("Add Hdr %x %x\n", Offset, RunLength);

      regHdr->Offset = Offset;
      regHdr->Length = RunLength;
      RtlCopyMemory (RegDataBuffer + RegDataSize, Update.Image + Offset, RunLength);

      RegDataSize += RunLength;
      Offset += RunLength;
      Length -= RunLength;
   } while (Length);
}


VOID
FlushRun
(
VOID
) {
   LONG    Status;
   UCHAR   s[50];

   if (RegDataSize) {
      sprintf (s, "%08x", RegDataSequence);
      RegDataSequence += 1;

      if (Verbose) {
         printf ("SetValue %s\n", s);
      }

      Status = RegSetValueEx (RegKey, s, 0L, REG_BINARY, RegDataBuffer, RegDataSize);
      RegDataSize = 0;
      if (Status != ERROR_SUCCESS) {
         printf ("Error writting registry value %s\n", s);
         Abort();
      }
   }
}


VOID
DeleteRegistryNode (
                   IN HKEY Handle
                   ) {
   UCHAR   s[500];
   ULONG   i;
   LONG    Status;
   HKEY    SubKey;
   ULONG   Type;
   ULONG   DataSize;

#if 0
   i = 0;
   for (; ;) {
      Status = RegEnumKey(Handle, i, s, sizeof(s));
      i += 1;
      if (Status == ERROR_NO_MORE_ITEMS) {
         break;
      }

      Status = RegOpenKey(Handle, s, &SubKey);
      if (Status == ERROR_SUCCESS) {
         DeleteRegistryNode (SubKey);
         RegCloseKey (SubKey);

         if (Verbose) {
            printf ("Delete key %s\n", s);
         }
         RegDeleteKey (Handle, s);
         i = 0;
      }
   }
#endif

   i = 0;
   for (; ;) {
      s[0] = 0;
      DataSize = 0;
      Status = RegEnumValue(
                           Handle,
                           i,
                           s,
                           &DataSize,
                           NULL,
                           &Type,
                           NULL,
                           0
                           );
      i += 1;
      if (Status == ERROR_NO_MORE_ITEMS) {
         break;
      }

      s[DataSize] = 0;
      if (Verbose) {
         printf ("Delete value %s\n", s);
      }

      Status = RegDeleteValue (Handle, s);
      if (Status == ERROR_SUCCESS) {
         i = 0;
      }
   }
}


VOID
GetRegistryKey (
               IN PIFILE   Image
               ) {
   LONG    Status;

   sprintf (s, "System\\CurrentControlSet\\Services\\ACPI\\Parameters\\%c%c%c%c\\%s\\%s\\%.8x",
            signa[0],
            signa[1],
            signa[2],
            signa[3],
            Image->OemID,
            Image->OemTableID,
            Image->OemRevision
           );

   Status = RegCreateKey (HKEY_LOCAL_MACHINE, s, &RegKey);
   if (Status == ERROR_SUCCESS) {
      RegCloseKey (RegKey);
   }

   Status = RegOpenKeyEx (
                         HKEY_LOCAL_MACHINE,
                         s,
                         0L,
                         KEY_ALL_ACCESS,
                         &RegKey
                         );

   if (Status != ERROR_SUCCESS) {
      RegKey = NULL;
      printf ("Count not access the registry path: %s\n", s);
      Abort ();
   }
}


VOID
CheckImageHeader (
                 IN PIFILE   File
                 ) {
   PUCHAR      Image;
   PDSDT       Dsdt; // Variable name kept as Dsdt even though this program can handle all types
   UCHAR       check;
   ULONG       i;
   BOOL found = FALSE;
   //ULONG signatures[] = SIGNATURES;
   ULONG signatures[] = SIGNATURES;


   if (File->FileSize < sizeof(DSDT)) {
      FAbort ("Invalid image size in", File);
   }

   Dsdt  = (PDSDT) File->Image;

   for (i=0;i<sizeof(signatures);i++) {
      if (signatures[i] == Dsdt->Signature) {
         found = TRUE;
         signa = (PUCHAR)(&(Dsdt->Signature));
         break;
      }
   }
   if (!found && !Force) {
      UCHAR sig[64];
      sprintf(sig, "Image signature (%c%c%c%c) not recognized in",
              ((PUCHAR)(&Dsdt->Signature))[0],
              ((PUCHAR)(&Dsdt->Signature))[1],
              ((PUCHAR)(&Dsdt->Signature))[2],
              ((PUCHAR)(&Dsdt->Signature))[3]);
      FAbort (sig, File);
   }

   
//
// BUGBUG: remove? (Or at least revision should be "1")
//
//    if (Dsdt->Revision != 0) {
//        FAbort ("DSDT revision not 0 in", File);
//    }

   if (File->FileSize != Dsdt->Length) {
      UCHAR sig[64];
      sprintf(sig, "File size in %c%c%c%c does not match image size in",
              signa[0],
              signa[1],
              signa[2],
              signa[3]);
      FAbort (sig, File);
   }

   check = 0;
   for (Image = File->Image; Image < File->EndOfImage; Image += 1) {
      check += *Image;
   }

   if (check) {
      FAbort ("Image checksum is incorrect in", File);
   }

   //
   // normalize fixed strings
   //
   File->OemID = FixString (Dsdt->OemID, 6);
   File->OemTableID = FixString (Dsdt->OemTableID, 8);
   File->OemRevision = Dsdt->OemRevision;


//    for (i=0; i < 4; i++) {
//        if (File->OemRevision[i] == 0 || File->OemRevision[i] == ' ') {
//            File->OemRevision[i] = '_';
//        }
//    }

   if (Verbose) {
      printf ("\n");
      printf ("%c%c%c%c info for %s (%s)\n", 
              signa[0],
              signa[1],
              signa[2],
              signa[3],
              File->Desc, File->FileName);
      printf ("  Size of image: %d\n", File->FileSize);
      printf ("  OEM id.......: %s\n", File->OemID);
      printf ("  OEM Table id.: %s\n", File->OemTableID);
      printf ("  OEM revision.: %.8x\n", File->OemRevision);

   }
         
}

PUCHAR
FixString (
          IN PUCHAR   Str,
          IN ULONG    Len
          ) {
   PUCHAR  p;
   ULONG   i;

   p = malloc(Len+1);
   memcpy (p, Str, Len);
   p[Len] = 0;

   for (i=Len; i; i--) {
      if (p[i] != ' ') {
         break;
      }
      p[i] = 0;
   }
   return p;
}

VOID
FAbort (
       PUCHAR  Text,
       PIFILE  File
       ) {
   
   printf ("%s %s (%s)\n", Text, File->Desc, File->FileName);
   Abort();
}


VOID
Abort(
     VOID
     ) {
   if (RegInProgress) {
      DeleteRegistryNode(RegKey);
   }

   if (!ArgsParsed) {
      printf ("amlload: UpdateImage [OriginalImage] [-v] [-d] [-f]\n");
   }
   exit (1);
}


VOID
ParseArgs (
          IN int  argc,
          IN char *argv[]
          ) {
   PIFILE      File;
   OFSTRUCT    OpenBuf;

   File = &Update;

   while (--argc) {
      argv += 1;

      //
      // If it's a flag crack it
      //

      if (argv[0][0] == '-') {
         switch (argv[0][1]) {
         case 'v':
         case 'V':
            Verbose = TRUE;
            break;

         case 'd':
         case 'D':
            DeleteUpdate = TRUE;
            break;

         case 'f':
         case 'F':
            Force = TRUE;
            break;

         default:
            printf ("Unknown flag %s\n", argv[0]);
            Abort ();
         }

      } else {

         if (!File) {
            printf ("Unexcepted parameter %s\n", argv[0]);
            Abort();
         }

         //
         // Open the file
         //

         File->FileName = argv[0];
         File->FileHandle = (HANDLE) OpenFile(
                                             argv[0],
                                             &OpenBuf,
                                             OF_READ
                                             );
         if (File->FileHandle == (HANDLE) HFILE_ERROR) {
            FAbort ("Can not open", File);
         }

         File->FileSize = GetFileSize(File->FileHandle, NULL);

         //
         // Map it
         //

         File->MapHandle =
         CreateFileMapping(
                          File->FileHandle,
                          NULL,
                          PAGE_READONLY,
                          0,
                          File->FileSize,
                          NULL
                          );

         if (!File->MapHandle) {
            FAbort ("Cannot map", File);
         }

         File->Image =
         MapViewOfFile (
                       File->MapHandle,
                       FILE_MAP_READ,
                       0,
                       0,
                       File->FileSize
                       );

         if (!File->Image) {
            FAbort ("Cannot map view of image", File);
         }
         File->EndOfImage = File->Image + File->FileSize;
         File->Opened = TRUE;

         //
         // Next file param
         //

         if (File == &Update) {
            File = &Orig;
         } else {
            File = NULL;
         }
      }
   }

   //
   // At least a update image is needed
   //

   if (!Update.Opened) {
      Abort ();
   }

   ArgsParsed = TRUE;
   return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\driver\acpisim.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 acpisim.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IO Device Control Handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include "oprghdlr.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimlib.h"
#include "acpisim.h"

//
// Globals
//

PVOID   g_OpRegionSharedMemory = 0;
PVOID   g_OperationRegionObject = 0;

//
// Private function prototypes
//

NTSTATUS
EXPORT
AcpisimOpRegionHandler (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    );

//
// Code
//

NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to register our operation region
    handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    g_OpRegionSharedMemory = ExAllocatePoolWithTag (NonPagedPool,
                                                    OPREGION_SIZE,
                                                    ACPISIM_POOL_TAG);

    status = RegisterOpRegionHandler (AcpisimLibGetNextDevice (DeviceObject),
                                      ACPI_OPREGION_ACCESS_AS_COOKED,
                                      ACPISIM_OPREGION_TYPE,
                                      (PACPI_OP_REGION_HANDLER) AcpisimOpRegionHandler,
                                      (PVOID) ACPISIM_TAG,
                                      0,
                                      &g_OperationRegionObject);

    return status;
}

NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to unregister our operation region
    handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    status = DeRegisterOpRegionHandler (AcpisimLibGetNextDevice (DeviceObject),
                                        g_OperationRegionObject);

    ExFreePool (g_OpRegionSharedMemory);

    return status;
}

NTSTATUS
EXPORT
AcpisimOpRegionHandler (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    )

/*++

Routine Description:

    This routine is called when ASL touches the op region.
    
Arguments:

    AccessType - Indicates whether it is a read or write.
    OperationRegionObject - A pointer to our op region
    Address - Offset into the op region for which the access occurred
    Size - Number of bytes of the access
    Data - Data being written, or location to store data being read
    Context - A user definable context (in this case, device extension)
    CompletionHandler - internal, not used
    CompletionContext - internal, not used

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    ASSERT (AccessType == ACPI_OPREGION_WRITE || AccessType == ACPI_OPREGION_READ);

    //
    // Insert additional handler code here
    //

    switch (AccessType) {
    
    case ACPI_OPREGION_WRITE:

        RtlCopyMemory ((PVOID) ((ULONG_PTR) g_OpRegionSharedMemory + Address), Data, Size);
        status = STATUS_SUCCESS;
        break;
    
    case ACPI_OPREGION_READ:

        RtlCopyMemory (Data, (PVOID) ((ULONG_PTR) g_OpRegionSharedMemory + Address), Size);
        status = STATUS_SUCCESS;
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Unknown Opregion access type.  Ignoring.\n");

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;
}

NTSTATUS AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for IOCTL requests. This is the "meat" of 
    the driver so to speak.  All of the op-region accesses from user
    mode are handled here.  
    
    The implementer should perform the action and return an appropriate
    status, or return STATUS_UNSUPPORTED if the IOCTL is unrecognized.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\inc\asimlib.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 asimlib.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_ASIMLIB_H_)
#define _ASIMLIB_H_

//
// includes
//

//
// Definitions
//

#define ACPISIM_GUID                {0x27FC71F0, 0x8B2D, 0x4D05, { 0xBD, 0xD0, 0xE8, 0xEA, 0xCA, 0xA0, 0x78, 0xA0}}
#define ACPISIM_TAG                 (ULONG) 'misA'

//
// Debug Flags
//

#define DBG_ERROR   0x00000001
#define DBG_WARN    0x00000002
#define DBG_INFO    0x00000004

//
// Public function prototypes
//

VOID
AcpisimDbgPrint
    (
    ULONG DebugLevel,
    TCHAR *Text,
    ...
    );

PDEVICE_OBJECT
AcpisimLibGetNextDevice
    (
        PDEVICE_OBJECT DeviceObject
    );


#define DBG_PRINT AcpisimDbgPrint

#endif // _ASIMLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\driver\acpisim.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 ioctl.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IO Device Control Handler module
     
Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:
    
     This header file shows all of the functions that must be exported
     in order to compile against the ACPI BIOS Simulator Library.
     
Revision History:
	 

--*/

#if !defined(_ACPISIM_H_)
#define _ACPISIM_H_

//
// Defines
//

#define OPREGION_SIZE               1024    // use a hardcoded value of 1024 for our operation region size
#define ACPISIM_POOL_TAG            (ULONG) 'misA'

//
// Specify the operation region type here
//

#define ACPISIM_OPREGION_TYPE      0x81

//
// Public function prototypes
//

NTSTATUS 
AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

#endif // _ACPISIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\lib\acpisim.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 acpisim.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>
#include <ntpoapi.h>

//
// Specific includes
//

#include "acpisim.h"
#include "dispatch.h"
#include "util.h"

//
// Debug global flag
//
#ifdef DBG
extern ULONG AcpisimDebugMask = 0x00000000;
#endif


//
// Globals
//

PDRIVER_OBJECT_EXTENSION g_DriverObjectExtension = 0;

//
// Define supported IRPs, friendly name them, and associate handlers
//

IRP_DISPATCH_TABLE g_IrpDispatchTable [] = {
    IRP_MJ_PNP,             "PnP Irp",              AcpisimDispatchPnp,
    IRP_MJ_POWER,           "Power Irp",            AcpisimDispatchPower,
    IRP_MJ_DEVICE_CONTROL,  "IOCTL Irp",            AcpisimDispatchIoctl,
    IRP_MJ_CREATE,          "Create Irp",           AcpisimCreateClose,
    IRP_MJ_CLOSE,           "Close Irp",            AcpisimCreateClose,
    IRP_MJ_SYSTEM_CONTROL,  "System Control IRP",   AcpisimDispatchSystemControl
};

//
// Private funtion prototypes
//

NTSTATUS DriverEntry
	(
	    IN PDRIVER_OBJECT DriverObject,
	    IN PUNICODE_STRING RegistryPath 
	);

NTSTATUS
AcpisimGeneralDispatch
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

VOID
AcpisimUnload
    (
        IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
AcpisimAddDevice
    (
        IN PDRIVER_OBJECT DriverObject,
        IN PDEVICE_OBJECT Pdo
    );

//
// Define pageable / init discardable routines
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#endif


NTSTATUS DriverEntry
	(
	IN PDRIVER_OBJECT	DriverObject,
	IN PUNICODE_STRING	RegistryPath 
	)

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise.

--*/

{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    ULONG       count = 0, subcount = 0;

    DBG_PRINT (DBG_INFO, "Entering DriverEntry\n");
    
    status = IoAllocateDriverObjectExtension (DriverObject,
                                              (PVOID) 'GLBL',
                                              sizeof (DRIVER_OBJECT_EXTENSION),
                                              &g_DriverObjectExtension);

    if (!NT_SUCCESS (status)) {
        DBG_PRINT (DBG_ERROR, "Unable to allocate global driver object extension (%lx).\n", status);
        goto EndDriverEntry;
    }

    RtlZeroMemory (g_DriverObjectExtension, sizeof (DRIVER_OBJECT_EXTENSION));
    
    RtlInitUnicodeString (&g_DriverObjectExtension->RegistryPath,
                          (PCWSTR) RegistryPath->Buffer);
    
    g_DriverObjectExtension->DriverObject = DriverObject;

    //
    // Init dispatch points.  We'll use a generic dispatch routine for
    // IRP types we handle.
    //

    while (count <= IRP_MJ_MAXIMUM_FUNCTION) {
        
        for (subcount = 0; subcount < sizeof (g_IrpDispatchTable) / sizeof (IRP_DISPATCH_TABLE); subcount++) {
            
            if (count == g_IrpDispatchTable[subcount].IrpFunction) {
                DriverObject->MajorFunction [count] = AcpisimGeneralDispatch;
            }
        }

        count ++;
    }

    DriverObject->DriverUnload = AcpisimUnload;
    DriverObject->DriverExtension->AddDevice = AcpisimAddDevice;


EndDriverEntry:
    
    DBG_PRINT (DBG_INFO, "Exiting DriverEntry\n");
    return status;
}

NTSTATUS
AcpisimGeneralDispatch
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is a general dispatch routine for supported IRPs.
    
Arguments:

    DeviceObject - pointer to the device object

    Irp - pointer to the IRP being passed in

Return Value:

    status of IRP handling

--*/

{
    PDEVICE_EXTENSION		deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION		irpsp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS				status = STATUS_UNSUCCESSFUL;
    ULONG                   count = 0;
    
    DBG_PRINT (DBG_INFO, "Entering AcpisimGeneralDispatch\n");

    
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    
    //
    // Acquire the remove lock for outstanding I/O
    //

    IoAcquireRemoveLock (&deviceextension->RemoveLock, Irp);
    
    while (count < sizeof (g_IrpDispatchTable) / sizeof (IRP_DISPATCH_TABLE)) {

        if (irpsp->MajorFunction == g_IrpDispatchTable[count].IrpFunction) {
            
            DBG_PRINT (DBG_INFO,
                       "Recognized IRP MajorFunction = 0x%x '%s'.\n",
                       g_IrpDispatchTable[count].IrpFunction,
                       g_IrpDispatchTable[count].IrpName
                       );

            status = g_IrpDispatchTable[count].IrpHandler (DeviceObject, Irp);
            
            goto EndAcpisimProcessIncomingIrp;
        }

        count ++;
    }

    //
    // Unrecognized IRP - pass it on
    //

    DBG_PRINT (DBG_INFO, "Unrecognized IRP MajorFunction = 0x%x\n, pass it on.\n", irpsp->MajorFunction);
    
    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (deviceextension->NextDevice, Irp);

EndAcpisimProcessIncomingIrp:
    
    //
    // If the status is pending, the IRP hasn't "left" our
    // driver yet.  Whoever completes the IRP will do the
    // decrement.
    //
    
    if (status != STATUS_PENDING)
    {
        AcpisimDecrementIrpCount (DeviceObject);
        IoReleaseRemoveLock (&deviceextension->RemoveLock, Irp);
    }
     
    DBG_PRINT (DBG_INFO, "Exiting AcpisimGeneralDispatch\n");
    return status;
}

VOID
AcpisimUnload
    (
        IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the driver unload routine.
    
Arguments:

    DriverObject - pointer to the driver object

Return Value:

    none

--*/

{
    PDRIVER_OBJECT_EXTENSION driverobjectextension = 0;

    driverobjectextension = IoGetDriverObjectExtension (DriverObject,
                                                        (PVOID) 'GLBL');
    if (!driverobjectextension) {
        DBG_PRINT (DBG_ERROR, "Unable to get driver object extension.  Memory will probably leak.\n");

        goto EndAcpisimUnload;
    }

EndAcpisimUnload:

    return;
}

NTSTATUS
AcpisimAddDevice
    (
        IN PDRIVER_OBJECT DriverObject,
        IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This is the driver WDM AddDevice Routine
    
Arguments:

    DriverObject - pointer to the driver object
    Pdo - pointer to PDO for this device

Return Value:

    status of device addition

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT      deviceobject = 0;
    PDEVICE_EXTENSION   deviceextension = 0;
    CONST GUID          guid = ACPISIM_GUID;

    
    DBG_PRINT (DBG_INFO, "Entering AcpisimAddDevice.\n");
    
    //
    // If Pdo is NULL, we are being asked to do legacy detection.
    // Our device is never legacy detected, so return accordingly.
    //

    if (Pdo == NULL) {

        DBG_PRINT (DBG_WARN, "AddDevice - asked to do legacy detection (Pdo = NULL).  Not supported...\n");
        status = STATUS_NO_MORE_ENTRIES;
        goto EndAcpisimAddDevice;
    }

    //
    // Create our FDO.  Don't use a name - we'll use a device interface
    //

    status = IoCreateDevice (DriverObject,
                             sizeof (DEVICE_EXTENSION),
                             0,
                             FILE_DEVICE_UNKNOWN,
                             0,
                             TRUE,
                             &deviceobject);

    if (!NT_SUCCESS (status)) {
        
        DBG_PRINT (DBG_ERROR, "Can't create FDO.  Status = %lx.\n", status);
        goto EndAcpisimAddDevice;
    }

    //
    // Init our device extension
    //

    deviceextension = deviceobject->DeviceExtension;
    RtlZeroMemory (deviceextension, sizeof (DEVICE_EXTENSION));
    
    deviceextension->Signature = ACPISIM_TAG;
    deviceextension->PnpState = PNP_STATE_INITIALIZING;
    deviceextension->OutstandingIrpCount = 1;
    deviceextension->DeviceObject = deviceobject;
    deviceextension->Pdo = Pdo;

    KeInitializeEvent (&deviceextension->IrpsCompleted, SynchronizationEvent, FALSE);

    //
    // Initialize the remove lock
    //

    IoInitializeRemoveLock (&deviceextension->RemoveLock,
                            ACPISIM_TAG,
                            1,
                            20);

    //
    // Attach our newly created FDO to the device stack
    //

    deviceextension->NextDevice = IoAttachDeviceToDeviceStack (deviceobject, Pdo);

    if (!deviceextension->NextDevice) {
        DBG_PRINT (DBG_ERROR, "Error attaching to device stack.  AddDevice failed.\n");

        status = STATUS_UNSUCCESSFUL;
        goto EndAcpisimAddDevice;
    }

    //
    // Set up device object flags
    // Copy DO_POWER_PAGABLE and DO_POWER_INRUSH from next device to
    // play by rules, and avoid bugcheck 0x9F.
    //

    deviceobject->Flags |= (deviceextension->NextDevice->Flags & DO_POWER_PAGABLE);
	deviceobject->Flags |= (deviceextension->NextDevice->Flags & DO_POWER_INRUSH);
	
    //
    // Register our device interface, so we can be accessed from user mode
    //

    status = IoRegisterDeviceInterface (Pdo,
                                        &guid,
                                        NULL,
                                        &deviceextension->InterfaceString);

    if (!NT_SUCCESS (status)) {
        DBG_PRINT (DBG_ERROR, "Error registering device interface.  Status = %lx.\n", status);

        goto EndAcpisimAddDevice;
    }

    AcpisimSetDevExtFlags (deviceobject, DE_FLAG_INTERFACE_REGISTERED);

    //
    // In AddDevice, we cannot determine power state because
    // we are not allowed to touch the hardware.  Initialize
    // it to PowerDeviceUnspecified.
    //

    AcpisimUpdatePowerState (deviceobject, POWER_STATE_WORKING);
    AcpisimUpdateDevicePowerState (deviceobject, PowerDeviceUnspecified);
    
    //
    // We are done adding our device - clear DO_DEVICE_INITIALIZING
    //
    
    deviceobject->Flags &= ~DO_DEVICE_INITIALIZING;
 

EndAcpisimAddDevice:

    //
    // Do cleanup, if necessary
    //

    if (!NT_SUCCESS (status)) {

        if (deviceobject) {

            if (deviceextension->NextDevice) {

                IoDetachDevice (deviceextension->NextDevice);
            }

            IoDeleteDevice (deviceobject);
        }
    }

    DBG_PRINT (DBG_INFO, "Exiting AcpisimAddDevice (%lx).\n", status);
    return status;
}

VOID
AcpisimDbgPrint
    (
    ULONG DebugLevel,
    TCHAR *Text,
    ...
    )

/*++

Routine Description:

    Prints to the debugger if checked build, and the print level
    is unmasked.
        
Arguments:

    DebugLevel - print level to associate message with

    Text - Message to print

Return Value:

    None

--*/

{
    TCHAR textout[2000];
    
    va_list va;
    va_start (va, Text);
    vsprintf (textout, Text, va);
    va_end (va);

#if DBG
    
    if (DebugLevel & AcpisimDebugMask) {
        DbgPrint ("ACPISIM:");
        DbgPrint (textout);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\lib\dispatch.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 pnppower.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Pnp / Power handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_PNPPOWER_H_)
#define _PNPPOWER_H_

//
// Power context structure
//

typedef struct _POWER_CONTEXT {

    PIRP    SIrp;
    PVOID   Context;
} POWER_CONTEXT, *PPOWER_CONTEXT;

#define POWER_CONTEXT_TAG   'misA'

//
// External functions
//

extern
NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

extern
NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

extern
NTSTATUS
AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    );

//
// Public function prototypes
//

NTSTATUS
AcpisimDispatchPnp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimDispatchPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS 
AcpisimDispatchIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimDispatchSystemControl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS 
AcpisimCreateClose
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

#endif // _PNPPOWER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\lib\util.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 util.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Utility module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include "ntddk.h"

//
// Specific includes
//

#include "acpisim.h"
#include "util.h"

//
// Private function prototypes
//

VOID
AcpisimSetDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    )

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->Flags &= Flags;
    
}

VOID
AcpisimClearDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    )

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->Flags &= ~Flags;
    
}

VOID
AcpisimUpdatePnpState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PNP_STATE PnpState
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->PnpState = PnpState;

}

VOID
AcpisimUpdateDevicePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEVICE_POWER_STATE DevicePowerState
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->DevicePowerState = DevicePowerState;
    
}

VOID
AcpisimUpdatePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PWR_STATE PowerState
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->PowerState = PowerState;
    
}

NTSTATUS
AcpisimEnableDisableDeviceInterface
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN BOOLEAN Enable
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    status = IoSetDeviceInterfaceState (&deviceextension->InterfaceString, Enable);

    return status;
}

VOID
AcpisimDecrementIrpCount
    (
        PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    if (!deviceextension->OutstandingIrpCount) {

        DBG_PRINT (DBG_ERROR, "*** Internal consistency error - AcpisimDecrementIrpCount called with OutstandingIrpCount at 0!\n");
    }

    if (!InterlockedDecrement (&deviceextension->OutstandingIrpCount)) {

        DBG_PRINT (DBG_INFO, "All IRPs cleared - remove event signalled.\n");
        KeSetEvent (&deviceextension->IrpsCompleted, 0, FALSE);
    }

    return;
}

PDEVICE_EXTENSION
AcpisimGetDeviceExtension
    (
        PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceextension = DeviceObject->DeviceExtension;

    //
    // Check to make sure it is OUR extension
    //

    ASSERT (deviceextension->Signature == ACPISIM_TAG);

    return deviceextension;
}

PDEVICE_OBJECT
AcpisimLibGetNextDevice
    (
        PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceextension = DeviceObject->DeviceExtension;

    //
    // Check to make sure it is OUR extension
    //

    ASSERT (deviceextension->Signature == ACPISIM_TAG);

    return deviceextension->NextDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\lib\acpisim.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 acpisim.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_ACPISIM_H_)
#define _ACPISIM_H_

//
// includes
//

#include "asimlib.h"


//
// State definitions for PNP
//

typedef enum {
    PNP_STATE_INITIALIZING = 0,
    PNP_STATE_STARTED,
    PNP_STATE_STOPPED,
    PNP_STATE_REMOVED,
    PNP_STATE_SURPRISE_REMOVAL,
    PNP_STATE_STOP_PENDING,
    PNP_STATE_REMOVE_PENDING
} PNP_STATE;

//
// State definitions for Power
//

typedef enum {
    POWER_STATE_WORKING = 0,
    POWER_STATE_POWER_PENDING,
    POWER_STATE_POWERED_DOWN
} PWR_STATE;

//
// Device extension flag types
//

typedef enum {
    DE_FLAG_INTERFACE_REGISTERED = 1,
    DE_FLAG_INTERFACE_ENABLED = 2,
    DE_FLAG_OPREGION_REGISTERED = 4
} DEV_EXT_FLAGS;

//
// Global driver object extension definition
//

typedef struct _DRIVER_OBJECT_EXTENSION {
    UNICODE_STRING      RegistryPath;
    PDRIVER_OBJECT      DriverObject;
} DRIVER_OBJECT_EXTENSION, *PDRIVER_OBJECT_EXTENSION;

//
// Device extension definition
//

typedef struct _DEVICE_EXTENSION {
    ULONG               Signature;
    PNP_STATE           PnpState;
    PWR_STATE           PowerState;
    DEVICE_POWER_STATE  DevicePowerState;
    ULONG               OperationsInProgress;
    ULONG               OutstandingIrpCount;
    ULONG               HandleCount;
    UNICODE_STRING      InterfaceString;
    KEVENT              IrpsCompleted;
    PDEVICE_OBJECT      NextDevice;
    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      Pdo;
    DEVICE_POWER_STATE  PowerMappings [6];
    IO_REMOVE_LOCK      RemoveLock;

    //
    // Project specific fields
    //
    
    DEV_EXT_FLAGS       Flags;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Irp dispatch routine handler function prototype
//

typedef
NTSTATUS
(*PIRP_DISPATCH_ROUTINE) (
                            IN PDEVICE_OBJECT   DeviceObject,
                            IN PIRP             Irp
                         );
//
// Irp dispatch table definition
//

typedef struct _IRP_DISPATCH_TABLE {
    ULONG                   IrpFunction;
    TCHAR                   IrpName[50];
    PIRP_DISPATCH_ROUTINE   IrpHandler;
} IRP_DISPATCH_TABLE, *PIRP_DISPATCH_TABLE;

//
// Public function prototypes
//

#endif // _ACPISIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\lib\util.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 util.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Utility module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_UTIL_H_)
#define _UTIL_H_


//
// Public function prototypes
//                

VOID
AcpisimSetDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    );

VOID
AcpisimClearDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    );

VOID
AcpisimUpdatePnpState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PNP_STATE PnpState
    );
VOID
AcpisimUpdateDevicePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEVICE_POWER_STATE DevicePowerState
    );

VOID
AcpisimUpdatePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PWR_STATE PowerState
    );

NTSTATUS
AcpisimEnableDisableDeviceInterface
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN BOOLEAN Enable
    );

VOID
AcpisimDecrementIrpCount
    (
        PDEVICE_OBJECT DeviceObject
    );

PDEVICE_EXTENSION
AcpisimGetDeviceExtension
    (
        PDEVICE_OBJECT DeviceObject
    );


#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\lib\dispatch.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 dispatch.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Pnp / Power handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:

           
Revision History:
	 

--*/

//
// General includes
//

#include "ntddk.h"

//
// Specific includes
//

#include "acpisim.h"
#include "dispatch.h"
#include "util.h"

//
// Private function prototypes
//

NTSTATUS
AcpisimPnpStartDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpQueryStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpCancelStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpQueryRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpCancelRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpSurpriseRemoval
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpQueryCapabilities
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPowerQueryPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPowerSetPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPowerSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimQueryPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimSetPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimCompletionRoutine
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );

NTSTATUS
AcpisimForwardIrpAndWait
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimIssuePowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );

NTSTATUS
AcpisimCompleteSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN UCHAR MinorFunction,
        IN POWER_STATE PowerState,
        IN PVOID Context,
        IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
AcpisimD0Completion
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );

VOID
AcpisimInitDevPowerStateTable 
    (
        IN PDEVICE_OBJECT   DeviceObject
    );


//
// Pnp minor dispatch table
//

IRP_DISPATCH_TABLE PnpDispatchTable[] = {
    IRP_MN_START_DEVICE,        "Pnp/START_DEVICE",         AcpisimPnpStartDevice,
    IRP_MN_STOP_DEVICE,         "Pnp/STOP_DEVICE",          AcpisimPnpStopDevice,
    IRP_MN_QUERY_STOP_DEVICE,   "Pnp/QUERY_STOP_DEVICE",    AcpisimPnpQueryStopDevice,
    IRP_MN_CANCEL_STOP_DEVICE,  "Pnp/CANCEL_STOP_DEVICE",   AcpisimPnpCancelStopDevice,
    IRP_MN_REMOVE_DEVICE,       "Pnp/REMOVE_DEVICE",        AcpisimPnpRemoveDevice,
    IRP_MN_QUERY_REMOVE_DEVICE, "Pnp/QUERY_REMOVE_DEVICE",  AcpisimPnpQueryRemoveDevice,
    IRP_MN_CANCEL_REMOVE_DEVICE,"Pnp/CANCEL_REMOVE_DEVICE", AcpisimPnpCancelRemoveDevice,
    IRP_MN_SURPRISE_REMOVAL,    "Pnp/SURPRISE_REMOVAL",     AcpisimPnpSurpriseRemoval,
    IRP_MN_QUERY_CAPABILITIES,  "Pnp/QUERY_CAPABILITIIES",  AcpisimPnpQueryCapabilities
};

//
// Power minor dispatch table
//

IRP_DISPATCH_TABLE PowerDispatchTable[] = {
    IRP_MN_QUERY_POWER,         "Power/QUERY_POWER",        AcpisimPowerQueryPower,
    IRP_MN_SET_POWER,           "Power/SET_POWER",          AcpisimPowerSetPower
};

NTSTATUS
AcpisimDispatchPnp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the pnp IRP handler.  It checks the minor code,
    and passes on to the appropriate minor handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;

    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchPnp.\n");

    while (count < sizeof (PnpDispatchTable) / sizeof (IRP_DISPATCH_TABLE)) {

        if (irpsp->MinorFunction == PnpDispatchTable[count].IrpFunction) {
            DBG_PRINT (DBG_INFO,
                       "Recognized PnP IRP 0x%x '%s'.\n",
                       irpsp->MinorFunction,
                       PnpDispatchTable[count].IrpName);

            status = PnpDispatchTable[count].IrpHandler (DeviceObject, Irp);

            goto EndAcpisimDispatchPnp;
        }
        
        count ++;
    }

    DBG_PRINT (DBG_INFO, "Unrecognized PnP IRP 0x%x, pass it on.\n", irpsp->MinorFunction);
    
    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (deviceextension->NextDevice, Irp);
    
EndAcpisimDispatchPnp:

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchPnp.\n");
    return status;
}

NTSTATUS
AcpisimDispatchPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the power IRP handler.  It checks the minor code,
    and passes on to the appropriate minor handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;

    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchPower.\n");

    while (count < sizeof (PowerDispatchTable) / sizeof (IRP_DISPATCH_TABLE)) {

        if (irpsp->MinorFunction == PowerDispatchTable[count].IrpFunction) {
            DBG_PRINT (DBG_INFO,
                       "Recognized Power IRP 0x%x '%s'.\n",
                       irpsp->MinorFunction,
                       PowerDispatchTable[count].IrpName);

            status = PowerDispatchTable[count].IrpHandler (DeviceObject, Irp);

            goto EndAcpisimDispatchPower;
        }

        count ++;
    }

    DBG_PRINT (DBG_INFO, "Unrecognized Power IRP 0x%x, pass it on.\n", irpsp->MinorFunction);
    
    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (deviceextension->NextDevice, Irp);
    
EndAcpisimDispatchPower:

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchPower.\n");
    return status;
}

NTSTATUS
AcpisimPnpStartDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Start Device handler.  It enables the device interface
    and registers the operation region handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP_MN_START_DEVICE processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    KIRQL               oldirql;
    
    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpStartDevice.\n");
    
    //
    // We handle this IRP on the way back up.
    //
    
    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    ASSERT (NT_SUCCESS (status));

    if ((status != STATUS_SUCCESS && status != STATUS_PENDING) || !NT_SUCCESS (Irp->IoStatus.Status)) {

        DBG_PRINT (DBG_ERROR,
                   "Error processing, or lower driver failed start IRP.  IoCallDriver = %lx, Irp->IoStatus.Status = %lx\n",
                   status,
                   Irp->IoStatus.Status);

        goto EndAcpisimPnpStartDevice;
    }

    //
    // Check to see if we are already started.  If we are,
    // just return success since we aren't using resources
    // anyway.
    //
    
    if (deviceextension->PnpState == PNP_STATE_STARTED) {

        status = STATUS_SUCCESS;
        goto EndAcpisimPnpStartDevice;
    }

    //
    // Enable our device interface
    //
    
    status = AcpisimEnableDisableDeviceInterface (DeviceObject, TRUE);

    ASSERT (NT_SUCCESS (status));
    
    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "Error enabling device interface.  Fail the start. Status = %lx.\n",
                   status);

        Irp->IoStatus.Status = status;
        
        goto EndAcpisimPnpStartDevice;
    }

    AcpisimSetDevExtFlags (DeviceObject, DE_FLAG_INTERFACE_ENABLED);

    //
    // Typically, we would check the state of our hardware, and
    // set our internal power state to reflect the current state
    // of the hardware.  However, in this case we are a virtual
    // device, and it is safe to assume we are in D0 when we
    // receive IRP_MN_START_DEVICE.
    //

    AcpisimUpdatePowerState (DeviceObject, POWER_STATE_WORKING);
    AcpisimUpdateDevicePowerState (DeviceObject, PowerDeviceD0);

    //
    // Finally, we can register our operation region handler.
    //

    status = AcpisimRegisterOpRegionHandler (DeviceObject);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "Couldn't register op region handler (%lx).  Fail start IRP.\n",
                   status);

        goto EndAcpisimPnpStartDevice;
    }

    AcpisimSetDevExtFlags (DeviceObject, DE_FLAG_OPREGION_REGISTERED);


EndAcpisimPnpStartDevice:
       
    //
    // If we completed the start successfully, change our pnp state
    // to PNP_STARTED
    //

    if (NT_SUCCESS (status)) {

        AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STARTED);
        
    } else {

        AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STOPPED);
    }

    //
    // Because we are handling this IRP "on the way up", we need
    // to complete it when we are done working with it.
    //
    
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpStartDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )
/*++

Routine Description:

    This is the Pnp Stop Device handler.  It checks to see if
    there are any outstanding requests, and fails the stop IRP 
    if there are.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP_MN_STOP_DEVICE processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpStopDevice.\n");
    
    //
    // BUGBUG - We currently don't handle the case where
    // there is still an outstanding request at stop
    // time.  If we were to do things correctly, we'd 
    // complete any outstanding requests in the driver
    // with an appropriate error code.  In this 
    // particular case, if a request happened to squeak
    // by our check at QUERY STOP time, it is likely
    // the request would not be completed at all.
    //

    //
    // Oh, and we had better not have LESS then 2 count
    // or we've got a bug somewhere.
    //

    if (deviceextension->OutstandingIrpCount < 2) {
        DBG_PRINT (DBG_WARN,
               "Possible internal consistency error - OutstandingIrpCount too low.\n");
    }
    
    ASSERT (deviceextension->OutstandingIrpCount == 2);
    
    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "IRP_MN_STOP forwarding failed (%lx).\n",
                   status);

        goto EndAcpisimPnpStopDevice;
    }

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STOPPED);
    
EndAcpisimPnpStopDevice:
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpStopDevice.\n");

    return status;
}

NTSTATUS
AcpisimPnpQueryStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Query Stop Device handler.  If there are any
    outstanding requests, it vetos the IRP.
    
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP_MN_QUERY_STOP_DEVICE processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    
    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpQueryStopDevice.\n");
    
    //
    // Let existing IRPs in the driver complete before we say OK.
    // But to do this, we need to get the OutstandingIrpsCount
    // right.  Subtract 2 since we are biased to 1, and we have an
    // additional 1 for the QUERY_STOP IRP.
    //

    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);
    
    status = KeWaitForSingleObject (&deviceextension->IrpsCompleted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    0);

    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    KeResetEvent (&deviceextension->IrpsCompleted);
    
    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "KeWaitForSingleObject failed (%lx). IRP_MN_QUERY_STOP failed.\n",
                   status);

        IoSkipCurrentIrpStackLocation (Irp);
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        status = IoCallDriver (deviceextension->NextDevice, Irp);

        ASSERT (NT_SUCCESS (status));

        goto EndPnpQueryStopDevice;
    }
    
    //
    // We can stop - change our state to stopping, and pass it on.
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STOP_PENDING);

EndPnpQueryStopDevice:
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpQueryStopDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpCancelStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Cancel Stop Device handler.  It does nothing
    more then returns the pnp state to started.  This is a virtual
    device so there is no work to do.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpCancelStopDevice.\n");

    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "IRP_MN_CANCEL_STOP forwarding failed (%lx).\n",
                   status);

        goto EndPnpCancelStopDevice;
    }
    
    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, 0);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STARTED);

EndPnpCancelStopDevice:

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpCancelStopDevice.\n");

    return status;
}

NTSTATUS
AcpisimPnpRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Remove Device handler.  It de-registers the
    operation region handler, detaches the device object, and
    deletes it if all goes well.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    status of removal operation

--*/


{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PDEVICE_OBJECT      nextdevice = deviceextension->NextDevice;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpRemoveDevice.\n");
    
    //
    // BUGBUG - We currently don't handle the case where
    // there is still an outstanding request at remove
    // time.  If we were to do things correctly, we'd 
    // complete any outstanding requests in the driver
    // with an appropriate error code.  In this 
    // particular case, if a request happened to squeak
    // by our check at QUERY REMOVE time, it is likely
    // the request would not be completed at all.
    //
    
    //
    // Our OutstandingIrpCount logic is biased to 1.  So
    // if we are processing a remove IRP, and there are
    // no other requests in the driver, OustandingIrpCount
    // had better be 2.
    
    if (deviceextension->OutstandingIrpCount < 2) {
        DBG_PRINT (DBG_WARN,
               "Possible internal consistency error - OutstandingIrpCount too low.\n");
    }
    
    ASSERT (deviceextension->OutstandingIrpCount == 2);

    //
    // Ok, we are ready to remove the device.  Shut down the
    // interface, deregister the opregion handler, and
    // delete the device object.
    //

    status = AcpisimEnableDisableDeviceInterface (DeviceObject, FALSE);

    ASSERT (NT_SUCCESS (status));

    if (NT_SUCCESS (status)) {

        AcpisimClearDevExtFlags (DeviceObject, DE_FLAG_INTERFACE_ENABLED);
    }

    status = AcpisimUnRegisterOpRegionHandler (DeviceObject);

    ASSERT (NT_SUCCESS (status));

    if (NT_SUCCESS (status)) {

        AcpisimClearDevExtFlags (DeviceObject, DE_FLAG_OPREGION_REGISTERED);
    }
    
    RtlFreeUnicodeString (&deviceextension->InterfaceString);

    IoDetachDevice (deviceextension->NextDevice);
    IoDeleteDevice (DeviceObject);

    //
    // Now, pass it on...
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (nextdevice, Irp);

    ASSERT (NT_SUCCESS (status));
    if (!NT_SUCCESS (status)) {
        
        DBG_PRINT (DBG_ERROR,
                   "Passing remove IRP onto next driver failed for some reason (%lx).\n",
                   status);
    }
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpRemoveDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpQueryRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Query Remove Device handler.  It waits for
    existing requests in the driver to finish, and then completes
    the IRP successfully.
            
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status of query remove device operation

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpQueryRemoveDevice.\n");

    //
    // Make sure our state is correct
    //

    ASSERT (deviceextension->OutstandingIrpCount >= 2);
    
    //
    // Let existing IRPs in the driver complete before we say OK.
    // But to do this, we need to get the OutstandingIrpsCount
    // right.  Subtract 2 since we are biased to 1, and we have an
    // additional 1 for the QUERY_STOP IRP.
    //
    
    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);

    status = KeWaitForSingleObject (&deviceextension->IrpsCompleted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    0);

    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    KeResetEvent (&deviceextension->IrpsCompleted);
    
    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "KeWaitForSingleObject failed (%lx). IRP_MN_QUERY_REMOVE failed.\n",
                   status);

        IoSkipCurrentIrpStackLocation (Irp);
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        status = IoCallDriver (deviceextension->NextDevice, Irp);

        ASSERT (NT_SUCCESS (status));

        goto EndPnpQueryRemoveDevice;
    }
    
    //
    // We can remove - change our state to remove pending, and pass it on.
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_REMOVE_PENDING);

EndPnpQueryRemoveDevice:
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpQueryRemoveDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpCancelRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )
/*++

Routine Description:

    This is the Pnp Cancel Remove Device handler.  It does nothing
    more then returns the pnp state to started.  This is a virtual
    device so there is no work to do.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpCancelRemoveDevice.\n");

    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "IRP_MN_CANCEL_REMOVE forwarding failed (%lx).\n",
                   status);

        goto EndPnpCancelRemoveDevice;
    }
    
    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, 0);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STARTED);

EndPnpCancelRemoveDevice:

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpCancelRemoveDevice.\n");    

    return status;
}

NTSTATUS
AcpisimPnpSurpriseRemoval
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Surprise Remove handler.  It basically updates
    the state, and passes the IRP on.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpSurpriseRemoval.\n");

    //
    // Again, because we are a virtual device, handling
    // surprise remove is really a no-op.  Just update
    // our state, and succeed the IRP.
    //

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_SURPRISE_REMOVAL);

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpSurpriseRemoval.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpQueryCapabilities
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MN_QUERY_CAPABILITIES.  We need this
    information to build our power state table correctly.  All
    we do here is set a completion routine, as we need to gather this
    data after the PDO has filled out DeviceState.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status of operation

--*/


{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp;
    UCHAR               count = 0;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpQueryCapabilities.\n");
    
    //
    // Fill out the power mapping table with a default
    //

    AcpisimInitDevPowerStateTable (DeviceObject);
    
    //
    // Handle this IRP after the PDO has filled out the structure
    //
    
    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR, "Somebody failed the QUERY_CAPABILITIES IRP...\n");
        goto EndAcpisimPnpQueryCapabilities;
    }

    irpsp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Update our power mappings with what we found in the device
    // capabilities structure.  We only use valid mappings, e.g.
    // PowerDeviceUnspecified is ignored.
    //
    
    DBG_PRINT (DBG_INFO, "Device mappings:\n");
    
    for (count = 0; count < 6; count ++) {

        if (irpsp->Parameters.DeviceCapabilities.Capabilities->DeviceState[count + 1] != PowerDeviceUnspecified) {

            deviceextension->PowerMappings[count] = irpsp->Parameters.DeviceCapabilities.Capabilities->DeviceState [count + 1];
        }
        
        DBG_PRINT (DBG_INFO, "S%d --> D%d\n", count, deviceextension->PowerMappings[count] - 1);    
    }

    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;

EndAcpisimPnpQueryCapabilities:

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpQueryCapabilities.\n");

    return status;
}

NTSTATUS
AcpisimPowerQueryPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the QUERY Power handler.  It determines if the power
    IRP is an S or D IRP, and passes it on to the proper handler.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

     DBG_PRINT (DBG_INFO,
               "Entering AcpisimPowerQueryPower.\n");
    
    switch (irpsp->Parameters.Power.Type) {
    
    case SystemPowerState:
        
        status = AcpisimPowerSIrp (DeviceObject, Irp);
        break;

    case DevicePowerState:

        status = AcpisimQueryPowerDIrp (DeviceObject, Irp);
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Undefined QUERY Power IRP type.  Ignoring.\n");

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (deviceextension->NextDevice, Irp);
    }
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPowerQueryPower.\n");
    
    return status;
}

NTSTATUS
AcpisimPowerSetPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the SET Power handler.  It determines if the power
    IRP is an S or D IRP, and passes it on to the proper handler.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPowerSetPower.\n");

    switch (irpsp->Parameters.Power.Type) {
    
    case SystemPowerState:
        
        status = AcpisimPowerSIrp (DeviceObject, Irp);
        break;

    case DevicePowerState:

        status = AcpisimSetPowerDIrp (DeviceObject, Irp);
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Undefined SET Power IRP type.  Ignoring.\n");

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (deviceextension->NextDevice, Irp);
    }

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPowerSetPower.\n");
    
    return status;
}

NTSTATUS
AcpisimPowerSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the power handler for S IRPs.  It sets a
    completion routine, which will queue a D IRP.  We don't
    do anything unless it is a D IRP.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPowerSIrp.\n");

    IoMarkIrpPending (Irp);	

    IoCopyCurrentIrpStackLocationToNext (Irp);
	IoSetCompletionRoutine (Irp,
                            AcpisimIssuePowerDIrp,
                            0,
                            TRUE,
                            TRUE,
                            TRUE);
	
    PoCallDriver (deviceextension->NextDevice, Irp);
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPowerSIrp.\n");
    
    return STATUS_PENDING;
}

NTSTATUS
AcpisimQueryPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the QUERY Power DIrp handler.  Validate the state, and
    say yes.  
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimQueryPowerDIrp.\n");
    
    //
    // Here, we are supposed to figure out if we can go to the
    // power state specified by the IRP.  Since we are a virtual
    // device, we don't have a good reason to not go to a different
    // power state.  Update our state, and wait to complete requests.
    //
    
    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);


    status = KeWaitForSingleObject (&deviceextension->IrpsCompleted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    0);

    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    KeResetEvent (&deviceextension->IrpsCompleted);

    ASSERT (NT_SUCCESS (status));

    //
    // Validate the D IRP
    //

    switch (irpsp->Parameters.Power.State.DeviceState) {
    case PowerDeviceD0:
    case PowerDeviceD1:
    case PowerDeviceD2:
    case PowerDeviceD3:

        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWER_PENDING);
        status = STATUS_SUCCESS;
        break;

    default:

        ASSERT (0);
        DBG_PRINT (DBG_ERROR,
                   "AcpisimQueryPowerDIrp: Illegal or unknown PowerDeviceState.  Failing.\n");
        
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    PoStartNextPowerIrp (Irp);
	IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = status;
    status = PoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));

    DBG_PRINT (DBG_INFO,
               "Leaving AcpisimQueryPowerDIrp.\n");
    
    return status;
}

NTSTATUS
AcpisimSetPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )
{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    POWER_STATE         powerstate;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimSetPowerDIrp.\n");
    
    //
    // Validate the D IRP
    //

    switch (irpsp->Parameters.Power.State.DeviceState) {
    
    //
    // For D0, if we are powered down, we need to pass the IRP down, and
    // set a completion routine.  We need the PDO to succeed the power
    // up before we do.
    //
    
    case PowerDeviceD0:

        if (deviceextension->PowerState != POWER_STATE_WORKING) {

            IoCopyCurrentIrpStackLocationToNext (Irp);
	        
            IoSetCompletionRoutine (Irp,
                                    AcpisimD0Completion,
                                    0,
                                    TRUE,
                                    TRUE,
                                    TRUE);
	
            IoMarkIrpPending (Irp); 
            PoCallDriver (deviceextension->NextDevice, Irp);
            status = STATUS_PENDING;
            goto EndAcpisimSetPowerDIrp;
        }
        
        break;

    case PowerDeviceD1:
        
        powerstate.DeviceState = PowerDeviceD1;
        PoSetPowerState (DeviceObject, DevicePowerState, powerstate);
        
        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWERED_DOWN);
        AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);
        status = STATUS_SUCCESS;
        break;

    case PowerDeviceD2:
        
        powerstate.DeviceState = PowerDeviceD2;
        PoSetPowerState (DeviceObject, DevicePowerState, powerstate);

        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWERED_DOWN);
        AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);
        status = STATUS_SUCCESS;
        break;

    case PowerDeviceD3:
        
        powerstate.DeviceState = PowerDeviceD3;
        PoSetPowerState (DeviceObject, DevicePowerState, powerstate);
        
        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWERED_DOWN);
        AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);
        status = STATUS_SUCCESS;
        break;

    default:

        ASSERT (0);
        DBG_PRINT (DBG_ERROR,
                   "AcpisimSetPowerDIrp: Illegal or unknown PowerDeviceState.  Failing.\n");
        
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    PoStartNextPowerIrp (Irp);
	IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = status;
    status = PoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));

EndAcpisimSetPowerDIrp:

    DBG_PRINT (DBG_INFO,
               "Leaving AcpisimSetPowerDIrp.\n");

    return status;
}

NTSTATUS
AcpisimCompletionRoutine
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    )

/*++

Routine Description:

    This is the generic Irp completion routine for when we
    want to wait for an IRP to be completed by the PDO and
    do post-completion work.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP
    
    Context - Context passed in by IoSetCompletionRoutine.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    DBG_PRINT (DBG_INFO,
               "Entering AcpisimCompletionRoutine.\n");

    KeSetEvent (Context, 0, FALSE);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimCompletionRoutine.\n");

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AcpisimForwardIrpAndWait
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This forwards the IRP down the device stack, sets
    a completion routine, and waits on the completion
    event. Useful for doing IRP post-completion, based
    on the result of the completion.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    The status set in the IRP when the IRP was completed.

--*/

{
    KEVENT              context;
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimForwardIrpAndWait.\n");
    
    KeInitializeEvent (&context, SynchronizationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp,
                            AcpisimCompletionRoutine,
                            &context,
                            TRUE,
                            TRUE,
                            TRUE);

    status = IoCallDriver (deviceextension->NextDevice, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject (&context,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        status = Irp->IoStatus.Status;
    }

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimForwardIrpAndWait.\n");

    return status;
}

NTSTATUS
AcpisimIssuePowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    )

/*++

Routine Description:

    This is the S-IRP completion routine.  It examines the completed
    IRP, and if there are no problems, asks the power manager to 
    send us the appropriate D-IRP.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

    Context - Context passed into IoSetCompletionRoutine
    
Return Value:

    Status of requesting D-IRP operation.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    POWER_STATE         powerstate;
    PPOWER_CONTEXT      context = NULL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimIssuePowerDIrp.\n");
    
    powerstate.DeviceState = PowerDeviceUnspecified;

    //
    // Make sure this IRP wasn't failed by the PDO or Lower FFDO
    //

    if (!NT_SUCCESS (Irp->IoStatus.Status)) {

        DBG_PRINT (DBG_INFO,
                   "AcpisimIssuePowerDIrp:  Lower FFDO, BFDO, or PDO failed this IRP (%lx).\n",
                   status);

        status = Irp->IoStatus.Status;
        
        goto EndAcpisimIssuePowerDIrp;
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {

        //
        // Ok, everybody is agreeing to this S state.  Send ourselves
        // the appropriate D IRP.
        //
        
        //
        // Make sure this is an S Irp
        //

        ASSERT (irpsp->Parameters.Power.Type == SystemPowerState);

        if (irpsp->Parameters.Power.Type != SystemPowerState) {

            DBG_PRINT (DBG_ERROR,
                       "Didn't recieve an S Irp when we expected to, or somebody messed up the IRP.  Fail it.\n");

            status = STATUS_INVALID_DEVICE_REQUEST;

            goto EndAcpisimIssuePowerDIrp;
        }

        ASSERT (irpsp->MinorFunction == IRP_MN_QUERY_POWER || irpsp->MinorFunction == IRP_MN_SET_POWER);
        
        if (irpsp->MinorFunction != IRP_MN_QUERY_POWER && irpsp->MinorFunction != IRP_MN_SET_POWER) {

            DBG_PRINT (DBG_ERROR,
                       "Irp isn't SET or QUERY.  Not sure why this wasn't caught earlier (somebody probably messed it up).\nWe don't support any other type.  Fail it.\n");

            status = STATUS_INVALID_DEVICE_REQUEST;

            goto EndAcpisimIssuePowerDIrp;
        }

        //
        // Make sure the S IRP is valid
        //

        if (irpsp->Parameters.Power.State.SystemState >= PowerSystemMaximum) {
            
            ASSERT (0);

            DBG_PRINT (DBG_ERROR,
                       "Received an undefined S IRP, or somebody messed up the IRP.  Fail it.\n");

            status = STATUS_INVALID_DEVICE_REQUEST;
            goto EndAcpisimIssuePowerDIrp;
        }

        //
        // Use our power mapping table to convert S-->D state
        //
        
        powerstate.DeviceState = deviceextension->PowerMappings [irpsp->Parameters.Power.State.SystemState - 1];

        DBG_PRINT (DBG_INFO,
                       "S%d --> D%d\n", irpsp->Parameters.Power.State.SystemState - 1, powerstate.DeviceState - 1);

        //
        // We need a context to pass a pointer to the S IRP to the D IRP handler
        // and a pointer to the device object.
        //
        
        context = ExAllocatePoolWithTag (NonPagedPool,
                                         sizeof (POWER_CONTEXT)+4,
                                         POWER_CONTEXT_TAG);

        if (!context) {

            DBG_PRINT (DBG_ERROR,
                       "Unable to allocate memory for the context.\n");

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto EndAcpisimIssuePowerDIrp;
        }

        context->SIrp = Irp;
        context->Context = DeviceObject;

        //
        // Send the D Irp
        //
        
        status = PoRequestPowerIrp (deviceextension->Pdo,
                                    irpsp->MinorFunction,
                                    powerstate,
                                    AcpisimCompleteSIrp,
                                    context,
                                    NULL);

        ASSERT (NT_SUCCESS (status));

        if (!NT_SUCCESS (status)) {

            DBG_PRINT (DBG_ERROR,
                       "AcpisimIssuePowerDIrp:  PoRequestPowerIrp failed (%lx).\n");

            goto EndAcpisimIssuePowerDIrp;
        }
    }

    status = STATUS_MORE_PROCESSING_REQUIRED;
    
EndAcpisimIssuePowerDIrp:
    
    //
    // We need to complete the request if something went wrong.  Also note,
    // it is not necessary to assume our state is S0/D0 again.  The power 
    // manager will send us an S0 IRP.
    //
    
    if (!NT_SUCCESS (status)  && status != STATUS_MORE_PROCESSING_REQUIRED) {

        DBG_PRINT (DBG_ERROR,
                   "AcpisimIssuePowerDIrp:  Something bad happened.  Just complete the S Irp with an error.");
        
        PoStartNextPowerIrp (Irp);    
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        IoReleaseRemoveLock (&deviceextension->RemoveLock, Irp);

        AcpisimDecrementIrpCount (DeviceObject);
        
        if (context) {

            ExFreePool (context);
        }
    }
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimIssuePowerDIrp.\n");
    
    return status;
}

NTSTATUS
AcpisimCompleteSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN UCHAR MinorFunction,
        IN POWER_STATE PowerState,
        IN PVOID Context,
        IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This is the S-Irp completion routine set by PoRequestPowerIrp.
        
Arguments:

    DeviceObject - pointer to the FDO
    
    MinorFunction - type of request
    
    PowerState - type of IRP
    
    Context - Context passed into PoRequestPowerIrp
    
    IoStatus - IoStatus block of completed D Irp

    
Return Value:

    STATUS_SUCCESS

--*/

{
    PPOWER_CONTEXT      context = (PPOWER_CONTEXT) Context;
    PDEVICE_OBJECT      deviceobject = context->Context;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (deviceobject);
    PIRP                sirp = context->SIrp;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimCompleteSIrp.\n");

    //
	// Propagate the device power IRP's status in the system power IRP
	//

	sirp->IoStatus.Status = IoStatus->Status;

    //
	// Tell the power manager we are done with this IRP
	//

	PoStartNextPowerIrp (sirp);
	
    IoCompleteRequest (sirp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&deviceextension->RemoveLock, sirp);
    ExFreePool (Context);

    //
    // Normally our dispatch routine decrements IRP counts,
    // but since it was returned STATUS_PENDING, it wasn't
    // decremented earlier
    //

    AcpisimDecrementIrpCount (deviceobject);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimCompleteSIrp.\n");

    return STATUS_SUCCESS;
}

NTSTATUS
AcpisimD0Completion
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    )

/*++

Routine Description:

    This is the D0 Irp completion routine
        
Arguments:

    DeviceObject - pointer to the FDO
    
    MinorFunction - type of request
    
    Context - Context passed into IoSetCompletionRoutine
    
    
Return Value:

    Error status or STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    POWER_STATE         powerstate;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimD0Completion.\n");
    
    //
    // Make sure this IRP wasn't failed by the PDO or Lower FFDO
    //

    if (!NT_SUCCESS (Irp->IoStatus.Status)) {

        DBG_PRINT (DBG_INFO,
                   "AcpisimD0Completion:  Lower FFDO, BFDO, or PDO failed this IRP (%lx).\n",
                   status);
        
        status = Irp->IoStatus.Status;
        
        goto EndAcpisimD0Completion;
    }

    //
    // This is where we do actual D0 transition work.  Since this
    // is a virtual device, the only thing we do is change our
    // internal state.
    //

    AcpisimUpdatePowerState (DeviceObject, POWER_STATE_WORKING);
    AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);

    powerstate.DeviceState = PowerDeviceD0;
    PoSetPowerState (DeviceObject, DevicePowerState, powerstate);
    
    status = STATUS_MORE_PROCESSING_REQUIRED;
    
EndAcpisimD0Completion:

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&deviceextension->RemoveLock, Irp);
    AcpisimDecrementIrpCount (DeviceObject);
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimD0Completion.\n");

    return status;

}

VOID
AcpisimInitDevPowerStateTable 
    (
        IN PDEVICE_OBJECT   DeviceObject
    )

/*++

Routine Description:

    This routine fills out the power mapping structure with defaults.
    We simply default to using D3 in any non-S0 state.
        
Arguments:

    DeviceObject - pointer to the FDO
    
Return Value:

    None

--*/

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    UCHAR   count;

    deviceextension->PowerMappings[0] = PowerDeviceD0;

    for (count = 1; count < 5; count ++) {

        deviceextension->PowerMappings[count] = PowerDeviceD3;
    }
}

NTSTATUS AcpisimDispatchIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for IOCTL requests.  We just call the supplied
    function to handle the IOCTL, or pass it on if the handler doesn't
    handle it.
    
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;
    
    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchIoctl\n");

    status = AcpisimHandleIoctl (DeviceObject, Irp);

    if (status == STATUS_NOT_SUPPORTED) {

        //
        // IOCTL wasn't handled, pass it on...
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (AcpisimLibGetNextDevice (DeviceObject), Irp);

    } else {

        //
        // IOCTL was handled, complete it.
        //

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchIoctl\n");
    return status;
}

NTSTATUS
AcpisimDispatchSystemControl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for System Control requests. Since we currently
    don't support any System Control calls, we are just going to pass
    them on to the next driver.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IoCallDriver

--*/

{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchSystemControl\n");
    
    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (AcpisimLibGetNextDevice (DeviceObject), Irp);

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchSystemControl\n");

    return status;
}

NTSTATUS AcpisimCreateClose
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for CreateFile and CloseHandle requests.
    We do nothing except update our internal extension to track
    the number of outstanding handles.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION      irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION       deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    ASSERT (irpsp->MajorFunction == IRP_MJ_CREATE || irpsp->MajorFunction == IRP_MJ_CLOSE);

    switch (irpsp->MajorFunction) {
    
    case IRP_MJ_CREATE:
        InterlockedIncrement (&deviceextension->HandleCount);
        status = STATUS_SUCCESS;
        break;

    case IRP_MJ_CLOSE:
        InterlockedDecrement (&deviceextension->HandleCount);
        status = STATUS_SUCCESS;
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "AcpisimCreateClose - unexpected Irp type.\n");

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, 0);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\app\asapp1\asapp1.c ===
/*++

Copyright (c) 2001  Microsoft Corporation 

Module Name:

	 asapp1.c

Abstract:

    This application is used with the ACPI BIOS Simulator.

Author(s):

    Vincent Geglia (vincentg) 06-Apr-2001
     
Environment:

	 Console App; User mode

Notes:


Revision History:

    

--*/


//
// General includes
//

#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "malloc.h"
#include "setupapi.h"
#include "devioctl.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimictl.h"

//
// Function definitions
//

void
__cdecl
main(
	 int    argc,
     char   *argv[]
	 )
{
    HDEVINFO                            deviceinfo = INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA            deviceinterfacedata;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    deviceinterfacedetaildata = 0;
    BOOL                                success = FALSE;
    CONST GUID                          guid = ACPISIM_GUID;
    DWORD                               size = 0;
    UCHAR                               methodname [4];
    HANDLE                              device = INVALID_HANDLE_VALUE;

    if (argc < 2) {

        printf ("Usage:  %s <ACPI method to execute>\n\n", argv[0]);
        goto Exitmain;
    }

    if (strlen (argv[1]) > 4) {

        printf ("Method name too long (4 chars max).\n\n");
        goto Exitmain;
    }

    ZeroMemory (&methodname, sizeof (methodname));

    CopyMemory (&methodname, argv[1], strlen (argv[1]));

    printf ("Method to execute:%c%c%c%c\n",
            methodname[0],
            methodname[1],
            methodname[2],
            methodname[3]);
    
    deviceinterfacedata.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    deviceinfo = SetupDiGetClassDevs (&guid,
                                      NULL,
                                      NULL,
                                      DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (deviceinfo == INVALID_HANDLE_VALUE) {

        printf ("Error enumerating ACPISIM device instances.\n");
        goto Exitmain;
    }

    success = SetupDiEnumDeviceInterfaces (deviceinfo,
                                           NULL,
                                           &guid,
                                           0,
                                           &deviceinterfacedata);

    if (!success) {

        printf ("Error enumerating ACPISIM device interface instances.\n");
        goto Exitmain;
    }

    //
    // Find out how big our buffer needs to be
    //

    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               NULL,
                                               0,
                                               &size,
                                               NULL);

    if (!size) {

        printf ("Error getting device interface size.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata = (PSP_DEVICE_INTERFACE_DETAIL_DATA) malloc (size);

    if (!deviceinterfacedetaildata) {

        printf ("Unable to allocate memory.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
    
    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               deviceinterfacedetaildata,
                                               size,
                                               NULL,
                                               NULL);

    if (!success) {

        printf ("Error getting device interface detail.\n");
        goto Exitmain;
    }
    
    device = CreateFile (
                         deviceinterfacedetaildata->DevicePath,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                         );

    if (device == INVALID_HANDLE_VALUE) {

        printf ("Error opening %s.\n", deviceinterfacedetaildata->DevicePath);
        goto Exitmain;
    }

    success = DeviceIoControl (
                               device,
                               IOCTL_ACPISIM_METHOD,
                               &methodname,
                               sizeof (methodname),
                               NULL,
                               0,
                               &size,
                               NULL
                               );

    if (!success) {

        printf ("Error issuing IOCTL (%x).\n", GetLastError ());
        goto Exitmain;
    }

Exitmain:

    if (deviceinterfacedetaildata) {

        free (deviceinterfacedetaildata);
    }

    if (device != INVALID_HANDLE_VALUE) {

        CloseHandle (device);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\app\asldtb\asldtb.c ===
/*++

Copyright (c) 2001  Microsoft Corporation 

Module Name:

	 asldtb.c

Abstract:

    This application is used with the ACPI BIOS Simulator.

Author(s):

    Vincent Geglia (vincentg) 16-Apr-2001
     
Environment:

	 Console App; User mode

Notes:


Revision History:

    

--*/


//
// General includes
//

#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "malloc.h"
#include "setupapi.h"
#include "devioctl.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimictl.h"

//
// Function code
//

void
__cdecl
main(
	 int    argc,
     char   *argv[]
	 )
{
    HDEVINFO                            deviceinfo = INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA            deviceinterfacedata;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    deviceinterfacedetaildata = 0;
    BOOL                                success = FALSE;
    CONST GUID                          guid = ACPISIM_GUID;
    DWORD                               size = 0, count = 0;
    HANDLE                              device = INVALID_HANDLE_VALUE;
    PACPISIM_LOAD_TABLE                 loadtable = 0;
    ULONG                               tablenumber = 0;
    
    
    if (argc < 2) {

        printf ("Usage:  %s <path to ACPI AML table to load> <location to load (1-20)>\n\n", argv[0]);
        goto Exitmain;
    }

    tablenumber = atoi (argv[2]);

    if (!tablenumber) {

        printf("Error parsing table number.\n");
        goto Exitmain;
    }

    tablenumber --;
    
    deviceinterfacedata.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    deviceinfo = SetupDiGetClassDevs (&guid,
                                      NULL,
                                      NULL,
                                      DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (deviceinfo == INVALID_HANDLE_VALUE) {

        printf ("Error enumerating ACPISIM device instances.\n");
        goto Exitmain;
    }

    success = SetupDiEnumDeviceInterfaces (deviceinfo,
                                           NULL,
                                           &guid,
                                           0,
                                           &deviceinterfacedata);

    if (!success) {

        printf ("Error enumerating ACPISIM device interface instances.\n");
        goto Exitmain;
    }

    //
    // Find out how big our buffer needs to be
    //

    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               NULL,
                                               0,
                                               &size,
                                               NULL);

    if (!size) {

        printf ("Error getting device interface size.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata = (PSP_DEVICE_INTERFACE_DETAIL_DATA) malloc (size);

    if (!deviceinterfacedetaildata) {

        printf ("Unable to allocate memory.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
    
    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               deviceinterfacedetaildata,
                                               size,
                                               NULL,
                                               NULL);

    if (!success) {

        printf ("Error getting device interface detail.\n");
        goto Exitmain;
    }
    
    device = CreateFile (
                         deviceinterfacedetaildata->DevicePath,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                         );

    if (device == INVALID_HANDLE_VALUE) {

        printf ("Error opening %s.\n", deviceinterfacedetaildata->DevicePath);
        goto Exitmain;
    }

    //
    // Setup input structure
    //

    size = sizeof (ACPISIM_LOAD_TABLE) + strlen (argv[1]) + 1 + 4;      // 1 for the NULL, 4 for the \\.\

    loadtable = malloc (size);

    if (!loadtable) {

        printf ("Error allocating memory.\n");
        goto Exitmain;
    }

    ZeroMemory (loadtable, size);
    loadtable->TableNumber = tablenumber;
    sprintf (loadtable->Filepath, "\\??\\%s", argv[1]);
    
    loadtable->Signature = ACPISIM_LOAD_TABLE_SIGNATURE;
   
    success = DeviceIoControl (
                               device,
                               IOCTL_ACPISIM_LOAD_TABLE,
                               loadtable,
                               size,
                               NULL,
                               0,
                               &size,
                               NULL
                               );

    if (!success) {

        printf ("Error issuing IOCTL (%x).\n", GetLastError ());
        goto Exitmain;
    }

Exitmain:

    if (deviceinterfacedetaildata) {

        free (deviceinterfacedetaildata);
    }

    if (loadtable) {

        free (loadtable);
    }

    if (device != INVALID_HANDLE_VALUE) {

        CloseHandle (device);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\app\asunld\asunld.c ===
/*++

Copyright (c) 2001  Microsoft Corporation 

Module Name:

	 asunld.c

Abstract:

    This application is used with the ACPI BIOS Simulator.

Author(s):

    Vincent Geglia (vincentg) 06-Apr-2001
     
Environment:

	 Console App; User mode

Notes:


Revision History:

    

--*/


//
// General includes
//

#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "malloc.h"
#include "setupapi.h"
#include "devioctl.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimictl.h"

//
// Function definitions
//

UCHAR
ConvertCharacterHexToDecimal
    (
        UCHAR   Character
    );

//
// Function code
//

void
__cdecl
main(
	 int    argc,
     char   *argv[]
	 )
{
    HDEVINFO                            deviceinfo = INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA            deviceinterfacedata;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    deviceinterfacedetaildata = 0;
    BOOL                                success = FALSE;
    CONST GUID                          guid = ACPISIM_GUID;
    DWORD                               size = 0, count = 0;
    HANDLE                              device = INVALID_HANDLE_VALUE;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX     inputbuffer = 0;
    UCHAR                               notifycode = 0;
    PACPI_METHOD_ARGUMENT               argument = 0;
    ULONG_PTR                           ddbhandle = 0;
    ULONG                               tablenumber = 0;
    
    if (argc < 2) {

        printf ("Usage:  %s <Table number (1-20) to unload>\n\n", argv[0]);
        goto Exitmain;
    }
    
    tablenumber = atoi (argv[1]);

    if (!tablenumber) {

        printf("Error parsing table number\n");
        goto Exitmain;
    }
    
    tablenumber --;
    
    deviceinterfacedata.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    deviceinfo = SetupDiGetClassDevs (&guid,
                                      NULL,
                                      NULL,
                                      DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (deviceinfo == INVALID_HANDLE_VALUE) {

        printf ("Error enumerating ACPISIM device instances.\n");
        goto Exitmain;
    }

    success = SetupDiEnumDeviceInterfaces (deviceinfo,
                                           NULL,
                                           &guid,
                                           0,
                                           &deviceinterfacedata);

    if (!success) {

        printf ("Error enumerating ACPISIM device interface instances.\n");
        goto Exitmain;
    }

    //
    // Find out how big our buffer needs to be
    //

    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               NULL,
                                               0,
                                               &size,
                                               NULL);

    if (!size) {

        printf ("Error getting device interface size.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata = (PSP_DEVICE_INTERFACE_DETAIL_DATA) malloc (size);

    if (!deviceinterfacedetaildata) {

        printf ("Unable to allocate memory.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
    
    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               deviceinterfacedetaildata,
                                               size,
                                               NULL,
                                               NULL);

    if (!success) {

        printf ("Error getting device interface detail.\n");
        goto Exitmain;
    }
    
    device = CreateFile (
                         deviceinterfacedetaildata->DevicePath,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                         );

    if (device == INVALID_HANDLE_VALUE) {

        printf ("Error opening %s.\n", deviceinterfacedetaildata->DevicePath);
        goto Exitmain;
    }

    //
    // Setup input structure
    //

    size = sizeof (ACPI_EVAL_INPUT_BUFFER_COMPLEX) + sizeof (ACPI_METHOD_ARGUMENT);

    inputbuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) malloc (size);

    if (!inputbuffer) {

        printf ("Error allocating memory.\n");
        goto Exitmain;
    }

    inputbuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    CopyMemory (inputbuffer->MethodName, "ULTB", 4);
    inputbuffer->Size = size;
    inputbuffer->ArgumentCount = 1;
    
    //
    // Set up notify device (1st argument)
    //
    
    inputbuffer->Argument[0].Type = ACPI_METHOD_ARGUMENT_INTEGER;
    inputbuffer->Argument[0].DataLength = sizeof (ULONG);
    inputbuffer->Argument[0].Argument = tablenumber;
    
    success = DeviceIoControl (
                               device,
                               IOCTL_ACPISIM_METHOD_COMPLEX,
                               inputbuffer,
                               size,
                               NULL,
                               0,
                               &size,
                               NULL
                               );

    if (!success) {

        printf ("Error issuing IOCTL (%x).\n", GetLastError ());
        goto Exitmain;
    }

Exitmain:

    if (deviceinterfacedetaildata) {

        free (deviceinterfacedetaildata);
    }

    if (inputbuffer) {

        free (inputbuffer);
    }

    if (device != INVALID_HANDLE_VALUE) {

        CloseHandle (device);
    }

    return;
}

UCHAR
ConvertCharacterHexToDecimal
    (
        UCHAR   Character
    )
{
    CharUpperBuff (&Character, 1);
    
    if (Character >= '0' && Character <= '9') {

        return Character - '0';

    }

    if (Character >= 'A' && Character <= 'F') {
    
        return (Character - 'A') + 10;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\driver\ioctl.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 ioctl.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IO Device Control Handler module
     Create/Close File Handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_IOCTL_H_)
#define _IOCTL_H_

#include "asimictl.h"


//
// IOCTL dispatch routine handler function prototype
//

typedef
NTSTATUS
(*PIOCTL_DISPATCH_ROUTINE) (
                            IN PDEVICE_OBJECT   DeviceObject,
                            IN PIRP             Irp
                          );
//
// Irp dispatch table definition
//

typedef struct _IOCTL_DISPATCH_TABLE {
    ULONG                   IoctlFunction;
    TCHAR                   IoctlName[50];
    PIOCTL_DISPATCH_ROUTINE IoctlHandler;
} IOCTL_DISPATCH_TABLE, *PIOCTL_DISPATCH_TABLE;

//
// Public function prototypes
//

NTSTATUS 
AcpisimDispatchIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

#endif // _IOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\driver\ioctl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 ioctl.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IO Device Control Handler module
     Create/Close File Handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include "ntddk.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimlib.h"
#include "ioctl.h"
#include "opregion.h"
#include "util.h"

//
// Private function prototypes
//

NTSTATUS
AcpisimIoctlMethod
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    );

NTSTATUS
AcpisimIoctlMethodComplex
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    );

NTSTATUS
AcpisimIoctlLoadTable
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    );

//
// Irp dispatch routine handler function prototype
//

typedef
NTSTATUS
(*PIRP_DISPATCH_ROUTINE) (
                            IN PDEVICE_OBJECT   DeviceObject,
                            IN PIRP             Irp
                         );
//
// Irp dispatch table definition
//

typedef struct _IRP_DISPATCH_TABLE {
    ULONG                   IrpFunction;
    TCHAR                   IrpName[50];
    PIRP_DISPATCH_ROUTINE   IrpHandler;
} IRP_DISPATCH_TABLE, *PIRP_DISPATCH_TABLE;


//
// IOCTL table
//

IOCTL_DISPATCH_TABLE    IoctlDispatchTable [] = {
    IOCTL_ACPISIM_METHOD,           "IOCTL_ACPISIM_METHOD",         AcpisimIoctlMethod,
    IOCTL_ACPISIM_METHOD_COMPLEX,   "IOCTL_ACPISIM_METHOD_COMPLEX", AcpisimIoctlMethodComplex,
    IOCTL_ACPISIM_LOAD_TABLE,       "IOCTL_ACPISIM_LOAD_TABLE",     AcpisimIoctlLoadTable
};


NTSTATUS AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for IOCTL requests. This is the "meat" of 
    the driver so to speak.  All of the op-region accesses from user
    mode are handled here.  The implementer should perform the action
    and return an appropriate status, or return STATUS_UNSUPPORTED if
    the IOCTL is unrecognized.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;
    
    DBG_PRINT (DBG_INFO, "Entering AcpisimHandleIoctl\n");

    while (count < sizeof (IoctlDispatchTable) / sizeof (IOCTL_DISPATCH_TABLE)) {
        
        if (irpsp->Parameters.DeviceIoControl.IoControlCode == IoctlDispatchTable[count].IoctlFunction) {
            
            DBG_PRINT (DBG_INFO, "Recognized %s\n", IoctlDispatchTable[count].IoctlName);
            status = IoctlDispatchTable[count].IoctlHandler (DeviceObject, Irp);
            
            //
            // We handled it, complete it.
            //
            
            goto ExitAcpisimDispatchIoctl;
        }
        count ++;
    } 

    //
    // If we get here, its because we don't recognize this IOCTL, simply pass it down.
    //
    
    status = STATUS_NOT_SUPPORTED;

ExitAcpisimDispatchIoctl:

    DBG_PRINT (DBG_INFO, "Exiting AcpisimHandleIoctl\n");
    return status;
}

NTSTATUS
AcpisimIoctlMethod
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    )

/*++

Routine Description:

    This routine simply evaluates a method through IOCTL_ACPISIM_METHOD
    calls.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    UCHAR               methodname[4];
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);

    DBG_PRINT (DBG_INFO, "Entering AcpisimIoctlMethod.\n");
    
    RtlZeroMemory (&methodname, sizeof (methodname));

    //
    // Get the method we want to run
    //

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength != 4 || (!Irp->AssociatedIrp.SystemBuffer && !irpsp->Parameters.DeviceIoControl.Type3InputBuffer)) {

        DBG_PRINT (DBG_ERROR, "IOCTL not called correctly.  Ignoring.\n");
        goto ExitAcpisimIoctlMethod;
    }
    //
    // We need to figure out where the data is coming from
    //

    if (Irp->AssociatedIrp.SystemBuffer) {

        RtlCopyMemory (&methodname, Irp->AssociatedIrp.SystemBuffer, 4);

    } else {
        
        RtlCopyMemory (&methodname, irpsp->Parameters.DeviceIoControl.Type3InputBuffer, 4);

    }
    

    status = AcpisimEvalAcpiMethod (DeviceObject, methodname, 0);

ExitAcpisimIoctlMethod:

    DBG_PRINT (DBG_INFO, "Exiting AcpisimIoctlMethod.\n");

    return status;
}

NTSTATUS
AcpisimIoctlMethodComplex
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    )

/*++

Routine Description:

    This routine simply evaluates a method through IOCTL_ACPISIM_METHOD
    calls, but also takes arguments to pass to the ACPI method.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputbuffer = 0;
    PIO_STACK_LOCATION              irpsp = IoGetCurrentIrpStackLocation (Irp);

    DBG_PRINT (DBG_INFO, "Entering AcpisimIoctlMethodComplex.\n");
    
    //
    // Get the method we want to run
    //

    if (!irpsp->Parameters.DeviceIoControl.InputBufferLength || (!Irp->AssociatedIrp.SystemBuffer && !irpsp->Parameters.DeviceIoControl.Type3InputBuffer)) {

        DBG_PRINT (DBG_ERROR, "IOCTL not called correctly.  Ignoring.\n");
        goto ExitAcpisimIoctlMethodComplex;
    }

    inputbuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) ExAllocatePoolWithTag (
                                                                           NonPagedPool,
                                                                           irpsp->Parameters.DeviceIoControl.InputBufferLength,
                                                                           ACPISIM_TAG
                                                                           ); 

    if (!inputbuffer) {

        DBG_PRINT (DBG_ERROR, "Error allocating memory.\n");
        goto ExitAcpisimIoctlMethodComplex;
    }

    //
    // We need to figure out where the data is coming from
    //

    if (Irp->AssociatedIrp.SystemBuffer) {

        RtlCopyMemory (inputbuffer, Irp->AssociatedIrp.SystemBuffer, irpsp->Parameters.DeviceIoControl.InputBufferLength);

    } else {
        
        RtlCopyMemory (inputbuffer, irpsp->Parameters.DeviceIoControl.Type3InputBuffer, irpsp->Parameters.DeviceIoControl.InputBufferLength);

    }
    

    status = AcpisimEvalAcpiMethodComplex (DeviceObject, inputbuffer, 0);

ExitAcpisimIoctlMethodComplex:

    if (inputbuffer) {

        ExFreePool (inputbuffer);
    }

    DBG_PRINT (DBG_INFO, "Exiting AcpisimIoctlMethodComplex.\n");
    return status;
}

NTSTATUS
AcpisimIoctlLoadTable
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    )
{
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION              irpsp = IoGetCurrentIrpStackLocation (Irp);
    PACPISIM_LOAD_TABLE             loadtable = 0;
    HANDLE                          filehandle = 0;
    OBJECT_ATTRIBUTES               fileobject;
    UNICODE_STRING                  filename;
    ANSI_STRING                     filenameansi;
    IO_STATUS_BLOCK                 iostatus;
    FILE_STANDARD_INFORMATION       fileinformation;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputbuffer = 0;
    PHYSICAL_ADDRESS                physicaladdress;
    ULONG                           size = 0;
    PACPI_METHOD_ARGUMENT           argument = 0;
    PVOID                           LoadTablePtr = 0;
    ULONG                           LoadTableSize = 0;

    DBG_PRINT (DBG_INFO, "Entering AcpisimIoctlLoadTable.\n");

    //
    // Make sure the IOCTL is formed correctly
    //

    if (irpsp->Parameters.DeviceIoControl.InputBufferLength < 4 ||
       (!Irp->AssociatedIrp.SystemBuffer && !irpsp->Parameters.DeviceIoControl.Type3InputBuffer)) {

        DBG_PRINT (DBG_ERROR, "IOCTL not called correctly.  Ignoring.\n");
        goto ExitAcpisimIoctlLoadTable;
    }
    
    loadtable = (PACPISIM_LOAD_TABLE) ExAllocatePoolWithTag (
                                                             NonPagedPool,
                                                             irpsp->Parameters.DeviceIoControl.InputBufferLength,
                                                             ACPISIM_TAG
                                                             ); 

    if (!loadtable) {

        DBG_PRINT (DBG_ERROR, "Error allocating memory.\n");
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // We need to figure out where the data is coming from
    //

    if (Irp->AssociatedIrp.SystemBuffer) {

        RtlCopyMemory (loadtable, Irp->AssociatedIrp.SystemBuffer, irpsp->Parameters.DeviceIoControl.InputBufferLength);

    } else {
        
        RtlCopyMemory (loadtable, irpsp->Parameters.DeviceIoControl.Type3InputBuffer, irpsp->Parameters.DeviceIoControl.InputBufferLength);

    }            

    if (loadtable->Signature != ACPISIM_LOAD_TABLE_SIGNATURE) {

        DBG_PRINT (DBG_ERROR, "IOCTL_ACPISIM_LOAD_TABLE passed in, but signature doesn't match.  Ignoring...\n");
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // Set up the file name path
    //       

    RtlInitAnsiString (
                       &filenameansi,
                       loadtable->Filepath
                       );
    
    if (!NT_SUCCESS (RtlAnsiStringToUnicodeString (
                                                   &filename,
                                                   &filenameansi,
                                                   TRUE
                                                   )))
    {
        DBG_PRINT (DBG_ERROR, "Unable to allocate string.\n");
        goto ExitAcpisimIoctlLoadTable;

    }

    InitializeObjectAttributes (
                                &fileobject,
                                &filename,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    //
    // Open the file
    //
    
    status = ZwOpenFile (
                         &filehandle,
                         FILE_ALL_ACCESS,
                         &fileobject,
                         &iostatus,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT
                         );

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR, "Unable to open %s (%lx).\n", loadtable->Filepath, status);
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // Get the file size
    //

    status = ZwQueryInformationFile (
                                     filehandle,
                                     &iostatus,
                                     &fileinformation,
                                     sizeof (FILE_STANDARD_INFORMATION),
                                     FileStandardInformation
                                     );

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR, "Unable to query %s (%lx).\n", loadtable->Filepath, status);
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // We don't handle the case where the table is actually larger then
    // 4GB.
    //
    
    if (fileinformation.EndOfFile.HighPart) {

        DBG_PRINT (DBG_ERROR, "Table size exceeds 4GB!.  Ignoring.\n");
        goto ExitAcpisimIoctlLoadTable;
    }
    
    LoadTablePtr = ExAllocatePoolWithTag (
                                          NonPagedPool,
                                          fileinformation.EndOfFile.LowPart,
                                          ACPISIM_TAG
                                          );

    if (!LoadTablePtr) {

        DBG_PRINT (DBG_ERROR, "Unable to allocate memory for ACPI table.\n");
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // Read in the file
    //

    status = ZwReadFile (
                         filehandle,
                         NULL,
                         NULL,
                         NULL,
                         &iostatus,
                         LoadTablePtr,
                         fileinformation.EndOfFile.LowPart,
                         0,
                         NULL
                         );

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR, "Unable to read %s (%lx).\n", loadtable->Filepath, status);
        goto ExitAcpisimIoctlLoadTable;
    }

    LoadTableSize = fileinformation.EndOfFile.LowPart;

    //
    // Get the address of the table we just loaded into memory
    //

    physicaladdress = MmGetPhysicalAddress (LoadTablePtr);

    //
    // Make sure the table is in 32bit address space (ACPI 1.0 doesn't
    // support 64bit addresses)
    //

    if (physicaladdress.HighPart) {

        DBG_PRINT (DBG_ERROR, "SSDT is outside 32bit address range.  Ignoring.\n");
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // Let's get our input buffer set up
    //

    size = sizeof (ACPI_EVAL_INPUT_BUFFER_COMPLEX) + (sizeof (ACPI_METHOD_ARGUMENT) * 2);

    inputbuffer = ExAllocatePoolWithTag (
                                         NonPagedPool,
                                         size,
                                         ACPISIM_TAG
                                         );

    if (!inputbuffer) {

        DBG_PRINT (DBG_ERROR, "Unable to allocate memory for input buffer.\n");
        goto ExitAcpisimIoctlLoadTable;
    }

    //
    // We need to pass the physical address of our table into the LDTB 
    // method.
    //
    
    inputbuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    RtlCopyMemory (inputbuffer->MethodName, "LDTB", 4);
    inputbuffer->Size = size;
    inputbuffer->ArgumentCount = 3;

    argument = inputbuffer->Argument;

    argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
    argument->DataLength = sizeof (ULONG);
    argument->Argument = physicaladdress.LowPart;
    
    //
    // We also need to pass the size of the table into the LDTB method
    //
    
    argument = ACPI_METHOD_NEXT_ARGUMENT (argument);

    argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
    argument->DataLength = sizeof (ULONG);
    argument->Argument = LoadTableSize;

    //
    // Next, we tell it which "slot" to use
    //
    
    argument = ACPI_METHOD_NEXT_ARGUMENT (argument);

    argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
    argument->DataLength = sizeof (ULONG);
    argument->Argument = loadtable->TableNumber;

    //
    // Ok, now let's evaluate the method to load the table
    //

    status = AcpisimEvalAcpiMethodComplex (DeviceObject, inputbuffer, 0);

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR, "Unable to evaluate LDTB method (%lx).\n", status);
        goto ExitAcpisimIoctlLoadTable;
    }
    
ExitAcpisimIoctlLoadTable:

    //
    // Cleanup
    //

    if (inputbuffer) {

        ExFreePool (inputbuffer);
    }

    if (LoadTablePtr) {

        ExFreePool (LoadTablePtr);
        LoadTableSize = 0;
    }
    
    if (filename.Buffer) {
        
        RtlFreeUnicodeString (&filename);
    }
    
    if (filehandle) {

        ZwClose (filehandle);
    }

    if (loadtable) {

        ExFreePool (loadtable);
    }
    
    DBG_PRINT (DBG_INFO, "Exiting AcpisimIoctlLoadTable.\n");
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\driver\opregion.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 opregion.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Operation Region handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_OPREGION_H_)
#define _OPREGION_H_

//
// Defines
//

#define OPREGION_SIZE               1024  // use a hardcoded value of 1024 for our operation region size
#define ACPISIM_POOL_TAG            (ULONG) 'misA'

//
// Specify the operation region type here
//

#define ACPISIM_OPREGION_TYPE      0x81

//
// Public function prototypes
//

NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

#endif // _OPREGION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\driver\opregion.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 opregion.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Operation Region handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:

    
Revision History:
	 

--*/

//
// General includes
//

/*

//
// Need to remove as oprghdlr includes wdm.h
//

#include "ntddk.h"
*/

//
// Specific includes
//

#include "oprghdlr.h"
#include "asimlib.h"
#include "opregion.h"

//
// Globals
//

PVOID   g_OpRegionSharedMemory = 0;
PVOID   g_OperationRegionObject = 0;

//
// Private function prototypes
//

NTSTATUS
EXPORT
AcpisimOpRegionHandler (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    );

NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to register our operation region
    handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    g_OpRegionSharedMemory = ExAllocatePoolWithTag (NonPagedPool,
                                                    OPREGION_SIZE,
                                                    ACPISIM_POOL_TAG);

    status = RegisterOpRegionHandler (AcpisimLibGetNextDevice (DeviceObject),
                                      ACPI_OPREGION_ACCESS_AS_COOKED,
                                      ACPISIM_OPREGION_TYPE,
                                      (PACPI_OP_REGION_HANDLER) AcpisimOpRegionHandler,
                                      (PVOID) ACPISIM_TAG,
                                      0,
                                      &g_OperationRegionObject);

    return status;
}

NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to unregister our operation region
    handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    status = DeRegisterOpRegionHandler (AcpisimLibGetNextDevice (DeviceObject),
                                        g_OperationRegionObject);

    ExFreePool (g_OpRegionSharedMemory);

    return status;
}

NTSTATUS
EXPORT
AcpisimOpRegionHandler (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    )

/*++

Routine Description:

    This routine is called when ASL touches the op region.
    
Arguments:

    AccessType - Indicates whether it is a read or write.
    OperationRegionObject - A pointer to our op region
    Address - Offset into the op region for which the access occurred
    Size - Number of bytes of the access
    Data - Data being written, or location to store data being read
    Context - A user definable context (in this case, device extension)
    CompletionHandler - internal, not used
    CompletionContext - internal, not used

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    ASSERT (AccessType == ACPI_OPREGION_WRITE || AccessType == ACPI_OPREGION_READ);

    //
    // Insert additional handler code here
    //

    switch (AccessType) {
    
    case ACPI_OPREGION_WRITE:

        RtlCopyMemory ((PVOID) ((ULONG_PTR) g_OpRegionSharedMemory + Address), Data, Size);
        status = STATUS_SUCCESS;
        break;
    
    case ACPI_OPREGION_READ:

        RtlCopyMemory (Data, (PVOID) ((ULONG_PTR) g_OpRegionSharedMemory + Address), Size);
        status = STATUS_SUCCESS;
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Unknown Opregion access type.  Ignoring.\n");

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\app\asntfy\asntfy.c ===
/*++

Copyright (c) 2001  Microsoft Corporation 

Module Name:

	 asntfy.c

Abstract:

    This application is used with the ACPI BIOS Simulator.

Author(s):

    Vincent Geglia (vincentg) 06-Apr-2001
     
Environment:

	 Console App; User mode

Notes:


Revision History:

    

--*/


//
// General includes
//

#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "malloc.h"
#include "setupapi.h"
#include "devioctl.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimictl.h"

//
// Function definitions
//

UCHAR
ConvertCharacterHexToDecimal
    (
        UCHAR   Character
    );

//
// Function code
//

void
__cdecl
main(
	 int    argc,
     char   *argv[]
	 )
{
    HDEVINFO                            deviceinfo = INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA            deviceinterfacedata;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    deviceinterfacedetaildata = 0;
    BOOL                                success = FALSE;
    CONST GUID                          guid = ACPISIM_GUID;
    DWORD                               size = 0, count = 0;
    HANDLE                              device = INVALID_HANDLE_VALUE;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX     inputbuffer;
    UCHAR                               notifycode = 0;
    PACPI_METHOD_ARGUMENT               argument = 0;
    
    if (argc < 2) {

        printf ("Usage:  %s <ACPI device to notify> <Notify code in hex>\n\n", argv[0]);
        goto Exitmain;
    }

    if (strlen (argv[2]) > 2) {

        printf ("Notify code must be between 00 and FF.\n");
        goto Exitmain;
    }

    if (strlen (argv[2]) == 2) {

        notifycode = (ConvertCharacterHexToDecimal (argv[2][0]) * 16) + ConvertCharacterHexToDecimal (argv[2][1]);

    } else {

        notifycode = ConvertCharacterHexToDecimal (argv[2][0]);
    }
    
    deviceinterfacedata.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    deviceinfo = SetupDiGetClassDevs (&guid,
                                      NULL,
                                      NULL,
                                      DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (deviceinfo == INVALID_HANDLE_VALUE) {

        printf ("Error enumerating ACPISIM device instances.\n");
        goto Exitmain;
    }

    success = SetupDiEnumDeviceInterfaces (deviceinfo,
                                           NULL,
                                           &guid,
                                           0,
                                           &deviceinterfacedata);

    if (!success) {

        printf ("Error enumerating ACPISIM device interface instances.\n");
        goto Exitmain;
    }

    //
    // Find out how big our buffer needs to be
    //

    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               NULL,
                                               0,
                                               &size,
                                               NULL);

    if (!size) {

        printf ("Error getting device interface size.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata = (PSP_DEVICE_INTERFACE_DETAIL_DATA) malloc (size);

    if (!deviceinterfacedetaildata) {

        printf ("Unable to allocate memory.\n");
        goto Exitmain;
    }

    deviceinterfacedetaildata->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
    
    success = SetupDiGetDeviceInterfaceDetail (deviceinfo,
                                               &deviceinterfacedata,
                                               deviceinterfacedetaildata,
                                               size,
                                               NULL,
                                               NULL);

    if (!success) {

        printf ("Error getting device interface detail.\n");
        goto Exitmain;
    }
    
    device = CreateFile (
                         deviceinterfacedetaildata->DevicePath,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                         );

    if (device == INVALID_HANDLE_VALUE) {

        printf ("Error opening %s.\n", deviceinterfacedetaildata->DevicePath);
        goto Exitmain;
    }

    //
    // Setup input structure
    //

    size = sizeof (ACPI_EVAL_INPUT_BUFFER_COMPLEX) + (sizeof (ACPI_METHOD_ARGUMENT) * 2) + strlen (argv[1]) + 1;

    inputbuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) malloc (size);

    if (!inputbuffer) {

        printf ("Error allocating memory.\n");
        goto Exitmain;
    }

    inputbuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    CopyMemory (inputbuffer->MethodName, "NTFY", 4);
    inputbuffer->Size = size;
    inputbuffer->ArgumentCount = 2;
    
    //
    // Set up notify device (1st argument)
    //
    
    inputbuffer->Argument[0].Type = ACPI_METHOD_ARGUMENT_BUFFER;
    inputbuffer->Argument[0].DataLength = (USHORT) strlen (argv[1]);
    CopyMemory (inputbuffer->Argument[0].Data, argv[1], strlen (argv[1]));

    //
    // Set up the notify code
    //

    argument = ACPI_METHOD_NEXT_ARGUMENT (&inputbuffer->Argument[0]);
    
    argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
    argument->DataLength = sizeof (ULONG);
    argument->Argument = (ULONG) notifycode;

    success = DeviceIoControl (
                               device,
                               IOCTL_ACPISIM_METHOD_COMPLEX,
                               inputbuffer,
                               size,
                               NULL,
                               0,
                               &size,
                               NULL
                               );

    if (!success) {

        printf ("Error issuing IOCTL (%x).\n", GetLastError ());
        goto Exitmain;
    }

Exitmain:

    if (deviceinterfacedetaildata) {

        free (deviceinterfacedetaildata);
    }

    if (inputbuffer) {

        free (inputbuffer);
    }

    if (device != INVALID_HANDLE_VALUE) {

        CloseHandle (device);
    }

    return;
}

UCHAR
ConvertCharacterHexToDecimal
    (
        UCHAR   Character
    )
{
    CharUpperBuff (&Character, 1);
    
    if (Character >= '0' && Character <= '9') {

        return Character - '0';

    }

    if (Character >= 'A' && Character <= 'F') {
    
        return (Character - 'A') + 10;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\driver\util.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 util.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Utility module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_UTIL_H_)
#define _UTIL_H_


//
// Public function prototypes
//                

NTSTATUS
AcpisimEvalAcpiMethod 
    (
        IN          PDEVICE_OBJECT  DeviceObject,
        IN          PUCHAR          MethodName,
        OPTIONAL    PVOID           *Result
    );

NTSTATUS
AcpisimEvalAcpiMethodComplex
    (
        IN          PDEVICE_OBJECT  DeviceObject,
        IN          PVOID           InputBuffer,
        OPTIONAL    PVOID           *Result
    );


#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\driver\util.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 util.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Utility module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include "ntddk.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimlib.h"
#include "util.h"


//
// Private function prototypes
//

NTSTATUS
AcpisimEvalAcpiMethod 
    (
        IN          PDEVICE_OBJECT  DeviceObject,
        IN          PUCHAR          MethodName,
        OPTIONAL    PVOID           *Result
    )

/*++

Routine Description:

    This routine evaluates an ACPI method, and returns the result
    if the caller passes in a pointer to a PVOID.

Arguments:

    DeviceObject - pointer to the device object
    MethodName - a 4 character method name of the method to evaluate
    Result - a pointer to a PVOID will contain a result (NOTE:  Caller
             MUST call ExFreePool on the pointer when finished)

Return Value:

    Status code of operation

--*/

{
    ACPI_EVAL_INPUT_BUFFER  inputbuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputbuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         iostatus;
    NTSTATUS                status;
    PIRP                    irp;
    
    DBG_PRINT (DBG_INFO, "Entering AcpisimEvalAcpiMethod\n");

    //
    // Initialize the event
    //
    
    KeInitializeEvent (&event, SynchronizationEvent, FALSE );

    //
    // Initialize the input buffer
    //
    
    DBG_PRINT (DBG_INFO,
               "Evaluating method '%c%c%c%c'\n",
               MethodName[0],
               MethodName[1],
               MethodName[2],
               MethodName[3]);

    
    RtlZeroMemory (&inputbuffer, sizeof (ACPI_EVAL_INPUT_BUFFER));
    inputbuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    RtlCopyMemory (&inputbuffer.MethodName, MethodName, 4);

    //
    // Initialize the output buffer
    //
    
    RtlZeroMemory (&outputbuffer, sizeof (ACPI_EVAL_OUTPUT_BUFFER));

    //
    // Initialize an IRP
    //

    irp = IoBuildDeviceIoControlRequest (IOCTL_ACPI_EVAL_METHOD,
                                         AcpisimLibGetNextDevice (DeviceObject),
                                         &inputbuffer,
                                         sizeof(ACPI_EVAL_INPUT_BUFFER),
                                         &outputbuffer,
                                         sizeof(ACPI_EVAL_OUTPUT_BUFFER),
                                         FALSE,
                                         &event,
                                         &iostatus);

    //
    // Irp initialization failed?
    //

    if (!irp) {

        DBG_PRINT (DBG_ERROR, "AcpisimEvalAcpiMethod:  Failed to create IRP\n");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitAcpisimEvalAcpiMethod;
    }

    //
    // Send to ACPI driver
    //

    status = IoCallDriver (AcpisimLibGetNextDevice (DeviceObject), irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //

        KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

        //
        // Get the real status
        //

        status = iostatus.Status;
    }

    //
    // Did we fail the request?
    //

    if (!NT_SUCCESS(status)) {

        DBG_PRINT (DBG_ERROR, "AcpisimEvalAcpiMethod:  Lower driver failed IRP (%lx)\n", status);

        goto ExitAcpisimEvalAcpiMethod;
    }

    //
    // Make sure the result is correct
    //

    ASSERT (iostatus.Information >= sizeof(ACPI_EVAL_OUTPUT_BUFFER));
    
    if (iostatus.Information < sizeof(ACPI_EVAL_OUTPUT_BUFFER) ||
        outputbuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputbuffer.Count == 0) {

        status = STATUS_UNSUCCESSFUL;
        goto ExitAcpisimEvalAcpiMethod;

    }
    
    if (Result) {

        *Result = ExAllocatePoolWithTag (
                                         NonPagedPool,
                                         iostatus.Information,
                                         ACPISIM_TAG
                                         );

        if (!*Result) {

            DBG_PRINT (DBG_ERROR, "Unable to allocate memory for result.\n");
            goto ExitAcpisimEvalAcpiMethod;
        }

        RtlCopyMemory (*Result, &outputbuffer, iostatus.Information);
    }

    status = STATUS_SUCCESS;

ExitAcpisimEvalAcpiMethod:    

    DBG_PRINT (DBG_INFO, "Exiting AcpisimEvalAcpiMethod\n");

    return status;
}

NTSTATUS
AcpisimEvalAcpiMethodComplex
    (
        IN          PDEVICE_OBJECT  DeviceObject,
        IN          PVOID           InputBuffer,
        OPTIONAL    PVOID           *Result
    )

/*++

Routine Description:

    This routine evaluates an ACPI method, but allows the
    passing in of parameters.

Arguments:

    DeviceObject - pointer to the device object
    MethodName - a 4 character method name of the method to evaluate
    Result - a pointer to a PVOID will contain a result (NOTE:  Caller
             MUST call ExFreePool on the pointer when finished)

Return Value:

    Status code of operation

--*/

{
    ACPI_EVAL_OUTPUT_BUFFER         outputbuffer;
    KEVENT                          event;
    IO_STATUS_BLOCK                 iostatus;
    NTSTATUS                        status;
    PIRP                            irp;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputbuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) InputBuffer;

    DBG_PRINT (DBG_INFO, "Entering AcpisimEvalAcpiMethodComplex\n");

    //
    // Initialize the event
    //
    
    KeInitializeEvent (&event, SynchronizationEvent, FALSE );

    
    //
    // Initialize the output buffer
    //
    
    RtlZeroMemory (&outputbuffer, sizeof (ACPI_EVAL_OUTPUT_BUFFER));

    //
    // Initialize an IRP
    //

    irp = IoBuildDeviceIoControlRequest (IOCTL_ACPI_EVAL_METHOD,
                                         AcpisimLibGetNextDevice (DeviceObject),
                                         inputbuffer,
                                         inputbuffer->Size,
                                         &outputbuffer,
                                         sizeof(ACPI_EVAL_OUTPUT_BUFFER),
                                         FALSE,
                                         &event,
                                         &iostatus);

    //
    // Irp initialization failed?
    //

    if (!irp) {

        DBG_PRINT (DBG_ERROR, "AcpisimEvalAcpiMethodComplex:  Failed to create IRP\n");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitAcpisimEvalAcpiMethodComplex;
    }

    //
    // Send to ACPI driver
    //

    status = IoCallDriver (AcpisimLibGetNextDevice (DeviceObject), irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //

        KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

        //
        // Get the real status
        //

        status = iostatus.Status;
    }

    //
    // Did we fail the request?
    //

    if (!NT_SUCCESS(status)) {

        DBG_PRINT (DBG_ERROR, "AcpisimEvalAcpiMethodComplex:  Lower driver failed IRP (%lx)\n", status);

        goto ExitAcpisimEvalAcpiMethodComplex;
    }

    //
    // Make sure the result is correct
    //

    ASSERT (iostatus.Information >= sizeof(ACPI_EVAL_OUTPUT_BUFFER));
    
    if (iostatus.Information < sizeof(ACPI_EVAL_OUTPUT_BUFFER) ||
        outputbuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputbuffer.Count == 0) {

        status = STATUS_UNSUCCESSFUL;
        goto ExitAcpisimEvalAcpiMethodComplex;

    }

    if (Result) {

        *Result = ExAllocatePoolWithTag (
                                         NonPagedPool,
                                         iostatus.Information,
                                         ACPISIM_TAG
                                         );

        if (!*Result) {

            DBG_PRINT (DBG_ERROR, "Unable to allocate memory for result.\n");
            goto ExitAcpisimEvalAcpiMethodComplex;
        }

        RtlCopyMemory (*Result, &outputbuffer, iostatus.Information);
    }

    status = STATUS_SUCCESS;

ExitAcpisimEvalAcpiMethodComplex:    

    DBG_PRINT (DBG_INFO, "Exiting AcpisimEvalAcpiMethodComplex\n");

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpiuasm\acpiuasm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiuasm.h

Abstract:

    Test wrapper for the unassembler

Author:

    Stephane Plante
    Based on code by Ken Reneris

Environment:

    User

Revision History:

--*/

#ifndef _ACPIUASM_H_
#define _ACPIUASM_H_

    #include <windows.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdarg.h>

    #define DATA_SIZE   7*1024      // max value to write into registry

    typedef struct _DSDT {
        ULONG       Signature;
        ULONG       Length;
        UCHAR       Revision;
        UCHAR       Checksum;
        UCHAR       OemID[6];
        UCHAR       OemTableID[8];
        UCHAR       OemRevision[4];
        UCHAR       CreatorID[4];
        UCHAR       CreatorRevision[4];
    } DSDT, *PDSDT;


    typedef struct _IFILE {
        BOOLEAN     Opened;
        PUCHAR      Desc;
        PUCHAR      FileName;
        HANDLE      FileHandle;
        HANDLE      MapHandle;
        ULONG       FileSize;
        PUCHAR      Image;
        PUCHAR      EndOfImage;

        PUCHAR      OemID;
        PUCHAR      OemTableID;
        UCHAR       OemRevision[4];
    } IFILE, *PIFILE;

    //
    // External references
    //
    extern
    ULONG
    ScopeParser(
        IN  PUCHAR  String,
        IN  ULONG   Length,
        IN  ULONG   BaseAddress,
        IN  ULONG   IndentLevel
        );

    //
    // Internal prototypes
    //
    VOID
    ParseArgs (
        IN int  argc,
        IN char *argv[]
        );

    VOID
    CheckImageHeader (
        IN PIFILE   File
        );

    VOID
    FAbort (
        PUCHAR  Text,
        PIFILE  File
        );

    VOID
    Abort (
        VOID
        );

    PUCHAR
    FixString (
        IN PUCHAR   Str,
        IN ULONG    Len
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpiwake\makefile.inc ===
obj\$(TARGET_DIRECTORY)\acpiwake.res: acpiwake.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpiwake\acpiwake.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    amlload.c

Abstract:

    This program installs an AML file into the NT registry

Author:

    Ken Reneris

Environment:

    Command-line.

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct _pm_tables {
    DWORD   bit;
    UCHAR   *name;
} pm_tables, *ppm_tables;

pm_tables pm_table_1[] = {
    { 0, "System Timer" },
    { 4, "BusMaster Request" },
    { 5, "Global Lock Request" },
};

pm_tables pm_table_2[] = {
    { 0, "Power Button" },
    { 1, "Sleep Button" },
    { 2, "Real Time Clock" },
};

UCHAR       s[500];                     // Registry path

VOID
Abort(
    )
{
    exit(1);
}

PUCHAR
get_fixed_event_name(
    IN  ppm_tables  CurTable,
    IN  DWORD       Index
    )
{
    DWORD   i;

    for (i = 0; i < 8; i++) {

        if (CurTable[i].bit == Index) {

            return CurTable[i].name;

        }
    }
    return NULL;
}

VOID
display_fixed_event_info(
    IN  UCHAR   *fixedmaskdata,
    IN  UCHAR   *fixedstatusdata,
    IN  DWORD   data_length)
{
    DWORD       i;
    DWORD       j;
    DWORD       k;
    ppm_tables  curTable;
    PUCHAR      text;

    printf("Fixed Event Information\n");

    for (i = 0; i < data_length && i < 2; i++) {

        if (i == 0) {
            curTable = pm_table_1;
        } else {
            curTable = pm_table_2;
        }

        /*
        printf("  MaskRegister[%d]:%x StatusRegister[%d]:%x\n",
            i, fixedmaskdata[i], i, fixedstatusdata[i]);
        */

        for (j = 1, k = 0; k < 8; k++, j = (j << 1)) {

            text = get_fixed_event_name( curTable, k);
            if (text == NULL) {

                continue;

            }

            if ( (fixedmaskdata[i] & j) && (fixedstatusdata[i] & j) ) {

                printf("  The %s is enabled and has awoken the system.\n", text);


            } else if (fixedmaskdata[i] & j) {

                printf("  The %s is enabled to wake the system.\n", text );

            } else if (fixedstatusdata[i] & j) {

                printf("  The %s was set but not enabled to wake the system.\n", text );

            }
        }
    }
    printf("\n");
}

VOID
display_generic_event_info(
    IN  UCHAR   *genericmaskdata,
    IN  UCHAR   *genericstatusdata,
    IN  DWORD   data_length
    )
{
    DWORD   i;
    DWORD   j;
    DWORD   k;

    printf("Generic Event Information\n");

    for (i = 0; i < data_length; i++) {

        /*
        printf("  MaskRegister[%d]:%x StatusRegister[%d]:%x\n",
            i, genericmaskdata[i], i, genericstatusdata[i]);
        */

        for (j = 1, k = 0; k < 8; k++, j = (j << 1) ) {

            if ( (genericmaskdata[i] & j) && (genericstatusdata[i] && j) ) {

                printf("  Event %02x is enabled and has awoken the system.\n",
                    ( (i * 8) + k ) );

            } else if (genericmaskdata[i] & j) {

                printf("  Event %02x is enabled to wake the system.\n",
                    ( (i * 8) + k ) );

            } else if (genericstatusdata[i] & j) {

                printf("  Event %02x was set but not enabled to wake the system.\n",
                    ( (i * 8) + k ) );

            }
        }
    }
    printf("\n");
}
int
__cdecl
main(
    IN int  argc,
    IN char *argv[]
    )
{
    DWORD   data_type;
    DWORD   data_length;
    HKEY    regKey;
    LONG    status;
    UCHAR   fixedmaskdata[32];
    UCHAR   fixedstatusdata[32];
    UCHAR   genericmaskdata[32];
    UCHAR   genericstatusdata[32];

    sprintf(s, "System\\CurrentControlSet\\Services\\ACPI\\Parameters\\WakeUp");

    status = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        s,
        0L,
        KEY_ALL_ACCESS,
        &regKey
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not access the registry path: %s\n", s);
        Abort();
    }

    //
    // Read the fixed event mask
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "FixedEventMask", 0,
        &data_type,
        fixedmaskdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read FixedEventMask from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("FixedEventMask does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();

    }

    //
    // Read the fixed event Status
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "FixedEventStatus", 0,
        &data_type,
        fixedstatusdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read FixedEventStatus from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("FixedEventStatus does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();

    }
    display_fixed_event_info( fixedmaskdata, fixedstatusdata, data_length );

    //
    // Read the generic event mask
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "GenericEventMask", 0,
        &data_type,
        genericmaskdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read GenericEventMask from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("GenericEventMask does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();
    }

    //
    // Read the generic event status
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "GenericEventStatus", 0,
        &data_type,
        genericstatusdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read GenericEventStatus from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("GenericEventStatus does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();
    }
    display_generic_event_info( genericmaskdata, genericstatusdata, data_length );

    RegCloseKey( regKey );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpisim\simulation\inc\asimictl.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	 asimictl.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IOCTL Definitions

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// ACPI Simulator GUID
//

#define ACPISIM_GUID                    {0x27FC71F0, 0x8B2D, 0x4D05, { 0xBD, 0xD0, 0xE8, 0xEA, 0xCA, 0xA0, 0x78, 0xA0}}

//
// IOCTL Definitions
//

#define IOCTL_ACPISIM_METHOD            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_ACPISIM_METHOD_COMPLEX    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_ACPISIM_LOAD_TABLE        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0002, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Other definitions
//

#define ACPISIM_LOAD_TABLE_SIGNATURE    'TLSA'

//
// IOCTL structures
//

typedef struct _ACPISIM_LOAD_TABLE {

    ULONG   Signature;                  // Signature must be 'ASLT'
    ULONG   TableNumber;                // Table location to load table
    UCHAR   Filepath [1];               // The filepath

} ACPISIM_LOAD_TABLE, *PACPISIM_LOAD_TABLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\cmdarg.c ===
/*** cmdarg.c - Command argument parsing functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */


#include "pch.h"

#ifdef DEBUGGER

/*** Local function prototypes
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs);
PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs);

/*** Local data
 */

PSZ pszSwitchChars = "-/";
PSZ pszOptionSeps = "=:";

/***EP  DbgParseArgs - parse command arguments
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      pdwNumArgs -> to hold the number of arguments parsed
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *      pszTokenSeps -> token separator characters string
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps)
{
    LONG rc = ARGERR_NONE;
    PSZ psz;

    *pdwNumArgs = 0;
    *pdwNonSWArgs = 0;
    while ((psz = STRTOK(NULL, pszTokenSeps)) != NULL)
    {
        (*pdwNumArgs)++;
        if ((rc = DbgParseOneArg(ArgTable, psz, *pdwNumArgs, pdwNonSWArgs)) !=
            ARGERR_NONE)
        {
            break;
        }
    }

    return rc;
}       //DbgParseArgs

/***LP  DbgParseOneArg - parse one command argument
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      psz -> argument string
 *      dwArgNum - argument number
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs)
{
    LONG rc = ARGERR_NONE;
    PCMDARG pArg;
    PSZ pszEnd;

    if ((pArg = DbgMatchArg(ArgTable, &psz, pdwNonSWArgs)) != NULL)
    {
        switch (pArg->dwArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pArg->dwfArg & AF_SEP)
                {
                    if ((*psz != '\0') &&
                        (STRCHR(pszOptionSeps, *psz) != NULL))
                    {
                        psz++;
                    }
                    else
                    {
                        ARG_ERROR(("argument missing option separator - %s",
                                   psz));
                        rc = ARGERR_SEP_NOT_FOUND;
                        break;
                    }
                }

                if (pArg->dwArgType == AT_STRING)
                {
                    *((PSZ *)pArg->pvArgData) = psz;
                }
                else
                {
                    *((PLONG)pArg->pvArgData) =
                        STRTOL(psz, &pszEnd, pArg->dwArgParam);
                    if (psz == pszEnd)
                    {
                        ARG_ERROR(("invalid numeric argument - %s", psz));
                        rc = ARGERR_INVALID_NUMBER;
                        break;
                    }
                }

                if (pArg->pfnArg != NULL)
                {
                    rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pArg->dwArgType == AT_ENABLE)
                    *((PULONG)pArg->pvArgData) |= pArg->dwArgParam;
                else
                    *((PULONG)pArg->pvArgData) &= ~pArg->dwArgParam;

                if ((pArg->pfnArg != NULL) &&
                    (pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (*psz != '\0')
                {
                    rc = DbgParseOneArg(ArgTable, psz, dwArgNum, pdwNonSWArgs);
                }
                break;

            case AT_ACTION:
                ASSERT(pArg->pfnArg != NULL);
                rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                break;

            default:
                ARG_ERROR(("invalid argument table"));
                rc = ARGERR_ASSERT_FAILED;
        }
    }
    else
    {
        ARG_ERROR(("invalid command argument - %s", psz));
        rc = ARGERR_INVALID_ARG;
    }

    return rc;
}       //DbgParseOneArg

/***LP  DbgMatchArg - match argument type from argument table
 *
 *  ENTRY
 *      ArgTable -> argument table
 *      ppsz -> argument string pointer
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns pointer to argument entry matched
 *  EXIT-FAILURE
 *      returns NULL
 */

PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs)
{
    PCMDARG pArg;

    for (pArg = ArgTable; pArg->dwArgType != AT_END; pArg++)
    {
        if (pArg->pszArgID == NULL)     //NULL means match anything.
        {
            (*pdwNonSWArgs)++;
            break;
        }
        else
        {
            ULONG dwLen;

            if (STRCHR(pszSwitchChars, **ppsz) != NULL)
                (*ppsz)++;

            dwLen = STRLEN(pArg->pszArgID);
            if (StrCmp(pArg->pszArgID, *ppsz, dwLen,
                       (BOOLEAN)((pArg->dwfArg & AF_NOI) != 0)) == 0)
            {
                (*ppsz) += dwLen;
                break;
            }
        }
    }

    if (pArg->dwArgType == AT_END)
        pArg = NULL;

    return pArg;
}       //DbgMatchArg

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\acpiuasm\acpiuasm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiuasm.c

Abstract:

    Test wrapper for the unassembler

Author:

    Stephane Plante
    Based on code by Ken Reneris

Environment:

    User

Revision History:

--*/

#include "acpiuasm.h"

IFILE       Orig;           // Image of original aml file
BOOLEAN     Verbose;
BOOLEAN     ArgsParsed;

int
__cdecl
main(
    IN int  argc,
    IN char *argv[]
    )
{
    //
    // Init globals
    //
    Orig.Desc   = "original image";

    //
    // Parse args
    //
    ParseArgs(argc, argv);

    //
    // Check the image header
    //
    CheckImageHeader(
        &Orig
        );

    //
    // Debug the image
    //
    return ScopeParser(
        (PUCHAR) (Orig.Image + sizeof(DSDT)),
        Orig.FileSize,
        (ULONG) ( 0 - (ULONG) Orig.Image - sizeof(DSDT) ),
        0
        );

}

VOID
CheckImageHeader (
    IN PIFILE   File
    )
{
    PUCHAR      Image;
    PDSDT       Dsdt;
    UCHAR       check;
    ULONG       i;


    if (File->FileSize < sizeof(DSDT)) {
        FAbort ("Invalid image size in", File);
    }

    Dsdt  = (PDSDT) File->Image;
    if (Dsdt->Signature != 'TDSD') {
        FAbort ("Image signature not DSDT in", File);
    }

    if (File->FileSize != Dsdt->Length) {
        FAbort ("File size in DSDT does not match image size in", File);
    }

    check = 0;
    for (Image = File->Image; Image < File->EndOfImage; Image += 1) {
        check += *Image;
    }

    if (check) {
        FAbort ("Image checksum is incorrect in", File);
    }

    // normalize fixed strings
    File->OemID = FixString (Dsdt->OemID, 6);
    File->OemTableID = FixString (Dsdt->OemID, 8);
    memcpy (File->OemRevision, Dsdt->OemRevision, 4);
    for (i=0; i < 4; i++) {
        if (File->OemRevision[i] == 0 || File->OemRevision[i] == ' ') {
            File->OemRevision[i] = '_';
        }
    }

    if (Verbose) {
        printf ("\n");
        printf ("DSDT info for %s (%s)\n",  File->Desc, File->FileName);
        printf ("  size of image: %d\n", File->FileSize);
        printf ("  OEM id.......: %s\n", File->OemID);
        printf ("  OEM Table id.: %s\n", File->OemTableID);
        printf ("  OEM revision.: %4x\n", File->OemRevision);
    }
}

PUCHAR
FixString (
    IN PUCHAR   Str,
    IN ULONG    Len
    )
{
    PUCHAR  p;
    ULONG   i;

    p = malloc(Len+1);
    memcpy (p, Str, Len);
    p[Len] = 0;

    for (i=Len; i; i--) {
        if (p[i] != ' ') {
            break;
        }
        p[i] = 0;
    }
    return p;
}

VOID
FAbort (
    PUCHAR  Text,
    PIFILE  File
    )
{
    printf ("%s %s (%s)\n", Text, File->Desc, File->FileName);
    Abort();
}

VOID
Abort(
    VOID
    )
{
    if (!ArgsParsed) {
        printf ("amlload: UpdateImage [OriginalImage] [-v] [-d]\n");
    }
    exit (1);
}

VOID
ParseArgs (
    IN int  argc,
    IN char *argv[]
    )
{
    PIFILE      File;
    OFSTRUCT    OpenBuf;

    File = &Orig;

    while (--argc) {
        argv += 1;

        //
        // If it's a flag crack it
        //

        if (argv[0][0] == '-') {
            switch (argv[0][1]) {
                case 'v':
                case 'V':
                    Verbose = TRUE;
                    break;

                default:
                    printf ("Unkown flag %s\n", argv[0]);
                    Abort ();
            }

        } else {

            if (!File) {
                printf ("Unexcepted parameter %s\n", argv[0]);
                Abort();
            }

            //
            // Open the file
            //

            File->FileName = argv[0];
            File->FileHandle = OpenFile(argv[0], &OpenBuf, OF_READ);
            if (File->FileHandle == HFILE_ERROR) {
                FAbort ("Can not open", File);
            }

            File->FileSize = GetFileSize(File->FileHandle, NULL);

            //
            // Map it
            //

            File->MapHandle =
                CreateFileMapping(
                    File->FileHandle,
                    NULL,
                    PAGE_READONLY,
                    0,
                    File->FileSize,
                    NULL
                    );

            if (!File->MapHandle) {
                FAbort ("Can not map", File);
            }

            File->Image =
                MapViewOfFile (
                    File->MapHandle,
                    FILE_MAP_READ,
                    0,
                    0,
                    File->FileSize
                    );

            if (!File->Image) {
                FAbort ("Can not map view of image", File);
            }
            File->EndOfImage = File->Image + File->FileSize;
            File->Opened = TRUE;

            //
            // Next file param
            //
            File = NULL;
        }

    }

    //
    // At least a update image is needed
    //

    if (!Orig.Opened) {
        Abort ();
    }

    ArgsParsed = TRUE;
    return ;
}

PVOID
MEMORY_ALLOCATE(
    ULONG   Num
    )
{
    return malloc( Num );
}

VOID
MEMORY_COPY(
    PVOID   Dest,
    PVOID   Src,
    ULONG   Length
    )
{
    memcpy( Dest, Src, Length);
}

VOID
MEMORY_FREE(
    PVOID   Dest
    )
{
    free( Dest );
}

VOID
MEMORY_SET(
    PVOID   Src,
    UCHAR   Value,
    ULONG   Length
    )
{
    memset(Src, Value, Length );
}

VOID
MEMORY_ZERO(
    PVOID   Src,
    ULONG   Length
    )
{
    memset( Src, 0, Length );
}

VOID
PRINTF(
    PUCHAR  String,
    ...
    )
{
    va_list ap;

    va_start( ap, String );
    vprintf( String, ap );
    va_end( ap );
}

ULONG
STRING_LENGTH(
    PUCHAR  String
    )
{
    return strlen( String );
}

VOID
STRING_PRINT(
    PUCHAR  Buffer,
    PUCHAR  String,
    ...
    )
{
    va_list ap;

    va_start( ap, String );
    vsprintf( Buffer, String, ap );
    va_end( ap );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\inc\parsearg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.h

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#ifndef _PARSEARG_H_
#define _PARSEARG_H_

//
// Error Codes
//
#define ARGERR_NONE             0
#define ARGERR_UNKNOWN_SWITCH   1
#define ARGERR_NO_SEPARATOR     2
#define ARGERR_INVALID_NUM      3
#define ARGERR_INVALID_TAIL     4

//
// Parsing options
//
#define DEF_SWITCHCHARS         "/-"
#define DEF_SEPARATORS          ":="

//
// Argument types
//
#define AT_STRING       1
#define AT_NUM          2
#define AT_ENABLE       3
#define AT_DISABLE      4
#define AT_ACTION       5

//
// Parse flags
//
#define PF_NOI          0x0001  //No-Ignore-Case
#define PF_SEPARATOR    0x0002  //parse for separator

//
// Type definitions
//
typedef struct _ARGTYPE ARGTYPE, *PARGTYPE;
typedef int (*PFNARG)(char **, PARGTYPE);
struct _ARGTYPE {
    UCHAR       *ArgID;         // argument ID string
    ULONG       ArgType;        // see argument types defined above
    ULONG       ParseFlags;     // see parse flags defined above
    VOID        *ArgData;       // ARG_STRING: (char **) - ptr to string ptr
                                // ARG_NUM: (int *) - ptr to integer number
                                // ARG_ENABLE: (unsigned *) - ptr to flags
                                // ARG_DISABLE: (unsigned *) - ptr to flags
                                // ARG_ACTION: ptr to function
    ULONG       ArgParam;       // ARG_STRING: none
                                // ARG_NUM: base
                                // ARG_ENABLE: flag bit mask
                                // ARG_DISABLE: flag bit mask
                                // ARG_ACTION: none
    PFNARG      ArgVerify;      // pointer to argument verification function
                                // this will be ignored for ARG_ACTION
};

typedef struct _PROGINFO {
    UCHAR *SwitchChars;         // if null, DEF_SWITCHCHARS is used
    UCHAR *Separators;          // if null, DEF_SEPARATORS is used
    UCHAR *ProgPath;            // ParseProgInfo set this ptr to prog. path
    UCHAR *ProgName;            // ParseProgInfo set this ptr to prog. name
} PROGINFO;
typedef PROGINFO *PPROGINFO;

//
// Export function prototypes
//
extern
VOID
EXPORT
ParseProgramInfo(
    PUCHAR      ProgramName,
    PPROGINFO   ProgramInfo
    );

extern
ULONG
EXPORT
ParseSwitches(
    PULONG      ArgumentCount,
    PUCHAR      **ArgumentList,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\inc\unasmdll.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unasmdll.h

Abstract:

    This contains all the data structures used by the ACPI Unassember. It
    also contains the only legal entry point into the library

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _UNASMDLL_H_
#define _UNASMDLL_H_

    #ifndef LOCAL
        #define LOCAL   __cdecl
    #endif
    #ifndef EXPORT
        #define EXPORT  __cdecl
    #endif

    typedef VOID (*PUNASM_PRINT)(PCCHAR DebugMessage, ... );

    extern
    ULONG
    EXPORT
    IsDSDTLoaded(
        VOID
        );

    extern
    NTSTATUS
    EXPORT
    UnAsmLoadDSDT(
        PUCHAR          DSDT
        );

    extern
    NTSTATUS
    EXPORT
    UnAsmDSDT(
        PUCHAR          DSDT,
        PUNASM_PRINT    PrintFunction,
        ULONG_PTR       BaseAddress,
        ULONG           IndentLevel
        );

    extern
    NTSTATUS
    EXPORT
    UnAsmScope(
        PUCHAR          *OpCode,
        PUCHAR          OpCodeEnd,
        PUNASM_PRINT    PrintFunction,
        ULONG_PTR       BaseAddress,
        ULONG           IndentLevel
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\build.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    kdext.h

Abstract:

    Header files for KD extension

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#ifndef _BUILD_H_
#define _BUILD_H_

    VOID
    dumpAcpiBuildList(
        PUCHAR  ListName
        );

    VOID
    dumpAcpiBuildLists(
        VOID
        );

    VOID
    dumpBuildDeviceListEntry(
        IN  PLIST_ENTRY ListEntry,
        IN  ULONG_PTR   Address,
        IN  ULONG       Verbose
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\amldebug.c ===
/*** amldebug.c - AML Debugger functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/*** Local function prototypes
 */

LONG LOCAL AMLIDbgBC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgBD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgBE(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgBL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgBP(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AddBrkPt(ULONG_PTR uipBrkPtAddr);
LONG LOCAL ClearBrkPt(int iBrkPt);
LONG LOCAL SetBrkPtState(int iBrkPt, BOOLEAN fEnable);
LONG LOCAL EnableDisableBP(PSZ pszArg, BOOLEAN fEnable, ULONG dwArgNum);
LONG LOCAL AMLIDbgCL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgDebugger(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
#ifdef DEBUG
LONG LOCAL AMLIDbgDH(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DumpHeap(ULONG_PTR uipHeap, ULONG dwSize);
#endif
LONG LOCAL AMLIDbgDL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgDNS(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs);
LONG LOCAL DumpNSObj(PSZ pszPath, BOOLEAN fRecursive);
VOID LOCAL DumpNSTree(PNSOBJ pnsObj, ULONG dwLevel);
LONG LOCAL AMLIDbgDO(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgDS(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL DumpStack(ULONG_PTR uipCtxt, PCTXT pctxt, BOOLEAN fVerbose);
LONG LOCAL AMLIDbgFind(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs);
BOOLEAN LOCAL FindNSObj(NAMESEG dwName, PNSOBJ pnsRoot);
LONG LOCAL AMLIDbgLC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgLN(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgP(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgR(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs);
LONG LOCAL DumpCtxt(ULONG_PTR uipCtxt);
LONG LOCAL AMLIDbgSet(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgT(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs);
LONG LOCAL AMLIDbgU(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs);
PSZ LOCAL GetObjectPath(PNSOBJ pns);
PSZ LOCAL GetObjAddrPath(ULONG_PTR uipns);
VOID LOCAL DumpObject(POBJDATA pdata, PSZ pszName, int iLevel);
PSZ LOCAL GetObjectTypeName(ULONG dwObjType);
PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace);
BOOLEAN LOCAL FindObjSymbol(ULONG_PTR uipObj, PULONG_PTR puipns,
                            PULONG pdwOffset);
VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen);
VOID LOCAL PrintSymbol(ULONG_PTR uip);
LONG LOCAL EvalExpr(PSZ pszArg, PULONG_PTR puipValue, BOOLEAN *pfPhysical,
                    PULONG_PTR puipns, PULONG pdwOffset);
BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG_PTR puipValue);
LONG LOCAL AMLITraceEnable(BOOL fEnable);

/*** Local data
 */

char gcszTokenSeps[] = " \t\n";
ULONG dwfDebuggerON = 0, dwfDebuggerOFF = 0;
ULONG dwfAMLIInitON = 0, dwfAMLIInitOFF = 0;
ULONG dwCmdArg = 0;

CMDARG ArgsHelp[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgHelp,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBC[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgBC,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBD[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgBD,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBE[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgBE,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsBP[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgBP,
    NULL, AT_END, 0, NULL, 0, NULL
};

#ifdef DEBUG
CMDARG ArgsDH[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgDH,
    NULL, AT_END, 0, NULL, 0, NULL
};
#endif

CMDARG ArgsDNS[] =
{
    "s", AT_ENABLE, 0, &dwCmdArg, DNSF_RECURSE, NULL,
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgDNS,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDO[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgDO,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsDS[] =
{
  #ifdef DEBUG
    "v", AT_ENABLE, 0, &dwCmdArg, DSF_VERBOSE, NULL,
  #endif
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgDS,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsFind[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgFind,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsLN[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgLN,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsR[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgR,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsSet[] =
{
    "traceon", AT_ENABLE, 0, &dwfDebuggerON, DBGF_AMLTRACE_ON, NULL,
    "traceoff", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_AMLTRACE_ON, NULL,
    "spewon", AT_ENABLE, 0, &dwfDebuggerON, DBGF_DEBUG_SPEW_ON, NULL,
    "spewoff", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_DEBUG_SPEW_ON, NULL,
    "nesttraceon", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_TRACE_NONEST, NULL,
    "nesttraceoff", AT_ENABLE, 0, &dwfDebuggerON, DBGF_TRACE_NONEST, NULL,
    "lbrkon", AT_ENABLE, 0, &dwfAMLIInitON, AMLIIF_LOADDDB_BREAK, NULL,
    "lbrkoff", AT_ENABLE, 0, &dwfAMLIInitOFF, AMLIIF_LOADDDB_BREAK, NULL,
    "errbrkon", AT_ENABLE, 0, &dwfDebuggerON, DBGF_ERRBREAK_ON, NULL,
    "errbrkoff", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_ERRBREAK_ON, NULL,
    "verboseon", AT_ENABLE, 0, &dwfDebuggerON, DBGF_VERBOSE_ON, NULL,
    "verboseoff", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_VERBOSE_ON, NULL,
    "logon", AT_ENABLE, 0, &dwfDebuggerON, DBGF_LOGEVENT_ON, NULL,
    "logoff", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_LOGEVENT_ON, NULL,
    "logmuton", AT_ENABLE, 0, &dwfDebuggerON, DBGF_LOGEVENT_MUTEX, NULL,
    "logmutoff", AT_ENABLE, 0, &dwfDebuggerOFF, DBGF_LOGEVENT_MUTEX, NULL,
    NULL, AT_END, 0, NULL, 0, NULL
};

CMDARG ArgsU[] =
{
    NULL, AT_ACTION, 0, NULL, 0, AMLIDbgU,
    NULL, AT_END, 0, NULL, 0, NULL
};

DBGCMD DbgCmds[] =
{
    "?", 0, ArgsHelp, AMLIDbgHelp,
    "bc", 0, ArgsBC, AMLIDbgBC,
    "bd", 0, ArgsBD, AMLIDbgBD,
    "be", 0, ArgsBE, AMLIDbgBE,
    "bl", 0, NULL, AMLIDbgBL,
    "bp", 0, ArgsBP, AMLIDbgBP,
    "cl", 0, NULL, AMLIDbgCL,
    "debugger", 0, NULL, AMLIDbgDebugger,
  #ifdef DEBUG
    "dh", 0, ArgsDH, AMLIDbgDH,
  #endif
    "dl", 0, NULL, AMLIDbgDL,
    "dns", 0, ArgsDNS, AMLIDbgDNS,
    "do", 0, ArgsDO, AMLIDbgDO,
    "ds", 0, ArgsDS, AMLIDbgDS,
    "find", 0, ArgsFind, AMLIDbgFind,
    "lc", 0, NULL, AMLIDbgLC,
    "ln", 0, ArgsLN, AMLIDbgLN,
    "p", 0, NULL, AMLIDbgP,
    "r", 0, ArgsR, AMLIDbgR,
    "set", 0, ArgsSet, AMLIDbgSet,
    "t", 0, NULL, AMLIDbgT,
    "u", 0, ArgsU, AMLIDbgU,
    NULL, 0, NULL, NULL
};

/***EP  AMLIDbgExecuteCmd - Parse and execute a debugger command
 *
 *  ENTRY
 *      pszCmd -> command string
 *
 *  EXIT
 *      None
 */

VOID STDCALL AMLIDbgExecuteCmd(PSZ pszCmd)
{
    PSZ psz;
    int i;
    ULONG dwNumArgs = 0, dwNonSWArgs = 0;

    if ((psz = STRTOK(pszCmd, gcszTokenSeps)) != NULL)
    {
        for (i = 0; DbgCmds[i].pszCmd != NULL; i++)
        {
            if (STRCMP(psz, DbgCmds[i].pszCmd) == 0)
            {
                if ((DbgCmds[i].pArgTable == NULL) ||
                    (DbgParseArgs(DbgCmds[i].pArgTable,
                                  &dwNumArgs,
                                  &dwNonSWArgs,
                                  gcszTokenSeps) == ARGERR_NONE))
                {
                    ASSERT(DbgCmds[i].pfnCmd != NULL);
                    DbgCmds[i].pfnCmd(NULL, NULL, dwNumArgs, dwNonSWArgs);
                }
                break;
            }
        }
    }
    else
    {
        DBG_ERROR(("invalid command \"%s\"", pszCmd));
    }
}       //AMLIDbgExecuteCmd

/***LP  AMLIDbgHelp - help
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);
    //
    // User typed ? <cmd>
    //
    if (pszArg != NULL)
    {
        if (STRCMP(pszArg, "?") == 0)
        {
            PRINTF("\nHelp:\n");
            PRINTF("Usage: ? [<Cmd>]\n");
            PRINTF("<Cmd> - command to get help on\n");
        }
        else if (STRCMP(pszArg, "bc") == 0)
        {
            PRINTF("\nClear Breakpoints:\n");
            PRINTF("Usage: bc <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "bd") == 0)
        {
            PRINTF("\nDisable Breakpoints:\n");
            PRINTF("Usage: bd <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "be") == 0)
        {
            PRINTF("\nEnable Breakpoints:\n");
            PRINTF("Usage: be <bp list> | *\n");
            PRINTF("<bp list> - list of breakpoint numbers\n");
            PRINTF("*         - all breakpoints\n");
        }
        else if (STRCMP(pszArg, "bl") == 0)
        {
            PRINTF("\nList All Breakpoints:\n");
            PRINTF("Usage: bl\n");
        }
        else if (STRCMP(pszArg, "bp") == 0)
        {
            PRINTF("\nSet BreakPoints:\n");
            PRINTF("Usage: bp <MethodName> | <CodeAddr> ...\n");
            PRINTF("<MethodName> - full path of method name to have breakpoint set at\n");
            PRINTF("<CodeAddr>   - address of AML code to have breakpoint set at\n");
        }
        else if (STRCMP(pszArg, "cl") == 0)
        {
            PRINTF("\nClear Event Log:\n");
            PRINTF("Usage: cl\n");
        }
        else if (STRCMP(pszArg, "debugger") == 0)
        {
            PRINTF("\nRequest entering AMLI debugger:\n");
            PRINTF("Usage: debugger\n");
        }
      #ifdef DEBUG
        else if (STRCMP(pszArg, "dh") == 0)
        {
            PRINTF("\nDump Heap:\n");
            PRINTF("Usage: dh [<Addr>]\n");
            PRINTF("<Addr> - address of the heap block, global heap if missing\n");
        }
      #endif
        else if (STRCMP(pszArg, "dl") == 0)
        {
            PRINTF("\nDump Event Log:\n");
            PRINTF("Usage: dl\n");
        }
        else if (STRCMP(pszArg, "dns") == 0)
        {
            PRINTF("\nDump Name Space Object:\n");
            PRINTF("Usage: dns [[/s] [<NameStr> | <Addr>]]\n");
            PRINTF("s         - recursively dump the name space subtree\n");
            PRINTF("<NameStr> - name space path (dump whole name space if absent)\n");
            PRINTF("<Addr>    - specify address of the name space object\n");
        }
        else if (STRCMP(pszArg, "do") == 0)
        {
            PRINTF("\nDump Data Object:\n");
            PRINTF("Usage: do <Addr>\n");
            PRINTF("<Addr> - address of the data object\n");
        }
        else if (STRCMP(pszArg, "ds") == 0)
        {
            PRINTF("\nDump Stack:\n");
          #ifdef DEBUG
            PRINTF("Usage: ds [/v] [<Addr>]\n");
            PRINTF("v - enable versbos mode\n");
          #else
            PRINTF("Usage: ds [<Addr>]\n");
          #endif
            PRINTF("<Addr> - address of the context block, use current context if missing\n");
        }
        else if (STRCMP(pszArg, "find") == 0)
        {
            PRINTF("\nFind NameSpace Object:\n");
            PRINTF("Usage: find <NameSeg>\n");
            PRINTF("<NameSeg> - Name of the NameSpace object without path\n");
        }
        else if (STRCMP(pszArg, "lc") == 0)
        {
            PRINTF("\nList All Contexts:\n");
            PRINTF("Usage: lc\n");
        }
        else if (STRCMP(pszArg, "ln") == 0)
        {
            PRINTF("\nDisplay Nearest Method Name:\n");
            PRINTF("Usage: ln [<MethodName> | <CodeAddr>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of AML code\n");
        }
        else if (STRCMP(pszArg, "p") == 0)
        {
            PRINTF("\nStep over AML Code\n");
            PRINTF("Usage: p\n");
        }
        else if (STRCMP(pszArg, "r") == 0)
        {
            PRINTF("\nDisplay Context Information:\n");
            PRINTF("Usage: r\n");
        }
        else if (STRCMP(pszArg, "set") == 0)
        {
            PRINTF("\nSet Debugger Options:\n");
            PRINTF("Usage: set [traceon | traceoff] [nesttraceon | nesttraceoff] [spewon | spewoff]\n"
                   "           [lbrkon | lbrkoff] [errbrkon | errbrkoff] [verboseon | verboseoff] \n"
                   "           [logon | logoff] [logmuton | logmutoff]\n");
            PRINTF("traceon      - turn on AML tracing\n");
            PRINTF("traceoff     - turn off AML tracing\n");
            PRINTF("nesttraceon  - turn on nest tracing (only valid with traceon)\n");
            PRINTF("nesttraceoff - turn off nest tracing (only valid with traceon)\n");
            PRINTF("spewon       - turn on debug spew\n");
            PRINTF("spewoff      - turn off debug spew\n");
            PRINTF("lbrkon       - enable load DDB completion break\n");
            PRINTF("lbrkoff      - disable load DDB completion break\n");
            PRINTF("errbrkon     - enable break on error\n");
            PRINTF("errbrkoff    - disable break on error\n");
            PRINTF("verboseon    - enable verbose mode\n");
            PRINTF("verboseoff   - disable verbose mode\n");
            PRINTF("logon        - enable event logging\n");
            PRINTF("logoff       - disable event logging\n");
            PRINTF("logmuton     - enable mutex event logging\n");
            PRINTF("logmutoff    - disable mutex event logging\n");
        }
        else if (STRCMP(pszArg, "t") == 0)
        {
            PRINTF("\nTrace Into AML Code:\n");
            PRINTF("Usage: t\n");
        }
        else if (STRCMP(pszArg, "u") == 0)
        {
            PRINTF("\nUnassemble AML code:\n");
            PRINTF("Usage: u [<MethodName> | <CodeAddr>]\n");
            PRINTF("<MethodName> - full path of method name\n");
            PRINTF("<CodeAddr>   - address of AML code\n");
        }
        else
        {
            DBG_ERROR(("invalid help command - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    //
    // User typed just a "?" without any arguments
    //
    else if (dwArgNum == 0)
    {
        PRINTF("\n");
        PRINTF("Help                     - ? [<Cmd>]\n");
        PRINTF("Clear Breakpoints        - bc <bp list> | *\n");
        PRINTF("Disable Breakpoints      - bd <bp list> | *\n");
        PRINTF("Enable Breakpoints       - be <bp list> | *\n");
        PRINTF("List Breakpoints         - bl\n");
        PRINTF("Set Breakpoints          - bp <MethodName> | <CodeAddr> ...\n");
        PRINTF("Clear Event Log          - cl\n");
        PRINTF("Request entering debugger- debugger\n");
      #ifdef DEBUG
        PRINTF("Dump Heap                - dh [<Addr>]\n");
      #endif
        PRINTF("Dump Event Log           - dl\n");
        PRINTF("Dump Name Space Object   - dns [[/s] [<NameStr> | <Addr>]]\n");
        PRINTF("Dump Data Object         - do <Addr>\n");
      #ifdef DEBUG
        PRINTF("Dump Stack               - ds [/v] [<Addr>]\n");
      #else
        PRINTF("Dump Stack               - ds [<Addr>]\n");
      #endif
        PRINTF("Find NameSpace Object    - find <NameSeg>\n");
        PRINTF("List All Contexts        - lc\n");
        PRINTF("Display Nearest Method   - ln [<MethodName> | <CodeAddr>]\n");
        PRINTF("Step Over AML Code       - p\n");
        PRINTF("Display Context Info.    - r\n");
        PRINTF("Set Debugger Options     - set [traceon | traceoff] [nesttraceon | nesttraceoff] [spewon | spewoff]\n"
               "                               [lbrkon | lbrkoff] [errbrkon | errbrkoff] [verboseon | verboseoff] \n"
               "                               [logon | logoff] [logmuton | logmutoff]\n");
        PRINTF("Trace Into AML Code      - t\n");
        PRINTF("Unassemble AML code      - u [<MethodName> | <CodeAddr>]\n");
    }

    return rc;
}       //AMLIDbgHelp

/***LP  AMLIDbgBC - Clear BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgBC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG dwBrkPt;

        if (STRCMP(pszArg, "*") == 0)
        {
            for (dwBrkPt = 0; dwBrkPt < MAX_BRK_PTS; ++dwBrkPt)
            {
                if ((rc = ClearBrkPt((int)dwBrkPt)) != DBGERR_NONE)
                {
                    break;
                }
            }
        }
        else if (IsNumber(pszArg, 10, (PULONG_PTR)&dwBrkPt))
        {
            rc = ClearBrkPt((int)dwBrkPt);
        }
        else
        {
            DBG_ERROR(("invalid breakpoint number"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (dwArgNum == 0)
    {
        DBG_ERROR(("invalid breakpoint command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgBC

/***LP  AMLIDbgBD - Disable BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgBD(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    rc = EnableDisableBP(pszArg, FALSE, dwArgNum);

    return rc;
}       //AMLIDbgBD

/***LP  AMLIDbgBE - Enable BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgBE(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    rc = EnableDisableBP(pszArg, TRUE, dwArgNum);

    return rc;
}       //AMLIDbgBE

/***LP  AMLIDbgBL - List BreakPoints
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgBL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        BRKPT BrkPts[MAX_BRK_PTS];

        if (ReadMemory(FIELDADDROF("gDebugger", DBGR, BrkPts),
                       BrkPts,
                       sizeof(BrkPts),
                       NULL))
        {
            int i;
            PNSOBJ pns;
            ULONG dwOffset;

            for (i = 0; i < MAX_BRK_PTS; ++i)
            {
                if (BrkPts[i].pbBrkPt != NULL)
                {
                    PRINTF("%2d: <%c> ",
                           i,
                           (BrkPts[i].dwfBrkPt & BPF_ENABLED)? 'e': 'd');

                    PrintSymbol((ULONG_PTR)BrkPts[i].pbBrkPt);
                    PRINTF("\n");
                }
            }
        }
        else
        {
            DBG_ERROR(("failed to read break point table"));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid breakpoint command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgBL

/***LP  AMLIDbgBP - Set BreakPoint
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgBP(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG_PTR uipBP;

        if ((rc = EvalExpr(pszArg, &uipBP, NULL, NULL, NULL)) == DBGERR_NONE)
        {
            rc = AddBrkPt(uipBP);
        }
    }
    else if (dwArgNum == 0)
    {
        DBG_ERROR(("invalid breakpoint command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgBP

/***LP  AddBrkPt - Add breakpoint
 *
 *  ENTRY
 *      uipBrkPtAddr - breakpoint address
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL AddBrkPt(ULONG_PTR uipBrkPtAddr)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uipBrkPts = FIELDADDROF("gDebugger", DBGR, BrkPts), uipBP = 0;
    int i, iBrkPt;

    //
    // Look for a vacant slot.
    //
    for (i = 0, iBrkPt = -1; i < MAX_BRK_PTS; ++i)
    {
        uipBP = READMEMULONGPTR(uipBrkPts +
                                sizeof(BRKPT)*i +
                                FIELD_OFFSET(BRKPT, pbBrkPt));
        if ((uipBrkPtAddr == uipBP) || (iBrkPt == -1) && (uipBP == 0))
        {
            iBrkPt = i;
        }
    }

    if (iBrkPt == -1)
    {
        DBG_ERROR(("no free breakpoint"));
        rc = DBGERR_CMD_FAILED;
    }
    else if (uipBP == 0)
    {
        BRKPT BrkPt;

        BrkPt.pbBrkPt = (PUCHAR)uipBrkPtAddr;
        BrkPt.dwfBrkPt = BPF_ENABLED;
        if (!WriteMemory(uipBrkPts + sizeof(BRKPT)*iBrkPt,
                         &BrkPt,
                         sizeof(BrkPt),
                         NULL))
        {
            DBG_ERROR(("failed to write to break point %d", iBrkPt));
            rc = DBGERR_CMD_FAILED;
        }
    }

    return rc;
}       //AddBrkPt

/***LP  ClearBrkPt - Clear breakpoint
 *
 *  ENTRY
 *      iBrkPt - breakpoint number
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL ClearBrkPt(int iBrkPt)
{
    LONG rc;

    if (iBrkPt < MAX_BRK_PTS)
    {
        MZERO(FIELDADDROF("gDebugger", DBGR, BrkPts) + sizeof(BRKPT)*iBrkPt,
              sizeof(BRKPT));
        rc = DBGERR_NONE;
    }
    else
    {
        DBG_ERROR(("invalid breakpoint number"));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //ClearBrkPt

/***LP  SetBrkPtState - Enable/Disable breakpoint
 *
 *  ENTRY
 *      iBrkPt - breakpoint number
 *      fEnable - enable breakpoint
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL SetBrkPtState(int iBrkPt, BOOLEAN fEnable)
{
    LONG rc = DBGERR_CMD_FAILED;

    if (iBrkPt < MAX_BRK_PTS)
    {
        ULONG_PTR uipBP = FIELDADDROF("gDebugger", DBGR, BrkPts) +
                          sizeof(BRKPT)*iBrkPt;
        BRKPT BrkPt;

        if (ReadMemory(uipBP, &BrkPt, sizeof(BrkPt), NULL))
        {
            if (BrkPt.pbBrkPt != NULL)
            {
                if (fEnable)
                {
                    BrkPt.dwfBrkPt |= BPF_ENABLED;
                }
                else
                {
                    BrkPt.dwfBrkPt &= ~BPF_ENABLED;
                }

                if (WriteMemory(uipBP, &BrkPt, sizeof(BrkPt), NULL))
                {
                    rc = DBGERR_NONE;
                }
                else
                {
                    DBG_ERROR(("failed to write break point %d",
                               iBrkPt));
                }
            }
            else
            {
                rc = DBGERR_NONE;
            }
        }
        else
        {
            DBG_ERROR(("failed to read break point %d", iBrkPt));
        }
    }
    else
    {
        DBG_ERROR(("invalid breakpoint number"));
    }

    return rc;
}       //SetBrkPtState

/***LP  EnableDisableBP - Enable/Disable BreakPoints
 *
 *  ENTRY
 *      pszArg -> argument string
 *      fEnable - TRUE if enable breakpoints
 *      dwArgNum - argument number
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL EnableDisableBP(PSZ pszArg, BOOLEAN fEnable, ULONG dwArgNum)
{
    LONG rc = DBGERR_NONE;

    if (pszArg != NULL)
    {
        ULONG dwBrkPt;

        if (STRCMP(pszArg, "*") == 0)
        {
            for (dwBrkPt = 0; dwBrkPt < MAX_BRK_PTS; ++dwBrkPt)
            {
                if ((rc = SetBrkPtState((int)dwBrkPt, fEnable)) != DBGERR_NONE)
                    break;
            }
        }
        else if (IsNumber(pszArg, 10, (PULONG_PTR)&dwBrkPt))
        {
            rc = SetBrkPtState((int)dwBrkPt, fEnable);
        }
        else
        {
            DBG_ERROR(("invalid breakpoint number"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (dwArgNum == 0)
    {
        DBG_ERROR(("invalid breakpoint command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //EnableDisableBP

/***LP  AMLIDbgCL - Clear event log
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgCL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        ULONG_PTR uipEventLog = READMEMULONGPTR(FIELDADDROF("gDebugger",
                                                            DBGR,
                                                            pEventLog));

        if (uipEventLog != 0)
        {
            ULONG dwLogSize = READMEMDWORD(FIELDADDROF("gDebugger",
                                                       DBGR,
                                                       dwLogSize));
            ULONG i;

            //
            // For some reason, zeroing the whole eventlog in one shot
            // causes WriteMemory to hang, so I'll do one record at a
            // time.
            //
            for (i = 0; i < dwLogSize; ++i)
            {
                MZERO(uipEventLog + i*sizeof(EVENTLOG), sizeof(EVENTLOG));
            }

            i = 0;
            WRITEMEMDWORD(FIELDADDROF("gDebugger", DBGR, dwLogIndex), i);
            rc = DBGERR_NONE;
        }
        else
        {
            DBG_ERROR(("no event log allocated"));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid CL command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgCL

/***LP  AMLIDbgDebugger - Request entering debugger
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDebugger(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        ULONG_PTR uip = FIELDADDROF("gDebugger", DBGR, dwfDebugger);

        if (uip != 0)
        {
            ULONG dwData = READMEMDWORD(uip);

            dwData |= DBGF_DEBUGGER_REQ;
            if (!WRITEMEMDWORD(uip, dwData))
            {
                DBG_ERROR(("failed to write debugger flag at %x", uip));
                rc = DBGERR_CMD_FAILED;
            }
        }
        else
        {
            DBG_ERROR(("failed to get debugger flag address"));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid debugger command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgDebugger

#ifdef DEBUG
/***LP  AMLIDbgDH - Dump heap
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDH(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static ULONG_PTR uipHeap = 0;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        if (uipHeap == 0)
        {
            if (!IsNumber(pszArg, 16, &uipHeap))
            {
                DBG_ERROR(("invalid heap block address - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("invalid dump heap command"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        HEAP HeapHdr;

        if (dwArgNum == 0)
        {
            uipHeap = READSYMULONGPTR("gpheapGlobal");
        }

        if (ReadMemory(uipHeap, &HeapHdr, sizeof(HeapHdr), NULL))
        {
            if (HeapHdr.dwSig == SIG_HEAP)
            {
                for (uipHeap = (ULONG_PTR)HeapHdr.pheapHead;
                     (rc == DBGERR_NONE) &&
                     (uipHeap != 0) &&
                     ReadMemory(uipHeap, &HeapHdr, sizeof(HeapHdr), NULL);
                     uipHeap = (ULONG_PTR)HeapHdr.pheapNext)
                {
                    rc = DumpHeap(uipHeap,
                                  (ULONG)((ULONG_PTR)HeapHdr.pbHeapEnd - uipHeap));
                }
            }
            else
            {
                DBG_ERROR(("invalid heap block at %x", uipHeap));
                rc = DBGERR_CMD_FAILED;
            }
        }
        else
        {
            DBG_ERROR(("failed to read heap header at %x", uipHeap));
            rc = DBGERR_CMD_FAILED;
        }

        uipHeap = 0;
    }

    return rc;
}       //AMLIDbgDH

/***LP  DumpHeap - Dump heap block
 *
 *  ENTRY
 *      uipHeap - Heap block address
 *      dwSize - Heap block size
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DumpHeap(ULONG_PTR uipHeap, ULONG dwSize)
{
    LONG rc = DBGERR_NONE;
    PHEAP pheap;

    if ((pheap = LocalAlloc(LPTR, dwSize)) != NULL)
    {
        if (ReadMemory(uipHeap, pheap, dwSize, NULL))
        {
            PHEAPOBJHDR phobj;
            ULONG_PTR uipXlate = uipHeap - (ULONG_PTR)pheap;

            PRINTF("HeapBlock=%08x, HeapEnd=%08x, HeapHead=%08x, HeapNext=%08x\n",
                   uipHeap, pheap->pbHeapEnd, pheap->pheapHead, pheap->pheapNext);
            PRINTF("HeapTop=%08x, HeapFreeList=%08x, UsedHeapSize=%d bytes\n",
                   pheap->pbHeapTop, pheap->plistFreeHeap,
                   pheap->pbHeapTop - uipHeap - FIELD_OFFSET(HEAP, Heap));

            for (phobj = &pheap->Heap;
                 (PUCHAR)phobj < pheap->pbHeapTop - uipXlate;
                 phobj = (PHEAPOBJHDR)((PUCHAR)phobj + phobj->dwLen))
            {
                PRINTF("%08x: %s, Len=%08d, Prev=%08x, Next=%08x\n",
                       (ULONG_PTR)phobj + uipXlate,
                       (phobj->dwSig == 0)? "free": NameSegString(phobj->dwSig),
                       phobj->dwLen,
                       (phobj->dwSig == 0)? phobj->list.plistPrev: 0,
                       (phobj->dwSig == 0)? phobj->list.plistNext: 0);
            }
        }
        else
        {
            DBG_ERROR(("failed to read heap block at %x, size=%d",
                       uipHeap, dwSize));
            rc = DBGERR_CMD_FAILED;
        }
        LocalFree(pheap);
    }
    else
    {
        DBG_ERROR(("failed to allocate heap block (size=%d)", dwSize));
        rc = DBGERR_CMD_FAILED;
    }

    return rc;
}       //DumpHeap
#endif

/***LP  AMLIDbgDL - Dump event log
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDL(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        DBG_ERROR(("invalid DL command"));
        rc = DBGERR_INVALID_CMD;
    }
    else
    {
        ULONG_PTR uipEventLog = READMEMULONGPTR(FIELDADDROF("gDebugger",
                                                            DBGR,
                                                            pEventLog));

        if (uipEventLog != 0)
        {
            ULONG dwLogSize, dwLogIndex, i;
            PEVENTLOG pEventLog;
            PEVENTLOG plog;
            TIME_FIELDS eventTime;
            LARGE_INTEGER eventTimeInt;

            dwLogSize = READMEMDWORD(FIELDADDROF("gDebugger", DBGR, dwLogSize));
            dwLogIndex = READMEMDWORD(FIELDADDROF("gDebugger", DBGR, dwLogIndex));

            if ((pEventLog = LocalAlloc(LPTR, sizeof(EVENTLOG)*dwLogSize)) !=
                NULL)
            {
                if (ReadMemory(uipEventLog,
                               pEventLog,
                               sizeof(EVENTLOG)*dwLogSize,
                               NULL))
                {
                    for (i = dwLogIndex;;)
                    {
                        if (pEventLog[i].dwEvent != 0)
                        {
                            plog = &pEventLog[i];

                            eventTimeInt.QuadPart = plog->ullTime;
                            RtlTimeToTimeFields( &eventTimeInt, &eventTime );
                            PRINTF(
                                "%d:%02d:%02d.%03d [%8x] ",
                                eventTime.Hour,
                                eventTime.Minute,
                                eventTime.Second,
                                eventTime.Milliseconds,
                                plog->uipData1
                                );

                            switch (plog->dwEvent) {
                                case 'AMUT':
                                    PRINTF("AcquireMutext         ");
                                    break;
                                case 'RMUT':
                                    PRINTF("ReleaseMutext         ");
                                    break;
                                case 'INSQ':
                                    PRINTF("InsertReadyQueue      ");
                                    break;
                                case 'NEST':
                                    PRINTF("NestContext           ");
                                    break;
                                case 'EVAL':
                                    PRINTF("EvaluateContext       ");
                                    break;
                                case 'QCTX':
                                    PRINTF("QueueContext          ");
                                    break;
                                case 'REST':
                                    PRINTF("RestartContext        ");
                                    break;
                                case 'KICK':
                                    PRINTF("QueueWorkItem         ");
                                    break;
                                case 'PAUS':
                                    PRINTF("PauseInterpreter      ");
                                    break;
                                case 'RSCB':
                                    PRINTF("RestartCtxtCallback   ");
                                    break;
                                case 'DONE':
                                    PRINTF("EvalMethodComplete    ");
                                    break;
                                case 'ASCB':
                                    PRINTF("AsyncCallBack         ");
                                    break;
                                case 'NSYN':
                                    PRINTF("NestedSyncEvalObject  ");
                                    break;
                                case 'SYNC':
                                    PRINTF("SyncEvalObject        ");
                                    break;
                                case 'ASYN':
                                    PRINTF("AsyncEvalObject       ");
                                    break;
                                case 'NASY':
                                    PRINTF("NestedAsyncEvalObject ");
                                    break;
                                case 'RUNC':
                                    PRINTF("RunContext            ");
                                    break;
                                case 'PACB':
                                    PRINTF("PauseAsyncCallback    ");
                                    break;
                                case 'RUN!':
                                    PRINTF("FinishedContext       ");
                                    break;
                                case 'RSUM':
                                    PRINTF("ResumeInterpreter     ");
                                    break;
                                case 'RSTQ':
                                    PRINTF("ResumeQueueWorkItem   ");
                                    break;
                                default:
                                    break;
                            }

                            switch (plog->dwEvent)
                            {
                                case 'AMUT':
                                case 'RMUT':
                                    PRINTF("\n    Mut=%08x Owner=%08x dwcOwned=%d rc=%x\n",
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4, plog->uipData5);
                                    break;

                                case 'INSQ':
                                case 'NEST':
                                case 'EVAL':
                                case 'QCTX':
                                case 'REST':
                                    PRINTF("Context=%08x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x pbOp=",
                                           plog->uipData5,
                                           GetObjAddrPath(plog->uipData6),
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4
                                           );
                                    PrintSymbol(plog->uipData7);
                                    PRINTF("\n");
                                    break;

                                case 'KICK':
                                case 'PAUS':
                                    PRINTF("\n    QTh=%08x QCt=%08x QFg=%08x rc=%x\n",
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4, plog->uipData5);
                                    break;


                                case 'RSCB':
                                    PRINTF("Context=%08x\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData5, plog->uipData2,
                                           plog->uipData3, plog->uipData4);
                                    break;

                                case 'DONE':
                                case 'ASCB':
                                    PRINTF("rc=%x pEvent=%x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData6, plog->uipData7,
                                           GetObjAddrPath(plog->uipData5),
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4
                                           );
                                    break;

                                case 'NSYN':
                                case 'SYNC':
                                case 'ASYN':
                                    PRINTF("IRQL=%2x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData5 & 0xff,
                                           GetObjAddrPath(plog->uipData6),
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4
                                           );
                                    break;

                                case 'NASY':
                                    PRINTF("Context=%x CallBack=%x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData6, plog->uipData7,
                                           GetObjAddrPath(plog->uipData5),
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4
                                           );
                                    break;

                                case 'RUNC':
                                    PRINTF("Context=%x\n    %s\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData5,
                                           GetObjAddrPath(plog->uipData6),
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4
                                           );
                                    break;

                                case 'PACB':
                                case 'RUN!':
                                    PRINTF("Context=%x rc=%x\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData5, plog->uipData6,
                                           plog->uipData2, plog->uipData3,
                                           plog->uipData4
                                           );
                                    break;

                                case 'RSUM':
                                case 'RSTQ':
                                    PRINTF("\n    QTh=%08x QCt=%08x QFg=%08x\n",
                                           plog->uipData1, plog->uipData2, plog->uipData3,
                                           plog->uipData4);
                                    break;

                                default:
                                    PRINTF("D1=%08x,D2=%08x,D3=%08x,D4=%08x,D5=%08x,D6=%08x,D7=%08x\n",
                                           plog->uipData1, plog->uipData2,
                                           plog->uipData3, plog->uipData4,
                                           plog->uipData5, plog->uipData6,
                                           plog->uipData7);
                            }
                        }
                        PRINTF("\n");

                        if (++i >= dwLogSize)
                        {
                            i = 0;
                        }

                        if (i == dwLogIndex)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    DBG_ERROR(("failed to read event log buffer at %x",
                               uipEventLog));
                    rc = DBGERR_CMD_FAILED;
                }
                LocalFree(pEventLog);
            }
            else
            {
                DBG_ERROR(("failed to allocate event log buffer (size=%d)",
                           dwLogSize));
                rc = DBGERR_CMD_FAILED;
            }
        }
        else
        {
            DBG_ERROR(("no event log allocated"));
            rc = DBGERR_CMD_FAILED;
        }
    }

    return rc;
}       //AMLIDbgDL

/***LP  AMLIDbgDNS - Dump Name Space
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDNS(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);
    //
    // User specified name space path or name space node address
    //
    if (pszArg != NULL)
    {
        ULONG_PTR uipNSObj;
        NSOBJ NSObj;

        if (!IsNumber(pszArg, 16, &uipNSObj))
        {
            //
            // The argument is not an address, could be a name space path.
            //
            STRUPR(pszArg);
            rc = DumpNSObj(pszArg,
                           (BOOLEAN)((dwCmdArg & DNSF_RECURSE) != 0));
        }
        else if (!ReadMemory(uipNSObj, &NSObj, sizeof(NSOBJ), NULL))
        {
            DBG_ERROR(("failed to read NameSpace object at %x", uipNSObj));
            rc = DBGERR_INVALID_CMD;
        }
        else
        {
            PRINTF("\nACPI Name Space: %s (%x)\n",
                   GetObjAddrPath(uipNSObj), uipNSObj);
            if (dwCmdArg & DNSF_RECURSE)
            {
                DumpNSTree(&NSObj, 0);
            }
            else
            {
                DumpObject(&NSObj.ObjData, NameSegString(NSObj.dwNameSeg), 0);
            }
        }
    }
    else
    {
        if (dwArgNum == 0)
        {
            //
            // User typed "dns" but did not specify any name space path
            // or address.
            //
            rc = DumpNSObj(NAMESTR_ROOT, TRUE);
        }

        dwCmdArg = 0;
    }

    return rc;
}       //AMLIDbgDNS

/***LP  DumpNSObj - Dump name space object
 *
 *  ENTRY
 *      pszPath -> name space path string
 *      fRecursive - TRUE if also dump the subtree recursively
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_ code
 */

LONG LOCAL DumpNSObj(PSZ pszPath, BOOLEAN fRecursive)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uipns;
    NSOBJ NSObj;

    if ((rc = GetNSObj(pszPath, NULL, &uipns, &NSObj,
                       NSF_LOCAL_SCOPE | NSF_WARN_NOTFOUND)) == DBGERR_NONE)
    {
        PRINTF("\nACPI Name Space: %s (%x)\n", pszPath, uipns);
        if (!fRecursive)
        {
            char szName[sizeof(NAMESEG) + 1] = {0};

            STRCPYN(szName, (PSZ)&NSObj.dwNameSeg, sizeof(NAMESEG));
            DumpObject(&NSObj.ObjData, szName, 0);
        }
        else
        {
            DumpNSTree(&NSObj, 0);
        }
    }

    return rc;
}       //DumpNSObj

/***LP  DumpNSTree - Dump all the name space objects in the subtree
 *
 *  ENTRY
 *      pnsObj -> name space subtree root
 *      dwLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL DumpNSTree(PNSOBJ pnsObj, ULONG dwLevel)
{
    char szName[sizeof(NAMESEG) + 1] = {0};
    ULONG_PTR uipns, uipnsNext;
    NSOBJ NSObj;
    //
    // First, dump myself
    //
    STRCPYN(szName, (PSZ)&pnsObj->dwNameSeg, sizeof(NAMESEG));
    DumpObject(&pnsObj->ObjData, szName, dwLevel);
    //
    // Then, recursively dump each of my children
    //
    for (uipns = (ULONG_PTR)pnsObj->pnsFirstChild;
         (uipns != 0) &&
         ReadMemory(uipns, &NSObj, sizeof(NSObj), NULL);
         uipns = uipnsNext)
    {
        //
        // If this is the last child, we have no more.
        //
        uipnsNext = (ULONG_PTR)(((PNSOBJ)NSObj.list.plistNext ==
                                  pnsObj->pnsFirstChild)?
                                NULL: NSObj.list.plistNext);
        //
        // Dump a child
        //
        DumpNSTree(&NSObj, dwLevel + 1);
    }
}       //DumpNSTree

/***LP  AMLIDbgDO - Dump data object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDO(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);
    //
    // User specified object address
    //
    if (pszArg != NULL)
    {
        ULONG_PTR uipObj;
        OBJDATA Obj;

        if (IsNumber(pszArg, 16, &uipObj))
        {
            if (ReadMemory(uipObj, &Obj, sizeof(Obj), NULL))
            {
                DumpObject(&Obj, NULL, 0);
            }
            else
            {
                DBG_ERROR(("failed to read object at %x", uipObj));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("invalid object address %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }

    return rc;
}       //AMLIDbgDO

/***LP  AMLIDbgDS - Dump stack
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgDS(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static ULONG_PTR uipCtxt = 0;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        if (uipCtxt == 0)
        {
            if (!IsNumber(pszArg, 16, &uipCtxt))
            {
                DBG_ERROR(("invalid context block address %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
        else
        {
            DBG_ERROR(("invalid dump stack command"));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else
    {
        ULONG dwCtxtBlkSize = READSYMDWORD("gdwCtxtBlkSize");
        PCTXT pctxt;

        if (dwArgNum == 0)
        {
            uipCtxt = READMEMULONGPTR(FIELDADDROF("gReadyQueue",
                                                  CTXTQ,
                                                  pctxtCurrent));
        }

        if (uipCtxt == 0)
        {
            DBG_ERROR(("no current context"));
            rc = DBGERR_CMD_FAILED;
        }
        else if ((pctxt = LocalAlloc(LPTR, dwCtxtBlkSize)) == NULL)
        {
            DBG_ERROR(("failed to allocate context block (size=%d)",
                       dwCtxtBlkSize));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            if (!ReadMemory(uipCtxt, pctxt, dwCtxtBlkSize, NULL))
            {
                DBG_ERROR(("failed to read context block (pctxt=%x, size=%d)",
                           uipCtxt, dwCtxtBlkSize));
                rc = DBGERR_CMD_FAILED;
            }
            else if (pctxt->dwSig == SIG_CTXT)
            {
                rc = DumpStack(uipCtxt,
                               pctxt,
                               (BOOLEAN)((dwCmdArg & DSF_VERBOSE) != 0));
            }
            else
            {
                DBG_ERROR(("invalid context block at %x", uipCtxt));
                rc = DBGERR_CMD_FAILED;
            }
            LocalFree(pctxt);
        }

        dwCmdArg = 0;
        pctxt = NULL;
    }

    return rc;
}       //AMLIDbgDS

/***LP  DumpStack - Dump stack of a context block
 *
 *  ENTRY
 *      uipCtxt - context block address
 *      pctxt -> CTXT
 *      fVerbose - TRUE if verbose mode on
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DumpStack(ULONG_PTR uipCtxt, PCTXT pctxt, BOOLEAN fVerbose)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uipXlate = uipCtxt - (ULONG_PTR)pctxt;
    PFRAMEHDR pfh;
    PUCHAR pbOp = NULL;

    ASSERT(pctxt->dwSig == SIG_CTXT);

    if (fVerbose)
    {
        PRINTF("CtxtBlock=%x, StackTop=%x, StackEnd=%x\n\n",
               uipCtxt, pctxt->LocalHeap.pbHeapEnd, pctxt->pbCtxtEnd);
    }

    for (pfh = (PFRAMEHDR)(pctxt->LocalHeap.pbHeapEnd - uipXlate);
         (PUCHAR)pfh < (PUCHAR)(pctxt->pbCtxtEnd - uipXlate);
         pfh = (PFRAMEHDR)((PUCHAR)pfh + pfh->dwLen))
    {
        if (fVerbose)
        {
            PRINTF("%08x: %s, Len=%08d, FrameFlags=%08x, ParseFunc=%08x\n",
                   (ULONG_PTR)pfh + uipXlate, NameSegString(pfh->dwSig),
                   pfh->dwLen, pfh->dwfFrame, pfh->pfnParse);
        }

        if (pfh->dwSig == SIG_CALL)
        {
            int i;

            PCALL pcall = (PCALL)pfh;
            //
            // This is a call frame, dump it.
            //
            PRINTF("%08x: %s(",
                   pbOp, GetObjAddrPath((ULONG_PTR)pcall->pnsMethod));
            if (pcall->icArgs > 0)
            {
                POBJDATA pArgs = LocalAlloc(LPTR,
                                            sizeof(OBJDATA)*pcall->icArgs);

                if (pArgs != NULL)
                {
                    if (ReadMemory((ULONG_PTR)pcall->pdataArgs,
                                   pArgs,
                                   sizeof(OBJDATA)*pcall->icArgs,
                                   NULL))
                    {
                        for (i = 0; i < pcall->icArgs; ++i)
                        {
                            DumpObject(&pArgs[i], NULL, -1);
                            if (i + 1 < pcall->icArgs)
                            {
                                PRINTF(",");
                            }
                        }
                    }
                    else
                    {
                        DBG_ERROR(("failed to read argument objects at %x",
                                   pcall->pdataArgs));
                        rc = DBGERR_CMD_FAILED;
                    }
                    LocalFree(pArgs);
                }
                else
                {
                    DBG_ERROR(("failed to allocate argument objects (size=%d)",
                               sizeof(OBJDATA)*pcall->icArgs));
                    rc = DBGERR_CMD_FAILED;
                }
            }
            PRINTF(")\n");

            if ((rc == DBGERR_NONE) && fVerbose)
            {
                for (i = 0; i < MAX_NUM_LOCALS; ++i)
                {
                    PRINTF("Local%d: ", i);
                    DumpObject(&pcall->Locals[i], NULL, 0);
                }
            }
        }
        else if (pfh->dwSig == SIG_SCOPE)
        {
            pbOp = ((PSCOPE)pfh)->pbOpRet;
        }
    }

    return rc;
}       //DumpStack

/***LP  AMLIDbgFind - Find NameSpace Object
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwfDataSize - data size flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgFind(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        ULONG dwLen;
        NSOBJ NSRoot;

        dwLen = STRLEN(pszArg);
        STRUPR(pszArg);
        if (dwLen > sizeof(NAMESEG))
        {
            DBG_ERROR(("invalid NameSeg - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
        else if (ReadMemory(READSYMULONGPTR("gpnsNameSpaceRoot"),
                            &NSRoot, sizeof(NSRoot), NULL))
        {
            NAMESEG dwName;

            dwName = NAMESEG_BLANK;
            MEMCPY(&dwName, pszArg, dwLen);

            if (!FindNSObj(dwName, &NSRoot))
            {
                PRINTF("No such NameSpace object - %s\n", pszArg);
            }
        }
        else
        {
            DBG_ERROR(("failed to read NameSpace root object"));
        }
    }
    else if (dwArgNum == 0)
    {
        DBG_ERROR(("invalid Find command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgFind

/***LP  FindNSObj - Find and print the full path of a name space object
 *
 *  ENTRY
 *      dwName - NameSeg of the name space object
 *      pnsRoot - root of subtree to search for object
 *
 *  EXIT-SUCCESS
 *      returns TRUE - found at least one match
 *  EXIT-FAILURE
 *      returns FALSE - found no match
 */

BOOLEAN LOCAL FindNSObj(NAMESEG dwName, PNSOBJ pnsRoot)
{
    BOOLEAN rc = FALSE;

    if (pnsRoot != NULL)
    {
        if (dwName == pnsRoot->dwNameSeg)
        {
            PRINTF("%s\n", GetObjectPath(pnsRoot));
            rc = TRUE;
        }

        if (pnsRoot->pnsFirstChild != NULL)
        {
            ULONG_PTR uip, uipNext;
            NSOBJ NSChild;

            for (uip = (ULONG_PTR)pnsRoot->pnsFirstChild;
                 (uip != 0) &&
                 ReadMemory(uip, &NSChild, sizeof(NSChild), NULL);
                 uip = uipNext)
            {
                uipNext = (ULONG_PTR)
                            (((PNSOBJ)NSChild.list.plistNext ==
                              pnsRoot->pnsFirstChild)?
                              NULL: NSChild.list.plistNext);

                rc |= FindNSObj(dwName, &NSChild);
            }
        }
    }

    return rc;
}       //FindNSObj

/***LP  AMLIDbgLC - List all contexts
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgLC(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        ULONG_PTR uipHead = READSYMULONGPTR("gplistCtxtHead");

        if (uipHead != 0)
        {
            ULONG_PTR uipCurrentCtxt = READMEMULONGPTR(
                                                FIELDADDROF("gReadyQueue",
                                                            CTXTQ,
                                                            pctxtCurrent));
            ULONG_PTR uipCurrentThread = READMEMULONGPTR(
                                                FIELDADDROF("gReadyQueue",
                                                            CTXTQ,
                                                            pkthCurrent));
            ULONG_PTR uip, uipNext;
            CTXT ctxt;

            for (uip = uipHead - FIELD_OFFSET(CTXT, listCtxt);
                 (uip != 0) && (rc == DBGERR_NONE);
                 uip = uipNext)
            {
                if (ReadMemory(uip, &ctxt, sizeof(ctxt), NULL))
                {
                    ASSERT(ctxt.dwSig == SIG_CTXT);
                    uipNext = ((ULONG_PTR)ctxt.listCtxt.plistNext == uipHead)?
                                        0:
                                        (ULONG_PTR)ctxt.listCtxt.plistNext -
                                        FIELD_OFFSET(CTXT, listCtxt);

                    PRINTF("%cCtxt=%08x, ThID=%08x, Flgs=%c%c%c%c%c%c%c%c%c, pbOp=%08x, Obj=%s\n",
                           (uip == uipCurrentCtxt)? '*': ' ',
                           uip,
                           (uip == uipCurrentCtxt)? uipCurrentThread: 0,
                           (ctxt.dwfCtxt & CTXTF_ASYNC_EVAL)? 'A': '-',
                           (ctxt.dwfCtxt & CTXTF_NEST_EVAL)? 'N': '-',
                           (ctxt.dwfCtxt & CTXTF_IN_READYQ)? 'Q': '-',
                           (ctxt.dwfCtxt & CTXTF_NEED_CALLBACK)? 'C': '-',
                           (ctxt.dwfCtxt & CTXTF_RUNNING)? 'R': '-',
                           (ctxt.dwfCtxt & CTXTF_READY)? 'W': '-',
                           (ctxt.dwfCtxt & CTXTF_TIMEOUT)? 'T': '-',
                           (ctxt.dwfCtxt & CTXTF_TIMER_DISPATCH)? 'D': '-',
                           (ctxt.dwfCtxt & CTXTF_TIMER_PENDING)? 'P': '-',
                           ctxt.pbOp, GetObjAddrPath((ULONG_PTR)ctxt.pnsObj));
                }
                else
                {
                    DBG_ERROR(("failed to read ctxt header at %x", uip));
                    rc = DBGERR_CMD_FAILED;
                }
            }
        }
    }
    else
    {
        DBG_ERROR(("invalid LC command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgLC

/***LP  AMLIDbgLN - Display nearest symbol
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgLN(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                     ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uip;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        if ((rc = EvalExpr(pszArg, &uip, NULL, NULL, NULL)) == DBGERR_NONE)
        {
            PrintSymbol(uip);
        }
    }
    else if (dwArgNum == 0)
    {
        uip = READMEMULONGPTR(FIELDADDROF("gReadyQueue", CTXTQ, pctxtCurrent));

        if (uip != 0)
        {
            PrintSymbol(READMEMULONGPTR(uip + FIELD_OFFSET(CTXT, pbOp)));
        }
        else
        {
            DBG_ERROR(("no current context"));
            rc = DBGERR_CMD_FAILED;
        }
    }

    return rc;
}       //AMLIDbgLN

/***LP  AMLIDbgP - Trace and step over an AML instruction
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgP(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        ULONG_PTR uip = FIELDADDROF("gDebugger", DBGR, dwfDebugger);
        ULONG dwData;

        dwData = READMEMDWORD(uip);
        dwData |= DBGF_STEP_OVER;
        if (!WRITEMEMDWORD(uip, dwData))
        {
            DBG_ERROR(("failed to write debugger flag at %x", uip));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid step command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //DebugStep

/***LP  AMLIDbgR - Dump debugger context
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgR(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uip;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    if (pszArg != NULL)
    {
        if ((rc = EvalExpr(pszArg, &uip, NULL, NULL, NULL)) == DBGERR_NONE)
        {
            rc = DumpCtxt(uip);
        }
    }
    else if (dwArgNum == 0)
    {
        rc = DumpCtxt(0);
    }

    return rc;
}       //AMLIDbgR

/***LP  DumpCtxt - Dump context
 *
 *  ENTRY
 *      uipCtxt - Ctxt address
 *
 *  EXIT
 *      None
 */

LONG LOCAL DumpCtxt(ULONG_PTR uipCtxt)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uipCurrentCtxt = READMEMULONGPTR(FIELDADDROF("gReadyQueue",
                                                           CTXTQ,
                                                           pctxtCurrent));
  #ifdef DEBUG
    ULONG_PTR uipCurrentThread = READMEMULONGPTR(FIELDADDROF("gReadyQueue",
                                                             CTXTQ,
                                                             pkthCurrent));
  #endif
    CTXT Ctxt;

    if (uipCtxt == 0)
    {
        uipCtxt = uipCurrentCtxt;
    }

    if (uipCtxt == 0)
    {
        DBG_ERROR(("no current context"));
        rc = DBGERR_CMD_FAILED;
    }
    else if (!ReadMemory(uipCtxt, &Ctxt, sizeof(Ctxt), NULL))
    {
        DBG_ERROR(("failed to read context header at %x", uipCtxt));
        rc = DBGERR_CMD_FAILED;
    }
    else if (Ctxt.dwSig != SIG_CTXT)
    {
        DBG_ERROR(("invalid context block at %x", uipCtxt));
        rc = DBGERR_CMD_FAILED;
    }
    else
    {
      #ifdef DEBUG
        PRINTF("\nContext=%08x%c, Queue=%08x, ResList=%08x\n",
               uipCtxt,
               (uipCtxt == uipCurrentCtxt)? '*': ' ',
               Ctxt.pplistCtxtQueue, Ctxt.plistResources);
        PRINTF("ThreadID=%08x, Flags=%08x, pbOp=",
               (uipCtxt == uipCurrentCtxt)? uipCurrentThread: 0,
               Ctxt.dwfCtxt);
        PrintSymbol((ULONG_PTR)Ctxt.pbOp);
        PRINTF("\n");
        PRINTF("StackTop=%08x, UsedStackSize=%d bytes, FreeStackSize=%d bytes\n",
               Ctxt.LocalHeap.pbHeapEnd,
               Ctxt.pbCtxtEnd - Ctxt.LocalHeap.pbHeapEnd,
               Ctxt.LocalHeap.pbHeapEnd - Ctxt.LocalHeap.pbHeapTop);
        PRINTF("LocalHeap=%08x, CurrentHeap=%08x, UsedHeapSize=%d bytes\n",
               uipCtxt + FIELD_OFFSET(CTXT, LocalHeap),
               Ctxt.pheapCurrent,
               Ctxt.LocalHeap.pbHeapTop -
               (uipCtxt + FIELD_OFFSET(CTXT, LocalHeap)));
        PRINTF("Object=%s, Scope=%s, ObjectOwner=%x, SyncLevel=%x\n",
               Ctxt.pnsObj? GetObjAddrPath((ULONG_PTR)Ctxt.pnsObj): "<none>",
               Ctxt.pnsScope? GetObjAddrPath((ULONG_PTR)Ctxt.pnsScope): "<none>",
               Ctxt.powner, Ctxt.dwSyncLevel);
        PRINTF("AsyncCallBack=%x, CallBackData=%x, CallBackContext=%x\n",
               Ctxt.pfnAsyncCallBack, Ctxt.pdataCallBack,
               Ctxt.pvContext);
      #endif
        if (Ctxt.pcall != NULL)
        {
            CALL Call;

            if (!ReadMemory((ULONG_PTR)Ctxt.pcall, &Call, sizeof(Call), NULL))
            {
                DBG_ERROR(("failed to read call frame at %x", Ctxt.pcall));
                rc = DBGERR_CMD_FAILED;
            }
            else
            {
                int i;

                PRINTF("\nMethodObject=%s\n",
                       Call.pnsMethod?
                           GetObjAddrPath((ULONG_PTR)Call.pnsMethod): "<none>");

                if (Call.icArgs > 0)
                {
                    POBJDATA pArgs = LocalAlloc(LPTR,
                                                sizeof(OBJDATA)*
                                                Call.icArgs);

                    if (pArgs == NULL)
                    {
                        DBG_ERROR(("failed to allocate arguemnt objects (size=%d)",
                                   sizeof(OBJDATA)*Call.icArgs));
                        rc = DBGERR_CMD_FAILED;
                    }
                    else
                    {
                        if (ReadMemory((ULONG_PTR)Call.pdataArgs,
                                       pArgs,
                                       sizeof(OBJDATA)*Call.icArgs,
                                       NULL))
                        {
                            for (i = 0; i < Call.icArgs; ++i)
                            {
                                PRINTF("%08x: Arg%d=",
                                       Call.pdataArgs +
                                       sizeof(OBJDATA)*i,
                                       i);
                                DumpObject(&pArgs[i], NULL, 0);
                            }
                        }
                        else
                        {
                            DBG_ERROR(("failed to read arguemnt objects at %x",
                                       Call.pdataArgs));
                            rc = DBGERR_CMD_FAILED;
                        }
                        LocalFree(pArgs);
                    }
                }

                for (i = 0; (rc == DBGERR_NONE) && (i < MAX_NUM_LOCALS); ++i)
                {
                    PRINTF("%08x: Local%d=",
                           Ctxt.pcall + FIELD_OFFSET(CALL, Locals) +
                           sizeof(OBJDATA)*i,
                           i);
                    DumpObject(&Call.Locals[i], NULL, 0);
                }
            }
        }

        if (rc == DBGERR_NONE)
        {
            PRINTF("%08x: RetObj=", uipCtxt + FIELD_OFFSET(CTXT, Result));
            DumpObject(&Ctxt.Result, NULL, 0);
        }

        if ((rc == DBGERR_NONE) && (Ctxt.plistResources != NULL))
        {
            ULONG_PTR uip, uipNext;
            RESOURCE Res;

            PRINTF("\nResources Owned:\n");
            for (uip = (ULONG_PTR)Ctxt.plistResources -
                       FIELD_OFFSET(RESOURCE, list);
                 uip != 0; uip = uipNext)
            {
                if (ReadMemory(uip, &Res, sizeof(Res), NULL))
                {
                    uipNext = (Res.list.plistNext != Ctxt.plistResources)?
                              (ULONG_PTR)Res.list.plistNext -
                              FIELD_OFFSET(RESOURCE, list): 0;
                    ASSERT(uipCtxt == (ULONG_PTR)Res.pctxtOwner);
                    PRINTF("  ResType=%s, ResObj=%x\n",
                           Res.dwResType == RESTYPE_MUTEX? "Mutex": "Unknown",
                           Res.pvResObj);
                }
                else
                {
                    DBG_ERROR(("failed to read resource object at %x", uip));
                    rc = DBGERR_CMD_FAILED;
                }
            }
        }

        if (rc == DBGERR_NONE)
        {
            ULONG_PTR uipbOp = (ULONG_PTR)Ctxt.pbOp;
            ULONG_PTR uipns = 0;
            ULONG dwOffset = 0;

            if (uipbOp == 0)
            {
                if (Ctxt.pnsObj != NULL)
                {
                    uipns = (ULONG_PTR)Ctxt.pnsObj;
                    dwOffset = 0;
                }
            }
            else if (!FindObjSymbol(uipbOp, &uipns, &dwOffset))
            {
                DBG_ERROR(("failed to find symbol at %x", Ctxt.pbOp));
                rc = DBGERR_CMD_FAILED;
            }

            if ((rc == DBGERR_NONE) && (uipns != 0))
            {
                NSOBJ NSObj;
                PMETHODOBJ pm;

                if (!ReadMemory(uipns, &NSObj, sizeof(NSObj), NULL))
                {
                    DBG_ERROR(("failed to read NameSpace object at %x", uipns));
                    rc = DBGERR_CMD_FAILED;
                }
                else if (NSObj.ObjData.dwDataType == OBJTYPE_METHOD)
                {
                    if ((pm = GetObjBuff(&NSObj.ObjData)) == NULL)
                    {
                        DBG_ERROR(("failed to read method object at %x",
                                   NSObj.ObjData.pbDataBuff));
                        rc = DBGERR_CMD_FAILED;
                    }
                    else
                    {
                        PUCHAR pbOp = &pm->abCodeBuff[dwOffset];

                        if (uipbOp == 0)
                        {
                            uipbOp = (ULONG_PTR)NSObj.ObjData.pbDataBuff +
                                     FIELD_OFFSET(METHODOBJ, abCodeBuff);
                        }
                        PRINTF("\nNext AML Pointer: ");
                        PrintSymbol(uipbOp);
                        PRINTF("\n");
                        rc = UnAsmScope(&pbOp,
                                        (PUCHAR)pm + NSObj.ObjData.dwDataLen,
                                        uipbOp,
                                        &NSObj,
                                        0,
                                        1);
                        PRINTF("\n");
                        LocalFree(pm);
                    }
                }
            }
        }
    }

    return rc;
}       //DumpCtxt

/***LP  AMLIDbgSet - Set debugger options
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgSet(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                      ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uip1, uip2;
    ULONG dwData1, dwData2;

    DEREF(pArg);
    DEREF(dwNonSWArgs);

    uip1 = FIELDADDROF("gDebugger", DBGR, dwfDebugger);
    uip2 = ADDROF("gdwfAMLIInit");


    dwData1 = READMEMDWORD(uip1);
    dwData2 = READMEMDWORD(uip2);

    if ((pszArg == NULL) && (dwArgNum == 0))
    {
        PRINTF("AMLTrace        =%s\n",
               (dwData1 & DBGF_AMLTRACE_ON)? "on": "off");
        PRINTF("AMLDebugSpew    =%s\n",
               (dwData1 & DBGF_DEBUG_SPEW_ON)? "on": "off");
        PRINTF("LoadDDBBreak    =%s\n",
               (dwData2 & AMLIIF_LOADDDB_BREAK)? "on": "off");
        PRINTF("ErrorBreak      =%s\n",
               (dwData1 & DBGF_ERRBREAK_ON)? "on": "off");
        PRINTF("VerboseMode     =%s\n",
               (dwData1 & DBGF_VERBOSE_ON)? "on": "off");
        PRINTF("LogEvent        =%s\n",
               (dwData1 & DBGF_LOGEVENT_ON)? "on": "off");
        PRINTF("LogSize         =%d\n",
               READMEMDWORD(FIELDADDROF("gDebugger", DBGR, dwLogSize)));
    }
    else
    {
        dwData1 |= dwfDebuggerON;
        dwData1 &= ~dwfDebuggerOFF;
        dwData2 |= dwfAMLIInitON;
        dwData2 &= ~dwfAMLIInitOFF;

        if (!WRITEMEMDWORD(uip1, dwData1))
        {
            DBG_ERROR(("failed to write debugger flags at %x", uip1));
            rc = DBGERR_CMD_FAILED;
        }
        else if (!WRITEMEMDWORD(uip2, dwData2))
        {
            DBG_ERROR(("failed to write init flags at %x", uip2));
            rc = DBGERR_CMD_FAILED;
        }

        dwfDebuggerON = dwfDebuggerOFF = 0;
        dwfAMLIInitON = dwfAMLIInitOFF = 0;

        //
        // Check to see if debug spew needs to be turned on. Turn on if needed.
        //
        if(dwData1 & DBGF_DEBUG_SPEW_ON)
        {
            rc = AMLITraceEnable(TRUE);
        }
        else
        {
            rc = AMLITraceEnable(FALSE);
        }

    }

    return rc;
}       //AMLIDbgSet

/***LP  AMLIDbgT - Single-step an AML instruction
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AMLIDbgT(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if (pszArg == NULL)
    {
        ULONG_PTR uip = FIELDADDROF("gDebugger", DBGR, dwfDebugger);
        ULONG dwData;

        dwData = READMEMDWORD(uip);
        dwData |= DBGF_SINGLE_STEP;
        if (!WRITEMEMDWORD(uip, dwData))
        {
            DBG_ERROR(("failed to write debugger flag at %x", uip));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        DBG_ERROR(("invalid trace command"));
        rc = DBGERR_INVALID_CMD;
    }

    return rc;
}       //AMLIDbgT

/***LP  AMLIDbgU - Unassemble AML code
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */
LONG LOCAL AMLIDbgU(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                    ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    static ULONG_PTR uipbOp = 0;
    static PUCHAR pbBuff = NULL;
    static ULONG dwBuffOffset = 0, dwBuffSize = 0;
    static ULONG_PTR uipns = 0;
    static NSOBJ NSObj = {0};

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);
    //
    // User specified name space path or memory address
    //
    if (pszArg != NULL)
    {
        uipbOp = 0;
        if (pbBuff != NULL)
        {
            LocalFree(pbBuff);
            pbBuff = NULL;
            dwBuffSize = 0;
            uipns = 0;
        }
        rc = EvalExpr(pszArg, &uipbOp, NULL, NULL, NULL);
    }
    else
    {
        if (uipbOp == 0)
        {
            ULONG_PTR uipCurrentCtxt = READMEMULONGPTR(
                                        FIELDADDROF("gReadyQueue",
                                                    CTXTQ,
                                                    pctxtCurrent));

            ASSERT(pbBuff == NULL);
            if (uipCurrentCtxt != 0)
            {
                uipbOp = READMEMULONGPTR(uipCurrentCtxt +
                                         FIELD_OFFSET(CTXT, pbOp));
                if (uipbOp == 0)
                {
                    uipns = READMEMULONGPTR(uipCurrentCtxt +
                                            FIELD_OFFSET(CTXT, pnsObj));
                    if ((uipns != 0) &&
                        ReadMemory(uipns, &NSObj, sizeof(NSObj), NULL) &&
                        (NSObj.ObjData.dwDataType == OBJTYPE_METHOD))
                    {
                        uipbOp = (ULONG_PTR)NSObj.ObjData.pbDataBuff +
                                 FIELD_OFFSET(METHODOBJ, abCodeBuff);
                    }
                }
            }
        }

        if (uipbOp == 0)
        {
            DBG_ERROR(("invalid AML code address %x", uipbOp));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            BOOLEAN fContinueLast = FALSE;

            if (pbBuff == NULL)
            {
                ULONG dwOffset = 0;

                if (uipns == 0)
                {
                    if (FindObjSymbol(uipbOp, &uipns, &dwOffset))
                    {
                        if (!ReadMemory(uipns, &NSObj, sizeof(NSObj), NULL))
                        {
                            DBG_ERROR(("failed to read NameSpace object at %x",
                                       uipns));
                            rc = DBGERR_CMD_FAILED;
                        }
                    }
                }

                if (rc == DBGERR_NONE)
                {
                    if (uipns != 0)
                    {
                        dwBuffSize = NSObj.ObjData.dwDataLen -
                                     FIELD_OFFSET(METHODOBJ, abCodeBuff) -
                                     dwOffset;
                    }
                    else
                    {
                        //
                        // The uipbOp is not associated with any method object,
                        // so we must be unassembling some code in the middle
                        // of a DDB load.  Set code length to 4K.
                        //
                        dwBuffSize = 4096;
                    }

                    dwBuffOffset = 0;
                    if ((pbBuff = LocalAlloc(LPTR, dwBuffSize)) == NULL)
                    {
                        DBG_ERROR(("failed to allocate code buffer (size=%d)",
                                   dwBuffSize));
                        rc = DBGERR_CMD_FAILED;
                    }
                    else if (!ReadMemory(uipbOp, pbBuff, dwBuffSize, NULL))
                    {
                        DBG_ERROR(("failed to read AML code at %x (size=%d)",
                                   uipbOp, dwBuffSize));
                        rc = DBGERR_CMD_FAILED;
                    }
                }
            }
            else
            {
                fContinueLast = TRUE;
            }

            if (rc == DBGERR_NONE)
            {
                PUCHAR pbOp = pbBuff + dwBuffOffset;

                rc = UnAsmScope(&pbOp,
                                pbBuff + dwBuffSize,
                                uipbOp + dwBuffOffset,
                                uipns? &NSObj: NULL,
                                fContinueLast? -1: 0,
                                0);

                PRINTF("\n");
                dwBuffOffset = (ULONG)(pbOp - pbBuff);
            }
        }
    }

    return rc;
}       //AMLIDbgU

/***LP  GetObjectPath - get object namespace path
 *
 *  ENTRY
 *      pns -> object
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjectPath(PNSOBJ pns)
{
    static char szPath[MAX_NAME_LEN + 1] = {0};
    NSOBJ NSParent;
    int i;

    if (pns != NULL)
    {
        if (pns->pnsParent == NULL)
        {
            STRCPY(szPath, "\\");
        }
        else if (ReadMemory((ULONG_PTR)pns->pnsParent,
                            &NSParent,
                            sizeof(NSParent),
                            NULL))
        {
            GetObjectPath(&NSParent);
            if (NSParent.pnsParent != NULL)
            {
                STRCAT(szPath, ".");
            }
            STRCATN(szPath, (PSZ)&pns->dwNameSeg, sizeof(NAMESEG));
        }

        for (i = STRLEN(szPath) - 1; i >= 0; --i)
        {
            if (szPath[i] == '_')
                szPath[i] = '\0';
            else
                break;
        }
    }
    else
    {
        szPath[0] = '\0';
    }

    return szPath;
}       //GetObjectPath

/***LP  GetObjAddrPath - get object namespace path
 *
 *  ENTRY
 *      uipns - object address
 *
 *  EXIT
 *      returns name space path
 */

PSZ LOCAL GetObjAddrPath(ULONG_PTR uipns)
{
    PSZ psz = NULL;
    NSOBJ NSObj;

    if (uipns == 0)
    {
        psz = "<null>";
    }
    else if (ReadMemory(uipns, &NSObj, sizeof(NSObj), NULL))
    {
        psz = GetObjectPath(&NSObj);
    }
    else
    {
        DBG_ERROR(("failed to read NameSpace object at %x", uipns));
    }

    return psz;
}       //GetObjAddrPath

/***LP  DumpObject - Dump object info.
 *
 *  ENTRY
 *      pdata -> data
 *      pszName -> object name
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      If iLevel is negative, no indentation and newline are printed.
 */

VOID LOCAL DumpObject(POBJDATA pdata, PSZ pszName, int iLevel)
{
    BOOLEAN fPrintNewLine = (BOOLEAN)(iLevel >= 0);
    int i;
    char szName1[sizeof(NAMESEG) + 1],
         szName2[sizeof(NAMESEG) + 1];

    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }

    if (pszName == NULL)
    {
        pszName = "";
    }

    switch (pdata->dwDataType)
    {
        case OBJTYPE_UNKNOWN:
            PRINTF("Unknown(%s)", pszName);
            break;

        case OBJTYPE_INTDATA:
            PRINTF("Integer(%s:Value=0x%08x[%d])",
                   pszName, pdata->uipDataValue, pdata->uipDataValue);
            break;

        case OBJTYPE_STRDATA:
        {
            PSZ psz = (PSZ)GetObjBuff(pdata);

            PRINTF("String(%s:Str=\"%s\")", pszName, psz);
            LocalFree(psz);
            break;
        }
        case OBJTYPE_BUFFDATA:
        {
            PUCHAR pbData = (PUCHAR)GetObjBuff(pdata);

            PRINTF("Buffer(%s:Ptr=%x,Len=%d)",
                   pszName, pdata->pbDataBuff, pdata->dwDataLen);
            PrintBuffData(pbData, pdata->dwDataLen);
            LocalFree(pbData);
            break;
        }
        case OBJTYPE_PKGDATA:
        {
            PPACKAGEOBJ ppkg = (PPACKAGEOBJ)GetObjBuff(pdata);

            PRINTF("Package(%s:NumElements=%d){", pszName, ppkg->dwcElements);

            if (fPrintNewLine)
            {
                PRINTF("\n");
            }

            for (i = 0; i < (int)ppkg->dwcElements; ++i)
            {
                DumpObject(&ppkg->adata[i],
                           NULL,
                           fPrintNewLine? iLevel + 1: -1);

                if (!fPrintNewLine && (i < (int)ppkg->dwcElements))
                {
                    PRINTF(",");
                }
            }

            for (i = 0; i < iLevel; ++i)
            {
                PRINTF("| ");
            }

            PRINTF("}");
            LocalFree(ppkg);
            break;
        }
        case OBJTYPE_FIELDUNIT:
        {
            PFIELDUNITOBJ pfu = (PFIELDUNITOBJ)GetObjBuff(pdata);

            PRINTF("FieldUnit(%s:FieldParent=%x,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                   pszName,
                   pfu->pnsFieldParent,
                   pfu->FieldDesc.dwByteOffset,
                   pfu->FieldDesc.dwStartBitPos,
                   pfu->FieldDesc.dwNumBits,
                   pfu->FieldDesc.dwFieldFlags);
            LocalFree(pfu);
            break;
        }
        case OBJTYPE_DEVICE:
            PRINTF("Device(%s)", pszName);
            break;

        case OBJTYPE_EVENT:
            PRINTF("Event(%s:pKEvent=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_METHOD:
        {
            PMETHODOBJ pm = (PMETHODOBJ)GetObjBuff(pdata);

            PRINTF("Method(%s:Flags=0x%x,CodeBuff=%x,Len=%d)",
                   pszName, pm->bMethodFlags, pm->abCodeBuff,
                   pdata->dwDataLen - FIELD_OFFSET(METHODOBJ, abCodeBuff));
            LocalFree(pm);
            break;
        }
        case OBJTYPE_MUTEX:
            PRINTF("Mutex(%s:pKMutex=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_OPREGION:
        {
            POPREGIONOBJ pop = (POPREGIONOBJ)GetObjBuff(pdata);

            PRINTF("OpRegion(%s:RegionSpace=%s,Offset=0x%x,Len=%d)",
                   pszName,
                   GetRegionSpaceName(pop->bRegionSpace),
                   pop->uipOffset,
                   pop->dwLen);
            LocalFree(pop);
            break;
        }
        case OBJTYPE_POWERRES:
        {
            PPOWERRESOBJ ppwres = (PPOWERRESOBJ)GetObjBuff(pdata);

            PRINTF("PowerResource(%s:SystemLevel=0x%x,ResOrder=%d)",
                   pszName, ppwres->bSystemLevel, ppwres->bResOrder);
            LocalFree(ppwres);
            break;
        }
        case OBJTYPE_PROCESSOR:
        {
            PPROCESSOROBJ pproc = (PPROCESSOROBJ)GetObjBuff(pdata);

            PRINTF("Processor(%s:ApicID=0x%x,PBlk=0x%x,PBlkLen=%d)",
                   pszName,
                   pproc->bApicID,
                   pproc->dwPBlk,
                   pproc->dwPBlkLen);
            LocalFree(pproc);
            break;
        }
        case OBJTYPE_THERMALZONE:
            PRINTF("ThermalZone(%s)", pszName);
            break;

        case OBJTYPE_BUFFFIELD:
        {
            PBUFFFIELDOBJ pbf = (PBUFFFIELDOBJ)GetObjBuff(pdata);

            PRINTF("BufferField(%s:Ptr=%x,Len=%d,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                   pszName, pbf->pbDataBuff, pbf->dwBuffLen,
                   pbf->FieldDesc.dwByteOffset, pbf->FieldDesc.dwStartBitPos,
                   pbf->FieldDesc.dwNumBits, pbf->FieldDesc.dwFieldFlags);
            LocalFree(pbf);
            break;
        }
        case OBJTYPE_DDBHANDLE:
            PRINTF("DDBHandle(%s:Handle=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_OBJALIAS:
        {
            NSOBJ NSObj;
            ULONG dwDataType;

            if (ReadMemory((ULONG_PTR)pdata->pnsAlias,
                           &NSObj,
                           sizeof(NSObj),
                           NULL))
            {
                dwDataType = NSObj.ObjData.dwDataType;
            }
            else
            {
                dwDataType = OBJTYPE_UNKNOWN;
            }
            PRINTF("ObjectAlias(%s:Alias=%s,Type=%s)",
                   pszName, GetObjAddrPath((ULONG_PTR)pdata->pnsAlias),
                   GetObjectTypeName(dwDataType));
            break;
        }
        case OBJTYPE_DATAALIAS:
        {
            OBJDATA Obj;

            PRINTF("DataAlias(%s:Link=%x)", pszName, pdata->pdataAlias);
            if (fPrintNewLine &&
                ReadMemory((ULONG_PTR)pdata->pdataAlias,
                           &Obj,
                           sizeof(Obj),
                           NULL))
            {
                DumpObject(&Obj, NULL, iLevel + 1);
                fPrintNewLine = FALSE;
            }
            break;
        }
        case OBJTYPE_BANKFIELD:
        {
            PBANKFIELDOBJ pbf = (PBANKFIELDOBJ)GetObjBuff(pdata);
            NSOBJ NSObj;

            if (ReadMemory((ULONG_PTR)pbf->pnsBase,
                           &NSObj,
                           sizeof(NSObj),
                           NULL))
            {
                STRCPYN(szName1, (PSZ)&NSObj.dwNameSeg, sizeof(NAMESEG));
            }
            else
            {
                szName1[0] = '\0';
            }

            if (ReadMemory((ULONG_PTR)pbf->pnsBank,
                           &NSObj,
                           sizeof(NSObj),
                           NULL))
            {
                STRCPYN(szName2, (PSZ)&NSObj.dwNameSeg, sizeof(NAMESEG));
            }
            else
            {
                szName2[0] = '\0';
            }

            PRINTF("BankField(%s:Base=%s,BankName=%s,BankValue=0x%x)",
                   pszName, szName1, szName2, pbf->dwBankValue);
            LocalFree(pbf);
            break;
        }
        case OBJTYPE_FIELD:
        {
            PFIELDOBJ pf = (PFIELDOBJ)GetObjBuff(pdata);
            NSOBJ NSObj;

            if (ReadMemory((ULONG_PTR)pf->pnsBase,
                           &NSObj,
                           sizeof(NSObj),
                           NULL))
            {
                STRCPYN(szName1, (PSZ)&NSObj.dwNameSeg, sizeof(NAMESEG));
            }
            else
            {
                szName1[0] = '\0';
            }
            PRINTF("Field(%s:Base=%s)", pszName, szName1);
            LocalFree(pf);
            break;
        }
        case OBJTYPE_INDEXFIELD:
        {
            PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)GetObjBuff(pdata);
            NSOBJ NSObj;

            if (ReadMemory((ULONG_PTR)pif->pnsIndex,
                           &NSObj,
                           sizeof(NSObj),
                           NULL))
            {
                STRCPYN(szName1, (PSZ)&NSObj.dwNameSeg, sizeof(NAMESEG));
            }
            else
            {
                szName1[0] = '\0';
            }

            if (ReadMemory((ULONG_PTR)pif->pnsData,
                           &NSObj,
                           sizeof(NSObj),
                           NULL))
            {
                STRCPYN(szName2, (PSZ)&NSObj.dwNameSeg, sizeof(NAMESEG));
            }
            else
            {
                szName2[0] = '\0';
            }

            PRINTF("IndexField(%s:IndexName=%s,DataName=%s)",
                   pszName, szName1, szName2);
            LocalFree(pif);
            break;
        }
        default:
            DBG_ERROR(("unexpected data object type (type=%x)",
                        pdata->dwDataType));
    }

    if (fPrintNewLine)
    {
        PRINTF("\n");
    }
}       //DumpObject

/***LP  GetObjectTypeName - get object type name
 *
 *  ENTRY
 *      dwObjType - object type
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetObjectTypeName(ULONG dwObjType)
{
    PSZ psz = NULL;
    int i;
    static struct
    {
        ULONG dwObjType;
        PSZ   pszObjTypeName;
    } ObjTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            0,                  NULL
        };

    for (i = 0; ObjTypeTable[i].pszObjTypeName != NULL; ++i)
    {
        if (dwObjType == ObjTypeTable[i].dwObjType)
        {
            psz = ObjTypeTable[i].pszObjTypeName;
            break;
        }
    }

    return psz;
}       //GetObjectTypeName

/***LP  GetRegionSpaceName - get region space name
 *
 *  ENTRY
 *      bRegionSpace - region space
 *
 *  EXIT
 *      return object type name
 */

PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace)
{
    PSZ psz = NULL;
    int i;
    static PSZ pszVendorDefined = "VendorDefined";
    static struct
    {
        UCHAR bRegionSpace;
        PSZ   pszRegionSpaceName;
    } RegionNameTable[] =
        {
            REGSPACE_MEM,       "SystemMemory",
            REGSPACE_IO,        "SystemIO",
            REGSPACE_PCICFG,    "PCIConfigSpace",
            REGSPACE_EC,        "EmbeddedController",
            REGSPACE_SMB,       "SMBus",
            0,                  NULL
        };

    for (i = 0; RegionNameTable[i].pszRegionSpaceName != NULL; ++i)
    {
        if (bRegionSpace == RegionNameTable[i].bRegionSpace)
        {
            psz = RegionNameTable[i].pszRegionSpaceName;
            break;
        }
    }

    if (psz == NULL)
    {
        psz = pszVendorDefined;
    }

    return psz;
}       //GetRegionSpaceName

/***LP  FindObjSymbol - Find nearest object with given address
 *
 *  ENTRY
 *      uipObj - address
 *      puipns -> to hold the nearest object address
 *      pdwOffset - to hold offset from the nearest object
 *
 *  EXIT-SUCCESS
 *      returns TRUE - found a nearest object
 *  EXIT-FAILURE
 *      returns FALSE - cannot found nearest object
 */

BOOLEAN LOCAL FindObjSymbol(ULONG_PTR uipObj, PULONG_PTR puipns,
                            PULONG pdwOffset)
{
    BOOLEAN rc = FALSE;
    ULONG_PTR uip;
    OBJSYM ObjSym;
    NSOBJ NSObj;

    for (uip = READMEMULONGPTR(FIELDADDROF("gDebugger", DBGR, posSymbolList));
         (uip != 0) &&
         ReadMemory(uip, &ObjSym, sizeof(ObjSym), NULL);
         uip = (ULONG_PTR)ObjSym.posNext)
    {
        if (uipObj <= (ULONG_PTR)ObjSym.pbOp)
        {
            if ((uipObj < (ULONG_PTR)ObjSym.pbOp) && (ObjSym.posPrev != NULL))
            {
                uip = (ULONG_PTR)ObjSym.posPrev;
                ReadMemory(uip, &ObjSym, sizeof(ObjSym), NULL);
            }

            if ((uipObj >= (ULONG_PTR)ObjSym.pbOp) &&
                ReadMemory((ULONG_PTR)ObjSym.pnsObj, &NSObj, sizeof(NSObj),
                           NULL) &&
                (uipObj < (ULONG_PTR)NSObj.ObjData.pbDataBuff +
                          NSObj.ObjData.dwDataLen))
            {
                *puipns = (ULONG_PTR)ObjSym.pnsObj;
                *pdwOffset = (ULONG)(uipObj - (ULONG_PTR)ObjSym.pbOp);
                rc = TRUE;
            }
            break;
        }
    }

    return rc;
}       //FindObjSymbol

/***LP  PrintBuffData - Print buffer data
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintBuffData(PUCHAR pb, ULONG dwLen)
{
    int i, j;

    PRINTF("{");
    for (i = j = 0; i < (int)dwLen; ++i)
    {
        if (j == 0)
            PRINTF("\n\t0x%02x", pb[i]);
        else
            PRINTF(",0x%02x", pb[i]);

        j++;
        if (j >= 14)
            j = 0;
    }
    PRINTF("}");
}       //PrintBuffData

/***LP  PrintSymbol - Print the nearest symbol of a given address
 *
 *  ENTRY
 *      uip - address
 *
 *  EXIT
 *      None
 */

VOID LOCAL PrintSymbol(ULONG_PTR uip)
{
    ULONG_PTR uipns;
    ULONG dwOffset;

    PRINTF("%08x", uip);
    if (FindObjSymbol(uip, &uipns, &dwOffset))
    {
        PRINTF(":%s", GetObjAddrPath(uipns));
        if (dwOffset != 0)
        {
            PRINTF("+%x", dwOffset);
        }
    }
}       //PrintSymbol

/***LP  EvalExpr - Parse and evaluate debugger expression
 *
 *  ENTRY
 *      pszArg -> expression argument
 *      puipValue -> to hold the result of expression
 *      pfPhysical -> set to TRUE if the expression is a physical address
 *                    (NULL if don't allow physical address)
 *      puipns -> to hold the pointer of the nearest pns object
 *      pdwOffset -> to hold the offset of the address to the nearest pns object
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */

LONG LOCAL EvalExpr(PSZ pszArg, PULONG_PTR puipValue, BOOLEAN *pfPhysical,
                    PULONG_PTR puipns, PULONG pdwOffset)
{
    LONG rc = DBGERR_NONE;
    ULONG_PTR uipns = 0;
    ULONG dwOffset = 0;
    NSOBJ NSObj;

    if (pfPhysical != NULL)
        *pfPhysical = FALSE;

    if ((pfPhysical != NULL) && (pszArg[0] == '%') && (pszArg[1] == '%'))
    {
        if (IsNumber(&pszArg[2], 16, puipValue))
        {
            *pfPhysical = TRUE;
        }
        else
        {
            DBG_ERROR(("invalid physical address - %s", pszArg));
            rc = DBGERR_INVALID_CMD;
        }
    }
    else if (!IsNumber(pszArg, 16, puipValue))
    {
        STRUPR(pszArg);
        if (GetNSObj(pszArg, NULL, &uipns, &NSObj,
                     NSF_LOCAL_SCOPE | NSF_WARN_NOTFOUND) == DBGERR_NONE)
        {
            if (NSObj.ObjData.dwDataType == OBJTYPE_METHOD)
            {
                *puipValue = (ULONG_PTR)(NSObj.ObjData.pbDataBuff +
                                         FIELD_OFFSET(METHODOBJ, abCodeBuff));
            }
            else
            {
                DBG_ERROR(("object is not a method - %s", pszArg));
                rc = DBGERR_INVALID_CMD;
            }
        }
    }
    else if (FindObjSymbol(*puipValue, &uipns, &dwOffset))
    {
        if (ReadMemory(uipns, &NSObj, sizeof(NSObj), NULL))
        {
            if ((NSObj.ObjData.dwDataType != OBJTYPE_METHOD) ||
                (dwOffset >= NSObj.ObjData.dwDataLen -
                             FIELD_OFFSET(METHODOBJ, abCodeBuff)))
            {
                uipns = 0;
                dwOffset = 0;
            }
        }
        else
        {
            DBG_ERROR(("failed to read NameSpace object at %x", uipns));
            rc = DBGERR_CMD_FAILED;
        }
    }

    if (rc == DBGERR_NONE)
    {
        if (puipns != NULL)
            *puipns = uipns;

        if (pdwOffset != NULL)
            *pdwOffset = dwOffset;
    }

    return rc;
}       //EvalExpr

/***LP  IsNumber - Check if string is a number, if so return the number
 *
 *  ENTRY
 *      pszStr -> string
 *      dwBase - base
 *      puipValue -> to hold the number
 *
 *  EXIT-SUCCESS
 *      returns TRUE - the string is a number
 *  EXIT-FAILURE
 *      returns FALSE - the string is not a number
 */

BOOLEAN LOCAL IsNumber(PSZ pszStr, ULONG dwBase, PULONG_PTR puipValue)
{
    BOOLEAN rc;
    PSZ psz;

    *puipValue = (ULONG_PTR)STRTOUL(pszStr, &psz, dwBase);
    rc = ((psz != pszStr) && (*psz == '\0'))? TRUE: FALSE;

    return rc;
}       //IsNumber

/***LP  AMLITraceEnable - Enable / Disable debug tracing
 *
 *  ENTRY
 *      fEnable -> TRUE to Enable
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_CMD_FAILED
 */
LONG LOCAL AMLITraceEnable(BOOL fEnable)
{
    LONG rc = DBGERR_NONE;
    ULONG dwData;
    ULONG_PTR uip;

    uip = GetExpression("NT!Kd_AMLI_Mask");

    if (!uip)
    {
        PRINTF("AMLITraceEnable: Could not find NT!Kd_AMLI_Mask\n");

    }

    if(fEnable)
    {
        dwData = 0xffffffff;
        if (!WRITEMEMDWORD(uip, dwData))
        {
            DBG_ERROR(("AMLITraceEnable: failed to write kd_amli_mask at %x", uip));
            rc = DBGERR_CMD_FAILED;
        }
    }
    else
    {
        dwData = 0;
        if (!WRITEMEMDWORD(uip, dwData))
        {
            DBG_ERROR(("AMLITraceEnable: failed to write kd_amli_mask at %x", uip));
            rc = DBGERR_CMD_FAILED;
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\build.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

UCHAR       BuildBuffer[2048];


VOID
dumpAcpiBuildListHeader(
    )
/*++

Routine Description:

    This routine displays the top line in the build list dump

Arguments:

    None

Return value:

    None

--*/
{
    dprintf("Request  Wd Cu Nx BuildCon  NsObj    Status   Union   Special\n");
}

VOID
dumpAcpiBuildList(
    IN  PUCHAR  ListName
    )
/*++

    This routine fetects a single Power Device List from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;

    //
    // Handle the queue list
    //
    address = GetExpression( ListName );
    if (!address) {

        dprintf( "dumpAcpiBuildList: could not read %s\n", ListName );

    } else {

        dprintf("%s at %08lx\n", ListName, address );
        status = ReadMemory(
            address,
            &listEntry,
            sizeof(LIST_ENTRY),
            &returnLength
            );
        if (status == FALSE || returnLength != sizeof(LIST_ENTRY)) {

            dprintf(
                "dumpAcpiBuildList: could not read LIST_ENTRY at %p\n",
                address
                );

        } else {

            dumpAcpiBuildListHeader();
            dumpBuildDeviceListEntry(
                &listEntry,
                address,
                0
                );
            dprintf("\n");

        }

    }
}

VOID
dumpAcpiBuildLists(
    VOID
    )
/*++

Routine Description:

    This routine dumps all of the devices lists used by the Build DPC

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;
    ULONG       value;

    status = GetUlongPtr( "ACPI!AcpiDeviceTreeLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiDeviceTreeLock\n");
        return;

    }

    dprintf("ACPI Build Tree Information\n");
    if (address) {

        dprintf("  + ACPI!AcpiDeviceTreeLock is owned");

        //
        // The bits other then the lowest is where the owning thread is
        // located. This function uses the property that -2 is every bit
        // except the least significant one
        //
        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiDeviceTreeLock is not owned\n");

    }

    status = GetUlongPtr( "ACPI!AcpiBuildQueueLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiBuildQueueLock\n");
        return;

    }
    if (address) {

        dprintf("  + ACPI!AcpiBuildQueueLock is owned\n");

        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiBuildQueueLock is not owned\n" );

    }

    status = GetUlong( "ACPI!AcpiBuildWorkDone", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiBuildWorkDone\n");
        return;

    }
    dprintf("  + AcpiBuildWorkDone = %s\n", (value ? "TRUE" : "FALSE" ) );


    status = GetUlong( "ACPI!AcpiBuildDpcRunning", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiBuildDpcRunning\n");
        return;

    }
    dprintf("  + AcpiBuildDpcRunning = %s\n", (value ? "TRUE" : "FALSE" ) );

    dumpAcpiBuildList( "ACPI!AcpiBuildQueueList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildDeviceList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildOperationRegionList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildPowerResourceList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildRunMethodList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildSynchronizationList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildThermalZoneList" );
}

VOID
dumpBuildDeviceListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address,
    IN  ULONG       Verbose
    )
/*++

Routine Description:

    This routine is called to dump a list of devices in one of the queues

Arguments:

    ListEntry   - The head of the list
    Address     - The original address of the list (to see when we looped
                  around

Return Value:

    NONE

--*/
{
    ULONG_PTR displacement;
    ACPI_BUILD_REQUEST  request;
    BOOL                stat;
    PACPI_BUILD_REQUEST requestAddress;
    UCHAR               buffer1[80];
    UCHAR               buffer2[80];
    UCHAR               buffer3[5];
    ULONG               i = 0;
    ULONG               returnLength;

    memset( buffer3, 0, 5);
    memset( buffer2, 0, 80);
    memset( buffer1, 0, 80);

    //
    // Look at the next address
    //
    ListEntry = ListEntry->Flink;

    while (ListEntry != (PLIST_ENTRY) Address) {

        //
        // Crack the listEntry to determine where the powerRequest is
        //
        requestAddress = CONTAINING_RECORD(
            ListEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Read the queued item
        //
        stat = ReadMemory(
            (ULONG_PTR) requestAddress,
            &request,
            sizeof(ACPI_BUILD_REQUEST),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(ACPI_BUILD_REQUEST)) {

            dprintf(
                "dumpBuildDeviceListEntry: Cannot read BuildRequest at %08lx\n",
                requestAddress
                );
            return;

        }

        if (request.CallBack != NULL) {

            GetSymbol(
                request.CallBack,
                buffer1,
                &displacement
                );

        } else {

            buffer1[0] = '\0';

        }
        if (request.Flags & BUILD_REQUEST_VALID_TARGET) {

            GetSymbol(
                request.TargetListEntry,
                buffer2,
                &displacement
                );

        } else {

            buffer2[0] = '\0';

        }

        //
        // Dump the entry for the device
        //
        if (!Verbose) {

            dprintf(
                "%08lx %2x %2x %2x %08lx %08lx %08lx %08lx",
                requestAddress,
                request.WorkDone,
                request.CurrentWorkDone,
                request.NextWorkDone,
                request.BuildContext,
                request.CurrentObject,
                request.Status,
                request.String
                );
            if (request.Flags & BUILD_REQUEST_VALID_TARGET) {

                dprintf(
                    " T: %08lx (%s)",
                    request.TargetListEntry,
                    buffer2
                    );

            } else if (request.Flags & BUILD_REQUEST_DEVICE) {

                 dprintf(
                     " O: %08lx",
                     requestAddress + FIELD_OFFSET( ACPI_BUILD_REQUEST, DeviceRequest.ResultData )
                 );

            } else if (request.Flags & BUILD_REQUEST_RUN) {

                memcpy( buffer3, request.RunRequest.ControlMethodNameAsUchar, 4);
                dprintf(
                    " R: %4s",
                    buffer3
                    );
                if (request.RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

                    dprintf(" Sta");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_MARK_INI) {

                    dprintf(" Ini");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_RECURSIVE) {

                    dprintf(" Rec");

                }

            } else if (request.Flags & BUILD_REQUEST_SYNC) {

                dprintf(
                    " S: %08lx",
                    request.SynchronizeRequest.SynchronizeListEntry
                    );
                if (request.SynchronizeRequest.Flags & SYNC_REQUEST_HAS_METHOD) {

                    memcpy( buffer3, request.SynchronizeRequest.SynchronizeMethodNameAsUchar, 4);
                    dprintf(
                        " %4s",
                        buffer3
                        );
                }

            }

            if (request.CallBack != NULL) {

                dprintf(" C: %s(%08lx)", buffer1, request.CallBackContext);

            }
            dprintf("\n");

        } else {

            dprintf(
                "%08lx\n"
                "  BuildContext:        %08lx\n"
                "  ListEntry:           F - %08lx B - %08lx\n"
                "  CallBack:            %08lx (%s)\n"
                "  CallBackContext:     %08lx\n"
                "  WorkDone:            %lx\n"
                "  CurrentWorkDone:     %lx\n"
                "  NextWorkDone:        %lx\n"
                "  CurrentObject:       %08lx\n"
                "  Status:              %08lx\n"
                "  Flags:               %08lx\n"
                "  Spare:               %08lx\n",
                requestAddress,
                request.BuildContext,
                request.ListEntry.Flink,
                request.ListEntry.Blink,
                request.CallBack,
                buffer1,
                request.CallBackContext,
                request.WorkDone,
                request.CurrentWorkDone,
                request.NextWorkDone,
                request.CurrentObject,
                request.Status,
                request.Flags,
                request.String
                );
            if (request.Flags & BUILD_REQUEST_VALID_TARGET) {

                dprintf(
                    "  TargetListEntry:     %08lx (%s)\n",
                    request.TargetListEntry,
                    buffer2
                    );

            } else if (request.Flags & BUILD_REQUEST_DEVICE) {

                dprintf(
                    "  ResultData:          %08lx\n",
                    requestAddress + FIELD_OFFSET( ACPI_BUILD_REQUEST, DeviceRequest.ResultData )
                    );

            } else if (request.Flags & BUILD_REQUEST_RUN) {

                dprintf(
                    "  ControlMethodName:   %4s\n"
                    "  ControlMethodFlags:  %08lx",
                    request.RunRequest.ControlMethodName
                    );
                if (request.RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

                    dprintf(" Sta");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_MARK_INI) {

                    dprintf(" Ini");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_RECURSIVE) {

                    dprintf(" Rec");

                }
                dprintf("\n");

            } else if (request.Flags & BUILD_REQUEST_SYNC) {

                dprintf(
                    " SynchronizeListEntry: %08lx\n"
                    " MethodName:           %4s\n",
                    request.SynchronizeRequest.SynchronizeListEntry,
                    request.SynchronizeRequest.SynchronizeMethodNameAsUchar
                    );

            }
            dprintf("\n");

        }

        //
        // Point to the next entry
        //
        ListEntry = request.ListEntry.Flink;

    } // while

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\context.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    context.c

Abstract:

    Dumps the AML Context Structure in Human-Readable-Form (HRF)

Author:

    Stephane Plante (splante) 21-Mar-1997

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

VOID
dumpAccessFieldObject(
    IN  ULONG_PTR AccessFieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    ACCFIELDOBJ     fieldObj;
    BOOL            result;
    UCHAR           buffer[80];
    ULONG           returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        AccessFieldAddress,
        &fieldObj,
        sizeof(ACCFIELDOBJ),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(ACCFIELDOBJ) ||
        fieldObj.FrameHdr.dwSig != SIG_ACCFIELDOBJ) {

        dprintf(
            "%sdumpAccessFieldUnit: Coult not read ACCFIELDOBJ %08lx\n",
            buffer,
            AccessFieldAddress
            );
        return;

    }

    dprintf(
        "%sAccess Field Object - %08lx\n"
        "%s  Field Data Object:     %08lx\n",
        buffer, AccessFieldAddress,
        buffer, fieldObj.pdataObj
        );
    if (fieldObj.pdataObj != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpPObject(
            (ULONG_PTR) fieldObj.pdataObj,
            Verbose,
            IndentLevel + 4
            );

    }
    dprintf(
        "%s  Target Buffer:         %08lx - %08lx\n"
        "%s  Access Size:           %08lx\n"
        "%s  # of Accesses:         %08lx\n"
        "%s  Data Mask:             %08lx\n"
        "%s  # of Left Bits:        %08lx\n"
        "%s  # of Right Bits:       %08lx\n"
        "%s  Index to #/Accesses:   %08lx\n"
        "%s  Temp Data:             %08lx\n",
        buffer, fieldObj.pbBuff, fieldObj.pbBuffEnd,
        buffer, fieldObj.dwAccSize,
        buffer, fieldObj.dwcAccesses,
        buffer, fieldObj.dwDataMask,
        buffer, fieldObj.iLBits,
        buffer, fieldObj.iRBits,
        buffer, fieldObj.iAccess,
        buffer, fieldObj.dwData
        );

    dprintf(
        "%s  Field Descriptor:      %p\n",
        buffer,
        ( (ULONG_PTR) &(fieldObj.fd) - (ULONG_PTR) &fieldObj + AccessFieldAddress )
        );
    dumpFieldAddress(
        ( (ULONG_PTR) &(fieldObj.fd) - (ULONG_PTR) &fieldObj + AccessFieldAddress ),
        Verbose,
        IndentLevel + 4
        );

}

VOID
dumpAccessFieldUnit(
    IN  ULONG_PTR AccessFieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    ACCFIELDUNIT    fieldUnit;
    BOOL            result;
    UCHAR           buffer[80];
    ULONG           returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        AccessFieldAddress,
        &fieldUnit,
        sizeof(ACCFIELDUNIT),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(ACCFIELDUNIT) ||
        fieldUnit.FrameHdr.dwSig != SIG_ACCFIELDUNIT) {

        dprintf(
            "%sdumpAccessFieldUnit: Coult not read ACCFIELDUNIT %08lx\n",
            buffer,
            AccessFieldAddress
            );
        return;

    }

    dprintf(
        "%sAccess Field Unit - %08lx\n"
        "%s  Field Data Object:     %08lx\n",
        buffer, AccessFieldAddress,
        buffer, fieldUnit.pdataObj
        );
    if (fieldUnit.pdataObj != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpPObject(
            (ULONG_PTR) fieldUnit.pdataObj,
            Verbose,
            IndentLevel + 4
            );

    }
    dprintf(
        "%s  Source/Result Object:  %08lx\n",
        buffer,
        fieldUnit.pdata
        );
    if (fieldUnit.pdata != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpPObject(
            (ULONG_PTR) fieldUnit.pdata,
            Verbose,
            IndentLevel + 4
            );

    }

}

VOID
dumpAmlTerm(
    IN  ULONG_PTR AmlTermAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    AMLTERM     amlTerm;
    BOOL        result;
    INT         i;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        AmlTermAddress,
        &amlTerm,
        sizeof(AMLTERM),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(AMLTERM)) {

        dprintf(
            "\n%sdumpAmlTerm: Could not read AMLTERM 0x%08lx\n",
            buffer,
            AmlTermAddress
            );
        return;

    }

    if (amlTerm.pszTermName != NULL) {

        result = ReadMemory(
            (ULONG_PTR) amlTerm.pszTermName,
            Buffer,
            32,
            &returnLength
            );
        if (result && returnLength <= 32) {

            Buffer[returnLength] = '\0';
            dprintf(" - %s\n", Buffer );

        }

    }

}

VOID
dumpCall(
    IN  ULONG_PTR CallAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    CALL        call;
    INT         i;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        CallAddress,
        &call,
        sizeof(CALL),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(CALL) ||
        call.FrameHdr.dwSig != SIG_CALL) {

        dprintf(
            "%sdumpCall: Coult not read CALL %08lx\n",
            buffer,
            CallAddress
            );
        return;

    }

    dprintf(
        "%sCall - %08lx\n", buffer, CallAddress
        );

    //
    // Method
    //
    dprintf(
        "%s  Method:                %08lx\n",
        buffer,
        call.pnsMethod
        );
    if (call.pnsMethod != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpNSObject( (ULONG_PTR) call.pnsMethod, Verbose, IndentLevel + 4);

    }

    //
    // Previous Call Frame
    //
    if (Verbose & VERBOSE_CALL) {

        dprintf(
            "%s  Previous Call Frame:   %08lx\n"
            "%s  Previous Owner:        %08lx\n",
            buffer,
            call.pcallPrev,
            buffer,
            call.pownerPrev
            );
        if (call.pownerPrev != NULL && (Verbose & VERBOSE_CONTEXT)) {

            dumpObjectOwner(
                (ULONG_PTR) call.pownerPrev,
                IndentLevel + 2
                );

        }

    }

    if (Verbose & VERBOSE_CONTEXT) {

        //
        // Dump arguments
        //
        dprintf(
            "%s  Arguments (Current):   %1d (%1d)\n",
            buffer,
            call.icArgs,
            call.iArg
            );
        for (i = 0; i < call.icArgs; i++) {

            dprintf(
                "%s  Argument(%d):          %p\n",
                buffer,
                i,
                (ULONG_PTR) (call.pdataArgs + i)
                );
            dumpPObject(
                (ULONG_PTR) (call.pdataArgs + i),
                Verbose,
                IndentLevel + 4
                );

        }

        dprintf(
            "%s  Result:                %08lx\n",
            buffer,
            call.pdataResult
            );
        if (call.pdataResult != NULL) {

            dumpPObject(
                (ULONG_PTR) call.pdataResult,
                Verbose,
                IndentLevel + 4
                );

        }

        if (Verbose & VERBOSE_CALL) {

            dprintf(
                "%s  Locals:\n",
                buffer
                );
            for (i = 0; i < MAX_NUM_LOCALS; i++) {

                dumpObject(
                    (ULONG) ( (PUCHAR) &(call.Locals[i]) - (PUCHAR) &call) +
                    CallAddress,
                    &(call.Locals[i]),
                    Verbose,
                    IndentLevel + 4
                    );

            }

        }

    }

}

VOID
dumpContext(
    IN  ULONG_PTR ContextAddress,
    IN  ULONG   Verbose
    )
/*++

Routine Description:

    This routine dumps a context structure in HRF

Arguments:

    ContextAddress  - Where on the target machine the context is located
    Verbose         - How verbose we should be

Return Value:

    None

--*/
{
    ULONG_PTR   displacement;
    BOOL        result;
    CTXT        context;
    ULONG       returnLength;

    //
    // Read the context from the target
    //
    result = ReadMemory(
        ContextAddress,
        &context,
        sizeof(CTXT),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(CTXT) ) {

        dprintf(
            "dumpContext: could not read CTXT %08lx\n",
            ContextAddress
            );
        return;

    }

    //
    // Is it a context?
    //
    if (context.dwSig != SIG_CTXT) {

        dprintf(
            "dumpContext: Signature (%08lx) != SIG_CTXT (%08lx)\n",
            context.dwSig,
            SIG_CTXT
            );
        return;

    }

    dprintf("Context - %08lx-%08lx\n",ContextAddress, context.pbCtxtEnd );
    if (Verbose & VERBOSE_CONTEXT) {

        dprintf(
            "  AllocatedContextList:    F:%08lx B:%08lx\n"
            "  QueingContextList:       F:%08lx B:%08lx\n"
            "  ContextListHead:         %08lx\n"
            "  SynchronizeLevel:        %08lx\n"
            "  CurrentOpByte:           %08lx\n"
            "  AsyncCallBack:           %08lx",
            context.listCtxt.plistNext, context.listCtxt.plistPrev,
            context.listQueue.plistNext, context.listQueue.plistPrev,
            context.pplistCtxtQueue,
            context.dwSyncLevel,
            context.pbOp,
            context.pfnAsyncCallBack
            );
        if (context.pfnAsyncCallBack != NULL) {

            GetSymbol(
                context.pfnAsyncCallBack,
                Buffer,
                &displacement
                );
            dprintf(" %s",
                Buffer
                );
        }
        dprintf(
            "\n"
            "  AsyncCallBackContext:    %08lx\n"
            "  AsyncDataCallBack:       %08lx\n",
            context.pvContext,
            context.pdataCallBack
            );

    }
    dprintf(
        "  Flags:                   %08lx",
        context.dwfCtxt
        );
    if (context.dwfCtxt & CTXTF_TIMER_PENDING) {

        dprintf(" Timer");

    }
    if (context.dwfCtxt & CTXTF_TIMEOUT) {

        dprintf(" Timeout");

    }
    if (context.dwfCtxt & CTXTF_READY) {

        dprintf(" Ready");

    }
    if (context.dwfCtxt & CTXTF_NEED_CALLBACK) {

        dprintf(" CallBack");

    }
    dprintf("\n");

    dprintf(
        "  NameSpace Object:        %08lx\n",
        context.pnsObj
        );
    if (Verbose & VERBOSE_CONTEXT) {

        dprintf(
            "  NameSpace Scope:         %08lx\n"
            "  NameSpace Owner:         %08lx\n",
            context.pnsScope,
            context.powner
            );
        if (context.powner != NULL) {

            dumpObjectOwner(
                (ULONG_PTR) context.powner,
                2
                );

        }

    }

    dprintf(
        "  Current Call Frame:      %08lx\n",
        context.pcall
        );
    if (context.pcall != NULL) {

        dumpCall(
            (ULONG_PTR) context.pcall,
            (Verbose & ~VERBOSE_CONTEXT),
            4
            );

    }

    dumpStack(
        ContextAddress,
        &context,
        Verbose,
        2
        );

}

VOID
dumpFieldAddress(
    IN  ULONG_PTR FieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    FIELDDESC   fd;
    BOOL        result;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        FieldAddress,
        &fd,
        sizeof(FIELDDESC),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(FIELDDESC) ) {

        dprintf(
            "%sdumpFieldAddress: Coult not read FIELDDESC %08lx\n",
            buffer,
            FieldAddress
            );
        return;

    }

    dprintf(
        "%sField Descriptor - %08lx\n"
        "%s  ByteOffset:          %08lx\n"
        "%s  Start Bit Position:  %08lx\n"
        "%s  Number of Bits:      %08lx\n"
        "%s  Flags:               %08lx\n",
        buffer, FieldAddress,
        buffer, fd.dwByteOffset,
        buffer, fd.dwStartBitPos,
        buffer, fd.dwNumBits,
        buffer, fd.dwFieldFlags
        );
}

VOID
dumpListContexts(
    IN  VOID
    )
/*++

--*/
{
    PLIST   pList;
    PLIST   pListNext;
}

VOID
dumpObjectOwner(
    IN  ULONG_PTR ObjOwnerAddress,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    OBJOWNER    objowner;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        ObjOwnerAddress,
        &objowner,
        sizeof(OBJOWNER),
        &returnLength
        );
    if (result == TRUE &&
        returnLength == sizeof(OBJOWNER) &&
        objowner.dwSig == SIG_OBJOWNER) {

        dprintf(
            "%sObjectOwner - %08lx\n"
            "%s  NameSpaceObject:     %08lx\n"
            "%s  List:                F:%08lx B:%08lx\n",
            buffer,
            ObjOwnerAddress,
            buffer,
            objowner.pnsObjList,
            buffer,
            objowner.list.plistNext,
            objowner.list.plistPrev
            );

    } else {

        dprintf(
            "%sdumpObjectOwner: Could not read OBJOWNER %08lx\n",
            buffer,ObjOwnerAddress
            );

    }
}

VOID
dumpScope(
    IN  ULONG_PTR ScopeAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    SCOPE       scope;
    UCHAR       indent[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';


    result = ReadMemory(
        ScopeAddress,
        &scope,
        sizeof(SCOPE),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(SCOPE) ||
        scope.FrameHdr.dwSig != SIG_SCOPE) {

        dprintf(
            "%sdumpScope: Coult not read SCOPE %08lx\n",
            indent,
            ScopeAddress
            );
        return;

    }

    dprintf(
        "%sScope - %08lx\n",
        indent,
        ScopeAddress
        );

    dprintf(
        "%s  ScopeEnd:              %08lx\n"
        "%s  ReturnAddress:         %08lx\n"
        "%s  Previous Scope:        %08lx\n",
        indent,
        scope.pbOpEnd,
        indent,
        scope.pbOpRet,
        indent,
        scope.pnsPrevScope
        );
    if (Verbose & VERBOSE_CALL) {

        dumpNSObject( (ULONG_PTR) scope.pnsPrevScope, Verbose, IndentLevel + 4);

    }

    dprintf(
        "%s  Previous Owner:        %08lx\n",
        indent,
        scope.pownerPrev
        );
    if (Verbose & VERBOSE_CALL) {

        dumpObjectOwner(
            (ULONG_PTR) scope.pownerPrev,
            IndentLevel + 4
            );

    }

    dprintf(
        "%s  Result Object:         %08lx\n",
        indent,
        scope.pdataResult
        );
    if (scope.pdataResult != NULL && (Verbose & VERBOSE_CALL) ) {

        dumpPObject(
            (ULONG_PTR) scope.pdataResult,
            Verbose,
            IndentLevel + 4
            );

    }
}

VOID
dumpStack(
    IN  ULONG_PTR ContextAddress,
    IN  PCTXT   Context,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    ULONG_PTR   displacement;
    BOOL        result;
    FRAMEHDR    frame;
    PUCHAR      frameAddress;
    UCHAR       indent[80];
    UCHAR       buffer[5];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    buffer[4] = '\0';

    dprintf(
        "%sStack - %p-%08lx (%08lx)\n",
        indent,
        ContextAddress,
        Context->LocalHeap.pbHeapEnd,
        Context->pbCtxtEnd
        );

    //
    // Calculate where the first frame lies
    //
    frameAddress = Context->LocalHeap.pbHeapEnd;
    while (frameAddress < Context->pbCtxtEnd) {

        result = ReadMemory(
            (ULONG_PTR) frameAddress,
            &frame,
            sizeof(FRAMEHDR),
            &returnLength
            );
        if (result != TRUE ||
            returnLength != sizeof(FRAMEHDR)) {

            dprintf(
                "%sdumpStack: could not read FRAMEHDR %08lx\n",
                indent,
                (ULONG_PTR) frameAddress
                );
            return;

        }

        memcpy( buffer, (PUCHAR) &(frame.dwSig), 4 );
        dprintf(
            "%s  %p: %s - (Length %08lx) (Flags %08lx)\n"
            "%s    ParseFunction          %08lx",
            indent,
            (ULONG_PTR) frameAddress,
            buffer,
            frame.dwLen,
            frame.dwfFrame,
            indent,
            frame.pfnParse
            );
        if (frame.pfnParse != NULL) {

            GetSymbol(
                frame.pfnParse,
                Buffer,
                &displacement
                );
            dprintf(" %s",
                Buffer
                );

        }
        dprintf("\n");

        //
        // Do we know how to crack the frame?
        //
        switch(frame.dwSig) {
            case SIG_CALL:

                dumpCall(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;
            case SIG_SCOPE:

                dumpScope(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

            case SIG_TERM:

                dumpTerm(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

            case SIG_ACCFIELDUNIT:

                dumpAccessFieldUnit(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

            case SIG_ACCFIELDOBJ:

                dumpAccessFieldObject(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

        }

        //
        // Make sure that there is some white space present
        //
        dprintf("\n\n");

        //
        // Next11
        //
        frameAddress += frame.dwLen;

    }

}

VOID
dumpTerm(
    IN  ULONG_PTR TermAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    INT         i;
    TERM        term;
    UCHAR       indent[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    result = ReadMemory(
        TermAddress,
        &term,
        sizeof(TERM),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(TERM) ||
        term.FrameHdr.dwSig != SIG_TERM) {

        dprintf(
            "%sdumpTerm: Coult not read TERM %08lx\n",
            indent,
            TermAddress
            );
        return;

    }

    dprintf(
        "%sTerm - %08lx\n",
        indent,
        TermAddress
        );

    dprintf(
        "%s  OpCodeStart:           %08lx\n"
        "%s  OpCodeEnd:             %08lx\n"
        "%s  ScopeEnd:              %08lx\n"
        "%s  NameSpaceObject:       %08lx\n",
        indent,
        term.pbOpTerm,
        indent,
        term.pbOpEnd,
        indent,
        term.pbScopeEnd,
        indent,
        term.pnsObj
        );
    if ( term.pnsObj != NULL && (Verbose & VERBOSE_CALL)) {

        dumpNSObject( (ULONG_PTR) term.pnsObj, Verbose, IndentLevel + 4);

    }

    dprintf(
        "%s  Aml Term:              %08lx",
        indent,
        term.pamlterm
        );
    if (term.pamlterm != NULL) {

        dumpAmlTerm( (ULONG_PTR) term.pamlterm, Verbose, IndentLevel + 4);

    } else {

        dprintf("\n");

    }

    //
    // Dump arguments
    //
    dprintf(
        "%s  Arguments (Current):   %1d (%1d)\n",
        indent,
        term.icArgs,
        term.iArg
        );

    for (i = 0; i < term.icArgs; i++) {

        dprintf(
            "%s  Argument(%d):           %p\n",
            indent,
            i,
            (ULONG_PTR) (term.pdataArgs + i)
            );

        if (Verbose & VERBOSE_CALL) {

            dumpPObject(
                (ULONG_PTR) (term.pdataArgs + i),
                Verbose,
                IndentLevel + 4
                );

        }

    }

    dprintf(
        "%s  Result:                %08lx\n",
        indent,
        term.pdataResult
        );
    if (term.pdataResult != NULL && (Verbose & VERBOSE_CALL) ) {

        dumpPObject(
            (ULONG_PTR) term.pdataResult,
            Verbose,
            IndentLevel + 4
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\dump.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dump.c

Abstract:

    Dumps a block of memory to file

Author:

    Stephane Plante (splante)

Environment:

    User Mode

--*/

#include "pch.h"

VOID
dumpMemory(
    IN  ULONG_PTR Address,
    IN  ULONG   Length,
    IN  PUCHAR  Name
    )
{
    BOOL    b;
    HANDLE  file;
    PUCHAR  buffer;
    ULONG   readLength;

    //
    // Open the file
    //
    file = CreateFile(
        Name,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS,
        0,
        NULL
        );
    if (file == INVALID_HANDLE_VALUE) {

        dprintf("dm: could not open '%s'\n",Name);
        return;

    }

    //
    // Read the bytes from memory
    //
    buffer = LocalAlloc( LPTR, Length );
    if (buffer == NULL) {

        dprintf("dm: could not allocate '0x%x' bytes\n", Length );
        CloseHandle( file );
        return;

    }
    b = ReadMemory(
        Address,
        buffer,
        Length,
        &readLength
        );
    if (!b) {

        dprintf(
            "dm: could not read '0x%x' bytes from '0x%p'\n",
            Length,
            Address
            );
        LocalFree ( buffer );
        CloseHandle( file );
        return;

    }

    //
    // Write the contents of memory to the file
    //
    WriteFile( file, buffer, readLength, &readLength, NULL );

    //
    // Done
    //
    CloseHandle( file );
    LocalFree( buffer );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\flags.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    kdext.h

Abstract:

    Header files for KD extension

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#ifndef _FLAGS_H_
#define _FLAGS_H_

    #define DUMP_FLAG_NO_INDENT         0x000001
    #define DUMP_FLAG_NO_EOL            0x000002
    #define DUMP_FLAG_SINGLE_LINE       0x000004
    #define DUMP_FLAG_TABLE             0x000008
    #define DUMP_FLAG_LONG_NAME         0x000010
    #define DUMP_FLAG_SHORT_NAME        0x000020
    #define DUMP_FLAG_SHOW_BIT          0x000040
    #define DUMP_FLAG_ALREADY_INDENTED  0x000080

    typedef struct _FLAG_RECORD {
        ULONGLONG   Bit;
        PCCHAR      ShortName;
        PCCHAR      LongName;
        PCCHAR      NotShortName;
        PCCHAR      NotLongName;
    } FLAG_RECORD, *PFLAG_RECORD;

    ULONG
    dumpFlags(
        IN  ULONGLONG       Value,
        IN  PFLAG_RECORD    FlagRecords,
        IN  ULONG           FlagRecordSize,
        IN  ULONG           IndentLEvel,
        IN  ULONG           Flags
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\flags.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    flags.c

Abstract:

    dumps the various flags that ACPIKD knows about

Author:

    Stephane Plante

Environment:

    User

Revision History:

--*/

#include "pch.h"

ULONG
dumpFlags(
    IN  ULONGLONG       Value,
    IN  PFLAG_RECORD    FlagRecords,
    IN  ULONG           FlagRecordSize,
    IN  ULONG           IndentLevel,
    IN  ULONG           Flags
    )
/*++

Routine Description:

    This routine dumps the flags specified in Value according to the
    description passing into FlagRecords. The formating is affected by
    the flags field

Arguments:

    Value           - The values
    FlagRecord      - What each bit in the flags means
    FlagRecordSize  - How many flags there are
    IndentLevel     - The base indent level
    Flags           - How we will process the flags

Return Value:

    ULONG   - the number of characters printed. 0 if we printed nothing

--*/
#define STATUS_PRINTED          0x00000001
#define STATUS_INDENTED         0x00000002
#define STATUS_NEED_COUNTING    0x00000004
#define STATUS_COUNTED          0x00000008
{
    PCHAR       string;
    UCHAR       indent[80];
    ULONG       column = IndentLevel;
    ULONG       currentStatus = 0;
    ULONG       fixedSize = 0;
    ULONG       stringSize;
    ULONG       tempCount;
    ULONG       totalCount = 0;
    ULONGLONG   i, j, k;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //dprintf("DumpFlags( %I64x, %x, %x, %x, %x )\n", Value, FlagRecords, FlagRecordSize, IndentLevel, Flags );

    //
    // Do we need to make a table?
    //
    if ( (Flags & DUMP_FLAG_TABLE) &&
        !(Flags & DUMP_FLAG_SINGLE_LINE) ) {

        currentStatus |= STATUS_NEED_COUNTING;

    }
    if ( (Flags & DUMP_FLAG_ALREADY_INDENTED) ) {

        currentStatus |= STATUS_INDENTED;

    }

    //
    // loop over all the steps that we need to do
    //
    while (1) {

        //dprintf("While(1)\n");

        for (i = 0; i < 64; i++) {

            k = (1 << i);
            for (j = 0; j < FlagRecordSize; j++) {

                //dprintf("FlagRecords[%x].Bit = %I64x\n", j, FlagRecords[j].Bit );
                if (!(FlagRecords[j].Bit & Value) ) {

                    //
                    // Are we looking at the correct bit?
                    //
                    if (!(FlagRecords[j].Bit & k) ) {

                        continue;

                    }

                    //
                    // Yes, we are, so pick the not-present values
                    //
                    if ( (Flags & DUMP_FLAG_LONG_NAME && FlagRecords[j].NotLongName == NULL) ||
                         (Flags & DUMP_FLAG_SHORT_NAME && FlagRecords[j].NotShortName == NULL) ) {

                        continue;

                    }

                    if ( (Flags & DUMP_FLAG_LONG_NAME) ) {

                        string = FlagRecords[j].NotLongName;

                    } else if ( (Flags & DUMP_FLAG_SHORT_NAME) ) {

                        string = FlagRecords[j].NotShortName;

                    }

                } else {

                    //
                    // Are we looking at the correct bit?
                    //
                    if (!(FlagRecords[j].Bit & k) ) {

                        continue;

                    }

                    //
                    // Yes, we are, so pick the not-present values
                    //
                    if ( (Flags & DUMP_FLAG_LONG_NAME && FlagRecords[j].LongName == NULL) ||
                         (Flags & DUMP_FLAG_SHORT_NAME && FlagRecords[j].ShortName == NULL) ) {

                        continue;

                    }

                    if ( (Flags & DUMP_FLAG_LONG_NAME) ) {

                        string = FlagRecords[j].LongName;

                    } else if ( (Flags & DUMP_FLAG_SHORT_NAME) ) {

                        string = FlagRecords[j].ShortName;

                    }

                }

                if (currentStatus & STATUS_NEED_COUNTING) {

                    stringSize = strlen( string ) + 1;
                    if (Flags & DUMP_FLAG_SHOW_BIT) {

                        stringSize += (4 + ( (ULONG) i / 4));
                        if ( (i % 4) != 0) {

                            stringSize++;

                        }

                    }
                    if (stringSize > fixedSize) {

                        fixedSize = stringSize;

                    }
                    continue;

                }


                if (currentStatus & STATUS_COUNTED) {

                    stringSize = fixedSize;

                } else {

                    stringSize = strlen( string ) + 1;
                    if (Flags & DUMP_FLAG_SHOW_BIT) {

                        stringSize += (4 + ( (ULONG) i / 4));
                        if ( (i % 4) != 0) {

                            stringSize++;

                        }

                    }

                }

                if (!(Flags & DUMP_FLAG_SINGLE_LINE) ) {

                    if ( (stringSize + column) > 79 ) {

                        dprintf("\n%n", &tempCount);
                        currentStatus &= ~STATUS_INDENTED;
                        totalCount += tempCount;
                        column = 0;

                    }
                }
                if (!(Flags & DUMP_FLAG_NO_INDENT) ) {

                    if (!(currentStatus & STATUS_INDENTED) ) {

                        dprintf("%s%n", indent, &tempCount);
                        currentStatus |= STATUS_INDENTED;
                        totalCount += tempCount;
                        column += IndentLevel;

                    }

                }
                if ( (Flags & DUMP_FLAG_SHOW_BIT) ) {

                    dprintf("%I64x - %n", k, &tempCount);
                    tempCount++; // to account for the fact that we dump
                                 // another space at the end of the string
                    totalCount += tempCount;
                    column += tempCount;

                } else {

                    tempCount = 0;

                }

                //
                // Actually print the string
                //
                dprintf( "%.*s %n", (stringSize - tempCount), string, &tempCount );
                if (Flags & DUMP_FLAG_SHOW_BIT) {

                    dprintf(" ");

                }

                totalCount += tempCount;
                column += tempCount;

            }

        }

        //
        // Change states
        //
        if (currentStatus & STATUS_NEED_COUNTING) {

            currentStatus &= ~STATUS_NEED_COUNTING;
            currentStatus |= STATUS_COUNTED;
            continue;

        }

        if (!(Flags & DUMP_FLAG_NO_EOL) && totalCount != 0) {

            dprintf("\n");
            totalCount++;

        }

        //
        // Done
        //
        break;

    }

    return totalCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\acpi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
UCHAR       Buffer[2048];
PCCHAR      DeviceStateTable[] = {
    "Stopped",
    "Inactive",
    "Started",
    "Removed",
    "SurpriseRemoved",
    "Invalid",
};
PCCHAR      DevicePowerStateTable[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
};
PCCHAR      SystemPowerStateTable[] = {
    "PowerSystemUnspecified",
    "PowerSystemWorking",
    "PowerSystemSleepingS1",
    "PowerSystemSleepingS2",
    "PowerSystemSleepingS3",
    "PowerSystemHibernate",
    "PowerSystemShutdown",
    "PowerSystemMaximum",
};
PCCHAR      SystemPowerActionTable[] = {
    "PowerActionNone",
    "PowerActionReserved",
    "PowerActionSleep",
    "PowerActionHibernate",
    "PowerActionShutdown",
    "PowerActionShutdownReset",
    "PowerActionShutdownOff",
    "PowerActionWarmEject"
};
CCHAR       ReallyShortDevicePowerStateTable[] = {
    'W',
    '0',
    '1',
    '2',
    '3',
    'M',
};
PCCHAR      ShortDevicePowerStateTable[] = {
    "Dw",
    "D0",
    "D1",
    "D2",
    "D3",
    "Dmax",
};
CCHAR       ReallyShortSystemPowerStateTable[] = {
    'W',
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    'M',
};
PCCHAR      ShortSystemPowerStateTable[] = {
    "Sx",
    "S0",
    "S1",
    "S2",
    "S3",
    "S4",
    "S5",
    "SM",
};
PCCHAR     WorkDone[] = {
    "Complete",
    "Pending",
    "Failure",
    "Step 0",
    "Step 1",
    "Step 2",
    "Step 3",
    "Step 4",
    "Step 5",
    "Step 6",
    "Step 7",
    "Step 8",
    "Step 9",
    "Step 10",
    "Step 11",
    "Step 12",
    "Step 13",
    "Step 14",
    "Step 15",
    "Step 16",
    "Step 17",
    "Step 18",
    "Step 19",
    "Step 20",
    "Step 21",
    "Step 22",
    "Step 23",
    "Step 24",
    "Step 25",
    "Step 26",
};

FLAG_RECORD DeviceExtensionButtonEventFlags[] = {
    { 0x00000001, "Pwr", "\"Power Button\"" , NULL, NULL },
    { 0x00000002, "Slp", "\"Sleep Button\"" , NULL, NULL },
    { 0x00000004, "Lid", "\"Lid Switch\"" , NULL, NULL },
    { 0x80000000, "Wake", "\"Wake Capable\"" , NULL, NULL },
};

FLAG_RECORD DeviceExtensionFlags[] = {
    { 0x0000000000000001, "Nev",   "NeverPresent" , NULL, NULL },
    { 0x0000000000000002, "!P" ,   "NotPresent" , NULL, NULL },
    { 0x0000000000000004, "Rmv",   "Removed" , NULL, NULL },
    { 0x0000000000000008, "!F" ,   "NotFound" , NULL, NULL },
    { 0x0000000000000010, "Fdo",   "FunctionalDeviceObject" , NULL, NULL  },
    { 0x0000000000000020, "Pdo",   "PhysicalDeviceObject" , NULL, NULL },
    { 0x0000000000000040, "Fil",   "Filter" , NULL, NULL },
    { 0x0000000000010000, "Wak",   "Wake" , NULL, NULL },
    { 0x0000000000020000, "Raw",   "RawOK" , NULL, NULL },
    { 0x0000000000040000, "But",   "Button" , NULL, NULL },
    { 0x0000000000080000, "PS0",   "AlwaysOn" , NULL, NULL },
    { 0x0000000000100000, "!Fil",  "NeverFilter" , NULL, NULL },
    { 0x0000000000200000, "!Stop", "NeverStop" , NULL, NULL },
    { 0x0000000000400000, "!Off",  "NeverOverrideOff" , NULL, NULL },
    { 0x0000000000800000, "ISA",   "ISABus" , NULL, NULL },
    { 0x0000000001000000, "EIO",   "EIOBus" , NULL, NULL },
    { 0x0000000002000000, "PCI",   "PCIBus" , NULL, NULL },
    { 0x0000000004000000, "Ser",   "SerialPort" , NULL, NULL },
    { 0x0000000008000000, "Tz",    "ThermalZone" , NULL, NULL },
    { 0x0000000010000000, "Lnk",   "LinkNode" , NULL, NULL },
    { 0x0000000020000000, "!UI",   "NoShowInUI" , NULL, NULL },
    { 0x0000000040000000, "!!UI",  "NeverShowInUI" , NULL, NULL },
    { 0x0000000080000000, "D3",    "StartInD3" , NULL, NULL },
    { 0x0000000100000000, "pci",   "PCIDevice" , NULL, NULL },
    { 0x0000000200000000, "PIC",   "ProgrammableInterruptController" , NULL, NULL },
    { 0x0000000400000000, "Dock-", "UnattachedDock" , NULL, NULL },
    { 0x0000100000000000, "Adr",   "HasAddress" , NULL, NULL },
    { 0x0000200000000000, "HID",   "HasHardwareID" , NULL, NULL },
    { 0x0000400000000000, "UID",   "HasUniqueID" , NULL, NULL },
    { 0x0000800000000000, "hid",   "FakeHardwareID" , NULL, NULL },
    { 0x0001000000000000, "uid",   "FakeUniqueID" , NULL, NULL },
    { 0x0002000000000000, "BAD",   "FailedInit" , NULL, NULL },
    { 0x0004000000000000, "SRS",   "Programmable" , NULL, NULL },
    { 0x0008000000000000, "Fake",  "NoAcpiObject" , NULL, NULL },
    { 0x0010000000000000, "Excl",  "Exclusive" , NULL, NULL },
    { 0x0020000000000000, "Ini",   "RanINI" , NULL, NULL },
    { 0x0040000000000000, "Ena",   "Enabled" , "!Ena", "NotEnabled" },
    { 0x0080000000000000, "BAD",   "Failed" , NULL, NULL },
    { 0x0100000000000000, "Pwr",   "AcpiPower" , NULL, NULL },
    { 0x0200000000000000, "Dock",  "DockProfile" , NULL, NULL },
    { 0x0400000000000000, "S->D",  "BuiltPowerTables" , NULL, NULL },
    { 0x0800000000000000, "PME",   "UsesPME" , NULL, NULL },
    { 0x1000000000000000, "!Lid",  "NoLidAction" , NULL, NULL },
};

FLAG_RECORD DeviceExtensionThermalFlags[] = {
    { 0x00000001, "Cooling", "\"Cooling Level\"" , NULL, NULL },
    { 0x00000002, "Temp", "Temp" , NULL, NULL },
    { 0x00000004, "Trip", "\"Trip Points\"" , NULL, NULL },
    { 0x00000008, "Mode", "Mode" , NULL, NULL },
    { 0x00000010, "Init", "Initialize" , NULL, NULL },
    { 0x20000000, "Wait", "\"Wait for Notify\"" , NULL, NULL },
    { 0x40000000, "Busy", "Busy" , NULL, NULL },
    { 0x80000000, "Loop", "\"In Service Loop\"" , NULL, NULL },
};

FLAG_RECORD PM1ControlFlags[] = {
    { 0x0001, "", "SCI_EN" , NULL, NULL },
    { 0x0002, "", "BM_RLD" , NULL, NULL },
    { 0x0004, "", "GBL_RLS" , NULL, NULL },
    { 0x0400, "", "SLP_TYP0" , NULL, NULL },
    { 0x0800, "", "SLP_TYP1" , NULL, NULL },
    { 0x1000, "", "SLP_TYP2" , NULL, NULL  },
    { 0x2000, "", "SLP_EN" , NULL, NULL  },
};

FLAG_RECORD PM1StatusFlags[] = {
    { 0x0001, "", "TMR_STS" , NULL, NULL },
    { 0x0010, "", "BM_STS" , NULL, NULL },
    { 0x0020, "", "GBL_STS" , NULL, NULL },
    { 0x0100, "", "PWRBTN_STS" , NULL, NULL },
    { 0x0200, "", "SLPBTN_STS" , NULL, NULL },
    { 0x0400, "", "RTC_STS" , NULL, NULL },
    { 0x8000, "", "WAK_STS" , NULL, NULL },
};

FLAG_RECORD PM1EnableFlags[] = {
    { 0x0001, "", "TMR_EN" , NULL, NULL },
    { 0x0020, "", "GBL_EN" , NULL, NULL },
    { 0x0100, "", "PWRBTN_EN" , NULL, NULL },
    { 0x0200, "", "SLPBTN_EN" , NULL, NULL },
    { 0x0400, "", "RTC_EN" , NULL, NULL },
};

FLAG_RECORD PowerNodeFlags[] = {
    { 0x00001, "PO", "Present" , NULL, NULL },
    { 0x00002, "Init", "Initialized" , NULL, NULL },
    { 0x00004, "!STA", "\"Status Unknown\"" , NULL, NULL },
    { 0x00010, "On", "On" , "Off", "Off" },
    { 0x00020, "On+", "OverrideOn" , NULL, NULL },
    { 0x00040, "Off-", "OverrideOff" , NULL, NULL },
    { 0x00200, "On++", "AlwaysOn" , NULL, NULL },
    { 0x00400, "Off--", "AlwaysOff" , NULL, NULL },
    { 0x10000, "Fail", "Failed" , NULL, NULL },
    { 0x20000, "Hiber", "HibernatePath" , NULL, NULL },
};

FLAG_RECORD PowerRequestFlags[] = {
    { 0x00001, "Dly",  "Delayed", NULL, NULL },
    { 0x00002, "!Q",   "NoQueue", NULL, NULL },
    { 0x00004, "Lck",  "LockDevice", NULL, NULL },
    { 0x00008, "!Lck", "UnlockDevice", NULL, NULL },
    { 0x00010, "+Hbr", "LockHiber", NULL, NULL },
    { 0x00020, "-Hbr", "UnlockHiber", NULL, NULL },
    { 0x00040, "Can",  "HasCancel", NULL, NULL },
};

VOID
displayAcpiDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    )
/*++

Routine Description:

    This routine is responsible for displaying a device extension

Arguments:

    DeviceExtension - Extension to display
    Address         - Where the extension lives in memory
    Verbose         - How much information to display
    IndentLevel     - How much to tab it over

Return Value:

    None

--*/
{
    BOOL                b;
    DEVICE_POWER_STATE  k;
    DWORD_PTR           displacement;
    IRP_DISPATCH_TABLE  dispatchTable;
    PACPI_POWER_INFO    powerInfo;
    SYSTEM_POWER_STATE  s;
    UCHAR               indent[80];
    ULONG               i,j;
    ULONG               returnLength;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    powerInfo = &(DeviceExtension->PowerInfo);

    //
    // Check signature
    //
    if (DeviceExtension->Signature != ACPI_SIGNATURE) {

        dprintf(
            "%s  Unknown Signature. This does appear to be an "
            "ACPI Extension\n",
            indent
            );
        return;

    }

    //
    // Line #1
    //
    dprintf("%sACPI DeviceExtension - %lx - ",indent, Address);
    displayAcpiDeviceExtensionName( Address );
#if 0
    if (DeviceExtension->Flags & DEV_PROP_HID) {

        if (DeviceExtension->DeviceID != NULL) {

            memset( Buffer, '0', 2048 );
            b = ReadMemory(
                (ULONG_PTR) DeviceExtension->DeviceID,
                Buffer,
                32,
                &returnLength
                );
            if (!b || Buffer[0] == '\0') {

                dprintf(" (%lx)", DeviceExtension->DeviceID );

            } else {

                dprintf(" %s", Buffer );

            }

        } else {

            dprintf( " NULL" );

        }
        if (DeviceExtension->Flags & DEV_PROP_UID) {

            if (DeviceExtension->InstanceID) {

                memset( Buffer, '0', 256 );
                b = ReadMemory(
                    (ULONG_PTR) DeviceExtension->InstanceID,
                    Buffer,
                    256,
                    &returnLength);
                if (!b || returnLength != 256 || Buffer[0] == '\0') {

                    dprintf(" [ (%lx) ]", DeviceExtension->InstanceID );

                } else {

                    dprintf(" [%s]", Buffer );

                }

            } else {

                dprintf(" [NULL]");

            }

        }

    } else if (DeviceExtension->Flags & DEV_PROP_ADDRESS) {

        dprintf(" %lx", DeviceExtension->Address );

    }
#endif
    dprintf("\n");

    //
    // Line #2
    //
    dprintf(
        "%s  DevObj     %8lx   PhysicalObj  %8lx   ",
        indent,
        DeviceExtension->DeviceObject,
        DeviceExtension->PhysicalDeviceObject
        );
    if (DeviceExtension->TargetDeviceObject != NULL) {

        dprintf("AttachedTo %8lx", DeviceExtension->TargetDeviceObject );

    }
    dprintf("\n");

    //
    // Line #3
    //
    dprintf(
        "%s  AcpiObject %8lx   ParentExt    %8lx\n",
        indent,
        DeviceExtension->AcpiObject,
        DeviceExtension->ParentExtension
        );

    //
    // Line #4
    //
    dprintf(
        "%s  PnpState   %-8s   OldPnpState  %-8s\n",
        indent,
        DeviceStateTable[DeviceExtension->DeviceState],
        DeviceStateTable[DeviceExtension->PreviousState]
        );

    //
    // Line #4
    //
    dprintf("%s  ",indent);
    if (DeviceExtension->ResourceList != NULL) {

        dprintf("CmResList  %lx   ", DeviceExtension->ResourceList );

    } else {

        dprintf("                      ");

    }
    if (DeviceExtension->PnpResourceList != NULL) {

        dprintf("PnpResList   %lx   ", DeviceExtension->PnpResourceList );

    } else {

        dprintf("                        ");

    }

    dprintf(
        "RefCounts  %dD %dI %dH %dW\n",
        DeviceExtension->ReferenceCount,
        DeviceExtension->OutstandingIrpCount,
        DeviceExtension->HibernatePathCount,
        powerInfo->WakeSupportCount
        );

    //
    // Line #5
    //
    if (DeviceExtension->Flags & DEV_PROP_DOCK) {

        dprintf( "%s  Dock       %8lx   ", indent, DeviceExtension->Dock );

    } else {

        dprintf( "%s                        ", indent );

    }
    dprintf(
        "Dispatch     %8lx   ",
        DeviceExtension->DispatchTable
        );
    if (DeviceExtension->RemoveEvent != NULL) {

        dprintf("Remove %lx", DeviceExtension->RemoveEvent);

    }
    dprintf("\n");

    //
    // Line #6
    //
    if (powerInfo->DeviceNotifyHandler != NULL) {

        GetSymbol(
            powerInfo->DeviceNotifyHandler,
            Buffer,
            &displacement
            );
        dprintf(
            "%s  Handler    %lx   Context      %8lx   %s+%x\n",
            indent,
            powerInfo->DeviceNotifyHandler,
            powerInfo->Context,
            Buffer,
            displacement
            );

    }

    //
    // Line #7-12
    //
    for (k = PowerDeviceUnspecified; k <= PowerDeviceD3; k++) {

        if (k < PowerDeviceD3) {

            if (powerInfo->PowerObject[k] == NULL &&
                powerInfo->PowerNode[k] == NULL) {

                continue;

            }

        } else {

            if (powerInfo->PowerObject[k] == NULL) {

                continue;

            }

        }

        //
        // Did we print on this line?
        //
        b = FALSE;
        dprintf("%s  ", indent);
        if (powerInfo->PowerObject[k] != NULL) {

            dprintf(
                "_PS%c       %lx   ",
                ReallyShortDevicePowerStateTable[k],
                powerInfo->PowerObject[k]
                );
            b = TRUE;

        }
        if (k <= PowerDeviceD2 && powerInfo->PowerNode[k] != NULL) {

            if (b) {

                dprintf(
                    "%s Nodes     %lx   ",
                    ShortDevicePowerStateTable[k],
                    powerInfo->PowerNode[k]
                    );

            } else {

                dprintf(
                    "%s Nodes   %lx   ",
                    ShortDevicePowerStateTable[k],
                    powerInfo->PowerNode[k]
                    );

            }

        }
        dprintf("\n");

    }

    //
    // Line #13
    //
    dprintf( "%s  State      %-2s", indent, ShortDevicePowerStateTable[powerInfo->PowerState]);
    if (powerInfo->DesiredPowerState != powerInfo->PowerState) {

        dprintf("->%-4s   ", ShortDevicePowerStateTable[powerInfo->DesiredPowerState]);

    } else {

        dprintf("         ");

    }
    dprintf("SxD Mapping  ");
    for (s = PowerSystemWorking; s < PowerSystemMaximum; s++) {

        k = powerInfo->DevicePowerMatrix[s];
        if (k == PowerDeviceUnspecified) {

            continue;

        }
        dprintf(
            "S%c->D%c ",
            ReallyShortSystemPowerStateTable[s],
            ReallyShortDevicePowerStateTable[k]
            );

    }
    dprintf("\n");

    //
    // Line #14
    //
    if (DeviceExtension->Flags & DEV_CAP_WAKE) {

        //
        // Print the start of the line
        //
        dprintf("%s      ", indent);

        s = powerInfo->SystemWakeLevel;
        if (s == PowerSystemUnspecified) {

            dprintf("Sw->Sx " );

        } else {

            dprintf("Sw->S%c ", ReallyShortSystemPowerStateTable[s] );

        }

        k = DeviceExtension->PowerInfo.DeviceWakeLevel;
        if (k == PowerDeviceUnspecified) {

            dprintf("Dw->Dx " );

        } else {

            dprintf("Dw->D%c ", ReallyShortDevicePowerStateTable[k] );

        }
        dprintf(
            "    Wake Pin     %8d   WakeCount  %8x\n",
            powerInfo->WakeBit,
            powerInfo->WakeSupportCount
            );

    }

    //
    // Line #15
    //
    if (powerInfo->CurrentPowerRequest != NULL) {

        dprintf(
            "%s  CurrentReq %lx   ",
            indent,
            powerInfo->CurrentPowerRequest
            );
        if (powerInfo->PowerRequestListEntry.Flink !=
            (PLIST_ENTRY) (Address + FIELD_OFFSET(DEVICE_EXTENSION, PowerInfo.PowerRequestListEntry) ) ) {

            dprintf(
                "PowerReqList %lx %lx",
                CONTAINING_RECORD( powerInfo->PowerRequestListEntry.Flink, ACPI_POWER_REQUEST, SerialListEntry ),
                CONTAINING_RECORD( powerInfo->PowerRequestListEntry.Blink, ACPI_POWER_REQUEST, SerialListEntry )
                );

        }
        dprintf("\n");

    }

    //
    // At this point, we are done with the common bits, and now deal with the
    // special parts of the extension
    //
    if ( (DeviceExtension->Flags & DEV_TYPE_FDO) ) {

        dprintf(
            "%s  DPC Obj    %8lx   Int Object   %08lx\n",
            indent,
            (Address + FIELD_OFFSET(DEVICE_EXTENSION, Fdo.InterruptDpc) ),
            DeviceExtension->Fdo.InterruptObject
            );
        dprintf(
            "%s  PM1 Status %8lx\n",
            indent,
            DeviceExtension->Fdo.Pm1Status
            );
        dumpPM1StatusRegister( DeviceExtension->Fdo.Pm1Status, IndentLevel + 2 );

    }
    if ( (DeviceExtension->Flags & DEV_CAP_BUTTON) ) {

        dprintf(
            "%s  LidState   %-8s   SpinLock     %x   ",
            indent,
            (DeviceExtension->Button.LidState ? "TRUE" : "FALSE"),
            (Address + FIELD_OFFSET(DEVICE_EXTENSION, Button.SpinLock) )
        );
        if (DeviceExtension->Button.Events) {

            dumpFlags(
                (DeviceExtension->Button.Events),
                &DeviceExtensionButtonEventFlags[0],
                sizeof(DeviceExtensionButtonEventFlags)/sizeof(FLAG_RECORD),
                IndentLevel,
                (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE | DUMP_FLAG_NO_EOL)
                );

        }
        dprintf("\n");

        if (DeviceExtension->Button.Capabilities) {

            dprintf(
                "%s  Capability %lx   ",
                indent,
                DeviceExtension->Button.Capabilities
                );
            dumpFlags(
                (DeviceExtension->Button.Capabilities),
                &DeviceExtensionButtonEventFlags[0],
                sizeof(DeviceExtensionButtonEventFlags)/sizeof(FLAG_RECORD),
                IndentLevel,
                (DUMP_FLAG_LONG_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE | DUMP_FLAG_NO_EOL)
                );
            dprintf("\n");

        }

    }
    if ( (DeviceExtension->Flags & DEV_CAP_THERMAL_ZONE) ) {

        THRM_INFO   thrm;

        dprintf(
            "%s  Info       %lx   Flags        %8x   ",
            indent,
            DeviceExtension->Thermal.Info,
            DeviceExtension->Thermal.Flags
            );
        dumpFlags(
            (DeviceExtension->Thermal.Flags),
            &DeviceExtensionThermalFlags[0],
            sizeof(DeviceExtensionThermalFlags)/sizeof(FLAG_RECORD),
            IndentLevel,
            (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
             DUMP_FLAG_SINGLE_LINE | DUMP_FLAG_NO_EOL)
            );
        dprintf("\n");

        //
        // Read the thermal Information and print it
        //
        b = ReadMemory(
            (ULONG_PTR) DeviceExtension->Thermal.Info,
            &thrm,
            sizeof(THRM_INFO),
            &returnLength
            );
        if (!b || returnLength != sizeof(THRM_INFO)) {

            dprintf(
                "%s  Could not read THRM_INFO @ %08lx\n",
                indent,
                DeviceExtension->Thermal.Info
                );

        } else {

            displayThermalInfo(
                &thrm,
                (ULONG_PTR) DeviceExtension->Thermal.Info,
                Verbose,
                IndentLevel + 2
                );

        }
    }

    //
    // Last Line. At this point, we can dump the ACPI Flags
    //
    dprintf("%s  Flags      %016I64x ", indent, DeviceExtension->Flags );
    dumpFlags(
        (DeviceExtension->Flags),
        &DeviceExtensionFlags[0],
        sizeof(DeviceExtensionFlags)/sizeof(FLAG_RECORD),
        IndentLevel + 4,
        (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
         DUMP_FLAG_SINGLE_LINE)
        );
    dumpFlags(
        (DeviceExtension->Flags),
        &DeviceExtensionFlags[0],
        sizeof(DeviceExtensionFlags)/sizeof(FLAG_RECORD),
        IndentLevel + 4,
        (DUMP_FLAG_LONG_NAME)
        );

}

VOID
displayAcpiDeviceExtensionBrief(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    )
/*++

Routine Description:

    This routine displays a one line summary of the device extension

Arguments:

    DeviceExtension - The extension to display
    Address         - Where the extension is located
    Verbose         - How much information to display
    IndentLevel     - How much whitespace to use

Return Value:

    VOID

--*/
{
    BOOL                b;
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               address;
    ULONG               i;
    ULONG               returnLength;
    ULONG               startAddress;

    //
    // Should we print this extension?
    //
    if ( (Verbose & VERBOSE_PRESENT) &&
         (DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) ) {

        return;

    }

    //
    // Make the IndentLevel 'relative' - Device By 4
    //
    IndentLevel /= 4;

    //
    // Indent the text
    //
    for (i = 0; i < IndentLevel; i++) {

        dprintf("| ");

    }

    //
    // Print the address of the object
    //
    dprintf("%08lx", Address );

    //
    // Try to get the name & instance
    //
    if (DeviceExtension->Flags & DEV_PROP_HID) {

        if (DeviceExtension->DeviceID) {

            memset( Buffer, '0', 2048 );
            b = ReadMemory(
                (ULONG_PTR) DeviceExtension->DeviceID,
                Buffer,
                256,
                &returnLength
                );
            if (b && Buffer[0] != '\0') {

                dprintf(" %s", Buffer );

            }

        } else {

            dprintf(" <Unknown HID>");

        }

        if (DeviceExtension->Flags & DEV_PROP_UID) {

            if (DeviceExtension->InstanceID) {

                memset( Buffer, '0', 2048 );
                b = ReadMemory(
                    (ULONG_PTR) DeviceExtension->InstanceID,
                    Buffer,
                    256,
                    &returnLength
                    );
                if (b && Buffer[0] != '\0') {

                    dprintf("(%s)", Buffer );

                }

            } else {

                dprintf(" <Unknown UID>");

            }

        }

    } else if (DeviceExtension->Flags & DEV_PROP_ADDRESS) {

        dprintf(" %lx", DeviceExtension->Address );

    } else {

        dprintf(" <NULL>");

    }

    if (Verbose & VERBOSE_THERMAL) {

        DEVICE_POWER_STATE  d;
        SYSTEM_POWER_STATE  s;

        if (DeviceExtension->PowerInfo.PowerState == 0) {

            dprintf(" Dx" );

        } else {

            dprintf(" D%d", (DeviceExtension->PowerInfo.PowerState - 1) );

        }

        for (s = PowerSystemWorking; s < PowerSystemMaximum; s++) {

            d = DeviceExtension->PowerInfo.DevicePowerMatrix[s];
            if (d == PowerDeviceUnspecified) {

                continue;

            }

            dprintf(
                " S%c->D%c",
                ReallyShortSystemPowerStateTable[s],
                ReallyShortDevicePowerStateTable[d]
                );

        }

        if (DeviceExtension->Flags & DEV_CAP_WAKE) {

            s = DeviceExtension->PowerInfo.SystemWakeLevel;
            if (s == PowerSystemUnspecified) {

                dprintf(" Sw->Sx" );

            } else {

                dprintf(" Sw->S%c", ReallyShortSystemPowerStateTable[s] );

            }

            d = DeviceExtension->PowerInfo.DeviceWakeLevel;
            if (d == PowerDeviceUnspecified) {

                dprintf(" Dw->Dx" );

            } else {

                dprintf(" Dw->D%c", ReallyShortDevicePowerStateTable[d] );

            }

        }

        //
        // If we are displaying thermal information, cut short early
        //
        dprintf("\n");
        return;

    }

    dprintf(" NS %08lx", DeviceExtension->AcpiObject );
    if (DeviceExtension->PowerInfo.PowerState == 0) {

        dprintf(" Dx" );

    } else {

        dprintf(" D%d", (DeviceExtension->PowerInfo.PowerState - 1) );

    }

    //
    // Print the device state
    //
    if (DeviceExtension->DeviceState == Stopped) {

        dprintf(" stop");

    } else if (DeviceExtension->DeviceState == Inactive) {

        dprintf(" inac");

    } else if (DeviceExtension->DeviceState == Started) {

        dprintf(" star");

    } else if (DeviceExtension->DeviceState == Removed) {

        dprintf(" remv");

    } else if (DeviceExtension->DeviceState == SurpriseRemoved) {

        dprintf(" surp");

    } else {

        dprintf(" inva");

    }
    dprintf(" %d-%d-%d",
        DeviceExtension->OutstandingIrpCount,
        DeviceExtension->ReferenceCount,
        DeviceExtension->HibernatePathCount
        );

    //
    // Display the flags
    //
    dumpFlags(
        (DeviceExtension->Flags),
        &DeviceExtensionFlags[0],
        sizeof(DeviceExtensionFlags)/sizeof(FLAG_RECORD),
        IndentLevel + 4,
        (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
         DUMP_FLAG_SINGLE_LINE)
        );

    // displayAcpiDeviceExtensionFlags( DeviceExtension );
}

VOID
displayAcpiDeviceExtensionFlags(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine displays the Flag for a device extension

    This routine prints a new line at the end of the only line of text that
    it consumes

Arguments:

    DeviceExtension - The extension whose flags to dump

Return Value:

    None

--*/
{
    //
    // Dump the flags
    //
    if (DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT) {

        dprintf(" Nev");

    }
    if (DeviceExtension->Flags & DEV_TYPE_NOT_PRESENT) {

        dprintf(" N/P");

    }
    if (DeviceExtension->Flags & DEV_TYPE_REMOVED) {

        dprintf(" Rmv");

    }
    if (DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) {

        dprintf(" N/F");

    }
    if (DeviceExtension->Flags & DEV_TYPE_FDO) {

        dprintf(" Fdo");

    }
    if (DeviceExtension->Flags & DEV_TYPE_PDO) {

        dprintf(" Pdo");

    }
    if (DeviceExtension->Flags & DEV_TYPE_FILTER) {

        dprintf(" Fil");

    }
    if (DeviceExtension->Flags & DEV_CAP_WAKE) {

        dprintf(" Wak");

    }
    if (DeviceExtension->Flags & DEV_CAP_RAW) {

        dprintf(" Raw");

    }
    if (DeviceExtension->Flags & DEV_CAP_BUTTON) {

        dprintf(" But");

    }
    if (DeviceExtension->Flags & DEV_CAP_ALWAYS_PS0) {

        dprintf(" PS0");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_FILTER) {

        dprintf(" !Fil");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_STOP) {

        dprintf(" !Stop");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_OVERRIDE) {

        dprintf(" !Off");

    }
    if (DeviceExtension->Flags & DEV_CAP_ISA) {

        dprintf(" Isa");

    }
    if (DeviceExtension->Flags & DEV_CAP_EIO) {

        dprintf(" Eio");

    }
    if (DeviceExtension->Flags & DEV_CAP_PCI) {

        dprintf(" Pci");

    }
    if (DeviceExtension->Flags & DEV_CAP_SERIAL) {

        dprintf(" Ser");

    }
    if (DeviceExtension->Flags & DEV_CAP_THERMAL_ZONE) {

        dprintf(" Thrm");

    }
    if (DeviceExtension->Flags & DEV_CAP_LINK_NODE) {

        dprintf(" Lnk");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_SHOW_IN_UI) {

        dprintf(" !UI");

    }
    if (DeviceExtension->Flags & DEV_CAP_NEVER_SHOW_IN_UI) {

        dprintf(" !!UI");

    }
    if (DeviceExtension->Flags & DEV_CAP_START_IN_D3) {

        dprintf(" D3");

    }
    if (DeviceExtension->Flags & DEV_CAP_PCI_DEVICE) {

        dprintf(" PciD");

    }
    if (DeviceExtension->Flags & DEV_CAP_PIC_DEVICE) {

        dprintf(" PIC");

    }
    if (DeviceExtension->Flags & DEV_CAP_UNATTACHED_DOCK) {

        dprintf(" Dock-");

    }
    if (DeviceExtension->Flags & DEV_PROP_ADDRESS) {

        dprintf(" Adr");

    }
    if (DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        dprintf(" FHid");

    } else if (DeviceExtension->Flags & DEV_PROP_HID) {

        dprintf(" Hid");

    }
    if (DeviceExtension->Flags & DEV_PROP_FIXED_UID) {

        dprintf(" FUid");

    } else if (DeviceExtension->Flags & DEV_PROP_UID) {

        dprintf(" Uid");

    }
    if (DeviceExtension->Flags & DEV_PROP_FAILED_INIT) {

        dprintf(" !INIT");

    }
    if (DeviceExtension->Flags & DEV_PROP_SRS_PRESENT) {

        dprintf(" SRS");

    }
    if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        dprintf(" Fake");

    }
    if (DeviceExtension->Flags & DEV_PROP_EXCLUSIVE) {

        dprintf(" Excl");

    }
    if (DeviceExtension->Flags & DEV_PROP_RAN_INI) {

        dprintf(" Ini");

    }
    if (!(DeviceExtension->Flags & DEV_PROP_DEVICE_ENABLED)) {

        dprintf(" !Ena");

    }
    if (DeviceExtension->Flags & DEV_PROP_DEVICE_FAILED) {

        dprintf(" Fail");

    }
    if (DeviceExtension->Flags & DEV_PROP_ACPI_POWER) {

        dprintf(" Pwr");

    }

    if (DeviceExtension->Flags & DEV_PROP_DOCK) {

       dprintf(" Prof");

    }
    if (DeviceExtension->Flags & DEV_PROP_BUILT_POWER_TABLE) {

        dprintf(" S->D");

    }
    if (DeviceExtension->Flags & DEV_PROP_HAS_PME) {

        dprintf(" PME");

    }
    dprintf("\n");

}

VOID
displayAcpiDeviceExtensionName(
    IN  ULONG_PTR DeviceExtensionAddress
    )
/*++

Routine Description:


    This routine is tasked to with displaying the name of the device in the
    best possible manner

Arguments:

    DeviceExtensionAddress  - The Address of the DeviceExtension

Return Value:

    NONE

--*/
{
    BOOL                status;
    DEVICE_EXTENSION    deviceExtension;
    NSOBJ               acpiObject;
    UCHAR               nameBuffer[80];
    ULONG_PTR           nameAddress;
    ULONG               returnLength;

    //
    // Read the entier extension
    //
    status = ReadMemory(
        DeviceExtensionAddress,
        &deviceExtension,
        sizeof(DEVICE_EXTENSION),
        &returnLength
        );
    if (status && returnLength == sizeof(DEVICE_EXTENSION) ) {

        if (deviceExtension.Flags & DEV_PROP_HID) {

            if (deviceExtension.DeviceID != NULL) {

                //
                // Now, try to read the name into the buffer
                //
                status = ReadMemory(
                    (ULONG_PTR) deviceExtension.DeviceID,
                    nameBuffer,
                    79,
                    &returnLength
                    );
                if (status && returnLength) {

                    nameBuffer[returnLength] = '\0';
                    dprintf("%s",nameBuffer);


                } else {

                    dprintf("(%lx)", deviceExtension.DeviceID);

                }

            } else {

                dprintf("NULL");

            }

        }
        if (deviceExtension.Flags & DEV_PROP_UID) {

            if (deviceExtension.InstanceID != NULL) {

                //
                // Now, try to read the name into the buffer
                //
                status = ReadMemory(
                    (ULONG_PTR) deviceExtension.InstanceID,
                    nameBuffer,
                    79,
                    &returnLength
                    );
                if (status && returnLength) {

                    nameBuffer[returnLength] = '\0';
                    dprintf(" [%s]",nameBuffer);


                } else {

                    dprintf(" [ (%lx) ]", deviceExtension.InstanceID);

                }

            } else {

                dprintf(" [NULL]");

            }

        }
        if (deviceExtension.Flags & DEV_PROP_ADDRESS) {

            dprintf("%lx", deviceExtension.Address );

        }
        return;

    }

    //
    // In this case, obtain the address of the ACPIObject for this device
    //
    nameAddress = (ULONG_PTR) &(deviceExtension.AcpiObject) -
        (ULONG_PTR) &(deviceExtension) + DeviceExtensionAddress;
    status = ReadMemory(
        nameAddress,
        &(deviceExtension.AcpiObject),
        sizeof(PNSOBJ),
        &returnLength
        );
    if (status && returnLength == sizeof(PNSOBJ)) {

        //
        // Read the object
        //
        status = ReadMemory(
            (ULONG_PTR) deviceExtension.AcpiObject,
            &acpiObject,
            sizeof(NSOBJ),
            &returnLength
            );
        if (status && returnLength == sizeof(NSOBJ)) {

            memcpy( nameBuffer, &(acpiObject.dwNameSeg), 4 );
            nameBuffer[4] = '\0';

            dprintf("Acpi(%s)", nameBuffer);
            return;

        }

    }

    dprintf("Unknown");
    return;
}
VOID
displayThermalInfo(
    IN  PTHRM_INFO  ThrmInfo,
    IN  ULONG_PTR   Address,
    IN  ULONG       Verbose,
    IN  ULONG       IndentLevel
    )
/*++

    This routine displays a thermal information structure

--*/
{
    BOOLEAN             noIndent;
    UCHAR               indent[80];
    UINT                i;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    dprintf(
        "%s  Stamp      %8lx   Affinity     %08lx   Mode       %s\n",
        indent,
        ThrmInfo->Info.ThermalStamp,
        ThrmInfo->Info.Processors,
        (ThrmInfo->Mode == 0 ? "Active" : "Passive")
        );
    dprintf(
        "%s  SampleRate %8ss  Constant1    %08lx   Constant2  %08lx\n",
        indent,
        TimeToSeconds( ThrmInfo->Info.SamplingPeriod ),
        ThrmInfo->Info.ThermalConstant1,
        ThrmInfo->Info.ThermalConstant2
        );
    dprintf(
        "%s  _TMP       %8lx   TempData     %8lx   CoolingLvl  %2d\n",
        indent,
        ThrmInfo->TempMethod,
        Address + FIELD_OFFSET( THRM_INFO, Temp ),
        ThrmInfo->CoolingLevel
        );
    for (i = 0; i < 10; i++) {

        noIndent = FALSE;

        if (i == 0) {

            dprintf(
                "%s  Current    %8sK  ",
                indent,
                TempToKelvins( ThrmInfo->Info.CurrentTemperature )
                );

        } else if (i == 1) {

            dprintf(
                "%s  Critical   %8sK  ",
                indent,
                TempToKelvins( ThrmInfo->Info.CriticalTripPoint )
                );

        } else if (i == 2) {

            dprintf(
                "%s  Passive    %8sK  ",
                indent,
                TempToKelvins( ThrmInfo->Info.PassiveTripPoint )
                );

        } else {

            noIndent = TRUE;

        }

        if (i >= ThrmInfo->Info.ActiveTripPointCount) {

            if (ThrmInfo->Info.ActiveTripPoint[i] != 0 ||
                ThrmInfo->ActiveList[i] != NULL) {

                if (noIndent == TRUE) {

                    dprintf( "%s                        ", indent );

                }
                dprintf(
                    "*Active #%d   %8sK  Method     %lx\n",
                    i,
                    TempToKelvins( ThrmInfo->Info.ActiveTripPoint[i] ),
                    ThrmInfo->ActiveList[i]
                    );

            } else if (i < 3) {

                dprintf("\n");

            } else {

                break;

            }


        } else {

            if (noIndent == TRUE) {

                dprintf( "%s                        ", indent );

            }
            dprintf(
                "Active #%d    %8sK  Method     %lx\n",
                i,
                TempToKelvins( ThrmInfo->Info.ActiveTripPoint[i] ),
                ThrmInfo->ActiveList[i]
                );

        }

    }
}

VOID
dumpAcpiDeviceNode(
    IN  PACPI_DEVICE_POWER_NODE DeviceNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    )
/*++

Routine Description:

    This routine dumps the contents of a single device node

Arguments:

    DeviceNode  - What to dump
    Address     - Where that node is located
    IndentLevel - How much whitespace to use

Return Value:

    None

--*/
{
    UCHAR   indent[80];

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    dprintf(
        "%sDevice Node - %08lx -> Extension - %08lx",
        indent,
        Address,
        DeviceNode->DeviceExtension
        );
    if (DeviceNode->DeviceExtension != NULL) {

        dprintf(" - ");
        displayAcpiDeviceExtensionName(
            (ULONG_PTR) DeviceNode->DeviceExtension
            );

    }
    dprintf("\n");

    dprintf(
        "%s  System     %2s         Device       %2s         Wake       %s\n",
        indent,
        ShortSystemPowerStateTable[DeviceNode->SystemState],
        ShortDevicePowerStateTable[DeviceNode->AssociatedDeviceState],
        (DeviceNode->WakePowerResource ? "TRUE" : "FALSE")
        );

}

VOID
dumpAcpiDeviceNodes(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This routine walks a Device Power List (given the address of the
    start of that list)

Arguments:

    Address     - Where in memory the first node is located
    Verbose     - How much information to display
    IndentLevel - How many characters to indent

Return Value:

    VOID

--*/
{
    BOOL                    status;
    ACPI_DEVICE_POWER_NODE  deviceNode;
    ACPI_POWER_DEVICE_NODE  powerNode;
    ULONG                   returnLength;
    ULONG_PTR               deviceAddress = Address;

    while (deviceAddress != 0) {

        //
        // Read the current node
        //
        status = ReadMemory(
            deviceAddress,
            &deviceNode,
            sizeof(ACPI_DEVICE_POWER_NODE),
            &returnLength
            );
        if (status != TRUE || returnLength != sizeof(ACPI_DEVICE_POWER_NODE)) {

            dprintf(
                "dumpAcpiDeviceNodes: could not read device node memory "
                "%08lx\n",
                deviceAddress
                );
            return;

        }

        //
        // Dump the node
        //
        dumpAcpiDeviceNode(
            &deviceNode,
            deviceAddress,
            Verbose,
            IndentLevel
            );

        status = ReadMemory(
            (ULONG_PTR) deviceNode.PowerNode,
            &powerNode,
            sizeof(ACPI_POWER_DEVICE_NODE),
            &returnLength);
        if (status != TRUE ||
            returnLength != sizeof(ACPI_POWER_DEVICE_NODE)) {

            dprintf(
                "dumpAcpiDeviceNode: could not read power node memory "
                "%08lx\n",
                deviceNode.PowerNode
                );
            return;

        }

        //
        // Dump the power resource
        //
        dumpAcpiPowerNode(
            &powerNode,
            (ULONG_PTR) deviceNode.PowerNode,
            Verbose,
            IndentLevel
            );

        //
        // setup next entry in the list
        //
        deviceAddress = (ULONG_PTR) deviceNode.Next;

    }

}

VOID
dumpAcpiExtension(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This dumps the ACPI device extension in a format that is readable by the
    user debugging the system

Arguments:

    Address     - Where the DeviceObject is located
    Verbose     - How much information to display
    IndentLevel - How much whitespace to have

Return Value:

    None

--*/
{
    BOOL                b;
    DEVICE_EXTENSION    deviceExtension;
    PLIST_ENTRY         listEntry;
    UCHAR               indent[80];
    ULONG_PTR           curAddress;
    ULONG               returnLength;
    ULONG_PTR           stopAddress;
    ULONG               subVerbose;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //
    // Read the sibling device extension
    //
    b = ReadMemory(
        Address,
        &deviceExtension,
        sizeof(DEVICE_EXTENSION),
        &returnLength
        );
    if (!b) {

        dprintf(
            "%s***ReadMemory Failed from %p\n",
            Address
            );
        return;

    } else if (returnLength != sizeof(DEVICE_EXTENSION) ) {

        dprintf(
            "%s***Error: Only read %08lx of %08lx bytes for %p\n",
            returnLength,
            sizeof(DEVICE_EXTENSION),
            Address
            );
        return;

    }

    if ( (Verbose & VERBOSE_ALL) ) {

        displayAcpiDeviceExtension(
            &deviceExtension,
            Address,
            Verbose,
            IndentLevel
            );

    } else {

        displayAcpiDeviceExtensionBrief(
            &deviceExtension,
            Address,
            Verbose,
            IndentLevel
            );

    }

    if (! (Verbose & VERBOSE_LOOP) ) {

        return;

    }

    //
    // Determine the current and stop addresses
    //
    stopAddress = (ULONG_PTR) &(deviceExtension.ChildDeviceList) -
        (ULONG_PTR) &deviceExtension + Address;
    listEntry = deviceExtension.ChildDeviceList.Flink;

    //
    // Loop while there are children
    //
    while (listEntry != (PLIST_ENTRY) stopAddress) {

        //
        // Check for Ctrl-C
        //
        if (CheckControlC()) {

            break;

        }

        //
        // The currentAddress is at the ListEntry --- lets convert
        //
        curAddress = (ULONG_PTR) CONTAINING_RECORD(
            listEntry,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

        //
        // Read the entry
        //
        b = ReadMemory(
            curAddress,
            &deviceExtension,
            sizeof(DEVICE_EXTENSION),
            &returnLength
            );
        if (!b) {

            dprintf(
                "%s    ***ReadMemory Failed from %p\n",
                curAddress
                );
            return;

        } else if (returnLength != sizeof(DEVICE_EXTENSION) ) {

            dprintf(
                "%s    ***Error: Only read %08lx of %08lx bytes "
                "for %p\n",
                returnLength,
                sizeof(DEVICE_EXTENSION),
                curAddress
                );
            return;

        }

        //
        // Recurse
        //
        dumpAcpiExtension(
            curAddress,
            Verbose,
            IndentLevel + 4
            );

        //
        // Point to the next extension
        //
        listEntry = deviceExtension.SiblingDeviceList.Flink;

    }
}

VOID
dumpPM1ControlRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    )
{


    //
    // Dump the PM1 Control Flags
    //
    dumpFlags(
        (Value & 0xFF),
        &PM1StatusFlags[0],
        sizeof(PM1ControlFlags) / sizeof(FLAG_RECORD),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );

}

VOID
dumpPM1StatusRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    )
{

    //
    // Dump the PM1 Status Flags
    //
    dumpFlags(
        (Value & 0xFFFF),
        PM1StatusFlags,
        (sizeof(PM1StatusFlags) / sizeof(FLAG_RECORD)),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );

    //
    // Switch to the PM1 Enable Flags
    //
    Value >>= 16;


    //
    // Dump the PM1 Enable Flags
    //
    dumpFlags(
        (Value & 0xFFFF),
        PM1EnableFlags,
        (sizeof(PM1EnableFlags) / sizeof(FLAG_RECORD)),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );
}

VOID
dumpAcpiPowerList(
    IN  PUCHAR  ListName
    )
/*++

    This routine fetects a single Power Device List from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;

    //
    // Handle the queue list
    //
    address = GetExpression( ListName );
    if (!address) {

        dprintf( "dumpAcpiPowerList: could not read %s\n", ListName );

    } else {

        dprintf("  %s at %p\n", ListName, address );
        status = ReadMemory(
            address,
            &listEntry,
            sizeof(LIST_ENTRY),
            &returnLength
            );
        if (status == FALSE || returnLength != sizeof(LIST_ENTRY)) {

            dprintf(
                "dumpAcpiPowerList: could not read LIST_ENTRY at %08lx\n",
                address
                );

        } else {

            dumpDeviceListEntry(
                &listEntry,
                address
                );
            dprintf("\n");

        }

    }
}

VOID
dumpAcpiPowerLists(
    VOID
    )
/*++

Routine Description:

    This routine fetches the Power Device list from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;
    ULONG       value;

    status = GetUlongPtr( "ACPI!AcpiPowerLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerLock\n");
        return;

    }

    dprintf("ACPI Power Information\n");
    if (address) {

        dprintf("  + ACPI!AcpiPowerLock is owned");

        //
        // The bits other then the lowest is where the owning thread is
        // located. This function uses the property that -2 is every bit
        // except the least significant one
        //
        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiPowerLock is not owned\n");

    }

    status = GetUlongPtr( "ACPI!AcpiPowerQueueLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerQueueLock\n");
        return;

    }
    if (address) {

        dprintf("  + ACPI!AcpiPowerQueueLock is owned\n");

        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiPowerQueueLock is not owned\n" );

    }

    status = GetUlong( "ACPI!AcpiPowerWorkDone", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerWorkDone\n");
        return;

    }
    dprintf("  + AcpiPowerWorkDone = %s\n", (value ? "TRUE" : "FALSE" ) );


    status = GetUlong( "ACPI!AcpiPowerDpcRunning", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerDpcRunning\n");
        return;

    }
    dprintf("  + AcpiPowerDpcRunning = %s\n", (value ? "TRUE" : "FALSE" ) );

    dumpAcpiPowerList( "ACPI!AcpiPowerQueueList" );
    dumpAcpiPowerList( "ACPI!AcpiPowerDelayedQueueList" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase0List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase1List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase2List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase3List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase4List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase5List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerWaitWakeList" );

}

VOID
dumpAcpiPowerNode(
    IN  PACPI_POWER_DEVICE_NODE PowerNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    )
/*++

Routine Description:

    This routine is called to display a power node

Arguments:

    PowerNode   - The power node to dump
    Address     - Where the power node is located
    Verbose     - How much information to display
    IndentLevel - How many characters to indent

Return Value:

    None

--*/
{
    BOOL    status;
    NSOBJ   ns;
    UCHAR   buffer[5];
    UCHAR   indent[80];
    ULONG   returnLength;

    buffer[4] = '\0';
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //
    // Read the associated power resource object
    //
    status = ReadMemory(
        (ULONG_PTR) PowerNode->PowerObject,
        &ns,
        sizeof(NSOBJ),
        &returnLength
        );
    if (status != FALSE && returnLength == sizeof(NSOBJ)) {

        memcpy( buffer, &(ns.dwNameSeg), 4 );

    } else {

        buffer[0] = '\0';

    }

    dprintf("%sPower Node - %08lx %s\n", indent, Address, buffer );
    dprintf(
        "%s  Resource   %8lx   Order        %8lx   WorkDone    %8s\n",
        indent,
        PowerNode->PowerObject,
        PowerNode->ResourceOrder,
        WorkDone[ PowerNode->WorkDone ]
        );
    dprintf(
        "%s  On Method  %8lx   Off Method   %8lx   UseCounts   %8lx\n",
        indent,
        PowerNode->PowerOnObject,
        PowerNode->PowerOffObject,
        PowerNode->UseCounts
        );
    dprintf(
        "%s  Level      %8s   Flags        %8lx   ",
        indent,
        ShortSystemPowerStateTable[PowerNode->SystemLevel],
        PowerNode->Flags
        );
    dumpFlags(
        (PowerNode->Flags),
        &PowerNodeFlags[0],
        sizeof(PowerNodeFlags)/sizeof(FLAG_RECORD),
        0,
        (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
         DUMP_FLAG_SINGLE_LINE)
        );
    if (Verbose & VERBOSE_4) {

        dumpFlags(
            (PowerNode->Flags),
            &PowerNodeFlags[0],
            sizeof(PowerNodeFlags)/sizeof(FLAG_RECORD),
            IndentLevel + 4,
            (DUMP_FLAG_LONG_NAME)
            );

    }

}

VOID
dumpAcpiPowerNodes(
    VOID
    )
/*++

Routine Description:

    This routine fetches the Power Device list from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    ACPI_DEVICE_POWER_NODE  deviceNode;
    ACPI_POWER_DEVICE_NODE  powerNode;
    BOOL                    status;
    LIST_ENTRY              listEntry;
    PLIST_ENTRY             list;
    ULONG_PTR               addr;
    ULONG_PTR               address;
    ULONG_PTR               endAddress;
    ULONG                   returnLength;
    ULONG_PTR               startAddress;

    status = GetUlongPtr( "ACPI!AcpiPowerLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerNodes: Could not read ACPI!AcpiPowerLock\n");
        return;

    }

    dprintf("ACPI Power Nodes\n");
    if (address) {

        dprintf("  + ACPI!AcpiPowerLock is owned");

        //
        // The bits other then the lowest is where the owning thread is
        // located. This function uses the property that -2 is every bit
        // except the least significant one
        //
        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiPowerLock is not owned\n");

    }

    dprintf("Power Node List\n");
    startAddress = GetExpression( "ACPI!AcpiPowerNodeList" );
    if (!startAddress) {

        dprintf("dumpAcpiPowerNodes: could not read ACPI!AcpiPowerNodeList\n");
        return;

    }
    status = ReadMemory(
        startAddress,
        &listEntry,
        sizeof(LIST_ENTRY),
        &returnLength
        );
    if (status == FALSE || returnLength != sizeof(LIST_ENTRY)) {

        dprintf(
            "dumpAcpiPowerNodes: could not read LIST_ENTRY at %08lx\n",
            startAddress
            );
        return;

    }

    //
    // Check to see if the list is empty
    //
    if ( (ULONG_PTR) listEntry.Flink == startAddress) {

        dprintf("  Empty\n");
        return;

    }

    address = (ULONG_PTR) CONTAINING_RECORD(
        (listEntry.Flink),
        ACPI_POWER_DEVICE_NODE,
        ListEntry
        );
    while (address != startAddress && address != 0) {

        //
        // Read the queued item
        //
        status = ReadMemory(
            address,
            &powerNode,
            sizeof(ACPI_POWER_DEVICE_NODE),
            &returnLength
            );
        if (status == FALSE || returnLength != sizeof(ACPI_POWER_DEVICE_NODE)) {

            dprintf(
                "dumpIrpListEntry: Cannot read Node at %08lx\n",
                address
                );
            return;

        }

        //
        // dump the node
        //
        dumpAcpiPowerNode(
            &powerNode,
            address,
            0,
            0
            );

        //
        // Lets walk the list of power nodes
        //
        list = powerNode.DevicePowerListHead.Flink;
        endAddress = ( (ULONG_PTR) &(powerNode.DevicePowerListHead) -
                 (ULONG_PTR) &(powerNode) ) +
               address;

        //
        // Loop until back at the start
        //
        while (list != (PLIST_ENTRY) endAddress) {

            //
            // Crack the record
            //
            addr = (ULONG_PTR) CONTAINING_RECORD(
                list,
                ACPI_DEVICE_POWER_NODE,
                DevicePowerListEntry
                );

            status = ReadMemory(
                addr,
                &deviceNode,
                sizeof(ACPI_DEVICE_POWER_NODE),
                &returnLength
                );
            if (status == FALSE ||
                returnLength != sizeof(ACPI_DEVICE_POWER_NODE)) {

                dprintf(
                    "dumpIrpListEntry: Cannot read Node at %08lx\n",
                    addr
                    );
                continue;

            }

            //
            // Dump the record
            //
            dumpAcpiDeviceNode(
                &deviceNode,
                addr,
                0,
                2
                );

            //
            // Next record
            //
            list = deviceNode.DevicePowerListEntry.Flink;

        }

        dprintf("\n");

        //
        // Next record
        //
        address = (ULONG_PTR) CONTAINING_RECORD(
            powerNode.ListEntry.Flink,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

    }

}

VOID
dumpDeviceListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine is called to dump a list of devices in one of the queues

Arguments:

    ListEntry   - The head of the list
    Address     - The original address of the list (to see when we looped
                  around

Return Value:

    NONE

--*/
{
    ULONG_PTR           displacement;
    ACPI_POWER_REQUEST  request;
    BOOL                stat;
    PACPI_POWER_REQUEST nextRequest;
    PACPI_POWER_REQUEST requestAddress;
    ULONG               i = 0;
    ULONG               returnLength;

    //
    // Look at the next address
    //
    ListEntry = ListEntry->Flink;

    while (ListEntry != (PLIST_ENTRY) Address) {

        //
        // Crack the listEntry to determine where the powerRequest is
        //
        requestAddress = CONTAINING_RECORD(
            ListEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Read the queued item
        //
        stat = ReadMemory(
            (ULONG_PTR) requestAddress,
            &request,
            sizeof(ACPI_POWER_REQUEST),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(ACPI_POWER_REQUEST)) {

            dprintf(
                "dumpDeviceListEntry: Cannot read PowerRequest at %08lx\n",
                requestAddress
                );
            return;

        }

        if (request.CallBack != NULL) {

            GetSymbol(
                request.CallBack,
                Buffer,
                &displacement
                );

        } else {

            Buffer[0] = '\0';

        }

        //
        // Dump the entry for the device
        //
        dprintf(
            "      %08lx\n"
            "        DeviceExtension:     %08lx",
            requestAddress,
            request.DeviceExtension
            );
        if (request.DeviceExtension != NULL) {

            dprintf(" - ");
            displayAcpiDeviceExtensionName(
                (ULONG_PTR) request.DeviceExtension
                );

        }
        dprintf("\n");
        dprintf(
            "        Status:              %08lx %s->%s\n",
            request.Status,
            WorkDone[request.WorkDone],
            WorkDone[request.NextWorkDone]
            );
        nextRequest = CONTAINING_RECORD(
            request.SerialListEntry.Flink,
            ACPI_POWER_REQUEST,
            SerialListEntry
            );
        if (nextRequest != requestAddress) {

            dprintf(
                "        SerialListEntry:     F - %08lx B - %08lx -> %08lx\n",
                request.SerialListEntry.Flink,
                request.SerialListEntry.Blink,
                nextRequest
                );

        }
        dprintf(
            "        CallBack:            %08lx (%s)\n"
            "        Context:             %08lx\n"
            "        RequestType:         %02lx\n"
            "        ResultData:          %08lx\n",
            request.CallBack,
            Buffer,
            request.Context,
            request.RequestType,
            requestAddress + (FIELD_OFFSET(ACPI_POWER_REQUEST, ResultData ) )
            );

        //
        // Dump some of the request specific information
        //
        if (request.RequestType == AcpiPowerRequestDevice) {

            dprintf(
                "        RequestType:         AcpiPowerRequestDevice\n"
                "        DevicePowerState:    %s\n"
                "        Flags:               %x ",
                DevicePowerStateTable[request.u.DevicePowerRequest.DevicePowerState],
                request.u.DevicePowerRequest.Flags
                );
            dumpFlags(
                (request.u.DevicePowerRequest.Flags),
                &PowerRequestFlags[0],
                sizeof(PowerRequestFlags)/sizeof(FLAG_RECORD),
                0,
                (DUMP_FLAG_LONG_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE)
                );

        } else if (request.RequestType == AcpiPowerRequestSystem) {

            dprintf(
                "        RequestType:         AcpiPowerRequestSystem\n"
                "        SystemPowerState:    %s\n"
                "        SystemPowerAction:   %s\n",
                SystemPowerStateTable[request.u.SystemPowerRequest.SystemPowerState],
                SystemPowerActionTable[request.u.SystemPowerRequest.SystemPowerAction]
                );

        } else if (request.RequestType == AcpiPowerRequestWaitWake) {

            dprintf(
                "        RequestType:         AcpiPowerRequestWaitWake\n"
                "        SystemPowerState:    %s\n"
                "        Flags:               %x ",
                SystemPowerStateTable[request.u.WaitWakeRequest.SystemPowerState],
                request.u.WaitWakeRequest.Flags
                );
            dumpFlags(
                (request.u.WaitWakeRequest.Flags),
                &PowerRequestFlags[0],
                sizeof(PowerRequestFlags)/sizeof(FLAG_RECORD),
                0,
                (DUMP_FLAG_LONG_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE)
                );

        }

        //
        // Point to the next entry
        //
        ListEntry = request.ListEntry.Flink;

    } // while

}

VOID
dumpIrpListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine is called to dump a list of devices in one of the queues

Arguments:

    ListEntry   - The head of the list
    Address     - The original address of the list (to see when we looped
                  around

Return Value:

    NONE

--*/
{
    BOOL                stat;
    DEVICE_OBJECT       deviceObject;
    DEVICE_EXTENSION    deviceExtension;
    IO_STACK_LOCATION   irpStack;
    PIRP                irpAddress;
    PIO_STACK_LOCATION  tempStack;
    IRP                 irp;
    ULONG               returnLength;

    //
    // Look at the first element in the list
    //
    ListEntry = ListEntry->Flink;

    //
    // Loop for all items in the list
    //
    while (ListEntry != (PLIST_ENTRY) Address) {

        irpAddress = CONTAINING_RECORD(
            ListEntry,
            IRP,
            Tail.Overlay.ListEntry
            );

        //
        // Read the queued item
        //
        stat = ReadMemory(
            (ULONG_PTR) irpAddress,
            &irp,
            sizeof(IRP),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(IRP)) {

            dprintf(
                "dumpIrpListEntry: Cannot read Irp at %08lx\n",
                irpAddress
                );
            return;

        }

        //
        // Get the current stack location
        //
        tempStack = IoGetCurrentIrpStackLocation( &irp );
        if (tempStack == NULL) {

            dprintf(
                "dumpIrpListEntry: Cannot read IrpStack for Irp at %08lx\n",
                irpAddress
                );
            return;

        }

        stat = ReadMemory(
            (ULONG_PTR) tempStack,
            &irpStack,
            sizeof(IO_STACK_LOCATION),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(IO_STACK_LOCATION)) {

            dprintf(
                "dumpIrpListEntry: Cannot read IoStackLocation at %08lx\n",
                tempStack
                );
            return;

        }

        stat = ReadMemory(
            (ULONG_PTR) irpStack.DeviceObject,
            &deviceObject,
            sizeof(DEVICE_OBJECT),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(DEVICE_OBJECT)) {

            dprintf(
                "dumpIrpListEntry: Cannot read DeviceObject at %08lx\n",
                irpStack.DeviceObject
                );
            return;

        }

        stat = ReadMemory(
            (ULONG_PTR) deviceObject.DeviceExtension,
            &deviceExtension,
            sizeof(DEVICE_EXTENSION),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(DEVICE_EXTENSION)) {

            dprintf(
                "dumpIrpListEntry: Cannot read DeviceExtension at %08lx\n",
                deviceObject.DeviceExtension
                );
            return;

        }

        memset( Buffer, '0', 2048 );
        stat = ReadMemory(
            (ULONG_PTR) deviceExtension.DeviceID,
            Buffer,
            256,
            &returnLength
            );
        if (stat && Buffer[0] != '\0' && returnLength != 0) {

            dprintf(
                "    Irp: %08x Device: %08lx (%s)\n",
                irpAddress,
                irpStack.DeviceObject,
                Buffer
                );

        } else {

            dprintf(
                "    Irp: %08x Device: %08lx\n",
                irpAddress,
                irpStack.DeviceObject
                );

        }

        //
        // Next item on the queue
        //
        ListEntry = irp.Tail.Overlay.ListEntry.Flink;

    }

}

VOID
dumpNSObject(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This function dumps a Name space object

Arguments:

    Address     - Where to find the object
    Verbose     - Should the object be dumped as well?
    IndentLevel - How much to indent

Return Value:

    None

--*/
{
    BOOL    b;
    NSOBJ   ns;
    UCHAR   buffer[5];
    UCHAR   indent[80];

    //
    // Init the buffers
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    buffer[4] = '\0';

    //
    // First step is to read the root NS
    //
    b = ReadMemory(
        Address,
        &ns,
        sizeof(NSOBJ),
        NULL
        );
    if (!b) {

        dprintf("%sdumpNSObject: could not read %x\n", indent,Address );
        return;

    }

    if (ns.dwNameSeg != 0) {

        memcpy( buffer, &(ns.dwNameSeg), 4 );

    } else {

        sprintf( buffer, "    ");

    }

    dprintf(
        "%sNameSpace Object %s (%08lx) - Device %08lx\n",
        indent,
        buffer,
        Address,
        ns.Context
        );
    if (Verbose & VERBOSE_NSOBJ) {

        dprintf(
            "%s  Flink %08lx  Blink  %08lx  Parent %08lx  Child %08lx\n",
            indent,
            ns.list.plistNext,
            ns.list.plistPrev,
            ns.pnsParent,
            ns.pnsFirstChild
            );

    }
    dprintf(
        "%s  Value %08lx  Length %08lx  Buffer %08lx  Flags %08lx",
        indent,
        ns.ObjData.uipDataValue,
        ns.ObjData.dwDataLen,
        ns.ObjData.pbDataBuff,
        ns.ObjData.dwfData
        );
    if (ns.ObjData.dwfData & DATAF_BUFF_ALIAS) {

        dprintf("  Alias" );

    }
    if (ns.ObjData.dwfData & DATAF_GLOBAL_LOCK) {

        dprintf("  Lock");

    }
    dprintf("\n");

    dumpObject( Address, &(ns.ObjData), Verbose, IndentLevel + 4);
}

VOID
dumpNSTree(
    IN  ULONG_PTR   Address,
    IN  ULONG       Level
    )
/*++

Routine Description:

    This thing dumps the NS tree

Arguments:

    Address - Where to find the root node --- we start dumping at the children

Return Value:

    None

--*/
{
    BOOL        end = FALSE;
    BOOL        b;
    NSOBJ       ns;
    UCHAR       buffer[5];
    ULONG_PTR   next;
    ULONG       back;
    ULONG_PTR   m1 = 0;
    ULONG_PTR   m2 = 0;
    ULONG       reason;
    ULONG       dataBuffSize;

    buffer[4] = '\0';

    //
    // Indent
    //
    for (m1 = 0; m1 < Level; m1 ++) {

        dprintf("| ");

    }

    //
    // First step is to read the root NS
    //
    b = ReadMemory(
        Address,
        &ns,
        sizeof(NSOBJ),
        NULL
        );
    if (!b) {

        dprintf("dumpNSTree: could not read %x\n", Address );
        return;

    }

    if (ns.dwNameSeg != 0) {

        memcpy( buffer, &(ns.dwNameSeg), 4 );
        dprintf("%4s ", buffer );

    } else {

        dprintf("     " );

    }
    dprintf(
        "(%08x) - ", Address );

    if (ns.Context != 0) {

        dprintf("Device %08lx\n", ns.Context );

    } else {

        //
        // We need to read the pbDataBuff here
        //
        if (ns.ObjData.pbDataBuff != 0) {

            dataBuffSize = (ns.ObjData.dwDataLen > 2047 ?
                2047 : ns.ObjData.dwDataLen
                );
            b = ReadMemory(
                (ULONG_PTR) ns.ObjData.pbDataBuff,
                Buffer,
                dataBuffSize,
                NULL
                );
            if (!b) {

                dprintf(
                    "dumpNSTree: could not read %x\n",
                    ns.ObjData.pbDataBuff
                    );
                return;

            }

        }
        switch(ns.ObjData.dwDataType) {
            default:
            case OBJTYPE_UNKNOWN:       dprintf("Unknown\n");           break;
            case OBJTYPE_INTDATA:
                dprintf("Integer - %lx\n", ns.ObjData.uipDataValue);
                break;
            case OBJTYPE_STRDATA:
                Buffer[dataBuffSize+1] = '\0';
                dprintf(
                     "String - %s\n",
                     Buffer
                     );
                break;
            case OBJTYPE_BUFFDATA:
                dprintf(
                     "Buffer - %08lx L=%04x\n",
                     ns.ObjData.pbDataBuff,
                     ns.ObjData.dwDataLen
                     );
                break;
            case OBJTYPE_PKGDATA: {

                PPACKAGEOBJ package = (PPACKAGEOBJ) Buffer;

                dprintf("Package - NumElements %x\n",package->dwcElements);
                break;

            }
            case OBJTYPE_FIELDUNIT:{

                PFIELDUNITOBJ   fieldUnit = (PFIELDUNITOBJ) Buffer;

                dprintf(
                    "FieldUnit - Parent %x Offset %x Start %x "
                    "Num %x Flags %x\n",
                    fieldUnit->pnsFieldParent,
                    fieldUnit->FieldDesc.dwByteOffset,
                    fieldUnit->FieldDesc.dwStartBitPos,
                    fieldUnit->FieldDesc.dwNumBits,
                    fieldUnit->FieldDesc.dwFieldFlags
                    );
                break;

            }
            case OBJTYPE_DEVICE:
                dprintf("Device\n");
                break;
            case OBJTYPE_EVENT:
                dprintf("Event - PKEvent %x\n", ns.ObjData.pbDataBuff);
                break;
            case OBJTYPE_METHOD: {

                PMETHODOBJ  method = (PMETHODOBJ) Buffer;

                dprintf(
                     "Method - Flags %x Start %08lx Len %x\n",
                     method->bMethodFlags,
                     (ULONG_PTR) method->abCodeBuff - (ULONG_PTR) method +
                        (ULONG_PTR) ns.ObjData.pbDataBuff,
                     (ULONG) ns.ObjData.dwDataLen - sizeof(METHODOBJ) +
                        ANYSIZE_ARRAY
                     );
                 break;

            }
            case OBJTYPE_OPREGION: {

                POPREGIONOBJ    opRegion = (POPREGIONOBJ) Buffer;

                dprintf(
                    "Opregion - RegionsSpace=%08x OffSet=%x Len=%x\n",
                    opRegion->bRegionSpace,
                    opRegion->uipOffset,
                    opRegion->dwLen
                    );
                break;

            }
            case OBJTYPE_BUFFFIELD: {

                PBUFFFIELDOBJ   field   = (PBUFFFIELDOBJ) Buffer;

                dprintf(
                    "Buffer Field Ptr=%x Len=%x Offset=%x Start=%x"
                    "NumBits=%x Flgas=%x\n",
                    field->pbDataBuff,
                    field->dwBuffLen,
                    field->FieldDesc.dwByteOffset,
                    field->FieldDesc.dwStartBitPos,
                    field->FieldDesc.dwNumBits,
                    field->FieldDesc.dwFieldFlags
                    );
                break;

            }
            case OBJTYPE_FIELD: {

                dprintf("Field\n");
                break;

            }
            case OBJTYPE_INDEXFIELD:    dprintf("Index Field\n");       break;

            case OBJTYPE_MUTEX:         dprintf("Mutex\n");             break;
            case OBJTYPE_POWERRES:      dprintf("Power Resource\n");    break;
            case OBJTYPE_PROCESSOR:     dprintf("Processor\n");         break;
            case OBJTYPE_THERMALZONE:   dprintf("Thermal Zone\n");      break;
            case OBJTYPE_DDBHANDLE:     dprintf("DDB Handle\n");        break;
            case OBJTYPE_DEBUG:         dprintf("Debug\n");             break;
            case OBJTYPE_OBJALIAS:      dprintf("Object Alias\n");      break;
            case OBJTYPE_DATAALIAS:     dprintf("Data Alias\n");        break;
            case OBJTYPE_BANKFIELD:     dprintf("Bank Field\n");        break;

        }

    }
    m1 = next = (ULONG_PTR) ns.pnsFirstChild;

    while (next != 0 && end == FALSE) {

        if (CheckControlC()) {

            break;

        }

        b = ReadMemory(
            next,
            &ns,
            sizeof(NSOBJ),
            NULL
            );
        if (!b) {

            dprintf("dumpNSTree: could not read %x\n", next );
            return;

        }

        dumpNSTree( next, Level + 1);

        //
        // Do the end check tests
        //
        if ( m2 == 0) {

            m2 = (ULONG_PTR) ns.list.plistPrev;

        } else if (m1 == (ULONG_PTR) ns.list.plistNext) {

            end = TRUE;
            reason = 1;

        } else if (m2 == next) {

            end = TRUE;
            reason = 2;
        }

        next = (ULONG_PTR) ns.list.plistNext;

    }

}

VOID
dumpObject(
    IN  ULONG_PTR   Address,
    IN  POBJDATA    Object,
    IN  ULONG       Verbose,
    IN  ULONG       IndentLevel
    )
/*++

Routine Description:

    This dumps an Objdata so that it can be understand --- great for debugging some of the
    AML code

Arguments:

    Address - Where the Object is located
    Object  - Pointer to the object

Return Value:

    None

--*/
{
    BOOL        b;
    NTSTATUS    status;
    UCHAR       buffer[2048];
    UCHAR       indent[80];
    ULONG       max;
    ULONG       returnLength;

    //
    // Init the buffers
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    dprintf("%sObject Data - %08lx Type - ", indent, Address );

    //
    // First step is to read whatever the buffer points to, if it
    // points to something
    //
    if (Object->pbDataBuff != 0) {

        max = (Object->dwDataLen > 2047 ? 2047 : Object->dwDataLen );
        b = ReadMemory(
            (ULONG_PTR) Object->pbDataBuff,
            buffer,
            max,
            &returnLength
            );
        if (!b || returnLength != max) {

            dprintf(
                "%sdumpObject: Could not read buffer %08lx (%d) %x<->%x\n",
                indent,
                Object->pbDataBuff,
                b,
                max,
                returnLength
                );
            return;

        }

    }
    switch( Object->dwDataType ) {
        case OBJTYPE_INTDATA:
            dprintf(
                "%02x <Integer> Value=%08lx\n",
                Object->dwDataType,
                Object->uipDataValue
                );
            break;
        case OBJTYPE_STRDATA:
            buffer[max] = '\0';
            dprintf(
                "%02x <String> String=%s\n",
                Object->dwDataType,
                buffer
                );
            break;
        case OBJTYPE_BUFFDATA:
            dprintf(
                "%02x <Buffer> Ptr=%08lx Length = %2x\n",
                Object->dwDataType,
                Object->pbDataBuff,
                Object->dwDataLen
                );
            break;
        case OBJTYPE_PKGDATA: {

            PPACKAGEOBJ package = (PPACKAGEOBJ) buffer;
            ULONG       i = 0;
            ULONG       j = package->dwcElements;

            dprintf(
                "%02x <Package> NumElements=%02x\n",
                Object->dwDataType,
                j
                );

            if (Verbose & VERBOSE_OBJECT) {

                for (; i < j; i++) {

                    dumpObject(
                        (ULONG_PTR) &(package->adata[i]) - (ULONG_PTR) package +
                        (ULONG_PTR) Object->pbDataBuff,
                        &(package->adata[i]),
                        Verbose,
                        IndentLevel+ 2
                        );

                }

            }

            break;

        }
        case OBJTYPE_FIELDUNIT: {

            PFIELDUNITOBJ   fieldUnit = (PFIELDUNITOBJ) buffer;

            dprintf(
                "%02x <Field Unit> Parent=%08lx Offset=%08lx Start=%08x "
                "Num=%x Flags=%x\n",
                Object->dwDataType,
                fieldUnit->pnsFieldParent,
                fieldUnit->FieldDesc.dwByteOffset,
                fieldUnit->FieldDesc.dwStartBitPos,
                fieldUnit->FieldDesc.dwNumBits,
                fieldUnit->FieldDesc.dwFieldFlags
                );
            break;

        }
        case OBJTYPE_DEVICE:
            dprintf(
                "%02x <Device>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_EVENT:
            dprintf(
                "%02x <Event> PKEvent=%08lx\n",
                Object->dwDataType,
                Object->pbDataBuff
                );
            break;
        case OBJTYPE_METHOD: {

            PMETHODOBJ  method = (PMETHODOBJ) buffer;

            max = Object->dwDataLen - sizeof(METHODOBJ) + ANYSIZE_ARRAY;
            dprintf(
                "%02x <Method> Flags=%x Start=%x Len=%x\n",
                Object->dwDataType,
                method->bMethodFlags,
                (ULONG_PTR) method->abCodeBuff - (ULONG_PTR) method +
                (ULONG_PTR) Object->pbDataBuff,
                max
                );
            break;

        }
        case OBJTYPE_MUTEX:

            dprintf(
                "%02x <Mutex> Mutex=%08lx\n",
                Object->dwDataType,
                Object->pbDataBuff
                );
            break;

        case OBJTYPE_OPREGION: {

            POPREGIONOBJ    opRegion = (POPREGIONOBJ) buffer;

            dprintf(
                "%02x <Operational Region> RegionSpace=%08x OffSet=%x "
                "Len=%x\n",
                Object->dwDataType,
                opRegion->bRegionSpace,
                opRegion->uipOffset,
                opRegion->dwLen
                );
            break;

        }

        case OBJTYPE_POWERRES: {

            PPOWERRESOBJ    powerRes = (PPOWERRESOBJ) buffer;

            dprintf(
                "%02x <Power Resource> SystemLevel=S%d Order=%x\n",
                Object->dwDataType,
                powerRes->bSystemLevel,
                powerRes->bResOrder
                );
            break;

        }

        case OBJTYPE_PROCESSOR: {

            PPROCESSOROBJ   proc = (PPROCESSOROBJ) buffer;

            dprintf(
                "%02x <Processor> AcpiID=%x PBlk=%x PBlkLen=%x\n",
                Object->dwDataType,
                proc->bApicID,
                proc->dwPBlk,
                proc->dwPBlkLen
                );
            break;

        }

        case OBJTYPE_THERMALZONE:
            dprintf(
                "%02x <Thermal Zone>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_BUFFFIELD: {

            PBUFFFIELDOBJ   field   = (PBUFFFIELDOBJ) buffer;

            dprintf(
                "%02x <Buffer Field> Ptr=%x Len=%x Offset=%x Start=%x "
                "NumBits=%x Flags=%x\n",
                Object->dwDataType,
                field->pbDataBuff,
                field->dwBuffLen,
                field->FieldDesc.dwByteOffset,
                field->FieldDesc.dwStartBitPos,
                field->FieldDesc.dwNumBits,
                field->FieldDesc.dwFieldFlags
                );
            break;

        }

        case OBJTYPE_DDBHANDLE:
            dprintf(
                "%02x <DDB Handle> Handle=%x\n",
                Object->dwDataType,
                Object->pbDataBuff
                );
            break;
        case OBJTYPE_DEBUG:
            dprintf(
                "%02x <Internal Debug>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_OBJALIAS:

            dprintf(
                "%02x <Internal Object Alias> NS Object=%x\n",
                Object->dwDataType,
                Object->uipDataValue
                );
            dumpNSObject( Object->uipDataValue, Verbose, IndentLevel + 2 );
            break;
        case OBJTYPE_DATAALIAS: {

            OBJDATA     objData;

            dprintf(
                "%02x <Internal Data Alias> Data Object=%x\n",
                Object->dwDataType,
                Object->uipDataValue
                );

            b = ReadMemory(
                (ULONG) Object->uipDataValue,
                &objData,
                sizeof(OBJDATA),
                NULL
                );
            if (!b) {

                dprintf(
                    "dumpObject: could not read %x\n",
                    Object->uipDataValue
                    );
                return;

            }
            dumpObject(
                (ULONG) Object->uipDataValue,
                &objData,
                Verbose,
                IndentLevel + 2
                );
            break;

        }
        case OBJTYPE_BANKFIELD:
            dprintf(
                "%02x <Internal Bank Field>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_FIELD:
            dprintf(
                "%02x <Internal Field>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_INDEXFIELD:
            dprintf(
                "%02x <Index Field>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_UNKNOWN:
        default:
            dprintf(
                "%02x <Unknown>\n",
                Object->dwDataType
                );
            break;
    }
}


VOID
dumpPObject(
    IN  ULONG_PTR   Address,
    IN  ULONG       Verbose,
    IN  ULONG       IndentLevel
    )
/*++

Routine Description:

    This is a wrapper for dumpObject


--*/
{
    BOOL    result;
    OBJDATA objdata;
    ULONG   returnLength;

    result = ReadMemory(
        Address,
        &objdata,
        sizeof(OBJDATA),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(OBJDATA) ) {

        UCHAR   indent[80];

        IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
        memset( indent, ' ', IndentLevel );
        indent[IndentLevel] = '\0';

        dprintf(
            "%sdumpPObject: Could not OBJDATA %08lx\n",
            indent,
            Address
            );
        return;

    }

    dumpObject(
        Address,
        &objdata,
        Verbose,
        IndentLevel
        );
    return;

}

PUCHAR
TempToKelvins(
    IN  ULONG   Temp
    )
{
    static  UCHAR buffer[80];

    sprintf( buffer, "%d.%d", (Temp / 10 ), (Temp % 10) );
    return buffer;
}

PUCHAR
TimeToSeconds(
    IN  ULONG   Time
    )
{
    static  UCHAR buffer[80];

    sprintf( buffer, "%d.%d", (Time / 10 ), (Time % 10) );
    return buffer;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\kdutil.c ===
/*** kdutil.c - KD Extension Utility Functions
 *
 *  This module contains KD Extension Utility Functions.
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/22/99
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  MemZero - Fill target buffer with zeros
 *
 *  ENTRY
 *      uipAddr - target buffer address
 *      dwSize - target buffer size
 *
 *  EXIT
 *      None
 */

VOID MemZero(ULONG_PTR uipAddr, ULONG dwSize)
{
    PUCHAR pbBuff;
    //
    // LPTR will zero init the buffer
    //
    if ((pbBuff = LocalAlloc(LPTR, dwSize)) != NULL)
    {
        if (!WriteMemory(uipAddr, pbBuff, dwSize, NULL))
        {
            DBG_ERROR(("MemZero: failed to write memory"));
        }
        LocalFree(pbBuff);
    }
    else
    {
        DBG_ERROR(("MemZero: failed to allocate buffer"));
    }
}       //MemZero

/***EP  ReadMemByte - Read a byte from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

BYTE ReadMemByte(ULONG_PTR uipAddr)
{
    BYTE bData = 0;

    if (!ReadMemory(uipAddr, &bData, sizeof(bData), NULL))
    {
        DBG_ERROR(("ReadMemByte: failed to read address %x", uipAddr));
    }

    return bData;
}       //ReadMemByte

/***EP  ReadMemWord - Read a word from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

WORD ReadMemWord(ULONG_PTR uipAddr)
{
    WORD wData = 0;

    if (!ReadMemory(uipAddr, &wData, sizeof(wData), NULL))
    {
        DBG_ERROR(("ReadMemWord: failed to read address %x", uipAddr));
    }

    return wData;
}       //ReadMemWord

/***EP  ReadMemDWord - Read a dword from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

DWORD ReadMemDWord(ULONG_PTR uipAddr)
{
    DWORD dwData = 0;

    if (!ReadMemory(uipAddr, &dwData, sizeof(dwData), NULL))
    {
        DBG_ERROR(("ReadMemDWord: failed to read address %x", uipAddr));
    }

    return dwData;
}       //ReadMemDWord

/***EP  ReadMemUlongPtr - Read a ulong ptr from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

ULONG_PTR ReadMemUlongPtr(ULONG_PTR uipAddr)
{
    ULONG_PTR uipData = 0;

    if (!ReadMemory(uipAddr, &uipData, sizeof(uipData), NULL))
    {
        DBG_ERROR(("ReadMemUlongPtr: failed to read address %x", uipAddr));
    }

    return uipData;
}       //ReadMemUlongPtr

/***LP  GetObjBuff - Allocate and read object buffer
 *
 *  ENTRY
 *      pdata -> object data
 *
 *  EXIT
 *      return the allocated object buffer pointer
 */

PVOID LOCAL GetObjBuff(POBJDATA pdata)
{
    PVOID pbuff;

    if ((pbuff = LocalAlloc(LPTR, pdata->dwDataLen)) == NULL)
    {
        DBG_ERROR(("failed to allocate object buffer (size=%d)",
                   pdata->dwDataLen));
    }
    else if (!ReadMemory((ULONG_PTR)pdata->pbDataBuff,
                         pbuff,
                         pdata->dwDataLen,
                         NULL))
    {
        DBG_ERROR(("failed to read object buffer at %x", pdata->pbDataBuff));
        LocalFree(pbuff);
        pbuff = NULL;
    }

    return pbuff;
}       //GetObjBuff

/***LP  GetNSObj - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> object path string
 *      pnsScope - object scope to start the search (NULL means root)
 *      puipns -> to hold the pnsobj address if found
 *      pns -> buffer to hold the object found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_ code
 */

LONG LOCAL GetNSObj(PSZ pszObjPath, PNSOBJ pnsScope, PULONG_PTR puipns,
                    PNSOBJ pns, ULONG dwfNS)
{
    LONG rc = DBGERR_NONE;
    BOOLEAN fSearchUp = (BOOLEAN)(!(dwfNS & NSF_LOCAL_SCOPE) &&
                                  (pszObjPath[0] != '\\') &&
                                  (pszObjPath[0] != '^') &&
                                  (STRLEN(pszObjPath) <= sizeof(NAMESEG)));
    BOOLEAN fMatch = TRUE;
    PSZ psz;
    NSOBJ NSObj, NSChildObj;

    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        pnsScope = NULL;
    }
    else
    {
        for (psz = pszObjPath;
             (*psz == '^') && (pnsScope != NULL) &&
             (pnsScope->pnsParent != NULL);
             psz++)
        {
            if (!ReadMemory((ULONG_PTR)pnsScope->pnsParent,
                            &NSObj,
                            sizeof(NSObj),
                            NULL))
            {
                DBG_ERROR(("failed to read parent object at %x",
                           pnsScope->pnsParent));
                rc = DBGERR_CMD_FAILED;
                break;
            }
            else
            {
                pnsScope = &NSObj;
            }
        }

        if ((rc == DBGERR_NONE) && (*psz == '^'))
        {
            if (dwfNS & NSF_WARN_NOTFOUND)
            {
                DBG_ERROR(("object %s not found", pszObjPath));
            }
            rc = DBGERR_CMD_FAILED;
        }
    }

    if ((rc == DBGERR_NONE) && (pnsScope == NULL))
    {
        if ((*puipns = READSYMULONGPTR("gpnsNameSpaceRoot")) == 0)
        {
            DBG_ERROR(("failed to get root object address"));
            rc = DBGERR_CMD_FAILED;
        }
        else if (!ReadMemory(*puipns, &NSObj, sizeof(NSObj), NULL))
        {
            DBG_ERROR(("failed to read NameSpace root object at %x", *puipns));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            pnsScope = &NSObj;
        }
    }

    while ((rc == DBGERR_NONE) && (*psz != '\0'))
    {
        if (pnsScope->pnsFirstChild == NULL)
        {
            fMatch = FALSE;
        }
        else
        {
            PSZ pszEnd = STRCHR(psz, '.');
            ULONG dwLen = (ULONG)(pszEnd? (pszEnd - psz): STRLEN(psz));

            if (dwLen > sizeof(NAMESEG))
            {
                DBG_ERROR(("invalid name path %s", pszObjPath));
                rc = DBGERR_CMD_FAILED;
            }
            else
            {
                NAMESEG dwName = NAMESEG_BLANK;
                BOOLEAN fFound = FALSE;
                ULONG_PTR uip;
                ULONG_PTR uipFirstChild = (ULONG_PTR)pnsScope->pnsFirstChild;

                MEMCPY(&dwName, psz, dwLen);
                //
                // Search all siblings for a matching NameSeg.
                //
                for (uip = uipFirstChild;
                     (uip != 0) &&
                     ReadMemory(uip, &NSChildObj, sizeof(NSObj), NULL);
                     uip = ((ULONG_PTR)NSChildObj.list.plistNext ==
                            uipFirstChild)?
                           0: (ULONG_PTR)NSChildObj.list.plistNext)
                {
                    if (NSChildObj.dwNameSeg == dwName)
                    {
                        *puipns = uip;
                        fFound = TRUE;
                        NSObj = NSChildObj;
                        pnsScope = &NSObj;
                        break;
                    }
                }

                if (fFound)
                {
                    psz += dwLen;
                    if (*psz == '.')
                    {
                        psz++;
                    }
                }
                else
                {
                    fMatch = FALSE;
                }
            }
        }

        if ((rc == DBGERR_NONE) && !fMatch)
        {
            if (fSearchUp && (pnsScope->pnsParent != NULL))
            {
                if (!ReadMemory((ULONG_PTR)pnsScope->pnsParent,
                                &NSObj,
                                sizeof(NSObj),
                                NULL))
                {
                    DBG_ERROR(("failed to read parent object at %x",
                               pnsScope->pnsParent));
                    rc = DBGERR_CMD_FAILED;
                }
                else
                {
                    fMatch = TRUE;
                    pnsScope = &NSObj;
                }
            }
            else
            {
                if (dwfNS & NSF_WARN_NOTFOUND)
                {
                    DBG_ERROR(("object %s not found", pszObjPath));
                }
                rc = DBGERR_CMD_FAILED;
            }
        }
    }

    if (rc != DBGERR_NONE)
    {
        *puipns = 0;
    }
    else if (pns != NULL)
    {
        MEMCPY(pns, pnsScope, sizeof(NSObj));
    }

    return rc;
}       //GetNSObj

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext)
{
    ULONG dwLen;
    UCHAR bFollowCnt, i;

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (ULONG)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (UCHAR)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (ULONG)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    return dwLen;
}       //ParsePackageLen

/***LP  NameSegString - convert a NameSeg to an ASCIIZ stri
 *
 *  ENTRY
 *      dwNameSeg - NameSeg
 *
 *  EXIT
 *      returns string
 */

PSZ LOCAL NameSegString(ULONG dwNameSeg)
{
    static char szNameSeg[sizeof(NAMESEG) + 1] = {0};

    STRCPYN(szNameSeg, (PSZ)&dwNameSeg, sizeof(NAMESEG));

    return szNameSeg;
}       //NameSegString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\kdutil.h ===
#define ConPrintf               dprintf
#define MZERO                   MemZero
#define ADDROF(s)               GetExpression("ACPI!" s)
#define FIELDADDROF(s,t,f)      (ULONG_PTR)(ADDROF(s) + FIELD_OFFSET(t, f))
#define READMEMBYTE             ReadMemByte
#define READMEMWORD             ReadMemWord
#define READMEMDWORD            ReadMemDWord
#define READMEMULONGPTR         ReadMemUlongPtr
#define READSYMBYTE(s)          ReadMemByte(ADDROF(s))
#define READSYMWORD(s)          ReadMemWord(ADDROF(s))
#define READSYMDWORD(s)         ReadMemDWord(ADDROF(s))
#define READSYMULONGPTR(s)      ReadMemUlongPtr(ADDROF(s))
#define WRITEMEMBYTE(a,d)       WriteMemory(a, &(d), sizeof(BYTE), NULL)
#define WRITEMEMWORD(a,d)       WriteMemory(a, &(d), sizeof(WORD), NULL)
#define WRITEMEMDWORD(a,d)      WriteMemory(a, &(d), sizeof(DWORD), NULL)
#define WRITEMEMULONGPTR(a,d)   WriteMemory(a, &(d), sizeof(ULONG_PTR), NULL)
#define WRITESYMBYTE(s,d)       WRITEMEMBYTE(ADDROF(s), d)
#define WRITESYMWORD(s,d)       WRITEMEMWORD(ADDROF(s), d)
#define WRITESYMDWORD(s,d)      WRITEMEMDWORD(ADDROF(s), d)
#define WRITESYMULONGPTR(s,d)   WRITEMEMULONGPTR(ADDROF(s), d)
#define TRACENAME(s)
#define ENTER(n,e)
#define EXIT(n,e)

VOID MemZero(ULONG_PTR uipAddr, ULONG dwSize);
BYTE ReadMemByte(ULONG_PTR uipAddr);
WORD ReadMemWord(ULONG_PTR uipAddr);
DWORD ReadMemDWord(ULONG_PTR uipAddr);
ULONG_PTR ReadMemUlongPtr(ULONG_PTR uipAddr);
PVOID LOCAL GetObjBuff(POBJDATA pdata);
LONG LOCAL GetNSObj(PSZ pszObjPath, PNSOBJ pnsScope, PULONG_PTR puipns,
                    PNSOBJ pns, ULONG dwfNS);
ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext);
PSZ LOCAL NameSegString(ULONG dwNameSeg);

VOID STDCALL AMLIDbgExecuteCmd(PSZ pszCmd);
LONG LOCAL AMLIDbgHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE
#define SPEC_VER    100

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <zwapi.h>
#include <pnp.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>

#include <memory.h>

#include <wmistr.h>
#include <wmilib.h>

//
// This header is part of the global one, but is only required because of
// thermal.h
//
#include <poclass.h>

//
// Load the debugger version of the files
//
#define DEBUGGER

//
// These are the ACPI specific include files
//
#include <acpitabl.h>
#include <aml.h>
#include <amli.h>
#include <acpi.h>
#include <acpipriv.h>
#include <acpidbg.h>
#include <acpiregs.h>
#include <dockintf.h>
#include <ospower.h>
#include <acpiosnt.h>
#include <buildsrc.h>
#include <res_bios.h>
#include <amlipriv.h>
#include <ctxt.h>
#include <thermal.h>
#include <arbiter.h>
#include <irqarb.h>
#include <ntacpi.h>
#include <cmdarg.h>
#include <amldebug.h>
#include <debugger.h>
#include <strlib.h>
#include "build.h"
#include "flags.h"
#include "kdext.h"
#include "stack.h"
#include "table.h"
//#include "udata.h"
//#include "udebug.h"
//#include "ulist.h"
//#include "unamespac.h"
#include "unasm.h"
#include "kdutil.h"


// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"


VOID
dumpPnPResources(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This routine processes the ACPI version of a PnP resource list given
    the address that it starts at

Arguments:

    Address - The Starting address

Return Value:

    NULL

--*/
{
    BOOL    success;
    PUCHAR  dataBuffer = NULL;
    UCHAR   currentTag;
    ULONG_PTR currentAddress = Address;
    ULONG   i;
    ULONG   indentLevel = 0;
    ULONG   returnLength;
    ULONG   tagCount = 0;
    USHORT  increment;

    //
    // repeat forever
    //
    while (1) {

        //
        // Allow a way to end this
        //
        if (CheckControlC()) {

            break;

        }

        //
        // Read the current tag
        //
        success = ReadMemory(
            currentAddress,
            &currentTag,
            sizeof(UCHAR),
            &returnLength
            );
        if (!success || returnLength != sizeof(UCHAR)) {

            dprintf(
                "dumpPnPResources: could not read tag at 0x%08lx\n",
                currentAddress
                );
            return;

        }

        //
        // Determine what we are looking at
        //
        if ( !(currentTag & LARGE_RESOURCE_TAG)) {

            //
            // We are looking at a small tag
            //
            increment = (USHORT) (currentTag & SMALL_TAG_SIZE_MASK) + 1;
            currentTag &= SMALL_TAG_MASK;

        } else {

            //
            // We are looking at a large Tag. We must read the length as
            // the next short in memory
            //
            success = ReadMemory(
                currentAddress + 1,
                &increment,
                sizeof(USHORT),
                &returnLength
                );
            if (!success || returnLength != sizeof(USHORT)) {

                dprintf(
                    "dumpPnPResources: could not read increment at 0x%08lx\n",
                    currentAddress + 1
                    );
                break;

            }

            //
            // Account for the increment
            //
            increment += 3;

        }

        //
        // Allocate space for the buffer
        //
        if (increment > 1) {

            dataBuffer = LocalAlloc( LPTR, increment);
            if (dataBuffer == NULL) {

                dprintf(
                    "dumpPnPResources: could not allocate 0x%x bytes\n",
                    (increment - 1)
                    );

            }

            //
            // Read the data into the buffer
            //
            success = ReadMemory(
                currentAddress,
                dataBuffer,
                increment,
                &returnLength
                );
            if (!success || returnLength != (ULONG) increment) {

                dprintf(
                    "dumpPnPResources: read buffer at 0x%08lx (0x%x)\n",
                    currentAddress,
                    increment
                    );
                LocalFree( dataBuffer );
                return;

            }

        }

        //
        // Indent the tag
        //
        for (i = 0; i < indentLevel; i++) {

            dprintf("| ");

        }

        //
        // What tag are we looking at
        //
        switch (currentTag) {
            case TAG_IRQ: {

                PPNP_IRQ_DESCRIPTOR res = (PPNP_IRQ_DESCRIPTOR) dataBuffer;
                USHORT              mask = res->IrqMask;
                USHORT              interrupt = 0;

                dprintf("%d - TAG_IRQ -", tagCount );
                for( ;mask; interrupt++, mask >>= 1) {

                    if (mask & 1) {

                        dprintf(" %d", interrupt );

                    }

                }
                if ( (res->Tag & SMALL_TAG_SIZE_MASK) == 3) {

                    if (res->Information & PNP_IRQ_LATCHED) {

                        dprintf(" Lat");

                    }
                    if (res->Information & PNP_IRQ_LEVEL) {

                        dprintf(" Lvl");

                    }
                    if (res->Information & PNP_IRQ_SHARED) {

                        dprintf(" Shr");

                    } else {

                        dprintf(" Exc");

                    }

                } else {

                    dprintf(" Edg Sha");

                }
                dprintf("\n");
                break;

            }
            case TAG_EXTENDED_IRQ: {

                PPNP_EXTENDED_IRQ_DESCRIPTOR    res =
                    (PPNP_EXTENDED_IRQ_DESCRIPTOR) dataBuffer;
                UCHAR                           tableCount = 0;
                UCHAR                           tableSize = res->TableSize;

                dprintf("%d - TAG_EXTENDED_IRQ -", tagCount );
                for (; tableCount < tableSize; tableCount++) {

                    dprintf(" %d", res->Table[tableCount] );

                }
                if (res->Flags & PNP_EXTENDED_IRQ_MODE) {

                    dprintf(" Lat");

                }
                if (res->Flags & PNP_EXTENDED_IRQ_POLARITY ) {

                    dprintf(" Edg");

                }
                if (res->Flags & PNP_EXTENDED_IRQ_SHARED) {

                    dprintf(" Shr");

                } else {

                    dprintf(" Exc");

                }
                if (res->Flags & PNP_EXTENDED_IRQ_RESOURCE_CONSUMER_ONLY) {

                    dprintf(" Con");

                } else {

                    dprintf(" Prod Con");

                }
                dprintf("\n");
                break;

            }
            case TAG_DMA: {

                PPNP_DMA_DESCRIPTOR res = (PPNP_DMA_DESCRIPTOR) dataBuffer;
                UCHAR               channel = 0;
                UCHAR               mask = res->ChannelMask;

                dprintf("%d - TAG_DMA -", tagCount );
                for (; mask; channel++, mask >>= 1) {

                    if (mask & 1) {

                        dprintf(" %d", channel);

                    }

                }
                switch( (res->Flags & PNP_DMA_SIZE_MASK) ) {
                case PNP_DMA_SIZE_8:
                    dprintf(" 8bit");
                    break;
                case PNP_DMA_SIZE_8_AND_16:
                    dprintf(" 8-16bit");
                    break;
                case PNP_DMA_SIZE_16:
                    dprintf(" 16bit");
                    break;
                case PNP_DMA_SIZE_RESERVED:
                default:
                    dprintf(" ??bit");
                    break;
                }
                if (res->Flags & PNP_DMA_BUS_MASTER) {
                    dprintf(" BM");

                }
                switch( (res->Flags & PNP_DMA_TYPE_MASK) ) {
                default:
                case PNP_DMA_TYPE_COMPATIBLE:
                    dprintf(" Com");
                    break;
                case PNP_DMA_TYPE_A:
                    dprintf(" A");
                    break;
                case PNP_DMA_TYPE_B:
                    dprintf(" B");
                    break;
                case PNP_DMA_TYPE_F:
                    dprintf(" F");
                }
                dprintf("\n");
                break;

            }
            case TAG_START_DEPEND:

                indentLevel++;
                dprintf("%d - TAG_START_DEPEND\n", tagCount);
                break;

            case TAG_END_DEPEND:

                indentLevel = 0;
                dprintf("%d - TAG_END_DEPEND\n", tagCount);
                break;

            case TAG_IO: {

                PPNP_PORT_DESCRIPTOR    res = (PPNP_PORT_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_IO - 0x%x-0x%x A:0x%x L:0x%x",
                    tagCount,
                    res->MinimumAddress,
                    res->MaximumAddress,
                    res->Alignment,
                    res->Length
                    );
                switch (res->Information & PNP_PORT_DECODE_MASK) {
                default:
                case PNP_PORT_10_BIT_DECODE:
                    dprintf(" 10bit");
                    break;
                case PNP_PORT_16_BIT_DECODE:
                    dprintf(" 16bit");
                    break;
                }
                dprintf("\n");
                break;

            }
            case TAG_IO_FIXED: {

                PPNP_FIXED_PORT_DESCRIPTOR  res =
                    (PPNP_FIXED_PORT_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_FIXED_IO - 0x%x L:0x%x\n",
                    tagCount,
                    res->MinimumAddress,
                    res->Length
                    );
                break;

            }
            case TAG_MEMORY: {

                PPNP_MEMORY_DESCRIPTOR  res =
                    (PPNP_MEMORY_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_MEMORY24 - 0x%x-0x%x A:0x%x L:0x%x",
                    tagCount,
                    res->MinimumAddress,
                    res->MaximumAddress,
                    res->Alignment,
                    res->MemorySize
                    );

                if (res->Information & PNP_MEMORY_READ_WRITE) {

                    dprintf(" RW");

                } else {

                    dprintf(" R");

                }
                break;

            }
            case TAG_MEMORY32: {

                PPNP_MEMORY32_DESCRIPTOR  res =
                    (PPNP_MEMORY32_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_MEMORY32 - 0x%x-0x%x A:0x%x L:0x%x",
                    tagCount,
                    res->MinimumAddress,
                    res->MaximumAddress,
                    res->Alignment,
                    res->MemorySize
                    );

                if (res->Information & PNP_MEMORY_READ_WRITE) {

                    dprintf(" RW");

                } else {

                    dprintf(" R");

                }
                break;

            }
            case TAG_MEMORY32_FIXED: {

                PPNP_FIXED_MEMORY32_DESCRIPTOR  res =
                    (PPNP_FIXED_MEMORY32_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_FIXED_MEMORY32 - 0x%x L:0x%x",
                    tagCount,
                    res->BaseAddress,
                    res->MemorySize
                    );

                if (res->Information & PNP_MEMORY_READ_WRITE) {

                    dprintf(" RW");

                } else {

                    dprintf(" R");

                }
                break;

            }
            case TAG_WORD_ADDRESS: {

                PPNP_WORD_ADDRESS_DESCRIPTOR    res =
                    (PPNP_WORD_ADDRESS_DESCRIPTOR) dataBuffer;

                dprintf("%d - TAG_WORD_ADDRESS -", tagCount);
                switch (res->RFlag) {
                case 0:
                    //
                    // Memory range
                    //
                    dprintf(
                         "Mem 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

                        dprintf(" RW");

                    } else {

                        dprintf(" R");

                    }

                    switch (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
                    default:
                    case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
                        dprintf(" NC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
                        dprintf(" C");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
                        dprintf(" WC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
                        dprintf(" PC");
                        break;
                    }
                    break;
                case 1:
                    //
                    // IO range
                    //
                    dprintf(
                         "IO 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_ISA_RANGE) {

                        dprintf(" ISA");

                    }
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE) {

                        dprintf(" Non-ISA");

                    }
                    break;
                case 2:
                    dprintf(
                         "Bus 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    break;
                } // switch( buffer->RFlag )

                //
                // Global Flags
                //
                if (res->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

                    dprintf(" Consumed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE) {

                    dprintf(" Subtractive");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

                    dprintf(" MinFixed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

                    dprintf(" MaxFixed");

                }

                if (increment > sizeof(PNP_WORD_ADDRESS_DESCRIPTOR) + 1) {

                    dprintf(
                        " %d<-%s",
                        dataBuffer[sizeof(PNP_WORD_ADDRESS_DESCRIPTOR)],
                        &(dataBuffer[sizeof(PNP_WORD_ADDRESS_DESCRIPTOR)+1])
                        );

                }
                dprintf("\n");
                break;

            }
            case TAG_DOUBLE_ADDRESS: {

                PPNP_DWORD_ADDRESS_DESCRIPTOR   res =
                    (PPNP_DWORD_ADDRESS_DESCRIPTOR) dataBuffer;

                dprintf("%d - TAG_DWORD_ADDRESS -", tagCount);
                switch (res->RFlag) {
                case 0:
                    //
                    // Memory range
                    //
                    dprintf(
                         "Mem 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

                        dprintf(" RW");

                    } else {

                        dprintf(" R");

                    }

                    switch (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
                    default:
                    case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
                        dprintf(" NC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
                        dprintf(" C");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
                        dprintf(" WC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
                        dprintf(" PC");
                        break;
                    }
                    break;
                case 1:
                    //
                    // IO range
                    //
                    dprintf(
                         "IO 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_ISA_RANGE) {

                        dprintf(" ISA");

                    }
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE) {

                        dprintf(" Non-ISA");

                    }
                    break;
                case 2:
                    dprintf(
                         "Bus 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    break;
                } // switch( buffer->RFlag )

                //
                // Global Flags
                //
                if (res->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

                    dprintf(" Consumed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE) {

                    dprintf(" Subtractive");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

                    dprintf(" MinFixed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

                    dprintf(" MaxFixed");

                }

                if (increment > sizeof(PNP_DWORD_ADDRESS_DESCRIPTOR) + 1) {

                    dprintf(
                        " %d<-%s",
                        (UCHAR) dataBuffer[sizeof(PNP_DWORD_ADDRESS_DESCRIPTOR)],
                        &(dataBuffer[sizeof(PNP_DWORD_ADDRESS_DESCRIPTOR)+1])
                        );

                }
                dprintf("\n");
                break;

            }
            case TAG_QUAD_ADDRESS: {

                PPNP_QWORD_ADDRESS_DESCRIPTOR   res =
                    (PPNP_QWORD_ADDRESS_DESCRIPTOR) dataBuffer;

                dprintf("%d - TAG_QWORD_ADDRESS -", tagCount);
                switch (res->RFlag) {
                case 0:
                    //
                    // Memory range
                    //
                    dprintf(
                         "Mem 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

                        dprintf(" RW");

                    } else {

                        dprintf(" R");

                    }

                    switch (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
                    default:
                    case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
                        dprintf(" NC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
                        dprintf(" C");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
                        dprintf(" WC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
                        dprintf(" PC");
                        break;
                    }
                    break;
                case 1:
                    //
                    // IO range
                    //
                    dprintf(
                         "IO 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_ISA_RANGE) {

                        dprintf(" ISA");

                    }
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE) {

                        dprintf(" Non-ISA");

                    }
                    break;
                case 2:
                    dprintf(
                         "Bus 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    break;
                } // switch( buffer->RFlag )

                //
                // Global Flags
                //
                if (res->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

                    dprintf(" Consumed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE) {

                    dprintf(" Subtractive");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

                    dprintf(" MinFixed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

                    dprintf(" MaxFixed");

                }

                if (increment > sizeof(PNP_QWORD_ADDRESS_DESCRIPTOR) + 1) {

                    dprintf(
                        " %d<-%s",
                        (UCHAR) dataBuffer[sizeof(PNP_QWORD_ADDRESS_DESCRIPTOR)],
                        &(dataBuffer[sizeof(PNP_QWORD_ADDRESS_DESCRIPTOR)+1])
                        );

                }
                dprintf("\n");
                break;

            }
            case TAG_END:

                dprintf("%d - TAG_END\n", tagCount);
                if (dataBuffer) {

                    LocalFree(dataBuffer );

                }
                return;

            default:

                dprintf("%d - TAG_UNKNOWN %d\n", tagCount, currentTag );
                break;


        } // switch

        //
        // Free the buffer if it was allocated
        //
        if (dataBuffer != NULL) {

            LocalFree( dataBuffer );
            dataBuffer = NULL;

        }

        //
        // Update the current address and tag number
        //
        tagCount++;
        currentAddress += increment;

    } // while

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\help.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    help.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

EXTERNAL_HELP_TABLE extensions[] =  {
    { "accfield",   "Dumps an Access Field Record from the AML stack" },
    { "acpiext",    "Dumps the ACPI Device Extension\n"
                    "\t\t\t  Arguments: <address> <flags>\n"
                    "\t\t\t    Flags: 0x1,0x2,0x4,0x8 - Verbosity Bits\n"
                    "\t\t\t           0x10            - Recurse" },
    { "amli",       "\tInvoke AMLI debugger\n"
                    "\t\t\t  Usage: amli <cmd> [arguments ...]" },
    { "call",       "\tDumps an Call Record from the AML stack" },
    { "context",    "Dumps an AML Stcak Context\n"
                    "\t\t\t  Arguments: <address> <flags>\n"
                    "\t\t\t    Flags: 0x00 - 0xff     - Verbosity Bits" },
    { "dm",         "\tDumps Memory to File: <Address> <Length> <File>" },
    { "dsdt",       "\tDumps the Differentiated System Description Table\n"
                    "\t\t\t  Arguments: <address> [savefile]" },
    { "facs",       "\tMoved to kdexts.dll" },
    { "fadt",       "\tMoved to kdexts.dll" },
    { "hdr",        "\tDumps the header at the specified address" },
    { "kb",         "\tDumps the AML Stack Trace (no nested terms)" },
    { "kv",         "\tDumps the AML Stack Trace (nested terms)" },
    { "inf",        "\tMoved to kdexts.dll -- see acpiinf" },
    { "mapic",      "Moved to kdexts.dll" },
    { "node",       "\tDumps a Device Power Node" },
    { "nsobj",      "Moved to kdexts.dll" },
    { "nstree",     "Moved to kdexts.dll" },
    { "objdata",    "Dumps the result of an AML call" },
    { "pnpreslist", "Dumps an ACPI PnP Resource Buffer" },
    { "polist",     "Dumps the ACPI Driver's Power Queues"},
    { "ponodes",    "Dumps the ACPI Driver's Power Node List"},
    { "rsdt",       "\tMoved to kdexts.dll" },
    { "scope",      "Dumps a Scope Record from the AML stack" },
    { "ssdt",       "\tDumps the Secondary System Description Table" },
    { "term",       "\tDums an Term Record from the AML stack" },
    { "unasm",      "Unassembles a section of AML" },
    { NULL,         NULL }
};

DECLARE_API( help )
{
    int i = 0;

    dprintf("\nACPI Debugger Extension\n");
    while(extensions[i].ExternalName != NULL)    {

        dprintf("\t%s - \t%s\n", extensions[i].ExternalName, extensions[i].ExternalDescription);
        i++;

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\kdext.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    kdext.h

Abstract:

    Header files for KD extension

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#ifndef _KDEXT_H_
#define _KDEXT_H_

//
// Various Defines
//
#define Move(dst, src)                                                  \
    try {                                                               \
        b = ReadMemory( (ULONG_PTR) (src), &(dst), sizeof(dst), NULL ); \
        if (!b) {                                                       \
            return;                                                     \
        }                                                               \
    } except (EXCEPTION_EXECUTE_HANDLER)  {                             \
        return;                                                         \
    }

#define MoveBlock( dst, src, size )                                     \
    try {                                                               \
        b = ReadMemory( (ULONG_PTR) (src), &(ds), size, NULL );         \
        if (!b) {                                                       \
            return;                                                     \
        }                                                               \
    } except (EXCEPTION_EXECUTE_HANDLER) {                              \
        return;                                                         \
    }

//
// Various Structures
//
typedef struct _EXTERNAL_HELP_TABLE {

    PUCHAR  ExternalName;
    PUCHAR  ExternalDescription;

} EXTERNAL_HELP_TABLE, *PEXTERNAL_HELP_TABLE;

//
// Verbose flags (for contexts)
//
#define VERBOSE_CONTEXT 0x01
#define VERBOSE_CALL    0x02
#define VERBOSE_HEAP    0x04
#define VERBOSE_OBJECT  0x08
#define VERBOSE_NSOBJ   0x10
#define VERBOSE_RECURSE 0x20

//
// Verbose flags (for device extensions)
//
#define VERBOSE_1       0x01
#define VERBOSE_2       0x02
#define VERBOSE_3       0x04
#define VERBOSE_4       0x08
#define VERBOSE_ALL     0x0f

//
// Verbose Flags (for walking the tree)
//
#define VERBOSE_LOOP    0x10
#define VERBOSE_THERMAL 0x20
#define VERBOSE_PRESENT 0x40

//
// Various data and externs
//
extern  UCHAR  Buffer[2048];

BOOL
GetUlong(
    IN  PCHAR   Name,
    IN  PULONG  Value
    );

BOOL
GetUlongPtr(
    IN  PCHAR   Name,
    IN  PULONG_PTR Address
    );

BOOL
ReadPhysicalOrVirtual(
    IN      ULONG_PTR Address,
    IN      PVOID   Buffer,
    IN      ULONG   Size,
    IN  OUT PULONG  ReturnLength,
    IN      BOOL    Virtual
    );

VOID
displayAcpiDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
displayAcpiDeviceExtensionBrief(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
displayAcpiDeviceExtensionFlags(
    IN  PDEVICE_EXTENSION   DeviceExtension
    );

VOID
displayAcpiDeviceExtensionName(
    IN  ULONG_PTR DeviceExtensionAddress
    );

VOID
displayThermalInfo(
    IN  PTHRM_INFO          Thrm,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
displayThermalInfoEx(
    IN  PTHRM_INFO          Thrm,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpAccessFieldObject(
    IN  ULONG_PTR           AccessFieldAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpAccessFieldUnit(
    IN  ULONG_PTR           AccessFieldAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpAcpiDeviceNode(
    IN  PACPI_DEVICE_POWER_NODE DeviceNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    );

VOID
dumpAcpiDeviceNodes(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    );

VOID
dumpAcpiExtension(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    );

VOID
dumpAcpiGpeInformation(
    VOID
    );

VOID
dumpAcpiInformation(
    VOID
    );

VOID
dumpAcpiPowerList(
    PUCHAR  ListName
    );

VOID
dumpAcpiPowerLists(
    VOID
    );

VOID
dumpAcpiPowerNode(
    IN  PACPI_POWER_DEVICE_NODE PowerNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    );

VOID
dumpAcpiPowerNodes(
    VOID
    );

VOID
dumpAmlTerm(
    IN  ULONG_PTR           AmlTermAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpCall(
    IN  ULONG_PTR           CallAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpContext(
    IN  ULONG_PTR           ContextAddress,
    IN  ULONG               Verbose
    );

VOID
dumpDeviceListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    );

VOID
dumpFieldAddress(
    IN  ULONG_PTR FieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    );

VOID
dumpIrpListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    );

VOID
dumpMemory(
    IN  ULONG_PTR           Address,
    IN  ULONG               Length,
    IN  PUCHAR              FileName
    );

VOID
dumpNSObject(
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpNSTree(
    IN  ULONG_PTR           Address,
    IN  ULONG               Level
    );

VOID
dumpObject(
    IN  ULONG_PTR           Address,
    IN  POBJDATA            Object,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpObjectOwner(
    IN  ULONG_PTR           ObjOwnerAddress,
    IN  ULONG               IndentLevel
    );

VOID
dumpPM1StatusRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    );

VOID
dumpPM1ControlRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    );

VOID
dumpPnPResources(
    IN  ULONG_PTR Address
    );

VOID
dumpPObject(
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpScope(
    IN  ULONG_PTR           ScopeAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpStack(
    IN  ULONG_PTR           ContextAddress,
    IN  PCTXT               Context,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpTerm(
    IN  ULONG_PTR           TermAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpIrqArb(
    IN  PVOID   IrqArb
    );

PUCHAR
TempToKelvins(
    IN  ULONG   Temp
    );

PUCHAR
TimeToSeconds(
    IN  ULONG   Time
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\stack.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.c

Abstract:

    Dumps the AML Context Structure in Human-Readable-Form (HRF)

Author:

    Stephane Plante (splante) 26-Oct-1997

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

VOID
stackArgument(
    IN  ULONG_PTR ObjectAddress
    )
{
    BOOL    result;
    OBJDATA object;
    PUCHAR  buffer = NULL;
    ULONG   returnLength;

    //
    // Read the object
    //
    result = ReadMemory(
        ObjectAddress,
        &object,
        sizeof(OBJDATA),
        &returnLength
        );
    if (!result || returnLength != sizeof(OBJDATA)) {

        dprintf("_BAD_");
        return;

    }

    if (object.pbDataBuff != 0) {

        buffer = LocalAlloc( LPTR, object.dwDataLen+1 );
        if (buffer == NULL) {

            dprintf("_MEM_");
            return;

        }
        result = ReadMemory(
            (ULONG_PTR) object.pbDataBuff,
            buffer,
            object.dwDataLen,
            &returnLength
            );
        if (!result || returnLength != object.dwDataLen) {

            dprintf("_BUF_");
            return;

        }

    }

    switch (object.dwDataType) {
    case OBJTYPE_INTDATA:
        dprintf("0x%x", object.uipDataValue);
        break;
    case OBJTYPE_STRDATA:
        buffer[object.dwDataLen] = '\0';
        dprintf("%s",buffer);
        break;
    case OBJTYPE_BUFFDATA:
        dprintf(
            "<buffer> %08lx-%08lx",
            object.pbDataBuff,
            object.pbDataBuff+object.dwDataLen
            );
        break;
    case OBJTYPE_PKGDATA:
        dprintf("<package> %08lx", ObjectAddress );
        break;
    case OBJTYPE_FIELDUNIT:
        dprintf("<fieldunit> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DEVICE:
        dprintf("<device> %08lx", ObjectAddress );
        break;
    case OBJTYPE_EVENT:
        dprintf("<event> %08lx", ObjectAddress );
        break;
    case OBJTYPE_METHOD:
        dprintf("<method> %08lx", ObjectAddress );
        break;
    case OBJTYPE_MUTEX:
        dprintf("<mutex> %08lx", ObjectAddress );
        break;
    case OBJTYPE_OPREGION:
        dprintf("<opregion> %08lx", ObjectAddress );
        break;
    case OBJTYPE_POWERRES:
        dprintf("<powerres> %08lx", ObjectAddress );
        break;
    case OBJTYPE_PROCESSOR:
        dprintf("<processor> %08lx", ObjectAddress );
        break;
    case OBJTYPE_THERMALZONE:
        dprintf("<thermalzone> %08lx", ObjectAddress );
        break;
    case OBJTYPE_BUFFFIELD:
        dprintf("<bufffield> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DDBHANDLE:
        dprintf("<ddbhandle> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DEBUG:
        dprintf("<debug> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DATAALIAS:
        dprintf("<dataalias> %08lx", ObjectAddress );
        break;
    case OBJTYPE_BANKFIELD:
        dprintf("<bankfield> %08lx", ObjectAddress );
        break;
    case OBJTYPE_FIELD:
        dprintf("<field> %08lx", ObjectAddress );
        break;
    case OBJTYPE_INDEXFIELD:
        dprintf("<indexfield> %08lx", ObjectAddress );
        break;
    default:
        dprintf("<unknown> %08lx", ObjectAddress );
        break;
    }

}

VOID
stackCall(
    IN  ULONG_PTR CallAddress
    )
/*++

Format Displayed:

    ResultAddress  MethodName( Arg0, ..., ArgN )

--*/
{
    ULONG_PTR   address;
    BOOL        result;
    CALL        call;
    INT         i;
    NSOBJ       object;
    PUCHAR      objectPath;
    ULONG       returnLength;

    result = ReadMemory(
        CallAddress,
        &call,
        sizeof(CALL),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(CALL) ||
        call.FrameHdr.dwSig != SIG_CALL) {

        dprintf(
            "stackCall: --- Coult not read call frame %08lx\n",
            CallAddress
            );
        return;

    }

    if (call.pnsMethod == NULL) {

        dprintf( "%08lx --- No method\n", CallAddress );
        return;

    }

    //
    // Display result address
    //
    dprintf("CALL %08lx  ", CallAddress );

    //
    // Display the function name
    //
    objectPath = stackGetObjectPath( (ULONG_PTR) call.pnsMethod );
    dprintf("%s(", objectPath);

    //
    // Display all parsed arguments;
    //
    for (i = 0; i < call.iArg; i++) {

        //
        // What is the address of the argument
        //
        address = (ULONG_PTR) &call.pdataArgs[i];

        //
        // Display that argument
        //
        stackArgument(
            address
            );

        if (i < (call.icArgs - 1)) {

            dprintf(",");

        }
    }

    //
    // Let the user know how many unprocessed arguments there are
    //
    for (; i < call.icArgs; i++) {

        dprintf("_???_");
        if (i < (call.icArgs-1)) {

            dprintf(",");

        }

    }
    dprintf(")\n");

}

PUCHAR
stackGetAmlTermPath(
    IN  ULONG_PTR AmlTermAddress
    )
{
    AMLTERM         amlTerm;
    BOOL            result;
    static  UCHAR   termPath[2049];
    ULONG           i;
    ULONG           resultLength;

    result = ReadMemory(
        AmlTermAddress,
        &amlTerm,
        sizeof(AMLTERM),
        &resultLength
        );
    if (!result || resultLength != sizeof(AMLTERM)) {

        return NULL;

    }

    if (amlTerm.pszTermName == NULL) {

        return NULL;
    }

    result = ReadMemory(
        (ULONG_PTR) amlTerm.pszTermName,
        &termPath,
        2048,
        &resultLength
        );
    if (!result || resultLength == 0) {

        return NULL;

    }
    termPath[resultLength] = '\0';
    return termPath;

}

PUCHAR
stackGetObjectPath(
    IN  ULONG_PTR ObjectAddress
    )
{
    BOOL            result;
    NSOBJ           object;
    static  UCHAR   namePath[2049];
    ULONG           i;
    ULONG           resultLength;

    //
    // Read the object
    //
    result = ReadMemory(
        ObjectAddress,
        &object,
        sizeof(NSOBJ),
        &resultLength
        );
    if (!result || resultLength != sizeof(NSOBJ)) {

        return NULL;

    }

    if (object.pnsParent == NULL) {

        strcpy( namePath, "\\");

    } else {

        NSOBJ   parent;

        stackGetObjectPath( (ULONG_PTR) object.pnsParent );

        result = ReadMemory(
            (ULONG_PTR) object.pnsParent,
            &parent,
            sizeof(NSOBJ),
            &resultLength
            );
        if (!result || resultLength != sizeof(NSOBJ)) {

            return NULL;

        }

        if (parent.pnsParent != NULL) {

            strcat(namePath, ".");

        }
        strncat( namePath, (PUCHAR) &(object.dwNameSeg), sizeof(NAMESEG) );

        for (i = strlen(namePath); i > 0; --i) {

            if (namePath[i-1] == '_') {

                namePath[i-1] = '\0';

            } else {

                break;

            }

        }

    }

    return namePath;
}

VOID
stackTerm(
    IN  ULONG_PTR TermAddress
    )
/*++

Format Displayed:

    term TermAddress  TermName( Arg0, ..., ArgN )

--*/
{
    ULONG_PTR   address;
    BOOL        result;
    INT         i;
    NSOBJ       object;
    PUCHAR      objectPath;
    TERM        term;
    ULONG       returnLength;

    result = ReadMemory(
        TermAddress,
        &term,
        sizeof(TERM),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(TERM) ||
        term.FrameHdr.dwSig != SIG_TERM) {

        dprintf(
            "stackTerm: --- Coult not read call frame %08lx\n",
            TermAddress
            );
        return;

    }

    if (term.pamlterm == NULL) {

        dprintf( "%08lx --- No term\n", TermAddress );
        return;

    }

    //
    // Display result address
    //
    dprintf("TERM %08lx  ", TermAddress );

    //
    // Display the function name
    //
    objectPath = stackGetAmlTermPath( (ULONG_PTR) term.pamlterm );
    dprintf("%s(", objectPath);

    //
    // Display all parsed arguments;
    //
    for (i = 0; i < term.iArg; i++) {

        //
        // What is the address of the argument
        //
        address = (ULONG_PTR) &term.pdataArgs[i];

        //
        // Display that argument
        //
        stackArgument(
            address
            );

        if (i < (term.icArgs - 1)) {

            dprintf(",");

        }
    }

    //
    // Let the user know how many unprocessed arguments there are
    //
    for (; i < term.icArgs; i++) {

        dprintf("_???_");
        if (i < (term.icArgs-1)) {

            dprintf(",");

        }

    }
    dprintf(")\n");

}

VOID
stackTrace(
    IN  ULONG_PTR ContextAddress,
    IN  ULONG   Verbose
    )
/*++

Routine Description:

    This routine dumps a context as a stack

Arguments:

    ContextAddress  - Where the stack is located
    Verbose         - How much information to display

Return Value:

    None

--*/
{
    BOOL        callSeen = FALSE;
    BOOL        result;
    CTXT        context;
    FRAMEHDR    frame;
    PUCHAR      frameAddress;
    ULONG       returnLength;

    //
    // Read the context from the target
    //
    result = ReadMemory(
        ContextAddress,
        &context,
        sizeof(CTXT),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(CTXT)) {

        dprintf(
            "stackTrace: --- Could not read Context %08lx\n",
            ContextAddress
            );
        return;

    }
    if (context.dwSig != SIG_CTXT) {

        dprintf(
            "stackTrace: --- Not a Context (%08lx)\n",
            context.dwSig
            );
        return;

    }

    //
    // Begin to walk the frames
    //
    frameAddress = context.LocalHeap.pbHeapEnd;
    while (frameAddress < context.pbCtxtEnd) {

        result = ReadMemory(
            (ULONG_PTR) frameAddress,
            &frame,
            sizeof(FRAMEHDR),
            &returnLength
            );
        if (result != TRUE || returnLength != sizeof(FRAMEHDR)) {

            dprintf(
                "stackTrace: --- could not read frame %08lx\n",
                frameAddress
                );
            return;

        }

        //
        // Do we care about the frame?
        //
        switch(frame.dwSig) {
        case SIG_CALL:

            callSeen = TRUE;
            stackCall(
                (ULONG_PTR) frameAddress
                );
            break;

        case SIG_TERM:

            if (!callSeen || (callSeen && Verbose)) {

                stackTerm(
                    (ULONG_PTR) frameAddress
                    );

            }

        } // switch

        //
        // Next
        //
        frameAddress += frame.dwLen;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Stephane Plante (splante)

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;
ULONG_PTR               AcpiExtAddress = 0;
ULONG_PTR               AcpiTreeAddress = 0;
ULONG_PTR               AcpiObjAddress = 0;
ULONG_PTR               AcpiFacsAddress = 0;
ULONG_PTR               AcpiFadtAddress = 0;
ULONG_PTR               AcpiHdrAddress = 0;
ULONG_PTR               AcpiMapicAddress = 0;
ULONG_PTR               AcpiRsdtAddress = 0;
ULONG_PTR               AcpiUnasmAddress = 0;
ULONG                   AcpiUnasmLength = 0;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    return;
}

BOOL
GetUlong (
    IN  PCHAR   String,
    IN  PULONG  Value
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Value,
        sizeof(ULONG),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}

BOOL
GetUlongPtr (
    IN  PCHAR   String,
    IN  PULONG_PTR Address
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Address,
        sizeof(ULONG_PTR),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( accfield )
{
    ULONG_PTR fieldAddress = 0;

    if (args != NULL) {

        fieldAddress = GetExpression( args );

    }

    if (fieldAddress == 0) {

        dprintf("accfield: <address>\n");
        return;

    }

    dumpAccessFieldUnit(
        fieldAddress,
        (ULONG) -1,
        0
        );

}

DECLARE_API( acpiext )
{
    BOOL                b;
    DEVICE_EXTENSION    deviceExtension;
    DEVICE_OBJECT       deviceObject;
    ULONG_PTR           deviceExtensionAddress = 0;
    ULONG               verbose = VERBOSE_ALL;

    //
    // Read the address of the device object
    //
    if ( args != NULL) {

        sscanf( args, "%lx %x", &deviceExtensionAddress, &verbose );

    }

    if (deviceExtensionAddress == 0) {

        if ( args != NULL) {

            deviceExtensionAddress = GetExpression( args );

        }
        if (deviceExtensionAddress == 0) {

            b = GetUlongPtr(
                "ACPI!RootDeviceExtension",
                &deviceExtensionAddress
                );
            if (!b) {

                deviceExtensionAddress = 0;

            }

        }
        if (deviceExtensionAddress == 0) {

            dprintf("acpiext <address>\n");
            return;

        }

    }

    //
    // Read the device object
    //
    b = ReadMemory(
        deviceExtensionAddress,
        &deviceExtension,
        sizeof(DEVICE_EXTENSION),
        NULL
        );
    if (!b || deviceExtension.Signature != ACPI_SIGNATURE) {

        //
        // Try to read a device object instead
        //
        b = ReadMemory(
            deviceExtensionAddress,
            &deviceObject,
            sizeof(DEVICE_OBJECT),
            NULL
            );
        if (!b) {

            dprintf("0x%08lx: Could not read DeviceObject\n", deviceExtensionAddress);
            return;

        }

        //
        // Try to read an extension now
        //
        deviceExtensionAddress = (ULONG_PTR) deviceObject.DeviceExtension;
        if (deviceExtensionAddress == 0) {

            dprintf("acpiext: Could not find ACPI Extension\n");
            return;

        }
    }

    dumpAcpiExtension(
        deviceExtensionAddress,
        verbose,
        0
        );
    return;
}

DECLARE_API( buildlist )
{
    UCHAR   tempBuff[100];

    if (args != NULL && args[0] != 0) {

        _snprintf( tempBuff, 100, "ACPI!ACPIBuild%sList", args );
        dumpAcpiBuildList( tempBuff );

    } else {

        dumpAcpiBuildLists();

    }

}

DECLARE_API( call )
{
    ULONG_PTR callAddress = 0;

    if (args != NULL) {

        callAddress = GetExpression( args );

    }

    if (callAddress == 0) {

        dprintf("call: <address>\n");
        return;

    }

    dumpCall(
        callAddress,
        (ULONG) -1,
        0
        );

}

DECLARE_API( context )
{
    BOOL    b;
    ULONG_PTR contextAddress = 0;
    ULONG   verbose = 0;

    //
    // If there are arguments, try to read them
    //
    if ( args != NULL) {

        sscanf( args, "%lx %x", &contextAddress, &verbose );

    }

    if (contextAddress == 0) {

        if (args != NULL) {

            contextAddress = GetExpression(args);

        }

        if (contextAddress == 0) {

            CTXT    context;
            PLIST   listEntry;
            ULONG   resultLength;

            //
            // Try to read the default address
            //
            b = GetUlongPtr( "ACPI!gplistCtxtHead", &contextAddress );
            if (!b || contextAddress == 0) {

                dprintf("context: Could not read ACPI!gplistCtxtHead\n" );
                return;


            }

            //
            // Read the list and look at the first item
            //
            b = ReadMemory(
                contextAddress,
                &listEntry,
                sizeof(PLIST),
                &resultLength
                );
            if (!b || resultLength != sizeof(PLIST)) {

                dprintf(
                    "context: Could not read PLIST @ 0x%08lx\n",
                    contextAddress
                    );
                return;

            }

            //
            // The first item in the list is the context that we are
            // interested in
            //
            contextAddress = (ULONG_PTR) listEntry -
                ( (ULONG_PTR) &(context.listCtxt) - (ULONG_PTR) &(context) );

            //
            // Is there a context there?
            //
            if (contextAddress == 0) {

                dprintf(
                    "context: No current context\n"
                    );

            }

        }

    }

    dumpContext( contextAddress, verbose );
    return;

}

DECLARE_API( dm )
{
    ULONG_PTR   address = 0;
    ULONG       i;
    ULONG       length = 0;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    char        sz[1000];


    if (args != NULL) {

        strcpy(sz, args);

        for (i = 0, tok = strtok( sz, " \t" );
             i < 3, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " Ll\t" );

            } else if (i == 1) {

                length = (ULONG)GetExpression ( tok );
                tok = strtok( NULL, " \t\n\r");

            } else if (i == 2) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0 || length == 0 || name == NULL) {

        dprintf("dm <address> L<length> <filename>\n");
        return;

    }

    dumpMemory( address, length, name );
    return;
}

#if 0
DECLARE_API( dsdt )
{
    ULONG_PTR   address = 0;
    ULONG       i;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    UCHAR       tempBuff[1000];

    if (args != NULL) {

        strcpy(tempBuff, args);

        for (i = 0, tok = strtok( tempBuff, " \t" );
             i < 2, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " \n\r\t" );

            } else if (i == 1) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       infAddress = 0;
        ULONG           returnLength;

        status = GetUlongPtr("ACPI!AcpiInformation", &infAddress );
        if (status == TRUE) {

            status = ReadMemory(
                infAddress,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                address = (ULONG_PTR) acpiInformation.DiffSystemDescTable;

            }
        }

    }

    if (address == 0) {

        dprintf("dsdt <address>\n");

    }

    dumpDSDT( address, name );
    return;
}
#endif

DECLARE_API( facs )
{

    if (args != NULL) {

        AcpiFacsAddress = GetExpression( args );

    }

    if (AcpiFacsAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiFacsAddress = (ULONG_PTR) acpiInformation.FirmwareACPIControlStructure;

            }

        }

    }

    if (AcpiFacsAddress == 0) {

        dprintf("facs <address>\n");
        return;

    }

    dumpFACS( AcpiFacsAddress );
    return;

}

DECLARE_API( fadt )
{

    if (args != NULL && *args != '\0') {

        AcpiFadtAddress = GetExpression( args );

    }

    if (AcpiFadtAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiFadtAddress = (ULONG_PTR) acpiInformation.FixedACPIDescTable;

            }

        }

    }

    if (AcpiFadtAddress == 0) {

        dprintf("fadt <address>\n");
        return;

    }
    dumpFADT( AcpiFadtAddress );
    return;

}

DECLARE_API( gbl )
{
    ULONG   verbose = VERBOSE_1;

    if (args != NULL) {

        if (!strcmp(args, "-v")) {

            verbose |= VERBOSE_2;

        }

    }

    dumpGBL( verbose );
}

DECLARE_API ( gpe )
{
    dumpAcpiGpeInformation( );
    return;
}

DECLARE_API( hdr )
{
    BOOL                b;
    BOOL                virtualMemory = FALSE;
    DESCRIPTION_HEADER  header;
    ULONG               returnLength;

    if (args != NULL) {

        AcpiHdrAddress = GetExpression( args );

    }
    if (AcpiHdrAddress == 0) {

        dprintf("hdr <address>\n");
        return;

    }

    //
    // First check to see if we find the correct things
    //
    b = ReadPhysicalOrVirtual(
        AcpiHdrAddress,
        &header,
        sizeof(DESCRIPTION_HEADER),
        &returnLength,
        virtualMemory
        );
    if (!b) {

        //
        // Attempt to read a Virtual address
        //
        virtualMemory = !virtualMemory;
        b = ReadPhysicalOrVirtual(
            AcpiHdrAddress,
            &header,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            virtualMemory
            );

    }

    //
    // Is the signature 'known'?
    //
    if (header.Signature != FADT_SIGNATURE &&
        header.Signature != FACS_SIGNATURE &&
        header.Signature != RSDT_SIGNATURE &&
        header.Signature != APIC_SIGNATURE &&
        header.Signature != DSDT_SIGNATURE &&
        header.Signature != SSDT_SIGNATURE &&
        header.Signature != PSDT_SIGNATURE &&
        header.Signature != SBST_SIGNATURE) {

        //
        // Unknown -- try again
        //
        virtualMemory = !virtualMemory;
        b = ReadPhysicalOrVirtual(
            AcpiHdrAddress,
            &header,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            virtualMemory
            );
        if (!b) {

            virtualMemory = !virtualMemory;
            b = ReadPhysicalOrVirtual(
                AcpiHdrAddress,
                &header,
                sizeof(DESCRIPTION_HEADER),
                &returnLength,
                virtualMemory
                );

        }

    }
    dumpHeader( AcpiHdrAddress, &header, TRUE );
    return;

}

DECLARE_API( kb )
{
    BOOL    b;
    ULONG_PTR contextAddress = 0;
    ULONG   verbose = 0;

    //
    // If there are arguments, try to read them
    //
    if (args != NULL) {

        contextAddress = GetExpression(args);

    }

    if (contextAddress == 0) {

        CTXT    context;
        PLIST   listEntry;
        ULONG   resultLength;

        //
        // Try to read the default address
        //
        b = GetUlongPtr( "ACPI!gplistCtxtHead", &contextAddress );
        if (!b || contextAddress == 0) {

            dprintf("kb: Could not read ACPI!gplistCtxtHead\n" );
            return;


        }

        //
        // Read the list and look at the first item
        //
        b = ReadMemory(
            contextAddress,
            &listEntry,
            sizeof(PLIST),
            &resultLength
            );
        if (!b || resultLength != sizeof(PLIST)) {

            dprintf(
                "kb: Could not read PLIST @ 0x%08lx\n",
                contextAddress
                );
            return;

        }

        //
        // The first item in the list is the context that we are
        // interested in
        //
        contextAddress = (ULONG_PTR) listEntry -
            ( (ULONG_PTR) &(context.listCtxt) - (ULONG_PTR) &(context) );

        //
        // Is there a context there?
        //
        if (contextAddress == 0) {

            dprintf(
                "kb: No current context\n"
                );

        }

    }

    stackTrace( contextAddress, 0 );
    return;

}

DECLARE_API( kv )
{
    BOOL    b;
    ULONG_PTR contextAddress = 0;
    ULONG   verbose = 0;

    //
    // If there are arguments, try to read them
    //
    if (args != NULL) {

        contextAddress = GetExpression(args);

    }

    if (contextAddress == 0) {

        CTXT    context;
        PLIST   listEntry;
        ULONG   resultLength;

        //
        // Try to read the default address
        //
        b = GetUlongPtr( "ACPI!gplistCtxtHead", &contextAddress );
        if (!b || contextAddress == 0) {

            dprintf("kv: Could not read ACPI!gplistCtxtHead\n" );
            return;


        }

        //
        // Read the list and look at the first item
        //
        b = ReadMemory(
            contextAddress,
            &listEntry,
            sizeof(PLIST),
            &resultLength
            );
        if (!b || resultLength != sizeof(PLIST)) {

            dprintf(
                "kv: Could not read PLIST @ 0x%08lx\n",
                contextAddress
                );
            return;

        }

        //
        // The first item in the list is the context that we are
        // interested in
        //
        contextAddress = (ULONG_PTR) listEntry -
            ( (ULONG_PTR) &(context.listCtxt) - (ULONG_PTR) &(context) );

        //
        // Is there a context there?
        //
        if (contextAddress == 0) {

            dprintf(
                "kv: No current context\n"
                );

        }

    }

    stackTrace( contextAddress, 1 );
    return;

}

DECLARE_API( inf )
{
    dumpAcpiInformation( );
    return;
}

DECLARE_API( mapic )
{
    if (args != NULL) {

        AcpiMapicAddress = GetExpression( args );

    }

    if (AcpiMapicAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiMapicAddress = (ULONG_PTR) acpiInformation.MultipleApicTable;
            }
        }
    }

    if (AcpiMapicAddress == 0) {
        dprintf("mapic <address>");
        return;
    }

    dumpMAPIC( AcpiMapicAddress );
    return;

}

DECLARE_API( node )
{
    ULONG_PTR nodeAddress;

    nodeAddress = GetExpression( args );
    if (nodeAddress == 0) {

        dprintf("node: Illegal Address (%s == NULL)\n", args );
        return;
    }
    dumpAcpiDeviceNodes( nodeAddress, VERBOSE_4, 0 );

}

DECLARE_API( nsobj )
{
    ULONG_PTR address = 0;

    if (args != NULL) {

        address = GetExpression( args );

    }

    if (args == 0) {

        dprintf(
            "nsobj: Could not find %s\n",
            (args != NULL ? args : "null")
            );
        return;

    }

    dumpNSObject( address, 0xFFFF, 0 );
}

DECLARE_API( nstree )
{
    ULONG_PTR address = 0;

    if ((args != NULL) && (*args != '\0')) {

        address = GetExpression( args );

    } else {

        address = GetExpression( "acpi!gpnsNameSpaceRoot" );

    }
    if (address == 0) {

        dprintf(
            "nstree: Could not find %s\n",
            (args != NULL ? args : "acpi!gpnsNameSpaceRoot" )
            );
        return;

    }

    dumpNSTree( address, 0 );
}

DECLARE_API( objdata )
{
    BOOL    b;
    ULONG   address = 0;

    //
    // Read the address of the device object
    //
    if (args != NULL) {

        AcpiObjAddress = GetExpression( args );

    }
    if (AcpiObjAddress == 0) {

        dprintf("object <address>\n");
        return;

    }

    dumpPObject( AcpiObjAddress, 0xFFFF, 0);
    return;

}

DECLARE_API( pnpreslist )
{
    ULONG_PTR address = 0;

    if (args != NULL) {

        address = GetExpression( args );

    }
    if (address == 0) {

        dprintf("pnpreslist <address>\n");
        return;

    }

    dumpPnPResources( address );
}

DECLARE_API( polist )
{
    UCHAR   tempBuff[100];

    if (args != NULL && args[0] != 0) {

        _snprintf( tempBuff, 100, "ACPI!ACPIPower%sList", args );
        dumpAcpiPowerList( tempBuff );

    } else {

        dumpAcpiPowerLists();

    }

}

DECLARE_API( ponodes )
{
    dumpAcpiPowerNodes();
}

#if 0
DECLARE_API( psdt )
{

    ULONG_PTR   address = 0;
    ULONG       i;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    UCHAR       tempBuff[1000];

    if (args != NULL) {

        strcpy(tempBuff, args);

        for (i = 0, tok = strtok( tempBuff, " \t" );
             i < 2, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " Ll\t" );

            } else if (i == 1) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0) {

        dprintf("psdt <address>");
        return;

    }

    dumpDSDT( address, name );
    return;
}
#endif

DECLARE_API( rsdt )
{

    if (args != NULL) {

        AcpiRsdtAddress = GetExpression( args );

    }
    if (AcpiRsdtAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiRsdtAddress = (ULONG_PTR) acpiInformation.RootSystemDescTable;
            }

        }

    }
    if (AcpiRsdtAddress == 0) {

        if (!findRSDT( &AcpiRsdtAddress) ) {

            dprintf("Could not locate the RSDT pointer\n");
            return;

        }

    }

    dumpRSDT( AcpiRsdtAddress );
    return;

}

DECLARE_API( scope )
{
    ULONG_PTR scopeAddress = 0;

    if (args != NULL) {

        scopeAddress = GetExpression( args );

    }

    if (scopeAddress == 0) {

        dprintf("scope: <address>\n");
        return;

    }

    dumpScope(
        scopeAddress,
        (ULONG) -1,
        0
        );

}

#if 0
DECLARE_API( ssdt )
{

    ULONG_PTR   address = 0;
    ULONG       i;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    UCHAR       tempBuff[1000];

    if (args != NULL) {

        strcpy(tempBuff, args);

        for (i = 0, tok = strtok( tempBuff, " \t" );
             i < 2, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " Ll\t" );

            } else if (i == 1) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0) {

        dprintf("ssdt <address>");
        return;

    }

    dumpDSDT( address, name );
    return;
}
#endif

DECLARE_API( term )
{
    ULONG_PTR termAddress = 0;

    if (args != NULL) {

        termAddress = GetExpression( args );

    }

    if (termAddress == 0) {

        dprintf("term: <address>\n");
        return;

    }

    dumpTerm(
        termAddress,
        (ULONG) -1,
        0
        );

}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf(
        "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
        DebuggerType,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
        );
}

DECLARE_API( amli )
/*++

Routine Description:

    Invoke AMLI debugger

Arguments:

    None

Return Value:

    None

--*/
{
    if ((args == NULL) || (*args == '\0'))
    {
        dprintf("Usage: amli <cmd> [arguments ...]\n"
                "where <cmd> is one of the following:\n");
        AMLIDbgHelp(NULL, NULL, 0, 0);
        dprintf("\n");
    }
    else
    {
        AMLIDbgExecuteCmd((PSZ)args);
        dprintf("\n");
    }
}

DECLARE_API( irqarb )
{

    dprintf("Moved to kdexts.dll  Try '!acpiirqarb'\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\udata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList
#define SK      TF_DELAY_UNASM          //term cannot be unasmed on the first pass

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN      UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

//
// Field flags
//
#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

//
// AccessAttribute
//

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

//
// Operation region space
//
#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

//
// Method flags
//
#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

//
// Match operation values
//
#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock", CD, 0, OP_NONE,     NULL, NULL, OL|CL|LL|AF|AV,
    "Include",         CD, 0, OP_NONE,     NULL, NULL, AF,
    "External",        CD, 0, OP_NONE,     NULL, "uX", AF,

    // Short Objects
    "Zero",            CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",             CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",            CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",        CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",            SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",            SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",            SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",            SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",            SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",            SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",            SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",          SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",          SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",          SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",          SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",          SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",          SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",          SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",          SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",           SN, 0, OP_DEBUG,    NULL, NULL, 0,

    // Named Terms
    "Alias",           NS, 0, OP_ALIAS,    "NN", "Ua", 0,
    "Name",            NS, 0, OP_NAME,     "NO", "u",  0,
    "Scope",           NS, 0, OP_SCOPE,    "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",          DO, 0, OP_BUFFER,   "C", "U",  DL|LN,
    "Package",         DO, 0, OP_PACKAGE,  "B", NULL, PL|LN,
    "EISAID",          DO, 0, OP_DWORD,    NULL,NULL, AF,

    // Argument Keywords
    "AnyAcc",          KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",         KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",         KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",        KW, ADW,  OP_NONE, NULL, "A", 0,
    "QWordAcc",        KW, AQW,  OP_NONE, NULL, "A", 0,
    "BufferAcc",       KW, ABFR, OP_NONE, NULL, "A", 0,

    "Lock",            KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",          KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",        KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",     KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",    KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",    KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",        KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",      KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl", KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",           KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",      KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",   KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",             KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",             KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",             KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",             KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",             KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",             KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",            KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",           KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",      KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",       KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",          KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",       KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",   KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",           KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",           KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",           KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",       KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",    KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",       KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",    KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",      KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",        KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",        KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",       KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",        KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer",KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer",KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",       KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",       KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",        KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",     KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",        KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",     KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",       KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",  KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",    KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",    KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",   KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges",KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",     KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",         KW, ($HGH | $EDG),  OP_NONE, NULL, "U", 0,
    "ExtLevel",        KW, ($LOW | $LVL),  OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",   KW, ($HGH | $EDG),  OP_NONE, NULL, "V", 0,
    "ExtActiveLow",    KW, ($LOW | $LVL),  OP_NONE, NULL, "V", 0,

    "ExtShared",       KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",    KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",      KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",          KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",          KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",         KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",          KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",    KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",       KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",        KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",       KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",        KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",     KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",     KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",  KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",    KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",    KW, DDB,  OP_NONE, NULL, "X", 0,

    "SMBQuick",            KW, SMBQ, OP_NONE, NULL, "Y", 0,
    "SMBSendReceive",      KW, SMBS, OP_NONE, NULL, "Y", 0,
    "SMBByte",             KW, SMBB, OP_NONE, NULL, "Y", 0,
    "SMBWord",             KW, SMBW, OP_NONE, NULL, "Y", 0,
    "SMBBlock",            KW, SMBK, OP_NONE, NULL, "Y", 0,
    "SMBProcessCall",      KW, SMBP, OP_NONE, NULL, "Y", 0,
    "SMBBlockProcessCall", KW, SMBC, OP_NONE, NULL, "Y", 0,

    // Field Macros
    "Offset",          FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",        FM, 0, 0x01,    NULL, "A" , AF,

    // Named Object Creators
    "BankField",       NO, 0, OP_BANKFIELD,  "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",  NO, 0, OP_BITFIELD,   "CCN",   "UUb",    0,
    "CreateByteField", NO, 0, OP_BYTEFIELD,  "CCN",   "UUb",    0,
    "CreateDWordField",NO, 0, OP_DWORDFIELD, "CCN",   "UUb",    0,
    "CreateField",     NO, 0, OP_CREATEFIELD,"CCCN",  "UUUb",   0,
    "CreateWordField", NO, 0, OP_WORDFIELD,  "CCN",   "UUb",    0,
    "Device",          NO, 0, OP_DEVICE,     "N",     "d",      OL|LN|CC,
    "Event",           NO, 0, OP_EVENT,      "N",     "e",      0,
    "Field",           NO, 0, OP_FIELD,      "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",      NO, 0, OP_IDXFIELD,   "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",          NO, 0, OP_METHOD,     "NKk",   "m!E",    CL|OL|LN|AF|CC|SK,
    "Mutex",           NO, 0, OP_MUTEX,      "NB",    "x",      0,
    "OperationRegion", NO, 0, OP_OPREGION,   "NKCC",  "oDUU",   AF,
    "PowerResource",   NO, 0, OP_POWERRES,   "NBW",   "p",      OL|LN|CC,
    "Processor",       NO, 0, OP_PROCESSOR,  "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",     NO, 0, OP_THERMALZONE,"N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",           C1, 0, OP_BREAK,       NULL,  NULL, 0,
    "BreakPoint",      C1, 0, OP_BREAKPOINT,  NULL,  NULL, 0,
    "Else",            C1, 0, OP_ELSE,        NULL,  NULL, AF|CL|OL|LN,
    "Fatal",           C1, 0, OP_FATAL,       "BDC", "  U",0,
    "If",              C1, 0, OP_IF,          "C",   "U",  CL|OL|LN,
    "Load",            C1, 0, OP_LOAD,        "NS",  "UU", 0,
    "Noop",            C1, 0, OP_NOP,         NULL,  NULL, 0,
    "Notify",          C1, 0, OP_NOTIFY,      "SC",  "UU", 0,
    "Release",         C1, 0, OP_RELEASE,     "S",   "X",  0,
    "Reset",           C1, 0, OP_RESET,       "S",   "E",  0,
    "Return",          C1, 0, OP_RETURN,      "C",   "U",  0,
    "Signal",          C1, 0, OP_SIGNAL,      "S",   "E",  0,
    "Sleep",           C1, 0, OP_SLEEP,       "C",   "U",  0,
    "Stall",           C1, 0, OP_STALL,       "C",   "U",  0,
    "Unload",          C1, 0, OP_UNLOAD,      "S",   "U",  0,
    "While",           C1, 0, OP_WHILE,       "C",   "U",  CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",         C2, 0, OP_ACQUIRE,     "SW",     "X",  0,
    "Add",             C2, 0, OP_ADD,         "CCS",    "UUU",0,
    "And",             C2, 0, OP_AND,         "CCS",    "UUU",0,
    "Concatenate",     C2, 0, OP_CONCAT,      "CCS",    "UUU",0,
    "CondRefOf",       C2, 0, OP_CONDREFOF,   "SS",     "UU", 0,
    "Decrement",       C2, 0, OP_DECREMENT,   "S",      "U",  0,
    "DerefOf",         C2, 0, OP_DEREFOF,     "C",      "U",  0,
    "Divide",          C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",0,
    "FindSetLeftBit",  C2, 0, OP_FINDSETLBIT, "CS",     "UU", 0,
    "FindSetRightBit", C2, 0, OP_FINDSETRBIT, "CS",     "UU", 0,
    "FromBCD",         C2, 0, OP_FROMBCD,     "CS",     "UU", 0,
    "Increment",       C2, 0, OP_INCREMENT,   "S",      "U",  0,
    "Index",           C2, 0, OP_INDEX,       "CCS",    "UUU",0,
    "LAnd",            C2, 0, OP_LAND,        "CC",     "UU", 0,
    "LEqual",          C2, 0, OP_LEQ,         "CC",     "UU", 0,
    "LGreater",        C2, 0, OP_LG,          "CC",     "UU", 0,
    "LGreaterEqual",   C2, 0, OP_LGEQ,        "CC",     "UU", 0,
    "LLess",           C2, 0, OP_LL,          "CC",     "UU", 0,
    "LLessEqual",      C2, 0, OP_LLEQ,        "CC",     "UU", 0,
    "LNot",            C2, 0, OP_LNOT,        "C",      "U",  0,
    "LNotEqual",       C2, 0, OP_LNOTEQ,      "CC",     "UU", 0,
    "LOr",             C2, 0, OP_LOR,         "CC",     "UU", 0,
    "Match",           C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU",AF,
    "Multiply",        C2, 0, OP_MULTIPLY,    "CCS",    "UUU",0,
    "NAnd",            C2, 0, OP_NAND,        "CCS",    "UUU",0,
    "NOr",             C2, 0, OP_NOR,         "CCS",    "UUU",0,
    "Not",             C2, 0, OP_NOT,         "CS",     "UU", 0,
    "ObjectType",      C2, 0, OP_OBJTYPE,     "S",      "U",  0,
    "Or",              C2, 0, OP_OR,          "CCS",    "UUU",0,
    "RefOf",           C2, 0, OP_REFOF,       "S",      "U",  0,
    "ShiftLeft",       C2, 0, OP_SHIFTL,      "CCS",    "UUU",0,
    "ShiftRight",      C2, 0, OP_SHIFTR,      "CCS",    "UUU",0,
    "SizeOf",          C2, 0, OP_SIZEOF,      "S",      "U",  0,
    "Store",           C2, 0, OP_STORE,       "CS",     "UU", 0,
    "Subtract",        C2, 0, OP_SUBTRACT,    "CCS",    "UUU",0,
    "ToBCD",           C2, 0, OP_TOBCD,       "CS",     "UU", 0,
    "Wait",            C2, 0, OP_WAIT,        "SC",     "E",  0,
    "XOr",             C2, 0, OP_XOR,         "CCS",    "UUU",0,

    NULL,              0,  0, OP_NONE,   NULL, NULL, 0
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\uasmdata.c ===
/*** uasmdata.c - Unassembler data
 *
 *  This module contains data declaration of the unassembler
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef DEBUGGER

int giLevel = 0;
ULONG_PTR guipbOpXlate = 0;
PNSOBJ gpnsCurUnAsmScope = NULL;

#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN	UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** AccessAttribute
 */

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  CD, 0, OP_NONE, NULL, NULL, OL|CL|LL|AF|AV,
    "Include",          CD, 0, OP_NONE, NULL, NULL, AF,
    "External",         CD, 0, OP_NONE, NULL, "uX", AF,

    // Short Objects
    "Zero",             CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",              CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",             CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",         CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",             SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",             SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",             SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",             SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",             SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",             SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",             SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",           SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",           SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",           SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",           SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",           SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",           SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",           SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",           SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",            SN, 0, OP_DEBUG,    NULL, NULL, 0,

    // Named Terms
    "Alias",            NS, 0, OP_ALIAS, "NN", "Ua", 0,
    "Name",             NS, 0, OP_NAME,  "NO", "u",  0,
    "Scope",            NS, 0, OP_SCOPE, "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",           DO, 0, OP_BUFFER,  "C",  "U",  DL|LN,
    "Package",          DO, 0, OP_PACKAGE, "B",  NULL, PL|LN,
    "EISAID",		DO, 0, OP_DWORD,   NULL, NULL, AF,

    // Argument Keywords
    "AnyAcc",           KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",          KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",          KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",         KW, ADW,  OP_NONE, NULL, "A", 0,
    "QWordAcc",         KW, AQW,  OP_NONE, NULL, "A", 0,
    "BufferAcc",        KW, ABFR, OP_NONE, NULL, "A", 0,

    "Lock",             KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",           KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",         KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",      KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",     KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",     KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",         KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",       KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl",  KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",            KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",       KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",    KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",              KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",              KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",              KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",              KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",              KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",              KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",             KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",            KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",       KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",        KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",           KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",        KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",    KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",            KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",            KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",            KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",        KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",     KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",        KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",     KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",       KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",         KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",         KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",        KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",         KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer", KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer", KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",        KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",        KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",         KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",      KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",         KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",      KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",        KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",   KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",     KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",     KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",    KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges", KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",      KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",          KW, $EDG, OP_NONE, NULL, "U", 0,
    "ExtLevel",         KW, $LVL, OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",    KW, $HGH, OP_NONE, NULL, "V", 0,
    "ExtActiveLow",     KW, $LOW, OP_NONE, NULL, "V", 0,

    "ExtShared",        KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",     KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",       KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",           KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",           KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",          KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",           KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",     KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",        KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",         KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",        KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",         KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",      KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",      KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",   KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",     KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",     KW, DDB,  OP_NONE, NULL, "X", 0,

    "SMBQuick",            KW, SMBQ, OP_NONE, NULL, "Y", 0,
    "SMBSendReceive",      KW, SMBS, OP_NONE, NULL, "Y", 0,
    "SMBByte",             KW, SMBB, OP_NONE, NULL, "Y", 0,
    "SMBWord",             KW, SMBW, OP_NONE, NULL, "Y", 0,
    "SMBBlock",            KW, SMBK, OP_NONE, NULL, "Y", 0,
    "SMBProcessCall",      KW, SMBP, OP_NONE, NULL, "Y", 0,
    "SMBBlockProcessCall", KW, SMBC, OP_NONE, NULL, "Y", 0,

    // Field Macros
    "Offset",           FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",         FM, 0, 0x01,    NULL, "A",  AF,

    // Named Object Creators
    "BankField",        NO, 0, OP_BANKFIELD,   "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",   NO, 0, OP_BITFIELD,    "CCN",   "UUb",    0,
    "CreateByteField",  NO, 0, OP_BYTEFIELD,   "CCN",   "UUb",    0,
    "CreateDWordField", NO, 0, OP_DWORDFIELD,  "CCN",   "UUb",    0,
    "CreateField",      NO, 0, OP_CREATEFIELD, "CCCN",  "UUUb",   0,
    "CreateWordField",  NO, 0, OP_WORDFIELD,   "CCN",   "UUb",    0,
    "Device",           NO, 0, OP_DEVICE,      "N",     "d",      OL|LN|CC,
    "Event",            NO, 0, OP_EVENT,       "N",     "e",      0,
    "Field",            NO, 0, OP_FIELD,       "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",       NO, 0, OP_IDXFIELD,    "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",           NO, 0, OP_METHOD,      "NKk",   "m!E",    CL|OL|LN|AF|CC,
    "Mutex",            NO, 0, OP_MUTEX,       "NB",    "x",      0,
    "OperationRegion",  NO, 0, OP_OPREGION,    "NKCC",  "oDUU",   AF,
    "PowerResource",    NO, 0, OP_POWERRES,    "NBW",   "p",      OL|LN|CC,
    "Processor",        NO, 0, OP_PROCESSOR,   "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",      NO, 0, OP_THERMALZONE, "N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",            C1, 0, OP_BREAK,      NULL,  NULL,  0,
    "BreakPoint",       C1, 0, OP_BREAKPOINT, NULL,  NULL,  0,
    "Else",             C1, 0, OP_ELSE,       NULL,  NULL,  AF|CL|OL|LN,
    "Fatal",            C1, 0, OP_FATAL,      "BDC", "  U", 0,
    "If",               C1, 0, OP_IF,         "C",   "U",   CL|OL|LN,
    "Load",             C1, 0, OP_LOAD,       "NS",  "UU",  0,
    "Noop",             C1, 0, OP_NOP,        NULL,  NULL,  0,
    "Notify",           C1, 0, OP_NOTIFY,     "SC",  "UU",  0,
    "Release",          C1, 0, OP_RELEASE,    "S",   "X",   0,
    "Reset",            C1, 0, OP_RESET,      "S",   "E",   0,
    "Return",           C1, 0, OP_RETURN,     "C",   "U",   0,
    "Signal",           C1, 0, OP_SIGNAL,     "S",   "E",   0,
    "Sleep",            C1, 0, OP_SLEEP,      "C",   "U",   0,
    "Stall",            C1, 0, OP_STALL,      "C",   "U",   0,
    "Unload",           C1, 0, OP_UNLOAD,     "S",   "U",   0,
    "While",            C1, 0, OP_WHILE,      "C",   "U",   CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",          C2, 0, OP_ACQUIRE,     "SW",     "X",      0,
    "Add",              C2, 0, OP_ADD,         "CCS",    "UUU",    0,
    "And",              C2, 0, OP_AND,         "CCS",    "UUU",    0,
    "Concatenate",      C2, 0, OP_CONCAT,      "CCS",    "UUU",    0,
    "CondRefOf",        C2, 0, OP_CONDREFOF,   "SS",     "UU",     0,
    "Decrement",        C2, 0, OP_DECREMENT,   "S",      "U",      0,
    "DerefOf",		C2, 0, OP_DEREFOF,     "C",      "U",      0,
    "Divide",           C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",   0,
    "FindSetLeftBit",   C2, 0, OP_FINDSETLBIT, "CS",     "UU",     0,
    "FindSetRightBit",  C2, 0, OP_FINDSETRBIT, "CS",     "UU",     0,
    "FromBCD",          C2, 0, OP_FROMBCD,     "CS",     "UU",     0,
    "Increment",        C2, 0, OP_INCREMENT,   "S",      "U",      0,
    "Index",            RO|C2, 0, OP_INDEX,    "CCS",    "UUU",    0,
    "LAnd",             C2, 0, OP_LAND,        "CC",     "UU",     0,
    "LEqual",           C2, 0, OP_LEQ,         "CC",     "UU",     0,
    "LGreater",         C2, 0, OP_LG,          "CC",     "UU",     0,
    "LGreaterEqual",    C2, 0, OP_LGEQ,        "CC",     "UU",     0,
    "LLess",            C2, 0, OP_LL,          "CC",     "UU",     0,
    "LLessEqual",       C2, 0, OP_LLEQ,        "CC",     "UU",     0,
    "LNot",             C2, 0, OP_LNOT,        "C",      "U",      0,
    "LNotEqual",        C2, 0, OP_LNOTEQ,      "CC",     "UU",     0,
    "LOr",              C2, 0, OP_LOR,         "CC",     "UU",     0,
    "Match",            C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU", AF,
    "Multiply",         C2, 0, OP_MULTIPLY,    "CCS",    "UUU",    0,
    "NAnd",             C2, 0, OP_NAND,        "CCS",    "UUU",    0,
    "NOr",              C2, 0, OP_NOR,         "CCS",    "UUU",    0,
    "Not",              C2, 0, OP_NOT,         "CS",     "UU",     0,
    "ObjectType",       C2, 0, OP_OBJTYPE,     "S",      "U",      0,
    "Or",               C2, 0, OP_OR,          "CCS",    "UUU",    0,
    "RefOf",            C2, 0, OP_REFOF,       "S",      "U",      0,
    "ShiftLeft",        C2, 0, OP_SHIFTL,      "CCS",    "UUU",    0,
    "ShiftRight",       C2, 0, OP_SHIFTR,      "CCS",    "UUU",    0,
    "SizeOf",           C2, 0, OP_SIZEOF,      "S",      "U",      0,
    "Store",            C2, 0, OP_STORE,       "CS",     "UU",     0,
    "Subtract",         C2, 0, OP_SUBTRACT,    "CCS",    "UUU",    0,
    "ToBCD",            C2, 0, OP_TOBCD,       "CS",     "UU",     0,
    "Wait",             C2, 0, OP_WAIT,        "SC",     "E",      0,
    "XOr",              C2, 0, OP_XOR,         "CCS",    "UUU",    0,

    NULL,               0,  0, OP_NONE, NULL, NULL, 0
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\stack.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.h

Abstract:

    Dumps the AML Context Structure in Human-Readable-Form (HRF)

Author:

    Stephane Plante (splante) 26-Oct-1997

Environment:

    User Mode.

Revision History:

--*/

#ifndef _STACK_H_
#define _STACK_H_

VOID
stackArgument(
    IN  ULONG_PTR ObjectAddress
    );

VOID
stackCall(
    IN  ULONG_PTR CallAddress
    );

PUCHAR
stackGetAmlTermPath(
    IN  ULONG_PTR AmlTermAddress
    );

PUCHAR
stackGetObjectPath(
    IN  ULONG_PTR AmlTermAddress
    );

VOID
stackTerm(
    IN  ULONG_PTR TermAddress
    );

VOID
stackTrace(
    IN  ULONG_PTR ContextAddress,
    IN  ULONG   Verbose
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\udata.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DATA_H
#define _DATA_H

    //
    // Constants
    //

    // String constants
    #define STR_PROGDESC            "ACPI Source Language Assembler"
    #define STR_COPYRIGHT           "Copyright (c) 1996,1997 Microsoft Corporation"
    #define STR_MS                  "MSFT"

    // Misc. constants
    #define NAMESEG_BLANK           0x5f5f5f5f      // "____"
    #define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
    #define NAMESEG                 ULONG
    #define SUPERNAME               NAMESEG
    #define NSF_LOCAL_SCOPE         0x00000001


    // Implementation constants
    #define MAX_STRING_LEN          199
    #define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
    #define MAX_MSG_LEN             127
    #define MAX_ARGS                7
    #define MAX_PACKAGE_LEN         0x0fffffff

    // Term classes
    #define UTC_PNP_MACRO           0x00100000
    #define UTC_REF_OBJECT          0x00200000
    #define UTC_FIELD_MACRO         0x00400000
    #define UTC_DATA_OBJECT         0x00800000
    #define UTC_NAMED_OBJECT        0x01000000
    #define UTC_NAMESPACE_MODIFIER  0x02000000
    #define UTC_OPCODE_TYPE1        0x04000000
    #define UTC_OPCODE_TYPE2        0x08000000
    #define UTC_CONST_NAME          0x10000000
    #define UTC_SHORT_NAME          0x20000000
    #define UTC_COMPILER_DIRECTIVE  0x40000000
    #define UTC_KEYWORD             0x80000000
    #define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 | \
                                     UTC_SHORT_NAME | UTC_CONST_NAME | \
                                     UTC_DATA_OBJECT)
    #define UTC_OPCODE_TERM         (UTC_CONST_NAME | UTC_SHORT_NAME | \
                                     UTC_DATA_OBJECT | UTC_NAMED_OBJECT | \
                                     UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 | \
                                     UTC_NAMESPACE_MODIFIER)

    // Term flags
    #define TF_ACTION_FLIST         0x00000001
    #define TF_ACTION_VLIST         0x00000002
    #define TF_PACKAGE_LEN          0x00000004
    #define TF_CHANGE_CHILDSCOPE    0x00000008
    #define TF_DELAY_UNASM          0x00000010
    #define TF_FIELD_MACRO          UTC_FIELD_MACRO
    #define TF_DATA_OBJECT          UTC_DATA_OBJECT
    #define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
    #define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
    #define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
    #define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
    #define TF_CONST_NAME           UTC_CONST_NAME
    #define TF_SHORT_NAME           UTC_SHORT_NAME
    #define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
    #define TF_KEYWORD              UTC_KEYWORD
    #define TF_PNP_MACRO            UTC_PNP_MACRO
    #define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
    #define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
    #define TF_DATA_LIST            0x00010000
    #define TF_FIELD_LIST           0x00020000
    #define TF_BYTE_LIST            0x00040000
    #define TF_DWORD_LIST           0x00080000
    #define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                     UTC_CONST_NAME)
    #define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                     TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                     TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                     TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                     TF_DATA_LIST | TF_PACKAGE_LIST | \
                                     TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                     TF_DWORD_LIST)

    // Code flags
    #define CF_MISSING_ARG          0x00000001
    #define CF_PARSING_FIXEDLIST    0x00000002
    #define CF_PARSING_VARLIST      0x00000004

    // NS flags
    #define NSF_EXIST_OK            0x00010000
    #define NSF_EXIST_ERR           0x00020000

    // Data types
    #define CODETYPE_UNKNOWN        0
    #define CODETYPE_ASLTERM        1
    #define CODETYPE_NAME           2
    #define CODETYPE_DATAOBJ        3
    #define CODETYPE_FIELDOBJ       4
    #define CODETYPE_INTEGER        5
    #define CODETYPE_STRING         6
    #define CODETYPE_KEYWORD        7
    #define CODETYPE_USERTERM       8
    #define CODETYPE_QWORD          9

    // NameSpace object types
    #define NSTYPE_UNKNOWN          'U'
    #define NSTYPE_SCOPE            'S'
    #define NSTYPE_FIELDUNIT        'F'
    #define NSTYPE_DEVICE           'D'
    #define NSTYPE_EVENT            'E'
    #define NSTYPE_METHOD           'M'
    #define NSTYPE_MUTEX            'X'
    #define NSTYPE_OPREGION         'O'
    #define NSTYPE_POWERRES         'P'
    #define NSTYPE_PROCESSOR        'C'
    #define NSTYPE_THERMALZONE      'T'
    #define NSTYPE_OBJALIAS         'A'
    #define NSTYPE_BUFFFIELD        'B'

    #define OBJTYPE_PRIVATE         0xf0
    #define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
    #define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)

    // Opcode classes
    #define OPCLASS_INVALID         0
    #define OPCLASS_DATA_OBJ        1
    #define OPCLASS_NAME_OBJ        2
    #define OPCLASS_CONST_OBJ       3
    #define OPCLASS_CODE_OBJ        4
    #define OPCLASS_ARG_OBJ         5
    #define OPCLASS_LOCAL_OBJ       6

    //dwfData flags
    #define DATAF_BUFF_ALIAS        0x00000001
    #define DATAF_GLOBAL_LOCK       0x00000002

    //dwDataType values
    #define OBJTYPE_UNKNOWN         0x00
    #define OBJTYPE_INTDATA         0x01
    #define OBJTYPE_STRDATA         0x02
    #define OBJTYPE_BUFFDATA        0x03
    #define OBJTYPE_PKGDATA         0x04
    #define OBJTYPE_FIELDUNIT       0x05
    #define OBJTYPE_DEVICE          0x06
    #define OBJTYPE_EVENT           0x07
    #define OBJTYPE_METHOD          0x08
    #define OBJTYPE_MUTEX           0x09
    #define OBJTYPE_OPREGION        0x0a
    #define OBJTYPE_POWERRES        0x0b
    #define OBJTYPE_PROCESSOR       0x0c
    #define OBJTYPE_THERMALZONE     0x0d
    #define OBJTYPE_BUFFFIELD       0x0e
    #define OBJTYPE_DDBHANDLE       0x0f

    //These are internal object types (not to be exported to the ASL code)
    #define OBJTYPE_INTERNAL        0x80

    //Predefined data values (dwDataValue)
    #define DATAVALUE_ZERO          0
    #define DATAVALUE_ONE           1
    #define DATAVALUE_ONES          0xffffffff

    //
    // Macros
    //
    #define MEMALLOC(n)           malloc(n)
    #define MEMFREE(p)            free(p)

    //
    // Type definitions
    //
    typedef int (LOCAL *PFNTERM)(PUCHAR, BOOL);

    typedef struct _aslterm
    {
        PUCHAR  ID;
        ULONG   TermClass;
        ULONG   TermData;
        ULONG   OpCode;
        PUCHAR  UnAsmArgTypes;
        PUCHAR  ArgActions;
        ULONG   Flags;
    } ASLTERM, *PASLTERM;

    typedef struct _opmap
    {
        UCHAR   ExtendedOpCode;
        UCHAR   OpCodeClass;
    } OPMAP, *POPMAP;

    extern ASLTERM  TermTable[];
    extern UCHAR    OpClassTable[];
    extern OPMAP    ExOpClassTable[];

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\strlib.c ===
/*** strlib.c - string functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/09/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***EP  StrLen - determine string length
 *
 *  ENTRY
 *      psz -> string
 *	n - limiting length
 *
 *  EXIT
 *      returns string length
 */

ULONG EXPORT StrLen(PSZ psz, ULONG n)
{
    TRACENAME("STRLEN")
    ULONG dwLen;

    ENTER(5, ("StrLen(str=%s,n=%d)\n", psz, n));

    ASSERT(psz != NULL);
    if (n != (ULONG)-1)
        n++;
    for (dwLen = 0; (dwLen <= n) && (*psz != '\0'); psz++)
        dwLen++;

    EXIT(5, ("StrLen=%u\n", dwLen));
    return dwLen;
}       //StrLen

/***EP  StrCpy - copy string
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to copy
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCPY")
    ULONG dwSrcLen;

    ENTER(5, ("StrCpy(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    MEMCPY(pszDst, pszSrc, n);
    pszDst[n] = '\0';

    EXIT(5, ("StrCpy=%s\n", pszDst));
    return pszDst;
}       //StrCpy

/***EP  StrCat - concatenate strings
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to concatenate
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCat(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCAT")
    ULONG dwSrcLen, dwDstLen;

    ENTER(5, ("StrCat(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    dwDstLen = StrLen(pszDst, (ULONG)(-1));
    MEMCPY(&pszDst[dwDstLen], pszSrc, n);
    pszDst[dwDstLen + n] = '\0';

    EXIT(5, ("StrCat=%s\n", pszDst));
    return pszDst;
}       //StrCat

/***EP  StrCmp - compare strings
 *
 *  ENTRY
 *      psz1 -> string 1
 *      psz2 -> string 2
 *      n - number of bytes to compare
 *      fMatchCase - TRUE if case sensitive
 *
 *  EXIT
 *      returns 0  if string 1 == string 2
 *              <0 if string 1 < string 2
 *              >0 if string 1 > string 2
 */

LONG EXPORT StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase)
{
    TRACENAME("STRCMP")
    LONG rc;
    ULONG dwLen1, dwLen2;
    ULONG i;

    ENTER(5, ("StrCmp(s1=%s,s2=%s,n=%d,fMatchCase=%d)\n",
              psz1, psz2, n, fMatchCase));

    ASSERT(psz1 != NULL);
    ASSERT(psz2 != NULL);

    dwLen1 = StrLen(psz1, n);
    dwLen2 = StrLen(psz2, n);
    if (n == (ULONG)(-1))
        n = (dwLen1 > dwLen2)? dwLen1: dwLen2;

    if (fMatchCase)
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(psz1[i] - psz2[i]);
        }
    }
    else
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(TOUPPER(psz1[i]) - TOUPPER(psz2[i]));
        }
    }

    if ((rc == 0) && (i < n))
    {
        if (i < dwLen1)
            rc = (LONG)psz1[i];
        else if (i < dwLen2)
            rc = (LONG)(-psz2[i]);
    }

    EXIT(5, ("StrCmp=%d\n", rc));
    return rc;
}       //StrCmp

/***EP  StrChr - look for a character in a string
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = pszStr; (*psz != c) && (*psz != '\0'); psz++)
        ;

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrChr=%x\n", psz));
    return psz;
}       //StrChr

/***EP  StrRChr - look for a character in a string in reverse direction
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrRChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = &pszStr[StrLen(pszStr, (ULONG)-1)];
         (*psz != c) && (psz > pszStr);
	 psz--)
    {
    }

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrRChr=%x\n", psz));
    return psz;
}       //StrRChr

/***EP  StrTok - find the next token in string
 *
 *  ENTRY
 *      pszStr -> string containing tokens
 *      pszSep -> string containing delimiters
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the beginning of the token
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrTok(PSZ pszStr, PSZ pszSep)
{
    TRACENAME("STRTOK")
    static PSZ pszNext = NULL;


    ENTER(5, ("StrTok(Str=%s,Sep=%s)\n", pszStr, pszSep));

    ASSERT(pszSep != NULL);

    if (pszStr == NULL)
        pszStr = pszNext;

    if (pszStr != NULL)
    {
        //
        // Skip leading delimiter characters
        //
        while ((*pszStr != '\0') && (StrChr(pszSep, *pszStr) != NULL))
            pszStr++;

        for (pszNext = pszStr;
             (*pszNext != '\0') && (StrChr(pszSep, *pszNext) == NULL);
             pszNext++)
            ;

        if (*pszStr == '\0')
            pszStr = NULL;
        else if (*pszNext != '\0')
        {
            *pszNext = '\0';
            pszNext++;
        }
    }

    EXIT(5, ("StrTok=%s (Next=%s)\n",
             pszStr? pszStr: "(null)", pszNext? pszNext: "(null)"));
    return pszStr;
}       //StrTok

/***EP  StrToUL - convert the number in a string to a unsigned long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

ULONG EXPORT StrToUL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOUL")
    ULONG n = 0;
    ULONG m;

    ENTER(5, ("StrToUL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (dwBase == 0)
    {
        if (psz[0] == '0')
        {
            if ((psz[1] == 'x') || (psz[1] == 'X'))
            {
                dwBase = 16;
                psz += 2;
            }
            else
            {
                dwBase = 8;
                psz++;
            }
        }
        else
            dwBase = 10;
    }

    while (*psz != '\0')
    {
        if ((*psz >= '0') && (*psz <= '9'))
            m = *psz - '0';
        else if ((*psz >= 'A') && (*psz <= 'Z'))
            m = *psz - 'A' + 10;
        else if ((*psz >= 'a') && (*psz <= 'z'))
            m = *psz - 'a' + 10;
	else
	    break;

        if (m < dwBase)
        {
            n = (n*dwBase) + m;
            psz++;
        }
        else
            break;
    }

    if (ppszEnd != NULL)
        *ppszEnd = psz;

    EXIT(5, ("StrToUL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToUL

/***EP  StrToL - convert the number in a string to a long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

LONG EXPORT StrToL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOL")
    LONG n = 0;
    BOOLEAN fMinus;

    ENTER(5, ("StrToL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (*psz == '-')
    {
        fMinus = TRUE;
        psz++;
    }
    else
        fMinus = FALSE;

    n = (LONG)StrToUL(psz, ppszEnd, dwBase);

    if (fMinus)
        n = -n;

    EXIT(5, ("StrToL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToL

/***EP  StrStr - find a substring in a given string
 *
 *  ENTRY
 *      psz1 -> string to be searched
 *      psz2 -> substring to find
 *
 *  EXIT-SUCCESS
 *      returns pointer to psz1 where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrStr(PSZ psz1, PSZ psz2)
{
    TRACENAME("STRSTR")
    PSZ psz = psz1;
    ULONG dwLen;

    ENTER(5, ("StrStr(psz1=%s,psz2=%s)\n", psz1, psz2));

    dwLen = StrLen(psz2, (ULONG)-1);
    while ((psz = StrChr(psz, *psz2)) != NULL)
    {
        if (StrCmp(psz, psz2, dwLen, TRUE) == 0)
            break;
        else
            psz++;
    }

    EXIT(5, ("StrStr=%s\n", psz));
    return psz;
}       //StrStr

/***EP  StrUpr - convert string to upper case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrUpr(PSZ pszStr)
{
    TRACENAME("STRUPR")
    PSZ psz;

    ENTER(5, ("StrUpr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOUPPER(*psz);
    }

    EXIT(5, ("StrUpr=%s\n", pszStr));
    return pszStr;
}       //StrUpr

/***EP  StrLwr - convert string to lower case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrLwr(PSZ pszStr)
{
    TRACENAME("STRLWR")
    PSZ psz;

    ENTER(5, ("StrLwr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOLOWER(*psz);
    }

    EXIT(5, ("StrLwr=%s\n", pszStr));
    return pszStr;
}       //StrLwr

/***EP  UlToA - convert an unsigned long value to a string
 *
 *  ENTRY
 *      dwValue - data
 *      pszStr -> string
 *      dwRadix - radix
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT UlToA(ULONG dwValue, PSZ pszStr, ULONG dwRadix)
{
    TRACENAME("ULTOA")
    PSZ psz;
    char ch;

    ENTER(5, ("UlToA(Value=%x,pszStr=%x,Radix=%d\n", dwValue, pszStr, dwRadix));

    for (psz = pszStr; dwValue != 0; dwValue/=dwRadix, psz++)
    {
        ch = (char)(dwValue%dwRadix);
        if (ch <= 9)
        {
            *psz = (char)(ch + '0');
        }
        else
        {
            *psz = (char)(ch - 10 + 'A');
        }
    }

    if (psz == pszStr)
    {
        pszStr[0] = '0';
        pszStr[1] = '\0';
    }
    else
    {
        PSZ psz2;

        *psz = '\0';
        for (psz2 = pszStr, psz--; psz2 < psz; psz2++, psz--)
        {
            ch = *psz2;
            *psz2 = *psz;
            *psz = ch;
        }
    }

    EXIT(5, ("UlToA=%s\n", pszStr));
    return pszStr;
}       //UlToA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\table.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

extern  FILE    *outputFile;

BOOL
ReadPhysicalOrVirtual(
    IN      ULONG_PTR Address,
    IN      PVOID   Buffer,
    IN      ULONG   Size,
    IN  OUT PULONG  ReturnLength,
    IN      BOOL    Virtual
    )
/*++

Routine Description:

    This is a way to abstract out the differences between ROM images
    and mapped memory

Arguments:

    Address         - Where (either physical, or virtual) the buffer is located
    Buffer          - Address of where to copy the memory to
    Size            - How many bytes to copy (maximum)
    ReturnLength    - How many bytes where copied
    Virtual         - False if this is physical memory

--*/
{
    BOOL                status = TRUE;
    PHYSICAL_ADDRESS    physicalAddress = { 0L, 0L };

    if (Virtual) {

        status = ReadMemory(
            Address,
            Buffer,
            Size,
            ReturnLength
            );

    } else {

        physicalAddress.QuadPart = Address;
        ReadPhysical(
            physicalAddress.QuadPart,
            Buffer,
            Size,
            ReturnLength
            );

    }

    if (ReturnLength && *ReturnLength != Size) {

        //
        // Didn't get enough memory
        //
        status = FALSE;

    }
    return status;
}

VOID
dumpAcpiGpeInformation(
    VOID
    )
{
    ACPIInformation acpiInformation;
    BOOL            status;
    UCHAR           gpeEnable[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeCurEnable[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeWakeEnable[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeIsLevel[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeHandlerType[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeWakeHandler[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeSpecialHandler[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpePending[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeMap[MAX_GPE_BUFFER_SIZE * 8];
    UCHAR           gpeRunMethod[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeComplete[MAX_GPE_BUFFER_SIZE];
    ULONG_PTR       address;
    ULONG           acpiGpeRunning;
    ULONG           acpiGpeWorkDone;
    ULONG           returnLength;
    ULONG           size;
    ULONG           value = 0;
    ULONG           i;

    //
    // Get the ACPI Information Table
    //
    status = GetUlongPtr("ACPI!AcpiInformation", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!AcpiInformation\n");
        return;

    }
    status = ReadMemory(
        address,
        &acpiInformation,
        sizeof(ACPIInformation),
        &returnLength
        );
    if (!status || returnLength != sizeof(ACPIInformation)) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            sizeof(ACPIInformation),
            address
            );
        return;

    }

    //
    // Read the current masks from the OS
    //
    status = GetUlongPtr("ACPI!GpeEnable", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeEnable\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeEnable,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeCurEnable", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeCurEnable\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeCurEnable,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeWakeEnable", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeWakeEnable\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeWakeEnable,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeIsLevel", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeIsLevel\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeIsLevel,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeHandlerType", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeHandlerType\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeHandlerType,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeWakeHandler", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeWakeHandler\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeWakeHandler,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeSpecialHandler", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeSpecialHandler\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeSpecialHandler,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpePending", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpePending\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpePending,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeRunMethod", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpePending\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeRunMethod,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeComplete", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpePending\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeComplete,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeMap", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeMap\n");
        return;

    }
    status = ReadMemory(
        address,
        &gpeMap,
        (acpiInformation.GpeSize * 8),
        &returnLength
        );
    if (!status || returnLength != (ULONG) (acpiInformation.GpeSize * 8) ) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            (acpiInformation.GpeSize * 8),
            address
            );
        return;

    }

    status = GetUlong( "ACPI!AcpiGpeDpcRunning", &acpiGpeRunning );
    if (status == FALSE) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!AcpiGpeDpcRunning\n");
        return;

    }

    status = GetUlong( "ACPI!AcpiGpeWorkDone", &acpiGpeWorkDone );
    if (status == FALSE) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!AcpiGpeDpcRunning\n");
        return;

    }

    dprintf("ACPI General Purpose Events\n");
    dprintf("  + AcpiGpeDpcRunning = %s\n", (acpiGpeRunning ? "TRUE" : "FALSE" ) );
    dprintf("  + AcpiGpeWorkDone   = %s\n", (acpiGpeRunning ? "TRUE" : "FALSE" ) );
    dprintf(
        "   Register Size:     %d bytes\n",
        (acpiInformation.Gpe0Size + acpiInformation.Gpe1Size)
        );

    dprintf("   Status Register:  ");
    for (i = acpiInformation.Gpe1Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP1_BLK + (i - 1), &value, &size );
        if (!size) {


        }
        dprintf(" %02x", value );

    }
    for (i = acpiInformation.Gpe0Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP0_BLK + (i - 1), &value, &size );
        if (!size) {

            value = 0;

        }
        dprintf(" %02x", value );

    }
    dprintf("\n");

    dprintf("   Enable Register:  ");
    for (i = acpiInformation.Gpe1Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP1_ENABLE + (i - 1), &value, &size );
        if (!size) {

            value = 0;

        }
        dprintf(" %02x", value );

    }
    for (i = acpiInformation.Gpe0Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP0_ENABLE + (i - 1), &value, &size );
        if (!size) {

            value = 0;

        }
        dprintf(" %02x", value );

    }
    dprintf("\n");

    dprintf("   OS Enable Mask:   ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeEnable[i-1] );

    }
    dprintf("\n");
    dprintf("   OS Current Mask:  ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeCurEnable[i-1] );

    }
    dprintf("\n");
    dprintf("   OS Wake Mask:     ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeWakeEnable[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Level Type:   ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeIsLevel[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Handler Type: ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeHandlerType[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Wake Handler: ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeWakeHandler[i-1] );

    }
    dprintf("\n");
    dprintf("   Special GPEs    : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeSpecialHandler[i-1] );

    }
    dprintf("\n");
    dprintf("   Pending GPEs    : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpePending[i-1] );

    }
    dprintf("\n");
    dprintf("   RunMethod GPEs  : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeRunMethod[i-1] );

    }
    dprintf("\n");
    dprintf("   Complete GPEs   : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeComplete[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Map         : ");
    for (i = 0 ; i < (ULONG) (acpiInformation.GpeSize * 8); i++) {

        dprintf(" %02x", gpeMap[i]);
        if ( ((i+1) % 16) == 0) {

            dprintf("\n                     ");

        }

    }
    dprintf("\n");
}

VOID
dumpAcpiInformation(
    VOID
    )
{
    BOOL            status;
    ACPIInformation acpiInformation;
    ULONG_PTR       address;
    ULONG           returnLength;
    ULONG           size;
    ULONG           value;
    ULONG           i;

    status = GetUlongPtr( "ACPI!AcpiInformation", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiInformation: Could not read ACPI!AcpiInformation\n");
        return;

    }

    status = ReadMemory(
        address,
        &acpiInformation,
        sizeof(ACPIInformation),
        &returnLength
        );
    if (!status || returnLength != sizeof(ACPIInformation)) {

        dprintf(
            "dumpAcpiInformation: Could not read %x bytes at %x\n",
            sizeof(ACPIInformation),
            address
            );
        return;

    }

    dprintf("ACPIInformation (%08lx)\n", address);
    dprintf(
        "  RSDT                     - %x\n",
        acpiInformation.RootSystemDescTable
        );
    dprintf(
        "  FADT                     - %x\n",
        acpiInformation.FixedACPIDescTable
        );
    dprintf(
        "  FACS                     - %x\n",
        acpiInformation.FirmwareACPIControlStructure
        );
    dprintf(
        "  DSDT                     - %x\n",
        acpiInformation.DiffSystemDescTable
        );
    dprintf(
        "  GlobalLock               - %x\n",
        acpiInformation.GlobalLock
        );
    dprintf(
        "  GlobalLockQueue          - F - %x B - %x\n",
        acpiInformation.GlobalLockQueue.Flink,
        acpiInformation.GlobalLockQueue.Blink
        );
    dprintf(
        "  GlobalLockQueueLock      - %x\n",
        acpiInformation.GlobalLockQueueLock
        );
    dprintf(
        "  GlobalLockOwnerContext   - %x\n",
        acpiInformation.GlobalLockOwnerContext
        );
    dprintf(
        "  GlobalLockOwnerDepth     - %x\n",
        acpiInformation.GlobalLockOwnerDepth
        );
    dprintf(
        "  ACPIOnly                 - %s\n",
        (acpiInformation.ACPIOnly ? "TRUE" : "FALSE" )
        );
    dprintf(
        "  PM1a_BLK                 - %x",
        acpiInformation.PM1a_BLK
        );
    if (acpiInformation.PM1a_BLK) {

        size = 4;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1a_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x) (%04x)\n", (value & 0xFFFF), (value >> 16) );
            dumpPM1StatusRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  PM1b_BLK                 - %x",
        acpiInformation.PM1b_BLK
        );
    if (acpiInformation.PM1b_BLK) {

        size = 4;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1b_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x) (%04x)\n", (value & 0xFFFF), (value >> 16) );
            dumpPM1StatusRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM1a_CTRL_BLK            - %x",
        acpiInformation.PM1a_CTRL_BLK
        );
    if (acpiInformation.PM1a_CTRL_BLK) {

        size = 2;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1a_CTRL_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x)\n", (value & 0xFFFF) );
            dumpPM1ControlRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM1b_CTRL_BLK            - %x",
        acpiInformation.PM1b_CTRL_BLK
        );

    if (acpiInformation.PM1b_CTRL_BLK) {

        size = 2;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1b_CTRL_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x)\n", (value & 0xFFFF));
            dumpPM1ControlRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM2_CTRL_BLK             - %x",
        acpiInformation.PM2_CTRL_BLK
        );
    if (acpiInformation.PM2_CTRL_BLK) {

        size = 1;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM2_CTRL_BLK, &value, &size );
        if (size) {

            dprintf(" (%02x)\n", (value & 0xFF) );
            if (value & 0x1) {

                dprintf("     0 - ARB_DIS\n");

            }

        } else {

            dprintf(" (N/A)\n");

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  PM_TMR                   - %x",
        acpiInformation.PM_TMR
        );
    if (acpiInformation.PM_TMR) {

        size = 4;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM_TMR, &value, &size );
        if (size) {

            dprintf(" (%08lx)\n", value );

        } else {

            dprintf(" (N/A)\n");

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_BLK                  - %x",
        acpiInformation.GP0_BLK
        );
    if (acpiInformation.GP0_BLK) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP0_BLK + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_ENABLE               - %x",
        acpiInformation.GP0_ENABLE
        );
    if (acpiInformation.GP0_ENABLE) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP0_ENABLE + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_LEN                  - %x\n",
        acpiInformation.GP0_LEN
        );
    dprintf(
        "  GP0_SIZE                 - %x\n",
        acpiInformation.Gpe0Size
        );
    dprintf(
        "  GP1_BLK                  - %x",
        acpiInformation.GP1_BLK
        );
    if (acpiInformation.GP1_BLK) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP1_BLK + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP1_ENABLE               - %x",
        acpiInformation.GP1_ENABLE
        );
    if (acpiInformation.GP1_ENABLE) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP1_ENABLE + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP1_LEN                  - %x\n",
        acpiInformation.GP1_LEN
        );
    dprintf(
        "  GP1_SIZE                 - %x\n",
        acpiInformation.Gpe1Size
        );
    dprintf(
        "  GP1_BASE_INDEX           - %x\n",
        acpiInformation.GP1_Base_Index
        );
    dprintf(
        "  GPE_SIZE                 - %x\n",
        acpiInformation.GpeSize
        );
    dprintf(
        "  PM1_EN_BITS              - %04x\n",
        acpiInformation.pm1_en_bits
        );
    dumpPM1StatusRegister( ( (ULONG) acpiInformation.pm1_en_bits << 16), 5 );
    dprintf(
        "  PM1_WAKE_MASK            - %04x\n",
        acpiInformation.pm1_wake_mask
        );
    dumpPM1StatusRegister( ( (ULONG) acpiInformation.pm1_wake_mask << 16), 5 );
    dprintf(
        "  C2_LATENCY               - %x\n",
        acpiInformation.c2_latency
        );
    dprintf(
        "  C3_LATENCY               - %x\n",
        acpiInformation.c3_latency
        );
    dprintf(
        "  ACPI_FLAGS               - %x\n",
        acpiInformation.ACPI_Flags
        );
    if (acpiInformation.ACPI_Flags & C2_SUPPORTED) {

        dprintf("    %2d - C2_SUPPORTED\n", C2_SUPPORTED_BIT);

    }
    if (acpiInformation.ACPI_Flags & C3_SUPPORTED) {

        dprintf("    %2d - C3_SUPPORTED\n", C3_SUPPORTED_BIT);

    }
    if (acpiInformation.ACPI_Flags & C3_PREFERRED) {

        dprintf("    %2d - C3_PREFERRED\n", C3_PREFERRED_BIT);

    }
    dprintf(
        "  ACPI_CAPABILITIES        - %x\n",
        acpiInformation.ACPI_Capabilities
        );
    if (acpiInformation.ACPI_Capabilities & CSTATE_C1) {

        dprintf("    %2d - CSTATE_C1\n", CSTATE_C1_BIT );

    }    if (acpiInformation.ACPI_Capabilities & CSTATE_C2) {

        dprintf("    %2d - CSTATE_C2\n", CSTATE_C2_BIT );

    }    if (acpiInformation.ACPI_Capabilities & CSTATE_C3) {

        dprintf("    %2d - CSTATE_C3\n", CSTATE_C3_BIT );

    }
}

#if 0
VOID
dumpDSDT(
    IN  ULONG_PTR Address,
    IN  PUCHAR  Name
    )
/*++

Routine Description:

    This dumps the DSDT at the specified address

Arguments:

    The address where the DSDT is located at

Return Value:

    None

--*/
{
    BOOL                status;
    BOOL                virtualMemory;
    DESCRIPTION_HEADER  dsdtHeader;
    NTSTATUS            result;
    PDSDT               dsdt;
    ULONG               returnLength;
    ULONG               index;

    //
    // Determine if we have virtual or physical memory
    //
    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &dsdtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status) {

            continue;

        } else if (dsdtHeader.Signature != DSDT_SIGNATURE &&
                   dsdtHeader.Signature != SSDT_SIGNATURE &&
                   dsdtHeader.Signature != PSDT_SIGNATURE ) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpDSDT: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpDSDT: Unknown Signature 0x%08lx\n",
                dsdtHeader.Signature
                );
            dumpHeader( Address, &dsdtHeader, TRUE );

        }
        return;
    } // switch

    //
    // Do we have a correctly sized data structure
    //
    dsdt = LocalAlloc( LPTR, dsdtHeader.Length );
    if (dsdt == NULL) {

        dprintf(
            "dumpDSDT: Could not allocate %#08lx bytes\n",
            Address,
            dsdtHeader.Length
            );
        dumpHeader( Address, &dsdtHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        dsdt,
        dsdtHeader.Length,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpDSDT: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            dsdtHeader.Length
            );
        dumpHeader( Address, &dsdtHeader, TRUE );
        LocalFree( dsdt );
        return;

    } else if (dsdt->Header.Signature != DSDT_SIGNATURE &&
               dsdt->Header.Signature != SSDT_SIGNATURE &&
               dsdt->Header.Signature != PSDT_SIGNATURE) {

        dprintf(
            "dumpDSDT: Unkown Signature (%#08lx)\n",
            dsdt->Header.Signature
            );
        dumpHeader( Address, &dsdtHeader, TRUE );
        LocalFree( dsdt );
        return;

    }

    //
    // Load the DSDT into the unassembler
    //
    if (!IsDSDTLoaded()) {

        result = UnAsmLoadDSDT(
            (PUCHAR) dsdt
            );
        if (!NT_SUCCESS(result)) {

            dprintf(
                "dumpDSDT: Could not load DSDT %08lx because %08lx\n",
                dsdt,
                result
                );
            return;

        }
        result = UnAsmLoadXSDTEx();
        if (!NT_SUCCESS(result)) {

            dprintf(
                "dumpDSDT: Could not load XSDTs because %08lx\n",
                result
                );
            return;

        }

    }

    if (Name == NULL) {

        result = UnAsmDSDT(
            (PUCHAR) dsdt,
            DisplayPrint,
            Address,
            0
            );

    } else {

        outputFile = fopen( Name, "w");
        if (outputFile == NULL) {

            dprintf("dumpDSDT: Could not open file \"%s\"\n", Name );

        } else {

            result = UnAsmDSDT(
                (PUCHAR) dsdt,
                FilePrint,
                Address,
                0
                );

            fflush( outputFile );
            fclose( outputFile );

        }

    }

    if (!NT_SUCCESS(result)) {

        dprintf("dumpDSDT: Unasm Error 0x%08lx\n", result );

    }
    LocalFree( dsdt );
    return;
}
#endif

VOID
dumpFACS(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This dumps the FADT at the specified address

Arguments:

    The address where the FADT is located at

Return Value:

    NONE

--*/
{
    BOOL    status;
    FACS    facs;
    ULONG   index;
    ULONG   returnLength;

    //
    // Read the data
    //
    dprintf("FACS - %#08lx\n", Address);

    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &facs,
            sizeof(FACS),
            &returnLength,
            (BOOL) index
            );
        if (!status || facs.Signature != FACS_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    default:
        break;
    case 2:
        if (!status) {

            dprintf(
                "dumpFACS: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(FACS)
                );

        } else {

            dprintf(
                "dumpFACS: Invalid Signature 0x%08lx != FACS_SIGNATURE\n",
                facs.Signature
                );

        }
        return;
    } // switch

    //
    // Dump the table
    //
    memset( Buffer, 0, 2048 );
    memcpy( Buffer, &(facs.Signature), sizeof(ULONG) );
    dprintf(
        "  Signature:               %s\n"
        "  Length:                  %#08lx\n"
        "  Hardware Signature:      %#08lx\n"
        "  Firmware Wake Vector:    %#08lx\n"
        "  Global Lock :            %#08lx\n",
        Buffer,
        facs.Length,
        facs.HardwareSignature,
        facs.pFirmwareWakingVector,
        facs.GlobalLock
        );

    if ( (facs.GlobalLock & GL_PENDING) ) {

        dprintf("    Request for Ownership Pending\n");

    }
    if ( (facs.GlobalLock & GL_OWNER) ) {

        dprintf("    Global Lock is Owned\n");

    }
    dprintf("  Flags:                   %#08lx\n", facs.Flags );
    if ( (facs.Flags & FACS_S4BIOS_SUPPORTED) ) {

        dprintf("    S4BIOS_REQ Supported\n");

    }
    return;
}

VOID
dumpFADT(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This dumps the FADT at the specified address

Arguments:

    The address where the FADT is located at

Return Value:

    NONE

--*/
{
    BOOL                status;
    BOOL                virtualMemory;
    DESCRIPTION_HEADER  fadtHeader;
    FADT                fadt;
    ULONG               fadtLength;
    ULONG               returnLength;
    ULONG               index;
    PCHAR               addressSpace;

    //
    // First check to see if we find the correct things
    //
    dprintf("FADT - ");

    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &fadtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status || fadtHeader.Signature != FADT_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpFADT: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpFADT: Invalid Signature 0x%08lx != FADT_SIGNATURE\n",
                fadtHeader.Signature
                );
            dumpHeader( Address, &fadtHeader, TRUE );

        }
        return;
    } // switch

    if (fadtHeader.Revision == 1) {
        fadtLength = FADT_REV_1_SIZE; // 116
    } else if (fadtHeader.Revision == 2) {
        fadtLength = FADT_REV_2_SIZE; // 129
    } else {
        fadtLength = sizeof(FADT);
    }

    //
    // Do we have a correctly sized data structure
    //
    if (fadtHeader.Length < fadtLength) {

        dprintf(
            "dumpFADT: Length (%#08lx) is not the size of the FADT (%#08lx)\n",
            Address,
            fadtHeader.Length,
            fadtLength
            );
        dumpHeader( Address, &fadtHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        &fadt,
        fadtLength,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpFADT: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            sizeof(FADT)
            );
        dumpHeader( Address, &fadtHeader, TRUE );
        return;

    } else if (fadt.Header.Signature != FADT_SIGNATURE) {

        dprintf(
            "%#08lx: Signature (%#08lx) != fadt_SIGNATURE (%#08lx)\n",
            Address,
            fadt.Header.Signature,
            FADT_SIGNATURE
            );
        dumpHeader( Address, &fadtHeader, TRUE );
        return;

    }

    //
    // Dump the table
    //
    dumpHeader( Address, &(fadt.Header), TRUE );
    dprintf(
        "FADT - BODY - %#08lx\n"
        "  FACS:                    0x%08lx\n"
        "  DSDT:                    0x%08lx\n"
        "  Int Model:               %s\n"
        "  SCI Vector:              0x%03x\n"
        "  SMI Port:                0x%08lx\n"
        "  ACPI On Value:           0x%03x\n"
        "  ACPI Off Value:          0x%03x\n"
        "  SMI CMD For S4 State:    0x%03x\n"
        "  PM1A Event Block:        0x%08lx\n"
        "  PM1B Event Block:        0x%08lx\n"
        "  PM1 Event Length:        0x%03x\n"
        "  PM1A Control Block:      0x%08lx\n"
        "  PM1B Control Block:      0x%08lx\n"
        "  PM1 Control Length:      0x%03x\n"
        "  PM2 Control Block:       0x%08lx\n"
        "  PM2 Control Length:      0x%03x\n"
        "  PM Timer Block:          0x%08lx\n"
        "  PM Timer Length:         0x%03x\n"
        "  GP0 Block:               0x%08lx\n"
        "  GP0 Length:              0x%03x\n"
        "  GP1 Block:               0x%08lx\n"
        "  GP1 Length:              0x%08lx\n"
        "  GP1 Base:                0x%08lx\n"
        "  C2 Latency:              0x%05lx\n"
        "  C3 Latency:              0x%05lx\n"
        "  Memory Flush Size:       0x%05lx\n"
        "  Memory Flush Stride:     0x%05lx\n"
        "  Duty Cycle Index:        0x%03x\n"
        "  Duty Cycle Index Width:  0x%03x\n"
        "  Day Alarm Index:         0x%03x\n"
        "  Month Alarm Index:       0x%03x\n"
        "  Century byte (CMOS):     0x%03x\n"
        "  Boot Architecture:       0x%04x\n"
        "  Flags:                   0x%08lx\n",
        Address + sizeof(DESCRIPTION_HEADER),
        fadt.facs,
        fadt.dsdt,
        (fadt.int_model == 0 ? "Dual PIC" : "Multiple APIC" ),
        fadt.sci_int_vector,
        fadt.smi_cmd_io_port,
        fadt.acpi_on_value,
        fadt.acpi_off_value,
        fadt.s4bios_req,
        fadt.pm1a_evt_blk_io_port,
        fadt.pm1b_evt_blk_io_port,
        fadt.pm1_evt_len,
        fadt.pm1a_ctrl_blk_io_port,
        fadt.pm1b_ctrl_blk_io_port,
        fadt.pm1_ctrl_len,
        fadt.pm2_ctrl_blk_io_port,
        fadt.pm2_ctrl_len,
        fadt.pm_tmr_blk_io_port,
        fadt.pm_tmr_len,
        fadt.gp0_blk_io_port,
        fadt.gp0_blk_len,
        fadt.gp1_blk_io_port,
        fadt.gp1_blk_len,
        fadt.gp1_base,
        fadt.lvl2_latency,
        fadt.lvl3_latency,
#ifndef _IA64_   // XXTF
        fadt.flush_size,
        fadt.flush_stride,
        fadt.duty_offset,
        fadt.duty_width,
#endif
        fadt.day_alarm_index,
        fadt.month_alarm_index,
        fadt.century_alarm_index,
#ifndef _IA64_   // XXTF
        fadt.boot_arch,
#endif
        fadt.flags
        );
    if (fadt.flags & WRITEBACKINVALIDATE_WORKS) {

        dprintf("    Write Back Invalidate is supported\n");

    }
    if (fadt.flags & WRITEBACKINVALIDATE_DOESNT_INVALIDATE) {

        dprintf("    Write Back Invalidate doesn't invalidate the caches\n");

    }
    if (fadt.flags & SYSTEM_SUPPORTS_C1) {

        dprintf("    System cupports C1 Power state on all processors\n");

    }
    if (fadt.flags & P_LVL2_UP_ONLY) {

        dprintf("    System supports C2 in MP and UP configurations\n");

    }
    if (fadt.flags & PWR_BUTTON_GENERIC) {

        dprintf("    Power Button is treated as a generic feature\n");

    }
    if (fadt.flags & SLEEP_BUTTON_GENERIC) {

        dprintf("    Sleep Button is treated as a generic feature\n");

    }
    if (fadt.flags & RTC_WAKE_GENERIC) {

        dprintf("    RTC Wake is not supported in fixed register space\n");

    }
    if (fadt.flags & RTC_WAKE_FROM_S4) {

        dprintf("    RTC Wake can work from an S4 state\n");

    }
    if (fadt.flags & TMR_VAL_EXT) {

        dprintf("    TMR_VAL implemented as 32-bit value\n");

    }
#ifndef _IA64_   // XXTF
    if (fadt.Header.Revision > 1) {

        if (!(fadt.boot_arch & LEGACY_DEVICES)) {

            dprintf("    The machine does not contain legacy ISA devices\n");
        }
        if (!(fadt.boot_arch & I8042)) {

            dprintf("    The machine does not contain a legacy i8042\n");
        }
        if (fadt.flags & RESET_CAP) {

            dprintf("    The reset register is supported\n");
            dprintf("      Reset Val: %x\n", fadt.reset_val);

            switch (fadt.reset_reg.AddressSpaceID) {
            case 0:
                addressSpace = "Memory";
                break;
            case 1:
                addressSpace = "I/O";
                break;
            case 2:
                addressSpace = "PCIConfig";
                break;
            default:
                addressSpace = "undefined";
            }
            dprintf("      Reset register: %s - %08x'%08x\n",
                    addressSpace,
                    fadt.reset_reg.Address.HighPart,
                    fadt.reset_reg.Address.LowPart
                    );

        }

    }
#endif
    return;
}

VOID
dumpGBL(
    ULONG   Verbose
    )
/*++

Routine Description:

    This routine reads in all the system tables and prints out
    what the ACPI Good Bios List Entry for this machine should
    be

Arguments:

    None

Return Value:

    None

--*/
{
    ACPIInformation     inf;
    BOOL                status;
    DESCRIPTION_HEADER  hdr;
    ULONG64             dateAddress;
    PRSDTINFORMATION    info;
    PUCHAR              tempPtr;
    ULONG               i;
    ULONG               numElements;
    ULONG               returnLength;
    ULONG               size;
    ULONG_PTR           address;
    ULONG_PTR           address2;

    //
    // Remember where the date address is stored
    //
    dateAddress = 0xFFFF5;

    //
    // Make sure that we can read the pointer
    //
    address2 = GetExpression( "ACPI!RsdtInformation" );
    if (!address2) {

        dprintf("dumpGBL: Could not find RsdtInformation\n");
        return;

    }

    status = GetUlongPtr( "ACPI!RsdtInformation", &address );
    if (status == FALSE || !address) {

        dprintf("dumpGBL: No RsdtInformation present\n");
        return;

    }

    //
    // Read the ACPInformation table, so that we know where the RSDT lives
    //
    status = GetUlongPtr( "ACPI!AcpiInformation", &address2 );
    if (status == FALSE || !address2) {

        dprintf("dumpGBL: Could not read AcpiInformation\n");
        return;

    }
    status = ReadMemory( address2, &inf, sizeof(ACPIInformation), &returnLength );
    if (!status || returnLength != sizeof(ACPIInformation)) {

        dprintf("dumpGBL: Could not read AcpiInformation- %d %x\n", status, returnLength);
        return;

    }

    //
    // Read in the header for the RSDT
    //
    address2 = (ULONG_PTR) inf.RootSystemDescTable;
    status = ReadMemory( address2, &hdr, sizeof(DESCRIPTION_HEADER), &returnLength );
    if (!status || returnLength != sizeof(DESCRIPTION_HEADER)) {

        dprintf("dumpGBL: Could not read RSDT @%x - %d %x\n", address2, status, returnLength );
        return;

    }

    //
    // The number of elements in the table is the first entry
    // in the structure
    //
    status = ReadMemory(address, &numElements, sizeof(ULONG), &returnLength);
    if (status == FALSE || returnLength != sizeof(ULONG) ) {

        dprintf("dumpGBL: Could not read RsdtInformation\n");
        return;

    }

    //
    // If there are no elements, then return
    //
    if (numElements == 0) {

        dprintf("dumpGBL: No tables the RsdtInformation\n");
        return;

    }

    //
    // Allocate the table, and read in all the pointers
    //
    size = sizeof(RSDTINFORMATION) + ( (numElements - 1) * sizeof(RSDTELEMENT) );
    info = LocalAlloc( LPTR, size );
    if (info == NULL) {

        dprintf("dumpGBL: Could not allocate %x bytes for table\n", size);
        return;

    }

    //
    // Read the entire table
    //
    status = ReadMemory(
        address,
        info,
        size,
        &returnLength
        );
    if (!status || returnLength != size) {

        dprintf("dumpGBL: Could not read RsdtInformation Table\n");
        return;

    }

    //
    // Dump a header so that people know what this is
    //
    memset( Buffer, 0, 2048 );
    ReadPhysical( dateAddress, Buffer, 8, &returnLength );
    dprintf("\nGood Bios List Entry --- Machine BIOS Date %s\n\n", Buffer);

    memset( Buffer, 0, 2048 );
    memcpy( Buffer, hdr.OEMID, 6);
    tempPtr = Buffer;
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }
    memcpy( tempPtr, hdr.OEMTableID, 8 );
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }
    ReadPhysical( dateAddress, tempPtr, 8, &returnLength );
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }

    //
    // This is the entry name
    //
    dprintf("[%s]\n", Buffer );

    //
    // Dump the all the tables that are loaded in the RSDT table
    //
    for (i = 0; i < numElements; i++) {

        if (!(info->Tables[i].Flags & RSDTELEMENT_MAPPED) ) {

            continue;

        }

        dumpGBLEntry( (ULONG_PTR) info->Tables[i].Address, Verbose );

    }

    //
    // Dump the entry for the RSDT
    //
    dumpGBLEntry( (ULONG_PTR) inf.RootSystemDescTable, Verbose );

    //
    // Add some whitespace
    //
    dprintf("\n");

    //
    // Free the RSDT information structure
    //
    LocalFree( info );

    //
    // Done
    //
    return;
}

VOID
dumpGBLEntry(
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose
    )
/*++

Routine Description:

    This routine actually prints the rule for the table at the
    specified address

Arguments:

    Address - where the table is located

Return Value:

    None

--*/
{
    BOOL                status;
    DESCRIPTION_HEADER  header;
    ULONG               returnLength;
    UCHAR               tableId[7];
    UCHAR               entryId[20];


    //
    // Read the header for the table
    //
    status = ReadMemory(
        Address,
        &header,
        sizeof(DESCRIPTION_HEADER),
        &returnLength
        );
    if (!status || returnLength != sizeof(DESCRIPTION_HEADER)) {

        dprintf("dumpGBLEntry: %x - can't read header\n", Address );
        return;

    }

    //
    // Don't print out a table unless its the FACP or we are being verbose
    //
    if (!(Verbose & VERBOSE_2) && header.Signature != FADT_SIGNATURE) {

        return;

    }

    //
    // Initialize the table id field
    //
    memset( tableId, 0, 7 );
    tableId[0] = '\"';
    memcpy( &tableId[1], &(header.Signature), sizeof(ULONG) );
    strcat( tableId, "\"" );

    //
    // Get the entry ready for the OEM Id
    //
    memset( entryId, 0, 20 );
    entryId[0] = '\"';
    memcpy( &entryId[1], header.OEMID, 6 );
    strcat( entryId, "\"");
    dprintf("AcpiOemId=%s,%s\n", tableId, entryId );

    //
    // Get the entry ready for the OEM Table Id
    //
    memset( entryId, 0, 20 );
    entryId[0] = '\"';
    memcpy( &entryId[1], header.OEMTableID, 8 );
    strcat( entryId, "\"");
    dprintf("AcpiOemTableId=%s,%s\n", tableId, entryId );

    //
    // Get the entry ready for the OEM Revision
    //
    dprintf("AcpiOemRevision=\">=\",%s,%x\n", tableId, header.OEMRevision );

    //
    // Get the entry ready for the ACPI revision
    //
    if (header.Revision != 1) {

        dprintf("AcpiRevision=\">=\",%s,%x\n", tableId, header.Revision );

    }

    //
    // Get the entry ready for the ACPI Creator Revision
    //
    dprintf("AcpiCreatorRevision=\">=\",%s,%x\n", tableId, header.CreatorRev );

}

VOID
dumpHeader(
    IN  ULONG_PTR           Address,
    IN  PDESCRIPTION_HEADER Header,
    IN  BOOLEAN             Verbose
    )
/*++

Routine Description:

    This function dumps out a table header

Arugments:

    Address - Where the table is located
    Header  - The table header
    Verbose - How much information to give

Return Value:

    NULL

--*/
{
    memset( Buffer, 0, 2048 );
    memcpy( Buffer, &(Header->Signature), sizeof(ULONG) );

    if (Verbose) {

        dprintf(
            "HEADER - %#08lx\n"
            "  Signature:               %s\n"
            "  Length:                  0x%08lx\n"
            "  Revision:                0x%02x\n"
            "  Checksum:                0x%02x\n",
            Address,
            Buffer,
            Header->Length,
            Header->Revision,
            Header->Checksum
            );

        memset( Buffer, 0, 7 );
        memcpy( Buffer, Header->OEMID, 6 );
        dprintf("  OEMID:                   %s\n", Buffer );
        memcpy( Buffer, Header->OEMTableID, 8 );
        dprintf("  OEMTableID:              %s\n", Buffer );
        dprintf("  OEMRevision:             0x%08lx\n", Header->OEMRevision );
        memset( Buffer, 0, 8 );
        memcpy( Buffer, Header->CreatorID, 4 );
        dprintf("  CreatorID:               %s\n", Buffer );
        dprintf("  CreatorRev:              0x%08lx\n", Header->CreatorRev );

    } else {

        dprintf(
            "  %s @(%#08lx) Rev: %#03x Len: %#08lx",
            Buffer,
            Address,
            Header->Revision,
            Header->Length
            );
        memset( Buffer, 0, sizeof(ULONG) );
        memcpy( Buffer, Header->OEMTableID, 8 );
        dprintf(" TableID: %s\n", Buffer );

    }

    return;
}

VOID
dumpMAPIC(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This dumps the multiple apic table

Arguments:

    Address of the table

Return Value:

    None

--*/
{
    BOOL                hasMPSFlags;
    BOOL                status;
    BOOL                virtualMemory;
    DESCRIPTION_HEADER  mapicHeader;
    PIOAPIC             ioApic;
    PISA_VECTOR         interruptSourceOverride;
    PMAPIC              mapic;
    PIO_NMISOURCE       nmiSource;
    PLOCAL_NMISOURCE    localNmiSource;
    PPROCLOCALAPIC      localApic;
    PUCHAR              buffer;
    PUCHAR              limit;
    ULONG               index;
    ULONG               returnLength;
    ULONG               flags;

    //
    // First check to see if we find the correct things
    //
    dprintf("MAPIC - ");

    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &mapicHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status || mapicHeader.Signature != APIC_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpMAPIC: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpMAPIC: Invalid Signature 0x%08lx != ACPI_SIGNATURE\n",
                mapicHeader.Signature
                );
            dumpHeader( Address, &mapicHeader, TRUE );

        }
        return;
    } // switch

    //
    // Do we have a correctly sized data structure
    //
    mapic = LocalAlloc( LPTR, mapicHeader.Length );
    if (mapic == NULL) {

        dprintf(
            "%#08lx: Could not allocate %#08lx bytes\n",
            Address,
            mapicHeader.Length
            );
        dumpHeader( Address, &mapicHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        mapic,
        mapicHeader.Length,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpMAPIC: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            mapicHeader.Length
            );
        dumpHeader( Address, &mapicHeader, TRUE );
        LocalFree( mapic );
        return;

    }

    //
    // At this point, we are confident that everything worked
    //
    dumpHeader( Address, &(mapic->Header), TRUE );
    dprintf("MAPIC - BODY - %#08lx\n", Address + sizeof(DESCRIPTION_HEADER) );
    dprintf("  Local APIC Address:      %#08lx\n", mapic->LocalAPICAddress );
    dprintf("  Flags:                   %#08lx\n", mapic->Flags );
    if (mapic->Flags & PCAT_COMPAT) {

        dprintf("    PC-AT dual 8259 compatible setup\n");

    }

    buffer = (PUCHAR) &(mapic->APICTables[0]);
    limit = (PUCHAR) ( (ULONG_PTR)mapic + mapic->Header.Length );
    while (buffer < limit) {

        //
        // Assume that no flags are set
        //
        hasMPSFlags = FALSE;

        //
        // Lets see what kind of table we have?
        //
        localApic = (PPROCLOCALAPIC) buffer;
        ioApic = (PIOAPIC) buffer;
        interruptSourceOverride = (PISA_VECTOR) buffer;
        nmiSource = (PIO_NMISOURCE) buffer;
        localNmiSource = (PLOCAL_NMISOURCE) buffer;

        //
        // Is it a localApic?
        //
        if (localApic->Type == PROCESSOR_LOCAL_APIC) {

            buffer += localApic->Length;
            dprintf(
                "  Processor Local Apic\n"
                "    ACPI Processor ID:     0x%02x\n"
                "    APIC ID:               0x%02x\n"
                "    Flags:                 0x%08lx\n",
                localApic->ACPIProcessorID,
                localApic->APICID,
                localApic->Flags
                );
            if (localApic->Flags & PLAF_ENABLED) {

                dprintf("      Processor is Enabled\n");

            }
            if (localApic->Length != PROCESSOR_LOCAL_APIC_LENGTH) {

                dprintf(
                    "  Local Apic has length 0x%x instead of 0x%x\n",
                    localApic->Length,
                    PROCESSOR_LOCAL_APIC_LENGTH
                    );
                break;

            }

        } else if (ioApic->Type == IO_APIC) {

            buffer += ioApic->Length;
            dprintf(
                "  IO Apic\n"
                "    IO APIC ID:            0x%02x\n"
                "    IO APIC ADDRESS:       0x%08lx\n"
                "    System Vector Base:    0x%08lx\n",
                ioApic->IOAPICID,
                ioApic->IOAPICAddress,
                ioApic->SystemVectorBase
                );
            if (ioApic->Length != IO_APIC_LENGTH) {

                dprintf(
                    "  IO Apic has length 0x%x instead of 0x%x\n",
                    ioApic->Length,
                    IO_APIC_LENGTH
                    );
                break;

            }

        } else if (interruptSourceOverride->Type == ISA_VECTOR_OVERRIDE) {

            buffer += interruptSourceOverride->Length;
            dprintf(
                "  Interrupt Source Override\n"
                "    Bus:                   0x%02x\n"
                "    Source:                0x%02x\n"
                "    Global Interrupt:      0x%08lx\n"
                "    Flags:                 0x%04x\n",
                interruptSourceOverride->Bus,
                interruptSourceOverride->Source,
                interruptSourceOverride->GlobalSystemInterruptVector,
                interruptSourceOverride->Flags
                );

            if (interruptSourceOverride->Length != ISA_VECTOR_OVERRIDE_LENGTH) {

                dprintf(
                    "  Interrupt Source Override has length 0x%x instead of 0x%x\n",
                    interruptSourceOverride->Length,
                    ISA_VECTOR_OVERRIDE_LENGTH
                    );
                break;

            }

            hasMPSFlags = TRUE;
            flags = interruptSourceOverride->Flags;

        } else if (nmiSource->Type == IO_NMI_SOURCE) {

            buffer += nmiSource->Length;
            dprintf(
                "  Non Maskable Interrupt Source - on I/O APIC\n"
                "    Flags:                 0x%02x\n"
                "    Global Interrupt:      0x%08lx\n",
                nmiSource->Flags,
                nmiSource->GlobalSystemInterruptVector
                );
            if (nmiSource->Length != IO_NMI_SOURCE_LENGTH) {

                dprintf(
                    "  Non Maskable Interrupt source has length 0x%x instead of 0x%x\n",
                    nmiSource->Length,
                    IO_NMI_SOURCE_LENGTH
                    );
                break;

            }

            hasMPSFlags = TRUE;
            flags = nmiSource->Flags;


        } else if (localNmiSource->Type == LOCAL_NMI_SOURCE) {

            buffer += localNmiSource->Length;
            dprintf(
                "  Non Maskable Interrupt Source - local to processor\n"
                "    Flags:                 0x%04x\n"
                "    Processor:             0x%02x %s\n"
                "    LINTIN:                0x%02x\n",
                localNmiSource->Flags,
                localNmiSource->ProcessorID,
                localNmiSource->ProcessorID == 0xff ? "(all)" : "",
                localNmiSource->LINTIN
                );
            if (localNmiSource->Length != LOCAL_NMI_SOURCE_LENGTH) {

                dprintf(
                    "  Non Maskable Interrupt source has length 0x%x instead of 0x%x\n",
                    localNmiSource->Length,
                    IO_NMI_SOURCE_LENGTH
                    );
                break;

            }

            hasMPSFlags = TRUE;
            flags = localNmiSource->Flags;


        } else {

            dprintf("  UNKOWN RECORD\n");
            dprintf("    Length:                0x%8lx\n", ioApic->Length );
            buffer += ioApic->Length;

        }

        //
        // Do we have any flags to dump out?
        //
        if (hasMPSFlags) {

            switch (flags & PO_BITS) {
            case POLARITY_HIGH:
                dprintf("      POLARITY_HIGH\n");
                break;
            case POLARITY_LOW:
                dprintf("      POLARITY_LOW\n");
                break;
            case POLARITY_CONFORMS_WITH_BUS:
                dprintf("      POLARITY_CONFORMS_WITH_BUS\n");
                break;
            default:
                dprintf("      POLARITY_UNKNOWN\n");
                break;

            }

            switch (flags & EL_BITS) {
            case EL_EDGE_TRIGGERED:
                dprintf("      EL_EDGE_TRIGGERED\n");
                break;
            case EL_LEVEL_TRIGGERED:
                dprintf("      EL_LEVEL_TRIGGERED\n");
                break;
            case EL_CONFORMS_WITH_BUS:
                dprintf("      EL_CONFORMS_WITH_BUS\n");
                break;
            default:
                dprintf("      EL_UNKNOWN\n");
                break;

            }

        }

    }

    LocalFree( mapic );
    return;

}

VOID
dumpRSDT(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This search the dumps the RSDT table

Arguments:

    Pointer to the table

Return Value:

    NONE

--*/
{
    BOOL                status;
    BOOL                virtualMemory = FALSE;
    DESCRIPTION_HEADER  rsdtHeader;
    PRSDT               rsdt;
    ULONG               index;
    ULONG               numEntries;
    ULONG               returnLength;

    dprintf("RSDT - ");

    //
    // Determine if we have virtual or physical memory
    //
    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &rsdtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status || rsdtHeader.Signature != RSDT_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpRSDT: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpRSDT: Invalid Signature 0x%08lx != RSDT_SIGNATURE\n",
                rsdtHeader.Signature
                );
            dumpHeader( Address, &rsdtHeader, TRUE );

        }
        return;
    } // switch

    //
    // Do we have a correctly sized data structure
    //
    rsdt = LocalAlloc( LPTR, rsdtHeader.Length );
    if (rsdt == NULL) {

        dprintf(
            "dumpRSDT: Could not allocate %#08lx bytes\n",
            Address,
            rsdtHeader.Length
            );
        dumpHeader( Address, &rsdtHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        rsdt,
        rsdtHeader.Length,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpRSDT: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            rsdtHeader.Length
            );
        dumpHeader( Address, &rsdtHeader, TRUE );
        LocalFree( rsdt );
        return;

    } else if (rsdt->Header.Signature != RSDT_SIGNATURE) {

        dprintf(
            "dumpRSDT: Signature (%#08lx) != RSDT_SIGNATURE (%#08lx)\n",
            Address,
            rsdt->Header.Signature,
            RSDT_SIGNATURE
            );
        dumpHeader( Address, &rsdtHeader, TRUE );
        LocalFree( rsdt );
        return;

    }

    //
    // At this point, we are confident that everything worked
    //
    dumpHeader( Address, &(rsdt->Header), TRUE );
    dprintf("RSDT - BODY - %#08lx\n", Address + sizeof(DESCRIPTION_HEADER) );
    numEntries = ( rsdt->Header.Length - sizeof(DESCRIPTION_HEADER) ) /
        sizeof(rsdt->Tables[0]);
    for (index = 0; index < numEntries; index++) {

        //
        // Note: unless things radically change, the pointers in the
        // rsdt will always point to bios memory!
        //
        status = ReadPhysicalOrVirtual(
            rsdt->Tables[index],
            &rsdtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            FALSE
            );
        if (!status || returnLength != sizeof(DESCRIPTION_HEADER)) {

            dprintf(
                "dumpRSDT: [%d:0x%08lx] - Read %#08lx of %#08lx bytes\n",
                index,
                rsdt->Tables[index],
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );
            continue;

        }

        dumpHeader( rsdt->Tables[index], &rsdtHeader, FALSE );

    }

    LocalFree( rsdt );
    return;
}

BOOLEAN
findRSDT(
    IN  PULONG_PTR Address
    )
/*++

Routine Description:

    This searchs the memory on the target system for the RSDT pointer

Arguments:

    Address - Where to store the result

Return Value:

    TRUE    - If we found the RSDT

--*/
{
    PHYSICAL_ADDRESS    address = { 0L, 0L };
    RSDP                rsdp;
    RSDT                rsdt;
    UCHAR               index;
    UCHAR               sum;
    ULONG               limit;
    ULONG               returnLength;
    ULONG               start;

    //
    // Calculate the start and end of the search range
    //
    start = (ULONG) RSDP_SEARCH_RANGE_BEGIN;
    limit = (ULONG) start + RSDP_SEARCH_RANGE_LENGTH - RSDP_SEARCH_INTERVAL;

    dprintf( "Searching for RSDP.");

    //
    // Loop for a while
    //
    for (; start <= limit; start += RSDP_SEARCH_INTERVAL) {

        if (start % (RSDP_SEARCH_INTERVAL * 100 ) == 0) {

            dprintf(".");

        }
        //
        // Read the data from the target
        //
        address.LowPart = start;
        ReadPhysical( address.QuadPart, &rsdp, sizeof(RSDP), &returnLength);
        if (returnLength != sizeof(RSDP)) {

            dprintf(
                "%#08lx: Read %#08lx of %#08lx bytes\n",
                start,
                returnLength,
                sizeof(RSDP)
                );
            return FALSE;

        }

        //
        // Is this a match?
        //
        if (rsdp.Signature != RSDP_SIGNATURE) {

            continue;

        }

        //
        // Check the checksum out
        //
        for (index = 0, sum = 0; index < sizeof(RSDP); index++) {

            sum = (UCHAR) (sum + *( (UCHAR *) ( (ULONG_PTR) &rsdp + index ) ) );

        }
        if (sum != 0) {

            continue;

        }

        //
        // Found RSDP
        //
        dprintf("\nRSDP - %#08lx\n", start );
        memset( Buffer, 0, 2048 );
        memcpy( Buffer, &(rsdp.Signature), sizeof(ULONGLONG) );
        dprintf("  Signature:   %s\n", Buffer );
        dprintf("  Checksum:    %#03x\n", rsdp.Checksum );
        memset( Buffer, 0, sizeof(ULONGLONG) );
        memcpy( Buffer, rsdp.OEMID, 6 );
        dprintf("  OEMID:       %s\n", Buffer );
        dprintf("  Reserved:    %#03x\n", rsdp.Reserved );
        dprintf("  RsdtAddress: %#08lx\n", rsdp.RsdtAddress );

        //
        // Done
        //
        *Address = rsdp.RsdtAddress;
        return TRUE;

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\table.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    table.h

Abstract:

    ACPI table functions

Author:

    splante

Environment:

    User mode only

Revision History:

--*/

#ifndef _TABLE_H_
#define _TABLE_H_

    VOID
    dumpDSDT(
        IN  ULONG_PTR           Address,
        IN  PUCHAR              Name
        );

    VOID
    dumpFACS(
        IN  ULONG_PTR           Address
        );

    VOID
    dumpFADT(
        IN  ULONG_PTR           Address
        );

    VOID
    dumpGBL(
        IN  ULONG               Verbose
        );

    VOID
    dumpGBLEntry(
        IN  ULONG_PTR           Address,
        IN  ULONG               Verbose
        );

    VOID
    dumpHeader(
        IN  ULONG_PTR           Address,
        IN  PDESCRIPTION_HEADER Header,
        IN  BOOLEAN             Verbose
        );

    VOID
    dumpMAPIC(
        IN  ULONG_PTR           Address
        );

    VOID
    dumpRSDT(
        IN  ULONG_PTR           Address
        );

    BOOLEAN
    findRSDT(
        IN  PULONG_PTR          Address
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\udebug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

ULONG   globalDebugIndentLevel = 0;
ULONG   globalVerbosityLevel = 0;
UCHAR   DebugMessageBuffer[2048];

VOID
IndentProcedure(
    VOID
    )
{
    ULONG   i;

    for (i = 0; i < globalDebugIndentLevel; i++) {

        if (GlobalPrintFnc != NULL) {

            GlobalPrintFnc("| ");

        } else {

            fprintf( stderr, "| ");

        }

    }
}

VOID
DebugEnterProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    entered

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    va_list marker;

    if (VerbosityLevel <= globalVerbosityLevel) {

        IndentProcedure();
        va_start( marker, Format );
        if (GlobalPrintFnc != NULL) {

            vsprintf( DebugMessageBuffer, Format, marker );
            GlobalPrintFnc( DebugMessageBuffer );

        } else {

            vfprintf( stderr, Format, marker );
            fflush( stderr );

        }
        va_end ( marker );

    }
    globalDebugIndentLevel++;
}

VOID
DebugExitProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    exited

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    va_list marker;

    globalDebugIndentLevel--;
    if (VerbosityLevel <= globalVerbosityLevel) {

        IndentProcedure();
        va_start( marker, Format );
        if (GlobalPrintFnc != NULL) {

            vsprintf( DebugMessageBuffer, Format, marker );
            GlobalPrintFnc( DebugMessageBuffer );

        } else {

            vfprintf( stderr, Format, marker );
            fflush( stderr );

        }
        va_end ( marker );

    }

}

VOID
DebugPrintProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    exited

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    va_list marker;

    if (VerbosityLevel <= globalVerbosityLevel) {

        IndentProcedure();
        va_start( marker, Format );
        if (GlobalPrintFnc != NULL) {

            vsprintf( DebugMessageBuffer, Format, marker );
            GlobalPrintFnc( DebugMessageBuffer );

        } else {

            vfprintf( stderr, Format, marker );
            fflush( stderr );

        }
        va_end ( marker );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\ulist.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.h

Abstract:

    List Entry Manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _LIST_H_
#define _LIST_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\unamespac.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.h

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _NAMESPAC_H_
#define _NAMESPAC_H_

    extern PNSOBJ   RootNameSpaceObject;
    extern PNSOBJ   CurrentScopeNameSpaceObject;
    extern PNSOBJ   CurrentOwnerNameSpaceObject;

    NTSTATUS
    CreateNameSpaceObject(
        PUCHAR  ObjectName,
        PNSOBJ  ObjectScope,
        PNSOBJ  ObjectOwner,
        PNSOBJ  *Object,
        ULONG   Flags
        );


    NTSTATUS
    CreateObject(
        PUCHAR  ObjectName,
        UCHAR   ObjectType,
        PNSOBJ  *Object
        );

    NTSTATUS
    GetNameSpaceObject(
        PUCHAR  ObjectPath,
        PNSOBJ  ScopeObject,
        PNSOBJ  *NameObject,
        ULONG   Flags
        );

    PUCHAR
    GetObjectTypeName(
        ULONG   ObjectType
        );

    PUCHAR
    LocalGetObjectPath(
        PNSOBJ  NameObject
        );

    PUCHAR
    RemoteGetObjectPath(
        ULONG_PTR   ObjectAddress
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\ulist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.c

Abstract:

    List Entry manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

VOID
EXPORT
ListRemoveEntry(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove an Entry from the list

Arguments:

    List        - Entry to be removed
    ListHead    - List to be removed from

Return Value:

    None

--*/
{
    ASSERT(ListHead);

    ASSERT(List != NULL);
    if (List->plistNext == List) {

        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(List == *ListHead);
        *ListHead = NULL;

    } else {

        if (List == *ListHead) {

            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *ListHead = (*ListHead)->plistNext;

        }
        List->plistNext->plistPrev = List->plistPrev;
        List->plistPrev->plistNext = List->plistNext;

    }

}

PLIST
EXPORT
ListRemoveHead(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the head entry of the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    list = *ListHead;
    if ( list != NULL) {

        ListRemoveEntry(list, ListHead);

    }
    return list;

}

PLIST
EXPORT
ListRemoveTail(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the tail entry from the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    if (*ListHead == NULL) {

        list = NULL;

    } else {

        //
        // List is not empty, so find the tail.
        //
        list = (*ListHead)->plistPrev;
        ListRemoveEntry(list, ListHead);

    }
    return list;

}

VOID
EXPORT
ListInsertHead(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the head of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    ListInsertTail(List, ListHead);
    *ListHead = List;
}

VOID
EXPORT
ListInsertTail(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the tail of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    if (*ListHead == NULL) {

        //
        // List is empty, so this becomes the head.
        //
        *ListHead = List;
        List->plistPrev = List->plistNext = List;

    } else {

        List->plistNext = *ListHead;
        List->plistPrev = (*ListHead)->plistPrev;
        (*ListHead)->plistPrev->plistNext = List;
        (*ListHead)->plistPrev = List;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\unamespac.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.c

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

PNSOBJ  RootNameSpaceObject;
PNSOBJ  CurrentScopeNameSpaceObject;
PNSOBJ  CurrentOwnerNameSpaceObject;

NTSTATUS
CreateNameSpaceObject(
    PUCHAR  ObjectName,
    PNSOBJ  ObjectScope,
    PNSOBJ  ObjectOwner,
    PNSOBJ  *Object,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine creates a name space object under the current scope

Arguments:

    ObjectName  - Name Path String
    ObjectScope - Scope to start the search from (NULL == Root)
    ObjectOwner - The object which owns this one
    Object      - Where to store the point to the object that we just created
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        3,
        "CreateNameSpaceObject(%s,Scope=%s,Owner=%p,Object=%p,"
        "Flag=%08lx)\n",
        ObjectName,
        (ObjectScope ? LocalGetObjectPath( ObjectScope ) : "ROOT"),
        ObjectOwner,
        Object,
        Flags
        ) );

    if (ObjectScope == NULL) {

        ObjectScope = RootNameSpaceObject;

    }

    status = GetNameSpaceObject(
        ObjectName,
        ObjectScope,
        &localObject,
        NSF_LOCAL_SCOPE
        );
    if (NT_SUCCESS(status)) {

        if (!(Flags & NSF_EXIST_OK)) {

            status = STATUS_OBJECT_NAME_COLLISION;

        }

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        status = STATUS_SUCCESS;

        //
        // Are we creating root?
        //
        if (strcmp(ObjectName,"\\") == 0) {

            ASSERT( RootNameSpaceObject == NULL );
            ASSERT( ObjectOwner == NULL );

            localObject = MEMALLOC( sizeof(NSOBJ) );
            if (localObject == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

                memset( localObject, 0, sizeof(NSOBJ) );
                localObject->dwSig = SIG_NSOBJ;
                localObject->dwNameSeg = NAMESEG_ROOT;
                RootNameSpaceObject = localObject;

            }

        } else {

            PUCHAR  nameEnd;
            PNSOBJ  objectParent;

            nameEnd = strrchr(ObjectName, '.');
            if (nameEnd != NULL) {

                *nameEnd = '\0';
                nameEnd++;

                status = GetNameSpaceObject(
                    ObjectName,
                    ObjectScope,
                    &objectParent,
                    NSF_LOCAL_SCOPE
                    );

            } else if (*ObjectName == '\\') {

                nameEnd = &ObjectName[1];
                ASSERT( RootNameSpaceObject != NULL );
                objectParent = RootNameSpaceObject;

            } else if (*ObjectName == '^') {

                nameEnd = ObjectName;
                objectParent = ObjectScope;
                while ( (*nameEnd == '^') && (objectParent != NULL)) {

                    objectParent = objectParent->pnsParent;
                    nameEnd++;

                }

            } else {

                ASSERT( ObjectScope );
                nameEnd = ObjectName;
                objectParent = ObjectScope;

            }


            if (status == STATUS_SUCCESS) {

                ULONG   length = strlen(nameEnd);

                localObject = MEMALLOC( sizeof(NSOBJ) );

                if (localObject == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else if ( (*nameEnd != '\0') && (length > sizeof(NAMESEG))) {

                    status = STATUS_OBJECT_NAME_INVALID;
                    MEMFREE( localObject );

                } else {

                    memset( localObject, 0, sizeof(NSOBJ) );
                    localObject->dwSig = SIG_NSOBJ;
                    localObject->dwNameSeg = NAMESEG_BLANK;
                    memcpy( &(localObject->dwNameSeg), nameEnd, length );
                    localObject->hOwner = ObjectOwner;
                    localObject->pnsParent = objectParent;

                    ListInsertTail(
                        &(localObject->list),
                        (PPLIST) &(objectParent->pnsFirstChild)
                        );

                }

            }

        }

    }


    if (NT_SUCCESS(status) && Object != NULL) {

        *Object = localObject;

    }

    EXIT( (
        3,
        "CreateNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );

    return status;
}

NTSTATUS
CreateObject(
    PUCHAR  ObjectName,
    UCHAR   ObjectType,
    PNSOBJ  *Object
    )
/*++

Routine Description:

    Creates a NameSpace Object for the term

Arguments:

    ObjectName  - The name object object
    ObjectType  - The type of object to create
    Object      - Where to store a pointer to the created object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        2,
        "CreateObject(%s,Type=%02x,Object=%p)\n",
        ObjectName,
        ObjectType,
        Object
        ) );

    status = CreateNameSpaceObject(
        ObjectName,
        CurrentScopeNameSpaceObject,
        CurrentOwnerNameSpaceObject,
        &localObject,
        NSF_EXIST_OK
        );
    if (NT_SUCCESS(status)) {

        switch (ObjectType) {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                localObject->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                localObject->ObjData.dwDataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                localObject->ObjData.dwDataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                localObject->ObjData.dwDataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                localObject->ObjData.dwDataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                localObject->ObjData.dwDataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                localObject->ObjData.dwDataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                localObject->ObjData.dwDataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                localObject->ObjData.dwDataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                localObject->ObjData.dwDataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                localObject->ObjData.dwDataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        if (Object != NULL) {

            *Object = localObject;

        }


    }


    EXIT( (
        2,
        "CreateObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );
    return status;
}       //CreateObject

NTSTATUS
GetNameSpaceObject(
    PUCHAR  ObjectPath,
    PNSOBJ  ScopeObject,
    PNSOBJ  *NameObject,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine searches the namespace until it finds a matching object

Arguments:

    ObjectPath  - String with the Name to search for
    ScopeObject - Scope to start search at (NULL == ROOT)
    NameObject  - Where to store the object, if found
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      subPath;

    ENTER( (
        3,
        "GetNameSpaceObject(%s,Scope=%s,Object=%p,Flags=%08lx\n",
        ObjectPath,
        (ScopeObject ? LocalGetObjectPath( ScopeObject ) : "ROOT"),
        NameObject,
        Flags
        ) );
    if (ScopeObject == NULL) {

        ScopeObject = RootNameSpaceObject;

    }


    if (*ObjectPath == '\\') {

        subPath = &ObjectPath[1];
        ScopeObject = RootNameSpaceObject;

    } else {

        subPath = ObjectPath;
        while ( (*subPath == '^') && (ScopeObject != NULL)) {

            subPath++;
            ScopeObject = ScopeObject->pnsParent;

        }

    }

    *NameObject = ScopeObject;
    if (ScopeObject == NULL) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else if (*subPath != '\0') {

        BOOL    searchUp;
        PNSOBJ  tempObject;

        searchUp = (BOOL) ( !(Flags & NSF_LOCAL_SCOPE) &&
            (ObjectPath[0] != '\\') &&
            (ObjectPath[0] != '^') &&
            (strlen(ObjectPath) <= sizeof(NAMESEG)) );
        while (1) {

            do {

                tempObject = ScopeObject->pnsFirstChild;
                if (tempObject == NULL) {

                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    INFO( (5, "GetNameSpaceObject - %s has no children\n",
                           LocalGetObjectPath( tempObject ) ) );

                } else {

                    BOOL    found;
                    PUCHAR  bufferEnd;
                    ULONG   length;
                    NAMESEG dwNameSeg;

                    bufferEnd = strchr( subPath, '.' );
                    if (bufferEnd != NULL) {

                        length = (ULONG)(bufferEnd - subPath);

                    } else {

                        length = strlen(subPath);

                    }


                    if (length > sizeof(NAMESEG)) {

                        status = STATUS_OBJECT_NAME_INVALID;
                        found = FALSE;

                    } else {

                        dwNameSeg = NAMESEG_BLANK;
                        memcpy( &dwNameSeg, subPath, length );

                        INFO( (5, "GetNameSpaceObject - Looking for %*s\n",
                               length, subPath) );

                        //
                        // search all sibling fors a matching nameSeg
                        //
                        found = FALSE;
                        do {

                            INFO( (5, "GetNameSpaceObject - look at %s\n",
                                   LocalGetObjectPath( tempObject ) ) );
                            if (tempObject->dwNameSeg == dwNameSeg) {

                                ScopeObject = tempObject;
                                found = TRUE;
                                break;

                            }

                            tempObject = (PNSOBJ) tempObject->list.plistNext;

                        } while (tempObject != tempObject->pnsParent->pnsFirstChild );

                    }


                    if (status == STATUS_SUCCESS) {

                        if (!found) {

                            status = STATUS_OBJECT_NAME_NOT_FOUND;

                        } else {

                            subPath += length;
                            if (*subPath == '.') {

                                subPath++;

                            } else if (*subPath == '\0') {

                                *NameObject = ScopeObject;
                                break;

                            }

                        }

                    }

                }

            } while ( status == STATUS_SUCCESS );

            if (status == STATUS_OBJECT_NAME_NOT_FOUND && searchUp &&
                ScopeObject != NULL && ScopeObject->pnsParent != NULL) {

                INFO( (5, "GetNameSpaceObject - Changing Scope to %s\n",
                       LocalGetObjectPath( ScopeObject->pnsParent ) ) );
                ScopeObject = ScopeObject->pnsParent;
                status = STATUS_SUCCESS;

            } else {

                break;

            }

        }

    }


    if (status != STATUS_SUCCESS) {

        *NameObject = NULL;

    }


    EXIT( (
        3,
        "GetNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        *NameObject
        ) );
    return status;

}

PUCHAR
GetObjectTypeName(
    ULONG   ObjectType
    )
/*++

Routine Description:

    Returns a string which corresponds to the type object the object

Arugment:

    ObjectType  - The type that we wish to know about

Return Value:

    Globally Available String

--*/
{
    PUCHAR  type = NULL;
    ULONG   i;
    static struct {
        ULONG   ObjectType;
        PUCHAR  ObjectTypeName;
    } ObjectTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            OBJTYPE_PNP_RES,    "PNPResource",
            OBJTYPE_RES_FIELD,  "ResField",
            0,                  NULL
        };

    ENTER( (4, "GetObjectTypeName(Type=%02x)\n", ObjectType ) );

    for (i = 0; ObjectTypeTable[i].ObjectTypeName != NULL; i++) {

        if (ObjectType == ObjectTypeTable[i].ObjectType) {

            type = ObjectTypeTable[i].ObjectTypeName;
            break;

        }

    }

    EXIT( (4, "GetObjectTypeName=%s\n", type ? type : "NULL" ) );
    return type;
}

PUCHAR
LocalGetObjectPath(
    PNSOBJ  NameObject
    )
/*++

Routine Description:

    This routine takes a NameSpace Object and returns a string to represent
    its path

Arguments:

    NameObject  - The object whose path we want

Return Value:

    Pointer to the string which represents the path

--*/
{
    static UCHAR    namePath[MAX_NAME_LEN + 1] = {0};
    ULONG           i;

    ENTER( (6, "LocalGetObjectPath(Object=%p)\n", NameObject ) );

    if (NameObject != NULL) {

        if (NameObject->pnsParent == NULL) {

            strcpy(namePath, "\\");

        } else {

            LocalGetObjectPath(NameObject->pnsParent);
            if (NameObject->pnsParent->pnsParent != NULL) {

                strcat(namePath, ".");

            }
            strncat(namePath, (PUCHAR)&NameObject->dwNameSeg, sizeof(NAMESEG));

        }


        for (i = strlen(namePath) - 1; i >= 0; --i) {

            if (namePath[i] == '_') {

                namePath[i] = '\0';

            } else {

                break;

            }


        }

    } else {

        namePath[0] = '\0';

    }

    EXIT( (6, "LocalGetObjectPath=%s\n", namePath ) );
    return namePath;
}

PUCHAR
RemoteGetObjectPath(
    ULONG_PTR   ObjectAddress
    )
/*++

Routine Description:

    This routine takes a NameSpace Object and returns a string to represent
    its path

Arguments:

    NameObject  - The object whose path we want

Return Value:

    Pointer to the string which represents the path

--*/
{
    static UCHAR    namePath[MAX_NAME_LEN + 1] = {0};
    NSOBJ           nameObject;
    ULONG           i;

    ENTER( (6, "RemoteGetObjectPath(Object=%p)\n", ObjectAddress ) );

    if (ObjectAddress != 0 && ReadMemory( ObjectAddress, &nameObject, sizeof(nameObject), NULL) ) {

        if (nameObject.pnsParent == NULL) {

            strcpy(namePath, "\\");

        } else {

            RemoteGetObjectPath( (ULONG_PTR) nameObject.pnsParent);
            if (strlen(namePath) > 1) {

                strcat(namePath, ".");

            }
            strncat(namePath, (PUCHAR)&nameObject.dwNameSeg, sizeof(NAMESEG));

        }


        for (i = strlen(namePath) - 1; i >= 0; --i) {

            if (namePath[i] == '_') {

                namePath[i] = '\0';

            } else {

                break;

            }


        }

    } else {

        namePath[0] = '\0';

    }

    EXIT( (6, "RemoteGetObjectPath=%s\n", namePath ) );
    return namePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\unasm.c ===
/*** unasm.c - Unassemble AML back to ASL
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

//Local function prototype
VOID LOCAL Indent(PUCHAR pbOp, int iLevel);
UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(ULONG dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData);
LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp);
LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ pns, char c);
LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen);
LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp);
LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ pns);
LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos);

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Current Opcode pointer
 *      pbEnd -> end of scope
 *      uipbOp - Op address
 *      pnsScope - Scope object
 *      iLevel - level of indentation
 *      icLines - 1: unasm one line; 0: unasm all; -1: internal
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, ULONG_PTR uipbOp,
                      PNSOBJ pnsScope, int iLevel, int icLines)
{
    LONG rc = UNASMERR_NONE;
    int icLinesLeft = icLines;

    if (uipbOp != 0)
    {
        guipbOpXlate = uipbOp - (ULONG_PTR)(*ppbOp);
    }

    if (pnsScope != NULL)
    {
        gpnsCurUnAsmScope = pnsScope;
    }

    if (iLevel != -1)
    {
        giLevel = iLevel;
    }

    if (icLines < 0)
    {
        Indent(*ppbOp, giLevel);
        PRINTF("{");
        giLevel++;
    }
    else if (icLines == 0)
    {
        icLinesLeft = -1;
    }

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((rc = UnAsmOpcode(ppbOp)) == UNASMERR_NONE)
        {
            if (icLinesLeft < 0)
            {
                continue;
            }

            if (--icLinesLeft == 0)
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    if ((rc == UNASMERR_NONE) && (icLines < 0))
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmScope

/***LP  Indent - Print indent level
 *
 *  ENTRY
 *      pbOp -> opcode
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL Indent(PUCHAR pbOp, int iLevel)
{
    int i;

    PRINTF("\n%08x: ", pbOp + guipbOpXlate);
    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }
}       //Indent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable)
{
    UCHAR bOpClass = OPCLASS_INVALID;

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
        {
            pOpTable++;
        }
    }

    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(ULONG dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (UTC_CONST_NAME | UTC_SHORT_NAME | UTC_NAMESPACE_MODIFIER |
              UTC_DATA_OBJECT | UTC_NAMED_OBJECT | UTC_OPCODE_TYPE1 |
              UTC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == UTC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (UCHAR)(TermTable[i].dwTermData >> 8)) ==
             (UCHAR)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwOpcode;
    UCHAR bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    int i;

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((ULONG)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (ULONG)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp);
            break;

        case OPCLASS_NAME_OBJ:
        {
            NSOBJ NSObj = {0};

            if (((rc = UnAsmNameObj(ppbOp, &NSObj, NSTYPE_UNKNOWN)) ==
                 UNASMERR_NONE) &&
                (NSObj.ObjData.dwDataType == OBJTYPE_METHOD))
            {
                PMETHODOBJ pm = (PMETHODOBJ)GetObjBuff(&NSObj.ObjData);
                int iNumArgs;

                if (pm != NULL)
                {
                    iNumArgs = pm->bMethodFlags & METHOD_NUMARG_MASK;

                    for (i = 0; i < iNumArgs; ++i)
                    {
                        szUnAsmArgTypes[i] = 'C';
                    }
                    szUnAsmArgTypes[i] = '\0';
                    rc = UnAsmArgs(szUnAsmArgTypes, NULL, ppbOp, NULL);
                    LocalFree(pm);
                }
            }
            break;
        }
        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                DBG_ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = UNASMERR_FATAL;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp);
            }
            break;

        default:
            DBG_ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    UCHAR bOp = **ppbOp;
    PSZ psz;

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            PRINTF("0x%x", **ppbOp);
            *ppbOp += sizeof(UCHAR);
            break;

        case OP_WORD:
            PRINTF("0x%x", *((PUSHORT)*ppbOp));
            *ppbOp += sizeof(USHORT);
            break;

        case OP_DWORD:
            PRINTF("0x%x", *((PULONG)*ppbOp));
            *ppbOp += sizeof(ULONG);
            break;

        case OP_STRING:
            PRINTF("\"");
            for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
            {
                if (*psz == '\\')
                {
                    PRINTF("\\");
                }
                PRINTF("%c", *psz);
            }
            PRINTF("\"");
            *ppbOp += STRLEN((PSZ)*ppbOp) + 1;
            break;

        default:
            DBG_ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = UNASMERR_INVALID_OPCODE;
    }

    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ pns, char c)
{
    LONG rc = UNASMERR_NONE;
    char szName[MAX_NAME_LEN + 1];
    int iLen = 0;

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NAME_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            DBG_ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = UNASMERR_FATAL;
        }
        else
        {
            rc = UnAsmNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }

    if (rc == UNASMERR_NONE)
    {
        ULONG_PTR uipns = 0;
        NSOBJ NSObj;

        PRINTF("%s", szName);

        rc = GetNSObj(szName, gpnsCurUnAsmScope, &uipns, &NSObj, 0);

        if (rc == UNASMERR_NONE)
        {
            if (pns != NULL)
            {
                MEMCPY(pns, &NSObj, sizeof(NSObj));
            }

            if ((c == NSTYPE_SCOPE) && (uipns != 0))
            {
                gpnsCurUnAsmScope = pns;
            }
        }
        else
        {
            rc = UNASMERR_NONE;
        }
    }

    return rc;
}       //UnAsmNameObj

/***LP  UnAsmNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen)
{
    LONG rc = UNASMERR_NONE;
    int icNameSegs = 0;

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NAME_LEN))
    {
        STRCPYN(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NAME_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        DBG_ERROR(("UnAsmNameTail: name too long - %s", pszBuff));
        rc = UNASMERR_FATAL;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    return rc;
}       //UnAsmNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    PUCHAR pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurUnAsmScope;
    NSOBJ NSObj = {0};

    PRINTF("%s", pterm->pszID);

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions, ppbOp,
                       &NSObj);
    }

    if (rc == UNASMERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
            if ((pterm->dwfTerm & TF_CHANGE_CHILDSCOPE) &&
                (NSObj.ObjData.dwDataType != 0))
            {
                gpnsCurUnAsmScope = &NSObj;
            }

            rc = UnAsmScope(ppbOp, pbEnd, 0, NULL, -1, -1);
        }
    }
    gpnsCurUnAsmScope = pnsScopeSave;

    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      ppbOp -> opcode pointer
 *      pns -> to hold created object
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ pns)
{
    LONG rc = UNASMERR_NONE;
    static UCHAR bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm;

    iNumArgs = STRLEN(pszUnAsmArgTypes);
    PRINTF("(");

    for (i = 0; i < iNumArgs; ++i)
    {
        if (i != 0)
        {
            PRINTF(", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, pns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((ULONG)(**ppbOp));
                    ASSERT(pterm != NULL);
                    (*ppbOp)++;
                    rc = UnAsmTermObj(pterm, ppbOp);
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp);
                break;

            case 'B':
                PRINTF("0x%x", **ppbOp);
                *ppbOp += sizeof(UCHAR);
                break;

            case 'K':
            case 'k':
                if (pszUnAsmArgTypes[i] == 'K')
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    PRINTF("0x%x", **ppbOp & 0x07);
                }
                else
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    ASSERT(pterm != NULL);
                    PRINTF("%s", pterm->pszID);
                }

                if (pszUnAsmArgTypes[i] == 'K')
                {
                    *ppbOp += sizeof(UCHAR);
                }
                break;

            case 'W':
                PRINTF("0x%x", *((PUSHORT)*ppbOp));
                *ppbOp += sizeof(USHORT);
                break;

            case 'D':
                PRINTF("0x%x", *((PULONG)*ppbOp));
                *ppbOp += sizeof(ULONG);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp);
                break;

            default:
                DBG_ERROR(("UnAsmOpcode: invalid ArgType '%c'",
                           pszUnAsmArgTypes[i]));
                rc = UNASMERR_FATAL;
        }
    }

    PRINTF(")");

    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        PRINTF("Debug");
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp);
    }
    else
    {
        DBG_ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmSuperName

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    int i;

    Indent(*ppbOp, giLevel);
    PRINTF("{");

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, 0);
        PRINTF("0x%02x", **ppbOp);

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 8); ++i)
        {
            PRINTF(", 0x%02x", **ppbOp);
            (*ppbOp)++;
        }

        if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    Indent(*ppbOp, giLevel);
    PRINTF("}");

    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    PASLTERM pterm;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((ULONG)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp);
        }

        if (rc != UNASMERR_NONE)
        {
            break;
        }
        else if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwBitPos = 0;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);
        if ((rc = UnAsmField(ppbOp, &dwBitPos)) == UNASMERR_NONE)
        {
            if (*ppbOp < pbEnd)
            {
                PRINTF(",");
            }
        }
        else
        {
            break;
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0x01)
    {
        PASLTERM pterm = NULL;

        (*ppbOp)++;
        pterm = FindKeywordTerm('A', **ppbOp);
        if (pterm != NULL) {

            PRINTF("AccessAs(%s, 0x%x)", pterm->pszID, *(*ppbOp + 1));

        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        ULONG dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            STRCPYN(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
            {
                PRINTF("Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
            }
            else
            {
                PRINTF(", %d", dwcbBits);
            }
        }
        else
        {
            PRINTF("%s, %d", szNameSeg, dwcbBits);
        }

        *pdwBitPos += dwcbBits;
    }

    return rc;
}       //UnAsmField
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\unasm.h ===
/*** unasm.h - Unassembler Private Definitions
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UNASM_H
#define _UNASM_H

#ifdef DEBUGGER

/*** Constants
 */

// Implementation constants
#define MAX_ARGS                7

// Error codes
#define UNASMERR_NONE           0
#define UNASMERR_FATAL          -1
#define UNASMERR_INVALID_OPCODE -2
#define UNASMERR_ABORT          -3

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Term classes
#define UTC_PNP_MACRO           0x00100000
#define UTC_REF_OBJECT          0x00200000
#define UTC_FIELD_MACRO         0x00400000
#define UTC_DATA_OBJECT         0x00800000
#define UTC_NAMED_OBJECT        0x01000000
#define UTC_NAMESPACE_MODIFIER  0x02000000
#define UTC_OPCODE_TYPE1        0x04000000
#define UTC_OPCODE_TYPE2        0x08000000
#define UTC_CONST_NAME          0x10000000
#define UTC_SHORT_NAME          0x20000000
#define UTC_COMPILER_DIRECTIVE  0x40000000
#define UTC_KEYWORD             0x80000000
#define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 |  \
                                 UTC_SHORT_NAME | UTC_CONST_NAME |      \
                                 UTC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          UTC_FIELD_MACRO
#define TF_DATA_OBJECT          UTC_DATA_OBJECT
#define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
#define TF_CONST_NAME           UTC_CONST_NAME
#define TF_SHORT_NAME           UTC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
#define TF_KEYWORD              UTC_KEYWORD
#define TF_PNP_MACRO            UTC_PNP_MACRO
#define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                 UTC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

/*** Type definitions
 */

typedef ULONG NAMESEG;
typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    ULONG   dwfTermClass;
    ULONG   dwTermData;
    ULONG   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgActions;
    ULONG   dwfTerm;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    UCHAR   bExOp;
    UCHAR   bOpClass;
} OPMAP, *POPMAP;

// Data prototype
extern int giLevel;
extern ULONG_PTR guipbOpXlate;
extern PNSOBJ gpnsCurUnAsmScope;
extern ASLTERM TermTable[];
extern UCHAR OpClassTable[256];
extern OPMAP ExOpClassTable[];

// Exported functions
LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, ULONG_PTR uipbOp,
                      PNSOBJ pnsScope, int iLevel, int icLines);

#endif  //ifdef DEBUGGER

#endif  //ifndef _UNASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\udebug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DEBUG_H_
#define _DEBUG_H_

    #ifdef DBG

        #define ENTER(x)    DebugEnterProcedure x
        #define EXIT(x)     DebugExitProcedure x
        #define INFO(x)     DebugPrintProcedure x

        VOID
        DebugEnterProcedure(
            ULONG   VerbosityLevel,
            PCCHAR  Format,
            ...
            );

        VOID
        DebugExitProcedure(
            ULONG   VerbosityLevel,
            PCCHAR  Format,
            ...
            );

        VOID
        DebugPrintProcedure(
            ULONG   VerbosityLevel,
            PCCHAR  Format,
            ...
            );

    #else

        #define ENTER(x)
        #define EXIT(x)
        #define INFO(x)

    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\uparsearg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.c

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#include "pch.h"

VOID
ParseProgramInfo(
    PUCHAR      ProgramName,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    This routine parses program path and module name

Arguments:

    ProgramName - The Argv[0] from main()
    ProgramInfo - Program Information structure

Return Value:

    None

--*/
{
    PUCHAR   ptr;

    ProgramInfo->ProgPath = _strlwr(ProgramName);
    ptr = strrchr( ProgramName, '\\' );
    if (ptr != NULL) {

        *ptr = '\0';
        ProgramInfo->ProgName = ptr + 1;

    } else {

        ProgramInfo->ProgName = ProgramName;

    }

    ptr = strchr(ProgramInfo->ProgName, '.');
    if (ptr != NULL) {

        *ptr = '\0';

    }
}

ULONG
ParseSwitches(
    PULONG      ArgumentCount,
    PUCHAR      **ArgumentList,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse command line switches

Arguments:

    ArgumentCount   - Pointer to the number of arguments
    ArgumentList    - Pointer to the pointer to the list of arguments
    ArgumentArray   - How to parse the arguments
    ProgramInfo     - Program Specific structure

Return Value:

    ULONG   - Success = ARGERR_NONE

--*/
{
    PUCHAR  argument;
    ULONG   status = ARGERR_NONE;

    if (ProgramInfo->SwitchChars == NULL) {

        ProgramInfo->SwitchChars = DEF_SWITCHCHARS;

    }
    if (ProgramInfo->Separators == NULL) {

        ProgramInfo->Separators = DEF_SEPARATORS;

    }

    for (; *ArgumentCount; (*ArgumentCount)--, (*ArgumentList)++)
    {
        argument = **ArgumentList;

        if (strchr(ProgramInfo->SwitchChars, *argument)) {

            argument++;
            status = ParseArgSwitch(
                &argument,
                ArgumentArray,
                ProgramInfo
                );
            if (status != ARGERR_NONE) {

                PrintError( status, argument, ProgramInfo );
                break;

            }

        } else {

            break;

        }

    }

    return status;
}

ULONG
ParseArgSwitch(
    PUCHAR      *Argument,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse a command line switch

Arguments

    Argument        - Pointer to argument
    ArgumentArray   - How to handle the argument
    ProgramInfo     - Program Information Structure

Return Value:

    ULONG

--*/
{
    BOOL        found = FALSE;
    PARGTYPE    tableEntry;
    PUCHAR      argumentEnd;
    ULONG       length = 0;
    ULONG       status = ARGERR_NONE;

    tableEntry = ArgumentArray;
    while (tableEntry->ArgID[0]) {

        length = strlen(tableEntry->ArgID);
        if (tableEntry->ParseFlags & PF_NOI) {

            found = (strncmp(tableEntry->ArgID, *Argument, length) == 0);

        } else {

            found = (_strnicmp(tableEntry->ArgID, *Argument, length) == 0);

        }

        if (found) {

            break;
        }
        tableEntry++;

    }

    if (found) {

        *Argument += length;
        switch (tableEntry->ArgType) {
            case AT_STRING:
            case AT_NUM:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }
                if (tableEntry->ArgType == AT_STRING) {

                    *(UCHAR **)tableEntry->ArgData = *Argument;

                } else {

                    *(ULONG *)tableEntry->ArgData = (ULONG)
                        strtoul(*Argument, &argumentEnd, tableEntry->ArgParam);
                    if (*Argument == argumentEnd) {

                        status = ARGERR_INVALID_NUM;
                        break;

                    }
                    *Argument = argumentEnd;

                }
                if (tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);

                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (tableEntry->ArgType == AT_ENABLE) {

                    *(ULONG *)tableEntry->ArgData |= tableEntry->ArgParam;

                } else {

                    *(ULONG *)tableEntry->ArgData &= ~tableEntry->ArgParam;

                }

                if ( tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);
                    if (status == ARGERR_NONE) {

                        break;

                    }

                }

                if (**Argument) {

                    if (strchr(ProgramInfo->SwitchChars, **Argument)) {

                        (*Argument)++;

                    }
                    status = ParseArgSwitch(
                        Argument,
                        ArgumentArray,
                        ProgramInfo
                        );

                }
                break;

            case AT_ACTION:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }

#pragma warning(disable: 4055)
                status = (*(PFNARG)tableEntry->ArgData)(Argument, tableEntry);
#pragma warning(default: 4055)

                break;

        }

    } else {

        status = ARGERR_UNKNOWN_SWITCH;

    }
    return status;
}

VOID
PrintError(
    ULONG       ErrorCode,
    PUCHAR      Argument,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Print Appropriate Error Message according to error code

Arguments:

    ErrorCode   - The error which occured
    Argument    - Argument in Error
    ProgramInfo - Program info structure

Return Value:

    VOID

--*/
{
    switch (ErrorCode) {
        case ARGERR_UNKNOWN_SWITCH:
            fprintf(
               stderr,
               "%s: unknown switch \"%s\"\n",
               ProgramInfo->ProgName,
               Argument
               );
            break;

        case ARGERR_NO_SEPARATOR:
            fprintf(
                stderr,
                "%s: separator missing after the switch char '%c'\n",
                ProgramInfo->ProgName,
                *(Argument-1)
                );
            break;

        case ARGERR_INVALID_NUM:
            fprintf(
                stderr,
                "%s: invalid numeric switch \"%s\"\n",
                ProgramInfo->ProgName,
                Argument
                );
            break;

        case ARGERR_INVALID_TAIL:
            fprintf(
                 stderr,
                 "%s: invalid argument tail \"%s\"\n",
                 ProgramInfo->ProgName,
                 Argument
                 );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\ntsdext\acpintsd.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <heap.h>
#include <atom.h>
#include <stktrace.h>
#include <winsock2.h>

#include <ntcsrsrv.h>
#include "unasm.h"

#define move(dst, src)\
try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\kdext\uparsearg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.h

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#ifndef _PARSEARG_H_
#define _PARSEARG_H_

    //
    // Error Codes
    //
    #define ARGERR_NONE             0
    #define ARGERR_UNKNOWN_SWITCH   1
    #define ARGERR_NO_SEPARATOR     2
    #define ARGERR_INVALID_NUM      3
    #define ARGERR_INVALID_TAIL     4

    //
    // Parsing options
    //
    #define DEF_SWITCHCHARS         "/-"
    #define DEF_SEPARATORS          ":="

    //
    // Argument types
    //
    #define AT_STRING       1
    #define AT_NUM          2
    #define AT_ENABLE       3
    #define AT_DISABLE      4
    #define AT_ACTION       5

    //
    // Parse flags
    //
    #define PF_NOI          0x0001  //No-Ignore-Case
    #define PF_SEPARATOR    0x0002  //parse for separator

    //
    // Type definitions
    //
    typedef struct _ARGTYPE ARGTYPE, *PARGTYPE;
    typedef int (*PFNARG)(char **, PARGTYPE);
    struct _ARGTYPE {
        UCHAR       *ArgID;         // argument ID string
        ULONG       ArgType;        // see argument types defined above
        ULONG       ParseFlags;     // see parse flags defined above
        VOID        *ArgData;       // ARG_STRING: (char **) - ptr to string ptr
                                    // ARG_NUM: (int *) - ptr to integer number
                                    // ARG_ENABLE: (unsigned *) - ptr to flags
                                    // ARG_DISABLE: (unsigned *) - ptr to flags
                                    // ARG_ACTION: ptr to function
        ULONG       ArgParam;       // ARG_STRING: none
                                    // ARG_NUM: base
                                    // ARG_ENABLE: flag bit mask
                                    // ARG_DISABLE: flag bit mask
                                    // ARG_ACTION: none
        PFNARG      ArgVerify;      // pointer to argument verification function
                                    // this will be ignored for ARG_ACTION
    };

    typedef struct _PROGINFO {
        UCHAR *SwitchChars;         // if null, DEF_SWITCHCHARS is used
        UCHAR *Separators;          // if null, DEF_SEPARATORS is used
        UCHAR *ProgPath;            // ParseProgInfo set this ptr to prog. path
        UCHAR *ProgName;            // ParseProgInfo set this ptr to prog. name
    } PROGINFO;
    typedef PROGINFO *PPROGINFO;

    ULONG
    ParseArgSwitch(
        PUCHAR      *Argument,
        PARGTYPE    ArgumentArray,
        PPROGINFO   ProgramInfo
        );

    VOID
    ParseProgramInfo(
        PUCHAR      ProgramName,
        PPROGINFO   ProgramInfo
        );

    ULONG
    ParseSwitches(
        PULONG      ArgumentCount,
        PUCHAR      **ArgumentList,
        PARGTYPE    ArgumentArray,
        PPROGINFO   ProgramInfo
        );

    VOID
    PrintError(
        ULONG       ErrorCode,
        PUCHAR      Argument,
        PPROGINFO   ProgramInfo
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\ntsdext\acpintsd.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    acpintsd.c

Abstract:

    ACPI-Specific NTSD Extensions

Environment:

    Win32

Revision History:

--*/

#include "acpintsd.h"

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

PUCHAR  ScTableName[] = {
    "ParseFunctionHandler",
    "ParseArgument",
    "ParseArgumentObject",
    "ParseBuffer",
    "ParseByte",
    "ParseCodeObject",
    "ParseConstObject",
    "ParseData",
    "ParseDelimiter",
    "ParseDword",
    "ParseField",
    "ParseLocalObject",
    "ParseName",
    "ParseNameObject",
    "ParseOpcode",
    "ParsePackage",
    "ParsePop",
    "ParsePush",
    "ParseSuperName",
    "ParseTrailingArgument",
    "ParseTrailingBuffer",
    "ParseTrailingPackage",
    "ParseVariableObject",
    "ParseWord"
};

VOID
dumpParseStack(
    DWORD   AddrStack
    )
/*++

Routine Description:

    This dumps the parse stack

Arguments:

    AddrStack: Address of the stack to dump

Return Value:

    None

--*/
{
    BOOL            b;
    STRING_STACK    tempStack;
    PSTRING_STACK   stack;
    ULONG           index;

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        &tempStack,
        sizeof(STRING_STACK),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Allocate memory for the entire stack
    //
    stack = (PSTRING_STACK) LocalAlloc(
        LMEM_ZEROINIT,
        sizeof(STRING_STACK) + tempStack.StackSize - 1
        );
    if (!stack) {

        return;

    }

    //
    // Read the entire stack
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        stack,
        sizeof(STRING_STACK) + tempStack.StackSize - 1,
        NULL
        );
    if (!b) {

        LocalFree( stack );
        return;

    }

    //
    // Show the user something
    //
    dprintf(
        "ParseStack: Size 0x%x Top: 0x%x\n",
        tempStack.StackSize,
        tempStack.TopOfStack
        );
    if (tempStack.TopOfStack == 0) {

        dprintf("Stack is empty\n");
        return;

    }

    //
    // Walk the stack
    //
    for (index = tempStack.TopOfStack - 1; ; index--) {

        dprintf("[%2d] %s\n", index, ScTableName[ stack->Stack[index] ] );
        if (index == 0) {

            break;

        }

    }

    //
    // Free the stack
    //
    LocalFree( stack );

}

VOID
dumpStringStack(
    DWORD   AddrStack
    )
/*++

Routine Description:

    This dumps the parse stack

Arguments:

    AddrStack: Address of the stack to dump

Return Value:

    None

--*/
{
    BOOL            b;
    STRING_STACK    tempStack;
    PSTRING_STACK   stack;
    ULONG           index;

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        &tempStack,
        sizeof(STRING_STACK),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Allocate memory for the entire stack
    //
    stack = (PSTRING_STACK) LocalAlloc(
        LMEM_ZEROINIT,
        sizeof(STRING_STACK) + tempStack.StackSize
        );
    if (!stack) {

        return;

    }

    //
    // Read the entire stack
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        stack,
        sizeof(STRING_STACK) + tempStack.StackSize - 1,
        NULL
        );
    if (!b) {

        LocalFree( stack );
        return;

    }

    //
    // Show the user something
    //
    dprintf(
        "StringStack: Size 0x%x Top: 0x%x\nString: '%s'\n",
        tempStack.StackSize,
        tempStack.TopOfStack,
        stack->Stack
        );

    //
    // Free the stack
    //
    LocalFree( stack );

}

VOID
dumpScope(
    PSCOPE  Scope
    )
/*++

Routine Description:

    Dumps a scope, as used in the ACPI unasm.lib

Arguments:

    Scope - LocalCopy of the scope

Return Value:

    None

--*/
{
    BOOL    b;
    AMLTERM amlTerm;
    UCHAR   buffer[64];

    dprintf("%8x %8x %8x %8x %2x %2x %2x %1d %8x",
        Scope->CurrentByte,
        Scope->TermByte,
        Scope->LastByte,
        Scope->StringStack,
        Scope->Context1,
        Scope->Context2,
        Scope->Flags,
        Scope->IndentLevel,
        Scope->AmlTerm
        );

    b = ReadMemory(
        Scope->AmlTerm,
        &amlTerm,
        sizeof(AMLTERM),
        NULL
        );
    if (!b) {

        dprintf("\n");
        return;

    } else {

        dprintf(" %4x %4x\n",
            amlTerm.OpCode,
            amlTerm.OpCodeFlags
            );

        b = ReadMemory(
            amlTerm.TermName,
            buffer,
            64,
            NULL
            );
        if (b) {

            dprintf("  %-60s\n", buffer );

        }

    }

}

VOID
dumpScopeHeader(
    BOOL    Verbose
    )
/*++

Routine Description:

    Dumps the header for a scope stack dump

Arguments:

    Verbose: wether or not to include the field for stack level

Return Value:

    None

--*/
{
    if (Verbose) {

        dprintf("Level ");

    }

    dprintf(" Current    First     Last  S.Stack C1 C2 Fl I AML Term OpCd Flag\n" );

}

DECLARE_API( sscope )
/*++

Routine Description:

    Dumps one of the stacks used by the ACPI Unassembler

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None

--*/
{
    BOOL    b;
    DWORD   addrStack;
    DWORD   i;
    DWORD   offset;
    DWORD   top;
    STACK   tempStack;
    PSTACK  stack;
    PSCOPE  scope;

    INIT_API();

    //
    // Evaluate the argument string to get the address of the
    // stack to dump
    //
    addrStack = GetExpression( lpArgumentString );
    if ( !addrStack) {

        return;

    }

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) addrStack,
        &tempStack,
        sizeof(STACK),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Allocate memory for the entire stack
    //
    stack = (PSTACK) LocalAlloc(
        LMEM_ZEROINIT,
        sizeof(STACK) + tempStack.StackSize - 1
        );
    if (!stack) {

        return;

    }

    //
    // Read the entire stack
    //
    b = ReadMemory(
        (LPVOID) addrStack,
        stack,
        sizeof(STACK) + tempStack.StackSize - 1,
        NULL
        );
    if (!b) {

        LocalFree( stack );
        return;

    }

    //
    // Show the user something
    //
    dumpScopeHeader( TRUE );

    //
    // Loop on each of the scopes
    //
    for (top = (stack->TopOfStack / stack->StackElementSize) - 1;;top--) {

        scope = (PSCOPE) &(stack->Stack[ top * stack->StackElementSize ] );
        dprintf("[%2d]: ", top );
        dumpScope(scope);

        if (top == 0) {

            dumpParseStack( (DWORD) scope->ParseStack );
            dumpStringStack( (DWORD) scope->StringStack );
            break;

        }

    }

    //
    // Done
    //
    LocalFree( stack );
}

DECLARE_API( amlterm )
{
    BOOL    b;
    DWORD   addrTerm;
    DWORD   offset;
    AMLTERM amlTerm;
    UCHAR   nameBuff[17];
    UCHAR   symbolBuff[128];

    INIT_API();

    //
    // Evaluate the argument string to get the address of the
    // term to dump
    //
    addrTerm = GetExpression( lpArgumentString );
    if ( !addrTerm ) {

        return;

    }

    //
    // Read the term into memory
    //
    b = ReadMemory(
        (LPVOID) addrTerm,
        &amlTerm,
        sizeof(AMLTERM),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Begin to print things
    //
    dprintf("AMLTERM: %x\n", addrTerm);

    //
    // Read the name of the term into memory
    //
    nameBuff[16] = '\0';
    b = ReadMemory(
        (LPVOID) amlTerm.TermName,
        nameBuff,
        16,
        NULL
        );
    dprintf("Name: %-16s  ",( !b  ? "<Cannot Read Name>" : nameBuff) );

    //
    // Handle the symbol term
    //
    if (amlTerm.FunctionHandler != NULL) {

        //
        // Read the symbol of the term
        //
        GetSymbol( (LPVOID) amlTerm.FunctionHandler, symbolBuff, &offset );
        dprintf("    Handler: %-30s\n", symbolBuff );

    } else {

        dprintf("\n");

    }

    //
    // Display the opcode
    //
    if ( amlTerm.OpCode > 0xFF) {

        dprintf(
            "Opcode: %2x %2x",
            (amlTerm.OpCode & 0xff),
            (amlTerm.OpCode >> 8)
            );

    } else {

        dprintf("Opcode: %2x   ", amlTerm.OpCode );

    }

    //
    // Display the Argument Types
    //
    RtlZeroMemory( nameBuff, 17 );
    if (amlTerm.ArgumentTypes) {

        b = ReadMemory(
            (LPVOID) amlTerm.ArgumentTypes,
            nameBuff,
            16,
            NULL
            );
        dprintf("   Args: %-4s", (!b ? "????" : nameBuff ) );

    } else {

        dprintf("   Args: %-4s", "None");

    }

    //
    // Display the flags
    //
    switch( (amlTerm.OpCodeFlags & 0xF) ) {
        case 0: dprintf("  Flags:   NORMAL  "); break;
        case 1: dprintf("  Flags:   VARIABLE"); break;
        case 2: dprintf("  Flags:   ARG     "); break;
        case 3: dprintf("  Flags:   LOCAL   "); break;
        case 4: dprintf("  Flags:   CONSTANT"); break;
        case 5: dprintf("  Flags:   NAME    "); break;
        case 6: dprintf("  Flags:   DATA    "); break;
        case 7: dprintf("  Flags:   DEBUG   "); break;
        case 8: dprintf("  Flags:   REF     "); break;
        default: dprintf("  Flags:   UNKNOWN "); break;
    }

    //
    // Display the term group
    //
    switch(amlTerm.TermGroup & 0xF) {
        case 1: dprintf("  Group: NAMESPACE\n"); break;
        case 2: dprintf("  Group: NAMED OBJECT\n"); break;
        case 3: dprintf("  Group: TYPE 1\n"); break;
        case 4: dprintf("  Group: TYPE 2\n"); break;
        case 5: dprintf("  Group: OTHER\n"); break;
        default: dprintf("  Group: UNKNOWN\n"); break;

    }

}

DECLARE_API( scope )
{

    BOOL    b;
    DWORD   addrScope;
    SCOPE   scope;

    INIT_API();

    //
    // Evaluate the argument string to get the address of the
    // stack to dump
    //
    addrScope = GetExpression( lpArgumentString );
    if ( !addrScope) {

        return;

    }

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) addrScope,
        &scope,
        sizeof(scope),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Dump the string to the user
    //
    dumpScopeHeader(FALSE);
    dumpScope( &scope );
}

DECLARE_API( pstack )
{
    DWORD   addrStack;

    INIT_API();

    addrStack = GetExpression( lpArgumentString );
    if (!addrStack) {

        return;

    }

    dumpParseStack( addrStack );
}

DECLARE_API( sstack )
{
    DWORD   addrStack;

    INIT_API();

    addrStack = GetExpression( lpArgumentString );
    if (!addrStack) {

        return;

    }

    dumpStringStack( addrStack );
}

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {

        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;

    }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            "Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hkey
            ) == NO_ERROR
       ) {

        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(
                hkey,
                "CurrentType",
                NULL,
                &dwType,
                szCurrentType,
                &cb ) != 0
            ) {

            szCurrentType[0] = '\0';

        }

    }
    RegCloseKey(hkey);

    if (VersionInformation.szCSDVersion[0]) {

        sprintf(
            szCSDString,
            ": %s",
            VersionInformation.szCSDVersion
            );

    } else {

        szCSDString[0] = '\0';

    }

    dprintf(
        "Version %d.%d (Build %d%s) %s\n",
        VersionInformation.dwMajorVersion,
        VersionInformation.dwMinorVersion,
        VersionInformation.dwBuildNumber,
        szCSDString,
        szCurrentType
        );
    return;
}

DECLARE_API( help )
{
    INIT_API();

    dprintf("!version               - Dump System Version and Build Number\n");
    dprintf("!sscope                - Dump an UnASM Scope Stack\n");
    dprintf("!scope                 - Dump an UnASM Scope\n");
    dprintf("!pstack                - Dump an UnASM Parse Stack\n");
    dprintf("!sstack                - Dump an UnASM String STack\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\debug.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

typedef struct _SPSIM_STRING_MAP {
    ULONG Id;
    PCHAR String;
} SPSIM_STRING_MAP, *PSPSIM_STRING_MAP;

//
// Debug globals
//

extern LONG SpSimDebug;
extern SPSIM_STRING_MAP SpSimDbgPnpIrpStringMap[];
extern SPSIM_STRING_MAP SpSimDbgPoIrpStringMap[];
extern SPSIM_STRING_MAP SpSimDbgDeviceRelationStringMap[];
extern SPSIM_STRING_MAP SpSimDbgSystemPowerStringMap[];
extern SPSIM_STRING_MAP SpSimDbgDevicePowerStringMap[];
extern PSPSIM_STRING_MAP SpSimDbgStatusStringMap;

//
// Debug prototypes
//

VOID
SpSimDbgInitialize(
    VOID
    );

VOID
SpSimDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    );

PCHAR
SpSimDbgLookupString(
    IN PSPSIM_STRING_MAP Map,
    IN ULONG Id
    );

VOID
SpSimDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
SpSimDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    );

PUCHAR
SpSimDbgCmResourceTypeToText(
    UCHAR Type
    );


//
// Debug macros
//

#define DEBUG_PRINT(Level, Msg)                                             \
    if (Level <= SpSimDebug) DbgPrint Msg

#define DEBUG_MSG(Level, Msg)                                               \
    if (Level <= SpSimDebug) { DbgPrint("SpSim: "); DbgPrint Msg; }

#define ASSERT_SPSIM_DEVICE(DeviceObject)                                      \
    ASSERT(((PSPSIM_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == SpSimFunctionalDeviceObject                                 \
          ||                                                                \
           ((PSPSIM_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == SpSimPhysicalDeviceObject)


#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : SpSimDbgLookupString(SpSimDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    SpSimDbgLookupString(SpSimDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    SpSimDbgLookupString(SpSimDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    SpSimDbgLookupString(SpSimDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    SpSimDbgLookupString(SpSimDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    SpSimDbgLookupString(SpSimDbgDevicePowerStringMap, (_State))



#else

#define DEBUG_PRINT(Level, Msg) 
#define DEBUG_MSG(Level, Msg)
#define ASSERT_SPSIM_DEVICE(DeviceObject)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\debug.c ===
/*++      

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "SpSim.h"

//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }
#if DBG

LONG SpSimDebug = -1;

PSPSIM_STRING_MAP SpSimDbgStatusStringMap = (PSPSIM_STRING_MAP) ntstatusSymbolicNames;

SPSIM_STRING_MAP SpSimDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    END_STRING_MAP
};


SPSIM_STRING_MAP SpSimDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



SPSIM_STRING_MAP SpSimDbgDeviceRelationStringMap[] = {
    
    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP
    
};

SPSIM_STRING_MAP SpSimDbgSystemPowerStringMap[] = {
    
    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

SPSIM_STRING_MAP SpSimDbgDevicePowerStringMap[] = {
    
    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};

PCHAR
SpSimDbgLookupString(
    IN PSPSIM_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map
    
Arguments:

    Map - The string map
    
    Id - The id to lookup

Return Value:

    The string
        
--*/

{
    PSPSIM_STRING_MAP current = Map;
    
    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }
        
        current++;
    }
    
    return "** UNKNOWN **";
}

VOID
SpSimDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    )

/*++

Routine Description:

    Prints a registry style REG_MULTI_SZ
    
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    MultiSz - The string to print

Return Value:

    None
            
--*/

{
    PWSTR current = MultiSz;

    if (DebugLevel <= SpSimDebug) {

        if (MultiSz) {
        
            while(*current) {
        
                DbgPrint("%S", current);
                
                current += wcslen(current) + 1; // include the NULL
        
                DbgPrint(*current ? ", " : "\n");
        
            }
        } else {
            DbgPrint("*** None ***\n");
        }
    }
}

//
// Printing resource descriptors and resource lists (stolen from PCI)
//

PUCHAR
SpSimDbgCmResourceTypeToText(
    UCHAR Type
    )
{
    switch (Type) {
    case CmResourceTypePort:
        return "CmResourceTypePort";
    case CmResourceTypeInterrupt:
        return "CmResourceTypeInterrupt";
    case CmResourceTypeMemory:
        return "CmResourceTypeMemory";
    case CmResourceTypeDma:
        return "CmResourceTypeDma";
    case CmResourceTypeDeviceSpecific:
        return "CmResourceTypeDeviceSpecific";
    case CmResourceTypeBusNumber:
        return "CmResourceTypeBusNumber";
    case CmResourceTypeConfigData:
        return "CmResourceTypeConfigData";
    case CmResourceTypeDevicePrivate:
        return "CmResourceTypeDevicePrivate";
    case CmResourceTypePcCardConfig:
        return "CmResourceTypePcCardConfig";
    default:
        return "*** INVALID RESOURCE TYPE ***";
    }
}

VOID
SpSimDbgPrintIoResource(
    IN LONG Level,
    IN PIO_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= SpSimDebug) {
    
        t = SpSimDbgCmResourceTypeToText(D->Type);
        DbgPrint("     IoResource Descriptor dump:  Descriptor @0x%x\n", D);
        DbgPrint("        Option           = 0x%x\n", D->Option);
        DbgPrint("        Type             = %d (%s)\n", D->Type, t);
        DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
        DbgPrint("        Flags            = 0x%04X\n", D->Flags);
    
        for ( i = 0; i < 6 ; i+=3 ) {
            DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                     i,
                     D->u.DevicePrivate.Data[i],
                     D->u.DevicePrivate.Data[i+1],
                     D->u.DevicePrivate.Data[i+2]);
        }
    }
}


VOID
SpSimDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    )
{
    ULONG                   numlists;
    PIO_RESOURCE_LIST       list;


    if (Level <= SpSimDebug) {
    
        if (IoResReqList) {
            
            numlists = IoResReqList->AlternativeLists;
            list     = IoResReqList->List;
        
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     AlternativeLists     %d\n", numlists                   );
        
            while (numlists--) {
        
                PIO_RESOURCE_DESCRIPTOR resource = list->Descriptors;
                ULONG                   count    = list->Count;
        
                DbgPrint("\n     List[%d].Count = %d\n", numlists, count);
                while (count--) {
                    SpSimDbgPrintIoResource(Level, resource++);
                }
        
                list = (PIO_RESOURCE_LIST)resource;
            }
            DbgPrint("\n");
        } else {
            
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     *** EMPTY ***\n");
        }
    }
}


VOID
SpSimDbgPrintPartialResource(
    IN LONG Level,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= SpSimDebug) {

        if (D) {
        
            t = SpSimDbgCmResourceTypeToText(D->Type);
            DbgPrint("     Partial Resource Descriptor @0x%x\n", D);
            DbgPrint("        Type             = %d (%s)\n", D->Type, t);
            DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
            DbgPrint("        Flags            = 0x%04X\n", D->Flags);
            
            for ( i = 0; i < 3 ; i+=3 ) {
                DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                         i,
                         D->u.DevicePrivate.Data[i],
                         D->u.DevicePrivate.Data[i+1],
                         D->u.DevicePrivate.Data[i+2]);
            }

        } else {
        
            DbgPrint("     Partial Resource Descriptor EMPTY!!\n");
        }
    }
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
SpSimNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    Given a pointer to a CmPartialResourceDescriptor, return a pointer
    to the next descriptor in the same list.

    This is only done in a routine (rather than a simple descriptor++)
    because if the variable length resource CmResourceTypeDeviceSpecific.

Arguments:

    Descriptor   - Pointer to the descriptor being advanced over.

Return Value:

    Pointer to the next descriptor in the same list (or byte beyond
    end of list).

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextDescriptor;

    nextDescriptor = Descriptor + 1;

    if (Descriptor->Type == CmResourceTypeDeviceSpecific) {

        //
        // This (old) descriptor is followed by DataSize bytes
        // of device specific data, ie, not immediatelly by the
        // next descriptor.   Adjust nextDescriptor by this amount.
        //

        nextDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((PCHAR)nextDescriptor + Descriptor->u.DeviceSpecificData.DataSize);
    }
    return nextDescriptor;
}


VOID
SpSimDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (Level <= SpSimDebug) {
    

        if (ResourceList) {
        
            numlists = ResourceList->Count;
            full     = ResourceList->List;
        
            DbgPrint("  CM_RESOURCE_LIST (List Count = %d)\n",
                     numlists);
        
            while (numlists--) {
                PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
                ULONG                     count   = partial->Count;
        
                descriptor = partial->PartialDescriptors;
                while (count--) {
                    SpSimDbgPrintPartialResource(Level, descriptor);
                    descriptor = SpSimNextPartialDescriptor(descriptor);
                }
        
                full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
            }
            DbgPrint("\n");
        
        } else {
        
            DbgPrint("  CM_RESOURCE_LIST EMPTY!!!\n");
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\dispatch.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module provides the functions which dispatch IRPs to FDOs and PDOs.

Author:

    Adam Glass

Revision History:

--*/


#include "SpSim.h"
#include "spsimioct.h"

const GUID SPSIM_CTL = {0xbdde6934, 0x529d, 0x4183, 0xa9, 0x52, 0xad,
                        0xff, 0xb0, 0xdb, 0xb3, 0xdd};

NTSTATUS
SpSimAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
SpSimDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, SpSimAddDevice)
#pragma alloc_text(PAGE, SpSimDispatchPnp)
#endif

NTSTATUS
SpSimAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    Given a physical device object, this routine creates a functional
    device object for it and attaches it to the top of the stack.

Arguments:

    DriverObject - Pointer to our driver's DRIVER_OBJECT structure.

    PhysicalDeviceObject - Pointer to the physical device object for which
                           we must create a functional device object.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;
    PSPSIM_EXTENSION extension;

    ASSERT(DriverObject == SpSimDriverObject);

    PAGED_CODE();

    //
    // Create our FDO
    //

    status = SpSimCreateFdo(&fdo);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    extension = fdo->DeviceExtension;

    extension->PhysicalDeviceObject = PhysicalDeviceObject;

    //
    // Attach to the stack
    //
    
    extension->AttachedDevice = IoAttachDeviceToDeviceStack(
                                    fdo,
                                    PhysicalDeviceObject
                                    );

    if (!extension->AttachedDevice) {

        //
        // Could not attach
        //

        status = STATUS_NO_SUCH_DEVICE;
        goto cleanup;
    }

    status = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                       &SPSIM_CTL,
                                       NULL,
                                       &extension->SymbolicLinkName);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    DEBUG_MSG(1, ("Completed AddDevice for PDO 0x%08x\n", PhysicalDeviceObject));

    return STATUS_SUCCESS;

cleanup:

    if (fdo) {
        IoDeleteDevice(fdo);
    }

    return status;
}

NTSTATUS
SpSimDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for this driver.  It dispatches to
    the appropriate fdo/pdo routine.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PSPSIM_EXTENSION spsim;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    spsim = (PSPSIM_EXTENSION)  DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    return SpSimDispatchPnpFdo(DeviceObject,
                               spsim,
                               irpStack,
                               Irp
                               );
}

NTSTATUS
SpSimOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

#if 0
NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for this driver.  It dispatches
    to the routines described in the PoDispatchTable entry in the device object
    extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/


{
    NTSTATUS status;
    PSpSim_COMMON_EXTENSION common;
    PIO_STACK_LOCATION irpStack;

    ASSERT_SpSim_DEVICE(DeviceObject);

    //
    // Find out who we are and what we need to do
    //

    common = (PSpSim_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    if (IS_FDO(common)) {
        return SpSimDispatchPowerFdo(DeviceObject,
                                  (SPSIM_EXTENSION) common,
                                  irpStack,
                                  Irp);
    } else {
        return SpSimDispatchPowerPdo(DeviceObject,
                                  (PSpSim_CHILD_EXTENSION) common,
                                  irpStack,
                                  Irp);
    }
}

#endif

NTSTATUS
SpSimIrpNotSupported(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
/*++

Routine Description:

    This function handles the unsupported IRPs for both SpSim PDOs and FDOs

    This is NOT paged because is can be called from SpSimDispatchPower which can
    be called at DISPATCH_LEVEL

Arguments:

    Irp - Points to the IRP associated with this request.

    Extension - Points to the device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    STATUS_NOT_SUPPORTED

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Extension);
    UNREFERENCED_PARAMETER(IrpStack);

    DEBUG_MSG(1, ("Skipping upsupported IRP\n"));

    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\client\spctl.c ===
#include <windows.h>
#include <devioctl.h>
#include <spsimioct.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

typedef struct {
    WCHAR *szName;
} MANAGED_DEVICE, *PMANAGED_DEVICE;

PMANAGED_DEVICE g_pManagedDevices;
ULONG g_nDevices;

VOID Usage()
{
    _tprintf(TEXT("usage: spctl command args...\n"));
    _tprintf(TEXT("  commands are:\n"));
    _tprintf(TEXT("       notify devnum code\n"));
    _tprintf(TEXT("       setsta devnum value\n"));
    _tprintf(TEXT("       insert [devnum | * ]\n"));
    _tprintf(TEXT("       eject [devnum | * ]\n"));
    _tprintf(TEXT("       <nothing> - prints device status\n"));
}

DWORD
Notify(
    HANDLE hSpSim,
    DWORD Device,
    BYTE NotifyValue
    )
{
    SPSIM_NOTIFY_DEVICE notify;
    BOOL bResult;
    DWORD dwReturned;

    notify.Device = Device;
    notify.NotifyValue = NotifyValue;
    bResult = DeviceIoControl(hSpSim,
                              IOCTL_SPSIM_NOTIFY_DEVICE,
                              &notify,
                              sizeof(notify),
                              NULL,
                              0,
                              &dwReturned,
                              NULL
                              );
    if (!bResult) {

        _tprintf(TEXT("unable to notify device %u: %u\n"), Device, GetLastError());
        return GetLastError();
    }
    return 0;
}
DWORD
SetSta(
    HANDLE hSpSim,
    DWORD Device,
    BYTE StaValue
    )
{
    SPSIM_ACCESS_STA access;
    BOOL bResult;
    DWORD dwReturned;

    access.Device = Device;
    access.StaValue = StaValue;
    access.WriteOperation = TRUE;
    bResult = DeviceIoControl(hSpSim,
                              IOCTL_SPSIM_ACCESS_STA,
                              &access,
                              sizeof(access),
                              NULL,
                              0,
                              &dwReturned,
                              NULL
                              );
    if (!bResult) {
        _tprintf(TEXT("unable to set operation region's sta value for device %u: %u\n"), Device, GetLastError());
        return GetLastError();
    }
    return 0;
}
DWORD
GetManagedDevices(
    HANDLE hSpSim,
    DWORD Count
    )
{
    PSPSIM_DEVICE_NAME name;
    BOOL bResult;
    DWORD dwReturned, bufferSize, dwError, i;

    g_nDevices = Count;
    g_pManagedDevices = LocalAlloc(LPTR,
                                   g_nDevices * sizeof(MANAGED_DEVICE));
    if (g_pManagedDevices == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    bufferSize = sizeof(SPSIM_DEVICE_NAME) + sizeof(WCHAR) * 1024;
    name = LocalAlloc(LPTR, bufferSize);
    if (name == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for (i = 0; i < g_nDevices; i++) {
        name->Device = i;
        bResult = DeviceIoControl(hSpSim,
                                  IOCTL_SPSIM_GET_DEVICE_NAME,
                                  name,
                                  bufferSize,
                                  name,
                                  bufferSize,
                                  &dwReturned,
                                  NULL
                                  );
        if (!bResult) {
            return GetLastError();
        }
        g_pManagedDevices[i].szName = _wcsdup(name->DeviceName);
    }

    return 0;
}

void __cdecl
_tmain(INT argx, TCHAR *argv[]) {
    HANDLE hSpSim;
    PSPSIM_MANAGED_DEVICES managed;
    BOOL bResult;
    DWORD dwReturned, bufferSize, dwError;
    DWORD Device;
    BYTE NotifyCode, StaValue;
    
    managed = LocalAlloc(LPTR, sizeof(SPSIM_MANAGED_DEVICES));
    if (managed == NULL) {
        _tprintf(TEXT("out of memory\n"));
        return;
    }
    bufferSize = sizeof(SPSIM_MANAGED_DEVICES);

    //
    // BUGBUG Need to get the interface in a more portable way.
    //
    hSpSim = CreateFile(TEXT("\\\\.\\ACPI#SPSIMUL#2&daba3ff&0#{bdde6934-529d-4183-a952-adffb0dbb3dd}"), 
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
                       );
    if (hSpSim == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("Could not open handle to device.\n GetLastError()==%x\n"), 
                 GetLastError());
        return;
    }

retry:

    bResult = DeviceIoControl(hSpSim,
                              IOCTL_SPSIM_GET_MANAGED_DEVICES,
                              NULL,
                              0,
                              managed,
                              bufferSize,
                              &dwReturned,
                              NULL
                              );
    if (!bResult) {
        dwError = GetLastError();
        if (dwError == ERROR_MORE_DATA) {
            bufferSize = sizeof(SPSIM_MANAGED_DEVICES) +
                managed->Count * sizeof(UCHAR);
            managed = LocalReAlloc(managed, bufferSize, LMEM_MOVEABLE);
            if (managed == NULL) {
                _tprintf(TEXT("unable to realloc memory\n"));
                return;
            }
            goto retry;
        }
    } else {
        dwError = GetManagedDevices(hSpSim, managed->Count);
        if (dwError) {
            _tprintf("Couldn't get info on managed devices: %u\n", dwError);
            return;
        }
    }

    if (argx == 1) {
        for (Device = 0; Device < g_nDevices; Device++) {
            _tprintf(TEXT("\tDev %u : %_STA is 0x%x Name %ws\n"), Device, managed->StaValues[Device], g_pManagedDevices[Device].szName);
        }
    }
    else if (argx == 4) {
        Device = _ttol(argv[2]);
        if (!_tcsicmp(argv[1], "notify")) {
            NotifyCode = (BYTE) _ttol(argv[3]);

            Notify(hSpSim, Device, NotifyCode);
        } else if (!_tcsicmp(argv[1], "setsta")) {

            StaValue = (BYTE) _ttol(argv[3]);

            SetSta(hSpSim, Device, StaValue);
        } else {
            Usage();
        }            
    } else if (argx == 3) {
        if (!_tcsicmp(argv[1], "insert")) {
            if (*argv[2] == '*') {

                for (Device = 0; Device < g_nDevices; Device++) {
                    SetSta(hSpSim, Device, 0xf);
                    Notify(hSpSim, Device, 1);
                }
            } else {
                Device = _ttol(argv[2]);

                SetSta(hSpSim, Device, 0xf);
                Notify(hSpSim, Device, 1);
            }
        } else if (!_tcsicmp(argv[1], "eject")) {
            if (*argv[2] == '*') {

                for (Device = 0; Device < g_nDevices; Device++) {
                    Notify(hSpSim, Device, 3);
                }
            } else {
                Device = _ttol(argv[2]);

                Notify(hSpSim, Device, 3);
            }
        } else {
            Usage();
        }
    } else {
        Usage();
    }

    CloseHandle(hSpSim);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\fdo.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdo.c

Abstract:

    This module provides the functions which answer IRPs to functional devices.

Author:

    (Derived from MF)

Revision History:

--*/

#include "SpSim.h"
#include "spsimioct.h"

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
SpSimXxxFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:

    This function handles the Xxx requests for multifunction FDO's

Arguments:

    Irp - Points to the IRP associated with this request.

    SpSim - Points to the parent FDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be passed down without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/


NTSTATUS
SpSimDeferProcessingFdo(
    IN PSPSIM_EXTENSION SpSim,
    IN OUT PIRP Irp
    );

NTSTATUS
SpSimStartFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimStartFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpSimQueryStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimCancelStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimQueryRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimCancelRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, SpSimCancelRemoveFdo)
#pragma alloc_text(PAGE, SpSimCancelStopFdo)
#pragma alloc_text(PAGE, SpSimCreateFdo)
#pragma alloc_text(PAGE, SpSimDeferProcessingFdo)
#pragma alloc_text(PAGE, SpSimDispatchPnpFdo)
#pragma alloc_text(PAGE, SpSimPassIrp)
#pragma alloc_text(PAGE, SpSimQueryRemoveFdo)
#pragma alloc_text(PAGE, SpSimQueryStopFdo)
#pragma alloc_text(PAGE, SpSimRemoveFdo)
#pragma alloc_text(PAGE, SpSimStartFdo)
#pragma alloc_text(PAGE, SpSimQueryCapabilitiesFdo)
#pragma alloc_text(PAGE, SpSimSurpriseRemoveFdo)
#endif


PSPSIM_DISPATCH SpSimPnpDispatchTableFdo[] = {
    SpSimStartFdo,                     // IRP_MN_START_DEVICE
    SpSimQueryRemoveFdo,               // IRP_MN_QUERY_REMOVE_DEVICE
    SpSimRemoveFdo,                    // IRP_MN_REMOVE_DEVICE
    SpSimCancelRemoveFdo,              // IRP_MN_CANCEL_REMOVE_DEVICE
    SpSimPassIrp,                      // IRP_MN_STOP_DEVICE
    SpSimQueryStopFdo,                 // IRP_MN_QUERY_STOP_DEVICE
    SpSimCancelStopFdo,                // IRP_MN_CANCEL_STOP_DEVICE
    SpSimPassIrp,                      // IRP_MN_QUERY_DEVICE_RELATIONS
    SpSimPassIrp,                      // IRP_MN_QUERY_INTERFACE
    SpSimQueryCapabilitiesFdo,         // IRP_MN_QUERY_CAPABILITIES
    SpSimPassIrp,                      // IRP_MN_QUERY_RESOURCES
    SpSimPassIrp,                      // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    SpSimPassIrp,                      // IRP_MN_QUERY_DEVICE_TEXT
    SpSimPassIrp,                      // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    SpSimPassIrp,                      // Unused
    SpSimPassIrp,                      // IRP_MN_READ_CONFIG
    SpSimPassIrp,                      // IRP_MN_WRITE_CONFIG
    SpSimPassIrp,                      // IRP_MN_EJECT
    SpSimPassIrp,                      // IRP_MN_SET_LOCK
    SpSimPassIrp,                      // IRP_MN_QUERY_ID
    SpSimPassIrp,                      // IRP_MN_QUERY_PNP_DEVICE_STATE
    SpSimPassIrp,                      // IRP_MN_QUERY_BUS_INFORMATION
    SpSimPassIrp,                      // IRP_MN_DEVICE_USAGE_NOTIFICATION
    SpSimSurpriseRemoveFdo,            // IRP_MN_SURPRISE_REMOVAL
};

NTSTATUS
SpSimCreateFdo(
    OUT PDEVICE_OBJECT *Fdo
    )
/*++

Routine Description:

    This function creates a new FDO and initializes it.

Arguments:

    Fdo - Pointer to where the FDO should be returned

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

    NTSTATUS status;
    PSPSIM_EXTENSION extension;

    PAGED_CODE();

    ASSERT((sizeof(SpSimPnpDispatchTableFdo) / sizeof(PSPSIM_DISPATCH)) - 1
           == IRP_MN_PNP_MAXIMUM_FUNCTION);

#if 0
    ASSERT((sizeof(SpSimPoDispatchTableFdo) / sizeof(PSPSIM_DISPATCH)) -1
       == IRP_MN_PO_MAXIMUM_FUNCTION);
#endif

    *Fdo = NULL;

    status = IoCreateDevice(SpSimDriverObject,
                            sizeof(SPSIM_EXTENSION),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            0,
                            FALSE,
                            Fdo
                           );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Initialize the extension
    //

    extension = (PSPSIM_EXTENSION) (*Fdo)->DeviceExtension;

    extension->Self = *Fdo;

    IoInitializeRemoveLock(&extension->RemoveLock, 0, 1, 20);

    extension->PowerState = PowerDeviceD3;

    DEBUG_MSG(1, ("Created FDO @ 0x%08x\n", *Fdo));

    return status;

cleanup:

    if (*Fdo) {
        IoDeleteDevice(*Fdo);
    }

    return status;

}

VOID
SpSimDeleteFdo(
    IN PDEVICE_OBJECT Fdo
    )
{
    PSPSIM_EXTENSION SpSim = Fdo->DeviceExtension;

    if (SpSim->DeviceState & SPSIM_DEVICE_DELETED) {
        //
        // Trying to delete twice
        //
        ASSERT(!(SpSim->DeviceState & SPSIM_DEVICE_DELETED));
        return;
    }

    SpSim->DeviceState = SPSIM_DEVICE_DELETED;

    SpSimDeleteStaOpRegion(SpSim);

    SpSimDeleteMemOpRegion(SpSim);

    RtlFreeUnicodeString(&SpSim->SymbolicLinkName);

    //
    // Free up any memory we have allocated
    //

    IoDeleteDevice(Fdo);

    DEBUG_MSG(1, ("Deleted FDO @ 0x%08x\n", Fdo));

}

NTSTATUS
SpSimPassIrp(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(SpSim->AttachedDevice, Irp);
}

NTSTATUS
SpSimDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    SpSim - FDO extension

    IrpStack - Current stack location
    
    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    BOOLEAN isRemoveDevice;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    IoAcquireRemoveLock(&SpSim->RemoveLock, (PVOID) Irp);

    isRemoveDevice = IrpStack->MinorFunction == IRP_MN_REMOVE_DEVICE;

    if (IrpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        status = SpSimPassIrp(Irp, SpSim, IrpStack);

    } else {

        status =
            SpSimPnpDispatchTableFdo[IrpStack->MinorFunction](Irp,
                                                          SpSim,
                                                          IrpStack
                                                          );
    }

    if (!isRemoveDevice) {
        IoReleaseRemoveLock(&SpSim->RemoveLock, (PVOID) Irp);
    }

    return status;
}

NTSTATUS
SpSimPnPFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SpSimDeferProcessingFdo(
    IN PSPSIM_EXTENSION SpSim,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    SpSim - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           SpSimPnPFdoCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(SpSim->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
SpSimStartFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    IO_STACK_LOCATION location;
    POWER_STATE power;

    PWSTR string;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    power.DeviceState = PowerDeviceD0;
    PoSetPowerState(SpSim->Self, DevicePowerState, power);
    SpSim->PowerState = PowerDeviceD0;

    status = SpSimCreateStaOpRegion(SpSim);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = SpSimCreateMemOpRegion(SpSim);
    if (!NT_SUCCESS(status)) {
        SpSimDeleteStaOpRegion(SpSim);
        goto cleanup;
    }

    status = SpSimInstallStaOpRegionHandler(SpSim);
    if (!NT_SUCCESS(status)) {
        SpSimDeleteStaOpRegion(SpSim);
        goto cleanup;
    }

    status = SpSimInstallMemOpRegionHandler(SpSim);
    if (!NT_SUCCESS(status)) {
        SpSimDeleteStaOpRegion(SpSim);
        goto cleanup;
    }

    status = IoSetDeviceInterfaceState(&SpSim->SymbolicLinkName, TRUE);

cleanup:

    Irp->IoStatus.Status = status;
    if (!NT_SUCCESS(status)) {
        SpSimRemoveStaOpRegionHandler(SpSim);
        SpSimDeleteStaOpRegion(SpSim);
        SpSimRemoveMemOpRegionHandler(SpSim);
        SpSimDeleteMemOpRegion(SpSim);
    } else {
        //
        // We are now started!
        //
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;    
}

NTSTATUS
SpSimQueryStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
SpSimCancelStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimQueryRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return SpSimPassIrp(Irp, SpSim, IrpStack);
}

NTSTATUS
SpSimRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    POWER_STATE power;

    power.DeviceState = PowerDeviceD3;
    PoSetPowerState(SpSim->Self, DevicePowerState, power);
    SpSim->PowerState = PowerDeviceD3;

    (VOID) IoSetDeviceInterfaceState(&SpSim->SymbolicLinkName, FALSE);

    SpSimRemoveStaOpRegionHandler(SpSim);
    SpSimRemoveMemOpRegionHandler(SpSim);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = SpSimPassIrp(Irp, SpSim, IrpStack);
    ASSERT(status == STATUS_SUCCESS);

    IoReleaseRemoveLockAndWait(&SpSim->RemoveLock, (PVOID) Irp);

    //
    // Detach and delete myself
    //

    IoDetachDevice(SpSim->AttachedDevice);
    SpSim->AttachedDevice = NULL;

    SpSimDeleteFdo(SpSim->Self);

    return STATUS_SUCCESS;
}

NTSTATUS
SpSimQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (IrpStack->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    for (i = 0; i < PowerSystemMaximum; i++) {
        SpSim->DeviceStateMapping[i] =
            IrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    SpSim->DeviceState |= SPSIM_DEVICE_SURPRISE_REMOVED;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return SpSimPassIrp(Irp, SpSim, IrpStack);
}

NTSTATUS
SpSimCancelRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Description:

    Builds and send an IOCTL to a device and return the results

Arguments:

    Device - a device on the device stack to receive the IOCTL - the
             irp is always sent to the top of the stack

    IoctlCode - the IOCTL to run
    
    InputBuffer - arguments to the IOCTL
    
    InputBufferLength - length in bytes of the InputBuffer

    OutputBuffer - data returned by the IOCTL
    
    OnputBufferLength - the size in bytes of the OutputBuffer
    
Return Value:

    Status

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT targetDevice = NULL;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get the top of the stack to send the IRP to
    //

    targetDevice = IoGetAttachedDeviceReference(Device);

    if (!targetDevice) {
        status = STATUS_INVALID_PARAMETER;
	goto exit;
    }

    //
    // Get Io to build the IRP for us
    //

    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        targetDevice,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        FALSE, // InternalDeviceIoControl
                                        &event,
                                        &ioStatus
                                        );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IRP and wait for it to complete
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

exit:

    if (targetDevice) {    
        ObDereferenceObject(targetDevice);
    }

    return status;

}

NTSTATUS                           
SpSimDevControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

	DeviceIoControl handler.  It can handle both IOCTL_MEC_BIOS_OP_ACCESS and IOCTL_MEC_LOCAL_OP_ACCESS
	calls.  
	For example purposes this handles running ACPI methods in the bios.

Arguments:

	DeviceObject    - Pointer to class device object.
	Irp             - Pointer to the request packet.

Return Value:

	ntStatus

--*/
{
    PIO_STACK_LOCATION  CurrentIrpStack;
    PSPSIM_EXTENSION spsim = (PSPSIM_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS status;

    if (!Irp || !(CurrentIrpStack=IoGetCurrentIrpStackLocation(Irp))) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_2;
        IoCompleteRequest(Irp, 0);
        return STATUS_INVALID_PARAMETER_2;
    }

    switch(CurrentIrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SPSIM_GET_MANAGED_DEVICES:
        status = SpSimGetManagedDevicesIoctl(spsim, Irp, CurrentIrpStack);
        break;
    case IOCTL_SPSIM_ACCESS_STA:
        status = SpSimAccessStaIoctl(spsim, Irp, CurrentIrpStack);
        break;
    case IOCTL_SPSIM_NOTIFY_DEVICE:
        status = SpSimNotifyDeviceIoctl(spsim, Irp, CurrentIrpStack);
        break;
    case IOCTL_SPSIM_GET_DEVICE_NAME:
        status = SpSimGetDeviceName(spsim, Irp, CurrentIrpStack);
        break;
    default:
        status = SpSimPassIrp(Irp, spsim, CurrentIrpStack);
        return status;
    }
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
SpSimPowerCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PSPSIM_EXTENSION deviceExtension;
    PIRP Irp;
    NTSTATUS status;

    Irp = Context;
    deviceExtension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
}

NTSTATUS
SpSimPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID NotUsed
    )
/*++

Routine Description:

   The completion routine for Power

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Not used  - context pointer

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PSPSIM_EXTENSION deviceExtension;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        SYSTEM_POWER_STATE system =
            irpStack->Parameters.Power.State.SystemState;
        POWER_STATE power;

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            power.DeviceState = deviceExtension->DeviceStateMapping[system];

            PoRequestPowerIrp(DeviceObject,
                              irpStack->MinorFunction,
                              power,
                              SpSimPowerCallback,
                              Irp, 
                              NULL);
            return STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            status = Irp->IoStatus.Status;
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    } else {
        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            PoSetPowerState(DeviceObject, DevicePowerState,
                            irpStack->Parameters.Power.State);
            deviceExtension->PowerState =
                irpStack->Parameters.Power.State.DeviceState;
        }
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSPSIM_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);
    if (status == STATUS_DELETE_PENDING) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
         PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   SpSimPowerCompletion,
                                   NULL,   //Context
                                   TRUE,   //InvokeOnSuccess
                                   TRUE,  //InvokeOnError
                                   TRUE   //InvokeOnCancel
                                   );
            return PoCallDriver(deviceExtension->AttachedDevice, Irp);
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return status;
        }
    } else {
        switch (irpStack->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpStack->Parameters.Power.State.DeviceState >
                deviceExtension->PowerState) {
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       SpSimPowerCompletion,
                                       NULL,   //Context
                                       TRUE,   //InvokeOnSuccess
                                       TRUE,  //InvokeOnError
                                       TRUE   //InvokeOnCancel
                                       );
                break;
            } else {
                PoSetPowerState(DeviceObject, DevicePowerState,
                                irpStack->Parameters.Power.State);
                deviceExtension->PowerState =
                    irpStack->Parameters.Power.State.DeviceState;
                // 
                // Fall through ...
                //
            }
        case IRP_MN_QUERY_POWER:
            //
            // Fall through as the bus driver will mark this
            // STATUS_SUCCESS and complete it, if it gets that far.
            //
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            break;
        }
        status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\init.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the initialization and unload functions.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "SpSim.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SpSimUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SpSimUnload)
#endif

PDRIVER_OBJECT SpSimDriverObject;

NTSTATUS
SpSimDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles irps like IRP_MJ_DEVICE_CONTROL, which we don't support.
    This handler will complete the irp (if PDO) or pass it (if FDO).

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PSPSIM_EXTENSION spsim;
    PDEVICE_OBJECT attachedDevice;

    PAGED_CODE();

    spsim = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(spsim->AttachedDevice, Irp);
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    
    This is the entry point to SpSim.SYS and performs initialization.
    
Arguments:

    DriverObject - The system owned driver object for SpSim
    
    RegistryPath - The path to SpSim's service entry
    
Return Value:

    STATUS_SUCCESS

--*/
{

    DriverObject->DriverExtension->AddDevice = SpSimAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SpSimOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SpSimOpenClose;
    DriverObject->MajorFunction[IRP_MJ_PNP] = SpSimDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = SpSimDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SpSimDevControl;
    DriverObject->DriverUnload = SpSimUnload;

    //
    // Remember the driver object
    //

    SpSimDriverObject = DriverObject;

    DEBUG_MSG(1, ("Completed DriverEntry for Driver 0x%08x\n", DriverObject));
    
    return STATUS_SUCCESS;
}

VOID
SpSimUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This is called to reverse any operations performed in DriverEntry before a
    driver is unloaded.
        
Arguments:

    DriverObject - The system owned driver object for SpSim
    
Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();
    
    DEBUG_MSG(1, ("Completed Unload for Driver 0x%08x\n", DriverObject));
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\inc\spsimioct.h ===
DEFINE_GUID(SPSIM_CTL, 0xbdde6934, 0x529d, 0x4183, 0xa9, 0x52, 0xad,
            0xff, 0xb0, 0xdb, 0xb3, 0xdd);

typedef struct _SPSIM_ACCESS_STA {
    BOOLEAN WriteOperation;
    ULONG Device;
    UCHAR StaValue;
} SPSIM_ACCESS_STA, *PSPSIM_ACCESS_STA;

typedef struct _SPSIM_NOTIFY_DEVICE {
    ULONG Device;
    UCHAR NotifyValue;
} SPSIM_NOTIFY_DEVICE, *PSPSIM_NOTIFY_DEVICE;

typedef struct _SPSIM_DEVICE_NAME {
    ULONG   Device;
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} SPSIM_DEVICE_NAME, *PSPSIM_DEVICE_NAME;

typedef struct _SPSIM_MANAGED_DEVICES {
    ULONG Count;
    UCHAR StaValues[1]; 
} SPSIM_MANAGED_DEVICES, *PSPSIM_MANAGED_DEVICES;

#define IOCTL_SPSIM_ACCESS_STA       CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCC,METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPSIM_NOTIFY_DEVICE    CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCD,METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPSIM_GET_DEVICE_NAME      CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCE,METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPSIM_GET_MANAGED_DEVICES CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCF,METHOD_BUFFERED, FILE_READ_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\sta.c ===
#include "spsim.h"
#include "spsimioct.h"

NTSTATUS
SpSimCreateStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
/*++

Description:

    Retrieves information to construct the STA array that tells us
    what devices we control the _STA on

Arguments:

    SpSim - device extension

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG i;
    PACPI_METHOD_ARGUMENT argument;    
    //
    // Allocate a buffer big enough for all possible slots
    //

    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER);

    PAGED_CODE();

    output = ExAllocatePool(PagedPool, outputSize);

    if (!output) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send a IOCTL to ACPI to request evaluate the
    // SPSIM_STA_NAMES_METHOD under this object if present.
    //

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = SPSIM_STA_NAMES_METHOD;

    status = SpSimSendIoctl(SpSim->PhysicalDeviceObject,
                            IOCTL_ACPI_EVAL_METHOD,
                            &input,
                            sizeof(ACPI_EVAL_INPUT_BUFFER),
                            output,
                            outputSize
                            );
    if (status == STATUS_BUFFER_OVERFLOW) {
        outputSize = output->Length;
        ExFreePool(output);
        output = ExAllocatePool(PagedPool, outputSize);

        if (!output) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        status = SpSimSendIoctl(SpSim->PhysicalDeviceObject,
                                IOCTL_ACPI_EVAL_METHOD,
                                &input,
                                sizeof(ACPI_EVAL_INPUT_BUFFER),
                                output,
                                outputSize
                                );
    }

    if (NT_SUCCESS(status)) {
        argument = output->Argument;
        for (i = 0; i < output->Count; i++) {
            if (argument->Type != ACPI_METHOD_ARGUMENT_STRING) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        }
        SpSim->StaOpRegionValues = ExAllocatePool(NonPagedPool,
                                                  sizeof(UCHAR) * output->Count);
        if (SpSim->StaOpRegionValues == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            SpSim->StaNames = output;
            SpSim->StaCount = output->Count;
            RtlZeroMemory(SpSim->StaOpRegionValues,
                          sizeof(UCHAR) * SpSim->StaCount);
        }
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(output);
        SpSim->StaOpRegionValues = NULL;
        SpSim->StaNames = NULL;
        SpSim->StaCount = 0;
    }

    return status;
}

VOID
SpSimDeleteStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
{
    if (SpSim->StaNames) {
        ExFreePool(SpSim->StaNames);
        SpSim->StaNames = NULL;
    }

    if (SpSim->StaOpRegionValues) {
        ExFreePool(SpSim->StaOpRegionValues);
        SpSim->StaOpRegionValues = NULL;
    }
}
NTSTATUS
SpSimGetDeviceName(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PSPSIM_DEVICE_NAME name;
    PACPI_METHOD_ARGUMENT argument;
    PUCHAR source;
    PWCHAR dest;
    ULONG remainingBuffer, i, nameSize;

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaNames == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    name = Irp->AssociatedIrp.SystemBuffer;

    if (name->Device >= SpSim->StaCount) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(SPSIM_DEVICE_NAME)) {
        return STATUS_INVALID_PARAMETER;
    }

    argument = SpSim->StaNames->Argument;
    i = 0;
    while (i != name->Device) {
        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        i++;
    }
    
    nameSize = argument->DataLength * sizeof(WCHAR);
    name->DeviceNameLength = argument->DataLength;

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < (sizeof(SPSIM_DEVICE_NAME) + (nameSize - sizeof(WCHAR)))) {
        Irp->IoStatus.Information = sizeof(SPSIM_DEVICE_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    source = argument->Data;
    dest = name->DeviceName;
    while(*source) {
        *dest++ = (WCHAR) *source++;
    }
    *dest = UNICODE_NULL;
    Irp->IoStatus.Information = sizeof(SPSIM_DEVICE_NAME) - sizeof(WCHAR) +
        nameSize;
    return STATUS_SUCCESS;
}
NTSTATUS
SpSimGetManagedDevicesIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PACPI_METHOD_ARGUMENT argument;    
    PSPSIM_MANAGED_DEVICES managed;
    ULONG i, outputSize;
    PUCHAR current;
    NTSTATUS status;

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaOpRegionValues == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SPSIM_MANAGED_DEVICES)) {
        return STATUS_INVALID_PARAMETER;
    }

    managed = Irp->AssociatedIrp.SystemBuffer;
    managed->Count = SpSim->StaCount;

    outputSize = (sizeof(SPSIM_MANAGED_DEVICES) - sizeof(UCHAR)) +
        SpSim->StaCount * sizeof(UCHAR);

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < outputSize) {
        Irp->IoStatus.Information = sizeof(SPSIM_MANAGED_DEVICES);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(managed->StaValues,
                  SpSim->StaOpRegionValues,
                  SpSim->StaCount);
    
    Irp->IoStatus.Information = outputSize;
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimStaOpRegionReadWrite(
    PSPSIM_EXTENSION SpSim,
    ULONG AccessType,
    ULONG Offset,
    ULONG Size,
    PUCHAR Data
    )
{
    ULONG i;
    PUCHAR current;

    if (SpSim->StaOpRegionValues == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Offset >= SpSim->StaCount) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Offset + Size > SpSim->StaCount) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(Offset < SpSim->StaCount);

    current = SpSim->StaOpRegionValues + Offset;

    if (AccessType & ACPI_OPREGION_WRITE) {
        for (i = 0 ; i < Size; i++) {
            *current++ = *Data++;
        }
    } else {
        for (i = 0 ; i < Size; i++) {
            *Data++ = *current++;
        }
    }
    return STATUS_SUCCESS;
}
    

NTSTATUS
EXPORT
SpSimStaOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

	 This routine handles requests to service the 
	 SPSIM operation region contained within this driver

Arguments:

	 AccessType          - Read or Write data
	 OpRegion            - Operation region object
	 Address             - Address within the EC address space
	 Size                - Number of bytes to transfer
	 Data                - Data buffer to transfer to/from
	 Context             - SpSim
	 CompletionHandler   - AMLI handler to call when operation is complete
	 CompletionContext   - Context to pass to the AMLI handler

Return Value:

	 Status

--*/
{
    NTSTATUS status;

    status = SpSimStaOpRegionReadWrite((PSPSIM_EXTENSION) Context,
                                       AccessType,
                                       Address,
                                       Size,
                                       (PUCHAR)Data);
    return status;
}

NTSTATUS
SpSimInstallStaOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	This calls the ACPI driver to install itself as the op region
	handler for the STA region.  It also allocates the memory for the
	opregion itself.

Arguments:

	pSpSimData      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS                                status;

    status=RegisterOpRegionHandler (
        SpSim->AttachedDevice,
        ACPI_OPREGION_ACCESS_AS_COOKED,
        STA_OPREGION,
        SpSimStaOpRegionHandler,
        SpSim,
        0,
        &SpSim->StaOpRegion
        );

    //
    // Check the status code
    //
    if(!NT_SUCCESS(status)) {
        SpSim->StaOpRegion = NULL;
        DbgPrint("Not successful in installing:=%x\n", status);
        return status;
    }

    // XXXX

    return STATUS_SUCCESS;
}

NTSTATUS
SpSimRemoveStaOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	Uninstalls itself as the opregion handler.  

Arguments:

	SpSim      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS status;
    PIRP irp;

    if (SpSim->StaOpRegion != NULL) {
        status = DeRegisterOpRegionHandler (
            SpSim->AttachedDevice,
            SpSim->StaOpRegion
            );
        SpSim->StaOpRegion = NULL;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
SpSimAccessStaIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PSPSIM_ACCESS_STA access;
    NTSTATUS status;
    ULONG accessType;

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaNames == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SPSIM_ACCESS_STA)) {
        return STATUS_INVALID_PARAMETER;
    }

    access = Irp->AssociatedIrp.SystemBuffer;
    accessType = access->WriteOperation ? ACPI_OPREGION_WRITE :
        ACPI_OPREGION_READ;
    status = SpSimStaOpRegionReadWrite(SpSim,
                                       accessType,
                                       access->Device,
                                       sizeof(UCHAR),
                                       &access->StaValue);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(SPSIM_ACCESS_STA);
    } else {
        Irp->IoStatus.Information = 0;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\method.c ===
#include "spsim.h"
#include "spsimioct.h"

NTSTATUS
SpSimNotifyDeviceIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX input;
    PSPSIM_NOTIFY_DEVICE notify;
    NTSTATUS status;
    ULONG size;

    PAGED_CODE();

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SPSIM_NOTIFY_DEVICE)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaNames == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    notify = Irp->AssociatedIrp.SystemBuffer;

    if ((notify->Device >= SpSim->StaCount) || (notify->Device > 255)) {
        return STATUS_INVALID_PARAMETER;
    }

    size = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
        sizeof(ACPI_METHOD_ARGUMENT) * (2 - ANYSIZE_ARRAY);
    input = ExAllocatePool(PagedPool, size);
    if (input == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(input, size);
    input->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    input->MethodNameAsUlong = SPSIM_NOTIFY_DEVICE_METHOD;
    input->Size = size;
    input->ArgumentCount = 2;
    input->Argument[0].Type = input->Argument[1].Type =
        ACPI_METHOD_ARGUMENT_INTEGER;
    input->Argument[0].DataLength = input->Argument[1].DataLength =
        sizeof(ULONG);
    input->Argument[0].Argument = notify->Device;
    input->Argument[1].Argument = notify->NotifyValue;
    status = SpSimSendIoctl(SpSim->PhysicalDeviceObject,
                            IOCTL_ACPI_EVAL_METHOD,
                            input,
                            size,
                            NULL,
                            0
                            );
    ExFreePool(input);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\tztool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tztool.rc
//
#define IDD_TZDLG                       101
#define IDC_TZTEMP1                     1001
#define IDC_POLLTZ                      1002
#define IDC_FAHR                        1003
#define IDC_TZSELECT                    1004
#define IDC_TZONESEL                    1005
#define IDC_CRTTEMP                     1006
#define IDC_MINTEMP                     1007
#define IDC_TZONEDETAILS                1008
#define IDC_CURTEMP                     1008
#define IDC_TZDETAILS                   1009
#define IDC_TZDETAILS2                  1010
#define IDC_PSVDETAILS                  1011
#define IDC_ACXDETAILS                  1012
#define IDC_THROTTLE                    1013
#define IDC_MINTHROTTLE                 1014
#define IDC_MAXTHROTTLE                 1015
#define IDC_CURTHROTTLE                 1016
#define IDC_MAXIDLE                     1018
#define IDC_CURIDLE                     1019
#define IDC_COOLINGMODE                 1021
#define IDC_OPTIONS                     -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\spsim.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    local.h

Abstract:

    This header declares the stuctures and function prototypes shared between
    the various modules.

Author:

    Adam Glass

Revision History:

--*/


#if !defined(_SPSIM_H_)
#define _SPSIM_H_

#include <wdm.h>
#include <acpiioct.h>
#include <acpimsft.h>
#include "oprghdlr.h"
#include "debug.h"

//
// --- Constants ---
//

//
// These must be updated if any new PNP or PO irps are added
//

// XXX fix
#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_SURPRISE_REMOVAL
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

//
// Device state flags
//

#define SPSIM_DEVICE_STARTED               0x00000001
#define SPSIM_DEVICE_REMOVED               0x00000002
#define SPSIM_DEVICE_ENUMERATED            0x00000004
#define SPSIM_DEVICE_REMOVE_PENDING        0x00000008 /* DEPRECATED */
#define SPSIM_DEVICE_STOP_PENDING          0x00000010 /* DEPRECATED */
#define SPSIM_DEVICE_DELETED               0x00000080
#define SPSIM_DEVICE_SURPRISE_REMOVED      0x00000100

//
// --- Type definitions ---
//

typedef
NTSTATUS
(*PSPSIM_DISPATCH)(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

typedef struct {
    ULONG Addr;
    ULONG Length;
} MEM_REGION_DESCRIPTOR, *PMEM_REGION_DESCRIPTOR;
    
typedef struct  {

    //
    // Flags to indicate the device's current state (use SPSIM_DEVICE_*)
    //
    ULONG DeviceState;

    //
    // The power state of the device
    //
    DEVICE_POWER_STATE PowerState;
    DEVICE_POWER_STATE DeviceStateMapping[PowerSystemMaximum];

    //
    // Backpointer to the device object of whom we are the extension
    //
    PDEVICE_OBJECT Self;

    //
    // The PDO for the multi-function device
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // The next device in the stack who we should send our IRPs down to
    //
    PDEVICE_OBJECT AttachedDevice;

    PVOID StaOpRegion;
    ULONG StaCount;
    ACPI_EVAL_OUTPUT_BUFFER *StaNames;
    PUCHAR StaOpRegionValues;

    PVOID MemOpRegion;
    ULONG MemCount;
    PMEM_REGION_DESCRIPTOR MemOpRegionValues;

    UNICODE_STRING SymbolicLinkName;

    //
    // Remove lock.  Used to prevent the FDO from being removed while
    // other operations are digging around in the extension.
    //

    IO_REMOVE_LOCK RemoveLock;

} SPSIM_EXTENSION, *PSPSIM_EXTENSION;


//
// --- Globals ---
//

extern PDRIVER_OBJECT SpSimDriverObject;

NTSTATUS
SpSimCreateFdo(
    PDEVICE_OBJECT *Fdo
    );

NTSTATUS
SpSimDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPSIM_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
SpSimDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPSIM_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );


NTSTATUS
SpSimAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
SpSimDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS                           
SpSimDevControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimInstallStaOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimRemoveStaOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimInstallMemOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimRemoveMemOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    );

#define SPSIM_STA_NAMES_METHOD (ULONG)'MANS'
#define SPSIM_NOTIFY_DEVICE_METHOD (ULONG)'DFON'

NTSTATUS
SpSimCreateStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

VOID
SpSimDeleteStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimCreateMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

VOID
SpSimDeleteMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSTATUS
EXPORT
SpSimStaOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
SpSimOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimGetManagedDevicesIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimAccessStaIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimGetDeviceName(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimNotifyDeviceIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimPassIrp(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

#define STA_OPREGION 0x99
#define MEM_OPREGION 0x9A
#define MAX_MEMORY_OBJ 8
#define MAX_MEMORY_DESC_PER_OBJ 1

#define MIN_LARGE_DESC 32*1024*1024

#endif // !defined(_SPSIM_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\spsim\driver\memory.c ===
#include "spsim.h"

#define rgzMultiFunctionAdapter L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"
#define rgzAcpiConfigurationData L"Configuration Data"
#define rgzAcpiIdentifier L"Identifier"
#define rgzBIOSIdentifier L"ACPI BIOS"

typedef struct {
    ULONGLONG         Base;
    ULONGLONG         Length;
    ULONGLONG         Type;
} ACPI_E820_ENTRY, *PACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONGLONG           Count;
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE, *PACPI_BIOS_MULTI_NODE;

typedef enum {
    AcpiAddressRangeMemory = 1,
    AcpiAddressRangeReserved,
    AcpiAddressRangeACPI,
    AcpiAddressRangeNVS,
    AcpiAddressRangeMaximum,
} ACPI_BIOS_E820_TYPE, *PACPI_BIOS_E820_TYPE;

NTSTATUS
SpSimGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool(NonPagedPool,
                                keyValueLength);
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}
// insert pragmas here

NTSTATUS
SpSimRetrieveE820Data(
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com.

Arguments:

   AcpiMulti - ...

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    UNICODE_STRING unicodeString, unicodeValueName, biosId;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus;
    WCHAR wbuffer[10];
    ULONG i, length;
    PWSTR p;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    NTSTATUS status;
    BOOLEAN same;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;

    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        DbgPrint("AcpiBios:Can not open MultifunctionAdapter registry key.\n");
        return status;
    }

    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString(&biosId, rgzBIOSIdentifier);

    for (i = 0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            DbgPrint("AcpiBios: ACPI BIOS MultifunctionAdapter registry key not found.\n");
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //

        status = SpSimGetRegistryValue (hBus, rgzAcpiIdentifier, &valueInfo);
        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //

        while (length) {
            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {
                length -= 2;
            } else {
                break;
            }
        }

        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString(&biosId, &unicodeValueName, TRUE);
        ExFreePool(valueInfo);
        if (!same) {
            ZwClose (hBus);
            continue;
        }

        status = SpSimGetRegistryValue(hBus, rgzAcpiConfigurationData, &valueInfo);
        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


        break;
    }

    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                        ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

    *AcpiMulti = (PACPI_BIOS_MULTI_NODE)
                   ExAllocatePool(NonPagedPool,
                                  multiNodeSize);
    if (*AcpiMulti == NULL) {
        ExFreePool(valueInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);

    ExFreePool(valueInfo);
    return STATUS_SUCCESS;
}

VOID
SpSimFillMemoryDescs(
    PACPI_BIOS_MULTI_NODE E820Data,
    ULONGLONG memUnit,
    PMEM_REGION_DESCRIPTOR MemRegions
    )
{
    ULONG i, descCount;

#undef min
#define min(a,b) (a < b ? a : b)

    descCount = 0;
    for (i = 0; i < E820Data->Count; i++) {
        if (E820Data->E820Entry[i].Type != AcpiAddressRangeMemory) {
            continue;
        }
        if (E820Data->E820Entry[i].Length > memUnit) {
            ULONGLONG remains, base, extra;
            
            extra = E820Data->E820Entry[i].Length & (PAGE_SIZE - 1);
            remains = E820Data->E820Entry[i].Length - extra;
            base = (E820Data->E820Entry[i].Base + (PAGE_SIZE - 1)) &
                ~(PAGE_SIZE - 1);

            while (remains) {
                MemRegions[descCount].Addr = (ULONG) base;
                MemRegions[descCount].Length = (ULONG) min(remains, memUnit);
                descCount++;
                base += min(remains, memUnit);
                remains -= min(remains, memUnit);
            }
        } else {
            MemRegions[descCount].Addr = (ULONG) E820Data->E820Entry[i].Base;
            MemRegions[descCount].Length = (ULONG) E820Data->E820Entry[i].Length;

            descCount++;
        }
    }
}
ULONG
SpSimCalculateMemoryDescCount(
    PACPI_BIOS_MULTI_NODE E820Data,
    ULONGLONG memUnit
    )
{
    ULONG i, descCount;

    descCount = 0;
    for (i = 0; i < E820Data->Count; i++) {
        if (E820Data->E820Entry[i].Type != AcpiAddressRangeMemory) {
            continue;
        }
        ASSERT((0xFFFFFFFF00000000 & E820Data->E820Entry[i].Base) == 0);

        if (E820Data->E820Entry[i].Length > memUnit) {
            
            descCount += (ULONG) (E820Data->E820Entry[i].Length / memUnit);
            if ((E820Data->E820Entry[i].Length % memUnit) != 0) {
                descCount++;
            }
        } else {
            descCount++;
        }
    }
    return descCount;
}


NTSTATUS
SpSimCreateMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
{
    PACPI_BIOS_MULTI_NODE E820Data;
    ULONG i, descCount, memUnit = MIN_LARGE_DESC;
    NTSTATUS status;

    status = SpSimRetrieveE820Data(&E820Data);
    if (!NT_SUCCESS(status)) {
        SpSim->MemOpRegionValues = NULL;
        return status;
    }

    ASSERT(E820Data);

    descCount = descCount = SpSimCalculateMemoryDescCount(E820Data, memUnit);
    while (descCount > (MAX_MEMORY_OBJ * MAX_MEMORY_DESC_PER_OBJ)) {
        memUnit = memUnit << 1;
        descCount = SpSimCalculateMemoryDescCount(E820Data, memUnit);
    }

    SpSim->MemOpRegionValues =
        ExAllocatePool(NonPagedPool,
                       sizeof(MEM_REGION_DESCRIPTOR) * descCount);
    if (SpSim->MemOpRegionValues == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto out;
    }
    RtlZeroMemory(SpSim->MemOpRegionValues,
                  sizeof(MEM_REGION_DESCRIPTOR) * descCount);

    SpSimFillMemoryDescs(E820Data, memUnit, SpSim->MemOpRegionValues);

    SpSim->MemCount = descCount;

 out:
    ExFreePool(E820Data);
    if (!NT_SUCCESS(status)) {
        if (SpSim->MemOpRegionValues) {
            ExFreePool(SpSim->MemOpRegionValues);
            SpSim->MemOpRegionValues = NULL;
        }
        SpSim->MemCount = 0;
    }
    return status;
}

VOID
SpSimDeleteMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
{
    if (SpSim->MemOpRegionValues) {
        ExFreePool(SpSim->MemOpRegionValues);
        SpSim->MemOpRegionValues = NULL;
    }
}

NTSTATUS
SpSimMemOpRegionReadWrite(
    PSPSIM_EXTENSION SpSim,
    ULONG AccessType,
    ULONG Offset,
    ULONG Size,
    PUCHAR Data
    )
{
    ULONG i, limit;
    PUCHAR current;

    ASSERT((Offset & 3) == 0);
    ASSERT((Size & 3) == 0);

    if (SpSim->MemOpRegionValues == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    limit = sizeof(MEM_REGION_DESCRIPTOR)*SpSim->MemCount;

    // We're going to define this op region to return all zeros if you
    // access beyond that which we've been able to initialize using
    // the E820 data.

    if (Offset >= limit) {
        RtlZeroMemory(Data, Size);
        return STATUS_SUCCESS;
    }

    if (Offset + Size > limit) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(Offset < limit);

    /// XXX if the asserts hold then this should get fixed.

    current = ((PUCHAR) (SpSim->MemOpRegionValues)) + Offset;

    if (AccessType & ACPI_OPREGION_WRITE) {
        for (i = 0 ; i < Size; i++) {
            *current++ = *Data++;
        }
    } else {
        for (i = 0 ; i < Size; i++) {
            *Data++ = *current++;
        }
    }
    return STATUS_SUCCESS;
}
    

NTSTATUS
EXPORT
SpSimMemOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

	 This routine handles requests to service the 
	 SPSIM operation region contained within this driver

Arguments:

	 AccessType          - Read or Write data
	 OpRegion            - Operation region object
	 Address             - Address within the EC address space
	 Size                - Number of bytes to transfer
	 Data                - Data buffer to transfer to/from
	 Context             - SpSim
	 CompletionHandler   - AMLI handler to call when operation is complete
	 CompletionContext   - Context to pass to the AMLI handler

Return Value:

	 Status

--*/
{
    NTSTATUS status;

    status = SpSimMemOpRegionReadWrite((PSPSIM_EXTENSION) Context,
                                       AccessType,
                                       Address,
                                       Size,
                                       (PUCHAR)Data);
    return status;
}
NTSTATUS
SpSimInstallMemOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	This calls the ACPI driver to install itself as the op region
	handler for the Mem region.  It also allocates the memory for the
	opregion itself.

Arguments:

	pSpSimData      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS                                status;

    status=RegisterOpRegionHandler (
        SpSim->AttachedDevice,
        ACPI_OPREGION_ACCESS_AS_COOKED,
        MEM_OPREGION,
        SpSimMemOpRegionHandler,
        SpSim,
        0,
        &SpSim->MemOpRegion
        );

    //
    // Check the status code
    //
    if(!NT_SUCCESS(status)) {
        SpSim->MemOpRegion = NULL;
        DbgPrint("Not successful in installing:=%x\n", status);
        return status;
    }

    // XXXX

    return STATUS_SUCCESS;
}

NTSTATUS
SpSimRemoveMemOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	Uninstalls itself as the opregion handler.  

Arguments:

	SpSim      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS status;
    PIRP irp;

    if (SpSim->MemOpRegion != NULL) {
        status = DeRegisterOpRegionHandler (
            SpSim->AttachedDevice,
            SpSim->MemOpRegion
            );
        SpSim->MemOpRegion = NULL;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\tztool\tztool.c ===
/*
TZTool - Thermal Zone Information Tool
tztool.c
This the MAIN TZTool - C file.

Copyright (c) 1999 Microsoft Corporation

Module Name:

   TZTool - TZTool.c

Abstract:

   TZTool - Thermal Zone Information Tool

Author:

   Vincent Geglia (VincentG)

Notes:

Revision History:

    1.2 - (VincentG) Port to Win64

    1.1 - (JVert) add Kelvin to Farenheit conversion.  Add throttling gauge.

    1.0 - Original version


*/

// Includes

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntpoapi.h>
#include <commctrl.h>
#include "resource.h"
#include "wmium.h"

// Definitions

#define THERMAL_ZONE_GUID               {0xa1bc18c0, 0xa7c8, 0x11d1, {0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10} }
#define COOLING_PASSIVE                 0
#define COOLING_ACTIVE                  1
#define COOLING_UPDATE_TZONE            2
#define TIMER_ID                        1
#define TIMER_POLL_INTERVAL             500
#define MAX_ACTIVE_COOLING_LEVELS       10
#define MAX_THERMAL_ZONES               10

#define K_TO_F(_deg_) (((_deg_) - 2731) * 9 / 5 + 320)

GUID ThermalZoneGuid = THERMAL_ZONE_GUID;

// Structures

typedef struct _THERMAL_INFORMATION {
    ULONG           ThermalStamp;
    ULONG           ThermalConstant1;
    ULONG           ThermalConstant2;
    KAFFINITY       Processors;
    ULONG           SamplingPeriod;
    ULONG           CurrentTemperature;
    ULONG           PassiveTripPoint;
    ULONG           CriticalTripPoint;
    UCHAR           ActiveTripPointCount;
    ULONG           ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
} THERMAL_INFORMATION, *PTHERMAL_INFORMATION;

typedef struct _TZONE_INFO {

    THERMAL_INFORMATION ThermalInfo;
    ULONG64 TimeStamp;
    ULONG TZoneIndex;
    UCHAR TZoneName[100];
} TZONE_INFO, *PTZONE_INFO;

// Global variables

PTZONE_INFO g_TZonePtr = 0;
WMIHANDLE   g_WmiHandle;
INT         g_PollTz = 0;
BOOL        g_Fahrenheit = FALSE;

// Function declarations

WINAPI
WinMain (
        IN HINSTANCE hInstance,
        IN HINSTANCE hPrevInstance,
        IN PSTR CmdLine,
        IN INT CmdShow
        );

INT_PTR CALLBACK
TZoneDlgProc (
             IN HWND wnd,
             IN UINT Msg,
             IN WPARAM wParam,
             IN LPARAM lParam
             );

ULONG
UpdateTZoneData (
                IN OUT PTZONE_INFO ReturnedTZoneInfo,
                IN WMIHANDLE *Handle
                );

ULONG64
SystemTimeToUlong (
                  IN LPSYSTEMTIME SysTime
                  );

VOID
SetCoolingMode (
               IN UCHAR Mode
               );

VOID
UpgradePrivileges (
                  VOID
                  );

VOID
UpdateTZoneListBox (
                   IN HANDLE wnd
                   );

VOID
UpdateTZoneDetails (
                   IN HANDLE wnd
                   );

VOID
UpdateTZoneGauge (
                 IN HANDLE wnd
                 );

VOID
UpdateCPUGauge(
    IN HWND hwnd
    );

VOID
UpdateCoolingMode (
							IN HWND hwnd
                   );

/*++

Routine Description:

    Windows application Entry Point

Arguments:

    <standard winmain arguments>

Return Value:

    0 if successful, otherwise error status

--*/

WINAPI
WinMain (
        IN HINSTANCE hInstance,
        IN HINSTANCE hPrevInstance,
        IN PSTR CmdLine,
        IN INT CmdShow
        )

{

    UCHAR text [200];
    INITCOMMONCONTROLSEX CommonCtl;
    TZONE_INFO TZones [MAX_THERMAL_ZONES];
    ULONG status = 0;
    INT64 RetVal = 0;


    // Initialize TZ structures

    ZeroMemory (&TZones, sizeof (TZones));
    g_TZonePtr = (PTZONE_INFO) &TZones;

    // Initialize Common Controls DLL for gauge control

    CommonCtl.dwSize = sizeof (CommonCtl);
    CommonCtl.dwICC = ICC_PROGRESS_CLASS;

    InitCommonControlsEx (&CommonCtl);

    // Open WMI data source for the TZs

    status = WmiOpenBlock ((LPGUID) &ThermalZoneGuid,
                           GENERIC_READ,
                           &g_WmiHandle);

    if (status != ERROR_SUCCESS) {

        sprintf (text,
                 "Unable to open thermal zone GUIDs.  This computer may not be equipped with thermal zones, or may not be in ACPI mode.\nError: %d",
                 status);

        MessageBox (NULL,
                    text,
                    "Fatal Error",
                    MB_ICONERROR | MB_OK);

        return status;
    }

    // In order to change the policies, we need greater access privileges

    UpgradePrivileges ();

    // Show the main dialog box

    DialogBox (hInstance,
               MAKEINTRESOURCE (IDD_TZDLG),
               NULL,
               TZoneDlgProc);

    return 0;
}

/*++

Routine Description:

    Standard Windows Dialog Message Loop

Arguments:

    <standard dialog message loop arguments>

Return Value:

    FALSE if message not handled, TRUE if message handled

--*/

INT_PTR CALLBACK
TZoneDlgProc (
             IN HWND wnd,
             IN UINT Msg,
             IN WPARAM wParam,
             IN LPARAM lParam
             )
{
    ULONG Count = 0;
    INT_PTR RetVal = 0;
    switch (Msg) {

    case WM_TIMER:

        if (g_PollTz) {
            SetCoolingMode (COOLING_UPDATE_TZONE);
        }

        if (UpdateTZoneData (g_TZonePtr, g_WmiHandle)) {
            UpdateCoolingMode (wnd);
            UpdateTZoneDetails (wnd);
            UpdateTZoneGauge (wnd);
        }
        UpdateCPUGauge(wnd);
        return TRUE;

    case WM_INITDIALOG:

        // Fill TZ structure with initial values

        UpdateTZoneData (g_TZonePtr, g_WmiHandle);

        // Initialize all controls

        UpdateTZoneListBox (wnd);
        UpdateTZoneDetails (wnd);
        UpdateTZoneGauge (wnd);
        UpdateCPUGauge(wnd);
        UpdateCoolingMode(wnd);

        // Initialize polling timer

        SetTimer (wnd,
                  TIMER_ID,
                  TIMER_POLL_INTERVAL,
                  NULL);

        // Set gauge colors

        SendDlgItemMessage (wnd,
                            IDC_TZTEMP1,
                            PBM_SETBARCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x0000FF));

        SendDlgItemMessage (wnd,
                            IDC_TZTEMP1,
                            PBM_SETBKCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x000000));

        SendDlgItemMessage (wnd,
                            IDC_THROTTLE,
                            PBM_SETBARCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x0000FF));

        SendDlgItemMessage (wnd,
                            IDC_THROTTLE,
                            PBM_SETBKCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x000000));


        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {


        // Cleanup and exit

        case IDOK:
            KillTimer (wnd, TIMER_ID);
            EndDialog (wnd, 0);
            return TRUE;

            // Check to see if user selected a new TZ

        case IDC_TZSELECT:
            if (HIWORD (wParam) == CBN_SELCHANGE) {
                UpdateTZoneDetails (wnd);
                UpdateTZoneGauge (wnd);
                return TRUE;
            }
            break;

        case IDC_POLLTZ:

            // Check to see if user changed the TZ Polling setting

            if (HIWORD (wParam) == BN_CLICKED) {

                RetVal = SendDlgItemMessage (wnd,
                                             IDC_POLLTZ,
                                             BM_GETCHECK,
                                             0,
                                             0);

                if (!g_PollTz && RetVal == BST_CHECKED) {
                    g_PollTz = TRUE;
                }

                if (g_PollTz && RetVal == BST_UNCHECKED) {
                    g_PollTz = FALSE;
                }
            }
            break;

        case IDC_FAHR:

            // Check to see if user changed the Fahrenheit setting

            if (HIWORD(wParam) == BN_CLICKED) {
                RetVal = SendDlgItemMessage(wnd,
                                            IDC_FAHR,
                                            BM_GETCHECK,
                                            0,
                                            0);
                if (!g_Fahrenheit && RetVal == BST_CHECKED) {
                    g_Fahrenheit = TRUE;
                    SetDlgItemText(wnd, IDC_MINTEMP, "37F");
                    UpdateTZoneDetails(wnd);
                    UpdateTZoneGauge(wnd);
                } else if (g_Fahrenheit && RetVal == BST_UNCHECKED) {
                    g_Fahrenheit = FALSE;
                    SetDlgItemText(wnd, IDC_MINTEMP, "276K");
                    UpdateTZoneDetails(wnd);
                    UpdateTZoneGauge(wnd);
                }
            }
            break;


        default:
            break;

        }
        break;


    case WM_CLOSE:
      KillTimer (wnd, TIMER_ID);
      EndDialog (wnd, 0);
      break;
      
    case WM_DESTROY:
      PostQuitMessage(0);
      break;

    
    default:
        break;

    }

    return 0;
}

/*++

Routine Description:

    Issue WMI call to update TZ structures

Arguments:

    ReturnedTZoneInfo - Pointer to array of TZ structures
    Handle - Handle to WMI

Return Value:

    FALSE if no TZs were updated, TRUE if one or more TZs have an update

--*/

ULONG
UpdateTZoneData (
                IN OUT PTZONE_INFO ReturnedTZoneInfo,
                IN WMIHANDLE *Handle
                )
{
    ULONG status = 0;
    ULONG BufferSize = 0;
    PWNODE_ALL_DATA WmiAllData;
    PTHERMAL_INFORMATION ThermalInfo;
    ULONG Offset = 0;
    UCHAR *AllDataBuffer = 0;
    UCHAR *AllDataBufferSave = 0;
    UCHAR *OrigDataBuffer = 0;
    UCHAR *InstanceName = 0;
    ULONG TZCount = 0;
    ULONG Temp = 0;
    SYSTEMTIME SysTime;
    BOOL Updated = FALSE;

    status = WmiQueryAllData (Handle,
                              &BufferSize,
                              0);

    if (status != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    AllDataBuffer = malloc (BufferSize);

    if (!AllDataBuffer) {

        return FALSE;

    }

    //
    // Save original pointer to use with free()
    //
    
    OrigDataBuffer = AllDataBuffer;

    status = WmiQueryAllData (Handle,
                              &BufferSize,
                              AllDataBuffer);

    if (status != ERROR_SUCCESS) {
        free (AllDataBuffer);
        return FALSE;
    }

    // BUG BUG Assuming Thermal GUID only has one instance

    // Save away the buffer pointer as it wll get moved in the following while loop
    AllDataBufferSave = AllDataBuffer;

    while (TZCount < MAX_THERMAL_ZONES) {

        WmiAllData = (PWNODE_ALL_DATA) AllDataBuffer;

        if (WmiAllData->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE) {

            ThermalInfo = (PTHERMAL_INFORMATION) &AllDataBuffer[WmiAllData->DataBlockOffset];
        } else {

            ThermalInfo = (PTHERMAL_INFORMATION) &AllDataBuffer[WmiAllData->OffsetInstanceDataAndLength[0].OffsetInstanceData];
        }

        Offset = (ULONG) AllDataBuffer[WmiAllData->OffsetInstanceNameOffsets];

        InstanceName = (UCHAR *) &AllDataBuffer[Offset + 2];

        // Update TZone structure if timestamp has changed

        if (!ReturnedTZoneInfo[TZCount].TZoneIndex || (ThermalInfo->ThermalStamp != ReturnedTZoneInfo[TZCount].ThermalInfo.ThermalStamp)) {

            strcpy (ReturnedTZoneInfo[TZCount].TZoneName, InstanceName);
            GetSystemTime (&SysTime);
            ReturnedTZoneInfo[TZCount].TimeStamp = SystemTimeToUlong (&SysTime);
            ReturnedTZoneInfo[TZCount].TZoneIndex = TZCount + 1;
            memcpy (&ReturnedTZoneInfo[TZCount].ThermalInfo,
                    ThermalInfo,
                    sizeof (THERMAL_INFORMATION));
            Updated = TRUE;
        }

        if (!WmiAllData->WnodeHeader.Linkage) {

            break;
        }

        AllDataBuffer += WmiAllData->WnodeHeader.Linkage;

        TZCount ++;
    }

    // Restore the buffer pointer to the orginal location
    AllDataBuffer = AllDataBufferSave;

    free (OrigDataBuffer);

    return Updated;
}

/*++

Routine Description:

    Convert a system time structure to a 64bit ULONG

Arguments:

    SysTime - Pointer to system time structure to compare against current time

Return Value:

    Number of elapsed seconds between SysTime and current time

--*/

ULONG64
SystemTimeToUlong (
                  IN LPSYSTEMTIME SysTime
                  )

{
    ULONG64 TimeCount = 0;

    // BUG BUG Doesn't account for leap year

    TimeCount += SysTime->wYear * 31536000;
    TimeCount += SysTime->wMonth * 2628000;
    TimeCount += SysTime->wDay * 86400;
    TimeCount += SysTime->wHour * 3600;
    TimeCount += SysTime->wMinute * 60;
    TimeCount += SysTime->wSecond;

    return TimeCount;
}

/*++

Routine Description:

    Sets the cooling mode to ACTIVE, PASSIVE, or UPDATE ONLY.  This is accomplished by
    changing the FanThrottleTolerance value in the power policy.  Setting it to maxthrottle
    effectively puts the system into PASSIVE cooling mode.  Setting it to 100% will put
    the system in ACTIVE cooling mode UNLESS the current temperature exceeds the passive
    cooling trip points.

Arguments:

    Mode - Value to select the new cooling mode

Return Value:

    None

--*/

VOID
SetCoolingMode (
               IN UCHAR Mode
               )

{
    SYSTEM_POWER_POLICY SysPolicy;
    ULONG Status = 0;
    UCHAR TempFanThrottleTolerance = 0;

    // BUG BUG - This mechanism will currently only for while the machine is on AC.

    Status = NtPowerInformation(
                               SystemPowerPolicyAc,
                               0,
                               0,
                               &SysPolicy,
                               sizeof (SysPolicy)
                               );

    if (Status != ERROR_SUCCESS) {

        return;
    }

    switch (Mode) {

    case COOLING_PASSIVE:
        SysPolicy.FanThrottleTolerance = SysPolicy.MinThrottle;
        break;

    case COOLING_ACTIVE:
        SysPolicy.FanThrottleTolerance = 100;
        break;

    case COOLING_UPDATE_TZONE:
        TempFanThrottleTolerance = SysPolicy.FanThrottleTolerance;
        SysPolicy.FanThrottleTolerance = SysPolicy.FanThrottleTolerance != SysPolicy.MinThrottle ? SysPolicy.MinThrottle : 100;
        break;

    default:
        return;
    }

    Status = NtPowerInformation(
                               SystemPowerPolicyAc,
                               &SysPolicy,
                               sizeof (SysPolicy),
                               &SysPolicy,
                               sizeof (SysPolicy)
                               );

    if (Status != ERROR_SUCCESS) {

        return;
    }

    if (Mode == COOLING_UPDATE_TZONE) {

        SysPolicy.FanThrottleTolerance = TempFanThrottleTolerance;

        Status = NtPowerInformation(
                                   SystemPowerPolicyAc,
                                   &SysPolicy,
                                   sizeof (SysPolicy),
                                   &SysPolicy,
                                   sizeof (SysPolicy)
                                   );

        if (Status != ERROR_SUCCESS) {

            return;
        }
    }

}

/*++

Routine Description:

    Upgrades the process's access permission to change system power policy

Arguments:

    None

Return Value:

    None

--*/


VOID
UpgradePrivileges (
                  VOID
                  )
{
    TOKEN_PRIVILEGES tkp;
    HANDLE hToken;

    OpenProcessToken (GetCurrentProcess(),
                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                      &hToken);

    LookupPrivilegeValue (NULL,
                          SE_SHUTDOWN_NAME,
                          &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (hToken,
                           FALSE,
                           &tkp,
                           0,
                           NULL,
                           0);

}

/*++

Routine Description:

    Updates the entries presented in the TZ selection combo box

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/


VOID
UpdateTZoneListBox (
                   IN HANDLE wnd
                   )

{
    ULONG Count = 0;

    // Reset the contents

    SendDlgItemMessage (wnd,
                        IDC_TZSELECT,
                        CB_RESETCONTENT,
                        0,
                        0);

    while (Count < MAX_THERMAL_ZONES) {

        if (g_TZonePtr[Count].TZoneIndex) {

            SendDlgItemMessage (wnd,
                                IDC_TZSELECT,
                                CB_ADDSTRING,
                                0,
                                (LPARAM) g_TZonePtr[Count].TZoneName);
        } else {

            break;
        }

        Count ++;
    }

    // Automatically select first TZone

    SendDlgItemMessage (wnd,
                        IDC_TZSELECT,
                        CB_SETCURSEL,
                        0,
                        0);

}

/*++

Routine Description:

    Updates the details for the currently selected TZ

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/

VOID
UpdateTZoneDetails (
                   IN HANDLE wnd
                   )
{
    UCHAR text[1000], texttmp [1000];
    UCHAR CurrentTZone = 0;
    INT_PTR RetVal = 0;
    UCHAR Count = 0;
    ULONG Fahrenheit;

    RetVal = SendDlgItemMessage (wnd,
                                 IDC_TZSELECT,
                                 CB_GETCURSEL,
                                 0,
                                 0);

    if (RetVal == CB_ERR) {

        return;
    }

    if (g_Fahrenheit) {
        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint);
        sprintf (text,
                 "Passive Trip Point:\t%d.%dF\nThermal Constant 1:\t%d\nThermal Constant 2:\t%d",
                 Fahrenheit / 10,
                 Fahrenheit % 10,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant1,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant2);

    } else {
        sprintf (text,
                 "Passive Trip Point:\t%d.%dK\nThermal Constant 1:\t%d\nThermal Constant 2:\t%d",
                 g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint / 10,
                 g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint % 10,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant1,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant2);
    }

    SetDlgItemText (wnd,
                    IDC_PSVDETAILS,
                    text);

    ZeroMemory (&text, sizeof (text));

    while (Count < g_TZonePtr[RetVal].ThermalInfo.ActiveTripPointCount) {
        if (g_Fahrenheit) {
            Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count]);
            sprintf (texttmp,
                     "Active Trip Point #%d:\t%d.%dF\n",
                     Count,
                     Fahrenheit / 10,
                     Fahrenheit % 10);
        } else {
            sprintf (texttmp,
                     "Active Trip Point #%d:\t%d.%dK\n",
                     Count,
                     g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count] / 10,
                     g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count] % 10);
        }

        strcat (text, texttmp);
        Count ++;
    }

    SetDlgItemText (wnd,
                    IDC_ACXDETAILS,
                    text);

}

/*++

Routine Description:

    Updates the progress bar control (temp gauge) for the currently selected TZ

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/

VOID
UpdateTZoneGauge (
                 IN HANDLE wnd
                 )

{
    UCHAR CurrentTZone = 0;
    INT_PTR RetVal = 0;
    UCHAR text[20];
    ULONG Fahrenheit;

    RetVal = SendDlgItemMessage (wnd,
                                 IDC_TZSELECT,
                                 CB_GETCURSEL,
                                 0,
                                 0);

    if (RetVal == CB_ERR) {

        return;
    }

    if (g_Fahrenheit) {

        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint);
        sprintf (text,
                 "%d.%dF",
                 Fahrenheit / 10,
                 Fahrenheit % 10);

    } else {
        sprintf (text,
                 "%d.%dK",
                 g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint / 10,
                 g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint % 10);
    }

    SetDlgItemText (wnd,
                    IDC_CRTTEMP,
                    text);

    if (g_Fahrenheit) {

        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature);
        sprintf (text,
                 "Current: %d.%dF",
                 Fahrenheit / 10,
                 Fahrenheit % 10);

    } else {
        sprintf (text,
                 "Current: %d.%dK",
                 g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature / 10,
                 g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature % 10);

    }
    SetDlgItemText (wnd,
                    IDC_CURTEMP,
                    text);

    SendDlgItemMessage (wnd,
                        IDC_TZTEMP1,
                        PBM_SETRANGE,
                        0,
                        MAKELPARAM(2760, g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint));

    SendDlgItemMessage (wnd,
                        IDC_TZTEMP1,
                        PBM_SETPOS,
                        (INT) g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature,
                        0);
    return;
}


VOID
UpdateCPUGauge(
    IN HWND hwnd
    )
/*++

Routine Description:

    Updates the current CPU throttling gauge

Arguments:

    hwnd - Supplies the parent dialog hwnd

Return Value:

    None

--*/

{
    PROCESSOR_POWER_INFORMATION ProcInfo;
    NTSTATUS Status;
    UCHAR text[40];

    Status = NtPowerInformation(ProcessorInformation,
                                NULL,
                                0,
                                &ProcInfo,
                                sizeof(ProcInfo));
    if (NT_SUCCESS(Status)) {
        sprintf(text, "%d MHz", ProcInfo.MaxMhz);
        SetDlgItemText(hwnd, IDC_MAXTHROTTLE, text);

        sprintf(text,
                "Current %d MHz (%d %%)",
                ProcInfo.CurrentMhz,
                ProcInfo.CurrentMhz*100/ProcInfo.MaxMhz);
        SetDlgItemText(hwnd, IDC_CURTHROTTLE, text);

        //
        // update throttle gauge
        //
        SendDlgItemMessage (hwnd,
                            IDC_THROTTLE,
                            PBM_SETRANGE,
                            0,
                            MAKELPARAM(0, ProcInfo.MaxMhz));

        SendDlgItemMessage (hwnd,
                            IDC_THROTTLE,
                            PBM_SETPOS,
                            (INT) ProcInfo.CurrentMhz,
                            0);

        //
        // update idle information
        //
        sprintf(text, "C%d", ProcInfo.MaxIdleState);
        SetDlgItemText(hwnd, IDC_MAXIDLE, text);

        //
        // BUGBUG John Vert (jvert) 9/16/1999
        // the current idle state reporting ranges from 0-2
        // the max idle state reporting ranges from 1-3
        // probably current is wrong and should be 0-3 representing C0-C3
        // for now add one and don't run this on an MP machine!
        //
        sprintf(text, "C%d", ProcInfo.CurrentIdleState + 1);
        SetDlgItemText(hwnd, IDC_CURIDLE, text);

    }


}

VOID
UpdateCoolingMode ( 	IN HWND hwnd )
{
	SYSTEM_POWER_INFORMATION SystemInformation;
	UCHAR uCoolingMode;
	UCHAR text[50];
	NTSTATUS Status;

	Status = NtPowerInformation(SystemPowerInformation,
										 NULL,
										 0,
										 &SystemInformation,
										 sizeof(SystemInformation));
	uCoolingMode = SystemInformation.CoolingMode;
	// 0 = Active Mode
	// 1 = Passive Mode
	switch (uCoolingMode)
	{
		case 0: 
			SetDlgItemText(hwnd, IDC_COOLINGMODE, "Active");      
			break;

		case 1:
			SetDlgItemText(hwnd, IDC_COOLINGMODE, "Passive");      	
			break;

		default:
			SetDlgItemText(hwnd, IDC_COOLINGMODE, "Error!");      
	}  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\tztool\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\external.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    external.h

Abstract:

    This contains the protypes for the functions which
    are outside of the current library

Author:

    Stephane Plante

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _EXTERNAL_H_
#define _EXTERNAL_H_

    extern
    PVOID
    MEMORY_ALLOCATE(
        ULONG   Num
        );

    extern
    VOID
    MEMORY_COPY(
        PVOID   Dest,
        PVOID   Src,
        ULONG   Length
        );

    extern
    VOID
    MEMORY_FREE(
        PVOID   Dest
        );
    
    extern
    VOID
    MEMORY_SET(
        PVOID   Src,
        UCHAR   Value,
        ULONG   Length
        );

    extern
    VOID
    MEMORY_ZERO(
        PVOID   Src,
        ULONG   Length
        );

    extern
    VOID
    PRINTF(
        PUCHAR  String,
        ...
        );

    extern
    ULONG
    STRING_LENGTH(
        PUCHAR  String
        );

    extern
    VOID
    STRING_PRINT(
        PUCHAR  Buffer,
        PUCHAR  String,
        ...
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\data.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data file for AML

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

//
// Name Space Modifiers
//
UNASM_AMLTERM
    atAlias = {
        "Alias",            OP_ALIAS,       "NN",     TC_NAMESPACE_MODIFIER, OF_NORMAL_OBJECT,                      NULL
        },
    atName = {
        "Name",             OP_NAME,        "NO",     TC_NAMESPACE_MODIFIER, OF_NORMAL_OBJECT,                      NULL
        },
    atScope = {
        "Scope",            OP_SCOPE,       "N",      TC_NAMESPACE_MODIFIER, OF_VARIABLE_LIST,                      FunctionScope
        };

//
// Named Object Creators
//
UNASM_AMLTERM
    atBankField = {
        "BankField",        OP_BANKFIELD,   "NNCB",   TC_NAMED_OBJECT,       OF_VARIABLE_LIST|OF_UNASM_FIELDLIST,   FunctionField
        },
    atDevice = {
        "Device",           OP_DEVICE,      "N",      TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        },
    atEvent = {
        "Event",            OP_EVENT,       "N",      TC_NAMED_OBJECT,       OF_NORMAL_OBJECT,                      NULL
        },
    atField = {
        "Field",            OP_FIELD,       "NB",     TC_NAMED_OBJECT,       OF_VARIABLE_LIST|OF_UNASM_FIELDLIST,   FunctionField
        },
    atIndexField = {
        "IndexField",       OP_IDXFIELD,    "NNB",    TC_NAMED_OBJECT,       OF_VARIABLE_LIST|OF_UNASM_FIELDLIST,   FunctionField
        },
    atMethod = {
        "Method",           OP_METHOD,      "NB",     TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        },
    atMutex = {
        "Mutex",            OP_MUTEX,       "NB",     TC_NAMED_OBJECT,       OF_NORMAL_OBJECT,                      NULL
        },
    atOpRegion = {
        "OperationRegion",  OP_OPREGION,    "NBCC",   TC_NAMED_OBJECT,       OF_NORMAL_OBJECT,                      NULL
        },
    atPowerRes = {
        "PowerResource",    OP_POWERRES,    "NBW",    TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        },
    atProcessor = {
        "Processor",        OP_PROCESSOR,   "NBDB",   TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      NULL
        },
    atThermalZone = {
        "ThermalZone",      OP_THERMALZONE, "N",      TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        };

    //
    // Type 1 Opcodes
    //
UNASM_AMLTERM
    atBreak = {
        "Break",            OP_BREAK,       NULL,     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atBreakPoint = {
        "BreakPoint",       OP_BREAKPOINT,  NULL,     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atBitField = {
        "CreateBitField",   OP_BITFIELD,    "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atByteField = {
        "CreateByteField",  OP_BYTEFIELD,   "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atDWordField = {
        "CreateDWordField", OP_DWORDFIELD,  "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atCreateField = {
        "CreateField",      OP_CREATEFIELD, "CCCN",   TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atWordField = {
        "CreateWordField",  OP_WORDFIELD,   "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atCondRefOf = {
        "CondRefOf",        OP_CONDREFOF,   "SS",     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atElse = {
        "Else",             OP_ELSE,        NULL,     TC_OPCODE_TYPE1,       OF_VARIABLE_LIST|OF_PROCESS_UNASM,     FunctionScope
        },
    atFatal = {
        "Fatal",            OP_FATAL,       "BDC",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atIf = {
        "If",               OP_IF,          "C",      TC_OPCODE_TYPE1,       OF_VARIABLE_LIST|OF_PROCESS_UNASM,     FunctionScope
        },
    atLoad = {
        "Load",             OP_LOAD,        "NS",     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atNOP = {
        "NoOp",             OP_NOP,         NULL,     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atNotify = {
        "Notify",           OP_NOTIFY,      "SC",     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atRelease = {
        "Release",          OP_RELEASE,     "S",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atReset = {
        "Reset",            OP_RESET,       "S",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atReturn = {
        "Return",           OP_RETURN,      "C",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atSignal = {
        "Signal",           OP_SIGNAL,      "S",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atSleep = {
        "Sleep",            OP_SLEEP,       "C",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atStall = {
        "Stall",            OP_STALL,       "C",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atUnload = {
        "Unload",           OP_UNLOAD,      "N",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atWhile = {
        "While",            OP_WHILE,       "C",      TC_OPCODE_TYPE1,       OF_VARIABLE_LIST,                      FunctionScope
        };

    //
    // Type 2 Opcodes
    //
UNASM_AMLTERM
    atAcquire = {
        "Acquire",          OP_ACQUIRE,     "SW",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atAdd = {
        "Add",              OP_ADD,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atAnd = {
        "And",              OP_AND,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atConcat = {
        "Concatenate",      OP_CONCAT,      "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atDecrement = {
        "Decrement",        OP_DECREMENT,   "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atDerefOf = {
        "DerefOf",          OP_DEREFOF,     "C",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atDivide = {
        "Divide",           OP_DIVIDE,      "CCSS",   TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atFindSetLBit = {
        "FindSetLeftBit",   OP_FINDSETLBIT, "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atFindSetRBit = {
        "FindSetRightBit",  OP_FINDSETRBIT, "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atFromBCD = {
        "FromBCD",          OP_FROMBCD,     "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atIncrement = {
        "Increment",        OP_INCREMENT,   "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atIndex = {
        "Index",            OP_INDEX,       "CCS",    TC_OPCODE_TYPE2,       OF_REF_OBJECT,                         NULL
        },
    atLAnd = {
        "LAnd",             OP_LAND,        "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLEq = {
        "LEqual",           OP_LEQ,         "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLG = {
        "LGreater",         OP_LG,          "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLL = {
        "LLess",            OP_LL,          "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLNot = {
        "LNot",             OP_LNOT,        "C",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLOr = {
        "LOr",              OP_LOR,         "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atMatch = {
        "Match",            OP_MATCH,       "CCCCCC", TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atMultiply = {
        "Multiply",         OP_MULTIPLY,    "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atNAnd = {
        "NAnd",             OP_NAND,        "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atNOr = {
        "NOr",              OP_NOR,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atNot = {
        "Not",              OP_NOT,         "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atObjType = {
        "ObjectType",       OP_OBJTYPE,     "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atOr = {
        "Or",               OP_OR,          "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atRefOf = {
        "RefOf",            OP_REFOF,       "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atShiftLeft = {
        "ShiftLeft",        OP_SHIFTL,      "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atShiftRight = {
        "ShiftRight",       OP_SHIFTR,      "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atSizeOf = {
        "SizeOf",           OP_SIZEOF,      "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atStore = {
        "Store",            OP_STORE,       "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atSubtract = {
        "Subtract",         OP_SUBTRACT,    "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atToBCD = {
        "ToBCD",            OP_TOBCD,       "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atWait = {
        "Wait",             OP_WAIT,        "SC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atXOr = {
        "XOr",              OP_XOR,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        };

    //
    // Misc. Opcodes
    //
UNASM_AMLTERM
    atNameObj = {
        "NameObj",          OP_NONE,        NULL,     TC_OTHER,              OF_NAME_OBJECT,                        NULL
        },
    atDataObj = {
        "DataObj",          OP_NONE,        NULL,     TC_OTHER,              OF_DATA_OBJECT,                        NULL
        },
    atConstObj = {
        "ConstObj",         OP_NONE,        NULL,     TC_OTHER,              OF_CONST_OBJECT,                       NULL
        },
    atArgObj = {
        "ArgObj",           OP_NONE,        NULL,     TC_OTHER,              OF_ARG_OBJECT,                         NULL
        },
    atLocalObj = {
        "LocalObj",         OP_NONE,        NULL,     TC_OTHER,              OF_LOCAL_OBJECT,                       NULL
        },
    atDebugObj = {
        "Debug",            OP_DEBUG,       NULL,     TC_OTHER,              OF_DEBUG_OBJECT,                       NULL
        };

PUNASM_AMLTERM OpcodeTable[256] =
{ //0x00                0x01                0x02                0x03
    &atConstObj,        &atConstObj,        NULL,               NULL,
  //0x04                0x05                0x06                0x07
    NULL,               NULL,               &atAlias,           NULL,
  //0x08                0x09                0x0a                0x0b
    &atName,            NULL,               &atDataObj,         &atDataObj,
  //0x0c                0x0d                0x0e                0x0f
    &atDataObj,         &atDataObj,         NULL,               NULL,
  //0x10                0x11                0x12                0x13
    &atScope,           &atDataObj,         &atDataObj,         NULL,
  //0x14                0x15                0x16                0x17
    &atMethod,          NULL,               NULL,               NULL,
  //0x18                0x19                0x1a                0x1b
    NULL,               NULL,               NULL,               NULL,
  //0x1c                0x1d                0x1e                0x1f
    NULL,               NULL,               NULL,               NULL,
  //0x20                0x21                0x22                0x23
    NULL,               NULL,               NULL,               NULL,
  //0x24                0x25                0x26                0x27
    NULL,               NULL,               NULL,               NULL,
  //0x28                0x29                0x2a                0x2b
    NULL,               NULL,               NULL,               NULL,
  //0x2c                0x2d                0x2e                0x2f
    NULL,               NULL,               &atNameObj,         &atNameObj,
  //0x30                0x31                0x32                0x33
    NULL,               NULL,               NULL,               NULL,
  //0x34                0x35                0x36                0x37
    NULL,               NULL,               NULL,               NULL,
  //0x38                0x39                0x3a                0x3b
    NULL,               NULL,               NULL,               NULL,
  //0x3c                0x3d                0x3e                0x3f
    NULL,               NULL,               NULL,               NULL,
  //0x40                0x41                0x42                0x43
    NULL,               &atNameObj,         &atNameObj,         &atNameObj,
  //0x44                0x45                0x46                0x47
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x48                0x49                0x4a                0x4b
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x4c                0x4d                0x4e                0x4f
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x50                0x51                0x52                0x53
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x54                0x55                0x56                0x57
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x58                0x59                0x5a                0x5b
    &atNameObj,         &atNameObj,         &atNameObj,         NULL,
  //0x5c                0x5d                0x5e                0x5f
    &atNameObj,         NULL,               &atNameObj,         &atNameObj,
  //0x60                0x61                0x62                0x63
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x64                0x65                0x66                0x67
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x68                0x69                0x6a                0x6b
    &atArgObj,          &atArgObj,          &atArgObj,          &atArgObj,
  //0x6c                0x6d                0x6e                0x6f
    &atArgObj,          &atArgObj,          &atArgObj,          NULL,
  //0x70                0x71                0x72                0x73
    &atStore,           &atRefOf,           &atAdd,             &atConcat,
  //0x74                0x75                0x76                0x77
    &atSubtract,        &atIncrement,       &atDecrement,       &atMultiply,
  //0x78                0x79                0x7a                0x7b
    &atDivide,          &atShiftLeft,       &atShiftRight,      &atAnd,
  //0x7c                0x7d                0x7e                0x7f
    &atNAnd,            &atOr,              &atNOr,             &atXOr,
  //0x80                0x81                0x82                0x83
    &atNot,             &atFindSetLBit,     &atFindSetRBit,     &atDerefOf,
  //0x84                0x85                0x86                0x87
    NULL,               NULL,               &atNotify,          &atSizeOf,
  //0x88                0x89                0x8a                0x8b
    &atIndex,           &atMatch,           &atDWordField,      &atWordField,
  //0x8c                0x8d                0x8e                0x8f
    &atByteField,       &atBitField,        &atObjType,         NULL,
  //0x90                0x91                0x92                0x93
    &atLAnd,            &atLOr,             &atLNot,            &atLEq,
  //0x94                0x95                0x96                0x97
    &atLG,              &atLL,              NULL,               NULL,
  //0x98                0x99                0x9a                0x9b
    NULL,               NULL,               NULL,               NULL,
  //0x9c                0x9d                0x9e                0x9f
    NULL,               NULL,               NULL,               NULL,
  //0xa0                0xa1                0xa2                0xa3
    &atIf,              &atElse,            &atWhile,           &atNOP,
  //0xa4                0xa5                0xa6                0xa7
    &atReturn,          &atBreak,           NULL,               NULL,
  //0xa8                0xa9                0xaa                0xab
    NULL,               NULL,               NULL,               NULL,
  //0xac                0xad                0xae                0xaf
    NULL,               NULL,               NULL,               NULL,
  //0xb0                0xb1                0xb2                0xb3
    NULL,               NULL,               NULL,               NULL,
  //0xb4                0xb5                0xb6                0xb7
    NULL,               NULL,               NULL,               NULL,
  //0xb8                0xb9                0xba                0xbb
    NULL,               NULL,               NULL,               NULL,
  //0xbc                0xbd                0xbe                0xbf
    NULL,               NULL,               NULL,               NULL,
  //0xc0                0xc1                0xc2                0xc3
    NULL,               NULL,               NULL,               NULL,
  //0xc4                0xc5                0xc6                0xc7
    NULL,               NULL,               NULL,               NULL,
  //0xc8                0xc9                0xca                0xcb
    NULL,               NULL,               NULL,               NULL,
  //0xcc                0xcd                0xce                0xcf
    &atBreakPoint,      NULL,               NULL,               NULL,
  //0xd0                0xd1                0xd2                0xd3
    NULL,               NULL,               NULL,               NULL,
  //0xd4                0xd5                0xd6                0xd7
    NULL,               NULL,               NULL,               NULL,
  //0xd8                0xd9                0xda                0xdb
    NULL,               NULL,               NULL,               NULL,
  //0xdc                0xdd                0xde                0xdf
    NULL,               NULL,               NULL,               NULL,
  //0xe0                0xe1                0xe2                0xe3
    NULL,               NULL,               NULL,               NULL,
  //0xe4                0xe5                0xe6                0xe7
    NULL,               NULL,               NULL,               NULL,
  //0xe8                0xe9                0xea                0xeb
    NULL,               NULL,               NULL,               NULL,
  //0xec                0xed                0xee                0xef
    NULL,               NULL,               NULL,               NULL,
  //0xf0                0xf1                0xf2                0xf3
    NULL,               NULL,               NULL,               NULL,
  //0xf4                0xf5                0xf6                0xf7
    NULL,               NULL,               NULL,               NULL,
  //0xf8                0xf9                0xfa                0xfb
    NULL,               NULL,               NULL,               NULL,
  //0xfc                0xfd                0xfe                0xff
    NULL,               NULL,               NULL,               &atConstObj
};

UNASM_OPCODEMAP ExOpcodeTable[] =
{
    EXOP_MUTEX,         &atMutex,
    EXOP_EVENT,         &atEvent,
    EXOP_CONDREFOF,     &atCondRefOf,
    EXOP_CREATEFIELD,   &atCreateField,
    EXOP_LOAD,          &atLoad,
    EXOP_STALL,         &atStall,
    EXOP_SLEEP,         &atSleep,
    EXOP_ACQUIRE,       &atAcquire,
    EXOP_SIGNAL,        &atSignal,
    EXOP_WAIT,          &atWait,
    EXOP_RESET,         &atReset,
    EXOP_RELEASE,       &atRelease,
    EXOP_FROMBCD,       &atFromBCD,
    EXOP_TOBCD,         &atToBCD,
    EXOP_UNLOAD,        &atUnload,
    EXOP_REVISION,      &atConstObj,
    EXOP_DEBUG,         &atDebugObj,
    EXOP_FATAL,         &atFatal,
    EXOP_OPREGION,      &atOpRegion,
    EXOP_FIELD,         &atField,
    EXOP_DEVICE,        &atDevice,
    EXOP_PROCESSOR,     &atProcessor,
    EXOP_POWERRES,      &atPowerRes,
    EXOP_THERMALZONE,   &atThermalZone,
    EXOP_IDXFIELD,      &atIndexField,
    EXOP_BANKFIELD,     &atBankField,
    0,                  NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\data.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.h

Abstract:

    Data file for AML

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _DATA_H_
#define _DATA_H_

    #define STACK_GROWTH_RATE   8
    #define STACK_SIGNATURE     '_SGP'

    #define STRING_GROWTH_RATE  32
    #define STRING_SIGNATURE    ')SGP'

    //
    // This is the size of an individual name segment
    //
    #define NAMESEG  ULONG

    //
    // This is for the ArgumentType Table
    //
    #define ARGTYPE_NAME            'N'
    #define ARGTYPE_DATAOBJECT      'O'
    #define ARGTYPE_DWORD           'D'
    #define ARGTYPE_WORD            'W'
    #define ARGTYPE_BYTE            'B'
    #define ARGTYPE_SUPERNAME       'S'
    #define ARGTYPE_OPCODE          'C'

    //
    // This is for the term group table
    //
    #define TC_NAMESPACE_MODIFIER   0x01
    #define TC_NAMED_OBJECT         0x02
    #define TC_OPCODE_TYPE1         0x03
    #define TC_OPCODE_TYPE2         0x04
    #define TC_OTHER                0x05

    //
    // Opcode Flag table
    //
    #define OF_NORMAL_OBJECT        0x00000000
    #define OF_VARIABLE_LIST        0x00000001
    #define OF_ARG_OBJECT           0x00000002
    #define OF_LOCAL_OBJECT         0x00000003
    #define OF_CONST_OBJECT         0x00000004
    #define OF_NAME_OBJECT          0x00000005
    #define OF_DATA_OBJECT          0x00000006
    #define OF_DEBUG_OBJECT         0x00000007
    #define OF_REF_OBJECT           0x00000008
    #define OF_PROCESS_UNASM        0x00000000
    #define OF_UNASM_FIELDLIST      0x00000000

    //
    // Scope Flags
    //
    #define SC_FLAG_NESTED          0x00000001

    //
    // These are the various values allowed for the states
    //
    #define SC_FUNCTION_HANDLER         0x00
    #define SC_PARSE_ARGUMENT           0x01
    #define SC_PARSE_ARGUMENT_OBJECT    0x02
    #define SC_PARSE_BUFFER             0x03
    #define SC_PARSE_BYTE               0x04
    #define SC_PARSE_CODE_OBJECT        0x05
    #define SC_PARSE_CONST_OBJECT       0x06
    #define SC_PARSE_DATA               0x07
    #define SC_PARSE_DELIMITER          0x08
    #define SC_PARSE_DWORD              0x09
    #define SC_PARSE_FIELD              0x0A
    #define SC_PARSE_LOCAL_OBJECT       0x0B
    #define SC_PARSE_NAME               0x0C
    #define SC_PARSE_NAME_OBJECT        0x0D
    #define SC_PARSE_OPCODE             0x0E
    #define SC_PARSE_PACKAGE            0x0F
    #define SC_PARSE_POP                0x10
    #define SC_PARSE_PUSH               0x11
    #define SC_PARSE_SUPER_NAME         0x12
    #define SC_PARSE_TRAILING_ARGUMENT  0x13
    #define SC_PARSE_TRAILING_BUFFER    0x14
    #define SC_PARSE_TRAILING_PACKAGE   0x15
    #define SC_PARSE_VARIABLE_OBJECT    0x16
    #define SC_PARSE_WORD               0x17
    #define SC_MAX_TABLE                0x18


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\function.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    function.h

Abstract:

    Functions which are OpCode specific

Author:

    Stephane Plante

Environment:


    Any

Revision History:

--*/

#ifndef _FUNCTION_H_
#define _FUNCTION_H_

    NTSTATUS
    FunctionField(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    FunctionScope(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    FunctionTest(
        IN  PSTACK  *Stack
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\parser.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parser.c

Abstract:

    The aml parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

//
// This is a dispatch table
//
typedef NTSTATUS (*PARSE_STATE_FUNCTION) (PSTACK *Stack);
PARSE_STATE_FUNCTION ScopeStates[] = {
    ParseFunctionHandler,
    ParseArgument,
    ParseArgumentObject,
    ParseBuffer,
    ParseByte,
    ParseCodeObject,
    ParseConstObject,
    ParseData,
    ParseDelimiter,
    ParseDWord,
    ParseField,
    ParseLocalObject,
    ParseName,
    ParseNameObject,
    ParseOpcode,
    ParsePackage,
    ParsePop,
    ParsePush,
    ParseSuperName,
    ParseTrailingArgument,
    ParseTrailingBuffer,
    ParseTrailingPackage,
    ParseVariableObject,
    ParseWord
    };

NTSTATUS
ParseArgument(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine parses the arguments to a function

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_AMLTERM        amlTerm;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Get the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Check to see if we still need to process arguments?
    //
    amlTerm = localScope->AmlTerm;
    if ( localScope->Context1 == 0) {

        UCHAR   actionList[2] = {
                    SC_PARSE_ARGUMENT,
                    SC_PARSE_DELIMITER
                    };
        ULONG   i;

        //
        // Step 2.1.1: Push an opening "(" onto the stack
        //
        StringStackPush( &(rootScope->StringStack), 1, "(" );

        //
        // Step 2.1.2: Make sure to call the thing to handle the trailing
        // argument
        //
        action = SC_PARSE_TRAILING_ARGUMENT;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

        //
        // Step 2.1.3: This is the first that we have seen of the argument
        // Determine the number of bytes to process
        //
        localScope->Context2 = STRING_LENGTH( amlTerm->ArgumentTypes );

        //
        // Step 2.1.4: Setup the stack with the appropriate number of
        // calls to this function.
        //
        if (localScope->Context2 >= 2) {

            for (i = 0; i < localScope->Context2 - 1; i++) {

                StringStackPush( &(rootScope->ParseStack), 2, actionList );

            }

        }

    } else if ( localScope->Context1 >= localScope->Context2 ) {

        //
        // Step 2.2.1: BAD!!
        //
        return STATUS_UNSUCCESSFUL;

    }

    //
    // Step 3: Handle the current argument
    //
    switch( amlTerm->ArgumentTypes[ localScope->Context1 ] ) {
    case ARGTYPE_NAME:

        action = SC_PARSE_NAME;
        break;

    case ARGTYPE_DATAOBJECT:

        action = SC_PARSE_DATA;
        break;

    case ARGTYPE_WORD:

        action = SC_PARSE_WORD;
        break;

    case ARGTYPE_DWORD:

        action = SC_PARSE_DWORD;
        break;

    case ARGTYPE_BYTE:

        action = SC_PARSE_BYTE;
        break;

    case ARGTYPE_SUPERNAME:

        action = SC_PARSE_SUPER_NAME;
        break;

    case ARGTYPE_OPCODE: {

        UCHAR   actionList[2] = {
            SC_PARSE_POP,
            SC_PARSE_OPCODE
        };

        //
        // Step 3.1: Increment the argument count
        //
        localScope->Context1++;

        //
        // Step 3.2: Set up what wee need next
        //
        StringStackPush( &(rootScope->ParseStack), 2, actionList );

        //
        // Step 3.3: Push a new scope
        //
        status = ParsePush( Stack );
        if (!NT_SUCCESS(status) ) {

            return status;

        }

        //
        // Step 3.4: Make sure to note that we are now nesting things
        //
        status = StackTop( Stack, &localScope );
        if (!NT_SUCCESS( status ) ) {

            return status;

        }
        localScope->Flags |= SC_FLAG_NESTED;

        //
        // Step 3.5: Done
        //
        return STATUS_SUCCESS;

    }
    default:

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 4: Push the action onto the stack and setup for the next call
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );
    localScope->Context1++;

    //
    // Step 5: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseArgumentObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This parses and executes the ArgX instruction

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    CHAR            i;
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;
    UCHAR           buffer[5];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Find the string stack to use
    //
    stringStack = &(rootScope->StringStack);

    //
    // Step 3: Determine which argument we are looking at
    //
    i = *(localScope->CurrentByte) - OP_ARG0;
    if (i < 0 || i > 7) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 4: Show the argument number to the user
    //
    STRING_PRINT( buffer, "Arg%1d", i );
    StringStackPush( stringStack, 4, buffer );

    //
    // Step 5: Setup for next state
    //
    localScope->CurrentByte++;

    //
    // Step 6: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseBuffer(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles buffers

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS;

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       actionList[2] = { SC_PARSE_BYTE, SC_PARSE_TRAILING_BUFFER };
    ULONG       numBytes;
    ULONG       i;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Determine the number of bytes that we have
    //
    numBytes = localScope->LastByte - localScope->CurrentByte + 1;
    if (numBytes) {

        //
        // Step 3: Push the leading delimiter
        //
        StringStackPush( &(rootScope->StringStack), 2, " {" );

        //
        // Step 4: This handles the last byte in the stream. We assume that
        // we have at least one byte otherwise we would not be here
        //
        StringStackPush( &(rootScope->ParseStack), 1, &(actionList[1]) );

        //
        // Make sure that we process the right number of bytes
        //
        actionList[1] = SC_PARSE_DELIMITER;
        if (numBytes > 1) {

            for (i = 0; i < numBytes - 1; i++) {

                StringStackPush( &(rootScope->ParseStack), 2, actionList );

            }

        }
        StringStackPush( &(rootScope->ParseStack),1, actionList );

    }

    //
    // Step 4: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseByte(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles bytes

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           localBuffer[6];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Build the string
    //
    STRING_PRINT( localBuffer, "0x%02x", *(localScope->CurrentByte) );

    //
    // Step 3: Move the instruction pointer as appropriate, and setup
    // for the next instructions
    //
    localScope->CurrentByte += 1;

    //
    // Step 4: Now push the byte onto the string stack
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localBuffer ),
        localBuffer
        );

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseCodeObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This parses code

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;
    UCHAR           action;
    ULONG           i;
    ULONG           len;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Grab the scope that we will process
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Push a token onto the string stack to present the term
    // name
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localScope->AmlTerm->TermName ),
        localScope->AmlTerm->TermName
        );

    //
    // Step 3: This is guaranteed to be called after all arguments are
    // parsed
    //
    action = SC_FUNCTION_HANDLER;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 4: Determine if we have any arguments
    //
    if (localScope->AmlTerm->ArgumentTypes != NULL) {

        //
        // Step 4.1.1: Parse the Arguments
        //
        action = SC_PARSE_ARGUMENT;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

        //
        // Step 4.1.2: Make sure to start the argument index at zero
        //
        localScope->Context1 = localScope->Context2 = 0;

    }

    //
    // Step 5: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseConstObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This parses constants

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Find the string stack to use
    //
    stringStack = &(rootScope->StringStack);

    //
    // Step 3: Action depends on what the current byte value is:
    //
    switch ( *(localScope->CurrentByte) ) {
    case OP_ZERO:

        StringStackPush( stringStack, 4, "Zero" );
        break;

    case OP_ONE:

        StringStackPush( stringStack, 3, "One" );
        break;

    case OP_ONES:

        StringStackPush( stringStack, 4, "Ones" );
        break;

    case OP_REVISION:

        StringStackPush( stringStack, 8, "Revision" );
        break;

    default:

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Step 4: Done with the current byte
    //
    localScope->CurrentByte++;

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseData(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles data arguments

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;
    UCHAR           currentDataType;
    ULONG           i;
    ULONG           num;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Grab the current byte and decide what type of
    // data we are looking at based on that value
    //
    currentDataType = *(localScope->CurrentByte);
    localScope->CurrentByte++;
    switch( currentDataType ) {
    case OP_BYTE:

        action = SC_PARSE_BYTE;
        break;

    case OP_WORD:

        action = SC_PARSE_WORD;
        break;

    case OP_DWORD:

        action = SC_PARSE_DWORD;
        break;

    case OP_STRING:

        //
        // Step 2.2.1: Determine how long the string is
        //
        num = STRING_LENGTH( localScope->CurrentByte );

        //
        // Step 2.2.2: Push that number of bytes onto the string stack
        //
        StringStackPush( &(rootScope->StringStack), 1, "\"" );
        StringStackPush(
             &(rootScope->StringStack),
             num,
             localScope->CurrentByte
             );
        StringStackPush( &(rootScope->StringStack), 1, "\"" );

        //
        // Step 2.2.3: Update the current byte pointer and prepare for
        // next instructions
        //
        localScope->CurrentByte += (num + 1);

        //
        // Step 2.2.4: we don't have a next step, so we just return here
        //
        return STATUS_SUCCESS;

    case OP_BUFFER: {

        //
        // Step 2.1.1: This is an array of actions that we are about to
        // undertake. This reduces the number of calls to StringStackPush
        //
        UCHAR   actionList[4] = {
            SC_PARSE_POP,
            SC_PARSE_BUFFER,
            SC_PARSE_OPCODE,
            SC_PARSE_VARIABLE_OBJECT
        };

        //
        // Step 2.1.2: Push this array onto the stack
        //
        StringStackPush( &(rootScope->ParseStack), 4, actionList );

        //
        // Step 2.1.3: Display a name
        //
        StringStackPush( &(rootScope->StringStack), 7, "Buffer=");

        //
        // Step 2.1.3: Done
        //
        return STATUS_SUCCESS;

    }
    case OP_PACKAGE: {

        //
        // Step 2.3.1: Array of instructions to execute
        //
        UCHAR   actionList[3] = {
            SC_PARSE_POP,
            SC_PARSE_PACKAGE,
            SC_PARSE_VARIABLE_OBJECT
        };

        //
        // Step 2.3.2: Push those instructions onto the stack
        StringStackPush( &(rootScope->ParseStack), 3, actionList );

        //
        //
        // Step 2.3.3: Done
        //
        return STATUS_SUCCESS;

    }
    default:

        localScope->CurrentByte--;
        return STATUS_ILLEGAL_INSTRUCTION;

    }  // switch

    //
    // Step 3: Push action onto the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action);

    //
    // Step 4: done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseDelimiter(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is between elements. It is responsible for adding commas
    on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, "," );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseDWord(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles double words

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           localBuffer[12];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Build the string
    //
    STRING_PRINT( localBuffer, "0x%08x", *((PULONG)localScope->CurrentByte));

    //
    // Step 3: Move the instruction pointer as appropriate, and setup
    // for the next instructions
    //
    localScope->CurrentByte += 4;

    //
    // Step 4: Now push the byte onto the string stack
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localBuffer ),
        localBuffer
        );

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseField(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This is the code that actually parses a field

Arguments:

    The current thread's stack

Return Value:

    None:

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;
    UCHAR       followBits;
    UCHAR       i;
    UCHAR       buffer[32];
    ULONG       size;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Make sure that we still have some room to work with
    //
    if (localScope->CurrentByte > localScope->LastByte) {

        return STATUS_SUCCESS;

    }

    //
    // Step 3: This is the first byte in something that we will print out
    // And lets increment the count so that we have an idea of how many
    // items we have processed
    //
    localScope->TermByte = localScope->CurrentByte;
    localScope->Context1 += 1;

    //
    // Step 4: Action depends on current byte
    //
    if ( *(localScope->CurrentByte) == 0x01) {

        UCHAR   b1;
        UCHAR   b2;

        //
        // Step 4.1.1: Get the two bytes that we are going to use
        //
        localScope->CurrentByte++;
        b1 = *(localScope->CurrentByte++);
        b2 = *(localScope->CurrentByte++);

        //
        // Step 4.1.2: Make the string
        //
        STRING_PRINT( buffer,"AccessAs: (0x%2x,0x%2x)\n", b1, b2 );

        //
        // Step 4.1.3: Dump this to the string stack
        //
        StringStackPush(
            &(rootScope->StringStack),
            STRING_LENGTH( buffer ),
            buffer
            );

    } else {

        //
        // Step 4.2.1: Otherwise we have an encoded name
        //
        if ( *(localScope->CurrentByte) == 0x00 ) {

            StringStackPush(
                &(rootScope->StringStack),
                10,
                "(Reserved)"
                );
            localScope->CurrentByte++;

        } else {

            StringStackPush(
                &(rootScope->StringStack),
                sizeof(NAMESEG),
                localScope->CurrentByte
                );
            localScope->CurrentByte += sizeof(NAMESEG);

        }

        //
        // Step 4.2.2: Dump a seperator
        //
        StringStackPush(
            &(rootScope->StringStack),
            4,
            ": 0x"
            );

        //
        // Step 4.2.3: Calculate the size of the field
        //
        size = (ULONG) *(localScope->CurrentByte);
        localScope->CurrentByte++;
        followBits = (UCHAR) ( (size & 0xc0) >> 6);
        if (followBits) {

            size &= 0xf;
            for (i = 0; i < followBits; i++) {

                size |= (ULONG) *(localScope->CurrentByte) << (i * 8 + 4);
                localScope->CurrentByte++;

            }

        }

        //
        // Step 4.2.4: Dump a string that is correspondent to the size
        // of the number
        //
        STRING_PRINT( buffer,"%x", size );

        //
        // Step 4.2.5: Dump the length of the thing
        //
        StringStackPush(
            &(rootScope->StringStack),
            STRING_LENGTH( buffer ),
            buffer
            );

        //
        // Step 5.4: Print the string out
        //
        StringStackPush( &(rootScope->StringStack), 1, "\n" );

    }

    //
    // Step 5: Dump the string we generated
    //
    ScopePrint( Stack );

    //
    // Step 6: If there are still more thing to processe, we should
    // call this function again
    //
    if (localScope->CurrentByte <= localScope->LastByte) {

        action = SC_PARSE_FIELD;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

    }

    //
    // Step 7: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseFunctionHandler(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This code is actually something that transfers control to the term
    specific handler

Arguments:

    The current thread's stack

Return Value:

    None

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Check to see if we are at the end of the current nest
    //
    if (!(localScope->Flags & SC_FLAG_NESTED) ) {

        //
        // Step 2.1: Dump the string
        //
        StringStackPush( &(rootScope->StringStack), 2, "\n" );
        ScopePrint( Stack );

    }


    //
    // Step 4: Call the function handler if there is one
    //
    if ( localScope->AmlTerm->FunctionHandler != NULL) {

        status = (localScope->AmlTerm->FunctionHandler)( Stack );

    }

    //
    // Step 5: Done
    //
    return status;

}

NTSTATUS
ParseLocalObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles the LocalX instruction

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    CHAR            i;
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           buffer[7];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Which local are we talking about
    //
    i = *(localScope->CurrentByte) - OP_LOCAL0;
    if ( i < 0 || i > 7) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 3: Display this to the user
    //
    STRING_PRINT( buffer, "Local%1d", i );
    StringStackPush( &(rootScope->StringStack), 6, buffer );

    //
    // Step 4: Setup for next state
    //
    localScope->CurrentByte++;

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseName(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles generating the argument name

Arguments:

    Stack   - The Stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;
    ULONG           nameSegmentCount = 1;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and local scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Delimit the String
    //
    stringStack = &(rootScope->StringStack);
    StringStackPush( stringStack, 1, "\"");

    //
    // Step 3: Action depends on what the current byte value is:
    //
    switch ( *(localScope->CurrentByte) ) {
    case OP_ROOT_PREFIX:

        StringStackPush( stringStack, 1, "\\" );
        localScope->CurrentByte++;
        break;

    case OP_PARENT_PREFIX:

        while ( *(localScope->CurrentByte) == OP_PARENT_PREFIX ) {

            StringStackPush( stringStack, 1, "^" );
            localScope->CurrentByte++;

        }
        break;
    }

    //
    // Step 4: Determine the number of Name segments we are adding
    //
    switch ( *(localScope->CurrentByte) ) {
    case '\0':

        nameSegmentCount = 0;
        localScope->CurrentByte++;
        break;

    case OP_MULTI_NAME_PREFIX:

        //
        // The next byte contains the number of name segments
        //
        localScope->CurrentByte++;
        nameSegmentCount = (ULONG) *(localScope->CurrentByte);
        localScope->CurrentByte++;
        break;

    case OP_DUAL_NAME_PREFIX:

        //
        // There are two name segments
        //
        nameSegmentCount = 2;
        localScope->CurrentByte++;
        break;

    }

    //
    // Step 5: Push the name segments onto the stack
    //
    while (nameSegmentCount > 0) {

        //
        // Step 5.1 Add the segment onto the stack
        //
        StringStackPush(
            stringStack,
            sizeof( NAMESEG ),
            localScope->CurrentByte
            );

        //
        // Step 5.2: Decrement the number of remaining segments and
        // move the current byte pointer to point to the next
        // interesting thing
        //
        nameSegmentCount--;
        localScope->CurrentByte += sizeof(NAMESEG);

        //
        // Step 5.3: Check to see if we should add a seperator
        //
        if (nameSegmentCount) {

            StringStackPush( stringStack, 1, "." );

        }

    }

    //
    // Step 6: Push the closing delimiter
    //
    StringStackPush( stringStack, 1, "\"" );

    //
    // Step 7: done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseNameObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles name objects

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{

    //
    // Note: at this time, this function is just a wrapper for
    // ParseName(). If that was an assembler, it would have to execute
    // something here
    //
    return ParseName( Stack );

}

NTSTATUS
ParseOpcode(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine is the main parsing point for AML opcode

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_AMLTERM    amlTerm;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;
    ULONG       termGroup;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Check to see if we are past the end byte?
    //
    if (localScope->CurrentByte > localScope->LastByte) {

        return STATUS_SUCCESS;

    }

    //
    // Step 3: Remember which byte demarked the start of the
    // instruction
    //
    localScope->TermByte = localScope->CurrentByte;

    //
    // Step 4: Check to see if this is an extended instruction
    //
    if ( *(localScope->CurrentByte) == OP_EXT_PREFIX) {

        //
        // Step 4.1.1: Extended opcode. Next instruction will let us find the
        // AML term to use for the evaluation
        //
        localScope->CurrentByte++;

        //
        // Step 4.1.2: Grab the AML term for the extended operation
        //
        amlTerm = localScope->AmlTerm = ScopeFindExtendedOpcode( Stack );

    } else {

        //
        // Step 4.2.1: Grab the AML term for the current operation
        //
        amlTerm = localScope->AmlTerm =
            OpcodeTable[ *(localScope->CurrentByte) ];

    }
    localScope->Context1 = localScope->Context2 = 0;

    //
    // Step 5: Check to see if we have a valid AML term
    //
    if (localScope->AmlTerm == NULL) {

        return STATUS_UNSUCCESSFUL;

    }

    //
    // Step 6: Farm out the real work to functions that are better capable
    // of handling the current AML term
    //
    termGroup = (amlTerm->OpCodeFlags & 0xFF);
    switch( termGroup ) {
    case OF_NORMAL_OBJECT:
    case OF_VARIABLE_LIST:
    case OF_REF_OBJECT:

        //
        // Step 6.1: If we are going to handle a variable length instruction
        // than we must also pop it from the stack
        //
        if (amlTerm->OpCodeFlags == OF_VARIABLE_LIST) {

            UCHAR   actionList[5] = {
                SC_PARSE_OPCODE,
                SC_PARSE_POP,
                SC_PARSE_OPCODE,
                SC_PARSE_CODE_OBJECT,
                SC_PARSE_VARIABLE_OBJECT
            };

            StringStackPush( &(rootScope->ParseStack), 5, actionList );

        } else {

            //
            // If we are already nested, we know that there is an ParseOpcode
            // just waiting for us...
            //
            if (!(localScope->Flags & SC_FLAG_NESTED)) {

                action = SC_PARSE_OPCODE;
                StringStackPush( &(rootScope->ParseStack), 1, &action);

            }

            action = SC_PARSE_CODE_OBJECT;
            StringStackPush( &(rootScope->ParseStack), 1, &action);

        }

        //
        // Step 6.2: This is a code byte. Ergo we eat it since we just
        // processed it
        //
        localScope->CurrentByte++;

        //
        // Step 6.3: Done
        //
        return STATUS_SUCCESS;

    case OF_NAME_OBJECT:

        action = SC_PARSE_NAME_OBJECT;
        break;

    case OF_DATA_OBJECT:

        action = SC_PARSE_DATA;
        break;

    case OF_CONST_OBJECT:

        action = SC_PARSE_CONST_OBJECT;
        break;

    case OF_ARG_OBJECT:

        action = SC_PARSE_ARGUMENT_OBJECT;
        break;

    case OF_LOCAL_OBJECT:

        action = SC_PARSE_LOCAL_OBJECT;
        break;

    default:

        return STATUS_NOT_SUPPORTED;

    }

    //
    // Step 7: Actually push the action to execute next on to the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 8: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParsePackage(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine parses the stages of a package

Arguments:

    The current thread's stack

    Note: Caller needs to push a stack location before calling this and they
    have to pop it when it finishes

Return Value:

    NTSTATUS:

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Context1 is the current index in the package...
    //
    if (localScope->Context1 == 0) {

        UCHAR   actionList[2] = {
                    SC_PARSE_PACKAGE,
                    SC_PARSE_DELIMITER
                    };
        ULONG   i;

        //
        // Step 2.1.1: This is the first call to parse package...
        // What we need to do here is handle the first argument here,
        // and make sure that we get called again for the remaining
        // arguments
        //
        StringStackPush( &(rootScope->StringStack), 1, "[" );

        //
        // Step 2.1.2: This byte contains the number of arguments to handle
        //
        localScope->Context2 = *(localScope->CurrentByte);
        localScope->CurrentByte++;

        //
        // Step 2.1.3: Make sure that we close that bracket above
        //
        action = SC_PARSE_TRAILING_PACKAGE;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

        //
        // Step 2.1.3: Setup all the remaining calls to this function
        //
        if (localScope->Context2 >= 2) {

            for (i=0; i < localScope->Context2 - 1; i++) {

                StringStackPush( &(rootScope->ParseStack), 2, actionList );

            }

        }

    } else if (localScope->Context1 >= localScope->Context2) {

        //
        // Step 2.2.1: We are at the end of the package
        //
        return STATUS_UNSUCCESSFUL;

    }

    //
    // Step 3: Farm out the work depending on what the current byte is
    // This looks a lot like ParseData, but note the new default case
    //
    switch ( *(localScope->CurrentByte) ) {
        case OP_BYTE:
        case OP_WORD:
        case OP_DWORD:
        case OP_BUFFER:
        case OP_STRING:
        case OP_PACKAGE:
            action = SC_PARSE_DATA;
            break;
        default:
            action = SC_PARSE_NAME;

    }

    //
    // Step 4: Push the next action onto the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );
    localScope->Context1++;

    //
    // Step 5: done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParsePop(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine removes the top level of the stack and updates the
    current byte as appropriate

Arguments:

    The current thread's stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      topScope;
    PUNASM_SCOPE      prevScope;

    //
    // Step 1: Get the top scope
    //
    status = StackTop( Stack, &topScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Get the previous scope
    //
    status = StackParent( Stack, topScope, &prevScope );
    if (!NT_SUCCESS(status)) {

        //
        // Step 2.1: There is actually no parent to this function ...
        // Just pop the top and return
        //
        return StackPop( Stack );

    }

    //
    // Step 3: Make sure to update the prevScope's current byte
    //
    if (topScope->CurrentByte > prevScope->CurrentByte) {

        prevScope->CurrentByte = topScope->CurrentByte;

    }

    //
    // Step 4: Pop the top stack and return
    //
    return StackPop( Stack );
}

NTSTATUS
ParsePush(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles adding a level to the stack

Arguments:

    The thread's current stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      curScope;
    PUNASM_SCOPE      newScope;

    //
    // Step 1: Create a new scope on the stack
    //
    status = StackPush( Stack, &newScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Grab the parent from the stack
    //
    status = StackParent( Stack, newScope, &curScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 3: Copy the important values
    //
    newScope->CurrentByte = curScope->CurrentByte;
    newScope->TermByte = curScope->TermByte;
    newScope->LastByte = curScope->LastByte;
    newScope->StringStack = curScope->StringStack;
    newScope->IndentLevel = curScope->IndentLevel;
    newScope->AmlTerm = curScope->AmlTerm;
    newScope->Flags = curScope->Flags;

    //
    // Step 4: Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ParseScope(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles super names

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    PUCHAR      action;
    UCHAR       defAction = SC_PARSE_OPCODE;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Loop forever
    //
    while (1) {

        //
        // Step 2: Get the top of stack, and while it exits, process
        // the current operation
        //
        ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

        //
        // Step 3: We are done if we are in the root scope and the
        // current byte exceeds the last byte
        //
        if (localScope == rootScope &&
            localScope->CurrentByte > localScope->LastByte) {

            //
            // Step 3.1 Done!
            //
            return STATUS_SUCCESS;

        }

        //
        // Step 4: Fetch thing to execute
        //
        status = StringStackPop( &(rootScope->ParseStack), 1, &action );
        if (!NT_SUCCESS(status)) {

            //
            // Step 4.1.1: This is fixed in the look up table
            //
            status = (ScopeStates[ SC_PARSE_OPCODE ])( Stack );

        } else {

            //
            // Step 4.1.2: Determine what to execute
            //
            ASSERT( *action <= SC_MAX_TABLE );
            status = (ScopeStates[ *action ])( Stack );

        }

        if (!NT_SUCCESS(status)) {

            break;

        }

    }

    //
    // Step 5: Show the user the error
    //
    PRINTF("Error Code: %x\n", status );
    return status;
}

NTSTATUS
ParseSuperName(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles super names

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_AMLTERM        amlTerm;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Get the scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: What we do next depend on the current byte
    //
    if ( *(localScope->CurrentByte) == 0) {

        //
        // Unknown
        //
        localScope->CurrentByte++;
        return STATUS_SUCCESS;

    } else if ( *(localScope->CurrentByte) == OP_EXT_PREFIX &&
                *(localScope->CurrentByte + 1) == EXOP_DEBUG) {

        //
        // Debug Object
        //
        localScope->CurrentByte += 2;
        return STATUS_SUCCESS;

    } else if ( OpcodeTable[ *(localScope->CurrentByte) ] == NULL) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 3: Now, our action depends on the current AML Term
    //
    amlTerm = OpcodeTable[ *(localScope->CurrentByte) ];
    if ( amlTerm->OpCodeFlags == OF_NAME_OBJECT) {

        //
        // We have a name to parse
        //
        action = SC_PARSE_NAME;

    } else if ( amlTerm->OpCodeFlags == OF_ARG_OBJECT) {

        //
        // We have an argument to parse
        //
        action = SC_PARSE_ARGUMENT_OBJECT;

    } else if ( amlTerm->OpCodeFlags == OF_LOCAL_OBJECT) {

        //
        // We have a local object...
        //
        action = SC_PARSE_LOCAL_OBJECT;

    } else if ( amlTerm->OpCodeFlags == OF_REF_OBJECT) {

        UCHAR   actionList[3] = {
            SC_PARSE_OPCODE,
            SC_PARSE_POP,
            SC_PARSE_OPCODE
        };

        //
        // Step 3.1: Set up the initial task of the new scope
        //
        StringStackPush( &(rootScope->ParseStack), 3, actionList );

        //
        // Step 3.2: Push a new scope
        //
        status = ParsePush( Stack );
        if (!NT_SUCCESS(status) ) {

            return status;

        }

        //
        // Step 3.3: Done
        //
        return STATUS_SUCCESS;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 4: Push the action onto the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 5: Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ParseTrailingArgument(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is run at after all arguments are parsed. It is responsible
    for placing a trailing parentheses on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, ")" );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseTrailingBuffer(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is run at after the buffer is parsed. It is responsible
    for placing a trailing curly brace on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, "}" );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseTrailingPackage(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is run at after all elements are parsed. It is responsible
    for placing a trailing brace on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, "]" );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseVariableObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine creates another scope level on the stack to process the
    current variable length instruction. It modifies the current scope
    to (correctly) point to the next instruction

    Note:   Callers of this function are expected to pop off the stack
    when it is no longer required!!!

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      newScope;
    PUNASM_SCOPE      oldScope;
    PUCHAR      nextOpcode;
    UCHAR       i;
    UCHAR       lengthBytes;
    ULONG       packageLength;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Create a new scope on the stack
    //
    status = ParsePush( Stack );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Get the new top scope and its parent
    //
    status = StackTop( Stack, &newScope );
    if (!NT_SUCCESS( status ) ) {

        return status;

    }
    status = StackParent( Stack, newScope, &oldScope );
    if (!NT_SUCCESS( status ) ) {

        return status;

    }

    //
    // Step 3: Determine how bytes the current instruction takes
    //
    packageLength = (ULONG) *(newScope->CurrentByte);
    newScope->CurrentByte++;

    //
    // Step 4: If the the high 2 bits are set, this indicates that some
    // follow on bits are also used in calculating the length
    //
    lengthBytes = (UCHAR) ( ( packageLength & 0xC0) >> 6);
    if (lengthBytes) {

        //
        // Step 4.1: Mask off the non-length bits in the packageLength
        //
        packageLength &= 0xF;

        //
        // Step 4.2: Add the follow-on lengths
        //
        for (i = 0; i < lengthBytes; i++) {

            packageLength |= ( (ULONG) *(newScope->CurrentByte) << (i*8 + 4) );
            newScope->CurrentByte++;

        }

    }

    //
    // Step 5: We can calculate the start of the next opcode as the
    // opcode in the old scope plus the calculated length. The end of
    // new scope is the byte previous to this one
    //
    oldScope->CurrentByte += packageLength;
    newScope->LastByte = oldScope->CurrentByte - 1;

    //
    // Step 6: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseWord(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles words

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           localBuffer[8];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Build the string
    //
    STRING_PRINT( localBuffer, "0x%04x", *((PUSHORT)localScope->CurrentByte));

    //
    // Step 3: Move the instruction pointer as appropriate, and setup
    // for the next instructions
    //
    localScope->CurrentByte += 2;

    //
    // Step 4: Now push the byte onto the string stack
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localBuffer ),
        localBuffer
        );

    //
    // Step 5: Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\function.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    function.c

Abstract:

    Functions which are OpCode specific

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

NTSTATUS
FunctionField(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function is the handler for the AML term 'IfElse'

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    //
    // Step 1: Push a new scope
    //
    status = ParsePush( Stack );
    if (!NT_SUCCESS( status )) {

        return status;

    }

    //
    // Step 2: Find the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 3: Program the parameters for the new scope
    //
    localScope->IndentLevel += 2;

    //
    // Step 4: Remember to pop this scope
    //
    action = SC_PARSE_POP;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 5: Schedule a call to the field handler
    //
    action = SC_PARSE_FIELD;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 6:
    //
    return STATUS_SUCCESS;
}

NTSTATUS
FunctionScope(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function is the handler for the AML Term 'Scope'

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Push a new scope
    //
    status = ParsePush( Stack );
    if (!NT_SUCCESS( status )) {

        return status;

    }

    //
    // Step 2: Find the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 3: Program the parameters for the new scope
    //
    localScope->IndentLevel += 2;

    //
    // Step 4: Remember to pop this scope
    //
    action = SC_PARSE_POP;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 5: Next action is to parse an opcode...
    //
    action = SC_PARSE_OPCODE;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 6: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
FunctionTest(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function is the handler for the AML Term 'Scope'

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    return FunctionScope( Stack );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\parser.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parser.h

Abstract:

    The header for the parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _PARSER_H_
#define _PARSER_H_

    NTSTATUS
    ParseArgument(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseArgumentObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseBuffer(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseByte(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseCodeObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseConstObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseData(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseDelimiter(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseDWord(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseField(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseFunctionHandler(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseLocalObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseName(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseNameObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseOpcode(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParsePackage(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParsePop(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParsePush(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseScope(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseSuperName(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseTrailingArgument(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseTrailingBuffer(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseTrailingPackage(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseVariableObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseWord(
        IN  PSTACK  *Stack
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI Unassembler

Author:

    Stephane Plante

Environment:

    Kernel mode only.

Revision History:

--*/

//
// These are the global header files
//
#include <ntddk.h>
#include "aml.h"
#include "unasm.h"

//
// These form the primitives that are used by the local
// header files
//
#include "stack.h"
#include "ustring.h"

//
// These are the local include files
//
#include "parser.h"
#include "function.h"
#include "data.h"
#include "scope.h"

//
// This is to get around the fact that we don't want
// to compile in some routines
//
#include "external.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\scope.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scope.h

Abstract:

    Defines the structures used by the parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _SCOPE_H_
#define _SCOPE_H_

    PUNASM_AMLTERM
    ScopeFindExtendedOpcode(
        IN  PSTACK  *Stack
        );

    #define ScopeFindLocalScope(Stack, LocalScope, RootScope, Status)   \
        Status = StackTop( Stack, LocalScope );                         \
        if (!NT_SUCCESS(Status)) {                                      \
                                                                        \
            return Status;                                              \
                                                                        \
        }                                                               \
        Status = StackRoot( Stack, RootScope );                         \
        if (!NT_SUCCESS(Status)) {                                      \
                                                                        \
            return Status;                                              \
                                                                        \
        }

    NTSTATUS
    ScopeParser(
        IN  PUCHAR  Start,
        IN  ULONG   Length,
        IN  ULONG   BaseAddress,
	IN  ULONG   IndentLevel
        );

    NTSTATUS
    ScopePrint(
        IN  PSTACK  *Stack
        );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\stack.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.c

Abstract:

    This provides a generic stack handler to push/pop things onto it

Author:

    Stephane Plante (splante)

Environment:

    User, Kernel

--*/

#ifndef _STACK_H_
#define _STACK_H_

    NTSTATUS
    StackAllocate(
        OUT     PSTACK  *Stack,
        IN      ULONG   StackElementSize
        );

    NTSTATUS
    StackFree(
        IN  OUT PSTACK  *Stack
        );

    NTSTATUS
    StackParent(
        IN  OUT PSTACK  *Stack,
        IN      PVOID   Child,
            OUT PVOID   Parent
        );

    NTSTATUS
    StackPop(
        IN  OUT PSTACK  *Stack
        );

    NTSTATUS
    StackPush(
        IN  OUT PSTACK  *Stack,
            OUT PVOID   StackElement
        );

    NTSTATUS
    StackRoot(
        IN  OUT PSTACK  *Stack,
            OUT PVOID   RootElement
        );

    NTSTATUS
    StackTop(
        IN  OUT PSTACK  *Stack,
            OUT PVOID   TopElement
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\scope.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scope.c

Abstract:

    The scope portion of the parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"
UCHAR   GlobalIndent[80];

PUNASM_AMLTERM
ScopeFindExtendedOpcode(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function looks in the extended opcode table for the matching
    AML term

Arguments:

    Stack   - The current thread of execution

Return Value:

    None

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    ULONG       index = 0;
    PUNASM_OPCODEMAP  opcodeMap;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1:  Find the top of the stack
    //
    status = StackTop( Stack, &localScope );
    if (!NT_SUCCESS(status)) {

        return NULL;

    }

    //
    // Step 2: Loop Forever
    //
    while (1) {

        //
        // Step 2.1: Get the entry out of the extended opcode table
        //
        opcodeMap = &(ExOpcodeTable[index]);

        //
        // Step 2.2: Make sure that we haven't crossed the end
        //
        if (opcodeMap->OpCode == 0) {

            break;

        }

        //
        // Step 2.3: Did we find what we where looking for?
        //
        if (opcodeMap->OpCode == *(localScope->CurrentByte) ) {

            return opcodeMap->AmlTerm;

        }

        //
        // Step 2.4: No?
        //
        index++;

    }

    //
    // Step 3: Failure
    //
    return NULL;
}

#if 0
NTSTATUS
ScopeFindLocalScope(
    IN  PSTACK  *Stack,
    OUT PUNASM_SCOPE  *LocalScope,
    OUT PUNASM_SCOPE  *RootScope
    )
/*++

Routine Description:

    This function is a helper function. It simply grabs the top and bottom
    of the stack and returns them.

    This is a macro

Arguments:

    Stack       - The top of the stack
    LocalScope  - Where we want the top of stack
    RootScope   - Where we want the bottom of stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;

    ASSERT( Stack != NULL && *Stack != NULL );
    ASSERT( LocalScope != NULL );
    ASSERT( RootScope != NULL );

    //
    // Step 1: Grab the local scope
    //
    status = StackTop( Stack, LocalScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Grab the root
    //
    status = StackRoot( Stack, RootScope );
    if (!(NT_SUCCESS(status)) {

        return status;

    }
}
#endif

NTSTATUS
ScopeParser(
    IN  PUCHAR  Start,
    IN  ULONG   Length,
    IN  ULONG   BaseAddress,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This routine arranges things so that the supplied bytes can be parsed

Arguments:

    Start       - Pointer to the first byte to parse
    Length      - Number of Bytes to parse
    BaseAddress - Used for calculating memory location of instruction

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PSTACK      stack;
    PUNASM_SCOPE      scope;

    //
    // Setup the global indent
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel );
    MEMORY_SET( GlobalIndent, ' ', IndentLevel );
    GlobalIndent[IndentLevel] = '\0';

    //
    // Step 1: Obtain a stack
    //
    status = StackAllocate( &stack, sizeof(UNASM_SCOPE) );
    if (!NT_SUCCESS(status)) {

        return status;

    } else if (stack == NULL) {

        return STATUS_FAIL_CHECK;

    }

    //
    // Step 2: Setup the root scope
    //
    status = StackPush( &stack, &scope );
    if (!NT_SUCCESS(status)) {

        return status;

    }
    scope->CurrentByte = Start;
    scope->LastByte = Start + Length - 1;
    scope->IndentLevel = 0;
    scope->BaseAddress = BaseAddress;

    //
    // Step 3: Initialize the string stack
    //
    status = StringStackAllocate( &(scope->StringStack) );
    if (!NT_SUCCESS(status)) {

        return status;

    }
    status = StringStackAllocate( &(scope->ParseStack) );
    if (!NT_SUCCESS(status)) {

        return status;

    }
    //
    // Step 4: Parse the scope
    //
    status = ParseScope( &stack );
    if (NT_SUCCESS(status)) {

        status = StackRoot( &stack, &scope );
        if (!NT_SUCCESS(status)) {

            return status;

        }
        StringStackFree( &(scope->StringStack) );
        StringStackFree( &(scope->ParseStack) );
        StackPop( &stack );
        StackFree( &stack );

    }

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ScopePrint(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This prints and clears the string in the current scope

Arguments:

    The current thread's stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      scope;
    PUNASM_SCOPE      root;
    PUCHAR      buffer;

    //
    // Step 1: Get the local scope
    //
    ScopeFindLocalScope( Stack, &scope, &root, status );

    //
    // Step 2: Allocate a buffer to print spaces to
    //
    buffer = MEMORY_ALLOCATE( scope->IndentLevel + 11 );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Step 3: Check to see if there is an indent level
    //
    if (scope->IndentLevel) {

        //
        // Step 3.1.1: Print some spaces to that buffer
        //
        STRING_PRINT(
            buffer,
            "%s%08x  %*s",
            GlobalIndent,
            scope->TermByte + root->BaseAddress,
            scope->IndentLevel,
            ""
            );

    } else {

        //
        // Step 3.2.1: Print just the address
        //
        STRING_PRINT(
            buffer,
            "%s%08x  ",
            GlobalIndent,
            scope->TermByte + root->BaseAddress
            );

    }

    //
    // Step 4 Show it to the user
    //
    PRINTF( "%s", buffer );

    //
    // Step 5: Free the memory
    //
    MEMORY_FREE( buffer );

    //
    // Step 6: Grab the root stack
    //
    status = StackRoot( Stack, &scope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 7: Show the user the buffer
    //
    StringStackPush( &(scope->StringStack), 1, "\0" );
    PRINTF( "%s", scope->StringStack->Stack );
    StringStackClear( &(scope->StringStack) );

    //
    // Step 8: Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\stack.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.c

Abstract:

    This provides a generic stack handler to push/pop things onto it

Author:

    Stephane Plante (splante)

Environment:

    User, Kernel

--*/

#include "pch.h"

NTSTATUS
StackAllocate(
    OUT     PSTACK  *Stack,
    IN      ULONG   StackElementSize
    )
/*++

Routine Description:

    This routine allocates memory and returns a stack object

Arguments:

    Stack               - Where to store a pointer to the stack
    StackElementSize    - How much space on the stack a single element takes
                          up

Return Value:

    NTSTATUS

--*/
{
    PSTACK      tempStack;
    NTSTATUS    status  = STATUS_SUCCESS;

    //
    // Make sure that we have some place to store the stack pointer
    //
    ASSERT( Stack != NULL );
    ASSERT( StackElementSize != 0 );

    //
    // Allocate a block of memory for the stack
    //
    tempStack = MEMORY_ALLOCATE(
        sizeof(STACK) + ( (STACK_GROWTH_RATE * StackElementSize) - 1)
        );
    if (tempStack == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto StackAllocateExit;
    }

    //
    // Setup the control block of the stack
    //
    tempStack->Signature        = (ULONG) STACK_SIGNATURE;
    tempStack->StackSize        = STACK_GROWTH_RATE * StackElementSize;
    tempStack->StackElementSize = StackElementSize;
    tempStack->TopOfStack       = 0;

    //
    // Zero out the current elements on the stack
    //
    MEMORY_ZERO(
        &(tempStack->Stack[0]),
        STACK_GROWTH_RATE * StackElementSize
        );

    //
    // Return the stack pointer
    //
StackAllocateExit:
    *Stack = tempStack;
    return status;

}

NTSTATUS
StackFree(
    IN  OUT PSTACK  *Stack
    )
/*++

Routine Description:

    This routine frees the stack

Arguments:

    Stack   - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    //
    // Free the stack
    //
    MEMORY_FREE( *Stack );

    //
    // Point the stack to nowhere
    //
    *Stack = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
StackParent(
    IN  OUT PSTACK  *Stack,
    IN      PVOID   Child,
        OUT PVOID   Parent
    )
/*++

Routine Description:

    This routine returns a pointer to the stack location that is before
    the given Child.

Arguments:

    Stack   - The stack to operate on
    Child   - This is the node whose parent we want
    Parent  - This is where we store a pointer to the parent stack loc

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;
    ULONG   Addr = (ULONG) Child;

    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );
    ASSERT( Parent != NULL );

    //
    // make sure that the child node actually lies on the stack
    //
    localStack = *Stack;
    if ( Addr < (ULONG) localStack->Stack ||
         Addr > (ULONG) &(localStack->Stack[localStack->TopOfStack + 1]) -
           localStack->StackElementSize ) {

        *( (PULONG *)Parent) = NULL;
        return STATUS_FAIL_CHECK;

    }

    //
    // Make sure that the child node isn't the first element
    //
    if (Addr < (ULONG) &(localStack->Stack[localStack->StackElementSize]) ) {

        *( (PULONG *)Parent) = NULL;
        return STATUS_SUCCESS;

    }

    //
    // Set the parent to be one before the child
    //
    *( (PULONG *)Parent) = (PULONG) (Addr - localStack->StackElementSize);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StackPop(
    IN  OUT PSTACK  *Stack
    )
/*++

Routine Description:

    This routine reclaims the memory used for a stack location
    and wipes out whatever data existed in the reclaimed area

Arguments:

    Stack           - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;

    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    //
    // Is there an item that we can remove from the stack?
    //
    localStack = *Stack;
    if ( localStack->TopOfStack == 0) {

        return STATUS_FAIL_CHECK;

    }

    //
    // Wipe out the top-most element on the stack
    //
    localStack->TopOfStack -= localStack->StackElementSize;
    MEMORY_ZERO(
        &( localStack->Stack[ localStack->TopOfStack ] ),
        localStack->StackElementSize
        );

    return STATUS_SUCCESS;
}

NTSTATUS
StackPush(
    IN  OUT PSTACK  *Stack,
        OUT PVOID   StackElement
    )
/*++

Routine Description:

    This routine obtains a pointer for an object on the top of the stack
    and increments the top to point to something that can be then be used
    again.

Arguments:

    Stack           - Where to find a pointer to the stack
    StackElement    - Pointer to the element to be added to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;
    PSTACK  tempStack;
    ULONG   newSize;
    ULONG   deltaSize;

    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( StackElement != NULL );

    //
    // Find the stack pointer and make sure that the signature is still
    // valid
    //
    localStack = *Stack;
    ASSERT( localStack->Signature == STACK_SIGNATURE );

    //
    // Do we have enough space on the stack?
    //
    if ( localStack->TopOfStack >= localStack->StackSize ) {

        //
        // Figure out how many bytes by which to grow the stack and how
        // large the total stack should be
        //
        deltaSize = (STACK_GROWTH_RATE * localStack->StackElementSize);
        newSize = sizeof(STACK) + localStack->StackSize + deltaSize - 1;

        //
        // Grow the stack
        //
        tempStack = MEMORY_ALLOCATE( newSize );
        if (tempStack == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Empty the new stack and copy the old one to it
        //
        MEMORY_ZERO( &(tempStack->Stack[0]), newSize - sizeof(STACK) + 1);
        MEMORY_COPY( tempStack, localStack , newSize - deltaSize);

        //
        // Make sure that the new stack has the correct size
        //
        tempStack->StackSize += deltaSize;

        //
        // Free the old stack
        //
        StackFree( Stack );

        //
        // Set the stack to point to the new one
        //
        *Stack = localStack = tempStack;

    }

    //
    // Grab a pointer to the part that we will return to the caller
    //
    *( (PUCHAR *)StackElement) = &(localStack->Stack[ localStack->TopOfStack ]);

    //
    // Find the new Top of Stack
    //
    localStack->TopOfStack += localStack->StackElementSize;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StackRoot(
    IN  OUT PSTACK  *Stack,
        OUT PVOID   RootElement
    )
/*++

Routine Description:

    This routine returns the first element on the stack

Arguments:

    Stack       - Where the stack is located
    RootElement - Where to store the pointer to the root stack element

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;

    ASSERT( Stack != NULL && *Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    localStack = *Stack;
    if (localStack->TopOfStack < localStack->StackElementSize) {

        //
        // There is no stack location we can use
        //
        *( (PUCHAR *)RootElement) = NULL;
        return STATUS_UNSUCCESSFUL;

    }

    //
    // Grab the root element
    //
    *( (PUCHAR *)RootElement) = localStack->Stack;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StackTop(
    IN  OUT PSTACK  *Stack,
        OUT PVOID   TopElement
    )
/*++

Routine Description:

    This routine returns the topmost stack location that is in current use

Arguments:

    Stack       - Where the stack is located
    TopElement  - Where to store the pointer to the top stack element

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;
    ULONG   offset;

    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    localStack = *Stack;
    if (localStack->TopOfStack < localStack->StackElementSize) {

        //
        // No stack locations are in current use
        //
        *( (PUCHAR *)TopElement) = NULL;
        return STATUS_UNSUCCESSFUL;

    } else {

        offset = localStack->TopOfStack - localStack->StackElementSize;
    }

    //
    // Grab the top stack location
    //
    *( (PUCHAR *)TopElement) = &(localStack->Stack[ offset ]);

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\ustring.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    string.c

Abstract:

    The string stack portion of the un-assembler

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

NTSTATUS
StringStackAllocate(
    OUT     PSTRING_STACK  *StringStack
    )
/*++

Routine Description:

    This routine allocates memory and returns a string stack object

Arguments:

    String Stack    - Where to store a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK   tempStack;
    NTSTATUS        status  = STATUS_SUCCESS;

    //
    // Make sure that we have some place to store the stack pointer
    //
    ASSERT( StringStack != NULL );

    //
    // Allocate a block of memory for the stack
    //
    tempStack = MEMORY_ALLOCATE(
        sizeof(STRING_STACK) + ( STRING_GROWTH_RATE - 1 )
        );
    if (tempStack == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto StringStackAllocateExit;
    }

    //
    // Setup the control block of the stack
    //
    tempStack->Signature        = (ULONG) STRING_SIGNATURE;
    tempStack->StackSize        = STRING_GROWTH_RATE;
    tempStack->TopOfStack       = 0;

    //
    // Zero out the current elements on the stack
    //
    MEMORY_ZERO( tempStack->Stack, STRING_GROWTH_RATE );

    //
    // Return the stack pointer
    //
StringStackAllocateExit:
    *StringStack = tempStack;
    return status;

}

NTSTATUS
StringStackClear(
    IN  OUT PSTRING_STACK   *StringStack
    )
/*++

Routine Description:

    This routine wipes out the contents of the stack and
    restarts it as if it was new allocated. Saves some from
    freeing and reallocating a stack

Arguments:

    StringStack - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK   localStack;

    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL && *StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );

    //
    // Zero out the stack
    //
    localStack = *StringStack;
    MEMORY_ZERO( localStack->Stack, localStack->StackSize );

    //
    // Reset the TOS to the root
    //
    localStack->TopOfStack = 0;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StringStackFree(
    IN  OUT PSTRING_STACK   *StringStack
    )
/*++

Routine Description:

    This routine frees the string stack

Arguments:

    StringStack - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL && *StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );

    //
    // Free the stack
    //
    MEMORY_FREE( *StringStack );

    //
    // Point the stack to nowhere
    //
    *StringStack = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
StringStackPop(
    IN  OUT PSTRING_STACK   *StringStack,
    IN      ULONG           NumBytes,
        OUT PUCHAR          *String
    )
/*++

Routine Description:

    This routine returns a pointer to the requested offset from the end
    of the stack

    Note: String points to memory that can be freed at any time. It is the
    caller's responsibility to make a copy

Arguments:

    StringStack - Where to find a pointer to the stack
    NumBytes    - Number of bytes to pop off
    String      - Pointer to the bytes.

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK  localStack;

    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );
    ASSERT( String != NULL );

    //
    // Is there an item that we can remove from the stack?
    //
    localStack = *StringStack;
    if ( localStack->TopOfStack == 0 ||
         localStack->TopOfStack < NumBytes) {

        return STATUS_FAIL_CHECK;

    }

    //
    // Return a pointer to the requested bytes
    //
    localStack->TopOfStack -= NumBytes;
    *String = &( localStack->Stack[ localStack->TopOfStack ] );
    return STATUS_SUCCESS;

}

NTSTATUS
StringStackPush(
    IN  OUT PSTRING_STACK   *StringStack,
    IN      ULONG           StringLength,
    IN      PUCHAR          String
    )
/*++

Routine Description:

    This routine obtains a pointer for an object on the top of the stack
    and increments the top to point to something that can be then be used
    again.

Arguments:

    StringStack     - Where to find a pointer to the stack
    String          - String to push onto stack
    StringLength    - How many bytes to push onto the stack

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK   localStack;
    PSTRING_STACK   tempStack;
    ULONG           newSize;

    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL );
    ASSERT( String != NULL );

    //
    // Find the stack pointer and make sure that the signature is still
    // valid
    //
    localStack = *StringStack;
    ASSERT( localStack->Signature == STRING_SIGNATURE );

    //
    // Do we have enough space on the stack?
    //
    if ( localStack->TopOfStack + StringLength > localStack->StackSize ) {

        //
        // Figure out how many bytes by which to grow the stack and how
        // large the total stack should be
        //
        newSize = sizeof(STRING_STACK) + localStack->StackSize +
            STRING_GROWTH_RATE - 1;

        //
        // Grow the stack
        //
        tempStack = MEMORY_ALLOCATE( newSize );
        if (tempStack == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Empty the new stack and copy the old one to it
        //
        MEMORY_ZERO( tempStack->Stack, newSize - sizeof(STRING_STACK) + 1);
        MEMORY_COPY( tempStack, localStack , newSize - STRING_GROWTH_RATE);

        //
        // Make sure that the new stack has the correct size
        //
        tempStack->StackSize += STRING_GROWTH_RATE;

        //
        // Free the old stack
        //
        StringStackFree( StringStack );

        //
        // Set the stack to point to the new one
        //
        *StringStack = localStack = tempStack;

    }

    //
    // Grab a pointer to the part that we will return to the caller
    //
    MEMORY_COPY(
        &(localStack->Stack[ localStack->TopOfStack] ),
        String,
        StringLength
        );

    //
    // Find the new Top of Stack
    //
    localStack->TopOfStack += StringLength;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StringStackRoot(
    IN  OUT PSTRING_STACK   *StringStack,
        OUT PUCHAR          *RootElement
    )
/*++

Routine Description:

    This routine returns the topmost stack location that is in current use

Arguments:

    Stack       - Where the stack is located
    RootElement - Where to store the pointer to the root stack element

Return Value:

    NTSTATUS

--*/
{
    ASSERT( StringStack != NULL && *StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );

    //
    // Grab the top stack location
    //
    *RootElement = (PUCHAR) (*StringStack)->Stack;

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm\ustring.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ustring.h

Abstract:

    The stack string portion of the un-assembler

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _USTRING_H_
#define _USTRING_H_

    NTSTATUS
    StringStackAllocate(
        OUT     PSTRING_STACK   *StringStack
        );

    NTSTATUS
    StringStackClear(
        IN  OUT PSTRING_STACK   *StringStack
        );

    NTSTATUS
    StringStackFree(
        IN  OUT PSTRING_STACK   *StringStack
        );

    NTSTATUS
    StringStackPop(
        IN  OUT PSTRING_STACK   *StringStack,
        IN      ULONG           NumBytes,
            OUT PUCHAR          *String
        );

    NTSTATUS
    StringStackPush(
        IN  OUT PSTRING_STACK   *StringStack,
        IN      ULONG           StringLength,
        IN      PUCHAR          String
        );

    NTSTATUS
    StringStackRoot(
        IN  OUT PSTRING_STACK   *StringStack,
            OUT PUCHAR          *RootElement
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\data.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DATA_H
#define _DATA_H

extern ASLTERM  TermTable[];
extern UCHAR    OpClassTable[];
extern OPMAP    ExOpClassTable[];

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\debug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef DBG
#define ENTER(x)    DebugEnterProcedure x
#define EXIT(x)     DebugExitProcedure x
#else
#define ENTER(x)
#define EXIT(x)
#endif

VOID
CDECL
DebugEnterProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    );

VOID
CDECL
DebugExitProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\list.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.c

Abstract:

    List Entry manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

VOID
LOCAL
ListRemoveEntry(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove an Entry from the list

Arguments:

    List        - Entry to be removed
    ListHead    - List to be removed from

Return Value:

    None

--*/
{
    ASSERT(ListHead);

    ASSERT(List != NULL);
    if (List->ListNext == List) {

        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(List == *ListHead);
        *ListHead = NULL;

    } else {

        if (List == *ListHead) {

            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *ListHead = (*ListHead)->ListNext;

        }
        List->ListNext->ListPrev = List->ListPrev;
        List->ListPrev->ListNext = List->ListNext;

    }

}

PLIST
LOCAL
ListRemoveHead(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the head entry of the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    list = *ListHead;
    if ( list != NULL) {

        ListRemoveEntry(list, ListHead);

    }
    return list;

}

PLIST
LOCAL
ListRemoveTail(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the tail entry from the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    if (*ListHead == NULL) {

        list = NULL;

    } else {

        //
        // List is not empty, so find the tail.
        //
        list = (*ListHead)->ListPrev;
        ListRemoveEntry(list, ListHead);

    }
    return list;

}

VOID
LOCAL
ListInsertHead(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the head of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    ListInsertTail(List, ListHead);
    *ListHead = List;
}

VOID
LOCAL
ListInsertTail(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the tail of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    if (*ListHead == NULL) {

        //
        // List is empty, so this becomes the head.
        //
        *ListHead = List;
        List->ListPrev = List->ListNext = List;

    } else {

        List->ListNext = *ListHead;
        List->ListPrev = (*ListHead)->ListPrev;
        (*ListHead)->ListPrev->ListNext = List;
        (*ListHead)->ListPrev = List;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\acpiuasm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    apciuasm.c

Abstract:

    This unassembles an AML file

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <memory.h>
#include <crt\io.h>
#include <fcntl.h>
#include <windows.h>
#include <windef.h>

#define SPEC_VER    100
#include "acpitabl.h"
#include "unasmdll.h"
#include "parsearg.h"

ULONG   ParseOutput( PUCHAR *Argument, PARGTYPE TableEntry );
ULONG   PrintHelp(PUCHAR    *Argument, PARGTYPE TableEntry );
VOID    PrintOutput(PCCHAR  Format, ... );

ARGTYPE ArgTypes[] = {
    { "?",  AT_ACTION,  0,              PrintHelp,              0, NULL },
    { "Fo", AT_ACTION,  PF_SEPARATOR,   ParseOutput,            0, NULL },
    { "" ,  0,          0,              0,                      0, NULL }
};
#pragma warning(default: 4054)
PROGINFO    ProgInfo = { NULL, NULL, NULL, NULL };
FILE *outputHandle;

int
__cdecl
main(
    IN  int     argc,
    IN  char    *argv[]
    )
/*++

Routine Description:

    This routine unassembles and displays a file

Arguments:

    argc    - Number of Arguments
    argv    - Array of Arruments

Return Value:

    int

--*/
{
    int         rc;
    int         handle;
    NTSTATUS    result;
    PUCHAR      byte = NULL;
    ULONG       length;
    ULONG       readLength;

    outputHandle = stdout;

    //
    // Beging by initializing the program information
    //
    ParseProgramInfo( argv[0], &ProgInfo );
    argv++;
    argc--;

    //
    // Parse all the switches away
    //
    if (ParseSwitches( &argc, &argv, ArgTypes, &ProgInfo) != ARGERR_NONE ||
        argc != 1) {

        PrintHelp( NULL, NULL );
        return 0;

    }

    //
    // Open the remaining argument as our input file
    //
    handle = _open( argv[0], _O_BINARY | _O_RDONLY);
    if (handle == -1) {

        fprintf( stderr, "%s: Failed to open AML file - %s\n",
            ProgInfo.ProgName, argv[0] );
        return -1;

    }

    byte = malloc( sizeof(DESCRIPTION_HEADER) );
    if (byte == NULL) {

        fprintf( stderr, "%s: Failed to allocate description header block\n",
            ProgInfo.ProgName );
        return -2;

    }

    rc = _read( handle, byte, sizeof(DESCRIPTION_HEADER) );
    if (rc != sizeof(DESCRIPTION_HEADER) ) {

        fprintf( stderr, "%s: Failed to read description header block\n",
            ProgInfo.ProgName );
        return -3;

    }

    rc = _lseek( handle, 0, SEEK_SET);
    if (rc == -1) {

        fprintf( stderr, "%s: Failed seeking to beginning of file\n",
            ProgInfo.ProgName );
        return -4;

    }

    length = ( (PDESCRIPTION_HEADER) byte)->Length;
    free (byte);

    byte = malloc( length );
    if (byte == NULL) {

        fprintf( stderr, "%s: Failed to allocate AML file buffer\n",
            ProgInfo.ProgName );
        return -5;

    }

    readLength = (ULONG) _read( handle, byte, length );
    if (readLength != length) {

        fprintf( stderr, "%s: failed to read AML file\n",
            ProgInfo.ProgName );
        return - 6;

    }

    result = UnAsmLoadDSDT( byte );
    if (result == 0) {

        result = UnAsmDSDT( byte, PrintOutput, 0, 0 );

    }

    if (result != 0) {

        fprintf(stderr, "%s: result = 0x%08lx\n",
            ProgInfo.ProgName, result );

    }

    if (byte) {

        free(byte);

    }
    if (handle) {

        _close(handle);

    }

    return 0;
}

ULONG
ParseOutput(
    PUCHAR      *Argument,
    PARGTYPE    TableEntry
    )
/*++

Routine Description:

    This routine is called if the user specifies a different file to output
    things to

Arguments:

    Argument    - Pointer to the string
    TableEntry  - Which table entry was matched

Return Value:

    ULONG

--*/
{
    if (*Argument == '\0') {

        return ARGERR_INVALID_TAIL;

    }

    outputHandle = fopen( *Argument, "w" );
    if (outputHandle == NULL) {

        fprintf( stderr, "Failed to open AML file - %s\n", *Argument );
        return ARGERR_INVALID_TAIL;

    }
    return ARGERR_NONE;
}

ULONG
PrintHelp(
    PUCHAR      *Argument,
    PARGTYPE    TableEntry
    )
/*++

Routine Description:

    Print the help for the function

Arguments:

    Argument    - Pointer to the string
    TableEntry  - Which table entry was matched

Return Value:

    ULONG
--*/
{
    if (Argument != NULL) {

        printf("Error on Argument - \"%s\"\n", *Argument );

    }
    printf("Usage:\t%s /?\n", ProgInfo.ProgName );
    printf("\t%s [/Fo=<ASLFile>] <AMLFile>\n", ProgInfo.ProgName );
    printf("\t?             - Print this help message.\n");
    printf("\tFo=ASLFile    - Write output to ASLFile.\n");
    printf("\tAMLFile       - AML File to Unassemble\n");
    return ARGERR_NONE;
}

VOID
PrintOutput(
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine is called to display information to the user

Arguments:

    Format  - Character formating
    ...     - Arguments

Return Value:

    Null

--*/
{
    va_list marker;
    va_start( marker, Format );
    vfprintf( outputHandle, Format, marker );
    fflush( outputHandle );
    va_end( marker );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\data.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define NE      TF_CHECKNAME_EXIST      //check if name exists
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      TC_COMPILER_DIRECTIVE
#define FM      TC_FIELD_MACRO
#define CN      TC_CONST_NAME
#define SN      TC_SHORT_NAME
#define NS      TC_NAMESPACE_MODIFIER
#define DO      TC_DATA_OBJECT
#define KW      TC_KEYWORD
#define NO      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define RO      TC_REF_OBJECT
#define PM      TC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

//
// Field flags
//
#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define ABLK    (ACCTYPE_BLOCK | (ACCTYPE_MASK << 8))
#define ASSR    (ACCTYPE_SMBSENDRECV | (ACCTYPE_MASK << 8))
#define ASQ     (ACCTYPE_SMBQUICK | (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

//
// Ids
//
// Identifier token values
#define ID_LANG                 0
#define ID_DEFBLK               (ID_LANG + 0)
#define ID_INCLUDE              (ID_LANG + 1)
#define ID_EXTERNAL             (ID_LANG + 2)

#define ID_ZERO                 (ID_LANG + 100)
#define ID_ONE                  (ID_LANG + 101)
#define ID_ONES                 (ID_LANG + 102)
#define ID_REVISION             (ID_LANG + 103)
#define ID_ARG0                 (ID_LANG + 104)
#define ID_ARG1                 (ID_LANG + 105)
#define ID_ARG2                 (ID_LANG + 106)
#define ID_ARG3                 (ID_LANG + 107)
#define ID_ARG4                 (ID_LANG + 108)
#define ID_ARG5                 (ID_LANG + 109)
#define ID_ARG6                 (ID_LANG + 110)
#define ID_LOCAL0               (ID_LANG + 111)
#define ID_LOCAL1               (ID_LANG + 112)
#define ID_LOCAL2               (ID_LANG + 113)
#define ID_LOCAL3               (ID_LANG + 114)
#define ID_LOCAL4               (ID_LANG + 115)
#define ID_LOCAL5               (ID_LANG + 116)
#define ID_LOCAL6               (ID_LANG + 117)
#define ID_LOCAL7               (ID_LANG + 118)
#define ID_DEBUG                (ID_LANG + 119)

#define ID_ALIAS                (ID_LANG + 200)
#define ID_NAME                 (ID_LANG + 201)
#define ID_SCOPE                (ID_LANG + 202)

#define ID_BUFFER               (ID_LANG + 300)
#define ID_PACKAGE              (ID_LANG + 301)
#define ID_EISAID               (ID_LANG + 302)

#define ID_ANYACC               (ID_LANG + 400)
#define ID_BYTEACC              (ID_LANG + 401)
#define ID_WORDACC              (ID_LANG + 402)
#define ID_DWORDACC             (ID_LANG + 403)
#define ID_BLOCKACC             (ID_LANG + 404)
#define ID_SMBSENDRCVACC        (ID_LANG + 405)
#define ID_SMBQUICKACC          (ID_LANG + 406)
#define ID_LOCK                 (ID_LANG + 407)
#define ID_NOLOCK               (ID_LANG + 408)
#define ID_PRESERVE             (ID_LANG + 409)
#define ID_WRONES               (ID_LANG + 410)
#define ID_WRZEROS              (ID_LANG + 411)
#define ID_SYSMEM               (ID_LANG + 412)
#define ID_SYSIO                (ID_LANG + 413)
#define ID_PCICFG               (ID_LANG + 414)
#define ID_EMBCTRL              (ID_LANG + 415)
#define ID_SMBUS                (ID_LANG + 416)
#define ID_SERIALIZED           (ID_LANG + 417)
#define ID_NOTSERIALIZED        (ID_LANG + 418)
#define ID_MTR                  (ID_LANG + 419)
#define ID_MEQ                  (ID_LANG + 420)
#define ID_MLE                  (ID_LANG + 421)
#define ID_MLT                  (ID_LANG + 422)
#define ID_MGE                  (ID_LANG + 423)
#define ID_MGT                  (ID_LANG + 424)
#define ID_EDGE                 (ID_LANG + 425)
#define ID_LEVEL                (ID_LANG + 426)
#define ID_ACTIVEHI             (ID_LANG + 427)
#define ID_ACTIVELO             (ID_LANG + 428)
#define ID_SHARED               (ID_LANG + 429)
#define ID_EXCLUSIVE            (ID_LANG + 430)
#define ID_COMPAT               (ID_LANG + 431)
#define ID_TYPEA                (ID_LANG + 432)
#define ID_TYPEB                (ID_LANG + 433)
#define ID_TYPEF                (ID_LANG + 434)
#define ID_BUSMASTER            (ID_LANG + 435)
#define ID_NOTBUSMASTER         (ID_LANG + 436)
#define ID_TRANSFER8            (ID_LANG + 437)
#define ID_TRANSFER8_16         (ID_LANG + 438)
#define ID_TRANSFER16           (ID_LANG + 439)
#define ID_DECODE16             (ID_LANG + 440)
#define ID_DECODE10             (ID_LANG + 441)
#define ID_READWRITE            (ID_LANG + 442)
#define ID_READONLY             (ID_LANG + 443)
#define ID_RESCONSUMER          (ID_LANG + 444)
#define ID_RESPRODUCER          (ID_LANG + 445)
#define ID_SUBDECODE            (ID_LANG + 446)
#define ID_POSDECODE            (ID_LANG + 447)
#define ID_MINFIXED             (ID_LANG + 448)
#define ID_MINNOTFIXED          (ID_LANG + 449)
#define ID_MAXFIXED             (ID_LANG + 450)
#define ID_MAXNOTFIXED          (ID_LANG + 451)
#define ID_CACHEABLE            (ID_LANG + 452)
#define ID_WRCOMBINING          (ID_LANG + 453)
#define ID_PREFETCHABLE         (ID_LANG + 454)
#define ID_NONCACHEABLE         (ID_LANG + 455)
#define ID_ISAONLYRNG           (ID_LANG + 456)
#define ID_NONISAONLYRNG        (ID_LANG + 457)
#define ID_ENTIRERNG            (ID_LANG + 458)
#define ID_EXT_EDGE             (ID_LANG + 459)
#define ID_EXT_LEVEL            (ID_LANG + 460)
#define ID_EXT_ACTIVEHI         (ID_LANG + 461)
#define ID_EXT_ACTIVELO         (ID_LANG + 462)
#define ID_EXT_SHARED           (ID_LANG + 463)
#define ID_EXT_EXCLUSIVE        (ID_LANG + 464)
#define ID_UNKNOWN_OBJ          (ID_LANG + 465)
#define ID_INT_OBJ              (ID_LANG + 466)
#define ID_STR_OBJ              (ID_LANG + 467)
#define ID_BUFF_OBJ             (ID_LANG + 468)
#define ID_PKG_OBJ              (ID_LANG + 469)
#define ID_FIELDUNIT_OBJ        (ID_LANG + 470)
#define ID_DEV_OBJ              (ID_LANG + 471)
#define ID_EVENT_OBJ            (ID_LANG + 472)
#define ID_METHOD_OBJ           (ID_LANG + 473)
#define ID_MUTEX_OBJ            (ID_LANG + 474)
#define ID_OPREGION_OBJ         (ID_LANG + 475)
#define ID_POWERRES_OBJ         (ID_LANG + 476)
#define ID_THERMAL_OBJ          (ID_LANG + 477)
#define ID_BUFFFIELD_OBJ        (ID_LANG + 478)
#define ID_DDBHANDLE_OBJ        (ID_LANG + 479)

#define ID_OFFSET               (ID_LANG + 500)
#define ID_ACCESSAS             (ID_LANG + 501)

#define ID_BANKFIELD            (ID_LANG + 600)
#define ID_DEVICE               (ID_LANG + 601)
#define ID_EVENT                (ID_LANG + 602)
#define ID_FIELD                (ID_LANG + 603)
#define ID_IDXFIELD             (ID_LANG + 604)
#define ID_METHOD               (ID_LANG + 605)
#define ID_MUTEX                (ID_LANG + 606)
#define ID_OPREGION             (ID_LANG + 607)
#define ID_POWERRES             (ID_LANG + 608)
#define ID_PROCESSOR            (ID_LANG + 609)
#define ID_THERMALZONE          (ID_LANG + 610)

#define ID_BREAK                (ID_LANG + 700)
#define ID_BREAKPOINT           (ID_LANG + 701)
#define ID_BITFIELD             (ID_LANG + 702)
#define ID_BYTEFIELD            (ID_LANG + 703)
#define ID_DWORDFIELD           (ID_LANG + 704)
#define ID_CREATEFIELD          (ID_LANG + 705)
#define ID_WORDFIELD            (ID_LANG + 706)
#define ID_ELSE                 (ID_LANG + 707)
#define ID_FATAL                (ID_LANG + 708)
#define ID_IF                   (ID_LANG + 709)
#define ID_LOAD                 (ID_LANG + 710)
#define ID_NOP                  (ID_LANG + 711)
#define ID_NOTIFY               (ID_LANG + 712)
#define ID_RELEASE              (ID_LANG + 713)
#define ID_RESET                (ID_LANG + 714)
#define ID_RETURN               (ID_LANG + 715)
#define ID_SIGNAL               (ID_LANG + 716)
#define ID_SLEEP                (ID_LANG + 717)
#define ID_STALL                (ID_LANG + 718)
#define ID_UNLOAD               (ID_LANG + 719)
#define ID_WHILE                (ID_LANG + 720)

#define ID_ACQUIRE              (ID_LANG + 800)
#define ID_ADD                  (ID_LANG + 801)
#define ID_AND                  (ID_LANG + 802)
#define ID_CONCAT               (ID_LANG + 803)
#define ID_CONDREFOF            (ID_LANG + 804)
#define ID_DECREMENT            (ID_LANG + 805)
#define ID_DEREFOF              (ID_LANG + 806)
#define ID_DIVIDE               (ID_LANG + 807)
#define ID_FINDSETLBIT          (ID_LANG + 808)
#define ID_FINDSETRBIT          (ID_LANG + 809)
#define ID_FROMBCD              (ID_LANG + 810)
#define ID_INCREMENT            (ID_LANG + 811)
#define ID_INDEX                (ID_LANG + 812)
#define ID_LAND                 (ID_LANG + 813)
#define ID_LEQ                  (ID_LANG + 814)
#define ID_LG                   (ID_LANG + 815)
#define ID_LGEQ                 (ID_LANG + 816)
#define ID_LL                   (ID_LANG + 817)
#define ID_LLEQ                 (ID_LANG + 818)
#define ID_LNOT                 (ID_LANG + 819)
#define ID_LNOTEQ               (ID_LANG + 820)
#define ID_LOR                  (ID_LANG + 821)
#define ID_MATCH                (ID_LANG + 822)
#define ID_MULTIPLY             (ID_LANG + 823)
#define ID_NAND                 (ID_LANG + 824)
#define ID_NOR                  (ID_LANG + 825)
#define ID_NOT                  (ID_LANG + 826)
#define ID_OBJTYPE              (ID_LANG + 827)
#define ID_OR                   (ID_LANG + 828)
#define ID_REFOF                (ID_LANG + 829)
#define ID_SHIFTL               (ID_LANG + 830)
#define ID_SHIFTR               (ID_LANG + 831)
#define ID_SIZEOF               (ID_LANG + 832)
#define ID_STORE                (ID_LANG + 833)
#define ID_SUBTRACT             (ID_LANG + 834)
#define ID_TOBCD                (ID_LANG + 835)
#define ID_WAIT                 (ID_LANG + 836)
#define ID_XOR                  (ID_LANG + 837)

#define ID_RESTEMP              (ID_LANG + 1000)
#define ID_STARTDEPFNNOPRI      (ID_LANG + 1001)
#define ID_STARTDEPFN           (ID_LANG + 1002)
#define ID_ENDDEPFN             (ID_LANG + 1003)
#define ID_IRQNOFLAGS           (ID_LANG + 1004)
#define ID_IRQ                  (ID_LANG + 1005)
#define ID_DMA                  (ID_LANG + 1006)
#define ID_IO                   (ID_LANG + 1007)
#define ID_FIXEDIO              (ID_LANG + 1008)
#define ID_VENDORSHORT          (ID_LANG + 1009)
#define ID_MEMORY24             (ID_LANG + 1010)
#define ID_VENDORLONG           (ID_LANG + 1011)
#define ID_MEMORY32             (ID_LANG + 1012)
#define ID_MEMORY32FIXED        (ID_LANG + 1013)
#define ID_DWORDMEMORY          (ID_LANG + 1014)
#define ID_DWORDIO              (ID_LANG + 1015)
#define ID_WORDIO               (ID_LANG + 1016)
#define ID_WORDBUSNUMBER        (ID_LANG + 1017)
#define ID_INTERRUPT            (ID_LANG + 1018)
#define ID_QWORDMEMORY          (ID_LANG + 1019)
#define ID_QWORDIO              (ID_LANG + 1020)

//
// Operation region space
//
#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

//
// Method flags
//
#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

//
// Match operation values
//
#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  ID_DEFBLK,       CD, 0, OP_NONE,     NULL, "ZZBZZD", NULL, OL|CL|LL|AF|AV, NULL,
    "Include",          ID_INCLUDE,      CD, 0, OP_NONE,     NULL, "Z",      NULL, AF, NULL,
    "External",         ID_EXTERNAL,     CD, 0, OP_NONE,     NULL, "Nk",     "uX", AF, NULL,

    // Short Objects
    "Zero",             ID_ZERO,         CN, 0, OP_ZERO,     NULL, NULL, NULL, 0, NULL,
    "One",              ID_ONE,          CN, 0, OP_ONE,      NULL, NULL, NULL, 0, NULL,
    "Ones",             ID_ONES,         CN, 0, OP_ONES,     NULL, NULL, NULL, 0, NULL,
    "Revision",         ID_REVISION,     CN, 0, OP_REVISION, NULL, NULL, NULL, 0, NULL,
    "Arg0",             ID_ARG0,         SN, 0, OP_ARG0,     NULL, NULL, NULL, 0, NULL,
    "Arg1",             ID_ARG1,         SN, 0, OP_ARG1,     NULL, NULL, NULL, 0, NULL,
    "Arg2",             ID_ARG2,         SN, 0, OP_ARG2,     NULL, NULL, NULL, 0, NULL,
    "Arg3",             ID_ARG3,         SN, 0, OP_ARG3,     NULL, NULL, NULL, 0, NULL,
    "Arg4",             ID_ARG4,         SN, 0, OP_ARG4,     NULL, NULL, NULL, 0, NULL,
    "Arg5",             ID_ARG5,         SN, 0, OP_ARG5,     NULL, NULL, NULL, 0, NULL,
    "Arg6",             ID_ARG6,         SN, 0, OP_ARG6,     NULL, NULL, NULL, 0, NULL,
    "Local0",           ID_LOCAL0,       SN, 0, OP_LOCAL0,   NULL, NULL, NULL, 0, NULL,
    "Local1",           ID_LOCAL1,       SN, 0, OP_LOCAL1,   NULL, NULL, NULL, 0, NULL,
    "Local2",           ID_LOCAL2,       SN, 0, OP_LOCAL2,   NULL, NULL, NULL, 0, NULL,
    "Local3",           ID_LOCAL3,       SN, 0, OP_LOCAL3,   NULL, NULL, NULL, 0, NULL,
    "Local4",           ID_LOCAL4,       SN, 0, OP_LOCAL4,   NULL, NULL, NULL, 0, NULL,
    "Local5",           ID_LOCAL5,       SN, 0, OP_LOCAL5,   NULL, NULL, NULL, 0, NULL,
    "Local6",           ID_LOCAL6,       SN, 0, OP_LOCAL6,   NULL, NULL, NULL, 0, NULL,
    "Local7",           ID_LOCAL7,       SN, 0, OP_LOCAL7,   NULL, NULL, NULL, 0, NULL,
    "Debug",            ID_DEBUG,        SN, 0, OP_DEBUG,    NULL, NULL, NULL, 0, NULL,

    // Named Terms
    "Alias",            ID_ALIAS,        NS, 0, OP_ALIAS,    "NN", "NN", "Ua", 0, NULL,
    "Name",             ID_NAME,         NS, 0, OP_NAME,     "NO", "NO", "u",  0, NULL,
    "Scope",            ID_SCOPE,        NS, 0, OP_SCOPE,    "N",  "N",  "S",  OL|LN, NULL,

    // Data Objects
    "Buffer",           ID_BUFFER,       DO, 0, OP_BUFFER,   "C", "c",  "U",  DL|LN, NULL,
    "Package",          ID_PACKAGE,      DO, 0, OP_PACKAGE,  "B", "b",  NULL, PL|LN, NULL,
    "EISAID",           ID_EISAID,       DO, 0, OP_DWORD,    NULL,"Z",  NULL, AF, NULL,

    // Argument Keywords
    "AnyAcc",           ID_ANYACC,       KW, AANY, OP_NONE, NULL, NULL, "A", 0, NULL,
    "ByteAcc",          ID_BYTEACC,      KW, AB,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "WordAcc",          ID_WORDACC,      KW, AW,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "DWordAcc",         ID_DWORDACC,     KW, ADW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "BlockAcc",         ID_BLOCKACC,     KW, ABLK, OP_NONE, NULL, NULL, "A", 0, NULL,
    "SMBSendRecvAcc",   ID_SMBSENDRCVACC,KW, ASSR, OP_NONE, NULL, NULL, "A", 0, NULL,
    "SMBQuickAcc",      ID_SMBQUICKACC,  KW, ASQ,  OP_NONE, NULL, NULL, "A", 0, NULL,

    "Lock",             ID_LOCK,         KW, LK,   OP_NONE, NULL, NULL, "B", 0, NULL,
    "NoLock",           ID_NOLOCK,       KW, NOLK, OP_NONE, NULL, NULL, "B", 0, NULL,

    "Preserve",         ID_PRESERVE,     KW, PSRV, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsOnes",      ID_WRONES,       KW, WA1S, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsZeros",     ID_WRZEROS,      KW, WA0S, OP_NONE, NULL, NULL, "C", 0, NULL,

    "SystemMemory",     ID_SYSMEM,       KW, MEM,  OP_NONE, NULL, NULL, "D", 0, NULL,
    "SystemIO",         ID_SYSIO,        KW, IO,   OP_NONE, NULL, NULL, "D", 0, NULL,
    "PCI_Config",       ID_PCICFG,       KW, CFG,  OP_NONE, NULL, NULL, "D", 0, NULL,
    "EmbeddedControl",  ID_EMBCTRL,      KW, EC,   OP_NONE, NULL, NULL, "D", 0, NULL,
    "SMBus",            ID_SMBUS,        KW, SMB,  OP_NONE, NULL, NULL, "D", 0, NULL,

    "Serialized",       ID_SERIALIZED,   KW, SER,  OP_NONE, NULL, NULL, "E", 0, NULL,
    "NotSerialized",    ID_NOTSERIALIZED,KW, NOSER,OP_NONE, NULL, NULL, "E", 0, NULL,

    "MTR",              ID_MTR,          KW, OMTR, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MEQ",              ID_MEQ,          KW, OMEQ, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLE",              ID_MLE,          KW, OMLE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLT",              ID_MLT,          KW, OMLT, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGE",              ID_MGE,          KW, OMGE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGT",              ID_MGT,          KW, OMGT, OP_NONE, NULL, NULL, "F", 0, NULL,

    "Edge",             ID_EDGE,         KW, _HE,  OP_NONE, NULL, NULL, "G", 0, NULL,
    "Level",            ID_LEVEL,        KW, _LL,  OP_NONE, NULL, NULL, "G", 0, NULL,

    "ActiveHigh",       ID_ACTIVEHI,     KW, _HE,  OP_NONE, NULL, NULL, "H", 0, NULL,
    "ActiveLow",        ID_ACTIVELO,     KW, _LL,  OP_NONE, NULL, NULL, "H", 0, NULL,

    "Shared",           ID_SHARED,       KW, _SHR, OP_NONE, NULL, NULL, "I", 0, NULL,
    "Exclusive",        ID_EXCLUSIVE,    KW, _EXC, OP_NONE, NULL, NULL, "I", 0, NULL,

    "Compatibility",    ID_COMPAT,       KW, COMP, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeA",            ID_TYPEA,        KW, TYPA, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeB",            ID_TYPEB,        KW, TYPB, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeF",            ID_TYPEF,        KW, TYPF, OP_NONE, NULL, NULL, "J", 0, NULL,

    "BusMaster",        ID_BUSMASTER,    KW, BM,   OP_NONE, NULL, NULL, "K", 0, NULL,
    "NotBusMaster",     ID_NOTBUSMASTER, KW, NOBM, OP_NONE, NULL, NULL, "K", 0, NULL,

    "Transfer8",        ID_TRANSFER8,    KW, X8,   OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer8_16",     ID_TRANSFER8_16, KW, X816, OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer16",       ID_TRANSFER16,   KW, X16,  OP_NONE, NULL, NULL, "L", 0, NULL,

    "Decode16",         ID_DECODE16,     KW, DC16, OP_NONE, NULL, NULL, "M", 0, NULL,
    "Decode10",         ID_DECODE10,     KW, DC10, OP_NONE, NULL, NULL, "M", 0, NULL,

    "ReadWrite",        ID_READWRITE,    KW, _RW,  OP_NONE, NULL, NULL, "N", 0, NULL,
    "ReadOnly",         ID_READONLY,     KW, _ROM, OP_NONE, NULL, NULL, "N", 0, NULL,

    "ResourceConsumer", ID_RESCONSUMER,  KW, RCS,  OP_NONE, NULL, NULL, "O", 0, NULL,
    "ResourceProducer", ID_RESPRODUCER,  KW, RPD,  OP_NONE, NULL, NULL, "O", 0, NULL,

    "SubDecode",        ID_SUBDECODE,    KW, BSD,  OP_NONE, NULL, NULL, "P", 0, NULL,
    "PosDecode",        ID_POSDECODE,    KW, BPD,  OP_NONE, NULL, NULL, "P", 0, NULL,

    "MinFixed",         ID_MINFIXED,     KW, MIF,  OP_NONE, NULL, NULL, "Q", 0, NULL,
    "MinNotFixed",      ID_MINNOTFIXED,  KW, NMIF, OP_NONE, NULL, NULL, "Q", 0, NULL,

    "MaxFixed",         ID_MAXFIXED,     KW, MAF,  OP_NONE, NULL, NULL, "R", 0, NULL,
    "MaxNotFixed",      ID_MAXNOTFIXED,  KW, NMAF, OP_NONE, NULL, NULL, "R", 0, NULL,

    "Cacheable",        ID_CACHEABLE,    KW, CACH, OP_NONE, NULL, NULL, "S", 0, NULL,
    "WriteCombining",   ID_WRCOMBINING,  KW, WRCB, OP_NONE, NULL, NULL, "S", 0, NULL,
    "Prefetchable",     ID_PREFETCHABLE, KW, PREF, OP_NONE, NULL, NULL, "S", 0, NULL,
    "NonCacheable",     ID_NONCACHEABLE, KW, NCAC, OP_NONE, NULL, NULL, "S", 0, NULL,

    "ISAOnlyRanges",    ID_ISAONLYRNG,   KW, ISA,  OP_NONE, NULL, NULL, "T", 0, NULL,
    "NonISAOnlyRanges", ID_NONISAONLYRNG,KW, NISA, OP_NONE, NULL, NULL, "T", 0, NULL,
    "EntireRange",      ID_ENTIRERNG,    KW, ERNG, OP_NONE, NULL, NULL, "T", 0, NULL,

    "ExtEdge",          ID_EXT_EDGE,     KW, ($HGH | $EDG),  OP_NONE, NULL, NULL, "U", 0, NULL,
    "ExtLevel",         ID_EXT_LEVEL,    KW, ($LOW | $LVL),  OP_NONE, NULL, NULL, "U", 0, NULL,

    "ExtActiveHigh",    ID_EXT_ACTIVEHI, KW, ($HGH | $EDG),  OP_NONE, NULL, NULL, "V", 0, NULL,
    "ExtActiveLow",     ID_EXT_ACTIVELO, KW, ($LOW | $LVL),  OP_NONE, NULL, NULL, "V", 0, NULL,

    "ExtShared",        ID_EXT_SHARED,   KW, $SHR, OP_NONE, NULL, NULL, "W", 0, NULL,
    "ExtExclusive",     ID_EXT_EXCLUSIVE,KW, $EXC, OP_NONE, NULL, NULL, "W", 0, NULL,

    "UnknownObj",       ID_UNKNOWN_OBJ,  KW, UNK,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "IntObj",           ID_INT_OBJ,      KW, INT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "StrObj",           ID_STR_OBJ,      KW, STR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffObj",          ID_BUFF_OBJ,     KW, BUF,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PkgObj",           ID_PKG_OBJ,      KW, PKG,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "FieldUnitObj",     ID_FIELDUNIT_OBJ,KW, FDU,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DeviceObj",        ID_DEV_OBJ,      KW, DEV,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "EventObj",         ID_EVENT_OBJ,    KW, EVT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MethodObj",        ID_METHOD_OBJ,   KW, MET,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MutexObj",         ID_MUTEX_OBJ,    KW, MUT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "OpRegionObj",      ID_OPREGION_OBJ, KW, OPR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PowerResObj",      ID_POWERRES_OBJ, KW, PWR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "ThermalZoneObj",   ID_THERMAL_OBJ,  KW, THM,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffFieldObj",     ID_BUFFFIELD_OBJ,KW, BFD,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DDBHandleObj",     ID_DDBHANDLE_OBJ,KW, DDB,  OP_NONE, NULL, NULL, "X", 0, NULL,

    // Field Macros
    "Offset",           ID_OFFSET,       FM, 0, OP_NONE, NULL, "B",  NULL, 0,  NULL,
    "AccessAs",         ID_ACCESSAS,     FM, 0, 0x01,    NULL, "Kb", "A", AF, NULL,

    // Named Object Creators
    "BankField",        ID_BANKFIELD,    NO, 0, OP_BANKFIELD,  "NNCKkk","NNCKKK","OFUABC", FL|FM|LN|AF, NULL,
    "Device",           ID_DEVICE,       NO, 0, OP_DEVICE,     "N",    "N",      "d",      OL|LN, NULL,
    "Event",            ID_EVENT,        NO, 0, OP_EVENT,      "N",    "N",      "e",      0, NULL,
    "Field",            ID_FIELD,        NO, 0, OP_FIELD,      "NKkk", "NKKK",   "OABC",   FL|FM|LN|AF, NULL,
    "IndexField",       ID_IDXFIELD,     NO, 0, OP_IDXFIELD,   "NNKkk","NNKKK",  "FFABC",  FL|FM|LN|AF, NULL,
    "Method",           ID_METHOD,       NO, 0, OP_METHOD,     "NKk",  "Nbk",    "m!E",    CL|OL|LN|AF, NULL,
    "Mutex",            ID_MUTEX,        NO, 0, OP_MUTEX,      "NB",   "NB",     "x",      0,  NULL,
    "OperationRegion",  ID_OPREGION,     NO, 0, OP_OPREGION,   "NKCC", "NKCC",   "oDUU",   AF, NULL,
    "PowerResource",    ID_POWERRES,     NO, 0, OP_POWERRES,   "NBW",  "NBW",    "p",      OL|LN, NULL,
    "Processor",        ID_PROCESSOR,    NO, 0, OP_PROCESSOR,  "NBDB", "NBDB",   "c",      OL|LN, NULL,
    "ThermalZone",      ID_THERMALZONE,  NO, 0, OP_THERMALZONE,"N",    "N",      "t",      OL|LN, NULL,

    // Type 1 Opcode Terms
    "Break",            ID_BREAK,        C1, 0, OP_BREAK,       NULL,  NULL,  NULL, 0, NULL,
    "BreakPoint",       ID_BREAKPOINT,   C1, 0, OP_BREAKPOINT,  NULL,  NULL,  NULL, 0, NULL,
    "CreateBitField",   ID_BITFIELD,     C1, 0, OP_BITFIELD,    "CCN", "CPN", "UUb",0, NULL,
    "CreateByteField",  ID_BYTEFIELD,    C1, 0, OP_BYTEFIELD,   "CCN", "CMN", "UUb",0, NULL,
    "CreateDWordField", ID_DWORDFIELD,   C1, 0, OP_DWORDFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "CreateField",      ID_CREATEFIELD,  C1, 0, OP_CREATEFIELD, "CCCN","CPCN","UUUb",0,NULL,
    "CreateWordField",  ID_WORDFIELD,    C1, 0, OP_WORDFIELD,   "CCN", "CMN", "UUb",0, NULL,
    "Else",             ID_ELSE,         C1, 0, OP_ELSE,        NULL,  NULL,  NULL, AF|CL|LN, NULL,
    "Fatal",            ID_FATAL,        C1, 0, OP_FATAL,       "BDC", "BDC", "  U",0, NULL,
    "If",               ID_IF,           C1, 0, OP_IF,          "C",   "C",   "U",  CL|LN, NULL,
    "Load",             ID_LOAD,         C1, 0, OP_LOAD,        "NS",  "NS",  "UU", 0, NULL,
    "Noop",             ID_NOP,          C1, 0, OP_NOP,         NULL,  NULL,  NULL, 0, NULL,
    "Notify",           ID_NOTIFY,       C1, 0, OP_NOTIFY,      "SC",  "SC",  "UU", 0, NULL,
    "Release",          ID_RELEASE,      C1, 0, OP_RELEASE,     "S",   "S",   "X",  0, NULL,
    "Reset",            ID_RESET,        C1, 0, OP_RESET,       "S",   "S",   "E",  0, NULL,
    "Return",           ID_RETURN,       C1, 0, OP_RETURN,      "C",   "C",   "U",  0, NULL,
    "Signal",           ID_SIGNAL,       C1, 0, OP_SIGNAL,      "S",   "S",   "E",  0, NULL,
    "Sleep",            ID_SLEEP,        C1, 0, OP_SLEEP,       "C",   "C",   "U",  0, NULL,
    "Stall",            ID_STALL,        C1, 0, OP_STALL,       "C",   "C",   "U",  0, NULL,
    "Unload",           ID_UNLOAD,       C1, 0, OP_UNLOAD,      "S",   "S",   "U",  0, NULL,
    "While",            ID_WHILE,        C1, 0, OP_WHILE,       "C",   "C",   "U",  CL|LN, NULL,

    // Type 2 Opcode Terms
    "Acquire",          ID_ACQUIRE,      C2, 0, OP_ACQUIRE,     "SW",     "SW",     "X",  0, NULL,
    "Add",              ID_ADD,          C2, 0, OP_ADD,         "CCS",    "CCs",    "UUU",0, NULL,
    "And",              ID_AND,          C2, 0, OP_AND,         "CCS",    "CCs",    "UUU",0, NULL,
    "Concatenate",      ID_CONCAT,       C2, 0, OP_CONCAT,      "CCS",    "CCS",    "UUU",0, NULL,
    "CondRefOf",        ID_CONDREFOF,    C2, 0, OP_CONDREFOF,   "SS",     "SS",     "UU", 0, NULL,
    "Decrement",        ID_DECREMENT,    C2, 0, OP_DECREMENT,   "S",      "S",      "U",  0, NULL,
    "DerefOf",          ID_DEREFOF,      C2, 0, OP_DEREFOF,     "C",      "C",      "U",  0, NULL,
    "Divide",           ID_DIVIDE,       C2, 0, OP_DIVIDE,      "CCSS",   "CCss",   "UUUU",0,NULL,
    "FindSetLeftBit",   ID_FINDSETLBIT,  C2, 0, OP_FINDSETLBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FindSetRightBit",  ID_FINDSETRBIT,  C2, 0, OP_FINDSETRBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FromBCD",          ID_FROMBCD,      C2, 0, OP_FROMBCD,     "CS",     "Cs",     "UU", 0, NULL,
    "Increment",        ID_INCREMENT,    C2, 0, OP_INCREMENT,   "S",      "S",      "U",  0, NULL,
    "Index",            ID_INDEX,     RO|C2, 0, OP_INDEX,       "CCS",    "CMs",    "UUU",0, NULL,
    "LAnd",             ID_LAND,         C2, 0, OP_LAND,        "CC",     "CC",     "UU", 0, NULL,
    "LEqual",           ID_LEQ,          C2, 0, OP_LEQ,         "CC",     "CC",     "UU", 0, NULL,
    "LGreater",         ID_LG,           C2, 0, OP_LG,          "CC",     "CC",     "UU", 0, NULL,
    "LGreaterEqual",    ID_LGEQ,         C2, 0, OP_LGEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LLess",            ID_LL,           C2, 0, OP_LL,          "CC",     "CC",     "UU", 0, NULL,
    "LLessEqual",       ID_LLEQ,         C2, 0, OP_LLEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LNot",             ID_LNOT,         C2, 0, OP_LNOT,        "C",      "C",      "U",  0, NULL,
    "LNotEqual",        ID_LNOTEQ,       C2, 0, OP_LNOTEQ,      "CC",     "CC",     "UU", 0, NULL,
    "LOr",              ID_LOR,          C2, 0, OP_LOR,         "CC",     "CC",     "UU", 0, NULL,
    "Match",            ID_MATCH,        C2, 0, OP_MATCH,       "CKCKCC", "CKCKCC", "UFUFUU",AF,NULL,
    "Multiply",         ID_MULTIPLY,     C2, 0, OP_MULTIPLY,    "CCS",    "CCs",    "UUU",0, NULL,
    "NAnd",             ID_NAND,         C2, 0, OP_NAND,        "CCS",    "CCs",    "UUU",0, NULL,
    "NOr",              ID_NOR,          C2, 0, OP_NOR,         "CCS",    "CCs",    "UUU",0, NULL,
    "Not",              ID_NOT,          C2, 0, OP_NOT,         "CS",     "Cs",     "UU", 0, NULL,
    "ObjectType",       ID_OBJTYPE,      C2, 0, OP_OBJTYPE,     "S",      "S",      "U",  0, NULL,
    "Or",               ID_OR,           C2, 0, OP_OR,          "CCS",    "CCs",    "UUU",0, NULL,
    "RefOf",            ID_REFOF,        C2, 0, OP_REFOF,       "S",      "S",      "U",  0, NULL,
    "ShiftLeft",        ID_SHIFTL,       C2, 0, OP_SHIFTL,      "CCS",    "CCs",    "UUU",0, NULL,
    "ShiftRight",       ID_SHIFTR,       C2, 0, OP_SHIFTR,      "CCS",    "CCs",    "UUU",0, NULL,
    "SizeOf",           ID_SIZEOF,       C2, 0, OP_SIZEOF,      "S",      "S",      "U",  0, NULL,
    "Store",            ID_STORE,        C2, 0, OP_STORE,       "CS",     "CS",     "UU", 0, NULL,
    "Subtract",         ID_SUBTRACT,     C2, 0, OP_SUBTRACT,    "CCS",    "CCs",    "UUU",0, NULL,
    "ToBCD",            ID_TOBCD,        C2, 0, OP_TOBCD,       "CS",     "Cs",     "UU", 0, NULL,
    "Wait",             ID_WAIT,         C2, 0, OP_WAIT,        "SC",     "SC",     "E",  0, NULL,
    "XOr",              ID_XOR,          C2, 0, OP_XOR,         "CCS",    "CCs",    "UUU",0, NULL,

    // PNP Macros
    "ResourceTemplate", ID_RESTEMP,      DO, 0, OP_BUFFER, NULL, "",       NULL, ML|AF|AV|LN,NULL,
    "StartDependentFnNoPri",ID_STARTDEPFNNOPRI,PM,0,0x30,  NULL, "",       NULL, ML|AF,   NULL,
    "StartDependentFn", ID_STARTDEPFN,   PM, 0, 0x31,      NULL, "BB",     NULL, ML|AF,   NULL,
    "EndDependentFn",   ID_ENDDEPFN,     PM, 0, 0x38,      NULL, "",       NULL, AF,      NULL,
    "IRQNoFlags",       ID_IRQNOFLAGS,   PM, 0, 0x22,      NULL, "r",      NULL, BL|AV,   NULL,
    "IRQ",              ID_IRQ,          PM, 0, 0x23,      NULL, "KKkr",   "GHI",BL|AV,   NULL,
    "DMA",              ID_DMA,          PM, 0, 0x2a,      NULL, "KKKr",   "JKL",BL|AV,   NULL,
    "IO",               ID_IO,           PM, 0, 0x47,      NULL, "KWWBBr", "M",  AF,      NULL,
    "FixedIO",          ID_FIXEDIO,      PM, 0, 0x4b,      NULL, "WBr",    NULL, AF,      NULL,
    "VendorShort",      ID_VENDORSHORT,  PM, 0, OP_NONE,   NULL, "r",      NULL, BL|AV,   NULL,
    "Memory24",         ID_MEMORY24,     PM, 0, 0x81,      NULL, "KWWWWr", "N",  AF,      NULL,
    "VendorLong",       ID_VENDORLONG,   PM, 0, 0x84,      NULL, "r",      NULL, BL|AV,   NULL,
    "Memory32",         ID_MEMORY32,     PM, 0, 0x85,      NULL, "KDDDDr", "N",  AF,      NULL,
    "Memory32Fixed",    ID_MEMORY32FIXED,PM, 0, 0x86,      NULL, "KDDr",   "N",  AF,      NULL,
    "DWORDMemory",      ID_DWORDMEMORY,  PM, 0, 0x87,      NULL, "kkkkkKDDDDDbzr","OPQRSN",AF,  NULL,
    "DWORDIO",          ID_DWORDIO,      PM, 0, 0x87,      NULL, "kkkkkDDDDDbzr", "OQRPT", AF,  NULL,
    "WORDIO",           ID_WORDIO,       PM, 0, 0x88,      NULL, "kkkkkWWWWWbzr", "OQRPT", AF,  NULL,
    "WORDBusNumber",    ID_WORDBUSNUMBER,PM, 0, 0x88,      NULL, "kkkkWWWWWbzr",  "OQRP",  AF,  NULL,
    "Interrupt",        ID_INTERRUPT,    PM, 0, 0x89,      NULL, "kKKkbzr",       "OGHI",DD|AV, NULL,
    "QWORDMemory",      ID_QWORDMEMORY,  PM, 0, 0x8a,      NULL, "kkkkkKQQQQQbzr","OPQRSN",AF,  NULL,
    "QWORDIO",          ID_QWORDIO,      PM, 0, 0x8a,      NULL, "kkkkkQQQQQbzr", "OQRPT", AF,  NULL,

    NULL,               0,               0,  0, OP_NONE,   NULL, NULL, NULL, 0, NULL
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

ULONG   globalDebugIndentLevel = 0;
ULONG   globalVerbosityLevel = 0;

VOID
CDECL
DebugEnterProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    entered

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    ULONG   i;
    va_list marker;

    if (VerbosityLevel <= globalVerbosityLevel) {

        for (i = 0 ; i < globalDebugIndentLevel ; i++) {

            fprintf( stderr, "| ");

        }
        va_start( marker, Format );
        vfprintf( stderr, Format, marker );
        fflush( stderr );
        va_end ( marker );

    }
    globalDebugIndentLevel++;
}

VOID
CDECL
DebugExitProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    exited

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    ULONG   i;
    va_list marker;

    globalDebugIndentLevel--;
    if (VerbosityLevel <= globalVerbosityLevel) {

        for (i = 0 ; i < globalDebugIndentLevel ; i++) {

            fprintf( stderr, "| ");

        }
        va_start( marker, Format );
        vfprintf( stderr, Format, marker );
        fflush( stderr );
        va_end ( marker );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\makefile.inc ===
$(O)\acpiuasm.res: acpiuasm.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\list.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.h

Abstract:

    List Entry Manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _LIST_H_
#define _LIST_H_

typedef struct _LIST {
    struct  _LIST   *ListPrev;
    struct  _LIST   *ListNext;
} LIST, *PLIST, **PPLIST;

VOID
LOCAL
ListRemoveEntry(
    PLIST   List,
    PPLIST  LIstHead
    );

PLIST
LOCAL
ListRemoveHead(
    PPLIST  ListHead
    );

PLIST
LOCAL
ListRemoveTail(
    PPLIST  ListHead
    );

VOID
LOCAL
ListInsertHead(
    PLIST   List,
    PPLIST  ListHead
    );

VOID
LOCAL
ListInsertTail(
    PLIST   List,
    PPLIST  ListHead
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\namespac.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.c

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

PNSOBJ  RootNameSpaceObject;
PNSOBJ  CurrentScopeNameSpaceObject;
PNSOBJ  CurrentOwnerNameSpaceObject;

NTSTATUS
LOCAL
CreateNameSpaceObject(
    PUCHAR  ObjectName,
    PNSOBJ  ObjectScope,
    PNSOBJ  ObjectOwner,
    PNSOBJ  *Object,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine creates a name space object under the current scope

Arguments:

    ObjectName  - Name Path String
    ObjectScope - Scope to start the search from (NULL == Root)
    ObjectOwner - The object which owns this one
    Object      - Where to store the point to the object that we just created
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        1,
        "CreateNameSpaceObject(%s,Scope=%s,Owner=%p,Object=%p,"
        "Flag=%08lx)\n",
        ObjectName,
        (ObjectScope ? GetObjectPath( ObjectScope ) : "ROOT"),
        ObjectOwner,
        Object,
        Flags
        ) );

    if (ObjectScope == NULL) {

        ObjectScope = RootNameSpaceObject;

    }

    status = GetNameSpaceObject(
        ObjectName,
        ObjectScope,
        &localObject,
        NSF_LOCAL_SCOPE
        );
    if (NT_SUCCESS(status)) {

        if (!(Flags & NSF_EXIST_OK)) {

            status = STATUS_OBJECT_NAME_COLLISION;

        }

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        status = STATUS_SUCCESS;

        //
        // Are we creating root?
        //
        if (strcmp(ObjectName,"\\") == 0) {

            ASSERT( RootNameSpaceObject == NULL );
            ASSERT( ObjectOwner == NULL );

            localObject = MEMALLOC( sizeof(NSOBJ) );
            if (localObject == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

                memset( localObject, 0, sizeof(NSOBJ) );
                localObject->Signature = SIG_NSOBJ;
                localObject->NameSeg = NAMESEG_ROOT;
                RootNameSpaceObject = localObject;

            }

        } else {

            PUCHAR  nameEnd;
            PNSOBJ  objectParent;

            nameEnd = strrchr(ObjectName, '.');
            if (nameEnd != NULL) {

                *nameEnd = '\0';
                nameEnd++;

                status = GetNameSpaceObject(
                    ObjectName,
                    ObjectScope,
                    &objectParent,
                    NSF_LOCAL_SCOPE
                    );

            } else if (*ObjectName == '\\') {

                nameEnd = &ObjectName[1];
                ASSERT( RootNameSpaceObject != NULL );
                objectParent = RootNameSpaceObject;

            } else if (*ObjectName == '^') {

                nameEnd = ObjectName;
                objectParent = ObjectScope;
                while ( (*nameEnd == '^') && (objectParent != NULL)) {

                    objectParent = objectParent->ParentObject;
                    nameEnd++;

                }

            } else {

                ASSERT( ObjectScope );
                nameEnd = ObjectName;
                objectParent = ObjectScope;

            }


            if (status == STATUS_SUCCESS) {

                ULONG   length = strlen(nameEnd);

                localObject = MEMALLOC( sizeof(NSOBJ) );

                if (localObject == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else if ( (*nameEnd != '\0') && (length > sizeof(NAMESEG))) {

                    status = STATUS_OBJECT_NAME_INVALID;
                    MEMFREE( localObject );

                } else {

                    memset( localObject, 0, sizeof(NSOBJ) );
                    localObject->Signature = SIG_NSOBJ;
                    localObject->NameSeg = NAMESEG_BLANK;
                    memcpy( &(localObject->NameSeg), nameEnd, length );
                    localObject->Owner = ObjectOwner;
                    localObject->ParentObject = objectParent;

                    ListInsertTail(
                        &(localObject->List),
                        (PPLIST) &(objectParent->FirstChild)
                        );

                }

            }

        }

    }


    if (NT_SUCCESS(status) && Object != NULL) {

        *Object = localObject;

    }

    EXIT( (
        1,
        "CreateNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );

    return status;
}

NTSTATUS
LOCAL
CreateObject(
    PUCHAR  ObjectName,
    UCHAR   ObjectType,
    PNSOBJ  *Object
    )
/*++

Routine Description:

    Creates a NameSpace Object for the term

Arguments:

    ObjectName  - The name object object
    ObjectType  - The type of object to create
    Object      - Where to store a pointer to the created object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        1,
        "CreateObject(%s,Type=%02x,Object=%p)\n",
        ObjectName,
        ObjectType,
        Object
        ) );

    status = CreateNameSpaceObject(
        ObjectName,
        CurrentScopeNameSpaceObject,
        CurrentOwnerNameSpaceObject,
        &localObject,
        NSF_EXIST_ERR
        );
    if (NT_SUCCESS(status)) {

        switch (ObjectType) {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                localObject->ObjectData.DataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                localObject->ObjectData.DataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                localObject->ObjectData.DataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                localObject->ObjectData.DataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                localObject->ObjectData.DataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                localObject->ObjectData.DataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                localObject->ObjectData.DataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                localObject->ObjectData.DataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                localObject->ObjectData.DataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                localObject->ObjectData.DataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                localObject->ObjectData.DataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        if (Object != NULL) {

            *Object = localObject;

        }


    }


    EXIT( (
        1,
        "CreateObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );
    return status;
}       //CreateObject

NTSTATUS
LOCAL
GetNameSpaceObject(
    PUCHAR  ObjectPath,
    PNSOBJ  ScopeObject,
    PNSOBJ  *NameObject,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine searches the namespace until it finds a matching object

Arguments:

    ObjectPath  - String with the Name to search for
    ScopeObject - Scope to start search at (NULL == ROOT)
    NameObject  - Where to store the object, if found
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      subPath;

    ENTER( (
        1,
        "GetNameSpaceObject(%s,Scope=%s,Object=%p,Flags=%08lx\n",
        ObjectPath,
        (ScopeObject ? GetObjectPath( ScopeObject ) : "ROOT"),
        NameObject,
        Flags
        ) );

    if (ScopeObject == NULL) {

        ScopeObject = RootNameSpaceObject;

    }


    if (*ObjectPath == '\\') {

        subPath = &ObjectPath[1];
        ScopeObject = RootNameSpaceObject;

    } else {

        subPath = ObjectPath;
        while ( (*subPath == '^') && (ScopeObject != NULL)) {

            subPath++;
            ScopeObject = ScopeObject->ParentObject;

        }

    }


    *NameObject = ScopeObject;
    if (ScopeObject == NULL) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else if (*subPath != '\0') {

        BOOL    searchUp;
        PNSOBJ  tempObject;

        searchUp = !(Flags & NSF_LOCAL_SCOPE) &&
            (ObjectPath[0] == '\\') &&
            (ObjectPath[0] == '^') &&
            (strlen(ObjectPath) <= sizeof(NAMESEG));

        while (1) {

            do {

                tempObject = ScopeObject->FirstChild;
                if (tempObject == NULL) {

                    status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    BOOL    found;
                    PUCHAR  bufferEnd;
                    ULONG   length;
                    NAMESEG nameSeg;

                    bufferEnd = strchr( subPath, '.' );
                    if (bufferEnd != NULL) {

                        length = (ULONG)(bufferEnd - subPath);

                    } else {

                        length = strlen(subPath);

                    }


                    if (length > sizeof(NAMESEG)) {

                        status = STATUS_OBJECT_NAME_INVALID;
                        found = FALSE;

                    } else {

                        nameSeg = NAMESEG_BLANK;
                        memcpy( &nameSeg, subPath, length );

                        //
                        // search all sibling fors a matching nameSeg
                        //
                        found = FALSE;
                        do {

                            if (tempObject->NameSeg == nameSeg) {

                                ScopeObject = tempObject;
                                found = TRUE;
                                break;

                            }

                            tempObject = (PNSOBJ) tempObject->List.ListNext;

                        } while (tempObject != tempObject->ParentObject->FirstChild );

                    }


                    if (status == STATUS_SUCCESS) {

                        if (!found) {

                            status = STATUS_OBJECT_NAME_NOT_FOUND;

                        } else {

                            subPath += length;
                            if (*subPath == '.') {

                                subPath++;

                            } else if (*subPath == '\0') {

                                *NameObject = ScopeObject;
                                break;

                            }

                        }

                    }

                }

            } while ( status == STATUS_SUCCESS );

            if (status == STATUS_OBJECT_NAME_NOT_FOUND && searchUp &&
                ScopeObject != NULL && ScopeObject->ParentObject != NULL) {

                ScopeObject = ScopeObject->ParentObject;
                status = STATUS_SUCCESS;

            } else {

                break;

            }

        }

    }


    if (status != STATUS_SUCCESS) {

        *NameObject = NULL;

    }


    EXIT( (
        1,
        "GetNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        *NameObject
        ) );
    return status;

}

PUCHAR
LOCAL
GetObjectPath(
    PNSOBJ  NameObject
    )
/*++

Routine Description:

    This routine takes a NameSpace Object and returns a string to represent
    its path

Arguments:

    NameObject  - The object whose path we want

Return Value:

    Pointer to the string which represents the path

--*/
{
    static UCHAR    namePath[MAX_NAME_LEN + 1] = {0};
    ULONG           i;

    ENTER( (4, "GetObjectPath(Object=%p)\n", NameObject ) );

    if (NameObject != NULL) {

        if (NameObject->ParentObject == NULL) {

            strcpy(namePath, "\\");

        } else {

            GetObjectPath(NameObject->ParentObject);
            if (NameObject->ParentObject->ParentObject != NULL) {

                strcat(namePath, ".");

            }
            strncat(namePath, (PUCHAR)&NameObject->NameSeg, sizeof(NAMESEG));

        }


        for (i = strlen(namePath) - 1; i >= 0; --i) {

            if (namePath[i] == '_') {

                namePath[i] = '\0';

            } else {

                break;

            }


        }

    } else {

        namePath[0] = '\0';

    }

    EXIT( (4, "GetObjectPath=%s\n", namePath ) );
    return namePath;
}

PUCHAR
LOCAL
GetObjectTypeName(
    ULONG   ObjectType
    )
/*++

Routine Description:

    Returns a string which corresponds to the type object the object

Arugment:

    ObjectType  - The type that we wish to know about

Return Value:

    Globally Available String

--*/
{
    PUCHAR  type = NULL;
    ULONG   i;
    static struct {
        ULONG   ObjectType;
        PUCHAR  ObjectTypeName;
    } ObjectTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            OBJTYPE_PNP_RES,    "PNPResource",
            OBJTYPE_RES_FIELD,  "ResField",
            0,                  NULL
        };

    ENTER( (4, "GetObjectTypeName(Type=%02x)\n", ObjectType ) );

    for (i = 0; ObjectTypeTable[i].ObjectTypeName != NULL; i++) {

        if (ObjectType == ObjectTypeTable[i].ObjectType) {

            type = ObjectTypeTable[i].ObjectTypeName;
            break;

        }

    }

    EXIT( (4, "GetObjectTypeName=%s\n", type ? type : "NULL" ) );
    return type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\namespac.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.h

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _NAMESPAC_H_
#define _NAMESPAC_H_

extern PNSOBJ   RootNameSpaceObject;
extern PNSOBJ   CurrentScopeNameSpaceObject;
extern PNSOBJ   CurrentOwnerNameSpaceObject;

NTSTATUS
LOCAL
CreateNameSpaceObject(
    PUCHAR  ObjectName,
    PNSOBJ  ObjectScope,
    PNSOBJ  ObjectOwner,
    PNSOBJ  *Object,
    ULONG   Flags
    );


NTSTATUS
LOCAL
CreateObject(
    PUCHAR  ObjectName,
    UCHAR   ObjectType,
    PNSOBJ  *Object
    );

NTSTATUS
LOCAL
GetNameSpaceObject(
    PUCHAR  ObjectPath,
    PNSOBJ  ScopeObject,
    PNSOBJ  *NameObject,
    ULONG   Flags
    );

PUCHAR
LOCAL
GetObjectPath(
    PNSOBJ  NameObject
    );

PUCHAR
LOCAL
GetObjectTypeName(
    ULONG   ObjectType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\parsearg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.c

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#include "pch.h"

//
// Local function prototypes
//
ULONG
LOCAL
ParseArgSwitch(
    PUCHAR      *Argument,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    );

VOID
LOCAL
PrintError(
    ULONG       ErrorCode,
    PUCHAR      Argument,
    PPROGINFO   ProgramInfo
    );

VOID
EXPORT
ParseProgramInfo(
    PUCHAR      ProgramName,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    This routine parses program path and module name

Arguments:

    ProgramName - The Argv[0] from main()
    ProgramInfo - Program Information structure

Return Value:

    None

--*/
{
    PUCHAR   ptr;

    ProgramInfo->ProgPath = _strlwr(ProgramName);
    ptr = strrchr( ProgramName, '\\' );
    if (ptr != NULL) {

        *ptr = '\0';
        ProgramInfo->ProgName = ptr + 1;

    } else {

        ProgramInfo->ProgName = ProgramName;

    }

    ptr = strchr(ProgramInfo->ProgName, '.');
    if (ptr != NULL) {

        *ptr = '\0';

    }
}

ULONG
EXPORT
ParseSwitches(
    PULONG      ArgumentCount,
    PUCHAR      **ArgumentList,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse command line switches

Arguments:

    ArgumentCount   - Pointer to the number of arguments
    ArgumentList    - Pointer to the pointer to the list of arguments
    ArgumentArray   - How to parse the arguments
    ProgramInfo     - Program Specific structure

Return Value:

    ULONG   - Success = ARGERR_NONE

--*/
{
    PUCHAR  argument;
    ULONG   status = ARGERR_NONE;

    if (ProgramInfo->SwitchChars == NULL) {

        ProgramInfo->SwitchChars = DEF_SWITCHCHARS;

    }
    if (ProgramInfo->Separators == NULL) {

        ProgramInfo->Separators = DEF_SEPARATORS;

    }

    for (; *ArgumentCount; (*ArgumentCount)--, (*ArgumentList)++)
    {
        argument = **ArgumentList;

        if (strchr(ProgramInfo->SwitchChars, *argument)) {

            argument++;
            status = ParseArgSwitch(
                &argument,
                ArgumentArray,
                ProgramInfo
                );
            if (status != ARGERR_NONE) {

                PrintError( status, argument, ProgramInfo );
                break;

            }

        } else {

            break;

        }

    }

    return status;
}

ULONG
LOCAL
ParseArgSwitch(
    PUCHAR      *Argument,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse a command line switch

Arguments

    Argument        - Pointer to argument
    ArgumentArray   - How to handle the argument
    ProgramInfo     - Program Information Structure

Return Value:

    ULONG

--*/
{
    BOOL        found = FALSE;
    PARGTYPE    tableEntry;
    PUCHAR      argumentEnd;
    ULONG       length = 0;
    ULONG       status = ARGERR_NONE;

    tableEntry = ArgumentArray;
    while (tableEntry->ArgID[0]) {

        length = strlen(tableEntry->ArgID);
        if (tableEntry->ParseFlags & PF_NOI) {

            found = (strncmp(tableEntry->ArgID, *Argument, length) == 0);

        } else {

            found = (_strnicmp(tableEntry->ArgID, *Argument, length) == 0);

        }

        if (found) {

            break;
        }
        tableEntry++;

    }

    if (found) {

        *Argument += length;
        switch (tableEntry->ArgType) {
            case AT_STRING:
            case AT_NUM:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }
                if (tableEntry->ArgType == AT_STRING) {

                    *(UCHAR **)tableEntry->ArgData = *Argument;

                } else {

                    *(ULONG *)tableEntry->ArgData = (ULONG)
                        strtoul(*Argument, &argumentEnd, tableEntry->ArgParam);
                    if (*Argument == argumentEnd) {

                        status = ARGERR_INVALID_NUM;
                        break;

                    }
                    *Argument = argumentEnd;

                }
                if (tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);

                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (tableEntry->ArgType == AT_ENABLE) {

                    *(ULONG *)tableEntry->ArgData |= tableEntry->ArgParam;

                } else {

                    *(ULONG *)tableEntry->ArgData &= ~tableEntry->ArgParam;

                }

                if ( tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);
                    if (status == ARGERR_NONE) {

                        break;

                    }

                }

                if (**Argument) {

                    if (strchr(ProgramInfo->SwitchChars, **Argument)) {

                        (*Argument)++;

                    }
                    status = ParseArgSwitch(
                        Argument,
                        ArgumentArray,
                        ProgramInfo
                        );

                }
                break;

            case AT_ACTION:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }

#pragma warning(disable: 4055)
                status = (*(PFNARG)tableEntry->ArgData)(Argument, tableEntry);
#pragma warning(default: 4055)

                break;

        }

    } else {

        status = ARGERR_UNKNOWN_SWITCH;

    }
    return status;
}

VOID
LOCAL
PrintError(
    ULONG       ErrorCode,
    PUCHAR      Argument,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Print Appropriate Error Message according to error code

Arguments:

    ErrorCode   - The error which occured
    Argument    - Argument in Error
    ProgramInfo - Program info structure

Return Value:

    VOID

--*/
{
    switch (ErrorCode) {
        case ARGERR_UNKNOWN_SWITCH:
            fprintf(
               stderr,
               "%s: unknown switch \"%s\"\n",
               ProgramInfo->ProgName,
               Argument
               );
            break;

        case ARGERR_NO_SEPARATOR:
            fprintf(
                stderr,
                "%s: separator missing after the switch char '%c'\n",
                ProgramInfo->ProgName,
                *(Argument-1)
                );
            break;

        case ARGERR_INVALID_NUM:
            fprintf(
                stderr,
                "%s: invalid numeric switch \"%s\"\n",
                ProgramInfo->ProgName,
                Argument
                );
            break;

        case ARGERR_INVALID_TAIL:
            fprintf(
                 stderr,
                 "%s: invalid argument tail \"%s\"\n",
                 ProgramInfo->ProgName,
                 Argument
                 );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\pch.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled Header for UnAssembler DLL

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>

#include <stdio.h>      //for FILE *
#include <string.h>     //for _stricmp
#include <stdlib.h>     //for malloc
#include <memory.h>     //for memset
#include <ctype.h>      //for isspace
#include <windef.h>
#include <windows.h>
#include <imagehlp.h>

#ifndef LOCAL
    #define LOCAL   __cdecl
#endif
#ifndef EXPORT
    #define EXPORT  __cdecl
#endif

//
// We are compliant with Spec Version 1.00
//
#define SPEC_VER    100

#include "acpitabl.h"
#include "list.h"
#include "aml.h"

//
// Constants
//

// String constants
#define STR_PROGDESC            "ACPI Source Language Assembler"
#define STR_COPYRIGHT           "Copyright (c) 1996,1997 Microsoft Corporation"
#define STR_MS                  "MSFT"

// Misc. constants
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
#define NAMESEG                 ULONG
#define SUPERNAME               NAMESEG
#define NSF_LOCAL_SCOPE         0x00000001


// Implementation constants
#define MAX_STRING_LEN          199
#define MAX_NAME_LEN            1599    //approx. 255*4 + 254 + 255
#define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
#define MAX_MSG_LEN             127
#define MAX_ARGS                7
#define MAX_PACKAGE_LEN         0x0fffffff

// Term classes
#define TC_PNP_MACRO            0x00100000
#define TC_REF_OBJECT           0x00200000
#define TC_FIELD_MACRO          0x00400000
#define TC_DATA_OBJECT          0x00800000
#define TC_NAMED_OBJECT         0x01000000
#define TC_NAMESPACE_MODIFIER   0x02000000
#define TC_OPCODE_TYPE1         0x04000000
#define TC_OPCODE_TYPE2         0x08000000
#define TC_CONST_NAME           0x10000000
#define TC_SHORT_NAME           0x20000000
#define TC_COMPILER_DIRECTIVE   0x40000000
#define TC_KEYWORD              0x80000000
#define TC_OPCODE               (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | TC_DATA_OBJECT)
#define TC_OPCODE_TERM          (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | \
                                 TC_DATA_OBJECT | TC_NAMED_OBJECT | \
                                 TC_NAMESPACE_MODIFIER)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHECKNAME_EXIST      0x00000008
#define TF_FIELD_MACRO          TC_FIELD_MACRO
#define TF_DATA_OBJECT          TC_DATA_OBJECT
#define TF_NAMED_OBJECT         TC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   TC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         TC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         TC_OPCODE_TYPE2
#define TF_CONST_NAME           TC_CONST_NAME
#define TF_SHORT_NAME           TC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   TC_COMPILER_DIRECTIVE
#define TF_KEYWORD              TC_KEYWORD
#define TF_PNP_MACRO            TC_PNP_MACRO
#define TF_OBJECT_LIST          (TC_NAMED_OBJECT | TC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (TC_DATA_OBJECT | TC_SHORT_NAME | \
                                 TC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

// Code flags
#define CF_MISSING_ARG          0x00000001
#define CF_PARSING_FIXEDLIST    0x00000002
#define CF_PARSING_VARLIST      0x00000004

// NS flags
#define NSF_EXIST_OK            0x00010000
#define NSF_EXIST_ERR           0x00020000

// Data types
#define CODETYPE_UNKNOWN        0
#define CODETYPE_ASLTERM        1
#define CODETYPE_NAME           2
#define CODETYPE_DATAOBJ        3
#define CODETYPE_FIELDOBJ       4
#define CODETYPE_INTEGER        5
#define CODETYPE_STRING         6
#define CODETYPE_KEYWORD        7
#define CODETYPE_USERTERM       8
#define CODETYPE_QWORD          9

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

#define OBJTYPE_PRIVATE         0xf0
#define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
#define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

//dwfData flags
#define DATAF_BUFF_ALIAS        0x00000001
#define DATAF_GLOBAL_LOCK       0x00000002

//dwDataType values
#define OBJTYPE_UNKNOWN         0x00
#define OBJTYPE_INTDATA         0x01
#define OBJTYPE_STRDATA         0x02
#define OBJTYPE_BUFFDATA        0x03
#define OBJTYPE_PKGDATA         0x04
#define OBJTYPE_FIELDUNIT       0x05
#define OBJTYPE_DEVICE          0x06
#define OBJTYPE_EVENT           0x07
#define OBJTYPE_METHOD          0x08
#define OBJTYPE_MUTEX           0x09
#define OBJTYPE_OPREGION        0x0a
#define OBJTYPE_POWERRES        0x0b
#define OBJTYPE_PROCESSOR       0x0c
#define OBJTYPE_THERMALZONE     0x0d
#define OBJTYPE_BUFFFIELD       0x0e
#define OBJTYPE_DDBHANDLE       0x0f

//These are internal object types (not to be exported to the ASL code)
#define OBJTYPE_INTERNAL        0x80
#define OBJTYPE_DEBUG           (OBJTYPE_INTERNAL + 0x00)
#define OBJTYPE_OBJALIAS        (OBJTYPE_INTERNAL + 0x01)
#define OBJTYPE_DATAALIAS       (OBJTYPE_INTERNAL + 0x02)
#define OBJTYPE_BANKFIELD       (OBJTYPE_INTERNAL + 0x03)
#define OBJTYPE_FIELD           (OBJTYPE_INTERNAL + 0x04)
#define OBJTYPE_INDEXFIELD      (OBJTYPE_INTERNAL + 0x05)
#define OBJTYPE_DATA            (OBJTYPE_INTERNAL + 0x06)
#define OBJTYPE_DATAFIELD       (OBJTYPE_INTERNAL + 0x07)
#define OBJTYPE_DATAOBJ         (OBJTYPE_INTERNAL + 0x08)

//Predefined data values (dwDataValue)
#define DATAVALUE_ZERO          0
#define DATAVALUE_ONE           1
#define DATAVALUE_ONES          0xffffffff

//
// Macros
//
#define MEMALLOC(n)           malloc(n)
#define MEMFREE(p)            free(p)

//
// Type definitions
//
typedef int (LOCAL *PFNTERM)(PUCHAR, BOOL);

typedef struct _ObjData
{
    ULONG  Flags;                       //flags
    ULONG  Alias;                       //ref count if base obj,
                                        //  points to base obj if alias obj
    ULONG  DataType;                    //object type
    ULONG  DataValue;                   //object value
    ULONG  DataLen;                     //object buffer length
    PUCHAR DataBuff;                    //object buffer
} OBJDATA, *POBJDATA, **PPOBJDATA;

typedef struct _NSObj
{
    LIST    List;                        //NOTE: list must be first in structure
    struct _NSObj *ParentObject;
    struct _NSObj *FirstChild;
    ULONG   Signature;
    ULONG   NameSeg;
    HANDLE  Owner;
    struct _NSObj *OwnedNext;
    OBJDATA ObjectData;
    ULONG   Context;
} NSOBJ, *PNSOBJ, **PPNSOBJ;

#define SIG_NSOBJ               'SNTM'

typedef struct _aslterm
{
    PUCHAR  ID;
    LONG    LongID;
    ULONG   TermClass;
    ULONG   TermData;
    ULONG   OpCode;
    PUCHAR  UnAsmArgTypes;
    PUCHAR  ArgTypes;
    PUCHAR  ArgActions;
    ULONG   Flags;
    PFNTERM Term;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    UCHAR   ExtendedOpCode;
    UCHAR   OpCodeClass;
} OPMAP, *POPMAP;

#include "data.h"
#include "debug.h"
#include "namespac.h"
#include "parsearg.h"
#include "unasm.h"

#endif  //ifndef _ASLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\wmiacpi\wmimap.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmimap.c

Abstract:

    ACPI to WMI mapping layer

Author:

    Alan Warwick

Environment:

    Kernel mode

Revision History:

--*/

#define INITGUID

#include <wdm.h>

#ifdef MEMPHIS
//
// Lifted from ntrtl.h
NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToAnsiSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToAnsiSize(STRING) (                  \
    NLS_MB_CODE_PAGE_TAG ?                                    \
    RtlxUnicodeStringToAnsiSize(STRING) :                     \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)
#endif

#include <devioctl.h>
#include <acpiioct.h>
#include <wmistr.h>
#include <wmilib.h>
#include <wdmguid.h>

#include "wmimap.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
WmiAcpiPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
WmiAcpiSystemControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WmiAcpiPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );


NTSTATUS
WmiAcpiForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
WmiAcpiUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
WmiAcpiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
WmiAcpiSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
WmiAcpiGetAcpiInterfaces(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
WmiAcpiCheckIncomingString(
    PUNICODE_STRING UnicodeString,
    ULONG BufferSize,
    PUCHAR Buffer,
    PWCHAR EmptyString
);

VOID
WmiAcpiNotificationWorkItem(
    IN PVOID Context
    );

VOID
WmiAcpiNotificationRoutine (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    );

CHAR WmiAcpiXtoA(
    UCHAR HexDigit
    );

NTSTATUS
WmiAcpiAsyncEvalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
WmiAcpiSendAsyncDownStreamIrp(
    IN  PDEVICE_OBJECT   DeviceObject,
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  ULONG            InputBufferSize,
    IN  ULONG            OutputBufferSize,
    IN  PVOID            Buffer,
    IN  PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN  PVOID CompletionContext,
    IN  PBOOLEAN IrpPassed
);

NTSTATUS
WmiAcpiSendDownStreamIrp(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            *OutputBufferSize
);

ULONG WmiAcpiArgumentSize(
    IN PACPI_METHOD_ARGUMENT Argument
    );

NTSTATUS WmiAcpiCopyArgument(
    OUT PUCHAR Buffer,
    IN ULONG BufferSize,
    IN PACPI_METHOD_ARGUMENT Argument
    );

NTSTATUS WmiAcpiProcessResult(
    IN NTSTATUS Status,
    IN PACPI_EVAL_OUTPUT_BUFFER OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PUCHAR ResultBuffer,
    OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiSendMethodEvalIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodInt(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN ULONG ResultBufferSize,
    IN PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PBOOLEAN IrpPassed
    );

NTSTATUS
WmiAcpiQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
WmiAcpiQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
WmiAcpiSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiAcpiSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiAcpiExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiAcpiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGE,WmiAcpiSystemControlDispatch)
#pragma alloc_text(PAGE,WmiAcpiPnP)
#pragma alloc_text(PAGE,WmiAcpiUnload)
#pragma alloc_text(PAGE,WmiAcpiAddDevice)

#pragma alloc_text(PAGE,WmiAcpiSynchronousRequest)
#pragma alloc_text(PAGE,WmiAcpiGetAcpiInterfaces)

#pragma alloc_text(PAGE,WmiAcpiNotificationWorkItem)

#pragma alloc_text(PAGE,WmiAcpiCheckIncomingString)
#pragma alloc_text(PAGE,WmiAcpiXtoA)
#pragma alloc_text(PAGE,WmiAcpiArgumentSize)
#pragma alloc_text(PAGE,WmiAcpiCopyArgument)
#pragma alloc_text(PAGE,WmiAcpiProcessResult)

#pragma alloc_text(PAGE,WmiAcpiSendDownStreamIrp)
#pragma alloc_text(PAGE,WmiAcpiSendMethodEvalIrp)
#pragma alloc_text(PAGE,WmiAcpiEvalMethod)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodInt)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntBuffer)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntIntBuffer)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntString)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntIntString)

#pragma alloc_text(PAGE,WmiAcpiQueryWmiRegInfo)
#pragma alloc_text(PAGE,WmiAcpiQueryWmiDataBlock)
#pragma alloc_text(PAGE,WmiAcpiSetWmiDataBlock)
#pragma alloc_text(PAGE,WmiAcpiSetWmiDataItem)
#pragma alloc_text(PAGE,WmiAcpiExecuteWmiMethod)
#pragma alloc_text(PAGE,WmiAcpiFunctionControl)
#endif

#if DBG
ULONG WmiAcpiDebug = 0;
#endif

UNICODE_STRING WmiAcpiRegistryPath;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Installable driver initialization entry point.
    This is where the driver is called when the driver is being loaded
    by the I/O system.  This entry point is called directly by the I/O system.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiDriverEntry: %x Enter\n",
                  DriverObject
                     ));

    //
    // Save registry path for registering with WMI
    WmiAcpiRegistryPath.Length = 0;
    WmiAcpiRegistryPath.MaximumLength = RegistryPath->Length;
    WmiAcpiRegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool,
                                           RegistryPath->Length+sizeof(WCHAR),
                            WmiAcpiPoolTag);
    if (WmiAcpiRegistryPath.Buffer != NULL)
    {
        RtlCopyUnicodeString(&WmiAcpiRegistryPath, RegistryPath);
    }

    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverUnload                          = WmiAcpiUnload;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = WmiAcpiForwardIrp;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = WmiAcpiForwardIrp;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = WmiAcpiForwardIrp;

    DriverObject->MajorFunction[IRP_MJ_POWER]           = WmiAcpiPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = WmiAcpiPnP;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = WmiAcpiSystemControlDispatch;
    DriverObject->DriverExtension->AddDevice            = WmiAcpiAddDevice;


    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiDriverEntry: %x Return %x\n", DriverObject, ntStatus));

    return(ntStatus);
}

NTSTATUS
WmiAcpiPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiPowerDispatch: %x Irp %x, Minor Function %x, Parameters %x %x %x %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    deviceExtension = DeviceObject->DeviceExtension;

    PoStartNextPowerIrp( Irp );
    if (deviceExtension->LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( deviceExtension->LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return(status);
}

NTSTATUS
WmiAcpiSystemControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PWMILIB_CONTEXT wmilibContext;
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiSystemControl: %x Irp %x, Minor Function %x, Provider Id %x, DataPath %x, BufferSize %x, Buffer %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    status = WmiSystemControl(wmilibContext,
                              DeviceObject,
                              Irp,
                              &disposition);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiSystemControl: %x Irp %x returns %x, disposition %d\n",
                  DeviceObject,
                  Irp,
                  status,
                  disposition));

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            status = WmiAcpiForwardIrp(DeviceObject, Irp);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            status = WmiAcpiForwardIrp(DeviceObject,
                                       Irp);
            break;
        }
    }

    return(status);
}

NTSTATUS
WmiAcpiPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description:
    Process the IRPs sent to this device.

Arguments:
    DeviceObject - pointer to a device object
    Irp          - pointer to an I/O Request Packet

Return Value:
    NTSTATUS
--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PWMILIB_CONTEXT wmilibContext;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiPnp: %x Irp %x, Minor Function %x, Parameters %x %x %x %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    switch (irpSp->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
        {
            status = IoWMIRegistrationControl(DeviceObject,
                                              WMIREG_ACTION_REGISTER);
            if (! NT_SUCCESS(status))
            {
                //
                // If registration with WMI fails then there is no point
                // in starting the device.
                WmiAcpiPrint(WmiAcpiError,
                             ("WmiAcpiPnP: %x IoWMIRegister failed %x\n",
                              DeviceObject,
                              status));
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(status);
            } else {
                deviceExtension->Flags |= DEVFLAG_WMIREGED;
            }
            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        {

            deviceExtension->Flags |= DEVFLAG_REMOVED;

            if (deviceExtension->AcpiNotificationEnabled)
            {
                deviceExtension->WmiAcpiDirectInterface.UnregisterForDeviceNotifications(
                                                deviceExtension->WmiAcpiDirectInterface.Context,
                                                WmiAcpiNotificationRoutine);
                deviceExtension->AcpiNotificationEnabled = FALSE;
            }

            if (deviceExtension->Flags & DEVFLAG_WMIREGED)
            {
                if (deviceExtension->WmiAcpiMapInfo != NULL)
                {
                    ExFreePool(deviceExtension->WmiAcpiMapInfo);
                    deviceExtension->WmiAcpiMapInfo = NULL;
                }

                if (wmilibContext->GuidList != NULL)
                {
                    ExFreePool(wmilibContext->GuidList);
                    wmilibContext->GuidList = NULL;
                }

                IoWMIRegistrationControl(DeviceObject,
                                         WMIREG_ACTION_DEREGISTER);
                deviceExtension->Flags &= ~DEVFLAG_WMIREGED;
            }

            IoDetachDevice(deviceExtension->LowerDeviceObject);
            IoDeleteDevice(DeviceObject);

            break;
        }
    }

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

    return(status);
}


NTSTATUS
WmiAcpiForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    deviceExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiForwardIrp: %x Irp %x, Major %x Minor %x, Parameters %x %x %x %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MajorFunction,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

    return(status);
}


VOID
WmiAcpiUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
Routine Description:
    Free all the allocated resources, etc.

Arguments:
    DriverObject - pointer to a driver object

Return Value:
    None
--*/
{
    PAGED_CODE();

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiUnload: Driver %x is unloading\n",
                  DriverObject));
    ExFreePool(WmiAcpiRegistryPath.Buffer);
}


NTSTATUS
WmiAcpiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    DriverObject - pointer to the driver object for this instance of Sample
    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject = NULL;
    PWMILIB_CONTEXT         wmilibContext;
    PDEVICE_EXTENSION       deviceExtension;

    PAGED_CODE();

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiAddDevice: Driver %x, PDO %x\n",
                  DriverObject, PhysicalDeviceObject));

    status = IoCreateDevice (DriverObject,
                             sizeof(DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &deviceObject);

    if (NT_SUCCESS(status))
    {
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        deviceExtension = deviceObject->DeviceExtension;

        deviceExtension->LowerPDO = PhysicalDeviceObject;
        deviceExtension->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiAddDevice: Created device %x to stack %x PDO %x\n",
                      deviceObject,
                      deviceExtension->LowerDeviceObject,
                      deviceExtension->LowerPDO));

        if (deviceExtension->LowerDeviceObject->Flags & DO_POWER_PAGABLE)
        {
            deviceObject->Flags |= DO_POWER_PAGABLE;
        }

        wmilibContext = &deviceExtension->WmilibContext;
        wmilibContext->GuidCount = 0;
        wmilibContext->GuidList = NULL;

        wmilibContext->QueryWmiRegInfo = WmiAcpiQueryWmiRegInfo;
        wmilibContext->QueryWmiDataBlock = WmiAcpiQueryWmiDataBlock;
        wmilibContext->SetWmiDataBlock = WmiAcpiSetWmiDataBlock;
        wmilibContext->SetWmiDataItem = WmiAcpiSetWmiDataItem;
        wmilibContext->ExecuteWmiMethod = WmiAcpiExecuteWmiMethod;
        wmilibContext->WmiFunctionControl = WmiAcpiFunctionControl;
    } else {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiAddDevice: Create device failed %x\n",
                      status));
    }
    return(status);
}

NTSTATUS
WmiAcpiSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    No event.

--*/
{
    PAGED_CODE();
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
WmiAcpiGetAcpiInterfaces(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT   Pdo
    )

/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.  It does
    this the first time it is called, no more.

Arguments:

    None.

Return Value:

    Status

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    PDEVICE_OBJECT          LowerPdo;

    PAGED_CODE();

    //
    // Only need to do this once
    //
    if (DeviceExtension->WmiAcpiDirectInterface.RegisterForDeviceNotifications == NULL) {

        LowerPdo = IoGetAttachedDeviceReference (Pdo);

        //
        // Allocate an IRP for below
        //
        Irp = IoAllocateIrp (LowerPdo->StackSize, FALSE);      // Get stack size from PDO

        if (!Irp) {
            WmiAcpiPrint(WmiAcpiError,
                ("WmiAcpiGetAcpiInterfaces: %x Failed to allocate Irp\n",
                 Pdo));

            ObDereferenceObject(LowerPdo);

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        IrpSp = IoGetNextIrpStackLocation(Irp);

        //
        // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
        //
        IrpSp->MajorFunction = IRP_MJ_PNP;
        IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

        IrpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
        IrpSp->Parameters.QueryInterface.Version                = 1;
        IrpSp->Parameters.QueryInterface.Size                   = sizeof (DeviceExtension->WmiAcpiDirectInterface);
        IrpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) &DeviceExtension->WmiAcpiDirectInterface;
        IrpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

        IoSetCompletionRoutine (Irp, WmiAcpiSynchronousRequest, NULL, TRUE, TRUE, TRUE);
        Status = IoCallDriver (LowerPdo, Irp);

        IoFreeIrp (Irp);

        if (!NT_SUCCESS(Status)) {

            WmiAcpiPrint(WmiAcpiError,
               ("WmiAcpiGetAcpiInterfaces: Could not get ACPI driver interfaces, status = %x\n", Status));
        }

    ObDereferenceObject(LowerPdo);

    }

    return(Status);
}



NTSTATUS
WmiAcpiQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PWMILIB_CONTEXT wmilibContext;
    PDEVICE_EXTENSION deviceExtension;
    USHORT resultType;
    ULONG bufferSize;
    PUCHAR buffer;
    ULONG guidCount;
    NTSTATUS status;
    ULONG sizeNeeded;
    PWMIGUIDREGINFO guidList;
    PWMIACPIMAPINFO guidMapInfo;
    PWMIACPIGUIDMAP guidMap;
    ULONG i;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    //
    // Setup to use PDO instance names and our own registry path
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    if (WmiAcpiRegistryPath.Buffer != NULL)
    {
        *RegistryPath = &WmiAcpiRegistryPath;
    } else {
        *RegistryPath = NULL;
    }
    
    *Pdo = deviceExtension->LowerPDO;
    RtlInitUnicodeString(MofResourceName, L"MofResource");


    //
    // Build guid registration list from information obtained by calling
    // _WDG acpi method

    if (wmilibContext->GuidList == NULL)
    {
        bufferSize = 512;

        status = STATUS_BUFFER_TOO_SMALL;
        buffer = NULL;
        while (status == STATUS_BUFFER_TOO_SMALL)
        {
            if (buffer != NULL)
            {
                ExFreePool(buffer);
            }

            buffer = ExAllocatePoolWithTag(PagedPool,
                                           bufferSize,
                                           WmiAcpiPoolTag);

            if (buffer != NULL)
            {
                status = WmiAcpiEvalMethod(deviceExtension->LowerPDO,
                                       _WDGMethodAsULONG,
                                       buffer,
                                       &bufferSize,
                                       &resultType);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(status))
        {
            guidCount = bufferSize / sizeof(WMIACPIGUIDMAP);

            sizeNeeded = guidCount * sizeof(WMIGUIDREGINFO);

            wmilibContext->GuidCount = guidCount;
            wmilibContext->GuidList = ExAllocatePoolWithTag(PagedPool,
                                                         sizeNeeded,
                                                         WmiAcpiPoolTag);
            if (wmilibContext->GuidList != NULL)
            {
                sizeNeeded = guidCount * sizeof(WMIACPIMAPINFO);
                deviceExtension->GuidMapCount = guidCount;
                deviceExtension->WmiAcpiMapInfo = ExAllocatePoolWithTag(
                                                             NonPagedPool,
                                                             sizeNeeded,
                                                             WmiAcpiPoolTag);
                if (deviceExtension->WmiAcpiMapInfo != NULL)
                {
                    guidMap = (PWMIACPIGUIDMAP)buffer;
                    guidList = wmilibContext->GuidList;
                    guidMapInfo = deviceExtension->WmiAcpiMapInfo;
                    for (i = 0; i < guidCount; i++, guidMap++, guidList++, guidMapInfo++)
                    {
                        //
                        // Cannot be both an event and a method or be both a
                        // method and data block.
                        ASSERT( ! ((guidMap->Flags & WMIACPI_REGFLAG_EVENT) &&
                               (guidMap->Flags & WMIACPI_REGFLAG_METHOD)));

                        guidMapInfo->ObjectId[0] = guidMap->ObjectId[0];
                        guidMapInfo->ObjectId[1] = guidMap->ObjectId[1];
                        guidMapInfo->Flags = guidMap->Flags;
                        guidMapInfo->Guid = guidMap->Guid;

                        guidList->Flags = 0;
                        guidList->Guid = &guidMapInfo->Guid;
                        guidList->InstanceCount = guidMap->InstanceCount;
                        if (guidMap->Flags & WMIACPI_REGFLAG_EXPENSIVE)
                        {
                            guidList->Flags |= WMIREG_FLAG_EXPENSIVE;
                        }

                        if (guidMap->Flags & WMIACPI_REGFLAG_EVENT)
                        {
                            guidList->Flags |= WMIREG_FLAG_EVENT_ONLY_GUID;
                        }

                    }
                } else {
                    ExFreePool(wmilibContext->GuidList);
                    wmilibContext->GuidList = NULL;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (buffer != NULL)
        {
            ExFreePool(buffer);
        }

    } else {
        status = STATUS_SUCCESS;
    }

    return(status);
}

NTSTATUS
WmiAcpiQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call IoWMICompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG sizeNeeded;
    ULONG padNeeded;
    ULONG i;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    PUCHAR outBuffer;
    ULONG outBufferSize;
    ULONG currentInstanceIndex;
    BOOLEAN bufferTooSmall;
    PWMILIB_CONTEXT wmilibContext;

    PAGED_CODE();

#if DBG
    if (BufferAvail > 0)
    {
        RtlZeroMemory(Buffer, BufferAvail);
    }
#endif


    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    ASSERT(GuidIndex < wmilibContext->GuidCount);

    guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];

    //
    // Query only valid for those datablocks registered as not events
    // or methods.
    bufferTooSmall = FALSE;
    if ((guidMapInfo->Flags &
            (WMIACPI_REGFLAG_METHOD | WMIACPI_REGFLAG_EVENT)) == 0)
    {
        methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'Q',
                                                 guidMapInfo->ObjectId[0],
                                                 guidMapInfo->ObjectId[1]);

        status = STATUS_SUCCESS;
        sizeNeeded = 0;
        padNeeded = 0;
        for (i = 0; (i < InstanceCount) && NT_SUCCESS(status) ; i++)
        {
            currentInstanceIndex = i + InstanceIndex;

            sizeNeeded += padNeeded;
            if ((! bufferTooSmall) && (sizeNeeded < BufferAvail))
            {
                outBufferSize = BufferAvail - sizeNeeded;
                outBuffer = Buffer + sizeNeeded;
            } else {
                bufferTooSmall = TRUE;
                outBufferSize = 0;
                outBuffer = NULL;
            }

            status = WmiAcpiEvalMethodInt(deviceExtension->LowerPDO,
                                          methodAsUlong,
                                          currentInstanceIndex,
                                          outBuffer,
                                          &outBufferSize,
                                          &resultType);

            sizeNeeded += outBufferSize;
            padNeeded = ((sizeNeeded + 7) & ~7) - sizeNeeded;
            
            if (NT_SUCCESS(status))
            {
                InstanceLengthArray[i] = outBufferSize;
            }
            
            if (status == STATUS_BUFFER_TOO_SMALL)
            {
                bufferTooSmall = TRUE;
                status = STATUS_SUCCESS;
            }
        }

    } else if (guidMapInfo->Flags & WMIACPI_REGFLAG_METHOD) {
        //
        // WBEM requires methods respond queries
        sizeNeeded = 0;
        if (InstanceLengthArray != NULL)
        {
			for (i = 0; i < InstanceCount; i++)
			{
				InstanceLengthArray[i] = 0;
			}
            status = STATUS_SUCCESS;
        } else {
			status = STATUS_BUFFER_TOO_SMALL;
		}
    } else {
        sizeNeeded = 0;
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    if (NT_SUCCESS(status) && bufferTooSmall)
    {
        status = STATUS_BUFFER_TOO_SMALL;
    }
    
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
WmiAcpiCheckIncomingString(
    PUNICODE_STRING UnicodeString,
    ULONG BufferSize,
    PUCHAR Buffer,
    PWCHAR EmptyString
)
{
    ULONG status;
    USHORT stringLength;

    PAGED_CODE();

    if (BufferSize > sizeof(USHORT))
    {
        //
        // The length declared in the string must fit within the
        // passed in buffer
        stringLength = *((PUSHORT)Buffer);
        if ((stringLength + sizeof(USHORT)) <= BufferSize)
        {
            UnicodeString->Length = stringLength;
            UnicodeString->MaximumLength = stringLength;
            UnicodeString->Buffer = (PWCHAR)(Buffer + sizeof(USHORT));
            status = STATUS_SUCCESS;
        } else {
             status = STATUS_INVALID_PARAMETER;
        }
    } else if (BufferSize == 0) {
        //
        // An empty incoming buffer is translated into an empty string
        UnicodeString->Length = 0;
        UnicodeString->MaximumLength = 0;
        *EmptyString = UNICODE_NULL;
        UnicodeString->Buffer = EmptyString;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }
    return(status);
}

NTSTATUS
WmiAcpiSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    ULONG outBufferSize;
    PWMILIB_CONTEXT wmilibContext;
    UNICODE_STRING unicodeString;
    WCHAR emptyString;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    ASSERT(GuidIndex < wmilibContext->GuidCount);

    guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];

    //
    // Query only valid for those datablocks registered as not events
    // or methods.
    if ((guidMapInfo->Flags &
            (WMIACPI_REGFLAG_METHOD | WMIACPI_REGFLAG_EVENT)) == 0)
    {
        methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'S',
                                                 guidMapInfo->ObjectId[0],
                                                 guidMapInfo->ObjectId[1]);

        outBufferSize = 0;

        if (guidMapInfo->Flags & WMIACPI_REGFLAG_STRING)
        {
            status = WmiAcpiCheckIncomingString(&unicodeString,
                                               BufferSize,
                                               Buffer,
                                               &emptyString);
            if (NT_SUCCESS(status))
            {
                status = WmiAcpiEvalMethodIntString(deviceExtension->LowerPDO,
                                      methodAsUlong,
                                      InstanceIndex,
                                      &unicodeString,
                                      NULL,
                                      &outBufferSize,
                                      &resultType);

            }
        } else {
            status = WmiAcpiEvalMethodIntBuffer(deviceExtension->LowerPDO,
                                      methodAsUlong,
                                      InstanceIndex,
                                      BufferSize,
                                      Buffer,
                                      NULL,
                                      &outBufferSize,
                                      &resultType);
        }

        if (status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Since this operation is not supposed to return any results
            // then we need to ignore the fact that the return buffer
            // was too small.
            status = STATUS_SUCCESS;
        }

    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
WmiAcpiSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    status = STATUS_INVALID_DEVICE_REQUEST;

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}


NTSTATUS
WmiAcpiExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    PWMILIB_CONTEXT wmilibContext;
    BOOLEAN voidResultExpected;
    UNICODE_STRING unicodeString;
    WCHAR emptyString;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    ASSERT(GuidIndex < wmilibContext->GuidCount);

    guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];

    //
    // Query only valid for those datablocks registered as not events
    // or methods.
    if (guidMapInfo->Flags & WMIACPI_REGFLAG_METHOD)
    {
        methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'M',
                                                 guidMapInfo->ObjectId[0],
                                                 guidMapInfo->ObjectId[1]);

        voidResultExpected = (OutBufferSize == 0);

        if (guidMapInfo->Flags & WMIACPI_REGFLAG_STRING)
        {
            status = WmiAcpiCheckIncomingString(&unicodeString,
                                               InBufferSize,
                                               Buffer,
                                               &emptyString);

            if (NT_SUCCESS(status))
            {
                status = WmiAcpiEvalMethodIntIntString(deviceExtension->LowerPDO,
                                      methodAsUlong,
                                      InstanceIndex,
                                      MethodId,
                                      &unicodeString,
                                      Buffer,
                                      &OutBufferSize,
                                      &resultType);
            }

        } else {
            status = WmiAcpiEvalMethodIntIntBuffer(deviceExtension->LowerPDO,
                                      methodAsUlong,
                                      InstanceIndex,
                                      MethodId,
                                      InBufferSize,
                                      Buffer,
                                      Buffer,
                                      &OutBufferSize,
                                      &resultType);
        }

        if (voidResultExpected && (status == STATUS_BUFFER_TOO_SMALL))
        {
            //
            // Since this operation is not supposed to return any results
            // then we need to ignore the fact that the return buffer
            // was too small.
            status = STATUS_SUCCESS;
            OutBufferSize = 0;
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     OutBufferSize,
                                     IO_NO_INCREMENT);

    return(status);
}

VOID
WmiAcpiNotificationWorkItem(
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None

--*/
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER buffer;
    ULONG bufferSize;
    PDEVICE_EXTENSION deviceExtension;
    ULONG processedBufferSize;
    PUCHAR processedBuffer;
    USHORT resultType;
    PIRP_CONTEXT_BLOCK irpContextBlock;
    LPGUID guid;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    irpContextBlock = (PIRP_CONTEXT_BLOCK)Context;

    deviceObject = irpContextBlock->DeviceObject;
    deviceExtension = deviceObject->DeviceExtension;

    status = irpContextBlock->Status;

    buffer = (PACPI_EVAL_OUTPUT_BUFFER)irpContextBlock->OutBuffer;
    bufferSize = irpContextBlock->OutBufferSize;

    guid = irpContextBlock->CallerContext;

    WmiAcpiPrint(WmiAcpiEvalTrace,
                 ("WmiAcpi: %x _WED --> %x, size = %d\n",
                      deviceObject,
                      status,
                      bufferSize));

    if (NT_SUCCESS(status) && (bufferSize > 0))
    {
        processedBufferSize = _WEDBufferSize * sizeof(WCHAR);

        processedBuffer = ExAllocatePoolWithTag(PagedPool,
                                            processedBufferSize,
                                            WmiAcpiPoolTag);

        if (processedBuffer != NULL)
        {
            status = WmiAcpiProcessResult(status,
                                          buffer,
                                          bufferSize,
                                          processedBuffer,
                                          &processedBufferSize,
                                          &resultType);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (! NT_SUCCESS(status))
        {
            processedBufferSize = 0;
        }

    } else {
        processedBufferSize = 0;
        processedBuffer = NULL;
    }

    status = WmiFireEvent(
                   deviceObject,
                   guid,
                   0,
                   processedBufferSize,
                   processedBuffer);

#if DBG
    if (! NT_SUCCESS(status))
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpi: %x WmiWriteEvent failed %x\n",
                      deviceObject,
                      status));
    }
#endif

    ExFreePool(buffer);
    ExFreePool(irpContextBlock);
}

VOID
WmiAcpiNotificationRoutine (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    )
/*++

Routine Description:

    ACPI calls back this routine whenever the ACPI code fires a notification

Arguments:

    Context is the device object of the device whose ACPI code fired the event

    NotifyValue is the notify value fired by the ACPI code


Return Value:

    None

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PWMIACPIMAPINFO guidMapInfo;
    PUCHAR outBuffer;
    ULONG outBufferSize;
    ULONG i;
    NTSTATUS status;
    BOOLEAN irpPassed;

#if 0
    KIRQL oldIrql;
    oldIrql = KeRaiseIrqlToDpcLevel();
#endif

    deviceObject = (PDEVICE_OBJECT)Context;
    deviceExtension = deviceObject->DeviceExtension;

    guidMapInfo = (PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo;

    for (i = 0; i < deviceExtension->GuidMapCount; i++, guidMapInfo++)
    {
        if ((guidMapInfo->Flags & WMIACPI_REGFLAG_EVENT) &&
            (guidMapInfo->NotifyId.NotificationValue == NotifyValue))
        {
            outBufferSize = _WEDBufferSize;
            outBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                              outBufferSize,
                                              WmiAcpiPoolTag);

            irpPassed = FALSE;
            if (outBuffer != NULL)
            {
                status = WmiAcpiEvalMethodIntAsync(deviceObject,
                                              deviceExtension->LowerPDO,
                                              _WEDMethodAsULONG,
                                              NotifyValue,
                                              outBuffer,
                                              outBufferSize,
                                              WmiAcpiNotificationWorkItem,
                                              (PVOID)&guidMapInfo->Guid,
                                              &irpPassed);

            } else {
                WmiAcpiPrint(WmiAcpiError,
                             ("WmiAcpi: Event %d data lost due to insufficient resources\n",
                               NotifyValue));
            }

            if (! irpPassed)
            {
                //
                // If ACPI could not be called with an irp then fire an
                // empty event and cleanup.
                status = WmiFireEvent(
                               deviceObject,
                               &guidMapInfo[i].Guid,
                               0,
                               0,
                               NULL);

                if (outBuffer != NULL)
                {
                    ExFreePool(outBuffer);
                }
#if DBG
                if (! NT_SUCCESS(status))
                {
                    WmiAcpiPrint(WmiAcpiError,
                                 ("WmiAcpi: %x notification %x IoWMIFireEvent -> %x\n",
                              deviceObject, NotifyValue, status));
                }
#endif
            }

        }
    }
#if 0
    KeLowerIrql(oldIrql);
#endif
}

CHAR WmiAcpiXtoA(
    UCHAR HexDigit
    )
{
    CHAR c;

    PAGED_CODE();

    if ((HexDigit >= 0x0a) && (HexDigit <= 0x0f))
    {
        c = HexDigit + 'A' - 0x0a;
    } else {
        c = HexDigit + '0';
    }

    return(c);
}

NTSTATUS
WmiAcpiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    ULONG outBufferSize;
    PWMILIB_CONTEXT wmilibContext;
    CHAR c1, c2;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    ASSERT(GuidIndex < wmilibContext->GuidCount);

    guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];


    if (Function == WmiDataBlockControl)

    {
        methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'C',
                                                 guidMapInfo->ObjectId[0],
                                                 guidMapInfo->ObjectId[1]);
    } else {
        if (guidMapInfo->Flags & WMIACPI_REGFLAG_EVENT)
        {
            if (Enable)
            {
                status = WmiAcpiGetAcpiInterfaces(deviceExtension,
                                                  deviceExtension->LowerPDO);

                if (NT_SUCCESS(status))
                {
                    if (! deviceExtension->AcpiNotificationEnabled)
                    {
                        status = deviceExtension->WmiAcpiDirectInterface.RegisterForDeviceNotifications(
                                                   deviceExtension->WmiAcpiDirectInterface.Context,
                                                   WmiAcpiNotificationRoutine,
                                                   DeviceObject);

                        deviceExtension->AcpiNotificationEnabled = NT_SUCCESS(status);
                    }
                }
            }

            c1 = WmiAcpiXtoA((UCHAR)(guidMapInfo->NotifyId.NotificationValue >> 4));
            c2 = WmiAcpiXtoA((UCHAR)(guidMapInfo->NotifyId.NotificationValue & 0x0f));
            methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'E',
                                                         c1,
                                                         c2);
        } else {
            methodAsUlong = 0;
        }
    }


    //
    // Query only valid for those datablocks registered as not events
    // or methods.
    if (NT_SUCCESS(status))
    {
        if (methodAsUlong != 0)
        {
            outBufferSize = 0;
            status = WmiAcpiEvalMethodInt(deviceExtension->LowerPDO,
                                          methodAsUlong,
                                          Enable ? 1 : 0,
                                          NULL,
                                          &outBufferSize,
                                          &resultType);

            if (status == STATUS_BUFFER_TOO_SMALL)
            {
                //
                // Since this operation is not supposed to return any results
                // then we need to ignore the fact that the return buffer
                // was too small.
                status = STATUS_SUCCESS;
            }
        } else {
            status = STATUS_SUCCESS;
        }
    } else {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpi: RegisterForDeviceNotification(%x) -> %x\n",
                       DeviceObject, status));
    }


    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
WmiAcpiAsyncEvalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIRP_CONTEXT_BLOCK irpContextBlock;

    irpContextBlock = (PIRP_CONTEXT_BLOCK)Context;

    irpContextBlock->Status = Irp->IoStatus.Status;
    irpContextBlock->OutBufferSize = (ULONG)Irp->IoStatus.Information;
    irpContextBlock->OutBuffer = Irp->AssociatedIrp.SystemBuffer;

    ExInitializeWorkItem( &irpContextBlock->WorkQueueItem,
                          irpContextBlock->CallerWorkItemRoutine,
                          irpContextBlock );
    ExQueueWorkItem( &irpContextBlock->WorkQueueItem, DelayedWorkQueue );

    IoFreeIrp(Irp);
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
WmiAcpiSendAsyncDownStreamIrp(
    IN  PDEVICE_OBJECT   DeviceObject,
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  ULONG            InputBufferSize,
    IN  ULONG            OutputBufferSize,
    IN  PVOID            Buffer,
    IN  PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN  PVOID CompletionContext,
    IN  PBOOLEAN IrpPassed
)
/*++

Routine Description:

    Sends asynchronously an IRP_MJ_DEVICE_CONTROL to a device object

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    PIRP_CONTEXT_BLOCK  irpContextBlock;
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION irpSp;


    irpContextBlock = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(IRP_CONTEXT_BLOCK),
                                            WmiAcpiPoolTag);

    if (irpContextBlock == NULL)
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiSendAsyncDownStreamIrp: %x Failed to allocate Irp Context Block\n",
                      DeviceObject));
        *IrpPassed = FALSE;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    irp = IoAllocateIrp(Pdo->StackSize, TRUE);

    if (!irp)
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiSendAsyncDownStreamIrp: %x Failed to allocate Irp\n",
                      DeviceObject));
        *IrpPassed = FALSE;
        ExFreePool(irpContextBlock);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = Ioctl;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferSize;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferSize;

    irp->AssociatedIrp.SystemBuffer = Buffer;
    irp->Flags = IRP_BUFFERED_IO;

    irpContextBlock->CallerContext = CompletionContext;
    irpContextBlock->CallerWorkItemRoutine = CompletionRoutine;
    irpContextBlock->DeviceObject = DeviceObject;

    IoSetCompletionRoutine(irp,
                           WmiAcpiAsyncEvalCompletionRoutine,
                           irpContextBlock,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Pass request to Pdo
    //
    status = IoCallDriver(Pdo, irp);

    WmiAcpiPrint(WmiAcpiEvalTrace,
        ("WmiAcpiSendAsyncDownStreamIrp: %x Irp %x completed %x! \n",
         DeviceObject, irp, status )
        );


    *IrpPassed = TRUE;
    return(status);
}



NTSTATUS
WmiAcpiSendDownStreamIrp(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            *OutputBufferSize
)
/*++

Routine Description:

    Sends synchronously an IRP_MJ_DEVICE_CONTROL to a device object

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    IO_STATUS_BLOCK     ioBlock;
    KEVENT              event;
    NTSTATUS            status;
    PIRP                irp;
    ULONG               OutputSize = *OutputBufferSize;

    PAGED_CODE();

    //
    // Initialize an event to wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build the request
    //
    irp = IoBuildDeviceIoControlRequest(
        Ioctl,
        Pdo,
        InputBuffer,
        InputSize,
        OutputBuffer,
        OutputSize,
        FALSE,
        &event,
        &ioBlock
        );

    if (!irp)
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiSendDownStreamIrp: %x Failed to allocate Irp\n",
                       Pdo
                         ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Pass request to Pdo, always wait for completion routine
    //
    status = IoCallDriver(Pdo, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for the irp to be completed, then grab the real status code
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }

    //
    // Always get the return status from the irp. We don't trust the return
    // value since acpienum.c smashes it to STATUS_SUCCESS on memphis for some
    // reason.
    status = ioBlock.Status;

    //
    // Sanity check the data
    //
    *OutputBufferSize = (ULONG)ioBlock.Information;

    WmiAcpiPrint(WmiAcpiEvalTrace,
        ("WmiAcpiSendDownStreamIrp: %x Irp %x completed %x! \n",
         Pdo, irp, status )
        );


    return(status);
}

ULONG WmiAcpiArgumentSize(
    IN PACPI_METHOD_ARGUMENT Argument
    )
/*++

Routine Description:

    Determine the size needed to write the argument data into the WMI callers
    output buffer. For integers and buffers this is done by getting the size
    specified in the header. For strings this is done by determining the
    size of the string in UNICODE and adding the size of the preceedeing
    USHORT that holds the stirng length

Arguments:

    Argument is the ACPI method argument whose for whose data the WMI size
        is to be determined

Return Value:

    WMI size for the argument data

--*/
{
    ULONG size;
    ANSI_STRING AnsiString;

    PAGED_CODE();

    if (Argument->Type == ACPI_METHOD_ARGUMENT_STRING)
    {
        AnsiString.Length = Argument->DataLength;
        AnsiString.MaximumLength = Argument->DataLength;
        AnsiString.Buffer = Argument->Data;
        size = RtlAnsiStringToUnicodeSize(&AnsiString) + sizeof(USHORT);
    } else {
        size = Argument->DataLength;
    }
    return(size);
}

NTSTATUS WmiAcpiCopyArgument(
    OUT PUCHAR Buffer,
    IN ULONG BufferSize,
    IN PACPI_METHOD_ARGUMENT Argument
    )
/*++

Routine Description:

    Copy the argument data from the ACPI method argument into the WMI output
    buffer. For integer and buffers this is a straight copy, but for strings
    the string is converted to UNICODE with a USHORT containing the length
    (in bytes) of the string prependedded.

Arguments:

    Buffer has output buffer to which to write the data

    Argument is the ACPI method argument whose for whose data the WMI size
        is to be determined

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    PAGED_CODE();

    if (Argument->Type == ACPI_METHOD_ARGUMENT_STRING)
    {
        AnsiString.Length = Argument->DataLength;
        AnsiString.MaximumLength = Argument->DataLength;
        AnsiString.Buffer = Argument->Data;
        UnicodeString.MaximumLength = (USHORT)BufferSize;
        UnicodeString.Length = 0;
        UnicodeString.Buffer = (PWCHAR)(Buffer + sizeof(USHORT));

        status = RtlAnsiStringToUnicodeString(&UnicodeString,
                                              &AnsiString,
                                              FALSE);

        if (NT_SUCCESS(status))
        {
            *((PUSHORT)Buffer) = UnicodeString.Length + sizeof(WCHAR);
        }
    } else {
        RtlCopyMemory(Buffer, Argument->Data, Argument->DataLength);
        status = STATUS_SUCCESS;
    }
    return(status);
}

NTSTATUS WmiAcpiProcessResult(
    IN NTSTATUS Status,
    IN PACPI_EVAL_OUTPUT_BUFFER OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PUCHAR ResultBuffer,
    OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Validates the results from a method evaluation and returns a pointer to
    the result data and the result size

Arguments:

    Status has the return status from the method evaluation irp

    OutputBufferSize is the number of bytes available in OutputBuffer that
        ACPI can use to write the result data structure

    OutputBuffer is the buffer acpi uses to return the result data structure

    ResultBuffer is the buffer to return the result data.

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    PACPI_METHOD_ARGUMENT argument, nextArgument;
    ULONG count;
    ULONG i;
    ULONG sizeNeeded;
    ULONG maxSize;
    ULONG argumentSize;
    PUCHAR resultPtr;
    PCHAR stringPtr;

    PAGED_CODE();
    
    if (NT_SUCCESS(Status))
    {
        ASSERT((OutputBufferSize == 0) ||
               (OutputBufferSize >= sizeof(ACPI_EVAL_OUTPUT_BUFFER)));

        if (OutputBufferSize != 0)
        {
            if (OutputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE)
            {
                Status = STATUS_UNSUCCESSFUL;
            } else if (OutputBuffer->Count == 0) {
                //
                // Apparently no data is returned from the method
                *ResultSize = 0;
            } else {
                count = OutputBuffer->Count;
                argument = &OutputBuffer->Argument[0];

                if (count == 1)
                {
                    *ResultType = argument->Type;
                } else {
                    //
                    // Return buffer as the data type of a package
                    *ResultType = ACPI_METHOD_ARGUMENT_BUFFER;
                }

                maxSize = *ResultSize;
                sizeNeeded = 0;
                for (i = 0; (i < count) ; i++)
                {
                    nextArgument = ACPI_METHOD_NEXT_ARGUMENT(argument);

                    if ((argument->Type == ACPI_METHOD_ARGUMENT_STRING) &&
                        (argument->DataLength != 0))
                    {
                        //
                        // ACPI will return strings that are padded at the
                        // end with extra NULs. We want to strip out the
                        // padding.
                        stringPtr = argument->Data + argument->DataLength - 1;
                        while ((stringPtr >= argument->Data) &&
                               (*stringPtr == 0))
                        {
                            argument->DataLength--;
                            stringPtr--;
                        }
                    }

                    argumentSize = WmiAcpiArgumentSize(argument);

                    if (argument->Type == ACPI_METHOD_ARGUMENT_INTEGER)
                    {
                        //
                        // If the argument is an integer then we need to
                        // ensure that it is aligned properly on a 4 byte
                        // boundry.
                        sizeNeeded = (sizeNeeded + 3) & ~3;
                    } else if (argument->Type == ACPI_METHOD_ARGUMENT_STRING) {
                        //
                        // If the argument is an string then we need to
                        // ensure that it is aligned properly on a 2 byte
                        // boundry.
                        sizeNeeded = (sizeNeeded + 1) & ~1;
                    }

                    resultPtr = ResultBuffer + sizeNeeded;

                    sizeNeeded += argumentSize;

                    if (sizeNeeded <= maxSize)
                    {
                        //
                        // If there is enough room in the output buffer then
                        // copy the data to it.
                        WmiAcpiCopyArgument(resultPtr,
                                            argumentSize,
                                            argument);
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }

                    argument = nextArgument;
                }

                *ResultSize = sizeNeeded;
            }
        } else {
            //
            // Result is a void
            *ResultType = ACPI_METHOD_ARGUMENT_BUFFER;
            *ResultSize = 0;
    }
    } else if (Status == STATUS_BUFFER_OVERFLOW) {
        ASSERT((OutputBufferSize == 0) ||
               (OutputBufferSize >= sizeof(ACPI_EVAL_OUTPUT_BUFFER)));

        if (OutputBufferSize >= sizeof(ACPI_EVAL_OUTPUT_BUFFER))
        {
            //
            // If the result is a package, that is has multiple arguments
            // then we need to multiply the size needed by sizeof(WCHAR)
            // in case the returned arguments are strings. We also
            // include the size needed for the result data plus
            // extra space for the argument descriptors since the result
            // is a package.
            *ResultSize = (OutputBuffer->Length * sizeof(WCHAR)) +
                          (OutputBuffer->Count * sizeof(ACPI_METHOD_ARGUMENT));
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            Status = STATUS_UNSUCCESSFUL;

        }
    } else {
        //
        // We much all other ACPI status codes into this one since the ACPI
        // codes are not mapped to any user mode error codes.
        Status = STATUS_UNSUCCESSFUL;
    }

    return(Status);
}


NTSTATUS WmiAcpiSendMethodEvalIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a buffer argument
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    InputBuffer is a buffer containing an ACPI_EVAL_INPUT_BUFFER_* structure

    InputBufferSize is the size of InputBuffer in bytes

    ResultBuffer is the WMI buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    ULONG outputBufferSize;

    PAGED_CODE();

    outputBufferSize =     *ResultSize + ACPI_EVAL_OUTPUT_FUDGE;
    outputBuffer = ExAllocatePoolWithTag(PagedPool,
                                         outputBufferSize,
                                         WmiAcpiPoolTag);

    if (outputBuffer != NULL)
    {
        WmiAcpiPrint(WmiAcpiEvalTrace,
             ("WmiAcpiSendMethodEvalIrp: %x Eval Method %c%c%c%c \n",
              DeviceObject,
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[0],
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[1],
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[2],
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[3]
                 )
             );

           status = WmiAcpiSendDownStreamIrp(
                             DeviceObject,
                             IOCTL_ACPI_EVAL_METHOD,
                             InputBuffer,
                             InputBufferSize,
                             outputBuffer,
                             &outputBufferSize);

         WmiAcpiPrint(WmiAcpiEvalTrace,
                ("WmiAcpiSendMethodEvalIrp: %x Evaluated Method %c%c%c%c -> %x \n",
                 DeviceObject,
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[0],
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[1],
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[2],
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[3],
                 status
                  )
                );


           status = WmiAcpiProcessResult(status,
                                      outputBuffer,
                                      outputBufferSize,
                                      ResultBuffer,
                                      ResultSize,
                                      ResultType);

            if (outputBuffer != NULL)
            {
                ExFreePool(outputBuffer);
            }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


NTSTATUS WmiAcpiEvalMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take no input arguments and returns
    a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER inputBuffer;

    PAGED_CODE();

    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = MethodAsUlong;

    status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                (PUCHAR)&inputBuffer,
                                sizeof(ACPI_EVAL_INPUT_BUFFER),
                                ResultBuffer,
                                ResultSize,
                                ResultType);

    return(status);
}

NTSTATUS WmiAcpiEvalMethodInt(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take a single integer argument and
    returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER inputBuffer;

    PAGED_CODE();

    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
       inputBuffer.MethodNameAsUlong = MethodAsUlong;
    inputBuffer.IntegerArgument = IntegerArgument;

    status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                (PUCHAR)&inputBuffer,
                                sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
                                ResultBuffer,
                                ResultSize,
                                ResultType);

    return(status);
}

NTSTATUS WmiAcpiEvalMethodIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a buffer argument
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    BufferArgumentSize is the number of bytes contained in the buffer argument

    BufferArgument is a pointer to the buffer argument

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;

    PAGED_CODE();

    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         sizeof(ACPI_METHOD_ARGUMENT) +
                      BufferArgumentSize;

    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 2;
        inputBuffer->Size = inputBufferSize;

        argument = &inputBuffer->Argument[0];
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
        argument->DataLength = (USHORT)BufferArgumentSize;
        RtlCopyMemory(argument->Data,
                      BufferArgument,
                      argument->DataLength);

        status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);

          ExFreePool(inputBuffer);

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}

NTSTATUS WmiAcpiEvalMethodIntIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a buffer argument 
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method
        
    MethodAsUlong is the name of the method packed in a ULONG
       
    IntegerArgument is the integer argument to pass to the method

    IntegerArgument2 is the second integer argument to pass to the method
        
    BufferArgumentSize is the number of bytes contained in the buffer argument
        
    BufferArgument is a pointer to the buffer argument
        
    ResultBuffer is the buffer to return the result data
        
    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.
                        
    *ResultType returns with the data type for the method result
        
Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;
     
    PAGED_CODE();
        
    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         2 * sizeof(ACPI_METHOD_ARGUMENT) + 
                      BufferArgumentSize;
    
    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 3;
        inputBuffer->Size = inputBufferSize;
            
        argument = &inputBuffer->Argument[0];            
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument2;    
    
        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
        argument->DataLength = (USHORT)BufferArgumentSize;
        RtlCopyMemory(argument->Data,
                      BufferArgument,
                      argument->DataLength);                              
            
        status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);
            
          ExFreePool(inputBuffer);
        
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(status);
}

NTSTATUS WmiAcpiEvalMethodIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a string argument
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    StringArgument is a pointer to the string argument. This will be
        converted from unicode to ansi

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;
    USHORT stringLength;
    ANSI_STRING ansiString;

    PAGED_CODE();

    stringLength = (USHORT)(RtlUnicodeStringToAnsiSize(StringArgument) + 1);
    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         sizeof(ACPI_METHOD_ARGUMENT) +
                      stringLength;

    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 2;
        inputBuffer->Size = inputBufferSize;

        argument = &inputBuffer->Argument[0];
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_STRING;
        
        ansiString.MaximumLength = stringLength;
        ansiString.Length = 0;
        ansiString.Buffer = (PCHAR)&argument->Data;
        status = RtlUnicodeStringToAnsiString(&ansiString, 
                                              StringArgument, 
                                              FALSE);
        if (NT_SUCCESS(status))
        {
            argument->DataLength = ansiString.Length;
            status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);
            
        } else {
            WmiAcpiPrint(WmiAcpiError,
                         ("WmiAcpi: %x unicode to ansi conversion failed %x\n",
                                   DeviceObject,
                                   status));
        }
            
        ExFreePool(inputBuffer);
        
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(status);
}


NTSTATUS WmiAcpiEvalMethodIntIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a string argument 
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method
        
    MethodAsUlong is the name of the method packed in a ULONG
       
    IntegerArgument is the integer argument to pass to the method
        
    IntegerArgument2 is the second integer argument to pass to the method
        
    StringArgument is a pointer to the string argument. This will be
        converted from unicode to ansi
        
    ResultBuffer is the buffer to return the result data
        
    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.
                        
    *ResultType returns with the data type for the method result
        
Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;
    USHORT stringLength;
    ANSI_STRING ansiString;
     
    PAGED_CODE();
        
    stringLength = (USHORT)(RtlUnicodeStringToAnsiSize(StringArgument) + 1);
    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         2 * sizeof(ACPI_METHOD_ARGUMENT) + 
                      stringLength;
    
    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 3;
        inputBuffer->Size = inputBufferSize;
            
        argument = &inputBuffer->Argument[0];            
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument2;
        
        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_STRING;

        ansiString.MaximumLength = stringLength;
        ansiString.Length = 0;
        ansiString.Buffer = (PCHAR)&argument->Data;
        status = RtlUnicodeStringToAnsiString(&ansiString,
                                              StringArgument,
                                              FALSE);
        if (NT_SUCCESS(status))
        {
            argument->DataLength = ansiString.Length;
            status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);

        } else {
            WmiAcpiPrint(WmiAcpiError,
                         ("WmiAcpi: %x unicode to ansi conversion failed %x\n",
                                   DeviceObject,
                                   status));
        }

        ExFreePool(inputBuffer);

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}



NTSTATUS WmiAcpiEvalMethodIntAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN ULONG ResultBufferSize,
    IN PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PBOOLEAN IrpPassed
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take a single integer argument and
    returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER inputBuffer;

    ASSERT(ResultBuffer != NULL);
    ASSERT(ResultBufferSize >= sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER));

    inputBuffer = (PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER)ResultBuffer;
    inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer->MethodNameAsUlong = MethodAsUlong;
    inputBuffer->IntegerArgument = IntegerArgument;

    status = WmiAcpiSendAsyncDownStreamIrp(
                             DeviceObject,
                             Pdo,
                             IOCTL_ACPI_ASYNC_EVAL_METHOD,
                             sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
                             ResultBufferSize,
                             ResultBuffer,
                             CompletionRoutine,
                             CompletionContext,
                             IrpPassed);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\unasm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unasm.h

Abstract:

    This unassembles an AML file

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _UNASM_H_
#define _UNASM_H_

//
// Typedef for the print function
//
typedef VOID (*PUNASM_PRINT)(PCCHAR DebugMessage, ... );

//
// Global Variables
//
PUCHAR  TopOpcode;
PUCHAR  CurrentOpcode;
PUCHAR  StartOpcode;

//
// Functions
//
UCHAR
LOCAL
ComputeDataCheckSum(
    PUCHAR          OpCode,
    ULONG           Length
    );

VOID
LOCAL
DumpCode(
    PUCHAR          *Opcode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

PASLTERM
LOCAL
FindKeywordTerm(
    UCHAR   KeyWordGroup,
    UCHAR   Data
    );

UCHAR
LOCAL
FindOpClass(
    UCHAR       OpCode,
    POPMAP      OpCodeTable
    );

PASLTERM
LOCAL
FindOpTerm(
    ULONG   OpCode
    );

NTSTATUS
LOCAL
ParseNameTail(
    PUCHAR  *OpCode,
    PUCHAR  Buffer,
    ULONG   Length
    );

ULONG
LOCAL
ParsePackageLen(
    PUCHAR  *OpCode,
    PUCHAR  *OpCodeNext
    );

VOID
LOCAL
PrintIndent(
    PUNASM_PRINT    PrintFunction,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmArgs(
    PUCHAR          UnAsmArgTypes,
    PUCHAR          ArgActions,
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmDataList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmDataObj(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
EXPORT
UnAsmDSDT(
    PUCHAR          DSDT,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       DsdtLocation,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmField(
    PUCHAR          *OpCode,
    PULONG          BitPos,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmFieldList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmHeader(
    PDESCRIPTION_HEADER DsdtHeader,
    PUNASM_PRINT        PrintFunction,
    ULONG_PTR           DsdtLocation,
    ULONG               IndentLevel
    );

NTSTATUS
EXPORT
UnAsmLoadDSDT(
    PUCHAR          DSDT
    );

NTSTATUS
LOCAL
UnAsmNameObj(
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    UCHAR           ObjectType,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmOpcode(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmPkgList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmScope(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmSuperName(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmTermObj(
    PASLTERM        Term,
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\wmiacpi\wmimap.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmimap.h

Abstract:

    ACPI to WMI mapping layer

Author:

    Alan Warwick

Environment:

    Kernel mode

Revision History:

--*/

#if DBG
    extern ULONG WmiAcpiDebug;
    #define WmiAcpiPrint(l,m)    if(l & WmiAcpiDebug) DbgPrint m
#else
    #define WmiAcpiPrint(l,m)
#endif

#define WmiAcpiError        0x00000001
#define WmiAcpiWarning      0x00000002
#define WmiAcpiBasicTrace   0x00000004

#define WmiAcpiQueryTrace   0x00000010
#define WmiAcpiSetTrace     0x00000020
#define WmiAcpiMethodTrace  0x00000040
#define WmiAcpiEventTrace   0x00000080
#define WmiAcpiFncCtlTrace  0x00000100
#define WmiAcpiRegInfoTrace 0x00000200

#define WmiAcpiEvalTrace    0x00001000

#define ACPI_EVAL_OUTPUT_FUDGE sizeof(ACPI_EVAL_OUTPUT_BUFFER)

#define WmiAcpiPoolTag 'AimW'

typedef struct
{
    GUID Guid;
    union
    {
        CHAR ObjectId[2];
        struct 
        {
            UCHAR NotificationValue;
            UCHAR Reserved;
        } NotifyId;
    };
    USHORT Flags;
} WMIACPIMAPINFO, *PWMIACPIMAPINFO;

#define WmiAcpiMethodToMethodAsUlong(c1, c2, c3, c4) \
    ((ULONG)( c1 | (c2 << 8) | (c3 << 16) | (c4 << 24)))
        
#define _WDGMethodAsULONG (WmiAcpiMethodToMethodAsUlong('_','W','D','G'))

#define _WEDMethodAsULONG (WmiAcpiMethodToMethodAsUlong('_','W','E','D'))

typedef struct
{
    GUID Guid;             // Guid that names data block
    union
    {
        CHAR ObjectId[2];  // 2 character ACPI id for Data Blocks and Methods
        struct 
        {
            UCHAR NotificationValue;  // Byte value passed by event handler control method
            UCHAR Reserved[1];
        } NotifyId;
    };
    UCHAR InstanceCount;
    UCHAR Flags;
} WMIACPIGUIDMAP, *PWMIACPIGUIDMAP;

// Set this flag if the WCxx control method should be run to whenever 
// the first data consumer is interested in collecting the data block 
// and whenever the last data consumer is no longer interested.
#define WMIACPI_REGFLAG_EXPENSIVE   0x1

// Set this flag if the guid represents a set of WMI method calls and 
// not a data block
#define WMIACPI_REGFLAG_METHOD      0x2

// Set this flag if the data block is wholly composed of a string 
// and should be translated from ASCIZ to UNICODE in returning queries 
// and from UNICODE to ASCIZ when
// passing sets
#define WMIACPI_REGFLAG_STRING      0x04

// Set this flag if the guid maps to an event rather than a data block 
// or method
#define WMIACPI_REGFLAG_EVENT       0x08

typedef struct
{
    WORK_QUEUE_ITEM WorkQueueItem;
    PVOID CallerContext;
    PWORKER_THREAD_ROUTINE CallerWorkItemRoutine;
    PDEVICE_OBJECT DeviceObject;
    ULONG Status;
    PUCHAR OutBuffer;
    ULONG OutBufferSize;
} IRP_CONTEXT_BLOCK, *PIRP_CONTEXT_BLOCK;

//
// This defines the maximum size for the data returned from the _WED method
// and thus the maximum size of the data associated with an event
#define _WEDBufferSize 512

//
// Device extension for WMI acpi mapping devices
typedef struct
{
    PDEVICE_OBJECT LowerDeviceObject;
    PDEVICE_OBJECT LowerPDO;
    ULONG GuidMapCount;
    PWMIACPIMAPINFO WmiAcpiMapInfo;
    ULONG Flags;
    WMILIB_CONTEXT WmilibContext;    
    
    ACPI_INTERFACE_STANDARD      WmiAcpiDirectInterface;

    BOOLEAN AcpiNotificationEnabled;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// If this flag is set that means that the device has been removed from the
// system and any requests sent to it should be rejected. The only memory
// that can be relied upon is the DeviceExtension, but nothing that the
// device extension points to.
#define DEVFLAG_REMOVED                           0x00000001

//
// If this flag is set then the device has successfully registered with WMI
#define DEVFLAG_WMIREGED                          0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\wmiacpi\sample\makefile.inc ===
#
# generate auxilary files from the binary mof (bmf) file
#
# acpimof.vbs is a ready to run vbscript applet that will query all classes
#            in the mof. Once you add the ASL to the bios, 
#            update the registry, reboot, and ensure that the wmiacpi driver
#            has loaded run the script at the command line by typing: 
#            acpimof.vbs.

clean:
    del acpimof.vbs

$(O)\acpimof.bmf : $(O)\acpimof.mof

$(O)\acpimof.vbs: $(O)\acpimof.bmf
    wmimofck -t$(O)\acpimof.vbs $(O)\acpimof.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agp440\agp440.h ===
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440LX2_IDENTIFIER   0x71828086
#define AGP_440BX_IDENTIFIER    0x71908086
#define AGP_815_IDENTIFIER      0x11308086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define READ_SYNC_ENABLE 0x2000

#define Read440Config(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define Write440Config(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

#define AP_815_SIZE_COUNT 2
#define AP_815_MAX_SIZE (64 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL {
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG {
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    ULONGLONG           SpecialTarget;
} AGP440_EXTENSION, *PAGP440_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\tools\unasm2\unasm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unasm.c

Abstract:

    This unassembles an AML file

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

ULONG   DSDTLoaded = FALSE;

UCHAR
LOCAL
ComputeDataCheckSum(
    PUCHAR  OpCode,
    ULONG   Length
    )
/*++

Routine Description:

    This routine performs a data check sum on the supplied opcode pointer

Arguments:

    OpCode  - Data Buffer
    Length  - Number of bytes in buffer

Return Value:

    UCHAR

--*/
{
    UCHAR   checkSum = 0;

    while (Length > 0) {

        checkSum += *OpCode;
        OpCode++;
        Length--;

    }

    return checkSum;
}

DllInit(
    HANDLE  Module,
    ULONG   Reason,
    ULONG   Reserved
    )
/*++

Routine Description:

    This routine is called to initialize the DLL

Arguments:


Return Value:

--*/
{
    switch (Reason) {
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

VOID
LOCAL
DumpCode(
    PUCHAR          *Opcode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    This routine doesn't do much right now, but it is the point where
    raw bytes should be displayed as well as the unassembly

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    if (PrintFunction != NULL) {

        PrintFunction("\n");

    }
}

PASLTERM
LOCAL
FindKeywordTerm(
    UCHAR   KeyWordGroup,
    UCHAR   Data
    )
/*++

Routine Description:

    Find a Keyword within the TermTable

Arguments:

    KeyWordGroup    - What to search for
    Data            - Data to match keyword

Return Value:

    PASLTERM

--*/
{
    PASLTERM    term = NULL;
    ULONG       i;

    for (i = 0; TermTable[i].ID != NULL; i++) {

        if ((TermTable[i].TermClass == TC_KEYWORD) &&
            (TermTable[i].ArgActions[0] == KeyWordGroup) &&
            ((Data & (UCHAR)(TermTable[i].TermData >> 8)) ==
             (UCHAR)(TermTable[i].TermData & 0xff))) {

            break;

        }

    }

    if (TermTable[i].ID != NULL) {

        term = &TermTable[i];

    }


    return term;
}

UCHAR
LOCAL
FindOpClass(
    UCHAR       OpCode,
    POPMAP      OpCodeTable
    )
/*++

Routine Description:

    Find opcode class of extended opcode

Arguments:

    OpCode      - The Opcode to look up
    OpCodeTable - The table to look in

Return Value:

    UCHAR

--*/
{
    UCHAR   opCodeClass = OPCLASS_INVALID;

    while (OpCodeTable->OpCodeClass != 0) {

        if (OpCode == OpCodeTable->ExtendedOpCode) {

            opCodeClass = OpCodeTable->OpCodeClass;
            break;

        }


        OpCodeTable++;

    }

    return opCodeClass;
}

PASLTERM
LOCAL
FindOpTerm(
    ULONG   OpCode
    )
/*++

Routine Description:

    Find an OpCode within the TermTable

Arguments:

    OpCode  - What to look for in the TermTable

Return Value:

    PASLTERM

--*/
{
    PASLTERM    term = NULL;
    ULONG       i;

    for (i = 0; TermTable[i].ID != NULL; i++) {

        if ( (TermTable[i].OpCode == OpCode) &&
             (TermTable[i].TermClass & TC_OPCODE_TERM) ) {

            break;

        }

    }

    if (TermTable[i].ID != NULL) {

        term = &TermTable[i];

    }


    return term;
}

ULONG
EXPORT
IsDSDTLoaded(
    VOID
    )
/*++

Routine Description:

    This routine returns wether or not we have loaded a DSDT image

Arguments:

    None

Return:

    ULONG

--*/
{
    return DSDTLoaded;
}

NTSTATUS
LOCAL
ParseNameTail(
    PUCHAR  *OpCode,
    PUCHAR  Buffer,
    ULONG   Length
    )
/*++

Routine Description:

    Parse AML name tail

Arguments:

    OpCode  - Pointer to the OpCode
    Buffer  - Where to hold the parsed named
    Length  - Index to the tail of Buffer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       numSegments = 0;

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**OpCode == '\0'){

        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*OpCode)++;

    } else if (**OpCode == OP_MULTI_NAME_PREFIX) {

        (*OpCode)++;
        numSegments = (ULONG)**OpCode;
        (*OpCode)++;

    } else if (**OpCode == OP_DUAL_NAME_PREFIX) {

        (*OpCode)++;
        numSegments = 2;

    } else {

        numSegments = 1;

    }

    while ((numSegments > 0) && (Length + sizeof(NAMESEG) < MAX_NAME_LEN)) {

        strncpy(&Buffer[Length], (PUCHAR)(*OpCode), sizeof(NAMESEG));
        Length += sizeof(NAMESEG);
        *OpCode += sizeof(NAMESEG);
        numSegments--;

        if ((numSegments > 0) && (Length + 1 < MAX_NAME_LEN)) {

            Buffer[Length] = '.';
            Length++;

        }

    }

    if (numSegments > 0) {

        status = STATUS_NAME_TOO_LONG;

    } else {

        Buffer[Length] = '\0';

    }

    return status;
}

ULONG
LOCAL
ParsePackageLen(
    PUCHAR  *OpCode,
    PUCHAR  *OpCodeNext
    )
/*++

Routine Description:

    Parses the packages length

Arguments:

    OpCode      - Pointer to the current instruction
    OpCodeNode  - Where to hold a pointer to the next instruction

Return Value:

    ULONG - Package Length

--*/
{
    UCHAR   noBytes;
    UCHAR   i;
    ULONG   length;

    if (OpCodeNext != NULL) {

        *OpCodeNext = *OpCode;

    }

    length = (ULONG)(**OpCode);
    (*OpCode)++;
    noBytes = (UCHAR)((length & 0xc0) >> 6);
    if (noBytes != 0) {

        length &= 0x0000000f;
        for (i = 0; i < noBytes; i++) {

            length |= (ULONG)(**OpCode) << (i*8 + 4);
            (*OpCode)++;

        }

    }

    if (OpCodeNext != NULL) {

        *OpCodeNext += length;

    }
    return length;
}

VOID
LOCAL
PrintIndent(
    PUNASM_PRINT    PrintFunction,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Does the indenting required

Arguments:

    PrintFunction   - Function to call to indent
    IndentLevel     - How many levels to indent

Return Value:

    VOID

--*/
{
    ULONG   i;

    for (i = 0; i < IndentLevel; i++) {

        PrintFunction("  ");

    }

}

NTSTATUS
LOCAL
UnAsmArgs(
    PUCHAR          UnAsmArgTypes,
    PUCHAR          ArgActions,
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble Arguments:

Arguments:

    UnAsmArgTypes   - UnAsm ArgTypes String
    ArgActions      - Arg Action Types
    OpCode          - Pointer to the OpCode
    NameObject      - To hold created object
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PASLTERM        term;
    static UCHAR    argData = 0;
    ULONG           i;
    ULONG           numArgs;

    numArgs = strlen(UnAsmArgTypes);
    if (PrintFunction != NULL) {

        PrintFunction("(");

    }

    for (i = 0; i < numArgs; i++){

        if ((i != 0) && (PrintFunction != NULL)) {

            PrintFunction(", ");

        }

        switch (UnAsmArgTypes[i]) {
            case 'N':

                ASSERT(ArgActions != NULL);
                status = UnAsmNameObj(
                    OpCode,
                    (islower(ArgActions[i])? NameObject: NULL),
                    ArgActions[i],
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );
                break;

            case 'O':

                if ((**OpCode == OP_BUFFER) || (**OpCode == OP_PACKAGE) ||
                    (OpClassTable[**OpCode] == OPCLASS_CONST_OBJ)) {

                    term = FindOpTerm( (ULONG)(**OpCode) );
                    ASSERT(term != NULL);
                    (*OpCode)++;
                    status = UnAsmTermObj(
                        term,
                        OpCode,
                        PrintFunction,
                        BaseAddress,
                        IndentLevel
                        );

                } else {

                    status = UnAsmDataObj(
                        OpCode,
                        PrintFunction,
                        BaseAddress,
                        IndentLevel);

                }
                break;

            case 'C':

                status = UnAsmOpcode(
                    OpCode,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );
                break;

            case 'B':

                if (PrintFunction != NULL) {

                    PrintFunction("0x%x", **OpCode);

                }
                *OpCode += sizeof(UCHAR);
                break;

            case 'K':
            case 'k':

                if (UnAsmArgTypes[i] == 'K') {

                    argData = **OpCode;
                }

                if ((ArgActions != NULL) && (ArgActions[i] == '!')) {

                    if (*NameObject != NULL) {

                        (*NameObject)->ObjectData.DataValue =
                            (ULONG)(**OpCode & 0x07);

                    }

                    if (PrintFunction != NULL) {

                        PrintFunction("0x%x", **OpCode & 0x07);

                    }

                } else if (PrintFunction != NULL) {

                    term = FindKeywordTerm(ArgActions[i], argData);
                    ASSERT(term != NULL);
                    PrintFunction("%s", term->ID);

                }

                if (UnAsmArgTypes[i] == 'K') {

                    *OpCode += sizeof(UCHAR);

                }
                break;

            case 'W':

                if (PrintFunction != NULL) {

                    PrintFunction("0x%x", *( (PUSHORT)*OpCode ) );

                }
                *OpCode += sizeof(USHORT);
                break;

            case 'D':

                if (PrintFunction != NULL) {

                    PrintFunction("0x%x", *( (PULONG)*OpCode ) );

                }
                *OpCode += sizeof(ULONG);
                break;

            case 'S':

                ASSERT(ArgActions != NULL);
                status = UnAsmSuperName(
                    OpCode,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );
                break;

            default:

                status = STATUS_ACPI_INVALID_ARGTYPE;

        }

    }

    if (PrintFunction != NULL) {

        PrintFunction(")");

    }
    return status;

}

NTSTATUS
LOCAL
UnAsmDataList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble Data List

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       i;

    //
    // This is another place that DumpCode() was being called from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }

    while (*OpCode < OpCodeEnd) {

        if (PrintFunction != NULL) {

            PrintFunction("\t0x%02x", **OpCode);

        }

        (*OpCode)++;
        for (i = 1; (*OpCode < OpCodeEnd) && (i < 12); ++i) {

            if (PrintFunction != NULL) {

                PrintFunction(", 0x%02x", **OpCode);

            }
            (*OpCode)++;

        }

        if (PrintFunction != NULL) {

            if (*OpCode < OpCodeEnd) {

                PrintFunction(",");

            }
            PrintFunction("\n");

        }
    }

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }
    return status;
}

NTSTATUS
LOCAL
UnAsmDataObj(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassembles a data object

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    UCHAR       localOpcode = **OpCode;

    (*OpCode)++;
    switch (localOpcode)
    {
        case OP_BYTE:
            if (PrintFunction != NULL)
            {
                PrintFunction("0x%x", **OpCode);
            }
            *OpCode += sizeof(UCHAR);
            break;

        case OP_WORD:
            if (PrintFunction != NULL)
            {
                PrintFunction("0x%x", *((PUSHORT)*OpCode));
            }
            *OpCode += sizeof(USHORT);
            break;

        case OP_DWORD:
            if (PrintFunction != NULL)
            {
                PrintFunction("0x%x", *((PULONG)*OpCode));
            }
            *OpCode += sizeof(ULONG);
            break;

        case OP_STRING:
            if (PrintFunction != NULL)
            {
                PrintFunction("\"%s\"", *OpCode);
            }
            *OpCode += strlen((PUCHAR)*OpCode) + 1;
            break;

        default:
            status = STATUS_ACPI_INVALID_OPCODE;

    }

    return status;
}

NTSTATUS
EXPORT
UnAsmDSDT(
    PUCHAR          DSDT,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       DsdtLocation,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    This routine unassembles an entire DSDT table

Arguments:

    DSDT            - Where the DSDT is located in memory
    PrintFunction   - What function to call to print to the user
    DsdtLocation    - Where the DSDT is located in memory
    IndentLevel     - How much space to indent from the left margin

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDESCRIPTION_HEADER header = (PDESCRIPTION_HEADER) DSDT;

    ASSERT(RootNameSpaceObject != NULL);
    CurrentOwnerNameSpaceObject = NULL;
    CurrentScopeNameSpaceObject = RootNameSpaceObject;
    TopOpcode = CurrentOpcode = DSDT;

    //
    // Dump the header
    //
    status = UnAsmHeader( header, PrintFunction, DsdtLocation, IndentLevel );
    if (NT_SUCCESS(status)) {

        DSDT += sizeof(DESCRIPTION_HEADER);
        status = UnAsmScope(
            &DSDT,
            (PUCHAR) (DSDT + header->Length - sizeof(DESCRIPTION_HEADER)),
            PrintFunction,
            DsdtLocation,
            IndentLevel
            );

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmField(
    PUCHAR          *OpCode,
    PULONG          BitPos,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble field

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;

    if (**OpCode == 0x01) {

        (*OpCode)++;
        if (PrintFunction != NULL) {

            PASLTERM term;

            term = FindKeywordTerm('A', **OpCode);
            PrintFunction(
                "AccessAs(%s, 0x%x)",
                term->ID,
                *(*OpCode + 1)
                );

        }
        *OpCode += 2;

    } else {

        UCHAR   nameSeg[sizeof(NAMESEG) + 1];
        ULONG   length;

        if (**OpCode == 0) {

            nameSeg[0] = '\0';
            (*OpCode)++;

        } else {

            strncpy(nameSeg, (PUCHAR)*OpCode, sizeof(NAMESEG));
            nameSeg[sizeof(NAMESEG)] = '\0';
            *OpCode += sizeof(NAMESEG);

        }

        length = ParsePackageLen(
            OpCode,
            NULL
            );
        if (nameSeg[0] == '\0') {

            if (PrintFunction != NULL) {

                if ((length > 32) && (((*BitPos + length) % 8) == 0)) {

                    PrintFunction(
                        "Offset(0x%x)",
                        (*BitPos + length)/8
                        );

                } else {

                    PrintFunction(
                        ", %d",
                        length
                        );

                }

            }

        } else {

            if (PrintFunction != NULL) {

                PrintFunction(
                    "%s, %d",
                    nameSeg,
                    length
                    );

            }

            if (PrintFunction == NULL) {

                status = CreateObject(
                    nameSeg,
                    NSTYPE_FIELDUNIT,
                    NULL
                    );

            }

        }
        *BitPos += length;

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmFieldList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble field list

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       bitPos = 0;

    //
    // This is another place that DumpCode() was being called from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }
    IndentLevel++;

    while ((*OpCode < OpCodeEnd) && NT_SUCCESS(status)) {

        if (PrintFunction != NULL) {

            PrintIndent(PrintFunction, IndentLevel);

        }

        status = UnAsmField(
            OpCode,
            &bitPos,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

        if (NT_SUCCESS(status) && (*OpCode < OpCodeEnd) &&
            (PrintFunction != NULL) ) {

            PrintFunction(",");

        }

        //
        // This is another place that DumpCode() was being called from
        //
        DumpCode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    }

    IndentLevel--;
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmHeader(
    PDESCRIPTION_HEADER DsdtHeader,
    PUNASM_PRINT        PrintFunction,
    ULONG_PTR           DsdtLocation,
    ULONG               IndentLevel
    )
/*++

Routine Description:

    Unassembles the DSDT header

Arguments:

    DsdtHeader      - Header to unassemble
    PrintFunction   - Function to call to display information
    DsdtLocation    - Where in memory the DSDT Lives
    IndentLevel     - How much space to indent from the left margin

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    UCHAR       signature[sizeof(DsdtHeader->Signature) + 1] = {0};
    UCHAR       oemID[sizeof(DsdtHeader->OEMID) + 1] = {0};
    UCHAR       oemTableID[sizeof(DsdtHeader->OEMTableID) + 1] = {0};
    UCHAR       creatorID[sizeof(DsdtHeader->CreatorID) + 1] = {0};
    UCHAR       checkSum;

    //
    // Lets do a checksump on the entire table
    //
    checkSum = ComputeDataCheckSum(
        (PUCHAR) DsdtHeader,
        DsdtHeader->Length
        );
    if (checkSum != 0) {

        status = STATUS_ACPI_INVALID_TABLE;

    }

    strncpy(
        signature,
        (PUCHAR)&DsdtHeader->Signature,
        sizeof(DsdtHeader->Signature)
        );
    strncpy(
        oemID,
        (PUCHAR) DsdtHeader->OEMID,
        sizeof(DsdtHeader->OEMID)
        );
    strncpy(
        oemTableID,
        (PUCHAR) DsdtHeader->OEMTableID,
        sizeof(DsdtHeader->OEMTableID)
        );
    strncpy(
        creatorID,
        (PUCHAR) DsdtHeader->CreatorID,
        sizeof(DsdtHeader->CreatorID)
        );

    if (PrintFunction != NULL) {

        PrintIndent( PrintFunction, IndentLevel );
        PrintFunction(
            "// CreatorID = %s\tCreatorRevision =%x.%x.%d\n",
            creatorID,
            DsdtHeader->CreatorRev >> 24,
            ( (DsdtHeader->CreatorRev >> 16) & 0xFF),
            (DsdtHeader->CreatorRev & 0xFFFF)
            );

        PrintIndent( PrintFunction, IndentLevel );
        PrintFunction(
            "// TableLength = %d\tTableChkSum=0x%x\n\n",
            DsdtHeader->Length,
            DsdtHeader->Checksum
            );

        PrintIndent( PrintFunction, IndentLevel );
        PrintFunction(
            "DefinitionBlock(\"%s.AML\", \"%s\", 0x%02x, \"%s\", \"%s\", 0x%08x)",
            signature,
            signature,
            DsdtHeader->Revision,
            oemID,
            oemTableID,
            DsdtHeader->OEMRevision
            );

    }

    return status;
}

NTSTATUS
EXPORT
UnAsmLoadDSDT(
    PUCHAR          DSDT
    )
/*++

Routine Description:

    This routine causes the unassmebler to initialize itself with the
    given DSDT

Arguments:

    DSDT            - Where the DSDT is located in memory
    PrintFunction   - What function to call to print to the user
    DsdtLocation    - Where the DSDT is located in memory
    IndentLevel     - How much space to indent from the left margin

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDESCRIPTION_HEADER header = (PDESCRIPTION_HEADER) DSDT;
    PUCHAR              localDSDT;

    ENTER( (1, "UnAsmLoadDSDT(%08lx)\n", DSDT) );

    //
    // Step 1: Create the root namespace
    //
    status = CreateNameSpaceObject( "\\", NULL, NULL, NULL, NSF_EXIST_ERR );
    if (NT_SUCCESS(status)) {

        static struct _defobj {
            PUCHAR  Name;
            ULONG   ObjectType;
        } DefinedRootObjects[] = {
            "_GPE", OBJTYPE_UNKNOWN,
            "_PR", OBJTYPE_UNKNOWN,
            "_SB", OBJTYPE_UNKNOWN,
            "_SI", OBJTYPE_UNKNOWN,
            "_TZ", OBJTYPE_UNKNOWN,
            "_REV", OBJTYPE_INTDATA,
            "_OS", OBJTYPE_STRDATA,
            "_GL", OBJTYPE_MUTEX,
            NULL, 0
        };
        ULONG   i;
        PNSOBJ  nameObject;

        CurrentScopeNameSpaceObject = RootNameSpaceObject;
        for (i = 0; DefinedRootObjects[i].Name != NULL; i++) {

            //
            // Step 2: Create the fixed objects
            //
            status = CreateNameSpaceObject(
                DefinedRootObjects[i].Name,
                NULL,
                NULL,
                &nameObject,
                NSF_EXIST_ERR
                );
            if (NT_SUCCESS(status)) {

                nameObject->ObjectData.DataType =
                    DefinedRootObjects[i].ObjectType;

            } else {

                break;

            }

        }

        if (NT_SUCCESS(status)) {

            ASSERT(RootNameSpaceObject != NULL);
            CurrentOwnerNameSpaceObject = NULL;
            CurrentScopeNameSpaceObject = RootNameSpaceObject;
            TopOpcode = CurrentOpcode = DSDT;

            //
            // Step 3: Dump the header
            //
            status = UnAsmHeader( header, NULL, 0, 0 );
            if (NT_SUCCESS(status)) {

                //
                // Step 4: Dump the scope
                //
                localDSDT = DSDT + sizeof(DESCRIPTION_HEADER);
                status = UnAsmScope(
                    &localDSDT,
                    (PUCHAR) (DSDT + header->Length),
                    NULL,
                    0,
                    0
                    );

            }

        }

    }

    if (NT_SUCCESS(status)) {

        DSDTLoaded = 1;

    }

    EXIT( (1, "UnAsmLoadDSDT=%08lx\n", status ) );
    return status;
}

NTSTATUS
LOCAL
UnAsmNameObj(
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    UCHAR           ObjectType,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble name object

Arguments:

    OpCode          - Pointer to the OpCode
    NameObject      - Where to store the NS object if one is found/created
    ObjecType       - Type of NS object
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    UCHAR       name[MAX_NAME_LEN + 1];
    ULONG       length = 0;

    name[0] = '\0';
    if (**OpCode == OP_ROOT_PREFIX){

        name[length] = '\\';
        length++;
        (*OpCode)++;
        status = ParseNameTail(OpCode, name, length);

    } else if (**OpCode == OP_PARENT_PREFIX) {

        name[length] = '^';
        length++;
        (*OpCode)++;
        while ((**OpCode == OP_PARENT_PREFIX) && (length < MAX_NAME_LEN)) {

            name[length] = '^';
            length++;
            (*OpCode)++;

        }

        if (**OpCode == OP_PARENT_PREFIX) {

            status = STATUS_OBJECT_NAME_INVALID;

        } else {

            status = ParseNameTail(OpCode, name, length);

        }

    } else {

        status = ParseNameTail(OpCode, name, length);
    }

    if (NT_SUCCESS(status)) {

        PNSOBJ localObject = NULL;

        if (PrintFunction != NULL) {

            PrintFunction("%s", name);

        }

        if (isupper(ObjectType) || (PrintFunction != NULL)) {

            status = GetNameSpaceObject(
                name,
                CurrentScopeNameSpaceObject,
                &localObject,
                0
                );
            if (!NT_SUCCESS(status)) {

                status = STATUS_SUCCESS;

            }

        } else {

            status = CreateObject(
                name,
                (UCHAR) _toupper(ObjectType),
                &localObject
                );

        }

        if (NT_SUCCESS(status)) {

            if ((ObjectType == NSTYPE_SCOPE) && (localObject != NULL)) {

                CurrentScopeNameSpaceObject = localObject;

            }

            if (NameObject != NULL) {

                *NameObject = localObject;

            }

        }

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmOpcode(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble an Opcode

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PASLTERM    term;
    PNSOBJ      nameObject;
    UCHAR       opCodeClass;
    UCHAR       unAsmArgTypes[MAX_ARGS+1];
    ULONG       i;
    ULONG       localOpCode;

    if (**OpCode == OP_EXT_PREFIX) {

        (*OpCode)++;
        localOpCode = ( ( (ULONG) **OpCode) << 8) | OP_EXT_PREFIX;
        opCodeClass = FindOpClass(**OpCode, ExOpClassTable);

    } else {

        localOpCode = (ULONG)(**OpCode);
        opCodeClass = OpClassTable[**OpCode];

    }

    switch (opCodeClass) {
        case OPCLASS_DATA_OBJ:
            status = UnAsmDataObj(
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );
            break;

        case OPCLASS_NAME_OBJ:
            status = UnAsmNameObj(
                OpCode,
                &nameObject,
                NSTYPE_UNKNOWN,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );
            if (NT_SUCCESS(status) && nameObject != NULL &&
                nameObject->ObjectData.DataType == OBJTYPE_METHOD) {

                for (i = 0; i < nameObject->ObjectData.DataValue; i++) {

                    unAsmArgTypes[i] = 'C';

                }
                unAsmArgTypes[i] = '\0';

                status = UnAsmArgs(
                    unAsmArgTypes,
                    NULL,
                    OpCode,
                    NULL,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );

            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:

            term = FindOpTerm( localOpCode );
            if (term == NULL) {

                status = STATUS_ACPI_INVALID_OPCODE;

            } else {

                (*OpCode)++;
                status = UnAsmTermObj(
                    term,
                    OpCode,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );

            }
            break;

        default:
            status = STATUS_ACPI_INVALID_OPCODE;
    }

    return status;
}

NTSTATUS
LOCAL
UnAsmPkgList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble Package List

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PASLTERM    term;

    //
    // This is another place that DumpCode() was being called from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }
    IndentLevel++;

    while ((*OpCode < OpCodeEnd) && NT_SUCCESS(status)) {

        if (PrintFunction != NULL) {

            PrintIndent(PrintFunction, IndentLevel);

        }

        if ((**OpCode == OP_BUFFER) ||
            (**OpCode == OP_PACKAGE) ||
            (OpClassTable[**OpCode] == OPCLASS_CONST_OBJ) ) {

            term = FindOpTerm( (ULONG)(**OpCode) );
            ASSERT(term != NULL);
            (*OpCode)++;
            status = UnAsmTermObj(
                term,
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (OpClassTable[**OpCode] == OPCLASS_NAME_OBJ) {

            status = UnAsmNameObj(
                OpCode,
                NULL,
                NSTYPE_UNKNOWN,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else {

            status = UnAsmDataObj(
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        }

        if ((*OpCode < OpCodeEnd) && NT_SUCCESS(status) &&
            (PrintFunction != NULL) ) {

            PrintFunction(",");

        }

        //
        // This is another place that DumpCode() was being called from
        //
        DumpCode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    }

    IndentLevel--;
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }


    return status;
}

NTSTATUS
LOCAL
UnAsmScope(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    OpCode          - Pointer to the current Opcode
    OpCodeEnd       - End of Scope
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;

    //
    // Note: This is where DumpCode used to be called, so if this code
    // is ever changed to dump the by bytes of the previous whatever, then
    // this is where it needs to be done from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    //
    // Indent to the proper amount and dump opening brace
    //
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }

    //
    // Increase the indent level for future recursion
    //
    IndentLevel++;

    //
    // Loop while there are bytes in the scope
    //
    while ((NT_SUCCESS(status)) && (*OpCode < OpCodeEnd)) {

        //
        // Indent Again
        //
        if (PrintFunction != NULL) {

            PrintIndent(PrintFunction, IndentLevel);

        }

        //
        // Unassemble
        //
        status = UnAsmOpcode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

        //
        // This is another place where DumpCode was being called from
        //
        if ( StartOpcode != *OpCode) {

            DumpCode(
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (PrintFunction != NULL) {

            PrintFunction("\n");

        }

    }

    //
    // Return the IndentLevel to its proper value
    //
    IndentLevel--;

    //
    // Print the trailing brace
    //
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
LOCAL
UnAsmSuperName(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble supernames

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if (**OpCode == 0) {

        (*OpCode)++;

    } else if ((**OpCode == OP_EXT_PREFIX) && (*(*OpCode + 1) == EXOP_DEBUG)) {

        if (PrintFunction != NULL) {

            PrintFunction("Debug");

        }
        *OpCode += 2;

    } else if (OpClassTable[**OpCode] == OPCLASS_NAME_OBJ) {

        status = UnAsmNameObj(
            OpCode,
            NULL,
            NSTYPE_UNKNOWN,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    } else if ((**OpCode == OP_INDEX) ||
        (OpClassTable[**OpCode] == OPCLASS_ARG_OBJ) ||
        (OpClassTable[**OpCode] == OPCLASS_LOCAL_OBJ)) {

        status = UnAsmOpcode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    } else {

        status = STATUS_ACPI_INVALID_SUPERNAME;

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmTermObj(
    PASLTERM        Term,
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble term object

Arguments:

    Term            - Term Table Entry
    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      scopeObject = CurrentScopeNameSpaceObject;
    PNSOBJ      nameObject = NULL;
    PUCHAR      opCodeEnd = NULL;

    if (PrintFunction != NULL) {

        PrintFunction("%s", Term->ID);

    }

    if (Term->Flags & TF_PACKAGE_LEN) {

        ParsePackageLen(OpCode, &opCodeEnd);

    }

    if (Term->UnAsmArgTypes != NULL) {

        status = UnAsmArgs(
           Term->UnAsmArgTypes,
           Term->ArgActions,
           OpCode,
           &nameObject,
           PrintFunction,
           BaseAddress,
           IndentLevel
           );

    }

    if (NT_SUCCESS(status)) {

        if (Term->Flags & TF_DATA_LIST) {

            status = UnAsmDataList(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (Term->Flags & TF_PACKAGE_LIST) {

            status = UnAsmPkgList(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (Term->Flags & TF_FIELD_LIST) {

            status = UnAsmFieldList(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (Term->Flags & TF_PACKAGE_LEN) {

            if (nameObject != NULL) {

                CurrentScopeNameSpaceObject = nameObject;

            }
            status = UnAsmScope(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        }


    }


    CurrentScopeNameSpaceObject = scopeObject;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agp460\gart.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 460xx GART aperture

Author:

    Sunil A Kulkarni -  3/08/2000

  Initial Version:
    Naga Gurumoorthy -  6/11/1999

Revision History:

--*/
#include "agp460.h"

//
// Local function prototypes
//
NTSTATUS
Agp460CreateGart(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
Agp460SetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE
Agp460FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
Agp460SetGTLB_Enable(
    IN PAGP460_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, Agp460CreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, Agp460FindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif


NTSTATUS
AgpQueryAperture(
    IN  PAGP460_EXTENSION	    AgpContext,
    OUT PHYSICAL_ADDRESS	    *CurrentBase,
    OUT ULONG			    *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST  *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONGLONG ApBase;  //Aperture Base registers (APBASE & BAPBASE) are 64bit wide
    UCHAR     ApSize;  //AGPSIZ register is 8bits
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Index;
    ULONG Length;
    ULONG CBN;
    ULONG uiAp_Size_Count;
    
    PAGED_CODE();

    
    AGPLOG(AGP_NOISE, ("AGP460: AgpQueryAperture entered.\n"));
    
    //
    // Get the current APBASE and APSIZE settings
    //
    Read460CBN((PVOID)&CBN);
    EXTRACT_LSBYTE(CBN); // Zero out bits (32-8) as CBN is 8-bit wide - Sunil
    
    // Read the Aperture Size (AGPSIZ) first.  
    Read460Config(CBN,(PVOID) &ApSize, APSIZE_OFFSET, sizeof(ApSize));
    EXTRACT_LSBYTE(ApSize);   // Zero out bits (32-8) as ApSize is 8-bit wide - Sunil
    
    // If AGPSIZ[3] is 1, then Aperture Base is stored in BAPBASE.
    // else (when AGPSIZE[3] = 0, APBASE has the Aperture base address.
    if (ABOVE_TOM(ApSize)){
        Read460Config(CBN, (PVOID)&ApBase, BAPBASE_OFFSET, sizeof(ApBase));
    }else{
        Read460Config(CBN, (PVOID)&ApBase, APBASE_OFFSET, sizeof(ApBase));
    }
    
    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK_64;
    
    //
    // Convert APSIZE into the actual size of the aperture.
    // TO DO: Should we return the Current Size in OS page size or chipset page
    // size ? - Naga G
    //
    *CurrentSizeInPages = 0;
    
    if (ApSize & AP_SIZE_256MB) {
        *CurrentSizeInPages = (AP_256MB / PAGE_SIZE);

    } else {
        if (ApSize & AP_SIZE_1GB) {
            *CurrentSizeInPages = (AP_1GB / PAGE_SIZE);
        }
        
        // BUGBUG !32GB Aperture size is possible only with 4MB page size.
        // Currently this is not handled. Once this case is included, the
        // size of CurrentSizeInPages must be changed to ULONGLONG and there 
        // should be corresponding changes in the structures where this value 
        // will be stored - Sunil 3/16/00
        //else{
        //	if (ApSize & AP_SIZE_32GB)
        //		*CurrentSizeInPages = (AP_32GB / PAGE_SIZE);
        //}
    }                  
    
    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength         = *CurrentSizeInPages * PAGE_SIZE;
    
    if (pApertureRequirements != NULL) {
        
        //
        // 460 supports only the boot config, or "preferred" descriptor
        //
        *pApertureRequirements = NULL;
    }
	
    AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPQueryAperture.\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
AgpSetAperture(
    IN PAGP460_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    UCHAR ApSize;
    ULONGLONG ApBase;
	ULONG CBN;
	UCHAR ulTemp;

	AGPLOG(AGP_NOISE, ("AGP460: AgpSetAperture entered.\n"));

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) 
	{
        case AP_256MB / PAGE_SIZE:
				ApSize = AP_SIZE_256MB;
				break;
        case AP_1GB / PAGE_SIZE:
				ApSize = AP_SIZE_1GB;
				break;
        // TO DO: 4MB pages are not supported at this time. In the future,
		// we might have to support it. - Naga G
        default:
				AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
				ASSERT(FALSE);
				return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);

    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // Having validated the arguments now we need to reset the hardware 
	// to match the supplied settings.
    //
    // Unlike 440, 460GX has no hardware support to disable the use of GART table when
	// we are writing the new settings. 
    //
     
	//
	// Read the CBN first
	//
	Read460CBN((PVOID)&CBN);
	EXTRACT_LSBYTE(CBN); // Sunil

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //

	Read460Config(CBN, &ulTemp, APSIZE_OFFSET, sizeof(ulTemp));
	
	ulTemp &= 0xff;
	
	ulTemp &= 0xF8;     // To mask everything but the last 3 bits which contain 
						// the aperture size.

	ulTemp |= ApSize;   // Now, incorporate the new aperture size into the AGPSIZ 
						// keeping the first 5 bits as the same.
    Write460Config(CBN, &ulTemp, APSIZE_OFFSET, sizeof(ulTemp));

	
    //
    // Now we can update APBASE
    //
	ApBase = NewBase.QuadPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK_64;

	if (ABOVE_TOM(ulTemp)){
       Write460Config(CBN, &ApBase, BAPBASE_OFFSET, sizeof(ApBase));
	}else{
       Write460Config(CBN, &ApBase, APBASE_OFFSET, sizeof(ApBase));
	}


#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONGLONG DbgBase;
        UCHAR DbgSize;

        Read460Config(CBN,&DbgSize, APSIZE_OFFSET, sizeof(ApSize));
		
		if (ABOVE_TOM(DbgSize)){
			Read460Config(CBN, &DbgBase, BAPBASE_OFFSET, sizeof(ApBase));
		}else{
			Read460Config(CBN, &DbgBase, APBASE_OFFSET, sizeof(ApBase));
		}

		AGPLOG(AGP_NOISE, ("APBase %08lx, DbgBase %08lx\n",ApBase,DbgBase));

		DbgSize &= 0x7; //Check only against size bits - Sunil
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK_64) == ApBase);
    }
#endif

    
    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart  = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpSetAperture.\n"));    

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGP460_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{

	AGPLOG(AGP_NOISE, ("AGP460: Entering AgpDisableAperture.\n"));    

    //
	// In 82460GX there exists no hardware means to enable/disable the Graphics
	// Aperture & GART Translation.  
	//    
    AgpContext->GlobalEnable = FALSE;

	//
	// TO DO: The only thing that could possibly be done is to set AGPSIZ[2:0] to 000
	// which would indicate that there exists no GART. Need to try it out. - Naga G
	//

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpDisableAperture.\n"));    

}


NTSTATUS
AgpReserveMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;
	ULONG OS_ChipsetPagesizeRatio;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPReserveMemory.\n"));    

    ASSERT((Range->Type == MmNonCached) ||
           (Range->Type == MmWriteCombined) ||
           (Range->Type == MmCached));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {

        ASSERT(AgpContext->GartLength == 0);
        Status = Agp460CreateGart(AgpContext,Range->NumberOfPages);

        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp460CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

	// if OS page size is 8KB then, OS_ChipsetPagesizeRatio would be 2. To map x OS pages
    // into the GART, we need x * OS_ChipsetPagesizeRatio of GART entries.
	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = Agp460FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages * OS_ChipsetPagesizeRatio,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages * OS_ChipsetPagesizeRatio,
                Range->Type,
                AgpContext->Gart));

        //
        // BUGBUG John Vert (jvert) 11/4/1997
        //  This is the point where we should try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %p\n",
            Range->NumberOfPages * OS_ChipsetPagesizeRatio,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (Range->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_WB;
    }

    for (Index = 0;Index < (Range->NumberOfPages * OS_ChipsetPagesizeRatio); Index++) 
	{
        ASSERT( (FoundRange[Index].Soft.Valid == 0) && 
			    (FoundRange[Index].Soft.State == GART_ENTRY_FREE));
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * AGP460_PAGE_SIZE_4KB;
    Range->Context = FoundRange;

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.QuadPart));

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPReserveMemory.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;
	ULONG OS_ChipsetPagesizeRatio;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPReleaseMemory.\n"));

	// if OS page size is 8KB then, OS_ChipsetPagesizeRatio would be 2. To map x OS pages
    // into the GART, we need x * OS_ChipsetPagesizeRatio of GART entries.
	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < ((PGART_PTE)Range->Context + Range->NumberOfPages * OS_ChipsetPagesizeRatio);
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else if (Range->Type == MmWriteCombined) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WB);
        }

        Pte->Soft.State = GART_ENTRY_FREE;
		Pte->Soft.Valid = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPReleaseMemory.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
Agp460CreateGart(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The 82460GX has a 2MB region for 
	GART.  This memory starts at 0xFE20 0000h.  In reality, this memory is a 
	SRAM that hangs off the GXB.  The minimum pages argument is ignored.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
   
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    ULONG i;
	PHYSICAL_ADDRESS GartStartingLocation;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGP460CreateGART.\n"));
      
    // Set the GArtLength to actual SRAM size on the GXB and not fixed size - Sunil
	//GartLength =  1 * 1024 * 1024; 
	GartLength = AgpContext->ApertureLength / ONE_KB;
	GartStartingLocation.QuadPart = ATTBASE;
    
    Gart = MmMapIoSpace(GartStartingLocation,GartLength,MmNonCached);

    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp460CreateGart - couldn't map GART \n"));
    } else {

        AGPLOG(AGP_NOISE,
               ("Agp460CreateGart - GART of length %lx created at "
                "VA %p, "
                "PA %I64x\n",
                GartLength,
                Gart,
                GartStartingLocation.QuadPart));
    }

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
		Gart[i].Soft.Valid = GART_ENTRY_FREE;
    }


    //
    // Update our extension to reflect the current state.
    //

    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGP460CreateGART.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PULONGLONG Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
	ULONG OS_ChipsetPagesizeRatio;
	ULONG RunningCounter;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPMapMemory.\n"));

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    if (Range->Type == MmNonCached)
        TargetState = GART_ENTRY_RESERVED_UC;
    else if (Range->Type == MmWriteCombined)
        TargetState = GART_ENTRY_RESERVED_WC;
    else
        TargetState = GART_ENTRY_RESERVED_WB;

	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    Pte = StartPte + (OffsetInPages * OS_ChipsetPagesizeRatio);

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount * OS_ChipsetPagesizeRatio <= StartPte + Range->NumberOfPages * OS_ChipsetPagesizeRatio);
    NewPte.AsUlong = 0;
    NewPte.Soft.Valid = TRUE;
    if (Range->Type == MmCached) {
        NewPte.Hard.Coherency = TRUE;
    }

    Page = (PULONGLONG)(Mdl + 1);

    RunningCounter = 0;
    //AGPLOG(AGP_NOISE, ("AGP460: Entering AGPMapMemory -- LOOP: Pte: %0x, newPte: %0x.\n",Pte,NewPte));

    for (Index = 0; Index < (PageCount * OS_ChipsetPagesizeRatio); Index++) 
	{
        ASSERT(Pte[Index].Soft.State == TargetState);

        //NewPte.Hard.Page = *Page++;
		NewPte.Hard.Page = (ULONG) (*Page << (PAGE_SHIFT - GART_PAGESHIFT_460GX)) + RunningCounter;		
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
		//AGPLOG(AGP_NOISE, ("AGP460: Page: %0x, newPte: %0x\n",Page,NewPte));
		RunningCounter++;

		if (RunningCounter == OS_ChipsetPagesizeRatio){
			RunningCounter = 0;
			Page++;
		}
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    

    AgpContext->GlobalEnable = TRUE;

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPMapMemory.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;
	ULONG OS_ChipsetPagesizeRatio;

    PAGED_CODE();

	
	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPUnMapMemory.\n"));

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages * OS_ChipsetPagesizeRatio];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (AgpRange->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_WB;
    }


    for (i=0; i < NumberOfPages * OS_ChipsetPagesizeRatio; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
			Pte[i].Soft.Valid = FALSE;
            LastChanged = Pte;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPUnMapMemory.\n"));

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp460FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGP460FindRangeInGART.\n"));

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if ((Current->Soft.State == SearchState) && (Current->Soft.Valid == 0)) 
		{
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
				
				AGPLOG(AGP_NOISE, ("AGP460: Leaving AGP460FindRangeInGart.\n"));
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGP460FindRangeInGART.\n"));
    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
	ULONG OS_ChipsetPagesizeRatio;
    
	
	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPFindFreeRun.\n"));

	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    Pte = (PGART_PTE)(AgpRange->Context) + (OffsetInPages * OS_ChipsetPagesizeRatio);

    //
    // Find the first free PTE
    //
    for (i=0; i< (NumberOfPages * OS_ChipsetPagesizeRatio); i++) {
        if (Pte[i].Hard.Valid == FALSE) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i/OS_ChipsetPagesizeRatio + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages * OS_ChipsetPagesizeRatio ) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                Pte[i].Hard.Valid = GART_ENTRY_VALID; // Sunil
                ++i;
            }
			*FreePages /= OS_ChipsetPagesizeRatio;
            AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPFindFreeRun - 1 Length: %0x, Offset: %0x\n",NumberOfPages,OffsetInPages));
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;

	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPFindFreeRun - 0 Length: %0x, Offset: %0x\n",NumberOfPages,OffsetInPages));
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONGLONG Pages;
    ULONG OS_ChipsetPagesizeRatio;
	ULONGLONG AddressFromPFN;
	NTSTATUS ProbeStatus;

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPGetMappedPages.\n"));

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONGLONG)(Mdl + 1);

	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages * OS_ChipsetPagesizeRatio;

    for (i=0; i< NumberOfPages ; i++) {
        ASSERT(Pte[i*OS_ChipsetPagesizeRatio].Hard.Valid == 1);
		AddressFromPFN = Pte[i*OS_ChipsetPagesizeRatio].Hard.Page << GART_PAGESHIFT_460GX;		
        Pages[i] = AddressFromPFN >> PAGE_SHIFT;
    }

    //Mdl->MdlFlags |= MDL_PAGES_LOCKED;  sunil - either you can set the bit here, or in ..../port/agp.c

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPGetMappedPages.\n"));
    return;
}


NTSTATUS
AgpSpecialTarget(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = Agp460SetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
Agp460SetRate(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP460SetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP460SetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP460SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP460SetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP460SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP460SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP460SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agp460\agp460.h ===
#include "agp.h"

#define PCI_ADDRESS_MEMORY_ADDRESS_MASK_64 0xFFFFFFFFFFFFFFF0UI64

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//

//
// TBD: The GART registers on the 460 live in the GXB.  Though we are trying to use
// the code from 440 as much as possible. The HalGet calls may not be needed if
// all the GART registers live on the PCI-PCI bridge (GXB).  DOUBLE CHECK THIS 
// WITH THE EDS, VERIFY IT WITH JOHN VERT - NAGA G
//

// Compared to 440 there exists no equivalents for PAC configuration, 
// AGP Control & ATTBASE registers in 460GX. 

#define EXTRACT_LSBYTE(x)       x = (x & 0xFF)  // Sunil

#define ONE_KB                  1024
#define ONE_MB                  (ONE_KB * ONE_KB)
#define AP_256MB                (256 * ONE_MB)
#define AP_1GB                  (ONE_MB * ONE_KB)
#define AP_32GB                 (32 * AP_1GB)

#define ABOVE_TOM(x)             ( (x) & (0x08) )

#define AGP_460GX_IDENTIFIER	0x84E28086	// Device ID & Vendor ID 
											// for the 460GX SAC


 
#define APBASE_OFFSET  0x10		// Aperture Base Address:APBASE & BAPBASE are used to
#define BAPBASE_OFFSET 0x98		// store the base address of the Graphics Aperture(GA).
								// Only one of APBASE or BAPBASE is visible at a time.
								// APBASE is visible when AGPSIZ[3]=0 && AGPSIZ[2:0]!=0. 
								// BAPBASE is visible when AGPSIZ[3]=1 & AGPSIZ[2:0]!=0.
								// BAPBASE is used when the GA is mapped above 4GB and
								// APBASE when the GA is mapped below 4GB


#define APSIZE_OFFSET  0xA2     // Aperture Size Register - AGPSIZ    


      
#define ATTBASE 0xFE200000		// Aperture Translation Table Base - It is a 
								// 2MB region hard coded in 460GX to 0xFE200000h


#define AGPSTATUS_OFFSET  0xE4	// AGP Status Register - The CAP_PTR is
								// at 0xE0h in 460GX and the AGP Status
								// register is at CAP_PTR+4.


#define AGPCMD_OFFSET	  0xE8	// AGP Command Register - CAP_PTR + 8



//
// 82460GX specific definitions to get to the PCI configuration space of the
// SAC, GXB et al.
//
#define AGP460_SAC_BUS_ID		0	 // The bus number where the SAC resides in 82460GX

//
// The following two definitions should be interpreted as of type PCI_SLOT_NUMBER
// which combines the device & function number for a particular PCI device.  It is 
// a ULONG value which should be deciphered as follows:
// [xxxxxxxx xxxxxxxx xxxxxxxx YYYZZZZZ]
// where x = Reserved, Y = Function Number, Z = Device Number
//

#define AGP460_SAC_CBN_SLOT_ID 0x10 // The Chipset Bus Number resides at Bus 0,
							     // Device 10h & Function 0.

#define AGP460_GXB_SLOT_ID		0x34 // The GXB would be accessed at Bus CBN, Device 14h
								 // function BFN.  BFN is 1 by default.

#define AGP460_PAGE_SIZE_4KB	(4 * ONE_KB)
//
// Handy macros to read & write in the PCI Configuration space
//

//
// Read460CBN reads the CBN - Chipset Bus Number from the 82460GX SAC.
// CBN is a BYTE located at Bus 0, Device 10h, Function 0, Offset 40
// in the SAC Configuration space.  The CBN can be read once and reused
// subsequently.
// 

void Read460CBN(PVOID  CBN);


void Read460Config(ULONG  _CBN_,PVOID  _buf_,ULONG _offset_,ULONG _size_);

void Write460Config(ULONG _CBN_,PVOID  _buf_,ULONG _offset_,ULONG _size_);

//
// Conversions from AGPSIZ[2:0] encoding to Aperture Size in MB/GB
//
//  AGPSIZE[2:0]   Aperture Size
//          000         0MB (power on default; no GART SRAM present)
//			001       256MB 
//			010         1GB
//          100        32GB  (only with 4MB pages)
//
#define AP_SIZE_0MB     0x00
#define AP_SIZE_256MB   0x01
#define AP_SIZE_1GB     0x02
#define AP_SIZE_32GB    0x04


#define AP_SIZE_COUNT_4KB	2 //Only apertures of 256M & 1G are possible with 4KB pages
#define AP_SIZE_COUNT_4MB   3 //Apertures of 256M, 1G & 32G are possible with 4MB pages

#define AP_MIN_SIZE		    AP_256MB	// 0 is not counted as a possible 
									    // aperture size
#define AP_MAX_SIZE_4KB	    AP_1GB      // 1 GB is the maximum with 4KB pages
#define AP_MAX_SIZE_4MB     AP_1GB      // 32GB is the maximum with 4MB pages

#define PAGESIZE_460GX_CHIPSET  (4 * ONE_KB)

#define GART_PAGESHIFT_460GX	12


//
// Define the 82460GX GART table entry.  4KB pages are assumed.  To support 4MB pages new 
// structures have to be defined.
//
typedef struct _GART_ENTRY_HW {
    ULONG Page	     :  24;
	ULONG Valid		 :   1;
	ULONG Coherency  :   1;
	ULONG Parity     :   1;  // Parity bit is generated by Hardware. Software should
							 // mask it out and treat it as a reserved.
    ULONG Reserved   :   5;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1		    //  Bit 24 is the valid bit in 460GX GART
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100
#define GART_ENTRY_WB           6           //  110

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC
#define GART_ENTRY_RESERVED_WB  GART_ENTRY_WB



//
// Unlike 440, 82460GX GART driver doesn't have direct equivalent for GART PTE software
// states like GART_ENTRY_VALID_WC, GART_ENTRY_VALID_UC etc.  This is because of
// the organization of the GART PTEs - the valid bit is disjoint from any reserved bits
// and therefore have to be manipulated separately. - Naga G
//

typedef struct _GART_ENTRY_SW {
    ULONG Reserved0 : 24;
	ULONG Valid     :  1;
    ULONG Reserved1 :  2;
	ULONG State     :  3;
	ULONG Reserved2 :  2;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the 460-specific extension
//
typedef struct _AGP460_EXTENSION {
    BOOLEAN             GlobalEnable;				// Software only bit.  The GART will be 
													// initialized to a known invalid state (0s)
													// during initialization. Other than that
													// no hardware control is available in 460GX
													// to enable/disable GART accesses. Thus, this
													// is not of much use !
    PHYSICAL_ADDRESS    ApertureStart; 
    ULONG               ApertureLength;				// Aperture Length in Bytes
	ULONG               ChipsetPageSize;			// Can be 4KB or 4MB.
    PGART_PTE           Gart;
    ULONG               GartLength;					 // Maximum is 2MB
    PHYSICAL_ADDRESS    GartPhysical;				 // Physical address where GART starts
	BOOLEAN             bSupportMultipleAGPDevices;  // For future use.
	BOOLEAN             bSupportsCacheCoherency;     // For future use. 
    ULONGLONG SpecialTarget;
} AGP460_EXTENSION, *PAGP460_EXTENSION;

NTSTATUS Agp460FlushPages(
    IN PAGP460_EXTENSION AgpContext,
    IN PMDL Mdl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agp440\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Revision History:

--*/
#include "agp440.h"

//
// Local function prototypes
//
NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

NTSTATUS
Agp440SetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, Agp440CreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, Agp440FindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

#define Agp440EnableTB(_x_) Agp440SetGTLB_Enable((_x_), TRUE)
#define Agp440DisableTB(_x_) Agp440SetGTLB_Enable((_x_), FALSE)


NTSTATUS
AgpQueryAperture(
    IN PAGP440_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    UCHAR ApSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();
    //
    // Get the current APBASE and APSIZE settings
    //
    Read440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    Read440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = 4 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGP440 - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {
        ULONG VendorId;

        //
        // 440 supports 7 different aperture sizes, all must be 
        // naturally aligned. Start with the largest aperture and 
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        
        //
        // 815 only supports 64MB and 32MB Aperture sizes
        //
        Read440Config(&VendorId, 0, sizeof(VendorId));
        if (VendorId == AGP_815_IDENTIFIER) {
            Requirements->Count = AP_815_SIZE_COUNT;
            Length = AP_815_MAX_SIZE;
        
        } else {
            Requirements->Count = AP_SIZE_COUNT;
            Length = AP_MAX_SIZE;
        }

        for (i=0; i<Requirements->Count; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *pApertureRequirements = Requirements;


    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGP440_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    PACCFG PACConfig;
    UCHAR ApSize;
    ULONG ApBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }
    
    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then reenable the aperture
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 0;
    Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //
    Write440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    //
    // Now we can update APBASE
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    Write440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;

        Read440Config(&DbgSize, APSIZE_OFFSET, sizeof(ApSize));
        Read440Config(&DbgBase, APBASE_OFFSET, sizeof(ApBase));
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == ApBase);
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    if (AgpContext->GlobalEnable) {
        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        ASSERT(PACConfig.GlobalEnable == 0);
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //
    Agp440EnableTB(AgpContext);

    //
    // If the GART has been allocated, rewrite the ATTBASE
    //
    if (AgpContext->Gart != NULL) {
        Write440Config(&AgpContext->GartPhysical.LowPart,
                       ATTBASE_OFFSET,
                       sizeof(AgpContext->GartPhysical.LowPart));
    }

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGP440_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    PACCFG PACConfig;

    //
    // Disable the aperture
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    if (PACConfig.GlobalEnable == 1) {
        PACConfig.GlobalEnable = 0;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }
    AgpContext->GlobalEnable = FALSE;

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}


NTSTATUS
AgpReserveMemory(
    IN PAGP440