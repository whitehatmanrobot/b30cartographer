
#endif	/* PERL_OBJECT */

/*
    Interface for perl process functions
*/


#ifdef PERL_OBJECT

#ifndef Sighandler_t
typedef Signal_t (*Sighandler_t) _((int));
#endif
#ifndef jmp_buf
#include <setjmp.h>
#endif

class IPerlProc
{
public:
    virtual void	Abort(void) = 0;
    virtual char *	Crypt(const char* clear, const char* salt) = 0;
    virtual void	Exit(int status) = 0;
    virtual void	_Exit(int status) = 0;
    virtual int		Execl(const char *cmdname, const char *arg0,
			      const char *arg1, const char *arg2,
			      const char *arg3) = 0;
    virtual int		Execv(const char *cmdname, const char *const *argv) = 0;
    virtual int		Execvp(const char *cmdname, const char *const *argv) = 0;
    virtual uid_t	Getuid(void) = 0;
    virtual uid_t	Geteuid(void) = 0;
    virtual gid_t	Getgid(void) = 0;
    virtual gid_t	Getegid(void) = 0;
    virtual char *	Getlogin(void) = 0;
    virtual int		Kill(int pid, int sig) = 0;
    virtual int		Killpg(int pid, int sig) = 0;
    virtual int		PauseProc(void) = 0;
    virtual PerlIO *	Popen(const char *command, const char *mode) = 0;
    virtual int		Pclose(PerlIO *stream) = 0;
    virtual int		Pipe(int *phandles) = 0;
    virtual int		Setuid(uid_t uid) = 0;
    virtual int		Setgid(gid_t gid) = 0;
    virtual int		Sleep(unsigned int) = 0;
    virtual int		Times(struct tms *timebuf) = 0;
    virtual int		Wait(int *status) = 0;
    virtual int		Waitpid(int pid, int *status, int flags) = 0;
    virtual Sighandler_t	Signal(int sig, Sighandler_t subcode) = 0;
#ifdef WIN32
    virtual void	GetSysMsg(char*& msg, DWORD& dwLen, DWORD dwErr) = 0;
    virtual void	FreeBuf(char* msg) = 0;
    virtual BOOL	DoCmd(char *cmd) = 0;
    virtual int		Spawn(char*cmds) = 0;
    virtual int		Spawnvp(int mode, const char *cmdname,
				const char *const *argv) = 0;
    virtual int		ASpawn(void *vreally, void **vmark, void **vsp) = 0;
#endif
};

#define PerlProc_abort()	PL_piProc->Abort()
#define PerlProc_crypt(c,s)	PL_piProc->Crypt((c), (s))
#define PerlProc_exit(s)	PL_piProc->Exit((s))
#define PerlProc__exit(s)	PL_piProc->_Exit((s))
#define PerlProc_execl(c, w, x, y, z)					\
	PL_piProc->Execl((c), (w), (x), (y), (z))

#define PerlProc_execv(c, a)	PL_piProc->Execv((c), (a))
#define PerlProc_execvp(c, a)	PL_piProc->Execvp((c), (a))
#define PerlProc_getuid()	PL_piProc->Getuid()
#define PerlProc_geteuid()	PL_piProc->Geteuid()
#define PerlProc_getgid()	PL_piProc->Getgid()
#define PerlProc_getegid()	PL_piProc->Getegid()
#define PerlProc_getlogin()	PL_piProc->Getlogin()
#define PerlProc_kill(i, a)	PL_piProc->Kill((i), (a))
#define PerlProc_killpg(i, a)	PL_piProc->Killpg((i), (a))
#define PerlProc_pause()	PL_piProc->PauseProc()
#define PerlProc_popen(c, m)	PL_piProc->Popen((c), (m))
#define PerlProc_pclose(f)	PL_piProc->Pclose((f))
#define PerlProc_pipe(fd)	PL_piProc->Pipe((fd))
#define PerlProc_setuid(u)	PL_piProc->Setuid((u))
#define PerlProc_setgid(g)	PL_piProc->Setgid((g))
#define PerlProc_sleep(t)	PL_piProc->Sleep((t))
#define PerlProc_times(t)	PL_piProc->Times((t))
#define PerlProc_wait(t)	PL_piProc->Wait((t))
#define PerlProc_waitpid(p,s,f)	PL_piProc->Waitpid((p), (s), (f))
#define PerlProc_setjmp(b, n)	Sigsetjmp((b), (n))
#define PerlProc_longjmp(b, n)	Siglongjmp((b), (n))
#define PerlProc_signal(n, h)	PL_piProc->Signal((n), (h))

#ifdef WIN32
#define PerlProc_GetSysMsg(s,l,e)					\
	PL_piProc->GetSysMsg((s), (l), (e))

#define PerlProc_FreeBuf(s)	PL_piProc->FreeBuf((s))
#define PerlProc_Cmd(s)		PL_piProc->DoCmd((s))
#define do_spawn(s)		PL_piProc->Spawn((s))
#define do_spawnvp(m, c, a)	PL_piProc->Spawnvp((m), (c), (a))
#define PerlProc_aspawn(m,c,a)	PL_piProc->ASpawn((m), (c), (a))
#endif

#else	/* PERL_OBJECT */

#define PerlProc_abort()	abort()
#define PerlProc_crypt(c,s)	crypt((c), (s))
#define PerlProc_exit(s)	exit((s))
#define PerlProc__exit(s)	_exit((s))
#define PerlProc_execl(c,w,x,y,z)					\
	execl((c), (w), (x), (y), (z))
#define PerlProc_execv(c, a)	execv((c), (a))
#define PerlProc_execvp(c, a)	execvp((c), (a))
#define PerlProc_getuid()	getuid()
#define PerlProc_geteuid()	geteuid()
#define PerlProc_getgid()	getgid()
#define PerlProc_getegid()	getegid()
#define PerlProc_getlogin()	getlogin()
#define PerlProc_kill(i, a)	kill((i), (a))
#define PerlProc_killpg(i, a)	killpg((i), (a))
#define PerlProc_pause()	Pause()
#define PerlProc_popen(c, m)	my_popen((c), (m))
#define PerlProc_pclose(f)	my_pclose((f))
#define PerlProc_pipe(fd)	pipe((fd))
#define PerlProc_setuid(u)	setuid((u))
#define PerlProc_setgid(g)	setgid((g))
#define PerlProc_sleep(t)	sleep((t))
#define PerlProc_times(t)	times((t))
#define PerlProc_wait(t)	wait((t))
#define PerlProc_waitpid(p,s,f)	waitpid((p), (s), (f))
#define PerlProc_setjmp(b, n)	Sigsetjmp((b), (n))
#define PerlProc_longjmp(b, n)	Siglongjmp((b), (n))
#define PerlProc_signal(n, h)	signal((n), (h))


#endif	/* PERL_OBJECT */

/*
    Interface for perl socket functions
*/

#ifdef PERL_OBJECT

class IPerlSock
{
public:
    virtual u_long	Htonl(u_long hostlong) = 0;
    virtual u_short	Htons(u_short hostshort) = 0;
    virtual u_long	Ntohl(u_long netlong) = 0;
    virtual u_short	Ntohs(u_short netshort) = 0;
    virtual SOCKET	Accept(SOCKET s, struct sockaddr* addr,
			       int* addrlen, int &err) = 0;
    virtual int		Bind(SOCKET s, const struct sockaddr* name,
			     int namelen, int &err) = 0;
    virtual int		Connect(SOCKET s, const struct sockaddr* name,
				int namelen, int &err) = 0;
    virtual void	Endhostent(int &err) = 0;
    virtual void	Endnetent(int &err) = 0;
    virtual void	Endprotoent(int &err) = 0;
    virtual void	Endservent(int &err) = 0;
    virtual int		Gethostname(char* name, int namelen, int &err) = 0;
    virtual int		Getpeername(SOCKET s, struct sockaddr* name,
				    int* namelen, int &err) = 0;
    virtual struct hostent *	Gethostbyaddr(const char* addr, int len,
					      int type, int &err) = 0;
    virtual struct hostent *	Gethostbyname(const char* name, int &err) = 0;
    virtual struct hostent *	Gethostent(int &err) = 0;
    virtual struct netent *	Getnetbyaddr(long net, int type, int &err) = 0;
    virtual struct netent *	Getnetbyname(const char *, int &err) = 0;
    virtual struct netent *	Getnetent(int &err) = 0;
    virtual struct protoent *	Getprotobyname(const char* name, int &err) = 0;
    virtual struct protoent *	Getprotobynumber(int number, int &err) = 0;
    virtual struct protoent *	Getprotoent(int &err) = 0;
    virtual struct servent *	Getservbyname(const char* name,
					      const char* proto, int &err) = 0;
    virtual struct servent *	Getservbyport(int port, const char* proto,
					      int &err) = 0;
    virtual struct servent *	Getservent(int &err) = 0;
    virtual int		Getsockname(SOCKET s, struct sockaddr* name,
				    int* namelen, int &err) = 0;
    virtual int		Getsockopt(SOCKET s, int level, int optname,
				   char* optval, int* optlen, int &err) = 0;
    virtual unsigned long	InetAddr(const char* cp, int &err) = 0;
    virtual char *	InetNtoa(struct in_addr in, int &err) = 0;
    virtual int		Listen(SOCKET s, int backlog, int &err) = 0;
    virtual int		Recv(SOCKET s, char* buf, int len,
			     int flags, int &err) = 0;
    virtual int		Recvfrom(SOCKET s, char* buf, int len, int flags,
				 struct sockaddr* from, int* fromlen, int &err) = 0;
    virtual int		Select(int nfds, char* readfds, char* writefds,
			       char* exceptfds, const struct timeval* timeout,
			       int &err) = 0;
    virtual int		Send(SOCKET s, const char* buf, int len,
			     int flags, int &err) = 0; 
    virtual int		Sendto(SOCKET s, const char* buf, int len, int flags,
			       const struct sockaddr* to, int tolen, int &err) = 0;
    virtual void	Sethostent(int stayopen, int &err) = 0;
    virtual void	Setnetent(int stayopen, int &err) = 0;
    virtual void	Setprotoent(int stayopen, int &err) = 0;
    virtual void	Setservent(int stayopen, int &err) = 0;
    virtual int		Setsockopt(SOCKET s, int level, int optname,
				   const char* optval, int optlen, int &err) = 0;
    virtual int		Shutdown(SOCKET s, int how, int &err) = 0;
    virtual SOCKET	Socket(int af, int type, int protocol, int &err) = 0;
    virtual int		Socketpair(int domain, int type, int protocol,
				   int* fds, int &err) = 0;
#ifdef WIN32
    virtual int		Closesocket(SOCKET s, int& err) = 0;
    virtual int		Ioctlsocket(SOCKET s, long cmd, u_long *argp,
				    int& err) = 0;
#endif
};

#define PerlSock_htonl(x)		PL_piSock->Htonl(x)
#define PerlSock_htons(x)		PL_piSock->Htons(x)
#define PerlSock_ntohl(x)		PL_piSock->Ntohl(x)
#define PerlSock_ntohs(x)		PL_piSock->Ntohs(x)
#define PerlSock_accept(s, a, l)	PL_piSock->Accept(s, a, l, ErrorNo())
#define PerlSock_bind(s, n, l)		PL_piSock->Bind(s, n, l, ErrorNo())
#define PerlSock_connect(s, n, l)	PL_piSock->Connect(s, n, l, ErrorNo())
#define PerlSock_endhostent()		PL_piSock->Endhostent(ErrorNo())
#define PerlSock_endnetent()		PL_piSock->Endnetent(ErrorNo())
#define PerlSock_endprotoent()		PL_piSock->Endprotoent(ErrorNo())
#define PerlSock_endservent()		PL_piSock->Endservent(ErrorNo())
#define PerlSock_gethostbyaddr(a, l, t)	PL_piSock->Gethostbyaddr(a, l, t, ErrorNo())
#define PerlSock_gethostbyname(n)	PL_piSock->Gethostbyname(n, ErrorNo())
#define PerlSock_gethostent()		PL_piSock->Gethostent(ErrorNo())
#define PerlSock_gethostname(n, l)	PL_piSock->Gethostname(n, l, ErrorNo())
#define PerlSock_getnetbyaddr(n, t)	PL_piSock->Getnetbyaddr(n, t, ErrorNo())
#define PerlSock_getnetbyname(c)	PL_piSock->Getnetbyname(c, ErrorNo())
#define PerlSock_getnetent()		PL_piSock->Getnetent(ErrorNo())
#define PerlSock_getpeername(s, n, l)	PL_piSock->Getpeername(s, n, l, ErrorNo())
#define PerlSock_getprotobyname(n)	PL_piSock->Getprotobyname(n, ErrorNo())
#define PerlSock_getprotobynumber(n)	PL_piSock->Getprotobynumber(n, ErrorNo())
#define PerlSock_getprotoent()		PL_piSock->Getprotoent(ErrorNo())
#define PerlSock_getservbyname(n, p)	PL_piSock->Getservbyname(n, p, ErrorNo())
#define PerlSock_getservbyport(port, p)	PL_piSock->Getservbyport(port, p, ErrorNo())
#define PerlSock_getservent()		PL_piSock->Getservent(ErrorNo())
#define PerlSock_getsockname(s, n, l)	PL_piSock->Getsockname(s, n, l, ErrorNo())
#define PerlSock_getsockopt(s,l,n,v,i)	PL_piSock->Getsockopt(s, l, n, v, i, ErrorNo())
#define PerlSock_inet_addr(c)		PL_piSock->InetAddr(c, ErrorNo())
#define PerlSock_inet_ntoa(i)		PL_piSock->InetNtoa(i, ErrorNo())
#define PerlSock_listen(s, b)		PL_piSock->Listen(s, b, ErrorNo())
#define PerlSock_recv(s, b, l, f)	PL_piSock->Recv(s, b, l, f, ErrorNo())
#define PerlSock_recvfrom(s,b,l,f,from,fromlen)				\
	PL_piSock->Recvfrom(s, b, l, f, from, fromlen, ErrorNo())
#define PerlSock_select(n, r, w, e, t)					\
	PL_piSock->Select(n, (char*)r, (char*)w, (char*)e, t, ErrorNo())
#define PerlSock_send(s, b, l, f)	PL_piSock->Send(s, b, l, f, ErrorNo())
#define PerlSock_sendto(s, b, l, f, t, tlen)				\
	PL_piSock->Sendto(s, b, l, f, t, tlen, ErrorNo())
#define PerlSock_sethostent(f)		PL_piSock->Sethostent(f, ErrorNo())
#define PerlSock_setnetent(f)		PL_piSock->Setnetent(f, ErrorNo())
#define PerlSock_setprotoent(f)		PL_piSock->Setprotoent(f, ErrorNo())
#define PerlSock_setservent(f)		PL_piSock->Setservent(f, ErrorNo())
#define PerlSock_setsockopt(s, l, n, v, len)				\
	PL_piSock->Setsockopt(s, l, n, v, len, ErrorNo())
#define PerlSock_shutdown(s, h)		PL_piSock->Shutdown(s, h, ErrorNo())
#define PerlSock_socket(a, t, p)	PL_piSock->Socket(a, t, p, ErrorNo())
#define PerlSock_socketpair(a, t, p, f)	PL_piSock->Socketpair(a, t, p, f, ErrorNo())

#else	/* PERL_OBJECT */

#define PerlSock_htonl(x)		htonl(x)
#define PerlSock_htons(x)		htons(x)
#define PerlSock_ntohl(x)		ntohl(x)
#define PerlSock_ntohs(x)		ntohs(x)
#define PerlSock_accept(s, a, l)	accept(s, a, l)
#define PerlSock_bind(s, n, l)		bind(s, n, l)
#define PerlSock_connect(s, n, l)	connect(s, n, l)

#define PerlSock_gethostbyaddr(a, l, t)	gethostbyaddr(a, l, t)
#define PerlSock_gethostbyname(n)	gethostbyname(n)
#define PerlSock_gethostent		gethostent
#define PerlSock_endhostent		endhostent
#define PerlSock_gethostname(n, l)	gethostname(n, l)

#define PerlSock_getnetbyaddr(n, t)	getnetbyaddr(n, t)
#define PerlSock_getnetbyname(n)	getnetbyname(n)
#define PerlSock_getnetent		getnetent
#define PerlSock_endnetent		endnetent
#define PerlSock_getpeername(s, n, l)	getpeername(s, n, l)

#define PerlSock_getprotobyname(n)	getprotobyname(n)
#define PerlSock_getprotobynumber(n)	getprotobynumber(n)
#define PerlSock_getprotoent		getprotoent
#define PerlSock_endprotoent		endprotoent

#define PerlSock_getservbyname(n, p)	getservbyname(n, p)
#define PerlSock_getservbyport(port, p)	getservbyport(port, p)
#define PerlSock_getservent		getservent
#define PerlSock_endservent		endservent

#define PerlSock_getsockname(s, n, l)	getsockname(s, n, l)
#define PerlSock_getsockopt(s,l,n,v,i)	getsockopt(s, l, n, v, i)
#define PerlSock_inet_addr(c)		inet_addr(c)
#define PerlSock_inet_ntoa(i)		inet_ntoa(i)
#define PerlSock_listen(s, b)		listen(s, b)
#define PerlSock_recv(s, b, l, f)	recv(s, b, l, f)
#define PerlSock_recvfrom(s, b, l, f, from, fromlen)			\
	recvfrom(s, b, l, f, from, fromlen)
#define PerlSock_select(n, r, w, e, t)	select(n, r, w, e, t)
#define PerlSock_send(s, b, l, f)	send(s, b, l, f)
#define PerlSock_sendto(s, b, l, f, t, tlen)				\
	sendto(s, b, l, f, t, tlen)
#define PerlSock_sethostent(f)		sethostent(f)
#define PerlSock_setnetent(f)		setnetent(f)
#define PerlSock_setprotoent(f)		setprotoent(f)
#define PerlSock_setservent(f)		setservent(f)
#define PerlSock_setsockopt(s, l, n, v, len)				\
	setsockopt(s, l, n, v, len)
#define PerlSock_shutdown(s, h)		shutdown(s, h)
#define PerlSock_socket(a, t, p)	socket(a, t, p)
#define PerlSock_socketpair(a, t, p, f)	socketpair(a, t, p, f)


#endif	/* PERL_OBJECT */

#endif	/* __Inc__IPerl___ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\objpp.h ===
#ifndef __Objpp_h__
#define __Objpp_h__

#undef  amagic_call
#define amagic_call       CPerlObj::Perl_amagic_call
#undef  amagic_cmp
#define amagic_cmp        CPerlObj::amagic_cmp
#undef  amagic_cmp_locale
#define amagic_cmp_locale CPerlObj::amagic_cmp_locale
#undef  Gv_AMupdate
#define Gv_AMupdate       CPerlObj::Perl_Gv_AMupdate
#undef  add_data
#define add_data          CPerlObj::add_data
#undef  ao
#define ao                CPerlObj::ao
#undef  append_elem
#define append_elem       CPerlObj::Perl_append_elem
#undef  append_list
#define append_list       CPerlObj::Perl_append_list
#undef  apply
#define apply             CPerlObj::Perl_apply
#undef  asIV
#define asIV              CPerlObj::asIV
#undef  asUV
#define asUV              CPerlObj::asUV
#undef  assertref
#define assertref         CPerlObj::Perl_assertref
#undef  av_clear
#define av_clear          CPerlObj::Perl_av_clear
#undef  av_extend
#define av_extend         CPerlObj::Perl_av_extend
#undef  av_fake
#define av_fake           CPerlObj::Perl_av_fake
#undef  av_fetch
#define av_fetch          CPerlObj::Perl_av_fetch
#undef  av_fill
#define av_fill           CPerlObj::Perl_av_fill
#undef  av_len
#define av_len            CPerlObj::Perl_av_len
#undef  av_make
#define av_make           CPerlObj::Perl_av_make
#undef  av_pop
#define av_pop            CPerlObj::Perl_av_pop
#undef  av_push
#define av_push           CPerlObj::Perl_av_push
#undef  av_shift
#define av_shift          CPerlObj::Perl_av_shift
#undef  av_reify
#define av_reify          CPerlObj::Perl_av_reify
#undef  av_store
#define av_store          CPerlObj::Perl_av_store
#undef  av_undef 
#define av_undef          CPerlObj::Perl_av_undef 
#undef  av_unshift
#define av_unshift        CPerlObj::Perl_av_unshift
#undef  avhv_keys
#define avhv_keys         CPerlObj::Perl_avhv_keys
#undef  avhv_fetch_ent
#define avhv_fetch_ent    CPerlObj::Perl_avhv_fetch_ent
#undef  avhv_exists_ent
#define avhv_exists_ent   CPerlObj::Perl_avhv_exists_ent
#undef  avhv_index_sv
#define avhv_index_sv     CPerlObj::avhv_index_sv
#undef  avhv_iternext
#define avhv_iternext     CPerlObj::Perl_avhv_iternext
#undef  avhv_iterval
#define avhv_iterval      CPerlObj::Perl_avhv_iterval
#undef  bad_type
#define bad_type          CPerlObj::bad_type
#undef  bind_match
#define bind_match        CPerlObj::Perl_bind_match
#undef  block_end
#define block_end         CPerlObj::Perl_block_end
#undef  block_gimme
#define block_gimme       CPerlObj::Perl_block_gimme
#undef  block_start
#define block_start       CPerlObj::Perl_block_start
#undef  bset_obj_store
#define bset_obj_store    CPerlObj::Perl_bset_obj_store
#undef  byterun
#define byterun           CPerlObj::Perl_byterun
#undef  call_list
#define call_list         CPerlObj::Perl_call_list
#undef  cando
#define cando             CPerlObj::Perl_cando
#undef  cast_ulong
#define cast_ulong        CPerlObj::cast_ulong
#undef  checkcomma
#define checkcomma        CPerlObj::Perl_checkcomma
#undef  check_uni
#define check_uni         CPerlObj::Perl_check_uni
#undef  ck_anoncode
#define ck_anoncode       CPerlObj::Perl_ck_anoncode
#undef  ck_bitop
#define ck_bitop          CPerlObj::Perl_ck_bitop
#undef  ck_concat
#define ck_concat         CPerlObj::Perl_ck_concat
#undef  ck_delete
#define ck_delete         CPerlObj::Perl_ck_delete
#undef  ck_eof
#define ck_eof            CPerlObj::Perl_ck_eof
#undef  ck_eval
#define ck_eval           CPerlObj::Perl_ck_eval
#undef  ck_exec
#define ck_exec           CPerlObj::Perl_ck_exec
#undef  ck_exists
#define ck_exists         CPerlObj::Perl_ck_exists
#undef  ck_formline
#define ck_formline       CPerlObj::Perl_ck_formline
#undef  ck_ftst
#define ck_ftst           CPerlObj::Perl_ck_ftst
#undef  ck_fun
#define ck_fun            CPerlObj::Perl_ck_fun
#undef  ck_fun_locale
#define ck_fun_locale     CPerlObj::Perl_ck_fun_locale
#undef  ck_glob
#define ck_glob           CPerlObj::Perl_ck_glob
#undef  ck_grep
#define ck_grep           CPerlObj::Perl_ck_grep
#undef  ck_gvconst
#define ck_gvconst        CPerlObj::Perl_ck_gvconst
#undef  ck_index
#define ck_index          CPerlObj::Perl_ck_index
#undef  ck_lengthconst
#define ck_lengthconst    CPerlObj::Perl_ck_lengthconst
#undef  ck_lfun
#define ck_lfun           CPerlObj::Perl_ck_lfun
#undef  ck_listiob
#define ck_listiob        CPerlObj::Perl_ck_listiob
#undef  ck_match
#define ck_match          CPerlObj::Perl_ck_match
#undef  ck_null
#define ck_null           CPerlObj::Perl_ck_null
#undef  ck_repeat
#define ck_repeat         CPerlObj::Perl_ck_repeat
#undef  ck_require
#define ck_require        CPerlObj::Perl_ck_require
#undef  ck_retarget
#define ck_retarget       CPerlObj::Perl_ck_retarget
#undef  ck_rfun
#define ck_rfun           CPerlObj::Perl_ck_rfun
#undef  ck_rvconst
#define ck_rvconst        CPerlObj::Perl_ck_rvconst
#undef  ck_scmp
#define ck_scmp           CPerlObj::Perl_ck_scmp
#undef  ck_select
#define ck_select         CPerlObj::Perl_ck_select
#undef  ck_shift
#define ck_shift          CPerlObj::Perl_ck_shift
#undef  ck_sort
#define ck_sort           CPerlObj::Perl_ck_sort
#undef  ck_spair
#define ck_spair          CPerlObj::Perl_ck_spair
#undef  ck_split
#define ck_split          CPerlObj::Perl_ck_split
#undef  ck_subr
#define ck_subr           CPerlObj::Perl_ck_subr
#undef  ck_svconst
#define ck_svconst        CPerlObj::Perl_ck_svconst
#undef  ck_trunc
#define ck_trunc          CPerlObj::Perl_ck_trunc
#undef  convert
#define convert           CPerlObj::Perl_convert
#undef  cpytill
#define cpytill           CPerlObj::Perl_cpytill
#undef  croak
#define croak             CPerlObj::Perl_croak
#undef  cv_ckproto
#define cv_ckproto        CPerlObj::Perl_cv_ckproto
#undef  cv_clone
#define cv_clone          CPerlObj::Perl_cv_clone
#undef  cv_clone2
#define cv_clone2         CPerlObj::cv_clone2
#undef  cv_const_sv
#define cv_const_sv       CPerlObj::Perl_cv_const_sv
#undef  cv_undef 
#define cv_undef          CPerlObj::Perl_cv_undef 
#undef  cx_dump
#define cx_dump           CPerlObj::Perl_cx_dump
#undef  cxinc
#define cxinc             CPerlObj::Perl_cxinc
#undef  deb
#define deb               CPerlObj::Perl_deb
#undef  deb_growlevel
#define deb_growlevel     CPerlObj::Perl_deb_growlevel
#undef  debop
#define debop             CPerlObj::Perl_debop
#undef  debstackptrs
#define debstackptrs      CPerlObj::Perl_debstackptrs
#undef  debprof
#define debprof           CPerlObj::debprof
#undef  debprofdump
#define debprofdump       CPerlObj::Perl_debprofdump
#undef  debstack
#define debstack          CPerlObj::Perl_debstack
#undef  del_sv
#define del_sv            CPerlObj::del_sv
#undef  del_xiv
#define del_xiv           CPerlObj::del_xiv
#undef  del_xnv
#define del_xnv           CPerlObj::del_xnv
#undef  del_xpv
#define del_xpv           CPerlObj::del_xpv
#undef  del_xrv
#define del_xrv           CPerlObj::del_xrv
#undef  delimcpy
#define delimcpy          CPerlObj::Perl_delimcpy
#undef  depcom
#define depcom            CPerlObj::depcom
#undef  deprecate
#define deprecate         CPerlObj::Perl_deprecate
#undef  die
#define die               CPerlObj::Perl_die
#undef  die_where
#define die_where         CPerlObj::Perl_die_where
#undef  div128
#define div128            CPerlObj::div128
#undef  doencodes
#define doencodes         CPerlObj::doencodes
#undef  doeval
#define doeval            CPerlObj::doeval
#undef  doform
#define doform            CPerlObj::doform
#undef  dofindlabel
#define dofindlabel       CPerlObj::Perl_dofindlabel
#undef  doparseform
#define doparseform       CPerlObj::doparseform
#undef  dopoptoeval
#define dopoptoeval       CPerlObj::Perl_dopoptoeval
#undef  dopoptolabel
#define dopoptolabel      CPerlObj::dopoptolabel
#undef  dopoptoloop
#define dopoptoloop       CPerlObj::dopoptoloop
#undef  dopoptosub
#define dopoptosub        CPerlObj::dopoptosub
#undef  dopoptosub_at
#define dopoptosub_at     CPerlObj::dopoptosub_at
#undef  dounwind
#define dounwind          CPerlObj::Perl_dounwind
#undef  do_aexec
#define do_aexec          CPerlObj::Perl_do_aexec
#undef  do_aspawn
#define do_aspawn         CPerlObj::do_aspawn
#undef  do_binmode
#define do_binmode        CPerlObj::Perl_do_binmode
#undef  do_chop
#define do_chop           CPerlObj::Perl_do_chop
#undef  do_close
#define do_close          CPerlObj::Perl_do_close
#undef  do_eof
#define do_eof            CPerlObj::Perl_do_eof
#undef  do_exec
#define do_exec           CPerlObj::Perl_do_exec
#undef  do_execfree
#define do_execfree       CPerlObj::Perl_do_execfree
#undef  do_ipcctl
#define do_ipcctl         CPerlObj::Perl_do_ipcctl
#undef  do_ipcget
#define do_ipcget         CPerlObj::Perl_do_ipcget
#undef  do_join
#define do_join           CPerlObj::Perl_do_join
#undef  do_kv
#define do_kv             CPerlObj::Perl_do_kv
#undef  do_msgrcv
#define do_msgrcv         CPerlObj::Perl_do_msgrcv
#undef  do_msgsnd
#define do_msgsnd         CPerlObj::Perl_do_msgsnd
#undef  do_open
#define do_open           CPerlObj::Perl_do_open
#undef  do_pipe
#define do_pipe           CPerlObj::Perl_do_pipe
#undef  do_print
#define do_print          CPerlObj::Perl_do_print
#undef  do_readline
#define do_readline       CPerlObj::Perl_do_readline
#undef  do_chomp
#define do_chomp          CPerlObj::Perl_do_chomp
#undef  do_seek
#define do_seek           CPerlObj::Perl_do_seek
#undef  do_semop
#define do_semop          CPerlObj::Perl_do_semop
#undef  do_shmio
#define do_shmio          CPerlObj::Perl_do_shmio
#undef  do_sprintf
#define do_sprintf        CPerlObj::Perl_do_sprintf
#undef  do_sysseek
#define do_sysseek        CPerlObj::Perl_do_sysseek
#undef  do_tell
#define do_tell           CPerlObj::Perl_do_tell
#undef  do_trans
#define do_trans          CPerlObj::Perl_do_trans
#undef  do_vecset
#define do_vecset         CPerlObj::Perl_do_vecset
#undef  do_vop
#define do_vop            CPerlObj::Perl_do_vop
#undef  dofile
#define dofile            CPerlObj::Perl_dofile
#undef  do_clean_all
#define do_clean_all      CPerlObj::do_clean_all
#undef  do_clean_named_objs
#define do_clean_named_objs   CPerlObj::do_clean_named_objs
#undef  do_clean_objs
#define do_clean_objs     CPerlObj::do_clean_objs
#undef  do_report_used
#define do_report_used    CPerlObj::do_report_used
#undef  docatch
#define docatch           CPerlObj::docatch
#undef  dowantarray
#define dowantarray       CPerlObj::Perl_dowantarray
#undef  dump
#define dump              CPerlObj::dump
#undef  dump_all
#define dump_all          CPerlObj::Perl_dump_all
#undef  dump_eval
#define dump_eval         CPerlObj::Perl_dump_eval
#undef  dump_fds
#define dump_fds          CPerlObj::Perl_dump_fds
#undef  dump_form
#define dump_form         CPerlObj::Perl_dump_form
#undef  dump_gv
#define dump_gv           CPerlObj::Perl_dump_gv
#undef  dump_mstats
#define dump_mstats       CPerlObj::Perl_dump_mstats
#undef  dump_op
#define dump_op           CPerlObj::Perl_dump_op
#undef  dump_pm
#define dump_pm           CPerlObj::Perl_dump_pm
#undef  dump_packsubs
#define dump_packsubs     CPerlObj::Perl_dump_packsubs
#undef  dump_sub
#define dump_sub          CPerlObj::Perl_dump_sub
#undef  dumpuntil
#define dumpuntil         CPerlObj::dumpuntil
#undef  fbm_compile
#define fbm_compile       CPerlObj::Perl_fbm_compile
#undef  fbm_instr
#define fbm_instr         CPerlObj::Perl_fbm_instr
#undef  filter_add
#define filter_add        CPerlObj::Perl_filter_add
#undef  filter_del
#define filter_del        CPerlObj::Perl_filter_del
#undef  filter_gets
#define filter_gets       CPerlObj::filter_gets
#undef  filter_read
#define filter_read       CPerlObj::Perl_filter_read
#undef  find_beginning
#define find_beginning    CPerlObj::find_beginning
#undef  find_script
#define find_script       CPerlObj::Perl_find_script
#undef  forbid_setid
#define forbid_setid      CPerlObj::forbid_setid
#undef  force_ident
#define force_ident       CPerlObj::Perl_force_ident
#undef  force_list
#define force_list        CPerlObj::Perl_force_list
#undef  force_next
#define force_next        CPerlObj::Perl_force_next
#undef  force_word
#define force_word        CPerlObj::Perl_force_word
#undef  force_version
#define force_version     CPerlObj::force_version
#undef  form
#define form              CPerlObj::Perl_form
#undef  fold_constants
#define fold_constants    CPerlObj::Perl_fold_constants
#undef  fprintf
#define fprintf           CPerlObj::fprintf
#undef  free_tmps
#define free_tmps         CPerlObj::Perl_free_tmps
#undef  gen_constant_list
#define gen_constant_list CPerlObj::Perl_gen_constant_list
#undef  get_db_sub
#define get_db_sub        CPerlObj::get_db_sub
#undef  get_op_descs
#define get_op_descs      CPerlObj::Perl_get_op_descs
#undef  get_op_names
#define get_op_names      CPerlObj::Perl_get_op_names
#undef  get_no_modify
#define get_no_modify     CPerlObj::Perl_get_no_modify
#undef  get_opargs
#define get_opargs        CPerlObj::Perl_get_opargs
#undef  get_specialsv_list
#define get_specialsv_list CPerlObj::Perl_get_specialsv_list
#undef  get_vtbl
#define get_vtbl          CPerlObj::Perl_get_vtbl
#undef  getlogin
#define getlogin          CPerlObj::getlogin
#undef  gp_free
#define gp_free           CPerlObj::Perl_gp_free
#undef  gp_ref
#define gp_ref            CPerlObj::Perl_gp_ref
#undef  gv_autoload4
#define gv_autoload4      CPerlObj::Perl_gv_autoload4
#undef  gv_AVadd
#define gv_AVadd          CPerlObj::Perl_gv_AVadd
#undef  gv_HVadd
#define gv_HVadd          CPerlObj::Perl_gv_HVadd
#undef  gv_IOadd
#define gv_IOadd          CPerlObj::Perl_gv_IOadd
#undef  gv_check
#define gv_check          CPerlObj::Perl_gv_check
#undef  gv_efullname
#define gv_efullname      CPerlObj::Perl_gv_efullname
#undef  gv_efullname3
#define gv_efullname3     CPerlObj::Perl_gv_efullname3
#undef  gv_ename
#define gv_ename          CPerlObj::gv_ename
#undef  gv_fetchfile
#define gv_fetchfile      CPerlObj::Perl_gv_fetchfile
#undef  gv_fetchmeth
#define gv_fetchmeth      CPerlObj::Perl_gv_fetchmeth
#undef  gv_fetchmethod
#define gv_fetchmethod    CPerlObj::Perl_gv_fetchmethod
#undef  gv_fetchmethod_autoload
#define gv_fetchmethod_autoload  CPerlObj::Perl_gv_fetchmethod_autoload
#undef  gv_fetchpv
#define gv_fetchpv        CPerlObj::Perl_gv_fetchpv
#undef  gv_fullname
#define gv_fullname       CPerlObj::Perl_gv_fullname
#undef  gv_fullname3
#define gv_fullname3      CPerlObj::Perl_gv_fullname3
#undef  gv_init
#define gv_init           CPerlObj::Perl_gv_init
#undef  gv_init_sv
#define gv_init_sv        CPerlObj::gv_init_sv
#undef  gv_stashpv
#define gv_stashpv        CPerlObj::Perl_gv_stashpv
#undef  gv_stashpvn
#define gv_stashpvn       CPerlObj::Perl_gv_stashpvn
#undef  gv_stashsv
#define gv_stashsv        CPerlObj::Perl_gv_stashsv
#undef  he_delayfree
#define he_delayfree      CPerlObj::Perl_he_delayfree
#undef  he_free
#define he_free           CPerlObj::Perl_he_free
#undef  hfreeentries
#define hfreeentries      CPerlObj::hfreeentries
#undef  hoistmust
#define hoistmust         CPerlObj::Perl_hoistmust
#undef  hsplit
#define hsplit            CPerlObj::hsplit
#undef  hv_clear
#define hv_clear          CPerlObj::Perl_hv_clear
#undef  hv_delayfree_ent
#define hv_delayfree_ent  CPerlObj::Perl_hv_delayfree_ent
#undef  hv_delete
#define hv_delete         CPerlObj::Perl_hv_delete
#undef  hv_delete_ent
#define hv_delete_ent     CPerlObj::Perl_hv_delete_ent
#undef  hv_exists
#define hv_exists         CPerlObj::Perl_hv_exists
#undef  hv_exists_ent
#define hv_exists_ent     CPerlObj::Perl_hv_exists_ent
#undef  hv_free_ent
#define hv_free_ent       CPerlObj::Perl_hv_free_ent
#undef  hv_fetch
#define hv_fetch          CPerlObj::Perl_hv_fetch
#undef  hv_fetch_ent
#define hv_fetch_ent      CPerlObj::Perl_hv_fetch_ent
#undef  hv_iterinit
#define hv_iterinit       CPerlObj::Perl_hv_iterinit
#undef  hv_iterkey
#define hv_iterkey        CPerlObj::Perl_hv_iterkey
#undef  hv_iterkeysv
#define hv_iterkeysv      CPerlObj::Perl_hv_iterkeysv
#undef  hv_iternext
#define hv_iternext       CPerlObj::Perl_hv_iternext
#undef  hv_iternextsv
#define hv_iternextsv     CPerlObj::Perl_hv_iternextsv
#undef  hv_iterval
#define hv_iterval        CPerlObj::Perl_hv_iterval
#undef  hv_ksplit
#define hv_ksplit         CPerlObj::Perl_hv_ksplit
#undef  hv_magic
#define hv_magic          CPerlObj::Perl_hv_magic
#undef  hv_store
#define hv_store          CPerlObj::Perl_hv_store
#undef  hv_store_ent
#define hv_store_ent      CPerlObj::Perl_hv_store_ent
#undef  hv_undef 
#define hv_undef          CPerlObj::Perl_hv_undef 
#undef  ibcmp
#define ibcmp             CPerlObj::Perl_ibcmp
#undef  ibcmp_locale
#define ibcmp_locale      CPerlObj::Perl_ibcmp_locale
#undef  incpush
#define incpush           CPerlObj::incpush
#undef  incline
#define incline           CPerlObj::incline
#undef  incl_perldb
#define incl_perldb       CPerlObj::incl_perldb
#undef  ingroup
#define ingroup           CPerlObj::Perl_ingroup
#undef  init_debugger
#define init_debugger     CPerlObj::init_debugger
#undef  init_ids
#define init_ids          CPerlObj::init_ids
#undef  init_interp
#define init_interp       CPerlObj::init_interp
#undef  init_main_thread
#define init_main_thread  CPerlObj::init_main_thread
#undef  init_main_stash
#define init_main_stash   CPerlObj::init_main_stash
#undef  init_lexer
#define init_lexer        CPerlObj::init_lexer
#undef  init_perllib
#define init_perllib      CPerlObj::init_perllib
#undef  init_predump_symbols
#define init_predump_symbols  CPerlObj::init_predump_symbols
#undef  init_postdump_symbols
#define init_postdump_symbols  CPerlObj::init_postdump_symbols
#undef  init_stacks
#define init_stacks       CPerlObj::Perl_init_stacks
#undef  intro_my
#define intro_my          CPerlObj::Perl_intro_my
#undef  nuke_stacks
#define nuke_stacks       CPerlObj::nuke_stacks
#undef  instr
#define instr             CPerlObj::Perl_instr
#undef  intuit_method
#define intuit_method     CPerlObj::intuit_method
#undef  intuit_more
#define intuit_more       CPerlObj::Perl_intuit_more
#undef  invert
#define invert            CPerlObj::Perl_invert
#undef  io_close
#define io_close          CPerlObj::Perl_io_close
#undef  is_an_int
#define is_an_int         CPerlObj::is_an_int
#undef  isa_lookup
#define isa_lookup        CPerlObj::isa_lookup
#undef  jmaybe
#define jmaybe            CPerlObj::Perl_jmaybe
#undef  keyword
#define keyword           CPerlObj::Perl_keyword
#undef  leave_scope
#define leave_scope       CPerlObj::Perl_leave_scope
#undef  lex_end
#define lex_end           CPerlObj::Perl_lex_end
#undef  lex_start
#define lex_start         CPerlObj::Perl_lex_start
#undef  linklist
#define linklist          CPerlObj::Perl_linklist
#undef  list
#define list              CPerlObj::Perl_list
#undef  list_assignment
#define list_assignment   CPerlObj::list_assignment
#undef  listkids
#define listkids          CPerlObj::Perl_listkids
#undef  lop
#define lop               CPerlObj::lop
#undef  localize
#define localize          CPerlObj::Perl_localize
#undef  looks_like_number
#define looks_like_number CPerlObj::Perl_looks_like_number
#undef  magic_clearenv
#define magic_clearenv    CPerlObj::Perl_magic_clearenv
#undef  magic_clear_all_env
#define magic_clear_all_env CPerlObj::Perl_magic_clear_all_env
#undef  magic_clearpack
#define magic_clearpack   CPerlObj::Perl_magic_clearpack
#undef  magic_clearsig
#define magic_clearsig    CPerlObj::Perl_magic_clearsig
#undef  magic_existspack
#define magic_existspack  CPerlObj::Perl_magic_existspack
#undef  magic_freeregexp
#define magic_freeregexp  CPerlObj::Perl_magic_freeregexp
#undef  magic_get
#define magic_get         CPerlObj::Perl_magic_get
#undef  magic_getarylen
#define magic_getarylen   CPerlObj::Perl_magic_getarylen
#undef  magic_getdefelem
#define magic_getdefelem  CPerlObj::Perl_magic_getdefelem
#undef  magic_getpack
#define magic_getpack     CPerlObj::Perl_magic_getpack
#undef  magic_getglob
#define magic_getglob     CPerlObj::Perl_magic_getglob
#undef  magic_getnkeys
#define magic_getnkeys    CPerlObj::Perl_magic_getnkeys
#undef  magic_getpos
#define magic_getpos      CPerlObj::Perl_magic_getpos
#undef  magic_getsig
#define magic_getsig      CPerlObj::Perl_magic_getsig
#undef  magic_getsubstr
#define magic_getsubstr   CPerlObj::Perl_magic_getsubstr
#undef  magic_gettaint
#define magic_gettaint    CPerlObj::Perl_magic_gettaint
#undef  magic_getuvar
#define magic_getuvar     CPerlObj::Perl_magic_getuvar
#undef  magic_getvec
#define magic_getvec     CPerlObj::Perl_magic_getvec
#undef  magic_len
#define magic_len         CPerlObj::Perl_magic_len
#undef  magic_methcall
#define magic_methcall    CPerlObj::magic_methcall
#undef  magic_methpack
#define magic_methpack    CPerlObj::magic_methpack
#undef  magic_nextpack
#define magic_nextpack    CPerlObj::Perl_magic_nextpack
#undef  magic_set
#define magic_set         CPerlObj::Perl_magic_set
#undef  magic_set_all_env
#define magic_set_all_env CPerlObj::Perl_magic_set_all_env
#undef  magic_setamagic
#define magic_setamagic   CPerlObj::Perl_magic_setamagic
#undef  magic_setarylen
#define magic_setarylen   CPerlObj::Perl_magic_setarylen
#undef  magic_setbm
#define magic_setbm       CPerlObj::Perl_magic_setbm
#undef  magic_setcollxfrm
#define magic_setcollxfrm CPerlObj::Perl_magic_setcollxfrm
#undef  magic_setdbline
#define magic_setdbline   CPerlObj::Perl_magic_setdbline
#undef  magic_setdefelem
#define magic_setdefelem  CPerlObj::Perl_magic_setdefelem
#undef  magic_setenv
#define magic_setenv      CPerlObj::Perl_magic_setenv
#undef  magic_setfm
#define magic_setfm       CPerlObj::Perl_magic_setfm
#undef  magic_setisa
#define magic_setisa      CPerlObj::Perl_magic_setisa
#undef  magic_setglob
#define magic_setglob     CPerlObj::Perl_magic_setglob
#undef  magic_setmglob
#define magic_setmglob    CPerlObj::Perl_magic_setmglob
#undef  magic_setnkeys
#define magic_setnkeys    CPerlObj::Perl_magic_setnkeys
#undef  magic_setpack
#define magic_setpack     CPerlObj::Perl_magic_setpack
#undef  magic_setpos
#define magic_setpos      CPerlObj::Perl_magic_setpos
#undef  magic_setsig
#define magic_setsig      CPerlObj::Perl_magic_setsig
#undef  magic_setsubstr
#define magic_setsubstr   CPerlObj::Perl_magic_setsubstr
#undef  magic_settaint
#define magic_settaint    CPerlObj::Perl_magic_settaint
#undef  magic_setuvar
#define magic_setuvar     CPerlObj::Perl_magic_setuvar
#undef  magic_setvec
#define magic_setvec      CPerlObj::Perl_magic_setvec
#undef  magic_sizepack
#define magic_sizepack    CPerlObj::Perl_magic_sizepack
#undef  magic_unchain
#define magic_unchain     CPerlObj::Perl_magic_unchain
#undef  magic_wipepack
#define magic_wipepack    CPerlObj::Perl_magic_wipepack
#undef  magicname
#define magicname         CPerlObj::Perl_magicname
#undef  malloced_size
#define malloced_size     CPerlObj::Perl_malloced_size
#undef  markstack_grow
#define markstack_grow    CPerlObj::Perl_markstack_grow
#undef  markstack_ptr
#define markstack_ptr     CPerlObj::Perl_markstack_ptr
#undef  mess
#define mess              CPerlObj::Perl_mess
#undef  mess_alloc
#define mess_alloc        CPerlObj::mess_alloc
#undef  mem_collxfrm
#define mem_collxfrm      CPerlObj::Perl_mem_collxfrm
#undef  mg_clear
#define mg_clear          CPerlObj::Perl_mg_clear
#undef  mg_copy
#define mg_copy           CPerlObj::Perl_mg_copy
#undef  mg_find
#define mg_find           CPerlObj::Perl_mg_find
#undef  mg_free
#define mg_free           CPerlObj::Perl_mg_free
#undef  mg_get
#define mg_get            CPerlObj::Perl_mg_get
#undef  mg_length
#define mg_length         CPerlObj::Perl_mg_length
#undef  mg_magical
#define mg_magical        CPerlObj::Perl_mg_magical
#undef  mg_set
#define mg_set            CPerlObj::Perl_mg_set
#undef  mg_size
#define mg_size           CPerlObj::Perl_mg_size
#undef  missingterm
#define missingterm       CPerlObj::missingterm
#undef  mod
#define mod               CPerlObj::Perl_mod
#undef  modkids
#define modkids           CPerlObj::Perl_modkids
#undef  moreswitches
#define moreswitches      CPerlObj::Perl_moreswitches
#undef  more_sv
#define more_sv           CPerlObj::more_sv
#undef  more_xiv
#define more_xiv          CPerlObj::more_xiv
#undef  more_xnv
#define more_xnv          CPerlObj::more_xnv
#undef  more_xpv
#define more_xpv          CPerlObj::more_xpv
#undef  more_xrv
#define more_xrv          CPerlObj::more_xrv
#undef  mstats
#define mstats            CPerlObj::mstats
#undef  mul128
#define mul128            CPerlObj::mul128
#undef  my
#define my                CPerlObj::Perl_my
#undef  my_bcopy
#define my_bcopy          CPerlObj::Perl_my_bcopy
#undef  my_bzero
#define my_bzero          CPerlObj::Perl_my_bzero
#undef  my_exit
#define my_exit           CPerlObj::Perl_my_exit
#undef  my_exit_jump
#define my_exit_jump      CPerlObj::my_exit_jump
#undef  my_failure_exit
#define my_failure_exit   CPerlObj::Perl_my_failure_exit
#undef  my_lstat
#define my_lstat          CPerlObj::Perl_my_lstat
#undef  my_memcmp
#define my_memcmp         CPerlObj::Perl_my_memcmp
#undef  my_memset
#define my_memset         CPerlObj::Perl_my_memset
#undef  my_pclose
#define my_pclose         CPerlObj::Perl_my_pclose
#undef  my_popen
#define my_popen          CPerlObj::Perl_my_popen
#undef  my_safemalloc
#define my_safemalloc     CPerlObj::my_safemalloc
#undef  my_setenv
#define my_setenv         CPerlObj::Perl_my_setenv
#undef  my_stat
#define my_stat           CPerlObj::Perl_my_stat
#undef  my_swap
#define my_swap           CPerlObj::my_swap
#undef  my_htonl
#define my_htonl          CPerlObj::my_htonl
#undef  my_ntohl
#define my_ntohl          CPerlObj::my_ntohl
#undef  my_unexec
#define my_unexec         CPerlObj::Perl_my_unexec
#undef  newANONLIST
#define newANONLIST       CPerlObj::Perl_newANONLIST
#undef  newANONHASH
#define newANONHASH       CPerlObj::Perl_newANONHASH
#undef  newANONSUB
#define newANONSUB        CPerlObj::Perl_newANONSUB
#undef  newASSIGNOP
#define newASSIGNOP       CPerlObj::Perl_newASSIGNOP
#undef  newCONDOP
#define newCONDOP         CPerlObj::Perl_newCONDOP
#undef  newCONSTSUB
#define newCONSTSUB       CPerlObj::Perl_newCONSTSUB
#undef  newDEFSVOP
#define newDEFSVOP        CPerlObj::newDEFSVOP
#undef  newFORM
#define newFORM           CPerlObj::Perl_newFORM
#undef  newFOROP
#define newFOROP          CPerlObj::Perl_newFOROP
#undef  newLOGOP
#define newLOGOP          CPerlObj::Perl_newLOGOP
#undef  newLOOPEX
#define newLOOPEX         CPerlObj::Perl_newLOOPEX
#undef  newLOOPOP
#define newLOOPOP         CPerlObj::Perl_newLOOPOP
#undef  newMETHOD
#define newMETHOD         CPerlObj::Perl_newMETHOD
#undef  newNULLLIST
#define newNULLLIST       CPerlObj::Perl_newNULLLIST
#undef  newOP
#define newOP             CPerlObj::Perl_newOP
#undef  newPROG
#define newPROG           CPerlObj::Perl_newPROG
#undef  newRANGE
#define newRANGE          CPerlObj::Perl_newRANGE
#undef  newSLICEOP
#define newSLICEOP        CPerlObj::Perl_newSLICEOP
#undef  newSTATEOP
#define newSTATEOP        CPerlObj::Perl_newSTATEOP
#undef  newSUB
#define newSUB            CPerlObj::Perl_newSUB
#undef  newXS
#define newXS             CPerlObj::Perl_newXS
#undef  newXSUB
#define newXSUB           CPerlObj::Perl_newXSUB
#undef  newAV
#define newAV             CPerlObj::Perl_newAV
#undef  newAVREF
#define newAVREF          CPerlObj::Perl_newAVREF
#undef  newBINOP
#define newBINOP          CPerlObj::Perl_newBINOP
#undef  newCVREF
#define newCVREF          CPerlObj::Perl_newCVREF
#undef  newCVOP
#define newCVOP           CPerlObj::Perl_newCVOP
#undef  newGVOP
#define newGVOP           CPerlObj::Perl_newGVOP
#undef  newGVgen
#define newGVgen          CPerlObj::Perl_newGVgen
#undef  newGVREF
#define newGVREF          CPerlObj::Perl_newGVREF
#undef  newHVREF
#define newHVREF          CPerlObj::Perl_newHVREF
#undef  newHV
#define newHV             CPerlObj::Perl_newHV
#undef  newHVhv
#define newHVhv           CPerlObj::Perl_newHVhv
#undef  newIO
#define newIO             CPerlObj::Perl_newIO
#undef  newLISTOP
#define newLISTOP         CPerlObj::Perl_newLISTOP
#undef  newPMOP
#define newPMOP           CPerlObj::Perl_newPMOP
#undef  newPVOP
#define newPVOP           CPerlObj::Perl_newPVOP
#undef  newRV
#define newRV             CPerlObj::Perl_newRV
#undef  Perl_newRV_noinc
#define Perl_newRV_noinc  CPerlObj::Perl_newRV_noinc
#undef  newSV
#define newSV             CPerlObj::Perl_newSV
#undef  newSVREF
#define newSVREF          CPerlObj::Perl_newSVREF
#undef  newSVOP
#define newSVOP           CPerlObj::Perl_newSVOP
#undef  newSViv
#define newSViv           CPerlObj::Perl_newSViv
#undef  newSVnv
#define newSVnv           CPerlObj::Perl_newSVnv
#undef  newSVpv
#define newSVpv           CPerlObj::Perl_newSVpv
#undef  newSVpvf
#define newSVpvf          CPerlObj::Perl_newSVpvf
#undef  newSVpvn
#define newSVpvn          CPerlObj::Perl_newSVpvn
#undef  newSVrv
#define newSVrv           CPerlObj::Perl_newSVrv
#undef  newSVsv
#define newSVsv           CPerlObj::Perl_newSVsv
#undef  newUNOP
#define newUNOP           CPerlObj::Perl_newUNOP
#undef  newWHILEOP
#define newWHILEOP        CPerlObj::Perl_newWHILEOP
#undef  new_constant
#define new_constant      CPerlObj::new_constant
#undef  new_logop
#define new_logop         CPerlObj::new_logop
#undef  new_stackinfo
#define new_stackinfo     CPerlObj::Perl_new_stackinfo
#undef  new_sv
#define new_sv            CPerlObj::new_sv
#undef  new_xiv
#define new_xiv           CPerlObj::new_xiv
#undef  new_xnv
#define new_xnv           CPerlObj::new_xnv
#undef  new_xpv
#define new_xpv           CPerlObj::new_xpv
#undef  new_xrv
#define new_xrv           CPerlObj::new_xrv
#undef  nextargv
#define nextargv          CPerlObj::Perl_nextargv
#undef  nextchar
#define nextchar          CPerlObj::nextchar
#undef  ninstr
#define ninstr            CPerlObj::Perl_ninstr
#undef  not_a_number
#define not_a_number      CPerlObj::not_a_number
#undef  no_bareword_allowed
#define no_bareword_allowed     CPerlObj::Perl_no_bareword_allowed
#undef  no_fh_allowed
#define no_fh_allowed     CPerlObj::Perl_no_fh_allowed
#undef  no_op
#define no_op             CPerlObj::Perl_no_op
#undef  null
#define null              CPerlObj::null
#undef  profiledata
#define profiledata       CPerlObj::Perl_profiledata
#undef  package
#define package           CPerlObj::Perl_package
#undef  pad_alloc
#define pad_alloc         CPerlObj::Perl_pad_alloc
#undef  pad_allocmy
#define pad_allocmy       CPerlObj::Perl_pad_allocmy
#undef  pad_findmy
#define pad_findmy        CPerlObj::Perl_pad_findmy
#undef  op_const_sv
#define op_const_sv       CPerlObj::Perl_op_const_sv
#undef  op_free
#define op_free           CPerlObj::Perl_op_free
#undef  oopsCV
#define oopsCV            CPerlObj::Perl_oopsCV
#undef  oopsAV
#define oopsAV            CPerlObj::Perl_oopsAV
#undef  oopsHV
#define oopsHV            CPerlObj::Perl_oopsHV
#undef  open_script
#define open_script       CPerlObj::open_script
#undef  pad_leavemy
#define pad_leavemy       CPerlObj::Perl_pad_leavemy
#undef  pad_sv
#define pad_sv            CPerlObj::Perl_pad_sv
#undef  pad_findlex
#define pad_findlex       CPerlObj::pad_findlex
#undef  pad_free
#define pad_free          CPerlObj::Perl_pad_free
#undef  pad_reset
#define pad_reset         CPerlObj::Perl_pad_reset
#undef  pad_swipe
#define pad_swipe         CPerlObj::Perl_pad_swipe
#undef  peep
#define peep              CPerlObj::Perl_peep
#undef  perl_call_argv
#define perl_call_argv    CPerlObj::perl_call_argv
#undef  perl_call_method
#define perl_call_method  CPerlObj::perl_call_method
#undef  perl_call_pv
#define perl_call_pv      CPerlObj::perl_call_pv
#undef  perl_call_sv
#define perl_call_sv      CPerlObj::perl_call_sv
#undef  perl_callargv
#define perl_callargv     CPerlObj::perl_callargv
#undef  perl_callpv
#define perl_callpv       CPerlObj::perl_callpv
#undef  perl_callsv
#define perl_callsv       CPerlObj::perl_callsv
#undef  perl_eval_pv
#define perl_eval_pv      CPerlObj::perl_eval_pv
#undef  perl_eval_sv
#define perl_eval_sv      CPerlObj::perl_eval_sv
#undef  perl_get_sv
#define perl_get_sv       CPerlObj::perl_get_sv
#undef  perl_get_av
#define perl_get_av       CPerlObj::perl_get_av
#undef  perl_get_hv
#define perl_get_hv       CPerlObj::perl_get_hv
#undef  perl_get_cv
#define perl_get_cv       CPerlObj::perl_get_cv
#undef  Perl_GetVars
#define Perl_GetVars      CPerlObj::Perl_GetVars
#undef  perl_init_fold
#define perl_init_fold    CPerlObj::perl_init_fold
#undef  perl_init_i18nl10n
#define perl_init_i18nl10n CPerlObj::perl_init_i18nl10n
#undef  perl_init_i18nl14n
#define perl_init_i18nl14n CPerlObj::perl_init_i18nl14n
#undef  perl_new_collate
#define perl_new_collate  CPerlObj::perl_new_collate
#undef  perl_new_ctype
#define perl_new_ctype    CPerlObj::perl_new_ctype
#undef  perl_new_numeric
#define perl_new_numeric  CPerlObj::perl_new_numeric
#undef  perl_set_numeric_standard
#define perl_set_numeric_standard CPerlObj::perl_set_numeric_standard
#undef  perl_set_numeric_local
#define perl_set_numeric_local CPerlObj::perl_set_numeric_local
#undef  perl_require_pv
#define perl_require_pv   CPerlObj::perl_require_pv
#undef  perl_thread
#define perl_thread       CPerlObj::perl_thread
#undef  pidgone
#define pidgone           CPerlObj::Perl_pidgone
#undef  pmflag
#define pmflag            CPerlObj::Perl_pmflag
#undef  pmruntime
#define pmruntime         CPerlObj::Perl_pmruntime
#undef  pmtrans
#define pmtrans           CPerlObj::Perl_pmtrans
#undef  pop_return
#define pop_return        CPerlObj::Perl_pop_return
#undef  pop_scope
#define pop_scope         CPerlObj::Perl_pop_scope
#undef  prepend_elem
#define prepend_elem      CPerlObj::Perl_prepend_elem
#undef  provide_ref
#define provide_ref       CPerlObj::Perl_provide_ref
#undef  push_return
#define push_return       CPerlObj::Perl_push_return
#undef  push_scope
#define push_scope        CPerlObj::Perl_push_scope
#undef  pregcomp
#define pregcomp          CPerlObj::Perl_pregcomp
#undef  qsortsv
#define qsortsv           CPerlObj::qsortsv
#undef  ref
#define ref               CPerlObj::Perl_ref
#undef  refkids
#define refkids           CPerlObj::Perl_refkids
#undef  regdump
#define regdump           CPerlObj::Perl_regdump
#undef  rsignal
#define rsignal           CPerlObj::Perl_rsignal
#undef  rsignal_restore
#define rsignal_restore   CPerlObj::Perl_rsignal_restore
#undef  rsignal_save
#define rsignal_save      CPerlObj::Perl_rsignal_save
#undef  rsignal_state
#define rsignal_state     CPerlObj::Perl_rsignal_state
#undef  pregexec
#define pregexec          CPerlObj::Perl_pregexec
#undef  pregfree
#define pregfree          CPerlObj::Perl_pregfree
#undef  re_croak2
#define re_croak2         CPerlObj::re_croak2
#undef  refto
#define refto             CPerlObj::refto
#undef  reg
#define reg               CPerlObj::reg
#undef  reg_node
#define reg_node          CPerlObj::reg_node
#undef  reganode
#define reganode          CPerlObj::reganode
#undef  regatom
#define regatom           CPerlObj::regatom
#undef  regbranch
#define regbranch         CPerlObj::regbranch
#undef  regc
#define regc              CPerlObj::regc
#undef  regcurly
#define regcurly          CPerlObj::regcurly
#undef  regcppush
#define regcppush         CPerlObj::regcppush
#undef  regcppop
#define regcppop          CPerlObj::regcppop
#undef  regclass
#define regclass          CPerlObj::regclass
#undef  regexec_flags
#define regexec_flags     CPerlObj::Perl_regexec_flags
#undef  reginclass
#define reginclass        CPerlObj::reginclass
#undef  reginsert
#define reginsert         CPerlObj::reginsert
#undef  regmatch
#define regmatch          CPerlObj::regmatch
#undef  regnext
#define regnext           CPerlObj::Perl_regnext
#undef  regoptail
#define regoptail         CPerlObj::regoptail
#undef  regpiece
#define regpiece          CPerlObj::regpiece
#undef  regprop
#define regprop           CPerlObj::Perl_regprop
#undef  regrepeat
#define regrepeat         CPerlObj::regrepeat
#undef  regrepeat_hard
#define regrepeat_hard    CPerlObj::regrepeat_hard
#undef  regset
#define regset            CPerlObj::regset
#undef  regtail
#define regtail           CPerlObj::regtail
#undef  regtry
#define regtry            CPerlObj::regtry
#undef  regwhite
#define regwhite          CPerlObj::regwhite
#undef  repeatcpy
#define repeatcpy         CPerlObj::Perl_repeatcpy
#undef  restore_expect
#define restore_expect    CPerlObj::restore_expect
#undef  restore_lex_expect
#define restore_lex_expect CPerlObj::restore_lex_expect
#undef  restore_magic
#define restore_magic     CPerlObj::restore_magic
#undef  restore_rsfp
#define restore_rsfp      CPerlObj::restore_rsfp
#undef  rninstr
#define rninstr           CPerlObj::Perl_rninstr
#undef  runops_standard
#define runops_standard   CPerlObj::Perl_runops_standard
#undef  runops_debug
#define runops_debug      CPerlObj::Perl_runops_debug
#undef  rxres_free
#define rxres_free        CPerlObj::Perl_rxres_free
#undef  rxres_restore
#define rxres_restore     CPerlObj::Perl_rxres_restore
#undef  rxres_save
#define rxres_save        CPerlObj::Perl_rxres_save
#ifndef MYMALLOC
#undef  safefree
#define safefree          CPerlObj::Perl_safefree
#undef  safecalloc
#define safecalloc        CPerlObj::Perl_safecalloc
#undef  safemalloc
#define safemalloc        CPerlObj::Perl_safemalloc
#undef  saferealloc
#define saferealloc       CPerlObj::Perl_saferealloc
#endif	/* MYMALLOC */
#undef  same_dirent
#define same_dirent       CPerlObj::same_dirent
#undef  savepv
#define savepv            CPerlObj::Perl_savepv
#undef  savepvn
#define savepvn           CPerlObj::Perl_savepvn
#undef  savestack_grow
#define savestack_grow    CPerlObj::Perl_savestack_grow
#undef  save_aelem
#define save_aelem        CPerlObj::Perl_save_aelem
#undef  save_aptr
#define save_aptr         CPerlObj::Perl_save_aptr
#undef  save_ary
#define save_ary          CPerlObj::Perl_save_ary
#undef  save_clearsv
#define save_clearsv      CPerlObj::Perl_save_clearsv
#undef  save_delete
#define save_delete       CPerlObj::Perl_save_delete
#undef  save_destructor
#define save_destructor   CPerlObj::Perl_save_destructor
#undef  save_freesv
#define save_freesv       CPerlObj::Perl_save_freesv
#undef  save_freeop
#define save_freeop       CPerlObj::Perl_save_freeop
#undef  save_freepv
#define save_freepv       CPerlObj::Perl_save_freepv
#undef  save_generic_svref
#define save_generic_svref CPerlObj::Perl_save_generic_svref
#undef  save_gp
#define save_gp           CPerlObj::Perl_save_gp
#undef  save_hash
#define save_hash         CPerlObj::Perl_save_hash
#undef  save_hek
#define save_hek          CPerlObj::save_hek
#undef  save_helem
#define save_helem        CPerlObj::Perl_save_helem
#undef  save_hints
#define save_hints        CPerlObj::Perl_save_hints
#undef  save_hptr
#define save_hptr         CPerlObj::Perl_save_hptr
#undef  save_I16
#define save_I16          CPerlObj::Perl_save_I16
#undef  save_I32
#define save_I32          CPerlObj::Perl_save_I32
#undef  save_int
#define save_int          CPerlObj::Perl_save_int
#undef  save_item
#define save_item         CPerlObj::Perl_save_item
#undef  save_iv
#define save_iv           CPerlObj::Perl_save_iv
#undef  save_lines
#define save_lines        CPerlObj::save_lines
#undef  save_list
#define save_list         CPerlObj::Perl_save_list
#undef  save_long
#define save_long         CPerlObj::Perl_save_long
#undef  save_magic
#define save_magic        CPerlObj::save_magic
#undef  save_nogv
#define save_nogv         CPerlObj::Perl_save_nogv
#undef  save_op
#define save_op           CPerlObj::Perl_save_op
#undef  save_scalar
#define save_scalar       CPerlObj::Perl_save_scalar
#undef  save_scalar_at
#define save_scalar_at    CPerlObj::save_scalar_at
#undef  save_pptr
#define save_pptr         CPerlObj::Perl_save_pptr
#undef  save_sptr
#define save_sptr         CPerlObj::Perl_save_sptr
#undef  save_svref
#define save_svref        CPerlObj::Perl_save_svref
#undef  save_threadsv
#define save_threadsv     CPerlObj::Perl_save_threadsv
#undef  sawparens
#define sawparens         CPerlObj::Perl_sawparens
#undef  scalar
#define scalar            CPerlObj::Perl_scalar
#undef  scalarboolean
#define scalarboolean     CPerlObj::scalarboolean
#undef  scalarkids
#define scalarkids        CPerlObj::Perl_scalarkids
#undef  scalarseq
#define scalarseq         CPerlObj::Perl_scalarseq
#undef  scalarvoid
#define scalarvoid        CPerlObj::Perl_scalarvoid
#undef  scan_commit
#define scan_commit       CPerlObj::scan_commit
#undef  scan_const
#define scan_const        CPerlObj::Perl_scan_const
#undef  scan_formline
#define scan_formline     CPerlObj::Perl_scan_formline
#undef  scan_ident
#define scan_ident        CPerlObj::Perl_scan_ident
#undef  scan_inputsymbol
#define scan_inputsymbol  CPerlObj::Perl_scan_inputsymbol
#undef  scan_heredoc
#define scan_heredoc      CPerlObj::Perl_scan_heredoc
#undef  scan_hex
#define scan_hex          CPerlObj::Perl_scan_hex
#undef  scan_num
#define scan_num          CPerlObj::Perl_scan_num
#undef  scan_oct
#define scan_oct          CPerlObj::Perl_scan_oct
#undef  scan_pat
#define scan_pat          CPerlObj::Perl_scan_pat
#undef  scan_str
#define scan_str          CPerlObj::Perl_scan_str
#undef  scan_subst
#define scan_subst        CPerlObj::Perl_scan_subst
#undef  scan_trans
#define scan_trans        CPerlObj::Perl_scan_trans
#undef  scan_word
#define scan_word         CPerlObj::Perl_scan_word
#undef  scope
#define scope             CPerlObj::Perl_scope
#undef  screaminstr
#define screaminstr       CPerlObj::Perl_screaminstr
#undef  seed
#define seed              CPerlObj::seed
#undef  setdefout
#define setdefout         CPerlObj::Perl_setdefout
#undef  setenv_getix
#define setenv_getix      CPerlObj::Perl_setenv_getix
#undef  sharepvn
#define sharepvn          CPerlObj::Perl_sharepvn
#undef  set_csh
#define set_csh           CPerlObj::set_csh
#undef  sighandler
#define sighandler        CPerlObj::Perl_sighandler
#undef  share_hek
#define share_hek         CPerlObj::Perl_share_hek
#undef  skipspace
#define skipspace         CPerlObj::Perl_skipspace
#undef  sortcv
#define sortcv            CPerlObj::sortcv
#ifndef PERL_OBJECT
#undef  stack_base
#define stack_base        CPerlObj::Perl_stack_base
#endif
#undef  stack_grow
#define stack_grow        CPerlObj::Perl_stack_grow
#undef  start_subparse
#define start_subparse    CPerlObj::Perl_start_subparse
#undef  study_chunk
#define study_chunk       CPerlObj::study_chunk
#undef  sub_crush_depth
#define sub_crush_depth   CPerlObj::Perl_sub_crush_depth
#undef  sublex_done
#define sublex_done       CPerlObj::sublex_done
#undef  sublex_push
#define sublex_push       CPerlObj::sublex_push
#undef  sublex_start
#define sublex_start      CPerlObj::sublex_start
#undef  sv_2bool
#define sv_2bool          CPerlObj::Perl_sv_2bool
#undef  sv_2cv
#define sv_2cv            CPerlObj::Perl_sv_2cv
#undef  sv_2io
#define sv_2io            CPerlObj::Perl_sv_2io
#undef  sv_2iv
#define sv_2iv            CPerlObj::Perl_sv_2iv
#undef  sv_2uv
#define sv_2uv            CPerlObj::Perl_sv_2uv
#undef  sv_2mortal
#define sv_2mortal        CPerlObj::Perl_sv_2mortal
#undef  sv_2nv
#define sv_2nv            CPerlObj::Perl_sv_2nv
#undef  sv_2pv
#define sv_2pv            CPerlObj::Perl_sv_2pv
#undef  sv_add_arena
#define sv_add_arena      CPerlObj::Perl_sv_add_arena
#undef  sv_backoff
#define sv_backoff        CPerlObj::Perl_sv_backoff
#undef  sv_bless
#define sv_bless          CPerlObj::Perl_sv_bless
#undef  sv_catpv
#define sv_catpv          CPerlObj::Perl_sv_catpv
#undef  sv_catpv_mg
#define sv_catpv_mg       CPerlObj::Perl_sv_catpv_mg
#undef  sv_catpvf
#define sv_catpvf         CPerlObj::Perl_sv_catpvf
#undef  sv_catpvf_mg
#define sv_catpvf_mg      CPerlObj::Perl_sv_catpvf_mg
#undef  sv_catpvn
#define sv_catpvn         CPerlObj::Perl_sv_catpvn
#undef  sv_catpvn_mg
#define sv_catpvn_mg      CPerlObj::Perl_sv_catpvn_mg
#undef  sv_catsv
#define sv_catsv          CPerlObj::Perl_sv_catsv
#undef  sv_catsv_mg
#define sv_catsv_mg       CPerlObj::Perl_sv_catsv_mg
#undef  sv_check_thinkfirst
#define sv_check_thinkfirst CPerlObj::sv_check_thinkfirst
#undef  sv_chop
#define sv_chop           CPerlObj::Perl_sv_chop
#undef  sv_clean_all
#define sv_clean_all      CPerlObj::Perl_sv_clean_all
#undef  sv_clean_objs
#define sv_clean_objs     CPerlObj::Perl_sv_clean_objs
#undef  sv_clear
#define sv_clear          CPerlObj::Perl_sv_clear
#undef  sv_cmp
#define sv_cmp            CPerlObj::Perl_sv_cmp
#undef  sv_cmp_locale
#define sv_cmp_locale     CPerlObj::Perl_sv_cmp_locale
#undef  sv_collxfrm
#define sv_collxfrm       CPerlObj::Perl_sv_collxfrm
#undef  sv_compile_2op
#define sv_compile_2op    CPerlObj::Perl_sv_compile_2op
#undef  sv_dec
#define sv_dec            CPerlObj::Perl_sv_dec
#undef  sv_derived_from
#define sv_derived_from   CPerlObj::Perl_sv_derived_from
#undef  sv_dump
#define sv_dump           CPerlObj::Perl_sv_dump
#undef  sv_eq
#define sv_eq             CPerlObj::Perl_sv_eq
#undef  sv_free
#define sv_free           CPerlObj::Perl_sv_free
#undef  sv_free_arenas
#define sv_free_arenas    CPerlObj::Perl_sv_free_arenas
#undef  sv_gets
#define sv_gets           CPerlObj::Perl_sv_gets
#undef  sv_grow
#define sv_grow           CPerlObj::Perl_sv_grow
#undef  sv_inc
#define sv_inc            CPerlObj::Perl_sv_inc
#undef  sv_insert
#define sv_insert         CPerlObj::Perl_sv_insert
#undef  sv_isa
#define sv_isa            CPerlObj::Perl_sv_isa
#undef  sv_isobject
#define sv_isobject       CPerlObj::Perl_sv_isobject
#undef  sv_iv
#define sv_iv             CPerlObj::Perl_sv_iv
#undef  sv_len
#define sv_len            CPerlObj::Perl_sv_len
#undef  sv_magic
#define sv_magic          CPerlObj::Perl_sv_magic
#undef  sv_mortalcopy
#define sv_mortalcopy     CPerlObj::Perl_sv_mortalcopy
#undef  sv_mortalgrow
#define sv_mortalgrow     CPerlObj::sv_mortalgrow
#undef  sv_newmortal
#define sv_newmortal      CPerlObj::Perl_sv_newmortal
#undef  sv_newref
#define sv_newref         CPerlObj::Perl_sv_newref
#undef  sv_nv
#define sv_nv             CPerlObj::Perl_sv_nv
#undef  sv_peek
#define sv_peek           CPerlObj::Perl_sv_peek
#undef  sv_pvn
#define sv_pvn            CPerlObj::Perl_sv_pvn
#undef  sv_pvn_force
#define sv_pvn_force      CPerlObj::Perl_sv_pvn_force
#undef  sv_reftype
#define sv_reftype        CPerlObj::Perl_sv_reftype
#undef  sv_replace
#define sv_replace        CPerlObj::Perl_sv_replace
#undef  sv_report_used
#define sv_report_used    CPerlObj::Perl_sv_report_used
#undef  sv_reset
#define sv_reset          CPerlObj::Perl_sv_reset
#undef  sv_setiv
#define sv_setiv          CPerlObj::Perl_sv_setiv
#undef  sv_setiv_mg
#define sv_setiv_mg       CPerlObj::Perl_sv_setiv_mg
#undef  sv_setnv
#define sv_setnv          CPerlObj::Perl_sv_setnv
#undef  sv_setnv_mg
#define sv_setnv_mg       CPerlObj::Perl_sv_setnv_mg
#undef  sv_setuv
#define sv_setuv          CPerlObj::Perl_sv_setuv
#undef  sv_setuv_mg
#define sv_setuv_mg       CPerlObj::Perl_sv_setuv_mg
#undef  sv_setref_iv
#define sv_setref_iv      CPerlObj::Perl_sv_setref_iv
#undef  sv_setref_nv
#define sv_setref_nv      CPerlObj::Perl_sv_setref_nv
#undef  sv_setref_pv
#define sv_setref_pv      CPerlObj::Perl_sv_setref_pv
#undef  sv_setref_pvn
#define sv_setref_pvn     CPerlObj::Perl_sv_setref_pvn
#undef  sv_setpv
#define sv_setpv          CPerlObj::Perl_sv_setpv
#undef  sv_setpv_mg
#define sv_setpv_mg       CPerlObj::Perl_sv_setpv_mg
#undef  sv_setpvf
#define sv_setpvf         CPerlObj::Perl_sv_setpvf
#undef  sv_setpvf_mg
#define sv_setpvf_mg      CPerlObj::Perl_sv_setpvf_mg
#undef  sv_setpviv
#define sv_setpviv        CPerlObj::Perl_sv_setpviv
#undef  sv_setpviv_mg
#define sv_setpviv_mg     CPerlObj::Perl_sv_setpviv_mg
#undef  sv_setpvn
#define sv_setpvn         CPerlObj::Perl_sv_setpvn
#undef  sv_setpvn_mg
#define sv_setpvn_mg      CPerlObj::Perl_sv_setpvn_mg
#undef  sv_setsv
#define sv_setsv          CPerlObj::Perl_sv_setsv
#undef  sv_setsv_mg
#define sv_setsv_mg       CPerlObj::Perl_sv_setsv_mg
#undef  sv_taint
#define sv_taint          CPerlObj::Perl_sv_taint
#undef  sv_tainted
#define sv_tainted        CPerlObj::Perl_sv_tainted
#undef  sv_true
#define sv_true           CPerlObj::Perl_sv_true
#undef  sv_unglob
#define sv_unglob         CPerlObj::sv_unglob
#undef  sv_unmagic
#define sv_unmagic        CPerlObj::Perl_sv_unmagic
#undef  sv_unref
#define sv_unref          CPerlObj::Perl_sv_unref
#undef  sv_untaint
#define sv_untaint        CPerlObj::Perl_sv_untaint
#undef  sv_upgrade
#define sv_upgrade        CPerlObj::Perl_sv_upgrade
#undef  sv_usepvn
#define sv_usepvn         CPerlObj::Perl_sv_usepvn
#undef  sv_usepvn_mg
#define sv_usepvn_mg      CPerlObj::Perl_sv_usepvn_mg
#undef  sv_uv
#define sv_uv             CPerlObj::Perl_sv_uv
#undef  sv_vcatpvfn
#define sv_vcatpvfn       CPerlObj::Perl_sv_vcatpvfn
#undef  sv_vsetpvfn
#define sv_vsetpvfn       CPerlObj::Perl_sv_vsetpvfn
#undef  taint_env
#define taint_env         CPerlObj::Perl_taint_env
#undef  taint_not
#define taint_not         CPerlObj::Perl_taint_not
#undef  taint_proper
#define taint_proper      CPerlObj::Perl_taint_proper
#undef  tokeq
#define tokeq             CPerlObj::tokeq
#undef  too_few_arguments
#define too_few_arguments CPerlObj::Perl_too_few_arguments
#undef  too_many_arguments
#define too_many_arguments CPerlObj::Perl_too_many_arguments
#undef  unlnk
#define unlnk             CPerlObj::unlnk
#undef  unsharepvn
#define unsharepvn        CPerlObj::Perl_unsharepvn
#undef  unshare_hek
#define unshare_hek       CPerlObj::Perl_unshare_hek
#undef  unwind_handler_stack
#define unwind_handler_stack CPerlObj::unwind_handler_stack
#undef  usage
#define usage             CPerlObj::usage
#undef  utilize
#define utilize           CPerlObj::Perl_utilize
#undef  validate_suid
#define validate_suid     CPerlObj::validate_suid
#undef  visit
#define visit             CPerlObj::visit
#undef  vivify_defelem
#define vivify_defelem    CPerlObj::Perl_vivify_defelem
#undef  vivify_ref
#define vivify_ref        CPerlObj::Perl_vivify_ref
#undef  wait4pid
#define wait4pid          CPerlObj::Perl_wait4pid
#undef  warn
#define warn              CPerlObj::Perl_warn
#undef  watch
#define watch             CPerlObj::Perl_watch
#undef  whichsig
#define whichsig          CPerlObj::Perl_whichsig
#undef  win32_textfilter
#define win32_textfilter  CPerlObj::win32_textfilter
#undef  yyerror
#define yyerror           CPerlObj::Perl_yyerror
#undef  yylex
#define yylex             CPerlObj::Perl_yylex
#undef  yyparse
#define yyparse           CPerlObj::Perl_yyparse
#undef  yywarn
#define yywarn            CPerlObj::Perl_yywarn
#undef  yydestruct
#define yydestruct        CPerlObj::Perl_yydestruct

#define new_he            CPerlObj::new_he
#define more_he           CPerlObj::more_he
#define del_he            CPerlObj::del_he

#if defined(WIN32) && !defined(WIN32IO_IS_STDIO)
#undef errno
#define errno             CPerlObj::ErrorNo()

#endif /* WIN32 */

#endif /* __Objpp_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\objxsub.h ===
#ifndef __objXSUB_h__
#define __objXSUB_h__

/* Varibles */ 

#undef  PL_Sv			
#define PL_Sv					pPerl->PL_Sv			
#undef  PL_Xpv			
#define PL_Xpv					pPerl->PL_Xpv			
#undef  PL_av_fetch_sv		
#define PL_av_fetch_sv			pPerl->PL_av_fetch_sv		
#undef  PL_bodytarget		
#define PL_bodytarget				pPerl->PL_bodytarget		
#undef  PL_bostr		
#define PL_bostr				pPerl->PL_bostr		
#undef  PL_chopset		
#define PL_chopset				pPerl->PL_chopset		
#undef  PL_colors		
#define PL_colors				pPerl->PL_colors		
#undef  PL_colorset		
#define PL_colorset				pPerl->PL_colorset		
#undef  PL_cred_mutex
#define PL_cred_mutex				pPerl->PL_cred_mutex   
#undef  PL_curcop		
#define PL_curcop				pPerl->PL_curcop		
#undef  PL_curpad		
#define PL_curpad				pPerl->PL_curpad		
#undef  PL_curpm		
#define PL_curpm				pPerl->PL_curpm		
#undef  PL_curstack		
#define PL_curstack				pPerl->PL_curstack		
#undef  PL_curstackinfo		
#define PL_curstackinfo			pPerl->PL_curstackinfo		
#undef  PL_curstash		
#define PL_curstash				pPerl->PL_curstash		
#undef  PL_defoutgv		
#define PL_defoutgv				pPerl->PL_defoutgv		
#undef  PL_defstash		
#define PL_defstash				pPerl->PL_defstash		
#undef  PL_delaymagic		
#define PL_delaymagic				pPerl->PL_delaymagic		
#undef  PL_dirty		
#define PL_dirty				pPerl->PL_dirty		
#undef  PL_extralen		
#define PL_extralen				pPerl->PL_extralen		
#undef  PL_firstgv		
#define PL_firstgv				pPerl->PL_firstgv		
#undef  PL_formtarget		
#define PL_formtarget				pPerl->PL_formtarget		
#undef  PL_hv_fetch_ent_mh	
#define PL_hv_fetch_ent_mh		pPerl->PL_hv_fetch_ent_mh	
#undef  PL_hv_fetch_sv		
#define PL_hv_fetch_sv			pPerl->PL_hv_fetch_sv		
#undef  PL_in_eval		
#define PL_in_eval				pPerl->PL_in_eval		
#undef  PL_last_in_gv		
#define PL_last_in_gv				pPerl->PL_last_in_gv		
#undef  PL_lastgotoprobe	
#define PL_lastgotoprobe		pPerl->PL_lastgotoprobe	
#undef  PL_lastscream		
#define PL_lastscream				pPerl->PL_lastscream		
#undef  PL_localizing		
#define PL_localizing				pPerl->PL_localizing		
#undef  PL_mainstack		
#define PL_mainstack				pPerl->PL_mainstack		
#undef  PL_markstack		
#define PL_markstack				pPerl->PL_markstack		
#undef  PL_markstack_max	
#define PL_markstack_max		pPerl->PL_markstack_max	
#undef  PL_markstack_ptr	
#define PL_markstack_ptr		pPerl->PL_markstack_ptr	
#undef  PL_maxscream		
#define PL_maxscream				pPerl->PL_maxscream		
#undef  PL_modcount		
#define PL_modcount				pPerl->PL_modcount		
#undef  PL_nrs			
#define PL_nrs					pPerl->PL_nrs			
#undef  PL_ofs			
#define PL_ofs					pPerl->PL_ofs			
#undef  PL_ofslen		
#define PL_ofslen				pPerl->PL_ofslen		
#undef  PL_op			
#define PL_op					pPerl->PL_op			
#undef  PL_opsave		
#define PL_opsave				pPerl->PL_opsave		
#undef  PL_reg_eval_set		
#define PL_reg_eval_set			pPerl->PL_reg_eval_set		
#undef  PL_reg_flags		
#define PL_reg_flags				pPerl->PL_reg_flags		
#undef  PL_reg_start_tmp	
#define PL_reg_start_tmp		pPerl->PL_reg_start_tmp	
#undef  PL_reg_start_tmpl	
#define PL_reg_start_tmpl		pPerl->PL_reg_start_tmpl	
#undef  PL_regbol		
#define PL_regbol				pPerl->PL_regbol		
#undef  PL_regcc		
#define PL_regcc				pPerl->PL_regcc		
#undef  PL_regcode		
#define PL_regcode				pPerl->PL_regcode		
#undef  PL_regcomp_parse	
#define PL_regcomp_parse		pPerl->PL_regcomp_parse	
#undef  PL_regcomp_rx		
#define PL_regcomp_rx				pPerl->PL_regcomp_rx		
#undef  PL_regcompp		
#define PL_regcompp				pPerl->PL_regcompp		
#undef  PL_regdata		
#define PL_regdata				pPerl->PL_regdata		
#undef  PL_regdummy		
#define PL_regdummy				pPerl->PL_regdummy		
#undef  PL_regendp		
#define PL_regendp				pPerl->PL_regendp		
#undef  PL_regeol		
#define PL_regeol				pPerl->PL_regeol		
#undef  PL_regexecp		
#define PL_regexecp				pPerl->PL_regexecp		
#undef  PL_regflags		
#define PL_regflags				pPerl->PL_regflags		
#undef  PL_regindent		
#define PL_regindent				pPerl->PL_regindent		
#undef  PL_reginput		
#define PL_reginput				pPerl->PL_reginput		
#undef  PL_reginterp_cnt	
#define PL_reginterp_cnt		pPerl->PL_reginterp_cnt	
#undef  PL_reglastparen		
#define PL_reglastparen			pPerl->PL_reglastparen		
#undef  PL_regnarrate		
#define PL_regnarrate				pPerl->PL_regnarrate		
#undef  PL_regnaughty		
#define PL_regnaughty				pPerl->PL_regnaughty		
#undef  PL_regnpar		
#define PL_regnpar				pPerl->PL_regnpar		
#undef  PL_regprecomp		
#define PL_regprecomp				pPerl->PL_regprecomp		
#undef  PL_regprev		
#define PL_regprev				pPerl->PL_regprev		
#undef  PL_regprogram		
#define PL_regprogram				pPerl->PL_regprogram		
#undef  PL_regsawback		
#define PL_regsawback				pPerl->PL_regsawback		
#undef  PL_regseen		
#define PL_regseen				pPerl->PL_regseen		
#undef  PL_regsize		
#define PL_regsize				pPerl->PL_regsize		
#undef  PL_regstartp		
#define PL_regstartp				pPerl->PL_regstartp		
#undef  PL_regtill		
#define PL_regtill				pPerl->PL_regtill		
#undef  PL_regxend		
#define PL_regxend				pPerl->PL_regxend		
#undef  PL_restartop		
#define PL_restartop				pPerl->PL_restartop		
#undef  PL_retstack		
#define PL_retstack				pPerl->PL_retstack		
#undef  PL_retstack_ix		
#define PL_retstack_ix			pPerl->PL_retstack_ix		
#undef  PL_retstack_max		
#define PL_retstack_max			pPerl->PL_retstack_max		
#undef  PL_rs			
#define PL_rs					pPerl->PL_rs			
#undef  PL_savestack		
#define PL_savestack				pPerl->PL_savestack		
#undef  PL_savestack_ix		
#define PL_savestack_ix			pPerl->PL_savestack_ix		
#undef  PL_savestack_max	
#define PL_savestack_max		pPerl->PL_savestack_max	
#undef  PL_scopestack		
#define PL_scopestack				pPerl->PL_scopestack		
#undef  PL_scopestack_ix	
#define PL_scopestack_ix		pPerl->PL_scopestack_ix	
#undef  PL_scopestack_max	
#define PL_scopestack_max		pPerl->PL_scopestack_max	
#undef  PL_screamfirst		
#define PL_screamfirst			pPerl->PL_screamfirst		
#undef  PL_screamnext		
#define PL_screamnext				pPerl->PL_screamnext		
#undef  PL_secondgv		
#define PL_secondgv				pPerl->PL_secondgv		
#undef  PL_seen_evals		
#define PL_seen_evals				pPerl->PL_seen_evals		
#undef  PL_seen_zerolen		
#define PL_seen_zerolen			pPerl->PL_seen_zerolen		
#undef  PL_sortcop		
#define PL_sortcop				pPerl->PL_sortcop		
#undef  PL_sortcxix		
#define PL_sortcxix				pPerl->PL_sortcxix		
#undef  PL_sortstash		
#define PL_sortstash				pPerl->PL_sortstash		
#undef  PL_stack_base		
#define PL_stack_base				pPerl->PL_stack_base		
#undef  PL_stack_max		
#define PL_stack_max				pPerl->PL_stack_max		
#undef  PL_stack_sp		
#define PL_stack_sp				pPerl->PL_stack_sp		
#undef  PL_start_env		
#define PL_start_env				pPerl->PL_start_env		
#undef  PL_statbuf		
#define PL_statbuf				pPerl->PL_statbuf		
#undef  PL_statcache		
#define PL_statcache				pPerl->PL_statcache		
#undef  PL_statgv		
#define PL_statgv				pPerl->PL_statgv		
#undef  PL_statname		
#define PL_statname				pPerl->PL_statname		
#undef  PL_tainted		
#define PL_tainted				pPerl->PL_tainted		
#undef  PL_timesbuf		
#define PL_timesbuf				pPerl->PL_timesbuf		
#undef  PL_tmps_floor		
#define PL_tmps_floor				pPerl->PL_tmps_floor		
#undef  PL_tmps_ix		
#define PL_tmps_ix				pPerl->PL_tmps_ix		
#undef  PL_tmps_max		
#define PL_tmps_max				pPerl->PL_tmps_max		
#undef  PL_tmps_stack		
#define PL_tmps_stack				pPerl->PL_tmps_stack		
#undef  PL_top_env		
#define PL_top_env				pPerl->PL_top_env		
#undef  PL_toptarget		
#define PL_toptarget				pPerl->PL_toptarget		
#undef  PL_Argv			
#define PL_Argv					pPerl->PL_Argv			
#undef  PL_Cmd			
#define PL_Cmd					pPerl->PL_Cmd			
#undef  PL_DBcv			
#define PL_DBcv					pPerl->PL_DBcv			
#undef  PL_DBgv			
#define PL_DBgv					pPerl->PL_DBgv			
#undef  PL_DBline		
#define PL_DBline				pPerl->PL_DBline		
#undef  PL_DBsignal		
#define PL_DBsignal				pPerl->PL_DBsignal		
#undef  PL_DBsingle		
#define PL_DBsingle				pPerl->PL_DBsingle		
#undef  PL_DBsub		
#define PL_DBsub				pPerl->PL_DBsub		
#undef  PL_DBtrace		
#define PL_DBtrace				pPerl->PL_DBtrace		
#undef  PL_ampergv		
#define PL_ampergv				pPerl->PL_ampergv		
#undef  PL_archpat_auto		
#define PL_archpat_auto			pPerl->PL_archpat_auto		
#undef  PL_argvgv		
#define PL_argvgv				pPerl->PL_argvgv		
#undef  PL_argvoutgv		
#define PL_argvoutgv				pPerl->PL_argvoutgv		
#undef  PL_basetime		
#define PL_basetime				pPerl->PL_basetime		
#undef  PL_beginav		
#define PL_beginav				pPerl->PL_beginav		
#undef  PL_cddir		
#define PL_cddir				pPerl->PL_cddir		
#undef  PL_compcv		
#define PL_compcv				pPerl->PL_compcv		
#undef  PL_compiling		
#define PL_compiling				pPerl->PL_compiling		
#undef  PL_comppad		
#define PL_comppad				pPerl->PL_comppad		
#undef  PL_comppad_name		
#define PL_comppad_name			pPerl->PL_comppad_name		
#undef  PL_comppad_name_fill	
#define PL_comppad_name_fill		pPerl->PL_comppad_name_fill	
#undef  PL_comppad_name_floor	
#define PL_comppad_name_floor		pPerl->PL_comppad_name_floor	
#undef  PL_copline		
#define PL_copline				pPerl->PL_copline		
#undef  PL_curcopdb		
#define PL_curcopdb				pPerl->PL_curcopdb		
#undef  PL_curstname		
#define PL_curstname				pPerl->PL_curstname		
#undef  PL_dbargs		
#define PL_dbargs				pPerl->PL_dbargs		
#undef  PL_debdelim		
#define PL_debdelim				pPerl->PL_debdelim		
#undef  PL_debname		
#define PL_debname				pPerl->PL_debname		
#undef  PL_debstash		
#define PL_debstash				pPerl->PL_debstash		
#undef  PL_defgv		
#define PL_defgv				pPerl->PL_defgv		
#undef  PL_diehook		
#define PL_diehook				pPerl->PL_diehook		
#undef  PL_dlevel		
#define PL_dlevel				pPerl->PL_dlevel		
#undef  PL_dlmax		
#define PL_dlmax				pPerl->PL_dlmax		
#undef  PL_doextract		
#define PL_doextract				pPerl->PL_doextract		
#undef  PL_doswitches		
#define PL_doswitches				pPerl->PL_doswitches		
#undef  PL_dowarn		
#define PL_dowarn				pPerl->PL_dowarn		
#undef  PL_dumplvl		
#define PL_dumplvl				pPerl->PL_dumplvl		
#undef  PL_e_script		
#define PL_e_script				pPerl->PL_e_script		
#undef  PL_endav		
#define PL_endav				pPerl->PL_endav		
#undef  PL_envgv		
#define PL_envgv				pPerl->PL_envgv		
#undef  PL_errgv		
#define PL_errgv				pPerl->PL_errgv		
#undef  PL_eval_root		
#define PL_eval_root				pPerl->PL_eval_root		
#undef  PL_eval_start		
#define PL_eval_start				pPerl->PL_eval_start		
#undef  PL_exitlist		
#define PL_exitlist				pPerl->PL_exitlist		
#undef  PL_exitlistlen		
#define PL_exitlistlen			pPerl->PL_exitlistlen		
#undef  PL_fdpid		
#define PL_fdpid				pPerl->PL_fdpid		
#undef  PL_filemode		
#define PL_filemode				pPerl->PL_filemode		
#undef  PL_forkprocess		
#define PL_forkprocess			pPerl->PL_forkprocess		
#undef  PL_formfeed		
#define PL_formfeed				pPerl->PL_formfeed		
#undef  PL_generation		
#define PL_generation				pPerl->PL_generation		
#undef  PL_gensym		
#define PL_gensym				pPerl->PL_gensym		
#undef  PL_globalstash		
#define PL_globalstash			pPerl->PL_globalstash		
#undef  PL_hintgv		
#define PL_hintgv				pPerl->PL_hintgv		
#undef  PL_in_clean_all		
#define PL_in_clean_all			pPerl->PL_in_clean_all		
#undef  PL_in_clean_objs	
#define PL_in_clean_objs		pPerl->PL_in_clean_objs	
#undef  PL_incgv		
#define PL_incgv				pPerl->PL_incgv		
#undef  PL_initav		
#define PL_initav				pPerl->PL_initav		
#undef  PL_inplace		
#define PL_inplace				pPerl->PL_inplace		
#undef  PL_last_proto		
#define PL_last_proto				pPerl->PL_last_proto		
#undef  PL_lastfd		
#define PL_lastfd				pPerl->PL_lastfd		
#undef  PL_lastsize		
#define PL_lastsize				pPerl->PL_lastsize		
#undef  PL_lastspbase		
#define PL_lastspbase				pPerl->PL_lastspbase		
#undef  PL_laststatval		
#define PL_laststatval			pPerl->PL_laststatval		
#undef  PL_laststype		
#define PL_laststype				pPerl->PL_laststype		
#undef  PL_leftgv		
#define PL_leftgv				pPerl->PL_leftgv		
#undef  PL_lineary		
#define PL_lineary				pPerl->PL_lineary		
#undef  PL_linestart		
#define PL_linestart				pPerl->PL_linestart		
#undef  PL_localpatches		
#define PL_localpatches			pPerl->PL_localpatches		
#undef  PL_main_cv		
#define PL_main_cv				pPerl->PL_main_cv		
#undef  PL_main_root		
#define PL_main_root				pPerl->PL_main_root		
#undef  PL_main_start		
#define PL_main_start				pPerl->PL_main_start		
#undef  PL_maxsysfd		
#define PL_maxsysfd				pPerl->PL_maxsysfd		
#undef  PL_mess_sv		
#define PL_mess_sv				pPerl->PL_mess_sv		
#undef  PL_minus_F		
#define PL_minus_F				pPerl->PL_minus_F		
#undef  PL_minus_a		
#define PL_minus_a				pPerl->PL_minus_a		
#undef  PL_minus_c		
#define PL_minus_c				pPerl->PL_minus_c		
#undef  PL_minus_l		
#define PL_minus_l				pPerl->PL_minus_l		
#undef  PL_minus_n		
#define PL_minus_n				pPerl->PL_minus_n		
#undef  PL_minus_p		
#define PL_minus_p				pPerl->PL_minus_p		
#undef  PL_modglobal		
#define PL_modglobal				pPerl->PL_modglobal		
#undef  PL_multiline		
#define PL_multiline				pPerl->PL_multiline		
#undef  PL_mystrk		
#define PL_mystrk				pPerl->PL_mystrk		
#undef  PL_ofmt			
#define PL_ofmt					pPerl->PL_ofmt			
#undef  PL_oldlastpm		
#define PL_oldlastpm				pPerl->PL_oldlastpm		
#undef  PL_oldname		
#define PL_oldname				pPerl->PL_oldname		
#undef  PL_op_mask		
#define PL_op_mask				pPerl->PL_op_mask		
#undef  PL_origargc		
#define PL_origargc				pPerl->PL_origargc		
#undef  PL_origargv		
#define PL_origargv				pPerl->PL_origargv		
#undef  PL_origfilename		
#define PL_origfilename			pPerl->PL_origfilename		
#undef  PL_ors			
#define PL_ors					pPerl->PL_ors			
#undef  PL_orslen		
#define PL_orslen				pPerl->PL_orslen		
#undef  PL_parsehook		
#define PL_parsehook				pPerl->PL_parsehook		
#undef  PL_patchlevel		
#define PL_patchlevel				pPerl->PL_patchlevel		
#undef  PL_pending_ident	
#define PL_pending_ident		pPerl->PL_pending_ident	
#undef  PL_perl_destruct_level	
#define PL_perl_destruct_level		pPerl->PL_perl_destruct_level	
#undef  PL_perldb		
#define PL_perldb				pPerl->PL_perldb		
#undef  PL_preambleav		
#define PL_preambleav				pPerl->PL_preambleav		
#undef  PL_preambled		
#define PL_preambled				pPerl->PL_preambled		
#undef  PL_preprocess		
#define PL_preprocess				pPerl->PL_preprocess		
#undef  PL_profiledata		
#define PL_profiledata			pPerl->PL_profiledata		
#undef  PL_replgv		
#define PL_replgv				pPerl->PL_replgv		
#undef  PL_rightgv		
#define PL_rightgv				pPerl->PL_rightgv		
#undef  PL_rsfp			
#define PL_rsfp					pPerl->PL_rsfp			
#undef  PL_rsfp_filters		
#define PL_rsfp_filters			pPerl->PL_rsfp_filters		
#undef  PL_sawampersand		
#define PL_sawampersand			pPerl->PL_sawampersand		
#undef  PL_sawstudy		
#define PL_sawstudy				pPerl->PL_sawstudy		
#undef  PL_sawvec		
#define PL_sawvec				pPerl->PL_sawvec		
#undef  PL_siggv		
#define PL_siggv				pPerl->PL_siggv		
#undef  PL_splitstr		
#define PL_splitstr				pPerl->PL_splitstr		
#undef  PL_statusvalue		
#define PL_statusvalue			pPerl->PL_statusvalue		
#undef  PL_statusvalue_vms	
#define PL_statusvalue_vms		pPerl->PL_statusvalue_vms	
#undef  PL_stdingv		
#define PL_stdingv				pPerl->PL_stdingv		
#undef  PL_strchop		
#define PL_strchop				pPerl->PL_strchop		
#undef  PL_strtab		
#define PL_strtab				pPerl->PL_strtab		
#undef  PL_strtab_mutex
#define PL_strtab_mutex				pPerl->PL_strtab_mutex
#undef  PL_sub_generation	
#define PL_sub_generation		pPerl->PL_sub_generation	
#undef  PL_sublex_info		
#define PL_sublex_info			pPerl->PL_sublex_info		
#undef  PL_sv_arenaroot		
#define PL_sv_arenaroot			pPerl->PL_sv_arenaroot		
#undef  PL_sv_count		
#define PL_sv_count				pPerl->PL_sv_count		
#undef  PL_sv_objcount		
#define PL_sv_objcount			pPerl->PL_sv_objcount		
#undef  PL_sv_root		
#define PL_sv_root				pPerl->PL_sv_root		
#undef  PL_sys_intern		
#define PL_sys_intern				pPerl->PL_sys_intern		
#undef  PL_tainting		
#define PL_tainting				pPerl->PL_tainting		
#undef  PL_threadnum		
#define PL_threadnum				pPerl->PL_threadnum		
#undef  PL_thrsv		
#define PL_thrsv				pPerl->PL_thrsv		
#undef  PL_unsafe		
#define PL_unsafe				pPerl->PL_unsafe		
#undef  PL_warnhook		
#define PL_warnhook				pPerl->PL_warnhook		
#undef  PL_No			
#define PL_No					pPerl->PL_No			
#undef  PL_Yes			
#define PL_Yes					pPerl->PL_Yes			
#undef  PL_amagic_generation	
#define PL_amagic_generation		pPerl->PL_amagic_generation	
#undef  PL_an			
#define PL_an					pPerl->PL_an			
#undef  PL_bufend		
#define PL_bufend				pPerl->PL_bufend		
#undef  PL_bufptr		
#define PL_bufptr				pPerl->PL_bufptr		
#undef  PL_collation_ix		
#define PL_collation_ix			pPerl->PL_collation_ix		
#undef  PL_collation_name	
#define PL_collation_name		pPerl->PL_collation_name	
#undef  PL_collation_standard	
#define PL_collation_standard		pPerl->PL_collation_standard	
#undef  PL_collxfrm_base	
#define PL_collxfrm_base		pPerl->PL_collxfrm_base	
#undef  PL_collxfrm_mult	
#define PL_collxfrm_mult		pPerl->PL_collxfrm_mult	
#undef  PL_cop_seqmax		
#define PL_cop_seqmax				pPerl->PL_cop_seqmax		
#undef  PL_cryptseen		
#define PL_cryptseen				pPerl->PL_cryptseen		
#undef  PL_cshlen		
#define PL_cshlen				pPerl->PL_cshlen		
#undef  PL_cshname		
#define PL_cshname				pPerl->PL_cshname		
#undef  PL_curinterp		
#define PL_curinterp				pPerl->PL_curinterp		
#undef  PL_curthr		
#define PL_curthr				pPerl->PL_curthr		
#undef  PL_debug		
#define PL_debug				pPerl->PL_debug		
#undef  PL_do_undump		
#define PL_do_undump				pPerl->PL_do_undump		
#undef  PL_egid			
#define PL_egid					pPerl->PL_egid			
#undef  PL_error_count		
#define PL_error_count			pPerl->PL_error_count		
#undef  PL_euid			
#define PL_euid					pPerl->PL_euid			
#undef  PL_eval_cond		
#define PL_eval_cond				pPerl->PL_eval_cond		
#undef  PL_eval_mutex		
#define PL_eval_mutex				pPerl->PL_eval_mutex		
#undef  PL_eval_owner		
#define PL_eval_owner				pPerl->PL_eval_owner		
#undef  PL_evalseq		
#define PL_evalseq				pPerl->PL_evalseq		
#undef  PL_expect		
#define PL_expect				pPerl->PL_expect		
#undef  PL_gid			
#define PL_gid					pPerl->PL_gid			
#undef  PL_he_root		
#define PL_he_root				pPerl->PL_he_root		
#undef  PL_hexdigit		
#define PL_hexdigit				pPerl->PL_hexdigit		
#undef  PL_hints		
#define PL_hints				pPerl->PL_hints		
#undef  PL_in_my		
#define PL_in_my				pPerl->PL_in_my		
#undef  PL_in_my_stash		
#define PL_in_my_stash			pPerl->PL_in_my_stash		
#undef  PL_last_lop		
#define PL_last_lop				pPerl->PL_last_lop		
#undef  PL_last_lop_op		
#define PL_last_lop_op			pPerl->PL_last_lop_op		
#undef  PL_last_uni		
#define PL_last_uni				pPerl->PL_last_uni		
#undef  PL_lex_brackets		
#define PL_lex_brackets			pPerl->PL_lex_brackets		
#undef  PL_lex_brackstack	
#define PL_lex_brackstack		pPerl->PL_lex_brackstack	
#undef  PL_lex_casemods		
#define PL_lex_casemods			pPerl->PL_lex_casemods		
#undef  PL_lex_casestack	
#define PL_lex_casestack		pPerl->PL_lex_casestack	
#undef  PL_lex_defer		
#define PL_lex_defer				pPerl->PL_lex_defer		
#undef  PL_lex_dojoin		
#define PL_lex_dojoin				pPerl->PL_lex_dojoin		
#undef  PL_lex_expect		
#define PL_lex_expect				pPerl->PL_lex_expect		
#undef  PL_lex_fakebrack	
#define PL_lex_fakebrack		pPerl->PL_lex_fakebrack	
#undef  PL_lex_formbrack	
#define PL_lex_formbrack		pPerl->PL_lex_formbrack	
#undef  PL_lex_inpat		
#define PL_lex_inpat				pPerl->PL_lex_inpat		
#undef  PL_lex_inwhat		
#define PL_lex_inwhat				pPerl->PL_lex_inwhat		
#undef  PL_lex_op		
#define PL_lex_op				pPerl->PL_lex_op		
#undef  PL_lex_repl		
#define PL_lex_repl				pPerl->PL_lex_repl		
#undef  PL_lex_starts		
#define PL_lex_starts				pPerl->PL_lex_starts		
#undef  PL_lex_state		
#define PL_lex_state				pPerl->PL_lex_state		
#undef  PL_lex_stuff		
#define PL_lex_stuff				pPerl->PL_lex_stuff		
#undef  PL_linestr		
#define PL_linestr				pPerl->PL_linestr		
#undef  PL_malloc_mutex		
#define PL_malloc_mutex			pPerl->PL_malloc_mutex		
#undef  PL_max_intro_pending	
#define PL_max_intro_pending		pPerl->PL_max_intro_pending	
#undef  PL_maxo			
#define PL_maxo					pPerl->PL_maxo			
#undef  PL_min_intro_pending	
#define PL_min_intro_pending		pPerl->PL_min_intro_pending	
#undef  PL_multi_close		
#define PL_multi_close			pPerl->PL_multi_close		
#undef  PL_multi_end		
#define PL_multi_end				pPerl->PL_multi_end		
#undef  PL_multi_open		
#define PL_multi_open				pPerl->PL_multi_open		
#undef  PL_multi_start		
#define PL_multi_start			pPerl->PL_multi_start		
#undef  PL_na			
#define PL_na					pPerl->PL_na			
#undef  PL_nexttoke		
#define PL_nexttoke				pPerl->PL_nexttoke		
#undef  PL_nexttype		
#define PL_nexttype				pPerl->PL_nexttype		
#undef  PL_nextval		
#define PL_nextval				pPerl->PL_nextval		
#undef  PL_nice_chunk		
#define PL_nice_chunk				pPerl->PL_nice_chunk		
#undef  PL_nice_chunk_size	
#define PL_nice_chunk_size		pPerl->PL_nice_chunk_size	
#undef  PL_ninterps		
#define PL_ninterps				pPerl->PL_ninterps		
#undef  PL_nomemok		
#define PL_nomemok				pPerl->PL_nomemok		
#undef  PL_nthreads		
#define PL_nthreads				pPerl->PL_nthreads		
#undef  PL_nthreads_cond	
#define PL_nthreads_cond		pPerl->PL_nthreads_cond	
#undef  PL_numeric_local	
#define PL_numeric_local		pPerl->PL_numeric_local	
#undef  PL_numeric_name		
#define PL_numeric_name			pPerl->PL_numeric_name		
#undef  PL_numeric_standard	
#define PL_numeric_standard		pPerl->PL_numeric_standard	
#undef  PL_oldbufptr		
#define PL_oldbufptr				pPerl->PL_oldbufptr		
#undef  PL_oldoldbufptr		
#define PL_oldoldbufptr			pPerl->PL_oldoldbufptr		
#undef  PL_op_seqmax		
#define PL_op_seqmax				pPerl->PL_op_seqmax		
#undef  PL_origalen		
#define PL_origalen				pPerl->PL_origalen		
#undef  PL_origenviron		
#define PL_origenviron			pPerl->PL_origenviron		
#undef  PL_osname		
#define PL_osname				pPerl->PL_osname		
#undef  PL_pad_reset_pending	
#define PL_pad_reset_pending		pPerl->PL_pad_reset_pending	
#undef  PL_padix		
#define PL_padix				pPerl->PL_padix		
#undef  PL_padix_floor		
#define PL_padix_floor			pPerl->PL_padix_floor		
#undef  PL_patleave		
#define PL_patleave				pPerl->PL_patleave		
#undef  PL_pidstatus		
#define PL_pidstatus				pPerl->PL_pidstatus		
#undef  PL_runops		
#define PL_runops				pPerl->PL_runops		
#undef  PL_sh_path		
#define PL_sh_path				pPerl->PL_sh_path		
#undef  PL_sighandlerp		
#define PL_sighandlerp			pPerl->PL_sighandlerp		
#undef  PL_specialsv_list	
#define PL_specialsv_list		pPerl->PL_specialsv_list	
#undef  PL_subline		
#define PL_subline				pPerl->PL_subline		
#undef  PL_subname		
#define PL_subname				pPerl->PL_subname		
#undef  PL_sv_mutex		
#define PL_sv_mutex				pPerl->PL_sv_mutex		
#undef  PL_sv_no		
#define PL_sv_no				pPerl->PL_sv_no		
#undef  PL_sv_undef		
#define PL_sv_undef				pPerl->PL_sv_undef		
#undef  PL_sv_yes		
#define PL_sv_yes				pPerl->PL_sv_yes		
#undef  PL_svref_mutex		
#define PL_svref_mutex			pPerl->PL_svref_mutex		
#undef  PL_thisexpr		
#define PL_thisexpr				pPerl->PL_thisexpr		
#undef  PL_thr_key		
#define PL_thr_key				pPerl->PL_thr_key		
#undef  PL_threads_mutex	
#define PL_threads_mutex		pPerl->PL_threads_mutex	
#undef  PL_threadsv_names	
#define PL_threadsv_names		pPerl->PL_threadsv_names	
#undef  PL_tokenbuf		
#define PL_tokenbuf				pPerl->PL_tokenbuf		
#undef  PL_uid			
#define PL_uid					pPerl->PL_uid			
#undef  PL_xiv_arenaroot	
#define PL_xiv_arenaroot		pPerl->PL_xiv_arenaroot	
#undef  PL_xiv_root		
#define PL_xiv_root				pPerl->PL_xiv_root		
#undef  PL_xnv_root		
#define PL_xnv_root				pPerl->PL_xnv_root		
#undef  PL_xpv_root		
#define PL_xpv_root				pPerl->PL_xpv_root		
#undef  PL_xrv_root		
#define PL_xrv_root				pPerl->PL_xrv_root		

/* Functions */

#undef  amagic_call
#define amagic_call         pPerl->Perl_amagic_call
#undef  Perl_GetVars
#define Perl_GetVars        pPerl->Perl_GetVars
#undef  Gv_AMupdate
#define Gv_AMupdate         pPerl->Perl_Gv_AMupdate
#undef  append_elem
#define append_elem         pPerl->Perl_append_elem
#undef  append_list
#define append_list         pPerl->Perl_append_list
#undef  apply
#define apply               pPerl->Perl_apply
#undef  assertref
#define assertref           pPerl->Perl_assertref
#undef  av_clear
#define av_clear            pPerl->Perl_av_clear
#undef  av_extend
#define av_extend           pPerl->Perl_av_extend
#undef  av_fake
#define av_fake             pPerl->Perl_av_fake
#undef  av_fetch
#define av_fetch            pPerl->Perl_av_fetch
#undef  av_fill
#define av_fill             pPerl->Perl_av_fill
#undef  av_len
#define av_len              pPerl->Perl_av_len
#undef  av_make
#define av_make             pPerl->Perl_av_make
#undef  av_pop
#define av_pop              pPerl->Perl_av_pop
#undef  av_push
#define av_push             pPerl->Perl_av_push
#undef  av_reify
#define av_reify            pPerl->Perl_av_reify
#undef  av_shift
#define av_shift            pPerl->Perl_av_shift
#undef  av_store
#define av_store            pPerl->Perl_av_store
#undef  av_undef
#define av_undef            pPerl->Perl_av_undef
#undef  av_unshift
#define av_unshift          pPerl->Perl_av_unshift
#undef  avhv_exists_ent
#define avhv_exists_ent     pPerl->Perl_avhv_exists_ent
#undef  avhv_fetch_ent
#define avhv_fetch_ent      pPerl->Perl_avhv_fetch_ent
#undef  avhv_iternext
#define avhv_iternext       pPerl->Perl_avhv_iternext
#undef  avhv_iterval
#define avhv_iterval        pPerl->Perl_avhv_iterval
#undef  avhv_keys
#define avhv_keys           pPerl->Perl_avhv_keys
#undef  bind_match
#define bind_match          pPerl->Perl_bind_match
#undef  block_end
#define block_end           pPerl->Perl_block_end
#undef  block_gimme
#define block_gimme         pPerl->Perl_block_gimme
#undef  block_start
#define block_start         pPerl->Perl_block_start
#undef  byterun
#define byterun             pPerl->Perl_byterun
#undef  call_list
#define call_list           pPerl->Perl_call_list
#undef  cando
#define cando               pPerl->Perl_cando
#undef  cast_ulong
#define cast_ulong          pPerl->Perl_cast_ulong
#undef  checkcomma
#define checkcomma          pPerl->Perl_checkcomma
#undef  check_uni
#define check_uni           pPerl->Perl_check_uni
#undef  ck_concat
#define ck_concat           pPerl->Perl_ck_concat
#undef  ck_delete
#define ck_delete           pPerl->Perl_ck_delete
#undef  ck_eof
#define ck_eof              pPerl->Perl_ck_eof
#undef  ck_eval
#define ck_eval             pPerl->Perl_ck_eval
#undef  ck_exec
#define ck_exec             pPerl->Perl_ck_exec
#undef  ck_formline
#define ck_formline         pPerl->Perl_ck_formline
#undef  ck_ftst
#define ck_ftst             pPerl->Perl_ck_ftst
#undef  ck_fun
#define ck_fun              pPerl->Perl_ck_fun
#undef  ck_glob
#define ck_glob             pPerl->Perl_ck_glob
#undef  ck_grep
#define ck_grep             pPerl->Perl_ck_grep
#undef  ck_gvconst
#define ck_gvconst          pPerl->Perl_ck_gvconst
#undef  ck_index
#define ck_index            pPerl->Perl_ck_index
#undef  ck_lengthconst
#define ck_lengthconst      pPerl->Perl_ck_lengthconst
#undef  ck_lfun
#define ck_lfun             pPerl->Perl_ck_lfun
#undef  ck_listiob
#define ck_listiob          pPerl->Perl_ck_listiob
#undef  ck_match
#define ck_match            pPerl->Perl_ck_match
#undef  ck_null
#define ck_null             pPerl->Perl_ck_null
#undef  ck_repeat
#define ck_repeat           pPerl->Perl_ck_repeat
#undef  ck_require
#define ck_require          pPerl->Perl_ck_require
#undef  ck_retarget
#define ck_retarget         pPerl->Perl_ck_retarget
#undef  ck_rfun
#define ck_rfun             pPerl->Perl_ck_rfun
#undef  ck_rvconst
#define ck_rvconst          pPerl->Perl_ck_rvconst
#undef  ck_select
#define ck_select           pPerl->Perl_ck_select
#undef  ck_shift
#define ck_shift            pPerl->Perl_ck_shift
#undef  ck_sort
#define ck_sort             pPerl->Perl_ck_sort
#undef  ck_spair
#define ck_spair            pPerl->Perl_ck_spair
#undef  ck_split
#define ck_split            pPerl->Perl_ck_split
#undef  ck_subr
#define ck_subr             pPerl->Perl_ck_subr
#undef  ck_svconst
#define ck_svconst          pPerl->Perl_ck_svconst
#undef  ck_trunc
#define ck_trunc            pPerl->Perl_ck_trunc
#undef  condpair_magic
#define condpair_magic      pPerl->Perl_condpair_magic
#undef  convert
#define convert             pPerl->Perl_convert
#undef  cpytill
#define cpytill             pPerl->Perl_cpytill
#undef  croak
#define croak               pPerl->Perl_croak
#undef  cv_ckproto
#define cv_ckproto          pPerl->Perl_cv_ckproto
#undef  cv_clone
#define cv_clone            pPerl->Perl_cv_clone
#undef  cv_const_sv
#define cv_const_sv         pPerl->Perl_cv_const_sv
#undef  cv_undef
#define cv_undef            pPerl->Perl_cv_undef
#undef  cx_dump
#define cx_dump             pPerl->Perl_cx_dump
#undef  cxinc
#define cxinc               pPerl->Perl_cxinc
#undef  deb
#define deb                 pPerl->Perl_deb
#undef  deb_growlevel
#define deb_growlevel       pPerl->Perl_deb_growlevel
#undef  debprofdump
#define debprofdump         pPerl->Perl_debprofdump
#undef  debop
#define debop               pPerl->Perl_debop
#undef  debstack
#define debstack            pPerl->Perl_debstack
#undef  debstackptrs
#define debstackptrs        pPerl->Perl_debstackptrs
#undef  delimcpy
#define delimcpy            pPerl->Perl_delimcpy
#undef  deprecate
#define deprecate           pPerl->Perl_deprecate
#undef  die
#define die                 pPerl->Perl_die
#undef  die_where
#define die_where           pPerl->Perl_die_where
#undef  dopoptoeval
#define dopoptoeval         pPerl->Perl_dopoptoeval
#undef  dounwind
#define dounwind            pPerl->Perl_dounwind
#undef  do_aexec
#define do_aexec            pPerl->Perl_do_aexec
#undef  do_binmode
#define do_binmode          pPerl->Perl_do_binmode
#undef  do_chomp
#define do_chomp            pPerl->Perl_do_chomp
#undef  do_chop
#define do_chop             pPerl->Perl_do_chop
#undef  do_close
#define do_close            pPerl->Perl_do_close
#undef  do_eof
#define do_eof              pPerl->Perl_do_eof
#undef  do_exec
#define do_exec             pPerl->Perl_do_exec
#undef  do_execfree
#define do_execfree         pPerl->Perl_do_execfree
#undef  do_join
#define do_join             pPerl->Perl_do_join
#undef  do_kv
#define do_kv               pPerl->Perl_do_kv
#undef  do_open
#define do_open             pPerl->Perl_do_open
#undef  do_pipe
#define do_pipe             pPerl->Perl_do_pipe
#undef  do_print
#define do_print            pPerl->Perl_do_print
#undef  do_readline
#define do_readline         pPerl->Perl_do_readline
#undef  do_seek
#define do_seek             pPerl->Perl_do_seek
#undef  do_sprintf
#define do_sprintf          pPerl->Perl_do_sprintf
#undef  do_sysseek
#define do_sysseek          pPerl->Perl_do_sysseek
#undef  do_tell
#define do_tell             pPerl->Perl_do_tell
#undef  do_trans
#define do_trans            pPerl->Perl_do_trans
#undef  do_vecset
#define do_vecset           pPerl->Perl_do_vecset
#undef  do_vop
#define do_vop              pPerl->Perl_do_vop
#undef  dofile
#define dofile              pPerl->Perl_dofile
#undef  dowantarray
#define dowantarray         pPerl->Perl_dowantarray
#undef  dump_all
#define dump_all            pPerl->Perl_dump_all
#undef  dump_eval
#define dump_eval           pPerl->Perl_dump_eval
#undef  dump_fds
#define dump_fds            pPerl->Perl_dump_fds
#undef  dump_form
#define dump_form           pPerl->Perl_dump_form
#undef  dump_gv
#define dump_gv             pPerl->Perl_dump_gv
#undef  dump_mstats
#define dump_mstats         pPerl->Perl_dump_mstats
#undef  dump_op
#define dump_op             pPerl->Perl_dump_op
#undef  dump_pm
#define dump_pm             pPerl->Perl_dump_pm
#undef  dump_packsubs
#define dump_packsubs       pPerl->Perl_dump_packsubs
#undef  dump_sub
#define dump_sub            pPerl->Perl_dump_sub
#undef  fbm_compile
#define fbm_compile         pPerl->Perl_fbm_compile
#undef  fbm_instr
#define fbm_instr           pPerl->Perl_fbm_instr
#undef  filter_add
#define filter_add          pPerl->Perl_filter_add
#undef  filter_del
#define filter_del          pPerl->Perl_filter_del
#undef  filter_read
#define filter_read         pPerl->Perl_filter_read
#undef  find_threadsv
#define find_threadsv       pPerl->Perl_find_threadsv
#undef  find_script
#define find_script         pPerl->Perl_find_script
#undef  force_ident
#define force_ident         pPerl->Perl_force_ident
#undef  force_list
#define force_list          pPerl->Perl_force_list
#undef  force_next
#define force_next          pPerl->Perl_force_next
#undef  force_word
#define force_word          pPerl->Perl_force_word
#undef  form
#define form                pPerl->Perl_form
#undef  fold_constants
#define fold_constants      pPerl->Perl_fold_constants
#undef  fprintf
#define fprintf             pPerl->fprintf
#undef  free_tmps
#define free_tmps           pPerl->Perl_free_tmps
#undef  gen_constant_list
#define gen_constant_list   pPerl->Perl_gen_constant_list
#undef  get_op_descs
#define get_op_descs        pPerl->Perl_get_op_descs
#undef  get_op_names
#define get_op_names        pPerl->Perl_get_op_names
#undef  get_no_modify
#define get_no_modify       pPerl->Perl_get_no_modify
#undef  get_opargs
#define get_opargs	        pPerl->Perl_get_opargs
#undef  get_specialsv_list
#define get_specialsv_list  pPerl->Perl_get_specialsv_list
#undef  get_vtbl
#define get_vtbl            pPerl->Perl_get_vtbl
#undef  gp_free
#define gp_free             pPerl->Perl_gp_free
#undef  gp_ref
#define gp_ref              pPerl->Perl_gp_ref
#undef  gv_AVadd
#define gv_AVadd            pPerl->Perl_gv_AVadd
#undef  gv_HVadd
#define gv_HVadd            pPerl->Perl_gv_HVadd
#undef  gv_IOadd
#define gv_IOadd            pPerl->Perl_gv_IOadd
#undef  gv_autoload4
#define gv_autoload4        pPerl->Perl_gv_autoload4
#undef  gv_check
#define gv_check            pPerl->Perl_gv_check
#undef  gv_efullname
#define gv_efullname        pPerl->Perl_gv_efullname
#undef  gv_efullname3
#define gv_efullname3       pPerl->Perl_gv_efullname3
#undef  gv_fetchfile
#define gv_fetchfile        pPerl->Perl_gv_fetchfile
#undef  gv_fetchmeth
#define gv_fetchmeth        pPerl->Perl_gv_fetchmeth
#undef  gv_fetchmethod
#define gv_fetchmethod      pPerl->Perl_gv_fetchmethod
#undef  gv_fetchmethod_autoload
#define gv_fetchmethod_autoload pPerl->Perl_gv_fetchmethod_autoload
#undef  gv_fetchpv
#define gv_fetchpv          pPerl->Perl_gv_fetchpv
#undef  gv_fullname
#define gv_fullname         pPerl->Perl_gv_fullname
#undef  gv_fullname3
#define gv_fullname3        pPerl->Perl_gv_fullname3
#undef  gv_init
#define gv_init             pPerl->Perl_gv_init
#undef  gv_stashpv
#define gv_stashpv          pPerl->Perl_gv_stashpv
#undef  gv_stashpvn
#define gv_stashpvn         pPerl->Perl_gv_stashpvn
#undef  gv_stashsv
#define gv_stashsv          pPerl->Perl_gv_stashsv
#undef  he_delayfree
#define he_delayfree        pPerl->Perl_he_delayfree
#undef  he_free
#define he_free             pPerl->Perl_he_free
#undef  hoistmust
#define hoistmust           pPerl->Perl_hoistmust
#undef  hv_clear
#define hv_clear            pPerl->Perl_hv_clear
#undef  hv_delayfree_ent
#define hv_delayfree_ent    pPerl->Perl_hv_delayfree_ent
#undef  hv_delete
#define hv_delete           pPerl->Perl_hv_delete
#undef  hv_delete_ent
#define hv_delete_ent       pPerl->Perl_hv_delete_ent
#undef  hv_exists
#define hv_exists           pPerl->Perl_hv_exists
#undef  hv_exists_ent
#define hv_exists_ent       pPerl->Perl_hv_exists_ent
#undef  hv_fetch
#define hv_fetch            pPerl->Perl_hv_fetch
#undef  hv_fetch_ent
#define hv_fetch_ent        pPerl->Perl_hv_fetch_ent
#undef  hv_free_ent
#define hv_free_ent         pPerl->Perl_hv_free_ent
#undef  hv_iterinit
#define hv_iterinit         pPerl->Perl_hv_iterinit
#undef  hv_iterkey
#define hv_iterkey          pPerl->Perl_hv_iterkey
#undef  hv_iterkeysv
#define hv_iterkeysv        pPerl->Perl_hv_iterkeysv
#undef  hv_iternext
#define hv_iternext         pPerl->Perl_hv_iternext
#undef  hv_iternextsv
#define hv_iternextsv       pPerl->Perl_hv_iternextsv
#undef  hv_iterval
#define hv_iterval          pPerl->Perl_hv_iterval
#undef  hv_ksplit
#define hv_ksplit           pPerl->Perl_hv_ksplit
#undef  hv_magic
#define hv_magic            pPerl->Perl_hv_magic
#undef  hv_store
#define hv_store            pPerl->Perl_hv_store
#undef  hv_store_ent
#define hv_store_ent        pPerl->Perl_hv_store_ent
#undef  hv_undef
#define hv_undef            pPerl->Perl_hv_undef
#undef  ibcmp
#define ibcmp               pPerl->Perl_ibcmp
#undef  ibcmp_locale
#define ibcmp_locale        pPerl->Perl_ibcmp_locale
#undef  incpush
#define incpush             pPerl->incpush
#undef  incline
#define incline             pPerl->incline
#undef  incl_perldb
#define incl_perldb         pPerl->incl_perldb
#undef  ingroup
#define ingroup             pPerl->Perl_ingroup
#undef  init_stacks
#define init_stacks         pPerl->Perl_init_stacks
#undef  instr
#define instr               pPerl->Perl_instr
#undef  intro_my
#define intro_my            pPerl->Perl_intro_my
#undef  intuit_method
#define intuit_method       pPerl->intuit_method
#undef  intuit_more
#define intuit_more         pPerl->Perl_intuit_more
#undef  invert
#define invert              pPerl->Perl_invert
#undef  io_close
#define io_close            pPerl->Perl_io_close
#undef  ioctl
#define ioctl               pPerl->ioctl
#undef  jmaybe
#define jmaybe              pPerl->Perl_jmaybe
#undef  keyword
#define keyword             pPerl->Perl_keyword
#undef  leave_scope
#define leave_scope         pPerl->Perl_leave_scope
#undef  lex_end
#define lex_end             pPerl->Perl_lex_end
#undef  lex_start
#define lex_start           pPerl->Perl_lex_start
#undef  linklist
#define linklist            pPerl->Perl_linklist
#undef  list
#define list                pPerl->Perl_list
#undef  listkids
#define listkids            pPerl->Perl_listkids
#undef  lop
#define lop                 pPerl->lop
#undef  localize
#define localize            pPerl->Perl_localize
#undef  looks_like_number
#define looks_like_number   pPerl->Perl_looks_like_number
#undef  magic_clear_all_env
#define magic_clear_all_env pPerl->Perl_magic_clear_all_env
#undef  magic_clearenv
#define magic_clearenv      pPerl->Perl_magic_clearenv
#undef  magic_clearpack
#define magic_clearpack     pPerl->Perl_magic_clearpack
#undef  magic_clearsig
#define magic_clearsig      pPerl->Perl_magic_clearsig
#undef  magic_existspack
#define magic_existspack    pPerl->Perl_magic_existspack
#undef  magic_freeregexp
#define magic_freeregexp    pPerl->Perl_magic_freeregexp
#undef  magic_get
#define magic_get           pPerl->Perl_magic_get
#undef  magic_getarylen
#define magic_getarylen     pPerl->Perl_magic_getarylen
#undef  magic_getdefelem
#define magic_getdefelem    pPerl->Perl_magic_getdefelem
#undef  magic_getpack
#define magic_getpack       pPerl->Perl_magic_getpack
#undef  magic_getglob
#define magic_getglob       pPerl->Perl_magic_getglob
#undef  magic_getnkeys
#define magic_getnkeys      pPerl->Perl_magic_getnkeys
#undef  magic_getpos
#define magic_getpos        pPerl->Perl_magic_getpos
#undef  magic_getsig
#define magic_getsig        pPerl->Perl_magic_getsig
#undef  magic_getsubstr
#define magic_getsubstr     pPerl->Perl_magic_getsubstr
#undef  magic_gettaint
#define magic_gettaint      pPerl->Perl_magic_gettaint
#undef  magic_getuvar
#define magic_getuvar       pPerl->Perl_magic_getuvar
#undef  magic_getvec
#define magic_getvec        pPerl->Perl_magic_getvec
#undef  magic_len
#define magic_len           pPerl->Perl_magic_len
#undef  magic_methpack
#define magic_methpack      pPerl->magic_methpack
#undef  magic_mutexfree
#define magic_mutexfree     pPerl->Perl_magic_mutexfree
#undef  magic_nextpack
#define magic_nextpack      pPerl->Perl_magic_nextpack
#undef  magic_set
#define magic_set           pPerl->Perl_magic_set
#undef  magic_set_all_env
#define magic_set_all_env   pPerl->Perl_magic_set_all_env
#undef  magic_setamagic
#define magic_setamagic     pPerl->Perl_magic_setamagic
#undef  magic_setarylen
#define magic_setarylen     pPerl->Perl_magic_setarylen
#undef  magic_setbm
#define magic_setbm         pPerl->Perl_magic_setbm
#undef  magic_setcollxfrm
#define magic_setcollxfrm   pPerl->Perl_magic_setcollxfrm
#undef  magic_setdbline
#define magic_setdbline     pPerl->Perl_magic_setdbline
#undef  magic_setdefelem
#define magic_setdefelem    pPerl->Perl_magic_setdefelem
#undef  magic_setenv
#define magic_setenv        pPerl->Perl_magic_setenv
#undef  magic_setfm
#define magic_setfm         pPerl->Perl_magic_setfm
#undef  magic_setisa
#define magic_setisa        pPerl->Perl_magic_setisa
#undef  magic_setglob
#define magic_setglob       pPerl->Perl_magic_setglob
#undef  magic_setmglob
#define magic_setmglob      pPerl->Perl_magic_setmglob
#undef  magic_setnkeys
#define magic_setnkeys      pPerl->Perl_magic_setnkeys
#undef  magic_setpack
#define magic_setpack       pPerl->Perl_magic_setpack
#undef  magic_setpos
#define magic_setpos        pPerl->Perl_magic_setpos
#undef  magic_setsig
#define magic_setsig        pPerl->Perl_magic_setsig
#undef  magic_setsubstr
#define magic_setsubstr     pPerl->Perl_magic_setsubstr
#undef  magic_settaint
#define magic_settaint      pPerl->Perl_magic_settaint
#undef  magic_setuvar
#define magic_setuvar       pPerl->Perl_magic_setuvar
#undef  magic_setvec
#define magic_setvec        pPerl->Perl_magic_setvec
#undef  magic_sizepack
#define magic_sizepack      pPerl->Perl_magic_sizepack
#undef  magic_unchain
#define magic_unchain       pPerl->Perl_magic_unchain
#undef  magic_wipepack
#define magic_wipepack      pPerl->Perl_magic_wipepack
#undef  magicname
#define magicname           pPerl->Perl_magicname
#undef  malloced_size
#define malloced_size       pPerl->Perl_malloced_size
#undef  markstack_grow
#define markstack_grow      pPerl->Perl_markstack_grow
#undef  mem_collxfrm
#define mem_collxfrm        pPerl->Perl_mem_collxfrm
#undef  mess
#define mess                pPerl->Perl_mess
#undef  mg_clear
#define mg_clear            pPerl->Perl_mg_clear
#undef  mg_copy
#define mg_copy             pPerl->Perl_mg_copy
#undef  mg_find
#define mg_find             pPerl->Perl_mg_find
#undef  mg_free
#define mg_free             pPerl->Perl_mg_free
#undef  mg_get
#define mg_get              pPerl->Perl_mg_get
#undef  mg_magical
#define mg_magical          pPerl->Perl_mg_magical
#undef  mg_length
#define mg_length           pPerl->Perl_mg_length
#undef  mg_set
#define mg_set              pPerl->Perl_mg_set
#undef  mg_size
#define mg_size             pPerl->Perl_mg_size
#undef  missingterm
#define missingterm         pPerl->missingterm
#undef  mod
#define mod                 pPerl->Perl_mod
#undef  modkids
#define modkids             pPerl->Perl_modkids
#undef  moreswitches
#define moreswitches        pPerl->Perl_moreswitches
#undef  more_sv
#define more_sv             pPerl->more_sv
#undef  more_xiv
#define more_xiv            pPerl->more_xiv
#undef  more_xnv
#define more_xnv            pPerl->more_xnv
#undef  more_xpv
#define more_xpv            pPerl->more_xpv
#undef  more_xrv
#define more_xrv            pPerl->more_xrv
#undef  my
#define my                  pPerl->Perl_my
#undef  my_bcopy
#define my_bcopy            pPerl->Perl_my_bcopy
#undef  my_bzero
#define my_bzero            pPerl->Perl_my_bzero
#undef  my_chsize
#define my_chsize           pPerl->Perl_my_chsize
#undef  my_exit
#define my_exit             pPerl->Perl_my_exit
#undef  my_failure_exit
#define my_failure_exit     pPerl->Perl_my_failure_exit
#undef  my_htonl
#define my_htonl            pPerl->Perl_my_htonl
#undef  my_lstat
#define my_lstat            pPerl->Perl_my_lstat
#undef  my_memcmp
#define my_memcmp           pPerl->my_memcmp
#undef  my_ntohl
#define my_ntohl            pPerl->Perl_my_ntohl
#undef  my_pclose
#define my_pclose           pPerl->Perl_my_pclose
#undef  my_popen
#define my_popen            pPerl->Perl_my_popen
#undef  my_setenv
#define my_setenv           pPerl->Perl_my_setenv
#undef  my_stat
#define my_stat             pPerl->Perl_my_stat
#undef  my_swap
#define my_swap             pPerl->Perl_my_swap
#undef  my_unexec
#define my_unexec           pPerl->Perl_my_unexec
#undef  newANONLIST
#define newANONLIST         pPerl->Perl_newANONLIST
#undef  newANONHASH
#define newANONHASH         pPerl->Perl_newANONHASH
#undef  newANONSUB
#define newANONSUB          pPerl->Perl_newANONSUB
#undef  newASSIGNOP
#define newASSIGNOP         pPerl->Perl_newASSIGNOP
#undef  newCONDOP
#define newCONDOP           pPerl->Perl_newCONDOP
#undef  newCONSTSUB
#define newCONSTSUB         pPerl->Perl_newCONSTSUB
#undef  newFORM
#define newFORM             pPerl->Perl_newFORM
#undef  newFOROP
#define newFOROP            pPerl->Perl_newFOROP
#undef  newLOGOP
#define newLOGOP            pPerl->Perl_newLOGOP
#undef  newLOOPEX
#define newLOOPEX           pPerl->Perl_newLOOPEX
#undef  newLOOPOP
#define newLOOPOP           pPerl->Perl_newLOOPOP
#undef  newMETHOD
#define newMETHOD           pPerl->Perl_newMETHOD
#undef  newNULLLIST
#define newNULLLIST         pPerl->Perl_newNULLLIST
#undef  newOP
#define newOP               pPerl->Perl_newOP
#undef  newPROG
#define newPROG             pPerl->Perl_newPROG
#undef  newRANGE
#define newRANGE            pPerl->Perl_newRANGE
#undef  newSLICEOP
#define newSLICEOP          pPerl->Perl_newSLICEOP
#undef  newSTATEOP
#define newSTATEOP          pPerl->Perl_newSTATEOP
#undef  newSUB
#define newSUB              pPerl->Perl_newSUB
#undef  newXS
#define newXS               pPerl->Perl_newXS
#undef  newAV
#define newAV               pPerl->Perl_newAV
#undef  newAVREF
#define newAVREF            pPerl->Perl_newAVREF
#undef  newBINOP
#define newBINOP            pPerl->Perl_newBINOP
#undef  newCVREF
#define newCVREF            pPerl->Perl_newCVREF
#undef  newCVOP
#define newCVOP             pPerl->Perl_newCVOP
#undef  newGVOP
#define newGVOP             pPerl->Perl_newGVOP
#undef  newGVgen
#define newGVgen            pPerl->Perl_newGVgen
#undef  newGVREF
#define newGVREF            pPerl->Perl_newGVREF
#undef  newHVREF
#define newHVREF            pPerl->Perl_newHVREF
#undef  newHV
#define newHV               pPerl->Perl_newHV
#undef  newHVhv
#define newHVhv             pPerl->Perl_newHVhv
#undef  newIO
#define newIO               pPerl->Perl_newIO
#undef  newLISTOP
#define newLISTOP           pPerl->Perl_newLISTOP
#undef  newPMOP
#define newPMOP             pPerl->Perl_newPMOP
#undef  newPVOP
#define newPVOP             pPerl->Perl_newPVOP
#undef  newRV
#define newRV               pPerl->Perl_newRV
#undef  newRV_noinc
#undef  Perl_newRV_noinc
#define newRV_noinc         pPerl->Perl_newRV_noinc
#undef  newSV
#define newSV               pPerl->Perl_newSV
#undef  newSVREF
#define newSVREF            pPerl->Perl_newSVREF
#undef  newSVOP
#define newSVOP             pPerl->Perl_newSVOP
#undef  newSViv
#define newSViv             pPerl->Perl_newSViv
#undef  newSVnv
#define newSVnv             pPerl->Perl_newSVnv
#undef  newSVpv
#define newSVpv             pPerl->Perl_newSVpv
#undef  newSVpvf
#define newSVpvf            pPerl->Perl_newSVpvf
#undef  newSVpvn
#define newSVpvn            pPerl->Perl_newSVpvn
#undef  newSVrv
#define newSVrv             pPerl->Perl_newSVrv
#undef  newSVsv
#define newSVsv             pPerl->Perl_newSVsv
#undef  newUNOP
#define newUNOP             pPerl->Perl_newUNOP
#undef  newWHILEOP
#define newWHILEOP          pPerl->Perl_newWHILEOP
#undef  new_struct_thread
#define new_struct_thread   pPerl->Perl_new_struct_thread
#undef  new_stackinfo
#define new_stackinfo       pPerl->Perl_new_stackinfo
#undef  new_sv
#define new_sv              pPerl->new_sv
#undef  new_xnv
#define new_xnv             pPerl->new_xnv
#undef  new_xpv
#define new_xpv             pPerl->new_xpv
#undef  nextargv
#define nextargv            pPerl->Perl_nextargv
#undef  nextchar
#define nextchar            pPerl->nextchar
#undef  ninstr
#define ninstr              pPerl->Perl_ninstr
#undef  no_bareword_allowed
#define no_bareword_allowed       pPerl->Perl_no_bareword_allowed
#undef  no_fh_allowed
#define no_fh_allowed       pPerl->Perl_no_fh_allowed
#undef  no_op
#define no_op               pPerl->Perl_no_op
#undef  package
#define package             pPerl->Perl_package
#undef  pad_alloc
#define pad_alloc           pPerl->Perl_pad_alloc
#undef  pad_allocmy
#define pad_allocmy         pPerl->Perl_pad_allocmy
#undef  pad_findmy
#define pad_findmy          pPerl->Perl_pad_findmy
#undef  op_const_sv
#define op_const_sv         pPerl->Perl_op_const_sv
#undef  op_free
#define op_free             pPerl->Perl_op_free
#undef  oopsCV
#define oopsCV              pPerl->Perl_oopsCV
#undef  oopsAV
#define oopsAV              pPerl->Perl_oopsAV
#undef  oopsHV
#define oopsHV              pPerl->Perl_oopsHV
#undef  opendir
#define opendir             pPerl->opendir
#undef  pad_leavemy
#define pad_leavemy         pPerl->Perl_pad_leavemy
#undef  pad_sv
#define pad_sv              pPerl->Perl_pad_sv
#undef  pad_findlex
#define pad_findlex         pPerl->pad_findlex
#undef  pad_free
#define pad_free            pPerl->Perl_pad_free
#undef  pad_reset
#define pad_reset           pPerl->Perl_pad_reset
#undef  pad_swipe
#define pad_swipe           pPerl->Perl_pad_swipe
#undef  peep
#define peep                pPerl->Perl_peep
#undef  perl_atexit
#define perl_atexit         pPerl->perl_atexit
#undef  perl_call_argv
#define perl_call_argv      pPerl->perl_call_argv
#undef  perl_call_method
#define perl_call_method    pPerl->perl_call_method
#undef  perl_call_pv
#define perl_call_pv        pPerl->perl_call_pv
#undef  perl_call_sv
#define perl_call_sv        pPerl->perl_call_sv
#undef  perl_callargv
#define perl_callargv       pPerl->perl_callargv
#undef  perl_callpv
#define perl_callpv         pPerl->perl_callpv
#undef  perl_callsv
#define perl_callsv         pPerl->perl_callsv
#undef  perl_eval_pv
#define perl_eval_pv        pPerl->perl_eval_pv
#undef  perl_eval_sv
#define perl_eval_sv        pPerl->perl_eval_sv
#undef  perl_get_sv
#define perl_get_sv         pPerl->perl_get_sv
#undef  perl_get_av
#define perl_get_av         pPerl->perl_get_av
#undef  perl_get_hv
#define perl_get_hv         pPerl->perl_get_hv
#undef  perl_get_cv
#define perl_get_cv         pPerl->perl_get_cv
#undef  perl_init_i18nl10n
#define perl_init_i18nl10n  pPerl->perl_init_i18nl10n
#undef  perl_init_i18nl14n
#define perl_init_i18nl14n  pPerl->perl_init_i18nl14n
#undef  perl_new_collate
#define perl_new_collate    pPerl->perl_new_collate
#undef  perl_new_ctype
#define perl_new_ctype      pPerl->perl_new_ctype
#undef  perl_new_numeric
#define perl_new_numeric    pPerl->perl_new_numeric
#undef  perl_set_numeric_local
#define perl_set_numeric_local pPerl->perl_set_numeric_local
#undef  perl_set_numeric_standard
#define perl_set_numeric_standard pPerl->perl_set_numeric_standard
#undef  perl_require_pv
#define perl_require_pv     pPerl->perl_require_pv
#undef  pidgone
#define pidgone             pPerl->Perl_pidgone
#undef  pmflag
#define pmflag              pPerl->Perl_pmflag
#undef  pmruntime
#define pmruntime           pPerl->Perl_pmruntime
#undef  pmtrans
#define pmtrans             pPerl->Perl_pmtrans
#undef  pop_return
#define pop_return          pPerl->Perl_pop_return
#undef  pop_scope
#define pop_scope           pPerl->Perl_pop_scope
#undef  prepend_elem
#define prepend_elem        pPerl->Perl_prepend_elem
#undef  push_return
#define push_return         pPerl->Perl_push_return
#undef  push_scope
#define push_scope          pPerl->Perl_push_scope
#undef  pregcomp
#define pregcomp            pPerl->Perl_pregcomp
#undef  ref
#define ref                 pPerl->Perl_ref
#undef  refkids
#define refkids             pPerl->Perl_refkids
#undef  regexec_flags
#define regexec_flags       pPerl->Perl_regexec_flags
#undef  pregexec
#define pregexec            pPerl->Perl_pregexec
#undef  pregfree
#define pregfree            pPerl->Perl_pregfree
#undef  regdump
#define regdump             pPerl->Perl_regdump
#undef  regnext
#define regnext             pPerl->Perl_regnext
#undef  regnoderegnext
#define regnoderegnext      pPerl->regnoderegnext
#undef  regprop
#define regprop             pPerl->Perl_regprop
#undef  repeatcpy
#define repeatcpy           pPerl->Perl_repeatcpy
#undef  rninstr
#define rninstr             pPerl->Perl_rninstr
#undef  rsignal
#define rsignal             pPerl->Perl_rsignal
#undef  rsignal_restore
#define rsignal_restore     pPerl->Perl_rsignal_restore
#undef  rsignal_save
#define rsignal_save        pPerl->Perl_rsignal_save
#undef  rsignal_state
#define rsignal_state       pPerl->Perl_rsignal_state
#undef  run
#define run                 pPerl->Perl_run
#undef  rxres_free
#define rxres_free          pPerl->Perl_rxres_free
#undef  rxres_restore
#define rxres_restore       pPerl->Perl_rxres_restore
#undef  rxres_save
#define rxres_save          pPerl->Perl_rxres_save
#undef  safefree
#define safefree            pPerl->Perl_safefree
#undef  safecalloc
#define safecalloc          pPerl->Perl_safecalloc
#undef  safemalloc
#define safemalloc          pPerl->Perl_safemalloc
#undef  saferealloc
#define saferealloc         pPerl->Perl_saferealloc
#undef  safexcalloc
#define safexcalloc         pPerl->Perl_safexcalloc
#undef  safexfree
#define safexfree           pPerl->Perl_safexfree
#undef  safexmalloc
#define safexmalloc         pPerl->Perl_safexmalloc
#undef  safexrealloc
#define safexrealloc        pPerl->Perl_safexrealloc
#undef  same_dirent
#define same_dirent         pPerl->Perl_same_dirent
#undef  savepv
#define savepv              pPerl->Perl_savepv
#undef  savepvn
#define savepvn             pPerl->Perl_savepvn
#undef  savestack_grow
#define savestack_grow      pPerl->Perl_savestack_grow
#undef  save_aelem
#define save_aelem          pPerl->Perl_save_aelem
#undef  save_aptr
#define save_aptr           pPerl->Perl_save_aptr
#undef  save_ary
#define save_ary            pPerl->Perl_save_ary
#undef  save_clearsv
#define save_clearsv        pPerl->Perl_save_clearsv
#undef  save_delete
#define save_delete         pPerl->Perl_save_delete
#undef  save_destructor
#define save_destructor     pPerl->Perl_save_destructor
#undef  save_freesv
#define save_freesv         pPerl->Perl_save_freesv
#undef  save_freeop
#define save_freeop         pPerl->Perl_save_freeop
#undef  save_freepv
#define save_freepv         pPerl->Perl_save_freepv
#undef  save_generic_svref
#define save_generic_svref  pPerl->Perl_generic_save_svref
#undef  save_gp
#define save_gp             pPerl->Perl_save_gp
#undef  save_hash
#define save_hash           pPerl->Perl_save_hash
#undef  save_helem
#define save_helem          pPerl->Perl_save_helem
#undef  save_hints
#define save_hints          pPerl->Perl_save_hints
#undef  save_hptr
#define save_hptr           pPerl->Perl_save_hptr
#undef  save_I16
#define save_I16            pPerl->Perl_save_I16
#undef  save_I32
#define save_I32            pPerl->Perl_save_I32
#undef  save_int
#define save_int            pPerl->Perl_save_int
#undef  save_item
#define save_item           pPerl->Perl_save_item
#undef  save_iv
#define save_iv             pPerl->Perl_save_iv
#undef  save_list
#define save_list           pPerl->Perl_save_list
#undef  save_long
#define save_long           pPerl->Perl_save_long
#undef  save_nogv
#define save_nogv           pPerl->Perl_save_nogv
#undef  save_op
#define save_op             pPerl->Perl_save_op
#undef  save_scalar
#define save_scalar         pPerl->Perl_save_scalar
#undef  save_pptr
#define save_pptr           pPerl->Perl_save_pptr
#undef  save_sptr
#define save_sptr           pPerl->Perl_save_sptr
#undef  save_svref
#define save_svref          pPerl->Perl_save_svref
#undef  save_threadsv
#define save_threadsv       pPerl->Perl_save_threadsv
#undef  sawparens
#define sawparens           pPerl->Perl_sawparens
#undef  scalar
#define scalar              pPerl->Perl_scalar
#undef  scalarkids
#define scalarkids          pPerl->Perl_scalarkids
#undef  scalarseq
#define scalarseq           pPerl->Perl_scalarseq
#undef  scalarvoid
#define scalarvoid          pPerl->Perl_scalarvoid
#undef  scan_const
#define scan_const          pPerl->Perl_scan_const
#undef  scan_formline
#define scan_formline       pPerl->Perl_scan_formline
#undef  scan_ident
#define scan_ident          pPerl->Perl_scan_ident
#undef  scan_inputsymbol
#define scan_inputsymbol    pPerl->Perl_scan_inputsymbol
#undef  scan_heredoc
#define scan_heredoc        pPerl->Perl_scan_heredoc
#undef  scan_hex
#define scan_hex            pPerl->Perl_scan_hex
#undef  scan_num
#define scan_num            pPerl->Perl_scan_num
#undef  scan_oct
#define scan_oct            pPerl->Perl_scan_oct
#undef  scan_pat
#define scan_pat            pPerl->Perl_scan_pat
#undef  scan_str
#define scan_str            pPerl->Perl_scan_str
#undef  scan_subst
#define scan_subst          pPerl->Perl_scan_subst
#undef  scan_trans
#define scan_trans          pPerl->Perl_scan_trans
#undef  scope
#define scope               pPerl->Perl_scope
#undef  screaminstr
#define screaminstr         pPerl->Perl_screaminstr
#undef  setdefout
#define setdefout           pPerl->Perl_setdefout
#undef  setenv_getix
#define setenv_getix        pPerl->Perl_setenv_getix
#undef  share_hek
#define share_hek           pPerl->Perl_share_hek
#undef  sharepvn
#define sharepvn            pPerl->Perl_sharepvn
#undef  sighandler
#define sighandler          pPerl->Perl_sighandler
#undef  skipspace
#define skipspace           pPerl->Perl_skipspace
#undef  stack_grow
#define stack_grow          pPerl->Perl_stack_grow
#undef  start_subparse
#define start_subparse      pPerl->Perl_start_subparse
#undef  sub_crush_depth
#define sub_crush_depth     pPerl->Perl_sub_crush_depth
#undef  sublex_done
#define sublex_done         pPerl->Perl_sublex_done
#undef  sublex_start
#define sublex_start        pPerl->Perl_sublex_start
#undef  sv_2bool
#define sv_2bool	    pPerl->Perl_sv_2bool
#undef  sv_2cv
#define sv_2cv		    pPerl->Perl_sv_2cv
#undef  sv_2io
#define sv_2io		    pPerl->Perl_sv_2io
#undef  sv_2iv
#define sv_2iv		    pPerl->Perl_sv_2iv
#undef  sv_2mortal
#define sv_2mortal	    pPerl->Perl_sv_2mortal
#undef  sv_2nv
#define sv_2nv		    pPerl->Perl_sv_2nv
#undef  sv_2pv
#define sv_2pv		    pPerl->Perl_sv_2pv
#undef  sv_2uv
#define sv_2uv		    pPerl->Perl_sv_2uv
#undef  sv_add_arena
#define sv_add_arena	    pPerl->Perl_sv_add_arena
#undef  sv_backoff
#define sv_backoff	    pPerl->Perl_sv_backoff
#undef  sv_bless
#define sv_bless	    pPerl->Perl_sv_bless
#undef  sv_catpv
#define sv_catpv	    pPerl->Perl_sv_catpv
#undef  sv_catpvf
#define sv_catpvf	    pPerl->Perl_sv_catpvf
#undef  sv_catpvn
#define sv_catpvn	    pPerl->Perl_sv_catpvn
#undef  sv_catsv
#define sv_catsv	    pPerl->Perl_sv_catsv
#undef  sv_chop
#define sv_chop		    pPerl->Perl_sv_chop
#undef  sv_clean_all
#define sv_clean_all	    pPerl->Perl_sv_clean_all
#undef  sv_clean_objs
#define sv_clean_objs	    pPerl->Perl_sv_clean_objs
#undef  sv_clear
#define sv_clear	    pPerl->Perl_sv_clear
#undef  sv_cmp
#define sv_cmp		    pPerl->Perl_sv_cmp
#undef  sv_cmp_locale
#define sv_cmp_locale	    pPerl->Perl_sv_cmp_locale
#undef  sv_collxfrm
#define sv_collxfrm	    pPerl->Perl_sv_collxfrm
#undef  sv_compile_2op
#define sv_compile_2op	    pPerl->Perl_sv_compile_2op
#undef  sv_dec
#define sv_dec		    pPerl->Perl_sv_dec
#undef  sv_derived_from
#define sv_derived_from	    pPerl->Perl_sv_derived_from
#undef  sv_dump
#define sv_dump		    pPerl->Perl_sv_dump
#undef  sv_eq
#define sv_eq		    pPerl->Perl_sv_eq
#undef  sv_free
#define sv_free		    pPerl->Perl_sv_free
#undef  sv_free_arenas
#define sv_free_arenas	    pPerl->Perl_sv_free_arenas
#undef  sv_gets
#define sv_gets		    pPerl->Perl_sv_gets
#undef  sv_grow
#define sv_grow		    pPerl->Perl_sv_grow
#undef  sv_inc
#define sv_inc		    pPerl->Perl_sv_inc
#undef  sv_insert
#define sv_insert	    pPerl->Perl_sv_insert
#undef  sv_isa
#define sv_isa		    pPerl->Perl_sv_isa
#undef  sv_isobject
#define sv_isobject	    pPerl->Perl_sv_isobject
#undef  sv_iv
#define sv_iv		    pPerl->Perl_sv_iv
#undef  sv_len
#define sv_len		    pPerl->Perl_sv_len
#undef  sv_magic
#define sv_magic	    pPerl->Perl_sv_magic
#undef  sv_mortalcopy
#define sv_mortalcopy	    pPerl->Perl_sv_mortalcopy
#undef  sv_newmortal
#define sv_newmortal	    pPerl->Perl_sv_newmortal
#undef  sv_newref
#define sv_newref	    pPerl->Perl_sv_newref
#undef  sv_nv
#define sv_nv		    pPerl->Perl_sv_nv
#undef  sv_peek
#define sv_peek		    pPerl->Perl_sv_peek
#undef  sv_pvn
#define sv_pvn		    pPerl->Perl_sv_pvn
#undef  sv_pvn_force
#define sv_pvn_force	    pPerl->Perl_sv_pvn_force
#undef  sv_reftype
#define sv_reftype	    pPerl->Perl_sv_reftype
#undef  sv_replace
#define sv_replace	    pPerl->Perl_sv_replace
#undef  sv_report_used
#define sv_report_used	    pPerl->Perl_sv_report_used
#undef  sv_reset
#define sv_reset	    pPerl->Perl_sv_reset
#undef  sv_setiv
#define sv_setiv	    pPerl->Perl_sv_setiv
#undef  sv_setnv
#define sv_setnv	    pPerl->Perl_sv_setnv
#undef  sv_setpv
#define sv_setpv	    pPerl->Perl_sv_setpv
#undef  sv_setpvf
#define sv_setpvf	    pPerl->Perl_sv_setpvf
#undef  sv_setpviv
#define sv_setpviv	    pPerl->Perl_sv_setpviv
#undef  sv_setpvn
#define sv_setpvn	    pPerl->Perl_sv_setpvn
#undef  sv_setref_iv
#define sv_setref_iv	    pPerl->Perl_sv_setref_iv
#undef  sv_setref_nv
#define sv_setref_nv	    pPerl->Perl_sv_setref_nv
#undef  sv_setref_pv
#define sv_setref_pv	    pPerl->Perl_sv_setref_pv
#undef  sv_setref_pvn
#define sv_setref_pvn	    pPerl->Perl_sv_setref_pvn
#undef  sv_setsv
#define sv_setsv	    pPerl->Perl_sv_setsv
#undef  sv_setuv
#define sv_setuv	    pPerl->Perl_sv_setuv
#undef  sv_taint
#define sv_taint	    pPerl->Perl_sv_taint
#undef  sv_tainted
#define sv_tainted	    pPerl->Perl_sv_tainted
#undef  sv_true
#define sv_true		    pPerl->Perl_sv_true
#undef  sv_unmagic
#define sv_unmagic	    pPerl->Perl_sv_unmagic
#undef  sv_unref
#define sv_unref	    pPerl->Perl_sv_unref
#undef  sv_untaint
#define sv_untaint	    pPerl->Perl_sv_untaint
#undef  sv_upgrade
#define sv_upgrade	    pPerl->Perl_sv_upgrade
#undef  sv_usepvn
#define sv_usepvn	    pPerl->Perl_sv_usepvn
#undef  sv_uv
#define sv_uv		    pPerl->Perl_sv_uv
#undef  sv_vcatpvfn
#define sv_vcatpvfn	    pPerl->Perl_sv_vcatpvfn
#undef  sv_vsetpvfn
#define sv_vsetpvfn	    pPerl->Perl_sv_vsetpvfn
#undef  taint_env
#define taint_env	    pPerl->Perl_taint_env
#undef  taint_not
#define taint_not	    pPerl->Perl_taint_not
#undef  taint_proper
#define taint_proper	    pPerl->Perl_taint_proper
#undef  too_few_arguments
#define too_few_arguments   pPerl->Perl_too_few_arguments
#undef  too_many_arguments
#define too_many_arguments  pPerl->Perl_too_many_arguments
#undef  unlnk
#define unlnk               pPerl->Perl_unlnk
#undef  unlock_condpair
#define unlock_condpair     pPerl->Perl_unlock_condpair
#undef  unshare_hek
#define unshare_hek         pPerl->Perl_unshare_hek
#undef  unsharepvn
#define unsharepvn          pPerl->Perl_unsharepvn
#undef  utilize
#define utilize             pPerl->Perl_utilize
#undef  vivify_defelem
#define vivify_defelem      pPerl->Perl_vivify_defelem
#undef  vivify_ref
#define vivify_ref          pPerl->Perl_vivify_ref
#undef  wait4pid
#define wait4pid            pPerl->Perl_wait4pid
#undef  warn
#define warn    	    pPerl->Perl_warn
#undef  watch
#define watch    	    pPerl->Perl_watch
#undef  whichsig
#define whichsig            pPerl->Perl_whichsig
#undef  yyerror
#define yyerror             pPerl->Perl_yyerror
#undef  yylex
#define yylex               pPerl->Perl_yylex
#undef  yyparse
#define yyparse             pPerl->Perl_yyparse
#undef  yywarn
#define yywarn              pPerl->Perl_yywarn


#undef  PL_piMem
#define PL_piMem               (pPerl->PL_piMem)
#undef  PL_piENV
#define PL_piENV               (pPerl->PL_piENV)
#undef  PL_piStdIO
#define PL_piStdIO             (pPerl->PL_piStdIO)
#undef  PL_piLIO
#define PL_piLIO               (pPerl->PL_piLIO)
#undef  PL_piDir
#define PL_piDir               (pPerl->PL_piDir)
#undef  PL_piSock
#define PL_piSock              (pPerl->PL_piSock)
#undef  PL_piProc
#define PL_piProc              (pPerl->PL_piProc)

#ifndef NO_XSLOCKS
#undef closedir
#undef opendir
#undef stdin
#undef stdout
#undef stderr
#undef feof
#undef ferror
#undef fgetpos
#undef ioctl
#undef getlogin
#undef setjmp
#undef getc
#undef ungetc
#undef fileno

#define mkdir PerlDir_mkdir
#define chdir PerlDir_chdir
#define rmdir PerlDir_rmdir
#define closedir PerlDir_close
#define opendir PerlDir_open
#define readdir PerlDir_read
#define rewinddir PerlDir_rewind
#define seekdir PerlDir_seek
#define telldir PerlDir_tell
#define putenv PerlEnv_putenv
#define getenv PerlEnv_getenv
#define uname	PerlEnv_uname
#define stdin PerlIO_stdin()
#define stdout PerlIO_stdout()
#define stderr PerlIO_stderr()
#define fopen PerlIO_open
#define fclose PerlIO_close
#define feof PerlIO_eof
#define ferror PerlIO_error
#define fclearerr PerlIO_clearerr
#define getc PerlIO_getc
#define fputc(c, f) PerlIO_putc(f,c)
#define fputs(s, f) PerlIO_puts(f,s)
#define fflush PerlIO_flush
#define ungetc(c, f) PerlIO_ungetc((f),(c))
#define fileno PerlIO_fileno
#define fdopen PerlIO_fdopen
#define freopen PerlIO_reopen
#define fread(b,s,c,f) PerlIO_read((f),(b),(s*c))
#define fwrite(b,s,c,f) PerlIO_write((f),(b),(s*c))
#define setbuf PerlIO_setbuf
#define setvbuf PerlIO_setvbuf
#define setlinebuf PerlIO_setlinebuf
#define stdoutf PerlIO_stdoutf
#define vfprintf PerlIO_vprintf
#define ftell PerlIO_tell
#define fseek PerlIO_seek
#define fgetpos PerlIO_getpos
#define fsetpos PerlIO_setpos
#define frewind PerlIO_rewind
#define tmpfile PerlIO_tmpfile
#define access PerlLIO_access
#define chmod PerlLIO_chmod
#define chsize PerlLIO_chsize
#define close PerlLIO_close
#define dup PerlLIO_dup
#define dup2 PerlLIO_dup2
#define flock PerlLIO_flock
#define fstat PerlLIO_fstat
#define ioctl PerlLIO_ioctl
#define isatty PerlLIO_isatty
#define lseek PerlLIO_lseek
#define lstat PerlLIO_lstat
#define mktemp PerlLIO_mktemp
#define open PerlLIO_open
#define read PerlLIO_read
#define rename PerlLIO_rename
#define setmode PerlLIO_setmode
#define stat PerlLIO_stat
#define tmpnam PerlLIO_tmpnam
#define umask PerlLIO_umask
#define unlink PerlLIO_unlink
#define utime PerlLIO_utime
#define write PerlLIO_write
#define malloc PerlMem_malloc
#define realloc PerlMem_realloc
#define free PerlMem_free
#define abort PerlProc_abort
#define exit PerlProc_exit
#define _exit PerlProc__exit
#define execl PerlProc_execl
#define execv PerlProc_execv
#define execvp PerlProc_execvp
#define getuid PerlProc_getuid
#define geteuid PerlProc_geteuid
#define getgid PerlProc_getgid
#define getegid PerlProc_getegid
#define getlogin PerlProc_getlogin
#define kill PerlProc_kill
#define killpg PerlProc_killpg
#define pause PerlProc_pause
#define popen PerlProc_popen
#define pclose PerlProc_pclose
#define pipe PerlProc_pipe
#define setuid PerlProc_setuid
#define setgid PerlProc_setgid
#define sleep PerlProc_sleep
#define times PerlProc_times
#define wait PerlProc_wait
#define setjmp PerlProc_setjmp
#define longjmp PerlProc_longjmp
#define signal PerlProc_signal
#define htonl PerlSock_htonl
#define htons PerlSock_htons
#define ntohl PerlSock_ntohl
#define ntohs PerlSock_ntohs
#define accept PerlSock_accept
#define bind PerlSock_bind
#define connect PerlSock_connect
#define endhostent PerlSock_endhostent
#define endnetent PerlSock_endnetent
#define endprotoent PerlSock_endprotoent
#define endservent PerlSock_endservent
#define gethostbyaddr PerlSock_gethostbyaddr
#define gethostbyname PerlSock_gethostbyname
#define gethostent PerlSock_gethostent
#define gethostname PerlSock_gethostname
#define getnetbyaddr PerlSock_getnetbyaddr
#define getnetbyname PerlSock_getnetbyname
#define getnetent PerlSock_getnetent
#define getpeername PerlSock_getpeername
#define getprotobyname PerlSock_getprotobyname
#define getprotobynumber PerlSock_getprotobynumber
#define getprotoent PerlSock_getprotoent
#define getservbyname PerlSock_getservbyname
#define getservbyport PerlSock_getservbyport
#define getservent PerlSock_getservent
#define getsockname PerlSock_getsockname
#define getsockopt PerlSock_getsockopt
#define inet_addr PerlSock_inet_addr
#define inet_ntoa PerlSock_inet_ntoa
#define listen PerlSock_listen
#define recvfrom PerlSock_recvfrom
#define select PerlSock_select
#define send PerlSock_send
#define sendto PerlSock_sendto
#define sethostent PerlSock_sethostent
#define setnetent PerlSock_setnetent
#define setprotoent PerlSock_setprotoent
#define setservent PerlSock_setservent
#define setsockopt PerlSock_setsockopt
#define shutdown PerlSock_shutdown
#define socket PerlSock_socket
#define socketpair PerlSock_socketpair
#endif  /* NO_XSLOCKS */

#undef  PERL_OBJECT_THIS
#define PERL_OBJECT_THIS pPerl
#undef  PERL_OBJECT_THIS_
#define PERL_OBJECT_THIS_ pPerl,

#undef  SAVEDESTRUCTOR
#define SAVEDESTRUCTOR(f,p) \
	pPerl->Perl_save_destructor((FUNC_NAME_TO_PTR(f)),(p))

#ifdef WIN32

#ifndef WIN32IO_IS_STDIO
#undef	errno
#define errno                 ErrorNo()
#endif

#undef  ErrorNo
#define ErrorNo				pPerl->ErrorNo
#undef  NtCrypt
#define NtCrypt               pPerl->NtCrypt
#undef  NtGetLib
#define NtGetLib              pPerl->NtGetLib
#undef  NtGetArchLib
#define NtGetArchLib          pPerl->NtGetArchLib
#undef  NtGetSiteLib
#define NtGetSiteLib          pPerl->NtGetSiteLib
#undef  NtGetBin
#define NtGetBin              pPerl->NtGetBin
#undef  NtGetDebugScriptStr
#define NtGetDebugScriptStr   pPerl->NtGetDebugScriptStr
#endif /* WIN32 */

#endif	/* __objXSUB_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\op.h ===
/*    op.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * The fields of BASEOP are:
 *	op_next		Pointer to next ppcode to execute after this one.
 *			(Top level pre-grafted op points to first op,
 *			but this is replaced when op is grafted in, when
 *			this op will point to the real next op, and the new
 *			parent takes over role of remembering starting op.)
 *	op_ppaddr	Pointer to current ppcode's function.
 *	op_type		The type of the operation.
 *	op_flags	Flags common to all operations.  See OPf_* below.
 *	op_private	Flags peculiar to a particular operation (BUT,
 *			by default, set to the number of children until
 *			the operation is privatized by a check routine,
 *			which may or may not check number of children).
 */

typedef U32 PADOFFSET;
#define NOT_IN_PAD ((PADOFFSET) -1)

#ifdef DEBUGGING_OPS
#define OPCODE opcode
#else
#define OPCODE U16
#endif

#ifdef BASEOP_DEFINITION
#define BASEOP BASEOP_DEFINITION
#else
#define BASEOP				\
    OP*		op_next;		\
    OP*		op_sibling;		\
    OP*		(CPERLscope(*op_ppaddr))_((ARGSproto));		\
    PADOFFSET	op_targ;		\
    OPCODE	op_type;		\
    U16		op_seq;			\
    U8		op_flags;		\
    U8		op_private;
#endif

#define OP_GIMME(op,dfl) \
	(((op)->op_flags & OPf_WANT) == OPf_WANT_VOID   ? G_VOID   : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_SCALAR ? G_SCALAR : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_LIST   ? G_ARRAY   : \
	 dfl)

#define GIMME_V		OP_GIMME(PL_op, block_gimme())

/* Public flags */

#define OPf_WANT	3	/* Mask for "want" bits: */
#define  OPf_WANT_VOID	 1	/*   Want nothing */
#define  OPf_WANT_SCALAR 2	/*   Want single value */
#define  OPf_WANT_LIST	 3	/*   Want list of any length */
#define OPf_KIDS	4	/* There is a firstborn child. */
#define OPf_PARENS	8	/* This operator was parenthesized. */
				/*  (Or block needs explicit scope entry.) */
#define OPf_REF		16	/* Certified reference. */
				/*  (Return container, not containee). */
#define OPf_MOD		32	/* Will modify (lvalue). */
#define OPf_STACKED	64	/* Some arg is arriving on the stack. */
#define OPf_SPECIAL	128	/* Do something weird for this op: */
				/*  On local LVAL, don't init local value. */
				/*  On OP_SORT, subroutine is inlined. */
				/*  On OP_NOT, inversion was implicit. */
				/*  On OP_LEAVE, don't restore curpm. */
				/*  On truncate, we truncate filehandle */
				/*  On control verbs, we saw no label */
				/*  On flipflop, we saw ... instead of .. */
				/*  On UNOPs, saw bare parens, e.g. eof(). */
				/*  On OP_ENTERSUB || OP_NULL, saw a "do". */
				/*  On OP_(ENTER|LEAVE)EVAL, don't clear $@ */
				/*  On OP_ENTERITER, loop var is per-thread */

/* old names; don't use in new code, but don't break them, either */
#define OPf_LIST	OPf_WANT_LIST
#define OPf_KNOW	OPf_WANT
#define GIMME \
	  (PL_op->op_flags & OPf_WANT					\
	   ? ((PL_op->op_flags & OPf_WANT) == OPf_WANT_LIST		\
	      ? G_ARRAY							\
	      : G_SCALAR)						\
	   : dowantarray())

/* Private for lvalues */
#define OPpLVAL_INTRO	128	/* Lvalue must be localized */

/* Private for OP_AASSIGN */
#define OPpASSIGN_COMMON	64	/* Left & right have syms in common. */

/* Private for OP_SASSIGN */
#define OPpASSIGN_BACKWARDS	64	/* Left & right switched. */

/* Private for OP_MATCH and OP_SUBST{,CONST} */
#define OPpRUNTIME		64	/* Pattern coming in on the stack */

/* Private for OP_TRANS */
#define OPpTRANS_COUNTONLY	8
#define OPpTRANS_SQUASH		16
#define OPpTRANS_DELETE		32
#define OPpTRANS_COMPLEMENT	64

/* Private for OP_REPEAT */
#define OPpREPEAT_DOLIST	64	/* List replication. */

/* Private for OP_ENTERSUB, OP_RV2?V, OP_?ELEM */
#define OPpDEREF		(32|64)	/* Want ref to something: */
#define OPpDEREF_AV		32	/*   Want ref to AV. */
#define OPpDEREF_HV		64	/*   Want ref to HV. */
#define OPpDEREF_SV		(32|64)	/*   Want ref to SV. */
  /* OP_ENTERSUB only */
#define OPpENTERSUB_DB		16	/* Debug subroutine. */
  /* OP_RV2CV only */
#define OPpENTERSUB_AMPER	8	/* Used & form to call. */
#define OPpENTERSUB_NOPAREN	128	/* bare sub call (without parens) */
  /* OP_?ELEM only */
#define OPpLVAL_DEFER		16	/* Defer creation of array/hash elem */
  /* for OP_RV2?V, lower bits carry hints */

/* Private for OP_CONST */
#define	OPpCONST_STRICT		8	/* bearword subject to strict 'subs' */
#define OPpCONST_ENTERED	16	/* Has been entered as symbol. */
#define OPpCONST_ARYBASE	32	/* Was a $[ translated to constant. */
#define OPpCONST_BARE		64	/* Was a bare word (filehandle?). */

/* Private for OP_FLIP/FLOP */
#define OPpFLIP_LINENUM		64	/* Range arg potentially a line num. */

/* Private for OP_LIST */
#define OPpLIST_GUESSED		64	/* Guessed that pushmark was needed. */

/* Private for OP_DELETE */
#define OPpSLICE		64	/* Operating on a list of keys */

/* Private for OP_SORT, OP_PRTF, OP_SPRINTF, string cmp'n, and case changers */
#define OPpLOCALE		64	/* Use locale */

/* Private for OP_THREADSV */
#define OPpDONE_SVREF		64	/* Been through newSVREF once */

struct op {
    BASEOP
};

struct unop {
    BASEOP
    OP *	op_first;
};

struct binop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct logop {
    BASEOP
    OP *	op_first;
    OP *	op_other;
};

struct condop {
    BASEOP
    OP *	op_first;
    OP *	op_true;
    OP *	op_false;
};

struct listop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    U32		op_children;
};

struct pmop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    U32		op_children;
    OP *	op_pmreplroot;
    OP *	op_pmreplstart;
    PMOP *	op_pmnext;		/* list of all scanpats */
    REGEXP *	op_pmregexp;		/* compiled expression */
    U16		op_pmflags;
    U16		op_pmpermflags;
    U8		op_pmdynflags;
};

#define PMdf_USED	0x01		/* pm has been used once already */
#define PMdf_TAINTED	0x02		/* pm compiled from tainted pattern */

#define PMf_RETAINT	0x0001		/* taint $1 etc. if target tainted */
#define PMf_ONCE	0x0002		/* use pattern only once per reset */
#define PMf_REVERSED	0x0004		/* Should be matched right->left */
#define PMf_MAYBE_CONST	0x0008		/* replacement contains variables */
#define PMf_SKIPWHITE	0x0010		/* skip leading whitespace for split */
#define PMf_WHITE	0x0020		/* pattern is \s+ */
#define PMf_CONST	0x0040		/* subst replacement is constant */
#define PMf_KEEP	0x0080		/* keep 1st runtime pattern forever */
#define PMf_GLOBAL	0x0100		/* pattern had a g modifier */
#define PMf_CONTINUE	0x0200		/* don't reset pos() if //g fails */
#define PMf_EVAL	0x0400		/* evaluating replacement as expr */
#define PMf_LOCALE	0x0800		/* use locale for character types */
#define PMf_MULTILINE	0x1000		/* assume multiple lines */
#define PMf_SINGLELINE	0x2000		/* assume single line */
#define PMf_FOLD	0x4000		/* case insensitivity */
#define PMf_EXTENDED	0x8000		/* chuck embedded whitespace */

/* mask of bits stored in regexp->reganch */
#define PMf_COMPILETIME	(PMf_MULTILINE|PMf_SINGLELINE|PMf_LOCALE|PMf_FOLD|PMf_EXTENDED)

struct svop {
    BASEOP
    SV *	op_sv;
};

struct gvop {
    BASEOP
    GV *	op_gv;
};

struct pvop {
    BASEOP
    char *	op_pv;
};

struct loop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    U32		op_children;
    OP *	op_redoop;
    OP *	op_nextop;
    OP *	op_lastop;
};

#define cUNOP ((UNOP*)PL_op)
#define cBINOP ((BINOP*)PL_op)
#define cLISTOP ((LISTOP*)PL_op)
#define cLOGOP ((LOGOP*)PL_op)
#define cCONDOP ((CONDOP*)PL_op)
#define cPMOP ((PMOP*)PL_op)
#define cSVOP ((SVOP*)PL_op)
#define cGVOP ((GVOP*)PL_op)
#define cPVOP ((PVOP*)PL_op)
#define cCOP ((COP*)PL_op)
#define cLOOP ((LOOP*)PL_op)

#define cUNOPo ((UNOP*)o)
#define cBINOPo ((BINOP*)o)
#define cLISTOPo ((LISTOP*)o)
#define cLOGOPo ((LOGOP*)o)
#define cCONDOPo ((CONDOP*)o)
#define cPMOPo ((PMOP*)o)
#define cSVOPo ((SVOP*)o)
#define cGVOPo ((GVOP*)o)
#define cPVOPo ((PVOP*)o)
#define cCVOPo ((CVOP*)o)
#define cCOPo ((COP*)o)
#define cLOOPo ((LOOP*)o)

#define kUNOP ((UNOP*)kid)
#define kBINOP ((BINOP*)kid)
#define kLISTOP ((LISTOP*)kid)
#define kLOGOP ((LOGOP*)kid)
#define kCONDOP ((CONDOP*)kid)
#define kPMOP ((PMOP*)kid)
#define kSVOP ((SVOP*)kid)
#define kGVOP ((GVOP*)kid)
#define kPVOP ((PVOP*)kid)
#define kCOP ((COP*)kid)
#define kLOOP ((LOOP*)kid)

#define Nullop Null(OP*)

/* Lowest byte of opargs */
#define OA_MARK 1
#define OA_FOLDCONST 2
#define OA_RETSCALAR 4
#define OA_TARGET 8
#define OA_RETINTEGER 16
#define OA_OTHERINT 32
#define OA_DANGEROUS 64
#define OA_DEFGV 128

/* The next 4 bits encode op class information */
#define OA_CLASS_MASK (15 << 8)

#define OA_BASEOP (0 << 8)
#define OA_UNOP (1 << 8)
#define OA_BINOP (2 << 8)
#define OA_LOGOP (3 << 8)
#define OA_CONDOP (4 << 8)
#define OA_LISTOP (5 << 8)
#define OA_PMOP (6 << 8)
#define OA_SVOP (7 << 8)
#define OA_GVOP (8 << 8)
#define OA_PVOP (9 << 8)
#define OA_LOOP (10 << 8)
#define OA_COP (11 << 8)
#define OA_BASEOP_OR_UNOP (12 << 8)
#define OA_FILESTATOP (13 << 8)
#define OA_LOOPEXOP (14 << 8)

#define OASHIFT 12

/* Remaining nybbles of opargs */
#define OA_SCALAR 1
#define OA_LIST 2
#define OA_AVREF 3
#define OA_HVREF 4
#define OA_CVREF 5
#define OA_FILEREF 6
#define OA_SCALARREF 7
#define OA_OPTIONAL 8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\patchlevel.h ===
#ifndef __PATCHLEVEL_H_INCLUDED__

#include "BuildInfo.h"

#define PATCHLEVEL 5
#undef SUBVERSION     /* OS/390 has a SUBVERSION in a system header */
#define SUBVERSION 3

/*
	local_patches -- list of locally applied less-than-subversion patches.
	If you're distributing such a patch, please give it a name and a
	one-line description, placed just before the last NULL in the array
	below.  If your patch fixes a bug in the perlbug database, please
	mention the bugid.  If your patch *IS* dependent on a prior patch,
	please place your applied patch line after its dependencies. This
	will help tracking of patch dependencies.

	Please edit the hunk of diff which adds your patch to this list,
	to remove context lines which would give patch problems.  For instance,
	if the original context diff is
	   *** patchlevel.h.orig	<date here>
	   --- patchlevel.h	<date here>
	   *** 38,43 ***
	   --- 38,44 ---
	     	,"FOO1235 - some patch"
	     	,"BAR3141 - another patch"
	     	,"BAZ2718 - and another patch"
	   + 	,"MINE001 - my new patch"
	     	,NULL
	     };
	
	please change it to 
	   *** patchlevel.h.orig	<date here>
	   --- patchlevel.h	<date here>
	   *** 41,43 ***
	   --- 41,44 ---
	   + 	,"MINE001 - my new patch"
	     };
	
	(Note changes to line numbers as well as removal of context lines.)
	This will prevent patch from choking if someone has previously
	applied different patches than you.
 */
static	char	*local_patches[] = {
	NULL
	,ACTIVEPERL_LOCAL_PATCHES_ENTRY
	,NULL
};

/* Initial space prevents this variable from being inserted in config.sh  */
#  define	LOCAL_PATCH_COUNT	\
	(sizeof(local_patches)/sizeof(local_patches[0])-2)

#  define __PATCHLEVEL_H_INCLUDED__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlio.h ===
#include "iperlsys.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlcapi.h ===
EXTERN_C void SetCPerlObj(void* pP);
EXTERN_C void boot_CAPI_handler(CV *cv, void (*subaddr)(CV *c), void *pP);
EXTERN_C CV* Perl_newXS(char* name, void (*subaddr)(CV* cv), char* filename);


#undef PL_sawstudy
EXTERN_C bool * _PL_sawstudy ();
#define PL_sawstudy (*_PL_sawstudy())


#undef PL_main_root
EXTERN_C OP * * _PL_main_root ();
#define PL_main_root (*_PL_main_root())


#undef PL_copline
EXTERN_C line_t * _PL_copline ();
#define PL_copline (*_PL_copline())


#undef PL_basetime
EXTERN_C Time_t * _PL_basetime ();
#define PL_basetime (*_PL_basetime())


#undef PL_profiledata
EXTERN_C U32 * * _PL_profiledata ();
#define PL_profiledata (*_PL_profiledata())


#undef PL_debname
EXTERN_C char * * _PL_debname ();
#define PL_debname (*_PL_debname())


#undef PL_doextract
EXTERN_C bool * _PL_doextract ();
#define PL_doextract (*_PL_doextract())


#undef PL_sv_count
EXTERN_C I32 * _PL_sv_count ();
#define PL_sv_count (*_PL_sv_count())


#undef PL_curcopdb
EXTERN_C COP * * _PL_curcopdb ();
#define PL_curcopdb (*_PL_curcopdb())


#undef PL_main_start
EXTERN_C OP * * _PL_main_start ();
#define PL_main_start (*_PL_main_start())


#undef PL_lastspbase
EXTERN_C I32 * _PL_lastspbase ();
#define PL_lastspbase (*_PL_lastspbase())


#undef PL_ampergv
EXTERN_C GV * * _PL_ampergv ();
#define PL_ampergv (*_PL_ampergv())


#undef PL_rsfp_filters
EXTERN_C AV * * _PL_rsfp_filters ();
#define PL_rsfp_filters (*_PL_rsfp_filters())


#undef PL_eval_start
EXTERN_C OP * * _PL_eval_start ();
#define PL_eval_start (*_PL_eval_start())


#undef PL_exitlist
EXTERN_C PerlExitListEntry * * _PL_exitlist ();
#define PL_exitlist (*_PL_exitlist())


#undef PL_main_cv
EXTERN_C CV * * _PL_main_cv ();
#define PL_main_cv (*_PL_main_cv())


#undef PL_siggv
EXTERN_C GV * * _PL_siggv ();
#define PL_siggv (*_PL_siggv())


#undef PL_statusvalue
EXTERN_C I32 * _PL_statusvalue ();
#define PL_statusvalue (*_PL_statusvalue())


#undef PL_compiling
EXTERN_C COP * _PL_compiling ();
#define PL_compiling (*_PL_compiling())


#undef PL_diehook
EXTERN_C SV * * _PL_diehook ();
#define PL_diehook (*_PL_diehook())


#undef PL_comppad
EXTERN_C AV * * _PL_comppad ();
#define PL_comppad (*_PL_comppad())


#undef PL_DBsignal
EXTERN_C SV * * _PL_DBsignal ();
#define PL_DBsignal (*_PL_DBsignal())


#undef PL_cddir
EXTERN_C char * * _PL_cddir ();
#define PL_cddir (*_PL_cddir())


#undef PL_preprocess
EXTERN_C bool * _PL_preprocess ();
#define PL_preprocess (*_PL_preprocess())


#undef PL_fdpid
EXTERN_C AV * * _PL_fdpid ();
#define PL_fdpid (*_PL_fdpid())


#undef PL_compcv
EXTERN_C CV * * _PL_compcv ();
#define PL_compcv (*_PL_compcv())


#undef PL_leftgv
EXTERN_C GV * * _PL_leftgv ();
#define PL_leftgv (*_PL_leftgv())


#undef PL_formfeed
EXTERN_C SV * * _PL_formfeed ();
#define PL_formfeed (*_PL_formfeed())


#undef PL_warnhook
EXTERN_C SV * * _PL_warnhook ();
#define PL_warnhook (*_PL_warnhook())


#undef PL_sawvec
EXTERN_C bool * _PL_sawvec ();
#define PL_sawvec (*_PL_sawvec())


#undef PL_op_mask
EXTERN_C char * * _PL_op_mask ();
#define PL_op_mask (*_PL_op_mask())


#undef PL_eval_root
EXTERN_C OP * * _PL_eval_root ();
#define PL_eval_root (*_PL_eval_root())


#undef PL_initav
EXTERN_C AV * * _PL_initav ();
#define PL_initav (*_PL_initav())


#undef PL_dowarn
EXTERN_C bool * _PL_dowarn ();
#define PL_dowarn (*_PL_dowarn())


#undef PL_sv_objcount
EXTERN_C I32 * _PL_sv_objcount ();
#define PL_sv_objcount (*_PL_sv_objcount())


#undef PL_parsehook
EXTERN_C SV * * _PL_parsehook ();
#define PL_parsehook (*_PL_parsehook())


#undef PL_argvgv
EXTERN_C GV * * _PL_argvgv ();
#define PL_argvgv (*_PL_argvgv())


#undef PL_sys_intern
EXTERN_C struct interp_intern * _PL_sys_intern ();
#define PL_sys_intern (*_PL_sys_intern())


#undef PL_DBline
EXTERN_C GV * * _PL_DBline ();
#define PL_DBline (*_PL_DBline())


#undef PL_lastsize
EXTERN_C I32 * _PL_lastsize ();
#define PL_lastsize (*_PL_lastsize())


#undef PL_replgv
EXTERN_C GV * * _PL_replgv ();
#define PL_replgv (*_PL_replgv())


#undef PL_hintgv
EXTERN_C GV * * _PL_hintgv ();
#define PL_hintgv (*_PL_hintgv())


#undef PL_forkprocess
EXTERN_C int * _PL_forkprocess ();
#define PL_forkprocess (*_PL_forkprocess())


#undef PL_minus_F
EXTERN_C bool * _PL_minus_F ();
#define PL_minus_F (*_PL_minus_F())


#undef PL_curstname
EXTERN_C SV * * _PL_curstname ();
#define PL_curstname (*_PL_curstname())


#undef PL_bytecode_iv_overflows
EXTERN_C int * _PL_bytecode_iv_overflows ();
#define PL_bytecode_iv_overflows (*_PL_bytecode_iv_overflows())


#undef PL_laststatval
EXTERN_C int * _PL_laststatval ();
#define PL_laststatval (*_PL_laststatval())


#undef PL_sv_arenaroot
EXTERN_C SV* * _PL_sv_arenaroot ();
#define PL_sv_arenaroot (*_PL_sv_arenaroot())


#undef PL_dbargs
EXTERN_C AV * * _PL_dbargs ();
#define PL_dbargs (*_PL_dbargs())


#undef PL_multiline
EXTERN_C int * _PL_multiline ();
#define PL_multiline (*_PL_multiline())


#undef PL_exitlistlen
EXTERN_C I32 * _PL_exitlistlen ();
#define PL_exitlistlen (*_PL_exitlistlen())


#undef PL_DBtrace
EXTERN_C SV * * _PL_DBtrace ();
#define PL_DBtrace (*_PL_DBtrace())


#undef PL_debdelim
EXTERN_C char * * _PL_debdelim ();
#define PL_debdelim (*_PL_debdelim())


#undef PL_bytecode_sv
EXTERN_C SV * * _PL_bytecode_sv ();
#define PL_bytecode_sv (*_PL_bytecode_sv())


#undef PL_perl_destruct_level
EXTERN_C int * _PL_perl_destruct_level ();
#define PL_perl_destruct_level (*_PL_perl_destruct_level())


#undef PL_perldb
EXTERN_C U32 * _PL_perldb ();
#define PL_perldb (*_PL_perldb())


#undef PL_tainting
EXTERN_C bool * _PL_tainting ();
#define PL_tainting (*_PL_tainting())


#undef PL_unsafe
EXTERN_C bool * _PL_unsafe ();
#define PL_unsafe (*_PL_unsafe())


#undef PL_DBgv
EXTERN_C GV * * _PL_DBgv ();
#define PL_DBgv (*_PL_DBgv())


#undef PL_bytecode_obj_list
EXTERN_C void ** * _PL_bytecode_obj_list ();
#define PL_bytecode_obj_list (*_PL_bytecode_obj_list())


#undef PL_comppad_name
EXTERN_C AV * * _PL_comppad_name ();
#define PL_comppad_name (*_PL_comppad_name())


#undef PL_comppad_name_floor
EXTERN_C I32 * _PL_comppad_name_floor ();
#define PL_comppad_name_floor (*_PL_comppad_name_floor())


#undef PL_envgv
EXTERN_C GV * * _PL_envgv ();
#define PL_envgv (*_PL_envgv())


#undef PL_errgv
EXTERN_C GV * * _PL_errgv ();
#define PL_errgv (*_PL_errgv())


#undef PL_last_proto
EXTERN_C char * * _PL_last_proto ();
#define PL_last_proto (*_PL_last_proto())


#undef PL_laststype
EXTERN_C I32 * _PL_laststype ();
#define PL_laststype (*_PL_laststype())


#undef PL_bytecode_obj_list_fill
EXTERN_C I32 * _PL_bytecode_obj_list_fill ();
#define PL_bytecode_obj_list_fill (*_PL_bytecode_obj_list_fill())


#undef PL_comppad_name_fill
EXTERN_C I32 * _PL_comppad_name_fill ();
#define PL_comppad_name_fill (*_PL_comppad_name_fill())


#undef PL_minus_a
EXTERN_C bool * _PL_minus_a ();
#define PL_minus_a (*_PL_minus_a())


#undef PL_defgv
EXTERN_C GV * * _PL_defgv ();
#define PL_defgv (*_PL_defgv())


#undef PL_origargc
EXTERN_C int * _PL_origargc ();
#define PL_origargc (*_PL_origargc())


#undef PL_minus_c
EXTERN_C bool * _PL_minus_c ();
#define PL_minus_c (*_PL_minus_c())


#undef PL_strtab
EXTERN_C HV * * _PL_strtab ();
#define PL_strtab (*_PL_strtab())


#undef PL_origfilename
EXTERN_C char * * _PL_origfilename ();
#define PL_origfilename (*_PL_origfilename())


#undef PL_bytecode_pv
EXTERN_C XPV * _PL_bytecode_pv ();
#define PL_bytecode_pv (*_PL_bytecode_pv())


#undef PL_minus_l
EXTERN_C bool * _PL_minus_l ();
#define PL_minus_l (*_PL_minus_l())


#undef PL_minus_n
EXTERN_C bool * _PL_minus_n ();
#define PL_minus_n (*_PL_minus_n())


#undef PL_e_script
EXTERN_C SV * * _PL_e_script ();
#define PL_e_script (*_PL_e_script())


#undef PL_minus_p
EXTERN_C bool * _PL_minus_p ();
#define PL_minus_p (*_PL_minus_p())


#undef PL_origargv
EXTERN_C char ** * _PL_origargv ();
#define PL_origargv (*_PL_origargv())


#undef PL_splitstr
EXTERN_C char * * _PL_splitstr ();
#define PL_splitstr (*_PL_splitstr())


#undef PL_argvoutgv
EXTERN_C GV * * _PL_argvoutgv ();
#define PL_argvoutgv (*_PL_argvoutgv())


#undef PL_sawampersand
EXTERN_C bool * _PL_sawampersand ();
#define PL_sawampersand (*_PL_sawampersand())


#undef PL_DBsingle
EXTERN_C SV * * _PL_DBsingle ();
#define PL_DBsingle (*_PL_DBsingle())


#undef PL_sv_root
EXTERN_C SV* * _PL_sv_root ();
#define PL_sv_root (*_PL_sv_root())


#undef PL_debstash
EXTERN_C HV * * _PL_debstash ();
#define PL_debstash (*_PL_debstash())


#undef PL_endav
EXTERN_C AV * * _PL_endav ();
#define PL_endav (*_PL_endav())


#undef PL_maxsysfd
EXTERN_C I32 * _PL_maxsysfd ();
#define PL_maxsysfd (*_PL_maxsysfd())


#undef PL_DBsub
EXTERN_C GV * * _PL_DBsub ();
#define PL_DBsub (*_PL_DBsub())


#undef PL_modglobal
EXTERN_C HV * * _PL_modglobal ();
#define PL_modglobal (*_PL_modglobal())


#undef PL_localpatches
EXTERN_C char ** * _PL_localpatches ();
#define PL_localpatches (*_PL_localpatches())


#undef PL_lineary
EXTERN_C AV * * _PL_lineary ();
#define PL_lineary (*_PL_lineary())


#undef PL_globalstash
EXTERN_C HV * * _PL_globalstash ();
#define PL_globalstash (*_PL_globalstash())


#undef PL_sub_generation
EXTERN_C U32 * _PL_sub_generation ();
#define PL_sub_generation (*_PL_sub_generation())


#undef PL_dlmax
EXTERN_C I32 * _PL_dlmax ();
#define PL_dlmax (*_PL_dlmax())


#undef PL_incgv
EXTERN_C GV * * _PL_incgv ();
#define PL_incgv (*_PL_incgv())


#undef PL_rsfp
EXTERN_C PerlIO * VOL * _PL_rsfp ();
#define PL_rsfp (*_PL_rsfp())


#undef PL_rightgv
EXTERN_C GV * * _PL_rightgv ();
#define PL_rightgv (*_PL_rightgv())


#undef PL_dlevel
EXTERN_C I32 * _PL_dlevel ();
#define PL_dlevel (*_PL_dlevel())


#undef PL_inplace
EXTERN_C char * * _PL_inplace ();
#define PL_inplace (*_PL_inplace())


#undef PL_beginav
EXTERN_C AV * * _PL_beginav ();
#define PL_beginav (*_PL_beginav())


#undef PL_doswitches
EXTERN_C bool * _PL_doswitches ();
#define PL_doswitches (*_PL_doswitches())


#undef PL_stdingv
EXTERN_C GV * * _PL_stdingv ();
#define PL_stdingv (*_PL_stdingv())


#undef PL_retstack_ix
EXTERN_C I32 * _PL_retstack_ix ();
#define PL_retstack_ix (*_PL_retstack_ix())


#undef PL_retstack
EXTERN_C OP ** * _PL_retstack ();
#define PL_retstack (*_PL_retstack())


#undef PL_tmps_floor
EXTERN_C I32 * _PL_tmps_floor ();
#define PL_tmps_floor (*_PL_tmps_floor())


#undef PL_last_in_gv
EXTERN_C GV * * _PL_last_in_gv ();
#define PL_last_in_gv (*_PL_last_in_gv())


#undef PL_curpm
EXTERN_C PMOP * * _PL_curpm ();
#define PL_curpm (*_PL_curpm())


#undef PL_savestack_max
EXTERN_C I32 * _PL_savestack_max ();
#define PL_savestack_max (*_PL_savestack_max())


#undef PL_dirty
EXTERN_C bool * _PL_dirty ();
#define PL_dirty (*_PL_dirty())


#undef PL_statcache
EXTERN_C Stat_t * _PL_statcache ();
#define PL_statcache (*_PL_statcache())


#undef PL_scopestack_ix
EXTERN_C I32 * _PL_scopestack_ix ();
#define PL_scopestack_ix (*_PL_scopestack_ix())


#undef PL_nrs
EXTERN_C SV * * _PL_nrs ();
#define PL_nrs (*_PL_nrs())


#undef PL_scopestack_max
EXTERN_C I32 * _PL_scopestack_max ();
#define PL_scopestack_max (*_PL_scopestack_max())


#undef PL_chopset
EXTERN_C char * * _PL_chopset ();
#define PL_chopset (*_PL_chopset())


#undef PL_toptarget
EXTERN_C SV * * _PL_toptarget ();
#define PL_toptarget (*_PL_toptarget())


#undef PL_formtarget
EXTERN_C SV * * _PL_formtarget ();
#define PL_formtarget (*_PL_formtarget())


#undef PL_regcompp
EXTERN_C regcomp_t * _PL_regcompp ();
#define PL_regcompp (*_PL_regcompp())


#undef PL_curstack
EXTERN_C AV * * _PL_curstack ();
#define PL_curstack (*_PL_curstack())


#undef PL_maxscream
EXTERN_C I32 * _PL_maxscream ();
#define PL_maxscream (*_PL_maxscream())


#undef PL_hv_fetch_ent_mh
EXTERN_C HE * _PL_hv_fetch_ent_mh ();
#define PL_hv_fetch_ent_mh (*_PL_hv_fetch_ent_mh())


#undef PL_markstack
EXTERN_C I32 * * _PL_markstack ();
#define PL_markstack (*_PL_markstack())


#undef PL_restartop
EXTERN_C OP * * _PL_restartop ();
#define PL_restartop (*_PL_restartop())


#undef PL_defoutgv
EXTERN_C GV * * _PL_defoutgv ();
#define PL_defoutgv (*_PL_defoutgv())


#undef PL_tmps_ix
EXTERN_C I32 * _PL_tmps_ix ();
#define PL_tmps_ix (*_PL_tmps_ix())


#undef PL_rs
EXTERN_C SV * * _PL_rs ();
#define PL_rs (*_PL_rs())


#undef PL_retstack_max
EXTERN_C I32 * _PL_retstack_max ();
#define PL_retstack_max (*_PL_retstack_max())


#undef PL_ofslen
EXTERN_C STRLEN * _PL_ofslen ();
#define PL_ofslen (*_PL_ofslen())


#undef PL_av_fetch_sv
EXTERN_C SV * * _PL_av_fetch_sv ();
#define PL_av_fetch_sv (*_PL_av_fetch_sv())


#undef PL_tmps_max
EXTERN_C I32 * _PL_tmps_max ();
#define PL_tmps_max (*_PL_tmps_max())


#undef PL_Sv
EXTERN_C SV * * _PL_Sv ();
#define PL_Sv (*_PL_Sv())


#undef PL_curstash
EXTERN_C HV * * _PL_curstash ();
#define PL_curstash (*_PL_curstash())


#undef PL_delaymagic
EXTERN_C int * _PL_delaymagic ();
#define PL_delaymagic (*_PL_delaymagic())


#undef PL_statgv
EXTERN_C GV * * _PL_statgv ();
#define PL_statgv (*_PL_statgv())


#undef PL_screamnext
EXTERN_C I32 * * _PL_screamnext ();
#define PL_screamnext (*_PL_screamnext())


#undef PL_mainstack
EXTERN_C AV * * _PL_mainstack ();
#define PL_mainstack (*_PL_mainstack())


#undef PL_statname
EXTERN_C SV * * _PL_statname ();
#define PL_statname (*_PL_statname())


#undef PL_Xpv
EXTERN_C XPV * * _PL_Xpv ();
#define PL_Xpv (*_PL_Xpv())


#undef PL_op
EXTERN_C OP * * _PL_op ();
#define PL_op (*_PL_op())


#undef PL_curpad
EXTERN_C SV ** * _PL_curpad ();
#define PL_curpad (*_PL_curpad())


#undef PL_screamfirst
EXTERN_C I32 * * _PL_screamfirst ();
#define PL_screamfirst (*_PL_screamfirst())


#undef PL_seen_evals
EXTERN_C I32 * _PL_seen_evals ();
#define PL_seen_evals (*_PL_seen_evals())


#undef PL_markstack_max
EXTERN_C I32 * * _PL_markstack_max ();
#define PL_markstack_max (*_PL_markstack_max())


#undef PL_ofs
EXTERN_C char * * _PL_ofs ();
#define PL_ofs (*_PL_ofs())


#undef PL_curcop
EXTERN_C COP * VOL * _PL_curcop ();
#define PL_curcop (*_PL_curcop())


#undef PL_localizing
EXTERN_C int * _PL_localizing ();
#define PL_localizing (*_PL_localizing())


#undef PL_lastscream
EXTERN_C SV * * _PL_lastscream ();
#define PL_lastscream (*_PL_lastscream())


#undef PL_stack_base
EXTERN_C SV ** * _PL_stack_base ();
#define PL_stack_base (*_PL_stack_base())


#undef PL_regexecp
EXTERN_C regexec_t * _PL_regexecp ();
#define PL_regexecp (*_PL_regexecp())


#undef PL_reginterp_cnt
EXTERN_C int * _PL_reginterp_cnt ();
#define PL_reginterp_cnt (*_PL_reginterp_cnt())


#undef PL_bodytarget
EXTERN_C SV * * _PL_bodytarget ();
#define PL_bodytarget (*_PL_bodytarget())


#undef PL_stack_sp
EXTERN_C SV ** * _PL_stack_sp ();
#define PL_stack_sp (*_PL_stack_sp())


#undef PL_statbuf
EXTERN_C Stat_t * _PL_statbuf ();
#define PL_statbuf (*_PL_statbuf())


#undef PL_stack_max
EXTERN_C SV ** * _PL_stack_max ();
#define PL_stack_max (*_PL_stack_max())


#undef PL_in_eval
EXTERN_C VOL int * _PL_in_eval ();
#define PL_in_eval (*_PL_in_eval())


#undef PL_savestack_ix
EXTERN_C I32 * _PL_savestack_ix ();
#define PL_savestack_ix (*_PL_savestack_ix())


#undef PL_savestack
EXTERN_C ANY * * _PL_savestack ();
#define PL_savestack (*_PL_savestack())


#undef PL_tainted
EXTERN_C bool * _PL_tainted ();
#define PL_tainted (*_PL_tainted())


#undef PL_curstackinfo
EXTERN_C PERL_SI * * _PL_curstackinfo ();
#define PL_curstackinfo (*_PL_curstackinfo())


#undef PL_hv_fetch_sv
EXTERN_C SV * * _PL_hv_fetch_sv ();
#define PL_hv_fetch_sv (*_PL_hv_fetch_sv())


#undef PL_scopestack
EXTERN_C I32 * * _PL_scopestack ();
#define PL_scopestack (*_PL_scopestack())


#undef PL_defstash
EXTERN_C HV * * _PL_defstash ();
#define PL_defstash (*_PL_defstash())


#undef PL_markstack_ptr
EXTERN_C I32 * * _PL_markstack_ptr ();
#define PL_markstack_ptr (*_PL_markstack_ptr())


#undef PL_start_env
EXTERN_C JMPENV * _PL_start_env ();
#define PL_start_env (*_PL_start_env())


#undef PL_tmps_stack
EXTERN_C SV ** * _PL_tmps_stack ();
#define PL_tmps_stack (*_PL_tmps_stack())


#undef PL_top_env
EXTERN_C JMPENV * * _PL_top_env ();
#define PL_top_env (*_PL_top_env())


#undef PL_timesbuf
EXTERN_C struct tms * _PL_timesbuf ();
#define PL_timesbuf (*_PL_timesbuf())


#undef PL_osname
EXTERN_C char * * _PL_osname ();
#define PL_osname (*_PL_osname())


#undef PL_collation_ix
EXTERN_C U32 * _PL_collation_ix ();
#define PL_collation_ix (*_PL_collation_ix())


#undef PL_hints
EXTERN_C U32 * _PL_hints ();
#define PL_hints (*_PL_hints())


#undef PL_debug
EXTERN_C VOL U32 * _PL_debug ();
#define PL_debug (*_PL_debug())


#undef PL_lex_dojoin
EXTERN_C I32 * _PL_lex_dojoin ();
#define PL_lex_dojoin (*_PL_lex_dojoin())


#undef PL_amagic_generation
EXTERN_C long * _PL_amagic_generation ();
#define PL_amagic_generation (*_PL_amagic_generation())


#undef PL_na
EXTERN_C STRLEN * _PL_na ();
#define PL_na (*_PL_na())


#undef PL_lex_stuff
EXTERN_C SV * * _PL_lex_stuff ();
#define PL_lex_stuff (*_PL_lex_stuff())


#undef PL_Yes
EXTERN_C char * * _PL_Yes ();
#define PL_Yes (*_PL_Yes())


#undef PL_origalen
EXTERN_C U32 * _PL_origalen ();
#define PL_origalen (*_PL_origalen())


#undef PL_nexttoke
EXTERN_C I32 * _PL_nexttoke ();
#define PL_nexttoke (*_PL_nexttoke())


#undef PL_origenviron
EXTERN_C char ** * _PL_origenviron ();
#define PL_origenviron (*_PL_origenviron())


#undef PL_numeric_name
EXTERN_C char * * _PL_numeric_name ();
#define PL_numeric_name (*_PL_numeric_name())


#undef PL_min_intro_pending
EXTERN_C I32 * _PL_min_intro_pending ();
#define PL_min_intro_pending (*_PL_min_intro_pending())


#undef PL_bufptr
EXTERN_C char * * _PL_bufptr ();
#define PL_bufptr (*_PL_bufptr())


#undef PL_ninterps
EXTERN_C int * _PL_ninterps ();
#define PL_ninterps (*_PL_ninterps())


#undef PL_gid
EXTERN_C int * _PL_gid ();
#define PL_gid (*_PL_gid())


#undef PL_collation_standard
EXTERN_C bool * _PL_collation_standard ();
#define PL_collation_standard (*_PL_collation_standard())


#undef PL_max_intro_pending
EXTERN_C I32 * _PL_max_intro_pending ();
#define PL_max_intro_pending (*_PL_max_intro_pending())


#undef PL_padix
EXTERN_C I32 * _PL_padix ();
#define PL_padix (*_PL_padix())


#undef PL_padix_floor
EXTERN_C I32 * _PL_padix_floor ();
#define PL_padix_floor (*_PL_padix_floor())


#undef PL_lex_casemods
EXTERN_C I32 * _PL_lex_casemods ();
#define PL_lex_casemods (*_PL_lex_casemods())


#undef PL_nice_chunk
EXTERN_C char * * _PL_nice_chunk ();
#define PL_nice_chunk (*_PL_nice_chunk())


#undef PL_lex_repl
EXTERN_C SV * * _PL_lex_repl ();
#define PL_lex_repl (*_PL_lex_repl())


#undef PL_last_lop_op
EXTERN_C OPCODE * _PL_last_lop_op ();
#define PL_last_lop_op (*_PL_last_lop_op())


#undef PL_numeric_local
EXTERN_C bool * _PL_numeric_local ();
#define PL_numeric_local (*_PL_numeric_local())


#undef PL_last_uni
EXTERN_C char * * _PL_last_uni ();
#define PL_last_uni (*_PL_last_uni())


#undef PL_xnv_root
EXTERN_C double * * _PL_xnv_root ();
#define PL_xnv_root (*_PL_xnv_root())


#undef PL_xpv_root
EXTERN_C XPV * * _PL_xpv_root ();
#define PL_xpv_root (*_PL_xpv_root())


#undef PL_pidstatus
EXTERN_C HV * * _PL_pidstatus ();
#define PL_pidstatus (*_PL_pidstatus())


#undef PL_lex_fakebrack
EXTERN_C I32 * _PL_lex_fakebrack ();
#define PL_lex_fakebrack (*_PL_lex_fakebrack())


#undef PL_uid
EXTERN_C int * _PL_uid ();
#define PL_uid (*_PL_uid())


#undef PL_xrv_root
EXTERN_C XRV * * _PL_xrv_root ();
#define PL_xrv_root (*_PL_xrv_root())


#undef PL_lex_op
EXTERN_C OP * * _PL_lex_op ();
#define PL_lex_op (*_PL_lex_op())


#undef PL_collxfrm_mult
EXTERN_C Size_t * _PL_collxfrm_mult ();
#define PL_collxfrm_mult (*_PL_collxfrm_mult())


#undef PL_do_undump
EXTERN_C bool * _PL_do_undump ();
#define PL_do_undump (*_PL_do_undump())


#undef PL_op_seqmax
EXTERN_C U16 * _PL_op_seqmax ();
#define PL_op_seqmax (*_PL_op_seqmax())


#undef PL_oldoldbufptr
EXTERN_C char * * _PL_oldoldbufptr ();
#define PL_oldoldbufptr (*_PL_oldoldbufptr())


#undef PL_lex_expect
EXTERN_C expectation * _PL_lex_expect ();
#define PL_lex_expect (*_PL_lex_expect())


#undef PL_nice_chunk_size
EXTERN_C U32 * _PL_nice_chunk_size ();
#define PL_nice_chunk_size (*_PL_nice_chunk_size())


#undef PL_multi_start
EXTERN_C I32 * _PL_multi_start ();
#define PL_multi_start (*_PL_multi_start())


#undef PL_sv_undef
EXTERN_C SV * _PL_sv_undef ();
#define PL_sv_undef (*_PL_sv_undef())


#undef PL_pad_reset_pending
EXTERN_C I32 * _PL_pad_reset_pending ();
#define PL_pad_reset_pending (*_PL_pad_reset_pending())


#undef PL_in_my
EXTERN_C bool * _PL_in_my ();
#define PL_in_my (*_PL_in_my())


#undef PL_multi_open
EXTERN_C I32 * _PL_multi_open ();
#define PL_multi_open (*_PL_multi_open())


#undef PL_in_my_stash
EXTERN_C HV * * _PL_in_my_stash ();
#define PL_in_my_stash (*_PL_in_my_stash())


#undef PL_lex_formbrack
EXTERN_C I32 * _PL_lex_formbrack ();
#define PL_lex_formbrack (*_PL_lex_formbrack())


#undef PL_multi_close
EXTERN_C I32 * _PL_multi_close ();
#define PL_multi_close (*_PL_multi_close())


#undef PL_collxfrm_base
EXTERN_C Size_t * _PL_collxfrm_base ();
#define PL_collxfrm_base (*_PL_collxfrm_base())


#undef PL_linestr
EXTERN_C SV * * _PL_linestr ();
#define PL_linestr (*_PL_linestr())


#undef PL_multi_end
EXTERN_C I32 * _PL_multi_end ();
#define PL_multi_end (*_PL_multi_end())


#undef PL_collation_name
EXTERN_C char * * _PL_collation_name ();
#define PL_collation_name (*_PL_collation_name())


#undef PL_lex_state
EXTERN_C U32 * _PL_lex_state ();
#define PL_lex_state (*_PL_lex_state())


#undef PL_lex_starts
EXTERN_C I32 * _PL_lex_starts ();
#define PL_lex_starts (*_PL_lex_starts())


#undef PL_expect
EXTERN_C expectation * _PL_expect ();
#define PL_expect (*_PL_expect())


#undef PL_evalseq
EXTERN_C U32 * _PL_evalseq ();
#define PL_evalseq (*_PL_evalseq())


#undef PL_subline
EXTERN_C I32 * _PL_subline ();
#define PL_subline (*_PL_subline())


#undef PL_error_count
EXTERN_C I32 * _PL_error_count ();
#define PL_error_count (*_PL_error_count())


#undef PL_oldbufptr
EXTERN_C char * * _PL_oldbufptr ();
#define PL_oldbufptr (*_PL_oldbufptr())


#undef PL_lex_inwhat
EXTERN_C I32 * _PL_lex_inwhat ();
#define PL_lex_inwhat (*_PL_lex_inwhat())


#undef PL_maxo
EXTERN_C int * _PL_maxo ();
#define PL_maxo (*_PL_maxo())


#undef PL_hexdigit
EXTERN_C char * * _PL_hexdigit ();
#define PL_hexdigit (*_PL_hexdigit())


#undef PL_nomemok
EXTERN_C bool * _PL_nomemok ();
#define PL_nomemok (*_PL_nomemok())


#undef PL_egid
EXTERN_C int * _PL_egid ();
#define PL_egid (*_PL_egid())


#undef PL_xiv_root
EXTERN_C IV * * _PL_xiv_root ();
#define PL_xiv_root (*_PL_xiv_root())


#undef PL_xiv_arenaroot
EXTERN_C XPV* * _PL_xiv_arenaroot ();
#define PL_xiv_arenaroot (*_PL_xiv_arenaroot())


#undef PL_lex_brackstack
EXTERN_C char * * _PL_lex_brackstack ();
#define PL_lex_brackstack (*_PL_lex_brackstack())


#undef PL_numeric_standard
EXTERN_C bool * _PL_numeric_standard ();
#define PL_numeric_standard (*_PL_numeric_standard())


#undef PL_lex_inpat
EXTERN_C OP * * _PL_lex_inpat ();
#define PL_lex_inpat (*_PL_lex_inpat())


#undef PL_sv_no
EXTERN_C SV * _PL_sv_no ();
#define PL_sv_no (*_PL_sv_no())


#undef PL_sh_path
EXTERN_C char * * _PL_sh_path ();
#define PL_sh_path (*_PL_sh_path())


#undef PL_euid
EXTERN_C int * _PL_euid ();
#define PL_euid (*_PL_euid())


#undef PL_runops
EXTERN_C runops_proc_t * * _PL_runops ();
#define PL_runops (*_PL_runops())


#undef PL_subname
EXTERN_C SV * * _PL_subname ();
#define PL_subname (*_PL_subname())


#undef PL_lex_defer
EXTERN_C U32 * _PL_lex_defer ();
#define PL_lex_defer (*_PL_lex_defer())


#undef PL_an
EXTERN_C U32 * _PL_an ();
#define PL_an (*_PL_an())


#undef PL_cop_seqmax
EXTERN_C U32 * _PL_cop_seqmax ();
#define PL_cop_seqmax (*_PL_cop_seqmax())


#undef PL_he_root
EXTERN_C HE * * _PL_he_root ();
#define PL_he_root (*_PL_he_root())


#undef PL_sighandlerp
EXTERN_C Sighandler_t * _PL_sighandlerp ();
#define PL_sighandlerp (*_PL_sighandlerp())


#undef PL_patleave
EXTERN_C char * * _PL_patleave ();
#define PL_patleave (*_PL_patleave())


#undef PL_bufend
EXTERN_C char * * _PL_bufend ();
#define PL_bufend (*_PL_bufend())


#undef PL_thisexpr
EXTERN_C I32 * _PL_thisexpr ();
#define PL_thisexpr (*_PL_thisexpr())


#undef PL_lex_brackets
EXTERN_C I32 * _PL_lex_brackets ();
#define PL_lex_brackets (*_PL_lex_brackets())


#undef PL_sv_yes
EXTERN_C SV * _PL_sv_yes ();
#define PL_sv_yes (*_PL_sv_yes())


#undef PL_lex_casestack
EXTERN_C char * * _PL_lex_casestack ();
#define PL_lex_casestack (*_PL_lex_casestack())


#undef PL_No
EXTERN_C char * * _PL_No ();
#define PL_No (*_PL_No())


#undef PL_last_lop
EXTERN_C char * * _PL_last_lop ();
#define PL_last_lop (*_PL_last_lop())


START_EXTERN_C

#undef Perl_op_desc
char ** _Perl_op_desc ();
#define Perl_op_desc (_Perl_op_desc())

#undef Perl_op_name
char ** _Perl_op_name ();
#define Perl_op_name (_Perl_op_name())

#undef Perl_no_modify
char * _Perl_no_modify ();
#define Perl_no_modify (_Perl_no_modify())

#undef Perl_opargs
U32 * _Perl_opargs ();
#define Perl_opargs (_Perl_opargs())


#undef win32_errno
#undef win32_stdin
#undef win32_stdout
#undef win32_stderr
#undef win32_ferror
#undef win32_feof
#undef win32_fprintf
#undef win32_printf
#undef win32_vfprintf
#undef win32_vprintf
#undef win32_fread
#undef win32_fwrite
#undef win32_fopen
#undef win32_fdopen
#undef win32_freopen
#undef win32_fclose
#undef win32_fputs
#undef win32_fputc
#undef win32_ungetc
#undef win32_getc
#undef win32_fileno
#undef win32_clearerr
#undef win32_fflush
#undef win32_ftell
#undef win32_fseek
#undef win32_fgetpos
#undef win32_fsetpos
#undef win32_rewind
#undef win32_tmpfile
#undef win32_abort
#undef win32_fstat
#undef win32_stat
#undef win32_pipe
#undef win32_popen
#undef win32_pclose
#undef win32_rename
#undef win32_setmode
#undef win32_lseek
#undef win32_tell
#undef win32_dup
#undef win32_dup2
#undef win32_open
#undef win32_close
#undef win32_eof
#undef win32_read
#undef win32_write
#undef win32_mkdir
#undef win32_rmdir
#undef win32_chdir
#undef win32_setbuf
#undef win32_setvbuf
#undef win32_fgetc
#undef win32_fgets
#undef win32_gets
#undef win32_putc
#undef win32_puts
#undef win32_getchar
#undef win32_putchar
#undef win32_malloc
#undef win32_calloc
#undef win32_realloc
#undef win32_free
#undef win32_sleep
#undef win32_times
#undef win32_stat
#undef win32_ioctl
#undef win32_utime
#undef win32_getenv

#undef win32_htonl
#undef win32_htons
#undef win32_ntohl
#undef win32_ntohs
#undef win32_inet_addr
#undef win32_inet_ntoa

#undef win32_socket
#undef win32_bind
#undef win32_listen
#undef win32_accept
#undef win32_connect
#undef win32_send
#undef win32_sendto
#undef win32_recv
#undef win32_recvfrom
#undef win32_shutdown
#undef win32_closesocket
#undef win32_ioctlsocket
#undef win32_setsockopt
#undef win32_getsockopt
#undef win32_getpeername
#undef win32_getsockname
#undef win32_gethostname
#undef win32_gethostbyname
#undef win32_gethostbyaddr
#undef win32_getprotobyname
#undef win32_getprotobynumber
#undef win32_getservbyname
#undef win32_getservbyport
#undef win32_select
#undef win32_endhostent
#undef win32_endnetent
#undef win32_endprotoent
#undef win32_endservent
#undef win32_getnetent
#undef win32_getnetbyname
#undef win32_getnetbyaddr
#undef win32_getprotoent
#undef win32_getservent
#undef win32_sethostent
#undef win32_setnetent
#undef win32_setprotoent
#undef win32_setservent

#define win32_errno    _win32_errno
#define win32_stdin    _win32_stdin
#define win32_stdout   _win32_stdout
#define win32_stderr   _win32_stderr
#define win32_ferror   _win32_ferror
#define win32_feof     _win32_feof
#define win32_strerror _win32_strerror
#define win32_perror   _win32_perror
#define win32_fprintf  _win32_fprintf
#define win32_printf   _win32_printf
#define win32_vfprintf _win32_vfprintf
#define win32_vprintf  _win32_vprintf
#define win32_fread    _win32_fread
#define win32_fwrite   _win32_fwrite
#define win32_fopen    _win32_fopen
#define win32_fdopen   _win32_fdopen
#define win32_freopen  _win32_freopen
#define win32_fclose   _win32_fclose
#define win32_fputs    _win32_fputs
#define win32_fputc    _win32_fputc
#define win32_ungetc   _win32_ungetc
#define win32_getc     _win32_getc
#define win32_fileno   _win32_fileno
#define win32_clearerr _win32_clearerr
#define win32_fflush   _win32_fflush
#define win32_ftell    _win32_ftell
#define win32_fseek    _win32_fseek
#define win32_fgetpos  _win32_fgetpos
#define win32_fsetpos  _win32_fsetpos
#define win32_rewind   _win32_rewind
#define win32_tmpfile  _win32_tmpfile
#define win32_abort    _win32_abort
#define win32_fstat    _win32_fstat
#define win32_stat     _win32_stat
#define win32_pipe     _win32_pipe
#define win32_popen    _win32_popen
#define win32_pclose   _win32_pclose
#define win32_rename   _win32_rename
#define win32_setmode  _win32_setmode
#define win32_lseek    _win32_lseek
#define win32_tell     _win32_tell
#define win32_dup      _win32_dup
#define win32_dup2     _win32_dup2
#define win32_open     _win32_open
#define win32_close    _win32_close
#define win32_eof      _win32_eof
#define win32_read     _win32_read
#define win32_write    _win32_write
#define win32_mkdir    _win32_mkdir
#define win32_rmdir    _win32_rmdir
#define win32_chdir    _win32_chdir
#define win32_setbuf   _win32_setbuf
#define win32_setvbuf  _win32_setvbuf
#define win32_fgetc    _win32_fgetc
#define win32_fgets    _win32_fgets
#define win32_gets     _win32_gets
#define win32_putc     _win32_putc
#define win32_puts     _win32_puts
#define win32_getchar  _win32_getchar
#define win32_putchar  _win32_putchar
#define win32_malloc   _win32_malloc
#define win32_calloc   _win32_calloc
#define win32_realloc  _win32_realloc
#define win32_free     _win32_free
#define win32_sleep    _win32_sleep
#define win32_spawnvp  _win32_spawnvp
#define win32_times    _win32_times
#define win32_stat     _win32_stat
#define win32_ioctl    _win32_ioctl
#define win32_utime    _win32_utime
#define win32_getenv   _win32_getenv
#define win32_open_osfhandle _win32_open_osfhandle
#define win32_get_osfhandle  _win32_get_osfhandle

#define win32_htonl              _win32_htonl
#define win32_htons              _win32_htons
#define win32_ntohl              _win32_ntohl
#define win32_ntohs              _win32_ntohs
#define win32_inet_addr          _win32_inet_addr
#define win32_inet_ntoa          _win32_inet_ntoa

#define win32_socket             _win32_socket
#define win32_bind               _win32_bind
#define win32_listen             _win32_listen
#define win32_accept             _win32_accept
#define win32_connect            _win32_connect
#define win32_send               _win32_send
#define win32_sendto             _win32_sendto
#define win32_recv               _win32_recv
#define win32_recvfrom           _win32_recvfrom
#define win32_shutdown           _win32_shutdown
#define win32_closesocket        _win32_closesocket
#define win32_ioctlsocket        _win32_ioctlsocket
#define win32_setsockopt         _win32_setsockopt
#define win32_getsockopt         _win32_getsockopt
#define win32_getpeername        _win32_getpeername
#define win32_getsockname        _win32_getsockname
#define win32_gethostname        _win32_gethostname
#define win32_gethostbyname      _win32_gethostbyname
#define win32_gethostbyaddr      _win32_gethostbyaddr
#define win32_getprotobyname     _win32_getprotobyname
#define win32_getprotobynumber   _win32_getprotobynumber
#define win32_getservbyname      _win32_getservbyname
#define win32_getservbyport      _win32_getservbyport
#define win32_select             _win32_select
#define win32_endhostent         _win32_endhostent
#define win32_endnetent          _win32_endnetent
#define win32_endprotoent        _win32_endprotoent
#define win32_endservent         _win32_endservent
#define win32_getnetent          _win32_getnetent
#define win32_getnetbyname       _win32_getnetbyname
#define win32_getnetbyaddr       _win32_getnetbyaddr
#define win32_getprotoent        _win32_getprotoent
#define win32_getservent         _win32_getservent
#define win32_sethostent         _win32_sethostent
#define win32_setnetent          _win32_setnetent
#define win32_setprotoent        _win32_setprotoent
#define win32_setservent         _win32_setservent

int * 	_win32_errno(void);
FILE*	_win32_stdin(void);
FILE*	_win32_stdout(void);
FILE*	_win32_stderr(void);
int	_win32_ferror(FILE *fp);
int	_win32_feof(FILE *fp);
char*	_win32_strerror(int e);
void    _win32_perror(const char *str);
int	_win32_fprintf(FILE *pf, const char *format, ...);
int	_win32_printf(const char *format, ...);
int	_win32_vfprintf(FILE *pf, const char *format, va_list arg);
int	_win32_vprintf(const char *format, va_list arg);
size_t	_win32_fread(void *buf, size_t size, size_t count, FILE *pf);
size_t	_win32_fwrite(const void *buf, size_t size, size_t count, FILE *pf);
FILE*	_win32_fopen(const char *path, const char *mode);
FILE*	_win32_fdopen(int fh, const char *mode);
FILE*	_win32_freopen(const char *path, const char *mode, FILE *pf);
int	_win32_fclose(FILE *pf);
int	_win32_fputs(const char *s,FILE *pf);
int	_win32_fputc(int c,FILE *pf);
int	_win32_ungetc(int c,FILE *pf);
int	_win32_getc(FILE *pf);
int	_win32_fileno(FILE *pf);
void	_win32_clearerr(FILE *pf);
int	_win32_fflush(FILE *pf);
long	_win32_ftell(FILE *pf);
int	_win32_fseek(FILE *pf,long offset,int origin);
int	_win32_fgetpos(FILE *pf,fpos_t *p);
int	_win32_fsetpos(FILE *pf,const fpos_t *p);
void	_win32_rewind(FILE *pf);
FILE*	_win32_tmpfile(void);
void	_win32_abort(void);
int  	_win32_fstat(int fd,struct stat *sbufptr);
int  	_win32_stat(const char *name,struct stat *sbufptr);
int	_win32_pipe( int *phandles, unsigned int psize, int textmode );
FILE*	_win32_popen( const char *command, const char *mode );
int	_win32_pclose( FILE *pf);
int	_win32_rename( const char *oldname, const char *newname);
int	_win32_setmode( int fd, int mode);
long	_win32_lseek( int fd, long offset, int origin);
long	_win32_tell( int fd);
int	_win32_dup( int fd);
int	_win32_dup2(int h1, int h2);
int	_win32_open(const char *path, int oflag,...);
int	_win32_close(int fd);
int	_win32_eof(int fd);
int	_win32_read(int fd, void *buf, unsigned int cnt);
int	_win32_write(int fd, const void *buf, unsigned int cnt);
int	_win32_mkdir(const char *dir, int mode);
int	_win32_rmdir(const char *dir);
int	_win32_chdir(const char *dir);
void	_win32_setbuf(FILE *pf, char *buf);
int	_win32_setvbuf(FILE *pf, char *buf, int type, size_t size);
char*	_win32_fgets(char *s, int n, FILE *pf);
char*	_win32_gets(char *s);
int	_win32_fgetc(FILE *pf);
int	_win32_putc(int c, FILE *pf);
int	_win32_puts(const char *s);
int	_win32_getchar(void);
int	_win32_putchar(int c);
void*	_win32_malloc(size_t size);
void*	_win32_calloc(size_t numitems, size_t size);
void*	_win32_realloc(void *block, size_t size);
void	_win32_free(void *block);
unsigned _win32_sleep(unsigned int);
int	_win32_spawnvp(int mode, const char *cmdname, const char *const *argv);
int	_win32_times(struct tms *timebuf);
int	_win32_stat(const char *path, struct stat *buf);
int	_win32_ioctl(int i, unsigned int u, char *data);
int	_win32_utime(const char *f, struct utimbuf *t);
char*   _win32_getenv(const char *name);
int     _win32_open_osfhandle(long handle, int flags);
long    _win32_get_osfhandle(int fd);

u_long _win32_htonl (u_long hostlong);
u_short _win32_htons (u_short hostshort);
u_long _win32_ntohl (u_long netlong);
u_short _win32_ntohs (u_short netshort);
unsigned long _win32_inet_addr (const char * cp);
char * _win32_inet_ntoa (struct in_addr in);

SOCKET _win32_socket (int af, int type, int protocol);
int _win32_bind (SOCKET s, const struct sockaddr *addr, int namelen);
int _win32_listen (SOCKET s, int backlog);
SOCKET _win32_accept (SOCKET s, struct sockaddr *addr, int *addrlen);
int _win32_connect (SOCKET s, const struct sockaddr *name, int namelen);
int _win32_send (SOCKET s, const char * buf, int len, int flags);
int _win32_sendto (SOCKET s, const char * buf, int len, int flags,
                       const struct sockaddr *to, int tolen);
int _win32_recv (SOCKET s, char * buf, int len, int flags);
int _win32_recvfrom (SOCKET s, char * buf, int len, int flags,
                         struct sockaddr *from, int * fromlen);
int _win32_shutdown (SOCKET s, int how);
int _win32_closesocket (SOCKET s);
int _win32_ioctlsocket (SOCKET s, long cmd, u_long *argp);
int _win32_setsockopt (SOCKET s, int level, int optname,
                           const char * optval, int optlen);
int _win32_getsockopt (SOCKET s, int level, int optname, char * optval, int *optlen);
int _win32_getpeername (SOCKET s, struct sockaddr *name, int * namelen);
int _win32_getsockname (SOCKET s, struct sockaddr *name, int * namelen);
int _win32_gethostname (char * name, int namelen);
struct hostent * _win32_gethostbyname(const char * name);
struct hostent * _win32_gethostbyaddr(const char * addr, int len, int type);
struct protoent * _win32_getprotobyname(const char * name);
struct protoent * _win32_getprotobynumber(int proto);
struct servent * _win32_getservbyname(const char * name, const char * proto);
struct servent * _win32_getservbyport(int port, const char * proto);
int _win32_select (int nfds, Perl_fd_set *rfds, Perl_fd_set *wfds, Perl_fd_set *xfds,
		  const struct timeval *timeout);
void _win32_endnetent(void);
void _win32_endhostent(void);
void _win32_endprotoent(void);
void _win32_endservent(void);
struct netent * _win32_getnetent(void);
struct netent * _win32_getnetbyname(char *name);
struct netent * _win32_getnetbyaddr(long net, int type);
struct protoent *_win32_getprotoent(void);
struct servent *_win32_getservent(void);
void _win32_sethostent(int stayopen);
void _win32_setnetent(int stayopen);
void _win32_setprotoent(int stayopen);
void _win32_setservent(int stayopen);

END_EXTERN_C

#pragma warning(once : 4113)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlez.h ===
//
//	PerlEz.h
//
//  (c) 1998 ActiveState Tool Corp. All rights reserved. 
//


#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(PERLEZHANDLE);

enum
{
	plezNoError = 0,		// success
	plezMoreSpace,			// more space need to return result
	plezError,				// returned error string in buffer
	plezErrorMoreSpace,		// more space need to return error message
	plezErrorBadFormat,		// format string is invalid
	plezException,			// function call caused an exception
	plezInvalidHandle,		// hHandle was invalid
	plezCallbackAlreadySet,	// second call to PerlEzSetMagicFunction fails
	plezInvalidParams,		// invalid parameter was passed to a routine
	plezOutOfMemory,		// cannot allocate more memory
};


PERLEZHANDLE APIENTRY PerlEzCreate(LPCSTR lpFileName, LPCSTR lpOptions);
// Description:
//		Creates a Perl interpreter. The return value is required parameter
//		for all subsequent PerlEz calls.  Multiple interpreters can be created,
//		but only one will be executing at a time.
//		Call PerlEzDelete to release this handle.
//
// Parameters:
//		lpFileName a pointer to a ASCIIZ string that is the name of a file; can be NULL 
//		lpOptions a pointer to a ASCIIZ string that are the command line options that
//			will be provided before the script; can be NULL.
//			This parameter is used for setting @INC or debugging. 
//
// Returns:
//		A non zero handle to a Perl interpreter if successful; zero otherwise.


PERLEZHANDLE APIENTRY PerlEzCreateOpt(LPCSTR lpFileName, LPCSTR lpOptions, LPCSTR lpScriptOpts);
// Description:
//		Creates a Perl interpreter. The return value is required parameter
//		for all subsequent PerlEz calls.  Multiple interpreters can be created,
//		but only one will be executing at a time.
//		Call PerlEzDelete to release this handle.
//
// Parameters:
//		lpFileName a pointer to a ASCIIZ string that is the name of a file; can not be NULL 
//		lpOptions a pointer to a ASCIIZ string that are the command line options that
//			will be provided before the script; can be NULL.
//			This parameter is used for setting @INC or debugging. 
//		lpScriptOpts a pointer to a ASCIIZ string that are the command line options to be
//			passed to the script.
//
// Returns:
//		A non zero handle to a Perl interpreter if successful; zero otherwise.


BOOL APIENTRY PerlEzDelete(PERLEZHANDLE hHandle);
// Description:
//		Deletes a previously created Perl interpreter.
//		Releases all resources allocated by PerlEzCreate.
//
// Parameters:
//		hHandle	a handle returned by the call to PerlEzCreate
//
// Returns:
//		True if no error false otherwise.


int APIENTRY PerlEzEvalString(PERLEZHANDLE hHandle, LPCSTR lpString, LPSTR lpBuffer, DWORD dwBufSize);
// Description:
//		Evaluates the string a returns the result in lpBuffer.
//		If there is an error $! is returned in lpBuffer.
//
// Parameters:
//		hHandle	a handle returned by the call to PerlEzCreate
//		lpString a pointer to the ASCIIZ string to evaluate
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace


int APIENTRY PerlEzCall1(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize, LPCSTR lpFormat, LPVOID lpVoid);
// Description:
//		Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//		hHandle	a handle returned by the call to PerlEzCreate
//		lpFunction a pointer name of the function to call
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//		lpFormat a pointer to the parameter specifier; can be NULL. See L</"Format String">
//		lpVoid a pointer to a parameter will be interpreted based on lpFormat
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace
//		plezErrorBadFormat


int APIENTRY PerlEzCall2(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize,
					LPCSTR lpFormat, LPVOID lpVoid1, LPVOID lpVoid2);
// Description:
//		Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//		hHandle	a handle returned by the call to PerlEzCreate
//		lpFunction a pointer name of the function to call
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//		lpFormat a pointer to the parameter specifier; can be NULL. See L</"Format String">
//		lpVoid1...2 pointers to parameters that will be interpreted based on lpFormat
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace
//		plezErrorBadFormat


int APIENTRY PerlEzCall4(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize,
				LPCSTR lpFormat, LPVOID lpVoid1, LPVOID lpVoid2, LPVOID lpVoid3, LPVOID lpVoid4);
// Description:
//		Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//		hHandle	a handle returned by the call to PerlEzCreate
//		lpFunction a pointer name of the function to call
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//		lpFormat a pointer to the parameter specifier; can be NULL. See L</"Format String">
//		lpVoid1...4 pointers to parameters that will be interpreted based on lpFormat
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace
//		plezErrorBadFormat


int APIENTRY PerlEzCall8(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize,
				LPCSTR lpFormat, LPVOID lpVoid1, LPVOID lpVoid2, LPVOID lpVoid3, LPVOID lpVoid4,
				LPVOID lpVoid5, LPVOID lpVoid6, LPVOID lpVoid7, LPVOID lpVoid8);
// Description:
//		Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//		hHandle	a handle returned by the call to PerlEzCreate
//		lpFunction a pointer name of the function to call
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//		lpFormat a pointer to the parameter specifier; can be NULL. See L</"Format String">
//		lpVoid1...8 pointers to parameters that will be interpreted based on lpFormat
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace
//		plezErrorBadFormat


int APIENTRY PerlEzCall(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize, LPCSTR lpFormat, ...);
// Description:
//		Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//		hHandle a handle returned by the call to PerlEzCreate
//		lpFunction a pointer name of the function to call
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//		lpFormat a pointer to the parameter specifier; can be NULL. See L</"Format String">
//		... parameters to be interpreted based on lpFormat
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace
//		plezErrorBadFormat


int APIENTRY PerlEzCallContext(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPVOID lpContextInfo,
						LPSTR lpBuffer, DWORD dwBufSize, LPCSTR lpFormat, ...);
// Description:
//		Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//		hHandle a handle returned by the call to PerlEzCreate
//		lpFunction a pointer name of the function to call
//		lpContextInfo context info for magic fetch and store functions
//		lpBuffer a pointer to the buffer where the result will be placed
//		dwBufSize the size in bytes of the space where lpBuffer points
//		lpFormat a pointer to the parameter specifier; can be NULL. See L</"Format String">
//		... parameters to be interpreted based on lpFormat
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace
//		plezErrorBadFormat


typedef LPCSTR (*LPFETCHVALUEFUNCTION)(LPVOID, LPCSTR);
typedef LPCSTR (*LPSTOREVALUEFUNCTION)(LPVOID, LPCSTR,LPCSTR);

int APIENTRY PerlEzSetMagicScalarFunctions(PERLEZHANDLE hHandle, LPFETCHVALUEFUNCTION lpfFetch, LPSTOREVALUEFUNCTION lpfStore);
// Description:
//		Sets the call back function pointers for magic scalar variables.
//
// Parameters:
//		hHandle a handle returned by the call to PerlEzCreate
//		lpfFetch a pointer to the call back function for fetching a string
//			if lpfFetch is NULL, then the scalar is write only
//		lpfStore a pointer to the call back function for storinging a string
//			if lpfStore is NULL, then the scalar is read only
//
//		if lpfFetch and lpfStore are both NULL, then it is an error
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezCallbackAlreadySet
//		plezInvalidParams


int APIENTRY PerlEzSetMagicScalarName(PERLEZHANDLE hHandle, LPCSTR pVariableName);
// Description:
//		Creates the variable if it does not exists and sets it to be tied to
//			the call back function pointer for magic variables.
//
// Parameters:
//		hHandle a handle returned by the call to PerlEzCreate
//		pVariableName a pointer to the name of the variable
//
// Returns:
//		A zero if no error; otherwise error code.
//
// Possible Error returns
//		plezException
//		plezInvalidHandle
//		plezErrorMoreSpace

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\opcode.h ===
#define pp_i_preinc pp_preinc
#define pp_i_predec pp_predec
#define pp_i_postinc pp_postinc
#define pp_i_postdec pp_postdec

typedef enum {
	OP_NULL,	/* 0 */
	OP_STUB,	/* 1 */
	OP_SCALAR,	/* 2 */
	OP_PUSHMARK,	/* 3 */
	OP_WANTARRAY,	/* 4 */
	OP_CONST,	/* 5 */
	OP_GVSV,	/* 6 */
	OP_GV,		/* 7 */
	OP_GELEM,	/* 8 */
	OP_PADSV,	/* 9 */
	OP_PADAV,	/* 10 */
	OP_PADHV,	/* 11 */
	OP_PADANY,	/* 12 */
	OP_PUSHRE,	/* 13 */
	OP_RV2GV,	/* 14 */
	OP_RV2SV,	/* 15 */
	OP_AV2ARYLEN,	/* 16 */
	OP_RV2CV,	/* 17 */
	OP_ANONCODE,	/* 18 */
	OP_PROTOTYPE,	/* 19 */
	OP_REFGEN,	/* 20 */
	OP_SREFGEN,	/* 21 */
	OP_REF,		/* 22 */
	OP_BLESS,	/* 23 */
	OP_BACKTICK,	/* 24 */
	OP_GLOB,	/* 25 */
	OP_READLINE,	/* 26 */
	OP_RCATLINE,	/* 27 */
	OP_REGCMAYBE,	/* 28 */
	OP_REGCRESET,	/* 29 */
	OP_REGCOMP,	/* 30 */
	OP_MATCH,	/* 31 */
	OP_QR,		/* 32 */
	OP_SUBST,	/* 33 */
	OP_SUBSTCONT,	/* 34 */
	OP_TRANS,	/* 35 */
	OP_SASSIGN,	/* 36 */
	OP_AASSIGN,	/* 37 */
	OP_CHOP,	/* 38 */
	OP_SCHOP,	/* 39 */
	OP_CHOMP,	/* 40 */
	OP_SCHOMP,	/* 41 */
	OP_DEFINED,	/* 42 */
	OP_UNDEF,	/* 43 */
	OP_STUDY,	/* 44 */
	OP_POS,		/* 45 */
	OP_PREINC,	/* 46 */
	OP_I_PREINC,	/* 47 */
	OP_PREDEC,	/* 48 */
	OP_I_PREDEC,	/* 49 */
	OP_POSTINC,	/* 50 */
	OP_I_POSTINC,	/* 51 */
	OP_POSTDEC,	/* 52 */
	OP_I_POSTDEC,	/* 53 */
	OP_POW,		/* 54 */
	OP_MULTIPLY,	/* 55 */
	OP_I_MULTIPLY,	/* 56 */
	OP_DIVIDE,	/* 57 */
	OP_I_DIVIDE,	/* 58 */
	OP_MODULO,	/* 59 */
	OP_I_MODULO,	/* 60 */
	OP_REPEAT,	/* 61 */
	OP_ADD,		/* 62 */
	OP_I_ADD,	/* 63 */
	OP_SUBTRACT,	/* 64 */
	OP_I_SUBTRACT,	/* 65 */
	OP_CONCAT,	/* 66 */
	OP_STRINGIFY,	/* 67 */
	OP_LEFT_SHIFT,	/* 68 */
	OP_RIGHT_SHIFT,	/* 69 */
	OP_LT,		/* 70 */
	OP_I_LT,	/* 71 */
	OP_GT,		/* 72 */
	OP_I_GT,	/* 73 */
	OP_LE,		/* 74 */
	OP_I_LE,	/* 75 */
	OP_GE,		/* 76 */
	OP_I_GE,	/* 77 */
	OP_EQ,		/* 78 */
	OP_I_EQ,	/* 79 */
	OP_NE,		/* 80 */
	OP_I_NE,	/* 81 */
	OP_NCMP,	/* 82 */
	OP_I_NCMP,	/* 83 */
	OP_SLT,		/* 84 */
	OP_SGT,		/* 85 */
	OP_SLE,		/* 86 */
	OP_SGE,		/* 87 */
	OP_SEQ,		/* 88 */
	OP_SNE,		/* 89 */
	OP_SCMP,	/* 90 */
	OP_BIT_AND,	/* 91 */
	OP_BIT_XOR,	/* 92 */
	OP_BIT_OR,	/* 93 */
	OP_NEGATE,	/* 94 */
	OP_I_NEGATE,	/* 95 */
	OP_NOT,		/* 96 */
	OP_COMPLEMENT,	/* 97 */
	OP_ATAN2,	/* 98 */
	OP_SIN,		/* 99 */
	OP_COS,		/* 100 */
	OP_RAND,	/* 101 */
	OP_SRAND,	/* 102 */
	OP_EXP,		/* 103 */
	OP_LOG,		/* 104 */
	OP_SQRT,	/* 105 */
	OP_INT,		/* 106 */
	OP_HEX,		/* 107 */
	OP_OCT,		/* 108 */
	OP_ABS,		/* 109 */
	OP_LENGTH,	/* 110 */
	OP_SUBSTR,	/* 111 */
	OP_VEC,		/* 112 */
	OP_INDEX,	/* 113 */
	OP_RINDEX,	/* 114 */
	OP_SPRINTF,	/* 115 */
	OP_FORMLINE,	/* 116 */
	OP_ORD,		/* 117 */
	OP_CHR,		/* 118 */
	OP_CRYPT,	/* 119 */
	OP_UCFIRST,	/* 120 */
	OP_LCFIRST,	/* 121 */
	OP_UC,		/* 122 */
	OP_LC,		/* 123 */
	OP_QUOTEMETA,	/* 124 */
	OP_RV2AV,	/* 125 */
	OP_AELEMFAST,	/* 126 */
	OP_AELEM,	/* 127 */
	OP_ASLICE,	/* 128 */
	OP_EACH,	/* 129 */
	OP_VALUES,	/* 130 */
	OP_KEYS,	/* 131 */
	OP_DELETE,	/* 132 */
	OP_EXISTS,	/* 133 */
	OP_RV2HV,	/* 134 */
	OP_HELEM,	/* 135 */
	OP_HSLICE,	/* 136 */
	OP_UNPACK,	/* 137 */
	OP_PACK,	/* 138 */
	OP_SPLIT,	/* 139 */
	OP_JOIN,	/* 140 */
	OP_LIST,	/* 141 */
	OP_LSLICE,	/* 142 */
	OP_ANONLIST,	/* 143 */
	OP_ANONHASH,	/* 144 */
	OP_SPLICE,	/* 145 */
	OP_PUSH,	/* 146 */
	OP_POP,		/* 147 */
	OP_SHIFT,	/* 148 */
	OP_UNSHIFT,	/* 149 */
	OP_SORT,	/* 150 */
	OP_REVERSE,	/* 151 */
	OP_GREPSTART,	/* 152 */
	OP_GREPWHILE,	/* 153 */
	OP_MAPSTART,	/* 154 */
	OP_MAPWHILE,	/* 155 */
	OP_RANGE,	/* 156 */
	OP_FLIP,	/* 157 */
	OP_FLOP,	/* 158 */
	OP_AND,		/* 159 */
	OP_OR,		/* 160 */
	OP_XOR,		/* 161 */
	OP_COND_EXPR,	/* 162 */
	OP_ANDASSIGN,	/* 163 */
	OP_ORASSIGN,	/* 164 */
	OP_METHOD,	/* 165 */
	OP_ENTERSUB,	/* 166 */
	OP_LEAVESUB,	/* 167 */
	OP_CALLER,	/* 168 */
	OP_WARN,	/* 169 */
	OP_DIE,		/* 170 */
	OP_RESET,	/* 171 */
	OP_LINESEQ,	/* 172 */
	OP_NEXTSTATE,	/* 173 */
	OP_DBSTATE,	/* 174 */
	OP_UNSTACK,	/* 175 */
	OP_ENTER,	/* 176 */
	OP_LEAVE,	/* 177 */
	OP_SCOPE,	/* 178 */
	OP_ENTERITER,	/* 179 */
	OP_ITER,	/* 180 */
	OP_ENTERLOOP,	/* 181 */
	OP_LEAVELOOP,	/* 182 */
	OP_RETURN,	/* 183 */
	OP_LAST,	/* 184 */
	OP_NEXT,	/* 185 */
	OP_REDO,	/* 186 */
	OP_DUMP,	/* 187 */
	OP_GOTO,	/* 188 */
	OP_EXIT,	/* 189 */
	OP_OPEN,	/* 190 */
	OP_CLOSE,	/* 191 */
	OP_PIPE_OP,	/* 192 */
	OP_FILENO,	/* 193 */
	OP_UMASK,	/* 194 */
	OP_BINMODE,	/* 195 */
	OP_TIE,		/* 196 */
	OP_UNTIE,	/* 197 */
	OP_TIED,	/* 198 */
	OP_DBMOPEN,	/* 199 */
	OP_DBMCLOSE,	/* 200 */
	OP_SSELECT,	/* 201 */
	OP_SELECT,	/* 202 */
	OP_GETC,	/* 203 */
	OP_READ,	/* 204 */
	OP_ENTERWRITE,	/* 205 */
	OP_LEAVEWRITE,	/* 206 */
	OP_PRTF,	/* 207 */
	OP_PRINT,	/* 208 */
	OP_SYSOPEN,	/* 209 */
	OP_SYSSEEK,	/* 210 */
	OP_SYSREAD,	/* 211 */
	OP_SYSWRITE,	/* 212 */
	OP_SEND,	/* 213 */
	OP_RECV,	/* 214 */
	OP_EOF,		/* 215 */
	OP_TELL,	/* 216 */
	OP_SEEK,	/* 217 */
	OP_TRUNCATE,	/* 218 */
	OP_FCNTL,	/* 219 */
	OP_IOCTL,	/* 220 */
	OP_FLOCK,	/* 221 */
	OP_SOCKET,	/* 222 */
	OP_SOCKPAIR,	/* 223 */
	OP_BIND,	/* 224 */
	OP_CONNECT,	/* 225 */
	OP_LISTEN,	/* 226 */
	OP_ACCEPT,	/* 227 */
	OP_SHUTDOWN,	/* 228 */
	OP_GSOCKOPT,	/* 229 */
	OP_SSOCKOPT,	/* 230 */
	OP_GETSOCKNAME,	/* 231 */
	OP_GETPEERNAME,	/* 232 */
	OP_LSTAT,	/* 233 */
	OP_STAT,	/* 234 */
	OP_FTRREAD,	/* 235 */
	OP_FTRWRITE,	/* 236 */
	OP_FTREXEC,	/* 237 */
	OP_FTEREAD,	/* 238 */
	OP_FTEWRITE,	/* 239 */
	OP_FTEEXEC,	/* 240 */
	OP_FTIS,	/* 241 */
	OP_FTEOWNED,	/* 242 */
	OP_FTROWNED,	/* 243 */
	OP_FTZERO,	/* 244 */
	OP_FTSIZE,	/* 245 */
	OP_FTMTIME,	/* 246 */
	OP_FTATIME,	/* 247 */
	OP_FTCTIME,	/* 248 */
	OP_FTSOCK,	/* 249 */
	OP_FTCHR,	/* 250 */
	OP_FTBLK,	/* 251 */
	OP_FTFILE,	/* 252 */
	OP_FTDIR,	/* 253 */
	OP_FTPIPE,	/* 254 */
	OP_FTLINK,	/* 255 */
	OP_FTSUID,	/* 256 */
	OP_FTSGID,	/* 257 */
	OP_FTSVTX,	/* 258 */
	OP_FTTTY,	/* 259 */
	OP_FTTEXT,	/* 260 */
	OP_FTBINARY,	/* 261 */
	OP_CHDIR,	/* 262 */
	OP_CHOWN,	/* 263 */
	OP_CHROOT,	/* 264 */
	OP_UNLINK,	/* 265 */
	OP_CHMOD,	/* 266 */
	OP_UTIME,	/* 267 */
	OP_RENAME,	/* 268 */
	OP_LINK,	/* 269 */
	OP_SYMLINK,	/* 270 */
	OP_READLINK,	/* 271 */
	OP_MKDIR,	/* 272 */
	OP_RMDIR,	/* 273 */
	OP_OPEN_DIR,	/* 274 */
	OP_READDIR,	/* 275 */
	OP_TELLDIR,	/* 276 */
	OP_SEEKDIR,	/* 277 */
	OP_REWINDDIR,	/* 278 */
	OP_CLOSEDIR,	/* 279 */
	OP_FORK,	/* 280 */
	OP_WAIT,	/* 281 */
	OP_WAITPID,	/* 282 */
	OP_SYSTEM,	/* 283 */
	OP_EXEC,	/* 284 */
	OP_KILL,	/* 285 */
	OP_GETPPID,	/* 286 */
	OP_GETPGRP,	/* 287 */
	OP_SETPGRP,	/* 288 */
	OP_GETPRIORITY,	/* 289 */
	OP_SETPRIORITY,	/* 290 */
	OP_TIME,	/* 291 */
	OP_TMS,		/* 292 */
	OP_LOCALTIME,	/* 293 */
	OP_GMTIME,	/* 294 */
	OP_ALARM,	/* 295 */
	OP_SLEEP,	/* 296 */
	OP_SHMGET,	/* 297 */
	OP_SHMCTL,	/* 298 */
	OP_SHMREAD,	/* 299 */
	OP_SHMWRITE,	/* 300 */
	OP_MSGGET,	/* 301 */
	OP_MSGCTL,	/* 302 */
	OP_MSGSND,	/* 303 */
	OP_MSGRCV,	/* 304 */
	OP_SEMGET,	/* 305 */
	OP_SEMCTL,	/* 306 */
	OP_SEMOP,	/* 307 */
	OP_REQUIRE,	/* 308 */
	OP_DOFILE,	/* 309 */
	OP_ENTEREVAL,	/* 310 */
	OP_LEAVEEVAL,	/* 311 */
	OP_ENTERTRY,	/* 312 */
	OP_LEAVETRY,	/* 313 */
	OP_GHBYNAME,	/* 314 */
	OP_GHBYADDR,	/* 315 */
	OP_GHOSTENT,	/* 316 */
	OP_GNBYNAME,	/* 317 */
	OP_GNBYADDR,	/* 318 */
	OP_GNETENT,	/* 319 */
	OP_GPBYNAME,	/* 320 */
	OP_GPBYNUMBER,	/* 321 */
	OP_GPROTOENT,	/* 322 */
	OP_GSBYNAME,	/* 323 */
	OP_GSBYPORT,	/* 324 */
	OP_GSERVENT,	/* 325 */
	OP_SHOSTENT,	/* 326 */
	OP_SNETENT,	/* 327 */
	OP_SPROTOENT,	/* 328 */
	OP_SSERVENT,	/* 329 */
	OP_EHOSTENT,	/* 330 */
	OP_ENETENT,	/* 331 */
	OP_EPROTOENT,	/* 332 */
	OP_ESERVENT,	/* 333 */
	OP_GPWNAM,	/* 334 */
	OP_GPWUID,	/* 335 */
	OP_GPWENT,	/* 336 */
	OP_SPWENT,	/* 337 */
	OP_EPWENT,	/* 338 */
	OP_GGRNAM,	/* 339 */
	OP_GGRGID,	/* 340 */
	OP_GGRENT,	/* 341 */
	OP_SGRENT,	/* 342 */
	OP_EGRENT,	/* 343 */
	OP_GETLOGIN,	/* 344 */
	OP_SYSCALL,	/* 345 */
	OP_LOCK,	/* 346 */
	OP_THREADSV,	/* 347 */
	OP_max		
} opcode;

#define MAXO 348

#ifndef DOINIT
EXT char *op_name[];
#else
EXT char *op_name[] = {
	"null",
	"stub",
	"scalar",
	"pushmark",
	"wantarray",
	"const",
	"gvsv",
	"gv",
	"gelem",
	"padsv",
	"padav",
	"padhv",
	"padany",
	"pushre",
	"rv2gv",
	"rv2sv",
	"av2arylen",
	"rv2cv",
	"anoncode",
	"prototype",
	"refgen",
	"srefgen",
	"ref",
	"bless",
	"backtick",
	"glob",
	"readline",
	"rcatline",
	"regcmaybe",
	"regcreset",
	"regcomp",
	"match",
	"qr",
	"subst",
	"substcont",
	"trans",
	"sassign",
	"aassign",
	"chop",
	"schop",
	"chomp",
	"schomp",
	"defined",
	"undef",
	"study",
	"pos",
	"preinc",
	"i_preinc",
	"predec",
	"i_predec",
	"postinc",
	"i_postinc",
	"postdec",
	"i_postdec",
	"pow",
	"multiply",
	"i_multiply",
	"divide",
	"i_divide",
	"modulo",
	"i_modulo",
	"repeat",
	"add",
	"i_add",
	"subtract",
	"i_subtract",
	"concat",
	"stringify",
	"left_shift",
	"right_shift",
	"lt",
	"i_lt",
	"gt",
	"i_gt",
	"le",
	"i_le",
	"ge",
	"i_ge",
	"eq",
	"i_eq",
	"ne",
	"i_ne",
	"ncmp",
	"i_ncmp",
	"slt",
	"sgt",
	"sle",
	"sge",
	"seq",
	"sne",
	"scmp",
	"bit_and",
	"bit_xor",
	"bit_or",
	"negate",
	"i_negate",
	"not",
	"complement",
	"atan2",
	"sin",
	"cos",
	"rand",
	"srand",
	"exp",
	"log",
	"sqrt",
	"int",
	"hex",
	"oct",
	"abs",
	"length",
	"substr",
	"vec",
	"index",
	"rindex",
	"sprintf",
	"formline",
	"ord",
	"chr",
	"crypt",
	"ucfirst",
	"lcfirst",
	"uc",
	"lc",
	"quotemeta",
	"rv2av",
	"aelemfast",
	"aelem",
	"aslice",
	"each",
	"values",
	"keys",
	"delete",
	"exists",
	"rv2hv",
	"helem",
	"hslice",
	"unpack",
	"pack",
	"split",
	"join",
	"list",
	"lslice",
	"anonlist",
	"anonhash",
	"splice",
	"push",
	"pop",
	"shift",
	"unshift",
	"sort",
	"reverse",
	"grepstart",
	"grepwhile",
	"mapstart",
	"mapwhile",
	"range",
	"flip",
	"flop",
	"and",
	"or",
	"xor",
	"cond_expr",
	"andassign",
	"orassign",
	"method",
	"entersub",
	"leavesub",
	"caller",
	"warn",
	"die",
	"reset",
	"lineseq",
	"nextstate",
	"dbstate",
	"unstack",
	"enter",
	"leave",
	"scope",
	"enteriter",
	"iter",
	"enterloop",
	"leaveloop",
	"return",
	"last",
	"next",
	"redo",
	"dump",
	"goto",
	"exit",
	"open",
	"close",
	"pipe_op",
	"fileno",
	"umask",
	"binmode",
	"tie",
	"untie",
	"tied",
	"dbmopen",
	"dbmclose",
	"sselect",
	"select",
	"getc",
	"read",
	"enterwrite",
	"leavewrite",
	"prtf",
	"print",
	"sysopen",
	"sysseek",
	"sysread",
	"syswrite",
	"send",
	"recv",
	"eof",
	"tell",
	"seek",
	"truncate",
	"fcntl",
	"ioctl",
	"flock",
	"socket",
	"sockpair",
	"bind",
	"connect",
	"listen",
	"accept",
	"shutdown",
	"gsockopt",
	"ssockopt",
	"getsockname",
	"getpeername",
	"lstat",
	"stat",
	"ftrread",
	"ftrwrite",
	"ftrexec",
	"fteread",
	"ftewrite",
	"fteexec",
	"ftis",
	"fteowned",
	"ftrowned",
	"ftzero",
	"ftsize",
	"ftmtime",
	"ftatime",
	"ftctime",
	"ftsock",
	"ftchr",
	"ftblk",
	"ftfile",
	"ftdir",
	"ftpipe",
	"ftlink",
	"ftsuid",
	"ftsgid",
	"ftsvtx",
	"fttty",
	"fttext",
	"ftbinary",
	"chdir",
	"chown",
	"chroot",
	"unlink",
	"chmod",
	"utime",
	"rename",
	"link",
	"symlink",
	"readlink",
	"mkdir",
	"rmdir",
	"open_dir",
	"readdir",
	"telldir",
	"seekdir",
	"rewinddir",
	"closedir",
	"fork",
	"wait",
	"waitpid",
	"system",
	"exec",
	"kill",
	"getppid",
	"getpgrp",
	"setpgrp",
	"getpriority",
	"setpriority",
	"time",
	"tms",
	"localtime",
	"gmtime",
	"alarm",
	"sleep",
	"shmget",
	"shmctl",
	"shmread",
	"shmwrite",
	"msgget",
	"msgctl",
	"msgsnd",
	"msgrcv",
	"semget",
	"semctl",
	"semop",
	"require",
	"dofile",
	"entereval",
	"leaveeval",
	"entertry",
	"leavetry",
	"ghbyname",
	"ghbyaddr",
	"ghostent",
	"gnbyname",
	"gnbyaddr",
	"gnetent",
	"gpbyname",
	"gpbynumber",
	"gprotoent",
	"gsbyname",
	"gsbyport",
	"gservent",
	"shostent",
	"snetent",
	"sprotoent",
	"sservent",
	"ehostent",
	"enetent",
	"eprotoent",
	"eservent",
	"gpwnam",
	"gpwuid",
	"gpwent",
	"spwent",
	"epwent",
	"ggrnam",
	"ggrgid",
	"ggrent",
	"sgrent",
	"egrent",
	"getlogin",
	"syscall",
	"lock",
	"threadsv",
};
#endif

#ifndef DOINIT
EXT char *op_desc[];
#else
EXT char *op_desc[] = {
	"null operation",
	"stub",
	"scalar",
	"pushmark",
	"wantarray",
	"constant item",
	"scalar variable",
	"glob value",
	"glob elem",
	"private variable",
	"private array",
	"private hash",
	"private something",
	"push regexp",
	"ref-to-glob cast",
	"scalar deref",
	"array length",
	"subroutine deref",
	"anonymous subroutine",
	"subroutine prototype",
	"reference constructor",
	"scalar ref constructor",
	"reference-type operator",
	"bless",
	"backticks",
	"glob",
	"<HANDLE>",
	"append I/O operator",
	"regexp comp once",
	"regexp reset interpolation flag",
	"regexp compilation",
	"pattern match",
	"pattern quote",
	"substitution",
	"substitution cont",
	"character translation",
	"scalar assignment",
	"list assignment",
	"chop",
	"scalar chop",
	"safe chop",
	"scalar safe chop",
	"defined operator",
	"undef operator",
	"study",
	"match position",
	"preincrement",
	"integer preincrement",
	"predecrement",
	"integer predecrement",
	"postincrement",
	"integer postincrement",
	"postdecrement",
	"integer postdecrement",
	"exponentiation",
	"multiplication",
	"integer multiplication",
	"division",
	"integer division",
	"modulus",
	"integer modulus",
	"repeat",
	"addition",
	"integer addition",
	"subtraction",
	"integer subtraction",
	"concatenation",
	"string",
	"left bitshift",
	"right bitshift",
	"numeric lt",
	"integer lt",
	"numeric gt",
	"integer gt",
	"numeric le",
	"integer le",
	"numeric ge",
	"integer ge",
	"numeric eq",
	"integer eq",
	"numeric ne",
	"integer ne",
	"spaceship operator",
	"integer spaceship",
	"string lt",
	"string gt",
	"string le",
	"string ge",
	"string eq",
	"string ne",
	"string comparison",
	"bitwise and",
	"bitwise xor",
	"bitwise or",
	"negate",
	"integer negate",
	"not",
	"1's complement",
	"atan2",
	"sin",
	"cos",
	"rand",
	"srand",
	"exp",
	"log",
	"sqrt",
	"int",
	"hex",
	"oct",
	"abs",
	"length",
	"substr",
	"vec",
	"index",
	"rindex",
	"sprintf",
	"formline",
	"ord",
	"chr",
	"crypt",
	"upper case first",
	"lower case first",
	"upper case",
	"lower case",
	"quote metachars",
	"array deref",
	"known array element",
	"array element",
	"array slice",
	"each",
	"values",
	"keys",
	"delete",
	"exists operator",
	"hash deref",
	"hash elem",
	"hash slice",
	"unpack",
	"pack",
	"split",
	"join",
	"list",
	"list slice",
	"anonymous list",
	"anonymous hash",
	"splice",
	"push",
	"pop",
	"shift",
	"unshift",
	"sort",
	"reverse",
	"grep",
	"grep iterator",
	"map",
	"map iterator",
	"flipflop",
	"range (or flip)",
	"range (or flop)",
	"logical and",
	"logical or",
	"logical xor",
	"conditional expression",
	"logical and assignment",
	"logical or assignment",
	"method lookup",
	"subroutine entry",
	"subroutine exit",
	"caller",
	"warn",
	"die",
	"reset",
	"line sequence",
	"next statement",
	"debug next statement",
	"iteration finalizer",
	"block entry",
	"block exit",
	"block",
	"foreach loop entry",
	"foreach loop iterator",
	"loop entry",
	"loop exit",
	"return",
	"last",
	"next",
	"redo",
	"dump",
	"goto",
	"exit",
	"open",
	"close",
	"pipe",
	"fileno",
	"umask",
	"binmode",
	"tie",
	"untie",
	"tied",
	"dbmopen",
	"dbmclose",
	"select system call",
	"select",
	"getc",
	"read",
	"write",
	"write exit",
	"printf",
	"print",
	"sysopen",
	"sysseek",
	"sysread",
	"syswrite",
	"send",
	"recv",
	"eof",
	"tell",
	"seek",
	"truncate",
	"fcntl",
	"ioctl",
	"flock",
	"socket",
	"socketpair",
	"bind",
	"connect",
	"listen",
	"accept",
	"shutdown",
	"getsockopt",
	"setsockopt",
	"getsockname",
	"getpeername",
	"lstat",
	"stat",
	"-R",
	"-W",
	"-X",
	"-r",
	"-w",
	"-x",
	"-e",
	"-O",
	"-o",
	"-z",
	"-s",
	"-M",
	"-A",
	"-C",
	"-S",
	"-c",
	"-b",
	"-f",
	"-d",
	"-p",
	"-l",
	"-u",
	"-g",
	"-k",
	"-t",
	"-T",
	"-B",
	"chdir",
	"chown",
	"chroot",
	"unlink",
	"chmod",
	"utime",
	"rename",
	"link",
	"symlink",
	"readlink",
	"mkdir",
	"rmdir",
	"opendir",
	"readdir",
	"telldir",
	"seekdir",
	"rewinddir",
	"closedir",
	"fork",
	"wait",
	"waitpid",
	"system",
	"exec",
	"kill",
	"getppid",
	"getpgrp",
	"setpgrp",
	"getpriority",
	"setpriority",
	"time",
	"times",
	"localtime",
	"gmtime",
	"alarm",
	"sleep",
	"shmget",
	"shmctl",
	"shmread",
	"shmwrite",
	"msgget",
	"msgctl",
	"msgsnd",
	"msgrcv",
	"semget",
	"semctl",
	"semop",
	"require",
	"do 'file'",
	"eval string",
	"eval exit",
	"eval block",
	"eval block exit",
	"gethostbyname",
	"gethostbyaddr",
	"gethostent",
	"getnetbyname",
	"getnetbyaddr",
	"getnetent",
	"getprotobyname",
	"getprotobynumber",
	"getprotoent",
	"getservbyname",
	"getservbyport",
	"getservent",
	"sethostent",
	"setnetent",
	"setprotoent",
	"setservent",
	"endhostent",
	"endnetent",
	"endprotoent",
	"endservent",
	"getpwnam",
	"getpwuid",
	"getpwent",
	"setpwent",
	"endpwent",
	"getgrnam",
	"getgrgid",
	"getgrent",
	"setgrent",
	"endgrent",
	"getlogin",
	"syscall",
	"lock",
	"per-thread variable",
};
#endif

#ifndef PERL_OBJECT
START_EXTERN_C

OP *	ck_anoncode	_((OP* o));
OP *	ck_bitop	_((OP* o));
OP *	ck_concat	_((OP* o));
OP *	ck_delete	_((OP* o));
OP *	ck_eof		_((OP* o));
OP *	ck_eval		_((OP* o));
OP *	ck_exec		_((OP* o));
OP *	ck_exists	_((OP* o));
OP *	ck_ftst		_((OP* o));
OP *	ck_fun		_((OP* o));
OP *	ck_fun_locale	_((OP* o));
OP *	ck_glob		_((OP* o));
OP *	ck_grep		_((OP* o));
OP *	ck_index	_((OP* o));
OP *	ck_lengthconst	_((OP* o));
OP *	ck_lfun		_((OP* o));
OP *	ck_listiob	_((OP* o));
OP *	ck_match	_((OP* o));
OP *	ck_null		_((OP* o));
OP *	ck_repeat	_((OP* o));
OP *	ck_require	_((OP* o));
OP *	ck_rfun		_((OP* o));
OP *	ck_rvconst	_((OP* o));
OP *	ck_scmp		_((OP* o));
OP *	ck_select	_((OP* o));
OP *	ck_shift	_((OP* o));
OP *	ck_sort		_((OP* o));
OP *	ck_spair	_((OP* o));
OP *	ck_split	_((OP* o));
OP *	ck_subr		_((OP* o));
OP *	ck_svconst	_((OP* o));
OP *	ck_trunc	_((OP* o));

OP *	pp_null		_((ARGSproto));
OP *	pp_stub		_((ARGSproto));
OP *	pp_scalar	_((ARGSproto));
OP *	pp_pushmark	_((ARGSproto));
OP *	pp_wantarray	_((ARGSproto));
OP *	pp_const	_((ARGSproto));
OP *	pp_gvsv		_((ARGSproto));
OP *	pp_gv		_((ARGSproto));
OP *	pp_gelem	_((ARGSproto));
OP *	pp_padsv	_((ARGSproto));
OP *	pp_padav	_((ARGSproto));
OP *	pp_padhv	_((ARGSproto));
OP *	pp_padany	_((ARGSproto));
OP *	pp_pushre	_((ARGSproto));
OP *	pp_rv2gv	_((ARGSproto));
OP *	pp_rv2sv	_((ARGSproto));
OP *	pp_av2arylen	_((ARGSproto));
OP *	pp_rv2cv	_((ARGSproto));
OP *	pp_anoncode	_((ARGSproto));
OP *	pp_prototype	_((ARGSproto));
OP *	pp_refgen	_((ARGSproto));
OP *	pp_srefgen	_((ARGSproto));
OP *	pp_ref		_((ARGSproto));
OP *	pp_bless	_((ARGSproto));
OP *	pp_backtick	_((ARGSproto));
OP *	pp_glob		_((ARGSproto));
OP *	pp_readline	_((ARGSproto));
OP *	pp_rcatline	_((ARGSproto));
OP *	pp_regcmaybe	_((ARGSproto));
OP *	pp_regcreset	_((ARGSproto));
OP *	pp_regcomp	_((ARGSproto));
OP *	pp_match	_((ARGSproto));
OP *	pp_qr		_((ARGSproto));
OP *	pp_subst	_((ARGSproto));
OP *	pp_substcont	_((ARGSproto));
OP *	pp_trans	_((ARGSproto));
OP *	pp_sassign	_((ARGSproto));
OP *	pp_aassign	_((ARGSproto));
OP *	pp_chop		_((ARGSproto));
OP *	pp_schop	_((ARGSproto));
OP *	pp_chomp	_((ARGSproto));
OP *	pp_schomp	_((ARGSproto));
OP *	pp_defined	_((ARGSproto));
OP *	pp_undef	_((ARGSproto));
OP *	pp_study	_((ARGSproto));
OP *	pp_pos		_((ARGSproto));
OP *	pp_preinc	_((ARGSproto));
OP *	pp_i_preinc	_((ARGSproto));
OP *	pp_predec	_((ARGSproto));
OP *	pp_i_predec	_((ARGSproto));
OP *	pp_postinc	_((ARGSproto));
OP *	pp_i_postinc	_((ARGSproto));
OP *	pp_postdec	_((ARGSproto));
OP *	pp_i_postdec	_((ARGSproto));
OP *	pp_pow		_((ARGSproto));
OP *	pp_multiply	_((ARGSproto));
OP *	pp_i_multiply	_((ARGSproto));
OP *	pp_divide	_((ARGSproto));
OP *	pp_i_divide	_((ARGSproto));
OP *	pp_modulo	_((ARGSproto));
OP *	pp_i_modulo	_((ARGSproto));
OP *	pp_repeat	_((ARGSproto));
OP *	pp_add		_((ARGSproto));
OP *	pp_i_add	_((ARGSproto));
OP *	pp_subtract	_((ARGSproto));
OP *	pp_i_subtract	_((ARGSproto));
OP *	pp_concat	_((ARGSproto));
OP *	pp_stringify	_((ARGSproto));
OP *	pp_left_shift	_((ARGSproto));
OP *	pp_right_shift	_((ARGSproto));
OP *	pp_lt		_((ARGSproto));
OP *	pp_i_lt		_((ARGSproto));
OP *	pp_gt		_((ARGSproto));
OP *	pp_i_gt		_((ARGSproto));
OP *	pp_le		_((ARGSproto));
OP *	pp_i_le		_((ARGSproto));
OP *	pp_ge		_((ARGSproto));
OP *	pp_i_ge		_((ARGSproto));
OP *	pp_eq		_((ARGSproto));
OP *	pp_i_eq		_((ARGSproto));
OP *	pp_ne		_((ARGSproto));
OP *	pp_i_ne		_((ARGSproto));
OP *	pp_ncmp		_((ARGSproto));
OP *	pp_i_ncmp	_((ARGSproto));
OP *	pp_slt		_((ARGSproto));
OP *	pp_sgt		_((ARGSproto));
OP *	pp_sle		_((ARGSproto));
OP *	pp_sge		_((ARGSproto));
OP *	pp_seq		_((ARGSproto));
OP *	pp_sne		_((ARGSproto));
OP *	pp_scmp		_((ARGSproto));
OP *	pp_bit_and	_((ARGSproto));
OP *	pp_bit_xor	_((ARGSproto));
OP *	pp_bit_or	_((ARGSproto));
OP *	pp_negate	_((ARGSproto));
OP *	pp_i_negate	_((ARGSproto));
OP *	pp_not		_((ARGSproto));
OP *	pp_complement	_((ARGSproto));
OP *	pp_atan2	_((ARGSproto));
OP *	pp_sin		_((ARGSproto));
OP *	pp_cos		_((ARGSproto));
OP *	pp_rand		_((ARGSproto));
OP *	pp_srand	_((ARGSproto));
OP *	pp_exp		_((ARGSproto));
OP *	pp_log		_((ARGSproto));
OP *	pp_sqrt		_((ARGSproto));
OP *	pp_int		_((ARGSproto));
OP *	pp_hex		_((ARGSproto));
OP *	pp_oct		_((ARGSproto));
OP *	pp_abs		_((ARGSproto));
OP *	pp_length	_((ARGSproto));
OP *	pp_substr	_((ARGSproto));
OP *	pp_vec		_((ARGSproto));
OP *	pp_index	_((ARGSproto));
OP *	pp_rindex	_((ARGSproto));
OP *	pp_sprintf	_((ARGSproto));
OP *	pp_formline	_((ARGSproto));
OP *	pp_ord		_((ARGSproto));
OP *	pp_chr		_((ARGSproto));
OP *	pp_crypt	_((ARGSproto));
OP *	pp_ucfirst	_((ARGSproto));
OP *	pp_lcfirst	_((ARGSproto));
OP *	pp_uc		_((ARGSproto));
OP *	pp_lc		_((ARGSproto));
OP *	pp_quotemeta	_((ARGSproto));
OP *	pp_rv2av	_((ARGSproto));
OP *	pp_aelemfast	_((ARGSproto));
OP *	pp_aelem	_((ARGSproto));
OP *	pp_aslice	_((ARGSproto));
OP *	pp_each		_((ARGSproto));
OP *	pp_values	_((ARGSproto));
OP *	pp_keys		_((ARGSproto));
OP *	pp_delete	_((ARGSproto));
OP *	pp_exists	_((ARGSproto));
OP *	pp_rv2hv	_((ARGSproto));
OP *	pp_helem	_((ARGSproto));
OP *	pp_hslice	_((ARGSproto));
OP *	pp_unpack	_((ARGSproto));
OP *	pp_pack		_((ARGSproto));
OP *	pp_split	_((ARGSproto));
OP *	pp_join		_((ARGSproto));
OP *	pp_list		_((ARGSproto));
OP *	pp_lslice	_((ARGSproto));
OP *	pp_anonlist	_((ARGSproto));
OP *	pp_anonhash	_((ARGSproto));
OP *	pp_splice	_((ARGSproto));
OP *	pp_push		_((ARGSproto));
OP *	pp_pop		_((ARGSproto));
OP *	pp_shift	_((ARGSproto));
OP *	pp_unshift	_((ARGSproto));
OP *	pp_sort		_((ARGSproto));
OP *	pp_reverse	_((ARGSproto));
OP *	pp_grepstart	_((ARGSproto));
OP *	pp_grepwhile	_((ARGSproto));
OP *	pp_mapstart	_((ARGSproto));
OP *	pp_mapwhile	_((ARGSproto));
OP *	pp_range	_((ARGSproto));
OP *	pp_flip		_((ARGSproto));
OP *	pp_flop		_((ARGSproto));
OP *	pp_and		_((ARGSproto));
OP *	pp_or		_((ARGSproto));
OP *	pp_xor		_((ARGSproto));
OP *	pp_cond_expr	_((ARGSproto));
OP *	pp_andassign	_((ARGSproto));
OP *	pp_orassign	_((ARGSproto));
OP *	pp_method	_((ARGSproto));
OP *	pp_entersub	_((ARGSproto));
OP *	pp_leavesub	_((ARGSproto));
OP *	pp_caller	_((ARGSproto));
OP *	pp_warn		_((ARGSproto));
OP *	pp_die		_((ARGSproto));
OP *	pp_reset	_((ARGSproto));
OP *	pp_lineseq	_((ARGSproto));
OP *	pp_nextstate	_((ARGSproto));
OP *	pp_dbstate	_((ARGSproto));
OP *	pp_unstack	_((ARGSproto));
OP *	pp_enter	_((ARGSproto));
OP *	pp_leave	_((ARGSproto));
OP *	pp_scope	_((ARGSproto));
OP *	pp_enteriter	_((ARGSproto));
OP *	pp_iter		_((ARGSproto));
OP *	pp_enterloop	_((ARGSproto));
OP *	pp_leaveloop	_((ARGSproto));
OP *	pp_return	_((ARGSproto));
OP *	pp_last		_((ARGSproto));
OP *	pp_next		_((ARGSproto));
OP *	pp_redo		_((ARGSproto));
OP *	pp_dump		_((ARGSproto));
OP *	pp_goto		_((ARGSproto));
OP *	pp_exit		_((ARGSproto));
OP *	pp_open		_((ARGSproto));
OP *	pp_close	_((ARGSproto));
OP *	pp_pipe_op	_((ARGSproto));
OP *	pp_fileno	_((ARGSproto));
OP *	pp_umask	_((ARGSproto));
OP *	pp_binmode	_((ARGSproto));
OP *	pp_tie		_((ARGSproto));
OP *	pp_untie	_((ARGSproto));
OP *	pp_tied		_((ARGSproto));
OP *	pp_dbmopen	_((ARGSproto));
OP *	pp_dbmclose	_((ARGSproto));
OP *	pp_sselect	_((ARGSproto));
OP *	pp_select	_((ARGSproto));
OP *	pp_getc		_((ARGSproto));
OP *	pp_read		_((ARGSproto));
OP *	pp_enterwrite	_((ARGSproto));
OP *	pp_leavewrite	_((ARGSproto));
OP *	pp_prtf		_((ARGSproto));
OP *	pp_print	_((ARGSproto));
OP *	pp_sysopen	_((ARGSproto));
OP *	pp_sysseek	_((ARGSproto));
OP *	pp_sysread	_((ARGSproto));
OP *	pp_syswrite	_((ARGSproto));
OP *	pp_send		_((ARGSproto));
OP *	pp_recv		_((ARGSproto));
OP *	pp_eof		_((ARGSproto));
OP *	pp_tell		_((ARGSproto));
OP *	pp_seek		_((ARGSproto));
OP *	pp_truncate	_((ARGSproto));
OP *	pp_fcntl	_((ARGSproto));
OP *	pp_ioctl	_((ARGSproto));
OP *	pp_flock	_((ARGSproto));
OP *	pp_socket	_((ARGSproto));
OP *	pp_sockpair	_((ARGSproto));
OP *	pp_bind		_((ARGSproto));
OP *	pp_connect	_((ARGSproto));
OP *	pp_listen	_((ARGSproto));
OP *	pp_accept	_((ARGSproto));
OP *	pp_shutdown	_((ARGSproto));
OP *	pp_gsockopt	_((ARGSproto));
OP *	pp_ssockopt	_((ARGSproto));
OP *	pp_getsockname	_((ARGSproto));
OP *	pp_getpeername	_((ARGSproto));
OP *	pp_lstat	_((ARGSproto));
OP *	pp_stat		_((ARGSproto));
OP *	pp_ftrread	_((ARGSproto));
OP *	pp_ftrwrite	_((ARGSproto));
OP *	pp_ftrexec	_((ARGSproto));
OP *	pp_fteread	_((ARGSproto));
OP *	pp_ftewrite	_((ARGSproto));
OP *	pp_fteexec	_((ARGSproto));
OP *	pp_ftis		_((ARGSproto));
OP *	pp_fteowned	_((ARGSproto));
OP *	pp_ftrowned	_((ARGSproto));
OP *	pp_ftzero	_((ARGSproto));
OP *	pp_ftsize	_((ARGSproto));
OP *	pp_ftmtime	_((ARGSproto));
OP *	pp_ftatime	_((ARGSproto));
OP *	pp_ftctime	_((ARGSproto));
OP *	pp_ftsock	_((ARGSproto));
OP *	pp_ftchr	_((ARGSproto));
OP *	pp_ftblk	_((ARGSproto));
OP *	pp_ftfile	_((ARGSproto));
OP *	pp_ftdir	_((ARGSproto));
OP *	pp_ftpipe	_((ARGSproto));
OP *	pp_ftlink	_((ARGSproto));
OP *	pp_ftsuid	_((ARGSproto));
OP *	pp_ftsgid	_((ARGSproto));
OP *	pp_ftsvtx	_((ARGSproto));
OP *	pp_fttty	_((ARGSproto));
OP *	pp_fttext	_((ARGSproto));
OP *	pp_ftbinary	_((ARGSproto));
OP *	pp_chdir	_((ARGSproto));
OP *	pp_chown	_((ARGSproto));
OP *	pp_chroot	_((ARGSproto));
OP *	pp_unlink	_((ARGSproto));
OP *	pp_chmod	_((ARGSproto));
OP *	pp_utime	_((ARGSproto));
OP *	pp_rename	_((ARGSproto));
OP *	pp_link		_((ARGSproto));
OP *	pp_symlink	_((ARGSproto));
OP *	pp_readlink	_((ARGSproto));
OP *	pp_mkdir	_((ARGSproto));
OP *	pp_rmdir	_((ARGSproto));
OP *	pp_open_dir	_((ARGSproto));
OP *	pp_readdir	_((ARGSproto));
OP *	pp_telldir	_((ARGSproto));
OP *	pp_seekdir	_((ARGSproto));
OP *	pp_rewinddir	_((ARGSproto));
OP *	pp_closedir	_((ARGSproto));
OP *	pp_fork		_((ARGSproto));
OP *	pp_wait		_((ARGSproto));
OP *	pp_waitpid	_((ARGSproto));
OP *	pp_system	_((ARGSproto));
OP *	pp_exec		_((ARGSproto));
OP *	pp_kill		_((ARGSproto));
OP *	pp_getppid	_((ARGSproto));
OP *	pp_getpgrp	_((ARGSproto));
OP *	pp_setpgrp	_((ARGSproto));
OP *	pp_getpriority	_((ARGSproto));
OP *	pp_setpriority	_((ARGSproto));
OP *	pp_time		_((ARGSproto));
OP *	pp_tms		_((ARGSproto));
OP *	pp_localtime	_((ARGSproto));
OP *	pp_gmtime	_((ARGSproto));
OP *	pp_alarm	_((ARGSproto));
OP *	pp_sleep	_((ARGSproto));
OP *	pp_shmget	_((ARGSproto));
OP *	pp_shmctl	_((ARGSproto));
OP *	pp_shmread	_((ARGSproto));
OP *	pp_shmwrite	_((ARGSproto));
OP *	pp_msgget	_((ARGSproto));
OP *	pp_msgctl	_((ARGSproto));
OP *	pp_msgsnd	_((ARGSproto));
OP *	pp_msgrcv	_((ARGSproto));
OP *	pp_semget	_((ARGSproto));
OP *	pp_semctl	_((ARGSproto));
OP *	pp_semop	_((ARGSproto));
OP *	pp_require	_((ARGSproto));
OP *	pp_dofile	_((ARGSproto));
OP *	pp_entereval	_((ARGSproto));
OP *	pp_leaveeval	_((ARGSproto));
OP *	pp_entertry	_((ARGSproto));
OP *	pp_leavetry	_((ARGSproto));
OP *	pp_ghbyname	_((ARGSproto));
OP *	pp_ghbyaddr	_((ARGSproto));
OP *	pp_ghostent	_((ARGSproto));
OP *	pp_gnbyname	_((ARGSproto));
OP *	pp_gnbyaddr	_((ARGSproto));
OP *	pp_gnetent	_((ARGSproto));
OP *	pp_gpbyname	_((ARGSproto));
OP *	pp_gpbynumber	_((ARGSproto));
OP *	pp_gprotoent	_((ARGSproto));
OP *	pp_gsbyname	_((ARGSproto));
OP *	pp_gsbyport	_((ARGSproto));
OP *	pp_gservent	_((ARGSproto));
OP *	pp_shostent	_((ARGSproto));
OP *	pp_snetent	_((ARGSproto));
OP *	pp_sprotoent	_((ARGSproto));
OP *	pp_sservent	_((ARGSproto));
OP *	pp_ehostent	_((ARGSproto));
OP *	pp_enetent	_((ARGSproto));
OP *	pp_eprotoent	_((ARGSproto));
OP *	pp_eservent	_((ARGSproto));
OP *	pp_gpwnam	_((ARGSproto));
OP *	pp_gpwuid	_((ARGSproto));
OP *	pp_gpwent	_((ARGSproto));
OP *	pp_spwent	_((ARGSproto));
OP *	pp_epwent	_((ARGSproto));
OP *	pp_ggrnam	_((ARGSproto));
OP *	pp_ggrgid	_((ARGSproto));
OP *	pp_ggrent	_((ARGSproto));
OP *	pp_sgrent	_((ARGSproto));
OP *	pp_egrent	_((ARGSproto));
OP *	pp_getlogin	_((ARGSproto));
OP *	pp_syscall	_((ARGSproto));
OP *	pp_lock		_((ARGSproto));
OP *	pp_threadsv	_((ARGSproto));

END_EXTERN_C
#endif	/* PERL_OBJECT */

#ifndef DOINIT
EXT OP * (CPERLscope(*ppaddr)[])(ARGSproto);
#else
#ifndef PERL_OBJECT
EXT OP * (CPERLscope(*ppaddr)[])(ARGSproto) = {
	pp_null,
	pp_stub,
	pp_scalar,
	pp_pushmark,
	pp_wantarray,
	pp_const,
	pp_gvsv,
	pp_gv,
	pp_gelem,
	pp_padsv,
	pp_padav,
	pp_padhv,
	pp_padany,
	pp_pushre,
	pp_rv2gv,
	pp_rv2sv,
	pp_av2arylen,
	pp_rv2cv,
	pp_anoncode,
	pp_prototype,
	pp_refgen,
	pp_srefgen,
	pp_ref,
	pp_bless,
	pp_backtick,
	pp_glob,
	pp_readline,
	pp_rcatline,
	pp_regcmaybe,
	pp_regcreset,
	pp_regcomp,
	pp_match,
	pp_qr,
	pp_subst,
	pp_substcont,
	pp_trans,
	pp_sassign,
	pp_aassign,
	pp_chop,
	pp_schop,
	pp_chomp,
	pp_schomp,
	pp_defined,
	pp_undef,
	pp_study,
	pp_pos,
	pp_preinc,
	pp_i_preinc,
	pp_predec,
	pp_i_predec,
	pp_postinc,
	pp_i_postinc,
	pp_postdec,
	pp_i_postdec,
	pp_pow,
	pp_multiply,
	pp_i_multiply,
	pp_divide,
	pp_i_divide,
	pp_modulo,
	pp_i_modulo,
	pp_repeat,
	pp_add,
	pp_i_add,
	pp_subtract,
	pp_i_subtract,
	pp_concat,
	pp_stringify,
	pp_left_shift,
	pp_right_shift,
	pp_lt,
	pp_i_lt,
	pp_gt,
	pp_i_gt,
	pp_le,
	pp_i_le,
	pp_ge,
	pp_i_ge,
	pp_eq,
	pp_i_eq,
	pp_ne,
	pp_i_ne,
	pp_ncmp,
	pp_i_ncmp,
	pp_slt,
	pp_sgt,
	pp_sle,
	pp_sge,
	pp_seq,
	pp_sne,
	pp_scmp,
	pp_bit_and,
	pp_bit_xor,
	pp_bit_or,
	pp_negate,
	pp_i_negate,
	pp_not,
	pp_complement,
	pp_atan2,
	pp_sin,
	pp_cos,
	pp_rand,
	pp_srand,
	pp_exp,
	pp_log,
	pp_sqrt,
	pp_int,
	pp_hex,
	pp_oct,
	pp_abs,
	pp_length,
	pp_substr,
	pp_vec,
	pp_index,
	pp_rindex,
	pp_sprintf,
	pp_formline,
	pp_ord,
	pp_chr,
	pp_crypt,
	pp_ucfirst,
	pp_lcfirst,
	pp_uc,
	pp_lc,
	pp_quotemeta,
	pp_rv2av,
	pp_aelemfast,
	pp_aelem,
	pp_aslice,
	pp_each,
	pp_values,
	pp_keys,
	pp_delete,
	pp_exists,
	pp_rv2hv,
	pp_helem,
	pp_hslice,
	pp_unpack,
	pp_pack,
	pp_split,
	pp_join,
	pp_list,
	pp_lslice,
	pp_anonlist,
	pp_anonhash,
	pp_splice,
	pp_push,
	pp_pop,
	pp_shift,
	pp_unshift,
	pp_sort,
	pp_reverse,
	pp_grepstart,
	pp_grepwhile,
	pp_mapstart,
	pp_mapwhile,
	pp_range,
	pp_flip,
	pp_flop,
	pp_and,
	pp_or,
	pp_xor,
	pp_cond_expr,
	pp_andassign,
	pp_orassign,
	pp_method,
	pp_entersub,
	pp_leavesub,
	pp_caller,
	pp_warn,
	pp_die,
	pp_reset,
	pp_lineseq,
	pp_nextstate,
	pp_dbstate,
	pp_unstack,
	pp_enter,
	pp_leave,
	pp_scope,
	pp_enteriter,
	pp_iter,
	pp_enterloop,
	pp_leaveloop,
	pp_return,
	pp_last,
	pp_next,
	pp_redo,
	pp_dump,
	pp_goto,
	pp_exit,
	pp_open,
	pp_close,
	pp_pipe_op,
	pp_fileno,
	pp_umask,
	pp_binmode,
	pp_tie,
	pp_untie,
	pp_tied,
	pp_dbmopen,
	pp_dbmclose,
	pp_sselect,
	pp_select,
	pp_getc,
	pp_read,
	pp_enterwrite,
	pp_leavewrite,
	pp_prtf,
	pp_print,
	pp_sysopen,
	pp_sysseek,
	pp_sysread,
	pp_syswrite,
	pp_send,
	pp_recv,
	pp_eof,
	pp_tell,
	pp_seek,
	pp_truncate,
	pp_fcntl,
	pp_ioctl,
	pp_flock,
	pp_socket,
	pp_sockpair,
	pp_bind,
	pp_connect,
	pp_listen,
	pp_accept,
	pp_shutdown,
	pp_gsockopt,
	pp_ssockopt,
	pp_getsockname,
	pp_getpeername,
	pp_lstat,
	pp_stat,
	pp_ftrread,
	pp_ftrwrite,
	pp_ftrexec,
	pp_fteread,
	pp_ftewrite,
	pp_fteexec,
	pp_ftis,
	pp_fteowned,
	pp_ftrowned,
	pp_ftzero,
	pp_ftsize,
	pp_ftmtime,
	pp_ftatime,
	pp_ftctime,
	pp_ftsock,
	pp_ftchr,
	pp_ftblk,
	pp_ftfile,
	pp_ftdir,
	pp_ftpipe,
	pp_ftlink,
	pp_ftsuid,
	pp_ftsgid,
	pp_ftsvtx,
	pp_fttty,
	pp_fttext,
	pp_ftbinary,
	pp_chdir,
	pp_chown,
	pp_chroot,
	pp_unlink,
	pp_chmod,
	pp_utime,
	pp_rename,
	pp_link,
	pp_symlink,
	pp_readlink,
	pp_mkdir,
	pp_rmdir,
	pp_open_dir,
	pp_readdir,
	pp_telldir,
	pp_seekdir,
	pp_rewinddir,
	pp_closedir,
	pp_fork,
	pp_wait,
	pp_waitpid,
	pp_system,
	pp_exec,
	pp_kill,
	pp_getppid,
	pp_getpgrp,
	pp_setpgrp,
	pp_getpriority,
	pp_setpriority,
	pp_time,
	pp_tms,
	pp_localtime,
	pp_gmtime,
	pp_alarm,
	pp_sleep,
	pp_shmget,
	pp_shmctl,
	pp_shmread,
	pp_shmwrite,
	pp_msgget,
	pp_msgctl,
	pp_msgsnd,
	pp_msgrcv,
	pp_semget,
	pp_semctl,
	pp_semop,
	pp_require,
	pp_dofile,
	pp_entereval,
	pp_leaveeval,
	pp_entertry,
	pp_leavetry,
	pp_ghbyname,
	pp_ghbyaddr,
	pp_ghostent,
	pp_gnbyname,
	pp_gnbyaddr,
	pp_gnetent,
	pp_gpbyname,
	pp_gpbynumber,
	pp_gprotoent,
	pp_gsbyname,
	pp_gsbyport,
	pp_gservent,
	pp_shostent,
	pp_snetent,
	pp_sprotoent,
	pp_sservent,
	pp_ehostent,
	pp_enetent,
	pp_eprotoent,
	pp_eservent,
	pp_gpwnam,
	pp_gpwuid,
	pp_gpwent,
	pp_spwent,
	pp_epwent,
	pp_ggrnam,
	pp_ggrgid,
	pp_ggrent,
	pp_sgrent,
	pp_egrent,
	pp_getlogin,
	pp_syscall,
	pp_lock,
	pp_threadsv,
};
#endif	/* PERL_OBJECT */
#endif

#ifndef DOINIT
EXT OP * (CPERLscope(*check)[]) _((OP *op));
#else
#ifndef PERL_OBJECT
EXT OP * (CPERLscope(*check)[]) _((OP *op)) = {
	ck_null,	/* null */
	ck_null,	/* stub */
	ck_fun,		/* scalar */
	ck_null,	/* pushmark */
	ck_null,	/* wantarray */
	ck_svconst,	/* const */
	ck_null,	/* gvsv */
	ck_null,	/* gv */
	ck_null,	/* gelem */
	ck_null,	/* padsv */
	ck_null,	/* padav */
	ck_null,	/* padhv */
	ck_null,	/* padany */
	ck_null,	/* pushre */
	ck_rvconst,	/* rv2gv */
	ck_rvconst,	/* rv2sv */
	ck_null,	/* av2arylen */
	ck_rvconst,	/* rv2cv */
	ck_anoncode,	/* anoncode */
	ck_null,	/* prototype */
	ck_spair,	/* refgen */
	ck_null,	/* srefgen */
	ck_fun,		/* ref */
	ck_fun,		/* bless */
	ck_null,	/* backtick */
	ck_glob,	/* glob */
	ck_null,	/* readline */
	ck_null,	/* rcatline */
	ck_fun,		/* regcmaybe */
	ck_fun,		/* regcreset */
	ck_null,	/* regcomp */
	ck_match,	/* match */
	ck_match,	/* qr */
	ck_null,	/* subst */
	ck_null,	/* substcont */
	ck_null,	/* trans */
	ck_null,	/* sassign */
	ck_null,	/* aassign */
	ck_spair,	/* chop */
	ck_null,	/* schop */
	ck_spair,	/* chomp */
	ck_null,	/* schomp */
	ck_rfun,	/* defined */
	ck_lfun,	/* undef */
	ck_fun,		/* study */
	ck_lfun,	/* pos */
	ck_lfun,	/* preinc */
	ck_lfun,	/* i_preinc */
	ck_lfun,	/* predec */
	ck_lfun,	/* i_predec */
	ck_lfun,	/* postinc */
	ck_lfun,	/* i_postinc */
	ck_lfun,	/* postdec */
	ck_lfun,	/* i_postdec */
	ck_null,	/* pow */
	ck_null,	/* multiply */
	ck_null,	/* i_multiply */
	ck_null,	/* divide */
	ck_null,	/* i_divide */
	ck_null,	/* modulo */
	ck_null,	/* i_modulo */
	ck_repeat,	/* repeat */
	ck_null,	/* add */
	ck_null,	/* i_add */
	ck_null,	/* subtract */
	ck_null,	/* i_subtract */
	ck_concat,	/* concat */
	ck_fun,		/* stringify */
	ck_bitop,	/* left_shift */
	ck_bitop,	/* right_shift */
	ck_null,	/* lt */
	ck_null,	/* i_lt */
	ck_null,	/* gt */
	ck_null,	/* i_gt */
	ck_null,	/* le */
	ck_null,	/* i_le */
	ck_null,	/* ge */
	ck_null,	/* i_ge */
	ck_null,	/* eq */
	ck_null,	/* i_eq */
	ck_null,	/* ne */
	ck_null,	/* i_ne */
	ck_null,	/* ncmp */
	ck_null,	/* i_ncmp */
	ck_scmp,	/* slt */
	ck_scmp,	/* sgt */
	ck_scmp,	/* sle */
	ck_scmp,	/* sge */
	ck_null,	/* seq */
	ck_null,	/* sne */
	ck_scmp,	/* scmp */
	ck_bitop,	/* bit_and */
	ck_bitop,	/* bit_xor */
	ck_bitop,	/* bit_or */
	ck_null,	/* negate */
	ck_null,	/* i_negate */
	ck_null,	/* not */
	ck_bitop,	/* complement */
	ck_fun,		/* atan2 */
	ck_fun,		/* sin */
	ck_fun,		/* cos */
	ck_fun,		/* rand */
	ck_fun,		/* srand */
	ck_fun,		/* exp */
	ck_fun,		/* log */
	ck_fun,		/* sqrt */
	ck_fun,		/* int */
	ck_fun,		/* hex */
	ck_fun,		/* oct */
	ck_fun,		/* abs */
	ck_lengthconst,	/* length */
	ck_fun,		/* substr */
	ck_fun,		/* vec */
	ck_index,	/* index */
	ck_index,	/* rindex */
	ck_fun_locale,	/* sprintf */
	ck_fun,		/* formline */
	ck_fun,		/* ord */
	ck_fun,		/* chr */
	ck_fun,		/* crypt */
	ck_fun_locale,	/* ucfirst */
	ck_fun_locale,	/* lcfirst */
	ck_fun_locale,	/* uc */
	ck_fun_locale,	/* lc */
	ck_fun,		/* quotemeta */
	ck_rvconst,	/* rv2av */
	ck_null,	/* aelemfast */
	ck_null,	/* aelem */
	ck_null,	/* aslice */
	ck_fun,		/* each */
	ck_fun,		/* values */
	ck_fun,		/* keys */
	ck_delete,	/* delete */
	ck_exists,	/* exists */
	ck_rvconst,	/* rv2hv */
	ck_null,	/* helem */
	ck_null,	/* hslice */
	ck_fun,		/* unpack */
	ck_fun,		/* pack */
	ck_split,	/* split */
	ck_fun,		/* join */
	ck_null,	/* list */
	ck_null,	/* lslice */
	ck_fun,		/* anonlist */
	ck_fun,		/* anonhash */
	ck_fun,		/* splice */
	ck_fun,		/* push */
	ck_shift,	/* pop */
	ck_shift,	/* shift */
	ck_fun,		/* unshift */
	ck_sort,	/* sort */
	ck_fun,		/* reverse */
	ck_grep,	/* grepstart */
	ck_null,	/* grepwhile */
	ck_grep,	/* mapstart */
	ck_null,	/* mapwhile */
	ck_null,	/* range */
	ck_null,	/* flip */
	ck_null,	/* flop */
	ck_null,	/* and */
	ck_null,	/* or */
	ck_null,	/* xor */
	ck_null,	/* cond_expr */
	ck_null,	/* andassign */
	ck_null,	/* orassign */
	ck_null,	/* method */
	ck_subr,	/* entersub */
	ck_null,	/* leavesub */
	ck_fun,		/* caller */
	ck_fun,		/* warn */
	ck_fun,		/* die */
	ck_fun,		/* reset */
	ck_null,	/* lineseq */
	ck_null,	/* nextstate */
	ck_null,	/* dbstate */
	ck_null,	/* unstack */
	ck_null,	/* enter */
	ck_null,	/* leave */
	ck_null,	/* scope */
	ck_null,	/* enteriter */
	ck_null,	/* iter */
	ck_null,	/* enterloop */
	ck_null,	/* leaveloop */
	ck_null,	/* return */
	ck_null,	/* last */
	ck_null,	/* next */
	ck_null,	/* redo */
	ck_null,	/* dump */
	ck_null,	/* goto */
	ck_fun,		/* exit */
	ck_fun,		/* open */
	ck_fun,		/* close */
	ck_fun,		/* pipe_op */
	ck_fun,		/* fileno */
	ck_fun,		/* umask */
	ck_fun,		/* binmode */
	ck_fun,		/* tie */
	ck_fun,		/* untie */
	ck_fun,		/* tied */
	ck_fun,		/* dbmopen */
	ck_fun,		/* dbmclose */
	ck_select,	/* sselect */
	ck_select,	/* select */
	ck_eof,		/* getc */
	ck_fun,		/* read */
	ck_fun,		/* enterwrite */
	ck_null,	/* leavewrite */
	ck_listiob,	/* prtf */
	ck_listiob,	/* print */
	ck_fun,		/* sysopen */
	ck_fun,		/* sysseek */
	ck_fun,		/* sysread */
	ck_fun,		/* syswrite */
	ck_fun,		/* send */
	ck_fun,		/* recv */
	ck_eof,		/* eof */
	ck_fun,		/* tell */
	ck_fun,		/* seek */
	ck_trunc,	/* truncate */
	ck_fun,		/* fcntl */
	ck_fun,		/* ioctl */
	ck_fun,		/* flock */
	ck_fun,		/* socket */
	ck_fun,		/* sockpair */
	ck_fun,		/* bind */
	ck_fun,		/* connect */
	ck_fun,		/* listen */
	ck_fun,		/* accept */
	ck_fun,		/* shutdown */
	ck_fun,		/* gsockopt */
	ck_fun,		/* ssockopt */
	ck_fun,		/* getsockname */
	ck_fun,		/* getpeername */
	ck_ftst,	/* lstat */
	ck_ftst,	/* stat */
	ck_ftst,	/* ftrread */
	ck_ftst,	/* ftrwrite */
	ck_ftst,	/* ftrexec */
	ck_ftst,	/* fteread */
	ck_ftst,	/* ftewrite */
	ck_ftst,	/* fteexec */
	ck_ftst,	/* ftis */
	ck_ftst,	/* fteowned */
	ck_ftst,	/* ftrowned */
	ck_ftst,	/* ftzero */
	ck_ftst,	/* ftsize */
	ck_ftst,	/* ftmtime */
	ck_ftst,	/* ftatime */
	ck_ftst,	/* ftctime */
	ck_ftst,	/* ftsock */
	ck_ftst,	/* ftchr */
	ck_ftst,	/* ftblk */
	ck_ftst,	/* ftfile */
	ck_ftst,	/* ftdir */
	ck_ftst,	/* ftpipe */
	ck_ftst,	/* ftlink */
	ck_ftst,	/* ftsuid */
	ck_ftst,	/* ftsgid */
	ck_ftst,	/* ftsvtx */
	ck_ftst,	/* fttty */
	ck_ftst,	/* fttext */
	ck_ftst,	/* ftbinary */
	ck_fun,		/* chdir */
	ck_fun,		/* chown */
	ck_fun,		/* chroot */
	ck_fun,		/* unlink */
	ck_fun,		/* chmod */
	ck_fun,		/* utime */
	ck_fun,		/* rename */
	ck_fun,		/* link */
	ck_fun,		/* symlink */
	ck_fun,		/* readlink */
	ck_fun,		/* mkdir */
	ck_fun,		/* rmdir */
	ck_fun,		/* open_dir */
	ck_fun,		/* readdir */
	ck_fun,		/* telldir */
	ck_fun,		/* seekdir */
	ck_fun,		/* rewinddir */
	ck_fun,		/* closedir */
	ck_null,	/* fork */
	ck_null,	/* wait */
	ck_fun,		/* waitpid */
	ck_exec,	/* system */
	ck_exec,	/* exec */
	ck_fun,		/* kill */
	ck_null,	/* getppid */
	ck_fun,		/* getpgrp */
	ck_fun,		/* setpgrp */
	ck_fun,		/* getpriority */
	ck_fun,		/* setpriority */
	ck_null,	/* time */
	ck_null,	/* tms */
	ck_fun,		/* localtime */
	ck_fun,		/* gmtime */
	ck_fun,		/* alarm */
	ck_fun,		/* sleep */
	ck_fun,		/* shmget */
	ck_fun,		/* shmctl */
	ck_fun,		/* shmread */
	ck_fun,		/* shmwrite */
	ck_fun,		/* msgget */
	ck_fun,		/* msgctl */
	ck_fun,		/* msgsnd */
	ck_fun,		/* msgrcv */
	ck_fun,		/* semget */
	ck_fun,		/* semctl */
	ck_fun,		/* semop */
	ck_require,	/* require */
	ck_fun,		/* dofile */
	ck_eval,	/* entereval */
	ck_null,	/* leaveeval */
	ck_null,	/* entertry */
	ck_null,	/* leavetry */
	ck_fun,		/* ghbyname */
	ck_fun,		/* ghbyaddr */
	ck_null,	/* ghostent */
	ck_fun,		/* gnbyname */
	ck_fun,		/* gnbyaddr */
	ck_null,	/* gnetent */
	ck_fun,		/* gpbyname */
	ck_fun,		/* gpbynumber */
	ck_null,	/* gprotoent */
	ck_fun,		/* gsbyname */
	ck_fun,		/* gsbyport */
	ck_null,	/* gservent */
	ck_fun,		/* shostent */
	ck_fun,		/* snetent */
	ck_fun,		/* sprotoent */
	ck_fun,		/* sservent */
	ck_null,	/* ehostent */
	ck_null,	/* enetent */
	ck_null,	/* eprotoent */
	ck_null,	/* eservent */
	ck_fun,		/* gpwnam */
	ck_fun,		/* gpwuid */
	ck_null,	/* gpwent */
	ck_null,	/* spwent */
	ck_null,	/* epwent */
	ck_fun,		/* ggrnam */
	ck_fun,		/* ggrgid */
	ck_null,	/* ggrent */
	ck_null,	/* sgrent */
	ck_null,	/* egrent */
	ck_null,	/* getlogin */
	ck_fun,		/* syscall */
	ck_rfun,	/* lock */
	ck_null,	/* threadsv */
};
#endif	/* PERL_OBJECT */
#endif

#ifndef DOINIT
EXT U32 opargs[];
#else
EXT U32 opargs[] = {
	0x00000000,	/* null */
	0x00000000,	/* stub */
	0x00001c04,	/* scalar */
	0x00000004,	/* pushmark */
	0x00000014,	/* wantarray */
	0x00000704,	/* const */
	0x00000844,	/* gvsv */
	0x00000844,	/* gv */
	0x00011240,	/* gelem */
	0x00000044,	/* padsv */
	0x00000040,	/* padav */
	0x00000040,	/* padhv */
	0x00000040,	/* padany */
	0x00000640,	/* pushre */
	0x00000144,	/* rv2gv */
	0x00000144,	/* rv2sv */
	0x00000114,	/* av2arylen */
	0x00000140,	/* rv2cv */
	0x00000700,	/* anoncode */
	0x00001c04,	/* prototype */
	0x00002101,	/* refgen */
	0x00001106,	/* srefgen */
	0x00009c8c,	/* ref */
	0x00091504,	/* bless */
	0x00000c08,	/* backtick */
	0x00099508,	/* glob */
	0x00000c08,	/* readline */
	0x00000c08,	/* rcatline */
	0x00001104,	/* regcmaybe */
	0x00001104,	/* regcreset */
	0x00001304,	/* regcomp */
	0x00000640,	/* match */
	0x00000604,	/* qr */
	0x00001654,	/* subst */
	0x00000354,	/* substcont */
	0x00001914,	/* trans */
	0x00000004,	/* sassign */
	0x00022208,	/* aassign */
	0x00002c0d,	/* chop */
	0x00009c8c,	/* schop */
	0x00002c0d,	/* chomp */
	0x00009c8c,	/* schomp */
	0x00009c94,	/* defined */
	0x00009c04,	/* undef */
	0x00009c84,	/* study */
	0x00009c8c,	/* pos */
	0x00001164,	/* preinc */
	0x00001154,	/* i_preinc */
	0x00001164,	/* predec */
	0x00001154,	/* i_predec */
	0x0000116c,	/* postinc */
	0x0000115c,	/* i_postinc */
	0x0000116c,	/* postdec */
	0x0000115c,	/* i_postdec */
	0x0001120e,	/* pow */
	0x0001122e,	/* multiply */
	0x0001121e,	/* i_multiply */
	0x0001122e,	/* divide */
	0x0001121e,	/* i_divide */
	0x0001123e,	/* modulo */
	0x0001121e,	/* i_modulo */
	0x00012209,	/* repeat */
	0x0001122e,	/* add */
	0x0001121e,	/* i_add */
	0x0001122e,	/* subtract */
	0x0001121e,	/* i_subtract */
	0x0001120e,	/* concat */
	0x0000150e,	/* stringify */
	0x0001120e,	/* left_shift */
	0x0001120e,	/* right_shift */
	0x00011236,	/* lt */
	0x00011216,	/* i_lt */
	0x00011236,	/* gt */
	0x00011216,	/* i_gt */
	0x00011236,	/* le */
	0x00011216,	/* i_le */
	0x00011236,	/* ge */
	0x00011216,	/* i_ge */
	0x00011236,	/* eq */
	0x00011216,	/* i_eq */
	0x00011236,	/* ne */
	0x00011216,	/* i_ne */
	0x0001123e,	/* ncmp */
	0x0001121e,	/* i_ncmp */
	0x00011216,	/* slt */
	0x00011216,	/* sgt */
	0x00011216,	/* sle */
	0x00011216,	/* sge */
	0x00011216,	/* seq */
	0x00011216,	/* sne */
	0x0001121e,	/* scmp */
	0x0001120e,	/* bit_and */
	0x0001120e,	/* bit_xor */
	0x0001120e,	/* bit_or */
	0x0000112e,	/* negate */
	0x0000111e,	/* i_negate */
	0x00001116,	/* not */
	0x0000110e,	/* complement */
	0x0001150e,	/* atan2 */
	0x00009c8e,	/* sin */
	0x00009c8e,	/* cos */
	0x00009c0c,	/* rand */
	0x00009c04,	/* srand */
	0x00009c8e,	/* exp */
	0x00009c8e,	/* log */
	0x00009c8e,	/* sqrt */
	0x00009c8e,	/* int */
	0x00009c8e,	/* hex */
	0x00009c8e,	/* oct */
	0x00009c8e,	/* abs */
	0x00009c9c,	/* length */
	0x0991150c,	/* substr */
	0x0011151c,	/* vec */
	0x0091151c,	/* index */
	0x0091151c,	/* rindex */
	0x0002150f,	/* sprintf */
	0x00021505,	/* formline */
	0x00009c9e,	/* ord */
	0x00009c8e,	/* chr */
	0x0001150e,	/* crypt */
	0x00009c8e,	/* ucfirst */
	0x00009c8e,	/* lcfirst */
	0x00009c8e,	/* uc */
	0x00009c8e,	/* lc */
	0x00009c8e,	/* quotemeta */
	0x00000148,	/* rv2av */
	0x00013804,	/* aelemfast */
	0x00013204,	/* aelem */
	0x00023501,	/* aslice */
	0x00004c08,	/* each */
	0x00004c08,	/* values */
	0x00004c08,	/* keys */
	0x00001c00,	/* delete */
	0x00001c14,	/* exists */
	0x00000148,	/* rv2hv */
	0x00014204,	/* helem */
	0x00024501,	/* hslice */
	0x00011500,	/* unpack */
	0x0002150d,	/* pack */
	0x00111508,	/* split */
	0x0002150d,	/* join */
	0x00002501,	/* list */
	0x00224200,	/* lslice */
	0x00002505,	/* anonlist */
	0x00002505,	/* anonhash */
	0x02993501,	/* splice */
	0x0002351d,	/* push */
	0x00003c04,	/* pop */
	0x00003c04,	/* shift */
	0x0002351d,	/* unshift */
	0x0002d501,	/* sort */
	0x00002509,	/* reverse */
	0x00025541,	/* grepstart */
	0x00000348,	/* grepwhile */
	0x00025541,	/* mapstart */
	0x00000348,	/* mapwhile */
	0x00011400,	/* range */
	0x00011100,	/* flip */
	0x00000100,	/* flop */
	0x00000300,	/* and */
	0x00000300,	/* or */
	0x00011306,	/* xor */
	0x00000440,	/* cond_expr */
	0x00000304,	/* andassign */
	0x00000304,	/* orassign */
	0x00000140,	/* method */
	0x00002149,	/* entersub */
	0x00000100,	/* leavesub */
	0x00009c08,	/* caller */
	0x0000251d,	/* warn */
	0x0000255d,	/* die */
	0x00009c14,	/* reset */
	0x00000500,	/* lineseq */
	0x00000b04,	/* nextstate */
	0x00000b04,	/* dbstate */
	0x00000004,	/* unstack */
	0x00000000,	/* enter */
	0x00000500,	/* leave */
	0x00000500,	/* scope */
	0x00000a40,	/* enteriter */
	0x00000000,	/* iter */
	0x00000a40,	/* enterloop */
	0x00000200,	/* leaveloop */
	0x00002541,	/* return */
	0x00000e44,	/* last */
	0x00000e44,	/* next */
	0x00000e44,	/* redo */
	0x00000e44,	/* dump */
	0x00000e44,	/* goto */
	0x00009c44,	/* exit */
	0x0009651c,	/* open */
	0x0000ec14,	/* close */
	0x00066514,	/* pipe_op */
	0x00006c1c,	/* fileno */
	0x00009c1c,	/* umask */
	0x00006c04,	/* binmode */
	0x00217555,	/* tie */
	0x00007c14,	/* untie */
	0x00007c04,	/* tied */
	0x00114514,	/* dbmopen */
	0x00004c14,	/* dbmclose */
	0x01111508,	/* sselect */
	0x0000e50c,	/* select */
	0x0000ec0c,	/* getc */
	0x0917651d,	/* read */
	0x0000ec54,	/* enterwrite */
	0x00000100,	/* leavewrite */
	0x0002e515,	/* prtf */
	0x0002e515,	/* print */
	0x09116504,	/* sysopen */
	0x00116504,	/* sysseek */
	0x0917651d,	/* sysread */
	0x0991651d,	/* syswrite */
	0x0911651d,	/* send */
	0x0117651d,	/* recv */
	0x0000ec14,	/* eof */
	0x0000ec0c,	/* tell */
	0x00116504,	/* seek */
	0x00011514,	/* truncate */
	0x0011650c,	/* fcntl */
	0x0011650c,	/* ioctl */
	0x0001651c,	/* flock */
	0x01116514,	/* socket */
	0x11166514,	/* sockpair */
	0x00016514,	/* bind */
	0x00016514,	/* connect */
	0x00016514,	/* listen */
	0x0006651c,	/* accept */
	0x0001651c,	/* shutdown */
	0x00116514,	/* gsockopt */
	0x01116514,	/* ssockopt */
	0x00006c14,	/* getsockname */
	0x00006c14,	/* getpeername */
	0x00006d80,	/* lstat */
	0x00006d80,	/* stat */
	0x00006d94,	/* ftrread */
	0x00006d94,	/* ftrwrite */
	0x00006d94,	/* ftrexec */
	0x00006d94,	/* fteread */
	0x00006d94,	/* ftewrite */
	0x00006d94,	/* fteexec */
	0x00006d94,	/* ftis */
	0x00006d94,	/* fteowned */
	0x00006d94,	/* ftrowned */
	0x00006d94,	/* ftzero */
	0x00006d9c,	/* ftsize */
	0x00006d8c,	/* ftmtime */
	0x00006d8c,	/* ftatime */
	0x00006d8c,	/* ftctime */
	0x00006d94,	/* ftsock */
	0x00006d94,	/* ftchr */
	0x00006d94,	/* ftblk */
	0x00006d94,	/* ftfile */
	0x00006d94,	/* ftdir */
	0x00006d94,	/* ftpipe */
	0x00006d94,	/* ftlink */
	0x00006d94,	/* ftsuid */
	0x00006d94,	/* ftsgid */
	0x00006d94,	/* ftsvtx */
	0x00006d14,	/* fttty */
	0x00006d94,	/* fttext */
	0x00006d94,	/* ftbinary */
	0x00009c1c,	/* chdir */
	0x0000251d,	/* chown */
	0x00009c9c,	/* chroot */
	0x0000259d,	/* unlink */
	0x0000251d,	/* chmod */
	0x0000251d,	/* utime */
	0x0001151c,	/* rename */
	0x0001151c,	/* link */
	0x0001151c,	/* symlink */
	0x00009c8c,	/* readlink */
	0x0001151c,	/* mkdir */
	0x00009c9c,	/* rmdir */
	0x00016514,	/* open_dir */
	0x00006c00,	/* readdir */
	0x00006c0c,	/* telldir */
	0x00016504,	/* seekdir */
	0x00006c04,	/* rewinddir */
	0x00006c14,	/* closedir */
	0x0000001c,	/* fork */
	0x0000001c,	/* wait */
	0x0001151c,	/* waitpid */
	0x0002951d,	/* system */
	0x0002955d,	/* exec */
	0x0000255d,	/* kill */
	0x0000001c,	/* getppid */
	0x00009c1c,	/* getpgrp */
	0x0009951c,	/* setpgrp */
	0x0001151c,	/* getpriority */
	0x0011151c,	/* setpriority */
	0x0000001c,	/* time */
	0x00000000,	/* tms */
	0x00009c08,	/* localtime */
	0x00009c08,	/* gmtime */
	0x00009c9c,	/* alarm */
	0x00009c1c,	/* sleep */
	0x0011151d,	/* shmget */
	0x0011151d,	/* shmctl */
	0x0111151d,	/* shmread */
	0x0111151d,	/* shmwrite */
	0x0001151d,	/* msgget */
	0x0011151d,	/* msgctl */
	0x0011151d,	/* msgsnd */
	0x1111151d,	/* msgrcv */
	0x0011151d,	/* semget */
	0x0111151d,	/* semctl */
	0x0001151d,	/* semop */
	0x00009cc0,	/* require */
	0x00001140,	/* dofile */
	0x00001c40,	/* entereval */
	0x00001100,	/* leaveeval */
	0x00000300,	/* entertry */
	0x00000500,	/* leavetry */
	0x00001c00,	/* ghbyname */
	0x00011500,	/* ghbyaddr */
	0x00000000,	/* ghostent */
	0x00001c00,	/* gnbyname */
	0x00011500,	/* gnbyaddr */
	0x00000000,	/* gnetent */
	0x00001c00,	/* gpbyname */
	0x00001500,	/* gpbynumber */
	0x00000000,	/* gprotoent */
	0x00011500,	/* gsbyname */
	0x00011500,	/* gsbyport */
	0x00000000,	/* gservent */
	0x00001c14,	/* shostent */
	0x00001c14,	/* snetent */
	0x00001c14,	/* sprotoent */
	0x00001c14,	/* sservent */
	0x00000014,	/* ehostent */
	0x00000014,	/* enetent */
	0x00000014,	/* eprotoent */
	0x00000014,	/* eservent */
	0x00001c00,	/* gpwnam */
	0x00001c00,	/* gpwuid */
	0x00000000,	/* gpwent */
	0x00000014,	/* spwent */
	0x00000014,	/* epwent */
	0x00001c00,	/* ggrnam */
	0x00001c00,	/* ggrgid */
	0x00000000,	/* ggrent */
	0x00000014,	/* sgrent */
	0x00000014,	/* egrent */
	0x0000000c,	/* getlogin */
	0x0002151d,	/* syscall */
	0x00001c04,	/* lock */
	0x00000044,	/* threadsv */
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlhost.h ===
#include "iperlsys.h"

extern CPerlObj *pPerl;

#define CALLFUNC0RET(x)\
    int ret = x;\
    if (ret < 0)\
	err = errno;\
    return ret;

#define PROCESS_AND_RETURN  \
    if (errno)		    \
	err = errno;	    \
    return r

#define CALLFUNCRET(x)\
    int ret = x;\
    if (ret)\
	err = errno;\
    return ret;

#define CALLFUNCERR(x)\
    int ret = x;\
    if (errno)\
	err = errno;\
    return ret;

#define LCALLFUNCERR(x)\
    long ret = x;\
    if (errno)\
	err = errno;\
    return ret;

class CPerlDir : public IPerlDir
{
public:
    CPerlDir() {};
    virtual int Makedir(const char *dirname, int mode, int &err)
    {
	CALLFUNC0RET(win32_mkdir(dirname, mode));
    };
    virtual int Chdir(const char *dirname, int &err)
    {
	CALLFUNC0RET(win32_chdir(dirname));
    };
    virtual int Rmdir(const char *dirname, int &err)
    {
	CALLFUNC0RET(win32_rmdir(dirname));
    };
    virtual int Close(DIR *dirp, int &err)
    {
	return win32_closedir(dirp);
    };
    virtual DIR *Open(char *filename, int &err)
    {
	return win32_opendir(filename);
    };
    virtual struct direct *Read(DIR *dirp, int &err)
    {
	return win32_readdir(dirp);
    };
    virtual void Rewind(DIR *dirp, int &err)
    {
	win32_rewinddir(dirp);
    };
    virtual void Seek(DIR *dirp, long loc, int &err)
    {
	win32_seekdir(dirp, loc);
    };
    virtual long Tell(DIR *dirp, int &err)
    {
	return win32_telldir(dirp);
    };
};


extern char *		g_win32_get_privlib(char *pl);
extern char *		g_win32_get_sitelib(char *pl);

class CPerlEnv : public IPerlEnv
{
public:
    CPerlEnv() {};
    virtual char *Getenv(const char *varname, int &err)
    {
	return win32_getenv(varname);
    };
    virtual int Putenv(const char *envstring, int &err)
    {
	return win32_putenv(envstring);
    };
    virtual char* LibPath(char *pl)
    {
	return g_win32_get_privlib(pl);
    };
    virtual char* SiteLibPath(char *pl)
    {
	return g_win32_get_sitelib(pl);
    };
    virtual int Uname(struct utsname *name, int &err)
    {
	return win32_uname(name);
    };
};

class CPerlSock : public IPerlSock
{
public:
    CPerlSock() {};
    virtual u_long Htonl(u_long hostlong)
    {
	return win32_htonl(hostlong);
    };
    virtual u_short Htons(u_short hostshort)
    {
	return win32_htons(hostshort);
    };
    virtual u_long Ntohl(u_long netlong)
    {
	return win32_ntohl(netlong);
    };
    virtual u_short Ntohs(u_short netshort)
    {
	return win32_ntohs(netshort);
    }

    virtual SOCKET Accept(SOCKET s, struct sockaddr* addr, int* addrlen, int &err)
    {
	SOCKET r = win32_accept(s, addr, addrlen);
	PROCESS_AND_RETURN;
    };
    virtual int Bind(SOCKET s, const struct sockaddr* name, int namelen, int &err)
    {
	int r = win32_bind(s, name, namelen);
	PROCESS_AND_RETURN;
    };
    virtual int Connect(SOCKET s, const struct sockaddr* name, int namelen, int &err)
    {
	int r = win32_connect(s, name, namelen);
	PROCESS_AND_RETURN;
    };
    virtual void Endhostent(int &err)
    {
	win32_endhostent();
    };
    virtual void Endnetent(int &err)
    {
	win32_endnetent();
    };
    virtual void Endprotoent(int &err)
    {
	win32_endprotoent();
    };
    virtual void Endservent(int &err)
    {
	win32_endservent();
    };
    virtual struct hostent* Gethostbyaddr(const char* addr, int len, int type, int &err)
    {
	struct hostent *r = win32_gethostbyaddr(addr, len, type);
	PROCESS_AND_RETURN;
    };
    virtual struct hostent* Gethostbyname(const char* name, int &err)
    {
	struct hostent *r = win32_gethostbyname(name);
	PROCESS_AND_RETURN;
    };
    virtual struct hostent* Gethostent(int &err)
    {
        croak("gethostent not implemented!\n");
	return NULL;
    };
    virtual int Gethostname(char* name, int namelen, int &err)
    {
	int r = win32_gethostname(name, namelen);
	PROCESS_AND_RETURN;
    };
    virtual struct netent *Getnetbyaddr(long net, int type, int &err)
    {
	struct netent *r = win32_getnetbyaddr(net, type);
	PROCESS_AND_RETURN;
    };
    virtual struct netent *Getnetbyname(const char *name, int &err)
    {
	struct netent *r = win32_getnetbyname((char*)name);
	PROCESS_AND_RETURN;
    };
    virtual struct netent *Getnetent(int &err)
    {
	struct netent *r = win32_getnetent();
	PROCESS_AND_RETURN;
    };
    virtual int Getpeername(SOCKET s, struct sockaddr* name, int* namelen, int &err)
    {
	int r = win32_getpeername(s, name, namelen);
	PROCESS_AND_RETURN;
    };
    virtual struct protoent* Getprotobyname(const char* name, int &err)
    {
	struct protoent *r = win32_getprotobyname(name);
	PROCESS_AND_RETURN;
    };
    virtual struct protoent* Getprotobynumber(int number, int &err)
    {
	struct protoent *r = win32_getprotobynumber(number);
	PROCESS_AND_RETURN;
    };
    virtual struct protoent* Getprotoent(int &err)
    {
	struct protoent *r = win32_getprotoent();
	PROCESS_AND_RETURN;
    };
    virtual struct servent* Getservbyname(const char* name, const char* proto, int &err)
    {
	struct servent *r = win32_getservbyname(name, proto);
	PROCESS_AND_RETURN;
    };
    virtual struct servent* Getservbyport(int port, const char* proto, int &err)
    {
	struct servent *r = win32_getservbyport(port, proto);
	PROCESS_AND_RETURN;
    };
    virtual struct servent* Getservent(int &err)
    {
	struct servent *r = win32_getservent();
	PROCESS_AND_RETURN;
    };
    virtual int Getsockname(SOCKET s, struct sockaddr* name, int* namelen, int &err)
    {
	int r = win32_getsockname(s, name, namelen);
	PROCESS_AND_RETURN;
    };
    virtual int Getsockopt(SOCKET s, int level, int optname, char* optval, int* optlen, int &err)
    {
	int r = win32_getsockopt(s, level, optname, optval, optlen);
	PROCESS_AND_RETURN;
    };
    virtual unsigned long InetAddr(const char* cp, int &err)
    {
	unsigned long r = win32_inet_addr(cp);
	PROCESS_AND_RETURN;
    };
    virtual char* InetNtoa(struct in_addr in, int &err)
    {
	char *r = win32_inet_ntoa(in);
	PROCESS_AND_RETURN;
    };
    virtual int Listen(SOCKET s, int backlog, int &err)
    {
	int r = win32_listen(s, backlog);
	PROCESS_AND_RETURN;
    };
    virtual int Recv(SOCKET s, char* buffer, int len, int flags, int &err)
    {
	int r = win32_recv(s, buffer, len, flags);
	PROCESS_AND_RETURN;
    };
    virtual int Recvfrom(SOCKET s, char* buffer, int len, int flags, struct sockaddr* from, int* fromlen, int &err)
    {
	int r = win32_recvfrom(s, buffer, len, flags, from, fromlen);
	PROCESS_AND_RETURN;
    };
    virtual int Select(int nfds, char* readfds, char* writefds, char* exceptfds, const struct timeval* timeout, int &err)
    {
	int r = win32_select(nfds, (Perl_fd_set*)readfds, (Perl_fd_set*)writefds, (Perl_fd_set*)exceptfds, timeout);
	PROCESS_AND_RETURN;
    };
    virtual int Send(SOCKET s, const char* buffer, int len, int flags, int &err)
    {
	int r = win32_send(s, buffer, len, flags);
	PROCESS_AND_RETURN;
    };
    virtual int Sendto(SOCKET s, const char* buffer, int len, int flags, const struct sockaddr* to, int tolen, int &err)
    {
	int r = win32_sendto(s, buffer, len, flags, to, tolen);
	PROCESS_AND_RETURN;
    };
    virtual void Sethostent(int stayopen, int &err)
    {
	win32_sethostent(stayopen);
    };
    virtual void Setnetent(int stayopen, int &err)
    {
	win32_setnetent(stayopen);
    };
    virtual void Setprotoent(int stayopen, int &err)
    {
	win32_setprotoent(stayopen);
    };
    virtual void Setservent(int stayopen, int &err)
    {
	win32_setservent(stayopen);
    };
    virtual int Setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen, int &err)
    {
	int r = win32_setsockopt(s, level, optname, optval, optlen);
	PROCESS_AND_RETURN;
    };
    virtual int Shutdown(SOCKET s, int how, int &err)
    {
	int r = win32_shutdown(s, how);
	PROCESS_AND_RETURN;
    };
    virtual SOCKET Socket(int af, int type, int protocol, int &err)
    {
	SOCKET r = win32_socket(af, type, protocol);
	PROCESS_AND_RETURN;
    };
    virtual int Socketpair(int domain, int type, int protocol, int* fds, int &err)
    {
        croak("socketpair not implemented!\n");
	return 0;
    };
    virtual int Closesocket(SOCKET s, int& err)
    {
	int r = win32_closesocket(s);
	PROCESS_AND_RETURN;
    };
    virtual int Ioctlsocket(SOCKET s, long cmd, u_long *argp, int& err)
    {
	int r = win32_ioctlsocket(s, cmd, argp);
	PROCESS_AND_RETURN;
    };
};

class CPerlLIO : public IPerlLIO
{
public:
    CPerlLIO() {};
    virtual int Access(const char *path, int mode, int &err)
    {
	CALLFUNCRET(access(path, mode))
    };
    virtual int Chmod(const char *filename, int pmode, int &err)
    {
	CALLFUNCRET(chmod(filename, pmode))
    };
    virtual int Chown(const char *filename, uid_t owner, gid_t group, int &err)
    {
	CALLFUNCERR(chown(filename, owner, group))
    };
    virtual int Chsize(int handle, long size, int &err)
    {
	CALLFUNCRET(chsize(handle, size))
    };
    virtual int Close(int handle, int &err)
    {
	CALLFUNCRET(win32_close(handle))
    };
    virtual int Dup(int handle, int &err)
    {
	CALLFUNCERR(win32_dup(handle))
    };
    virtual int Dup2(int handle1, int handle2, int &err)
    {
	CALLFUNCERR(win32_dup2(handle1, handle2))
    };
    virtual int Flock(int fd, int oper, int &err)
    {
	CALLFUNCERR(win32_flock(fd, oper))
    };
    virtual int FileStat(int handle, struct stat *buffer, int &err)
    {
	CALLFUNCERR(fstat(handle, buffer))
    };
    virtual int IOCtl(int i, unsigned int u, char *data, int &err)
    {
	CALLFUNCERR(win32_ioctlsocket((SOCKET)i, (long)u, (u_long*)data))
    };
    virtual int Isatty(int fd, int &err)
    {
	return isatty(fd);
    };
    virtual long Lseek(int handle, long offset, int origin, int &err)
    {
	LCALLFUNCERR(win32_lseek(handle, offset, origin))
    };
    virtual int Lstat(const char *path, struct stat *buffer, int &err)
    {
	return NameStat(path, buffer, err);
    };
    virtual char *Mktemp(char *Template, int &err)
    {
	return mktemp(Template);
    };
    virtual int Open(const char *filename, int oflag, int &err)
    {
	CALLFUNCERR(win32_open(filename, oflag))
    };
    virtual int Open(const char *filename, int oflag, int pmode, int &err)
    {
	int ret;
	if(stricmp(filename, "/dev/null") == 0)
	    ret = open("NUL", oflag, pmode);
	else
	    ret = open(filename, oflag, pmode);

	if(errno)
	    err = errno;
	return ret;
    };
    virtual int Read(int handle, void *buffer, unsigned int count, int &err)
    {
	CALLFUNCERR(win32_read(handle, buffer, count))
    };
    virtual int Rename(const char *OldFileName, const char *newname, int &err)
    {
	CALLFUNCRET(win32_rename(OldFileName, newname))
    };
    virtual int Setmode(int handle, int mode, int &err)
    {
	CALLFUNCRET(win32_setmode(handle, mode))
    };
    virtual int NameStat(const char *path, struct stat *buffer, int &err)
    {
	return win32_stat(path, buffer);
    };
    virtual char *Tmpnam(char *string, int &err)
    {
	return tmpnam(string);
    };
    virtual int Umask(int pmode, int &err)
    {
	return umask(pmode);
    };
    virtual int Unlink(const char *filename, int &err)
    {
	chmod(filename, S_IREAD | S_IWRITE);
	CALLFUNCRET(unlink(filename))
    };
    virtual int Utime(char *filename, struct utimbuf *times, int &err)
    {
	CALLFUNCRET(win32_utime(filename, times))
    };
    virtual int Write(int handle, const void *buffer, unsigned int count, int &err)
    {
	CALLFUNCERR(win32_write(handle, buffer, count))
    };
};

class CPerlMem : public IPerlMem
{
public:
    CPerlMem() {};
    virtual void* Malloc(size_t size)
    {
	return win32_malloc(size);
    };
    virtual void* Realloc(void* ptr, size_t size)
    {
	return win32_realloc(ptr, size);
    };
    virtual void Free(void* ptr)
    {
	win32_free(ptr);
    };
};

#define EXECF_EXEC 1
#define EXECF_SPAWN 2

extern char *		g_getlogin(void);
extern int		do_spawn2(char *cmd, int exectype);
extern int		g_do_aspawn(void *vreally, void **vmark, void **vsp);

class CPerlProc : public IPerlProc
{
public:
    CPerlProc() {};
    virtual void Abort(void)
    {
	win32_abort();
    };
    virtual char * Crypt(const char* clear, const char* salt)
    {
	return win32_crypt(clear, salt);
    };
    virtual void Exit(int status)
    {
	exit(status);
    };
    virtual void _Exit(int status)
    {
	_exit(status);
    };
    virtual int Execl(const char *cmdname, const char *arg0, const char *arg1, const char *arg2, const char *arg3)
    {
	return execl(cmdname, arg0, arg1, arg2, arg3);
    };
    virtual int Execv(const char *cmdname, const char *const *argv)
    {
	return win32_execvp(cmdname, argv);
    };
    virtual int Execvp(const char *cmdname, const char *const *argv)
    {
	return win32_execvp(cmdname, argv);
    };
    virtual uid_t Getuid(void)
    {
	return getuid();
    };
    virtual uid_t Geteuid(void)
    {
	return geteuid();
    };
    virtual gid_t Getgid(void)
    {
	return getgid();
    };
    virtual gid_t Getegid(void)
    {
	return getegid();
    };
    virtual char *Getlogin(void)
    {
	return g_getlogin();
    };
    virtual int Kill(int pid, int sig)
    {
	return win32_kill(pid, sig);
    };
    virtual int Killpg(int pid, int sig)
    {
	croak("killpg not implemented!\n");
	return 0;
    };
    virtual int PauseProc(void)
    {
	return win32_sleep((32767L << 16) + 32767);
    };
    virtual PerlIO* Popen(const char *command, const char *mode)
    {
	win32_fflush(stdout);
	win32_fflush(stderr);
	return (PerlIO*)win32_popen(command, mode);
    };
    virtual int Pclose(PerlIO *stream)
    {
	return win32_pclose((FILE*)stream);
    };
    virtual int Pipe(int *phandles)
    {
	return win32_pipe(phandles, 512, O_BINARY);
    };
    virtual int Setuid(uid_t u)
    {
	return setuid(u);
    };
    virtual int Setgid(gid_t g)
    {
	return setgid(g);
    };
    virtual int Sleep(unsigned int s)
    {
	return win32_sleep(s);
    };
    virtual int Times(struct tms *timebuf)
    {
	return win32_times(timebuf);
    };
    virtual int Wait(int *status)
    {
	return win32_wait(status);
    };
    virtual int Waitpid(int pid, int *status, int flags)
    {
	return win32_waitpid(pid, status, flags);
    };
    virtual Sighandler_t Signal(int sig, Sighandler_t subcode)
    {
	return 0;
    };
    virtual void GetSysMsg(char*& sMsg, DWORD& dwLen, DWORD dwErr)
    {
	dwLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
			  |FORMAT_MESSAGE_IGNORE_INSERTS
			  |FORMAT_MESSAGE_FROM_SYSTEM, NULL,
			   dwErr, 0, (char *)&sMsg, 1, NULL);
	/* strip trailing whitespace and period */
	if (0 < dwLen) {
	    do {
		--dwLen;	/* dwLen doesn't include trailing null */
	    } while (0 < dwLen && isSPACE(sMsg[dwLen]));
	    if ('.' != sMsg[dwLen])
		dwLen++;
	    sMsg[dwLen] = '\0';
	}
	if (0 == dwLen) {
	    sMsg = (char*)LocalAlloc(0, 64/**sizeof(TCHAR)*/);
	    dwLen = sprintf(sMsg,
			"Unknown error #0x%lX (lookup 0x%lX)",
			dwErr, GetLastError());
	}
    };
    virtual void FreeBuf(char* sMsg)
    {
	LocalFree(sMsg);
    };
    virtual BOOL DoCmd(char *cmd)
    {
	do_spawn2(cmd, EXECF_EXEC);
        return FALSE;
    };
    virtual int Spawn(char* cmds)
    {
	return do_spawn2(cmds, EXECF_SPAWN);
    };
    virtual int Spawnvp(int mode, const char *cmdname, const char *const *argv)
    {
	return win32_spawnvp(mode, cmdname, argv);
    };
    virtual int ASpawn(void *vreally, void **vmark, void **vsp)
    {
	return g_do_aspawn(vreally, vmark, vsp);
    };
};


class CPerlStdIO : public IPerlStdIO
{
public:
    CPerlStdIO() {};
    virtual PerlIO* Stdin(void)
    {
	return (PerlIO*)win32_stdin();
    };
    virtual PerlIO* Stdout(void)
    {
	return (PerlIO*)win32_stdout();
    };
    virtual PerlIO* Stderr(void)
    {
	return (PerlIO*)win32_stderr();
    };
    virtual PerlIO* Open(const char *path, const char *mode, int &err)
    {
	PerlIO*pf = (PerlIO*)win32_fopen(path, mode);
	if(errno)
	    err = errno;
	return pf;
    };
    virtual int Close(PerlIO* pf, int &err)
    {
	CALLFUNCERR(win32_fclose(((FILE*)pf)))
    };
    virtual int Eof(PerlIO* pf, int &err)
    {
	CALLFUNCERR(win32_feof((FILE*)pf))
    };
    virtual int Error(PerlIO* pf, int &err)
    {
	CALLFUNCERR(win32_ferror((FILE*)pf))
    };
    virtual void Clearerr(PerlIO* pf, int &err)
    {
	win32_clearerr((FILE*)pf);
    };
    virtual int Getc(PerlIO* pf, int &err)
    {
	CALLFUNCERR(win32_getc((FILE*)pf))
    };
    virtual char* GetBase(PerlIO* pf, int &err)
    {
#ifdef FILE_base
	FILE *f = (FILE*)pf;
	return FILE_base(f);
#else
	return Nullch;
#endif
    };
    virtual int GetBufsiz(PerlIO* pf, int &err)
    {
#ifdef FILE_bufsiz
	FILE *f = (FILE*)pf;
	return FILE_bufsiz(f);
#else
	return (-1);
#endif
    };
    virtual int GetCnt(PerlIO* pf, int &err)
    {
#ifdef USE_STDIO_PTR
	FILE *f = (FILE*)pf;
	return FILE_cnt(f);
#else
	return (-1);
#endif
    };
    virtual char* GetPtr(PerlIO* pf, int &err)
    {
#ifdef USE_STDIO_PTR
	FILE *f = (FILE*)pf;
	return FILE_ptr(f);
#else
	return Nullch;
#endif
    };
    virtual char* Gets(PerlIO* pf, char* s, int n, int& err)
    {
	char* ret = win32_fgets(s, n, (FILE*)pf);
	if(errno)
	    err = errno;
	return ret;
    };
    virtual int Putc(PerlIO* pf, int c, int &err)
    {
	CALLFUNCERR(win32_fputc(c, (FILE*)pf))
    };
    virtual int Puts(PerlIO* pf, const char *s, int &err)
    {
	CALLFUNCERR(win32_fputs(s, (FILE*)pf))
    };
    virtual int Flush(PerlIO* pf, int &err)
    {
	CALLFUNCERR(win32_fflush((FILE*)pf))
    };
    virtual int Ungetc(PerlIO* pf,int c, int &err)
    {
	CALLFUNCERR(win32_ungetc(c, (FILE*)pf))
    };
    virtual int Fileno(PerlIO* pf, int &err)
    {
	CALLFUNCERR(win32_fileno((FILE*)pf))
    };
    virtual PerlIO* Fdopen(int fd, const char *mode, int &err)
    {
	PerlIO* pf = (PerlIO*)win32_fdopen(fd, mode);
	if(errno)
	    err = errno;
	return pf;
    };
    virtual PerlIO* Reopen(const char*path, const char*mode, PerlIO* pf, int &err)
    {
	PerlIO* newPf = (PerlIO*)win32_freopen(path, mode, (FILE*)pf);
	if(errno)
	    err = errno;
	return newPf;
    };
    virtual SSize_t Read(PerlIO* pf, void *buffer, Size_t size, int &err)
    {
	SSize_t i = win32_fread(buffer, 1, size, (FILE*)pf);
	if(errno)
	    err = errno;
	return i;
    };
    virtual SSize_t Write(PerlIO* pf, const void *buffer, Size_t size, int &err)
    {
	SSize_t i = win32_fwrite(buffer, 1, size, (FILE*)pf);
	if(errno)
	    err = errno;
	return i;
    };
    virtual void SetBuf(PerlIO* pf, char* buffer, int &err)
    {
	win32_setbuf((FILE*)pf, buffer);
    };
    virtual int SetVBuf(PerlIO* pf, char* buffer, int type, Size_t size, int &err)
    {
	int i = win32_setvbuf((FILE*)pf, buffer, type, size);
	if(errno)
	    err = errno;
	return i;
    };
    virtual void SetCnt(PerlIO* pf, int n, int &err)
    {
#ifdef STDIO_CNT_LVALUE
	FILE *f = (FILE*)pf;
	FILE_cnt(f) = n;
#endif
    };
    virtual void SetPtrCnt(PerlIO* pf, char * ptr, int n, int& err)
    {
#ifdef STDIO_PTR_LVALUE
	FILE *f = (FILE*)pf;
	FILE_ptr(f) = ptr;
	FILE_cnt(f) = n;
#endif
    };
    virtual void Setlinebuf(PerlIO* pf, int &err)
    {
	win32_setvbuf((FILE*)pf, NULL, _IOLBF, 0);
    };
    virtual int Printf(PerlIO* pf, int &err, const char *format,...)
    {
	va_list(arglist);
	va_start(arglist, format);
	int i = win32_vfprintf((FILE*)pf, format, arglist);
	if(errno)
	    err = errno;
	return i;
    };
    virtual int Vprintf(PerlIO* pf, int &err, const char *format, va_list arglist)
    {
	int i = win32_vfprintf((FILE*)pf, format, arglist);
	if(errno)
	    err = errno;
	return i;
    };
    virtual long Tell(PerlIO* pf, int &err)
    {
	long l = win32_ftell((FILE*)pf);
	if(errno)
	    err = errno;
	return l;
    };
    virtual int Seek(PerlIO* pf, off_t offset, int origin, int &err)
    {
	int i = win32_fseek((FILE*)pf, offset, origin);
	if(errno)
	    err = errno;
	return i;
    };
    virtual void Rewind(PerlIO* pf, int &err)
    {
	win32_rewind((FILE*)pf);
    };
    virtual PerlIO* Tmpfile(int &err)
    {
	PerlIO* pf = (PerlIO*)win32_tmpfile();
	if(errno)
	    err = errno;
	return pf;
    };
    virtual int Getpos(PerlIO* pf, Fpos_t *p, int &err)
    {
	int i = win32_fgetpos((FILE*)pf, p);
	if(errno)
	    err = errno;
	return i;
    };
    virtual int Setpos(PerlIO* pf, const Fpos_t *p, int &err)
    {
	int i = win32_fsetpos((FILE*)pf, p);
	if(errno)
	    err = errno;
	return i;
    };
    virtual void Init(int &err)
    {
    };
    virtual void InitOSExtras(void* p)
    {
	Perl_init_os_extras();
    };
    virtual int OpenOSfhandle(long osfhandle, int flags)
    {
	return win32_open_osfhandle(osfhandle, flags);
    }
    virtual int GetOSfhandle(int filenum)
    {
	return win32_get_osfhandle(filenum);
    }
};

class CPerlHost
{
public:
    CPerlHost() { pPerl = NULL; };
    inline BOOL PerlCreate(void)
    {
	try
	{
	    pPerl = perl_alloc(&perlMem, &perlEnv, &perlStdIO, &perlLIO,
			       &perlDir, &perlSock, &perlProc);
	    if(pPerl != NULL)
	    {
		try
		{
		    pPerl->perl_construct();
		}
		catch(...)
		{
		    win32_fprintf(stderr, "%s\n",
				  "Error: Unable to construct data structures");
		    pPerl->perl_free();
		    pPerl = NULL;
		}
	    }
	}
	catch(...)
	{
	    win32_fprintf(stderr, "%s\n", "Error: Unable to allocate memory");
	    pPerl = NULL;
	}
	return (pPerl != NULL);
    };
    inline int PerlParse(void (*xs_init)(CPerlObj*), int argc, char** argv, char** env)
    {
	int retVal;
	try
	{
	    retVal = pPerl->perl_parse(xs_init, argc, argv, env);
	}
	catch(int x)
	{
	    // this is where exit() should arrive
	    retVal = x;
	}
	catch(...)
	{
	    win32_fprintf(stderr, "Error: Parse exception\n");
	    retVal = -1;
	}
	*win32_errno() = 0;
	return retVal;
    };
    inline int PerlRun(void)
    {
	int retVal;
	try
	{
	    retVal = pPerl->perl_run();
	}
	catch(int x)
	{
	    // this is where exit() should arrive
	    retVal = x;
	}
	catch(...)
	{
	    win32_fprintf(stderr, "Error: Runtime exception\n");
	    retVal = -1;
	}
	return retVal;
    };
    inline void PerlDestroy(void)
    {
	try
	{
	    pPerl->perl_destruct();
	    pPerl->perl_free();
	}
	catch(...)
	{
	}
    };

protected:
    CPerlDir	perlDir;
    CPerlEnv	perlEnv;
    CPerlLIO	perlLIO;
    CPerlMem	perlMem;
    CPerlProc	perlProc;
    CPerlSock	perlSock;
    CPerlStdIO	perlStdIO;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perl.h ===
/*    perl.h
 *
 *    Copyright (c) 1987-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
#ifndef H_PERL
#define H_PERL 1
#define OVERLOAD

#ifdef PERL_FOR_X2P
/*
 * This file is being used for x2p stuff. 
 * Above symbol is defined via -D in 'x2p/Makefile.SH'
 * Decouple x2p stuff from some of perls more extreme eccentricities. 
 */
#undef EMBED
#undef NO_EMBED
#define NO_EMBED
#undef MULTIPLICITY
#undef USE_STDIO
#define USE_STDIO
#endif /* PERL_FOR_X2P */

#ifdef PERL_OBJECT

/* PERL_OBJECT explained  - DickH and DougL @ ActiveState.com

Defining PERL_OBJECT turns on creation of a C++ object that
contains all writable core perl global variables and functions.
Stated another way, all necessary global variables and functions
are members of a big C++ object. This object's class is CPerlObj.
This allows a Perl Host to have multiple, independent perl
interpreters in the same process space. This is very important on
Win32 systems as the overhead of process creation is quite high --
this could be even higher than the script compile and execute time
for small scripts.

The perl executable implementation on Win32 is composed of perl.exe
(the Perl Host) and perlX.dll. (the Perl Core). This allows the
same Perl Core to easily be embedded in other applications that use
the perl interpreter.

+-----------+
| Perl Host |
+-----------+
      ^
	  |
	  v
+-----------+   +-----------+
| Perl Core |<->| Extension |
+-----------+   +-----------+ ...

Defining PERL_OBJECT has the following effects:

PERL CORE
1. CPerlObj is defined (this is the PERL_OBJECT)
2. all static functions that needed to access either global
variables or functions needed are made member functions
3. all writable static variables are made member variables
4. all global variables and functions are defined as:
	#define var CPerlObj::Perl_var
	#define func CPerlObj::Perl_func
	* these are in objpp.h
This necessitated renaming some local variables and functions that
had the same name as a global variable or function. This was
probably a _good_ thing anyway.


EXTENSIONS
1. Access to global variables and perl functions is through a
pointer to the PERL_OBJECT. This pointer type is CPerlObj*. This is
made transparent to extension developers by the following macros:
	#define var pPerl->Perl_var
	#define func pPerl->Perl_func
	* these are done in objXSUB.h
This requires that the extension be compiled as C++, which means
that the code must be ANSI C and not K&R C. For K&R extensions,
please see the C API notes located in Win32/GenCAPI.pl. This script
creates a perlCAPI.lib that provides a K & R compatible C interface
to the PERL_OBJECT.
2. Local variables and functions cannot have the same name as perl's
variables or functions since the macros will redefine these. Look for
this if you get some strange error message and it does not look like
the code that you had written. This often happens with variables that
are local to a function.

PERL HOST
1. The perl host is linked with perlX.lib to get perl_alloc. This
function will return a pointer to CPerlObj (the PERL_OBJECT). It
takes pointers to the various PerlXXX_YYY interfaces (see iperlsys.h
for more information on this).
2. The perl host calls the same functions as normally would be
called in setting up and running a perl script, except that the
functions are now member functions of the PERL_OBJECT.

*/


class CPerlObj;

#define STATIC
#define CPERLscope(x) CPerlObj::x
#define CPERLproto CPerlObj *
#define _CPERLproto ,CPERLproto
#define CPERLarg CPerlObj *pPerl
#define CPERLarg_ CPERLarg,
#define _CPERLarg ,CPERLarg
#define PERL_OBJECT_THIS this
#define _PERL_OBJECT_THIS ,this
#define PERL_OBJECT_THIS_ this,
#define CALLRUNOPS (this->*PL_runops)
#define CALLREGCOMP (this->*PL_regcompp)
#define CALLREGEXEC (this->*PL_regexecp)

#else /* !PERL_OBJECT */

#define STATIC static
#define CPERLscope(x) x
#define CPERLproto
#define _CPERLproto
#define CPERLarg void
#define CPERLarg_
#define _CPERLarg
#define PERL_OBJECT_THIS
#define _PERL_OBJECT_THIS
#define PERL_OBJECT_THIS_
#define CALLRUNOPS PL_runops
#define CALLREGCOMP (*PL_regcompp)
#define CALLREGEXEC (*PL_regexecp)

#endif /* PERL_OBJECT */

#define VOIDUSED 1
#include "config.h"

#include "embed.h"

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C 
#  define END_EXTERN_C 
#  define EXTERN_C
#endif

#ifdef OP_IN_REGISTER
#  ifdef __GNUC__
#    define stringify_immed(s) #s
#    define stringify(s) stringify_immed(s)
#ifdef EMBED
register struct op *Perl_op asm(stringify(OP_IN_REGISTER));
#else
register struct op *op asm(stringify(OP_IN_REGISTER));
#endif
#  endif
#endif

/*
 * STMT_START { statements; } STMT_END;
 * can be used as a single statement, as in
 * if (x) STMT_START { ... } STMT_END; else ...
 *
 * Trying to select a version that gives no warnings...
 */
#if !(defined(STMT_START) && defined(STMT_END))
# if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(__cplusplus)
#   define STMT_START	(void)(	/* gcc supports ``({ STATEMENTS; })'' */
#   define STMT_END	)
# else
   /* Now which other defined()s do we need here ??? */
#  if (VOIDFLAGS) && (defined(sun) || defined(__sun__))
#   define STMT_START	if (1)
#   define STMT_END	else (void)0
#  else
#   define STMT_START	do
#   define STMT_END	while (0)
#  endif
# endif
#endif

#define NOOP (void)0

#define WITH_THR(s) STMT_START { dTHR; s; } STMT_END

/*
 * SOFT_CAST can be used for args to prototyped functions to retain some
 * type checking; it only casts if the compiler does not know prototypes.
 */
#if defined(CAN_PROTOTYPE) && defined(DEBUGGING_COMPILE)
#define SOFT_CAST(type)	
#else
#define SOFT_CAST(type)	(type)
#endif

#ifndef BYTEORDER  /* Should never happen -- byteorder is in config.h */
#   define BYTEORDER 0x1234
#endif

/* Overall memory policy? */
#ifndef CONSERVATIVE
#   define LIBERAL 1
#endif

#if 'A' == 65 && 'I' == 73 && 'J' == 74 && 'Z' == 90
#define ASCIIish
#else
#undef  ASCIIish
#endif

/*
 * The following contortions are brought to you on behalf of all the
 * standards, semi-standards, de facto standards, not-so-de-facto standards
 * of the world, as well as all the other botches anyone ever thought of.
 * The basic theory is that if we work hard enough here, the rest of the
 * code can be a lot prettier.  Well, so much for theory.  Sorry, Henry...
 */

/* define this once if either system, instead of cluttering up the src */
#if defined(MSDOS) || defined(atarist) || defined(WIN32)
#define DOSISH 1
#endif

#if defined(__STDC__) || defined(vax11c) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus)
# define STANDARD_C 1
#endif

#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX)
# define DONT_DECLARE_STD 1
#endif

#if defined(HASVOLATILE) || defined(STANDARD_C)
#   ifdef __cplusplus
#	define VOL		// to temporarily suppress warnings
#   else
#	define VOL volatile
#   endif
#else
#   define VOL
#endif

#define TAINT		(PL_tainted = TRUE)
#define TAINT_NOT	(PL_tainted = FALSE)
#define TAINT_IF(c)	if (c) { PL_tainted = TRUE; }
#define TAINT_ENV()	if (PL_tainting) { taint_env(); }
#define TAINT_PROPER(s)	if (PL_tainting) { taint_proper(Nullch, s); }

/* XXX All process group stuff is handled in pp_sys.c.  Should these 
   defines move there?  If so, I could simplify this a lot. --AD  9/96.
*/
/* Process group stuff changed from traditional BSD to POSIX.
   perlfunc.pod documents the traditional BSD-style syntax, so we'll
   try to preserve that, if possible.
*/
#ifdef HAS_SETPGID
#  define BSD_SETPGRP(pid, pgrp)	setpgid((pid), (pgrp))
#else
#  if defined(HAS_SETPGRP) && defined(USE_BSD_SETPGRP)
#    define BSD_SETPGRP(pid, pgrp)	setpgrp((pid), (pgrp))
#  else
#    ifdef HAS_SETPGRP2  /* DG/UX */
#      define BSD_SETPGRP(pid, pgrp)	setpgrp2((pid), (pgrp))
#    endif
#  endif
#endif
#if defined(BSD_SETPGRP) && !defined(HAS_SETPGRP)
#  define HAS_SETPGRP  /* Well, effectively it does . . . */
#endif

/* getpgid isn't POSIX, but at least Solaris and Linux have it, and it makes
    our life easier :-) so we'll try it.
*/
#ifdef HAS_GETPGID
#  define BSD_GETPGRP(pid)		getpgid((pid))
#else
#  if defined(HAS_GETPGRP) && defined(USE_BSD_GETPGRP)
#    define BSD_GETPGRP(pid)		getpgrp((pid))
#  else
#    ifdef HAS_GETPGRP2  /* DG/UX */
#      define BSD_GETPGRP(pid)		getpgrp2((pid))
#    endif
#  endif
#endif
#if defined(BSD_GETPGRP) && !defined(HAS_GETPGRP)
#  define HAS_GETPGRP  /* Well, effectively it does . . . */
#endif

/* These are not exact synonyms, since setpgrp() and getpgrp() may 
   have different behaviors, but perl.h used to define USE_BSDPGRP
   (prior to 5.003_05) so some extension might depend on it.
*/
#if defined(USE_BSD_SETPGRP) || defined(USE_BSD_GETPGRP)
#  ifndef USE_BSDPGRP
#    define USE_BSDPGRP
#  endif
#endif

#ifndef _TYPES_		/* If types.h defines this it's easy. */
#   ifndef major		/* Does everyone's types.h define this? */
#	include <sys/types.h>
#   endif
#endif

#ifdef __cplusplus
#  ifndef I_STDARG
#    define I_STDARG 1
#  endif
#endif

#ifdef I_STDARG
#  include <stdarg.h>
#else
#  ifdef I_VARARGS
#    include <varargs.h>
#  endif
#endif

#include "iperlsys.h"

#ifdef USE_NEXT_CTYPE

#if NX_CURRENT_COMPILER_RELEASE >= 400
#include <objc/NXCType.h>
#else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
#include <appkit/NXCType.h>
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */

#else /* !USE_NEXT_CTYPE */
#include <ctype.h>
#endif /* USE_NEXT_CTYPE */

#ifdef METHOD 	/* Defined by OSF/1 v3.0 by ctype.h */
#undef METHOD
#endif

#ifdef I_LOCALE
#   include <locale.h>
#endif

#if !defined(NO_LOCALE) && defined(HAS_SETLOCALE)
#   define USE_LOCALE
#   if !defined(NO_LOCALE_COLLATE) && defined(LC_COLLATE) \
       && defined(HAS_STRXFRM)
#	define USE_LOCALE_COLLATE
#   endif
#   if !defined(NO_LOCALE_CTYPE) && defined(LC_CTYPE)
#	define USE_LOCALE_CTYPE
#   endif
#   if !defined(NO_LOCALE_NUMERIC) && defined(LC_NUMERIC)
#	define USE_LOCALE_NUMERIC
#   endif
#endif /* !NO_LOCALE && HAS_SETLOCALE */

#include <setjmp.h>

#ifdef I_SYS_PARAM
#   ifdef PARAM_NEEDS_TYPES
#	include <sys/types.h>
#   endif
#   include <sys/param.h>
#endif


/* Use all the "standard" definitions? */
#if defined(STANDARD_C) && defined(I_STDLIB)
#   include <stdlib.h>
#endif

#define MEM_SIZE Size_t

/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */

#ifdef MYMALLOC

#   ifdef HIDEMYMALLOC
#	define malloc  Mymalloc
#	define calloc  Mycalloc
#	define realloc Myrealloc
#	define free    Myfree
Malloc_t Mymalloc _((MEM_SIZE nbytes));
Malloc_t Mycalloc _((MEM_SIZE elements, MEM_SIZE size));
Malloc_t Myrealloc _((Malloc_t where, MEM_SIZE nbytes));
Free_t   Myfree _((Malloc_t where));
#   endif
#   ifdef EMBEDMYMALLOC
#	define malloc  Perl_malloc
#	define calloc  Perl_calloc
#	define realloc Perl_realloc
/* VMS' external symbols are case-insensitive, and there's already a */
/* perl_free in perl.h */
#ifdef VMS
#	define free    Perl_myfree
#else
#	define free    Perl_free
#endif
Malloc_t Perl_malloc _((MEM_SIZE nbytes));
Malloc_t Perl_calloc _((MEM_SIZE elements, MEM_SIZE size));
Malloc_t Perl_realloc _((Malloc_t where, MEM_SIZE nbytes));
#ifdef VMS
Free_t   Perl_myfree _((Malloc_t where));
#else
Free_t   Perl_free _((Malloc_t where));
#endif
#   endif

#   undef safemalloc
#   undef safecalloc
#   undef saferealloc
#   undef safefree
#   define safemalloc  malloc
#   define safecalloc  calloc
#   define saferealloc realloc
#   define safefree    free

#endif /* MYMALLOC */

#if defined(STANDARD_C) && defined(I_STDDEF)
#   include <stddef.h>
#   define STRUCT_OFFSET(s,m)  offsetof(s,m)
#else
#   define STRUCT_OFFSET(s,m)  (Size_t)(&(((s *)0)->m))
#endif

#if defined(I_STRING) || defined(__cplusplus)
#   include <string.h>
#else
#   include <strings.h>
#endif

#if !defined(HAS_STRCHR) && defined(HAS_INDEX) && !defined(strchr)
#define strchr index
#define strrchr rindex
#endif

#ifdef I_MEMORY
#  include <memory.h>
#endif

#ifdef HAS_MEMCPY
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcpy
        extern char * memcpy _((char*, char*, int));
#    endif
#  endif
#else
#   ifndef memcpy
#	ifdef HAS_BCOPY
#	    define memcpy(d,s,l) bcopy(s,d,l)
#	else
#	    define memcpy(d,s,l) my_bcopy(s,d,l)
#	endif
#   endif
#endif /* HAS_MEMCPY */

#ifdef HAS_MEMSET
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memset
	extern char *memset _((char*, int, int));
#    endif
#  endif
#else
#  define memset(d,c,l) my_memset(d,c,l)
#endif /* HAS_MEMSET */

#if !defined(HAS_MEMMOVE) && !defined(memmove)
#   if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
#	define memmove(d,s,l) bcopy(s,d,l)
#   else
#	if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	    define memmove(d,s,l) memcpy(d,s,l)
#	else
#	    define memmove(d,s,l) my_bcopy(s,d,l)
#	endif
#   endif
#endif

#if defined(mips) && defined(ultrix) && !defined(__STDC__)
#   undef HAS_MEMCMP
#endif

#if defined(HAS_MEMCMP) && defined(HAS_SANE_MEMCMP)
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcmp
	extern int memcmp _((char*, char*, int));
#    endif
#  endif
#  ifdef BUGGY_MSC
  #  pragma function(memcmp)
#  endif
#else
#   ifndef memcmp
#	define memcmp 	my_memcmp
#   endif
#endif /* HAS_MEMCMP && HAS_SANE_MEMCMP */

#ifndef memzero
#   ifdef HAS_MEMSET
#	define memzero(d,l) memset(d,0,l)
#   else
#	ifdef HAS_BZERO
#	    define memzero(d,l) bzero(d,l)
#	else
#	    define memzero(d,l) my_bzero(d,l)
#	endif
#   endif
#endif

#ifndef HAS_BCMP
#   ifndef bcmp
#	define bcmp(s1,s2,l) memcmp(s1,s2,l)
#   endif
#endif /* !HAS_BCMP */

#ifdef I_NETINET_IN
#   include <netinet/in.h>
#endif

#ifdef I_ARPA_INET
#   include <arpa/inet.h>
#endif

#if defined(SF_APPEND) && defined(USE_SFIO) && defined(I_SFIO)
/* <sfio.h> defines SF_APPEND and <sys/stat.h> might define SF_APPEND
 * (the neo-BSD seem to do this).  */
#   undef SF_APPEND
#endif

#ifdef I_SYS_STAT
#   include <sys/stat.h>
#endif

/* The stat macros for Amdahl UTS, Unisoft System V/88 (and derivatives
   like UTekV) are broken, sometimes giving false positives.  Undefine
   them here and let the code below set them to proper values.

   The ghs macro stands for GreenHills Software C-1.8.5 which
   is the C compiler for sysV88 and the various derivatives.
   This header file bug is corrected in gcc-2.5.8 and later versions.
   --Kaveh Ghazi (ghazi@noc.rutgers.edu) 10/3/94.  */

#if defined(uts) || (defined(m88k) && defined(ghs))
#   undef S_ISDIR
#   undef S_ISCHR
#   undef S_ISBLK
#   undef S_ISREG
#   undef S_ISFIFO
#   undef S_ISLNK
#endif

#ifdef I_TIME
#   include <time.h>
#endif

#ifdef I_SYS_TIME
#   ifdef I_SYS_TIME_KERNEL
#	define KERNEL
#   endif
#   include <sys/time.h>
#   ifdef I_SYS_TIME_KERNEL
#	undef KERNEL
#   endif
#endif

#if defined(HAS_TIMES) && defined(I_SYS_TIMES)
#    include <sys/times.h>
#endif

#if defined(HAS_STRERROR) && (!defined(HAS_MKDIR) || !defined(HAS_RMDIR))
#   undef HAS_STRERROR
#endif

#include <errno.h>
#ifdef HAS_SOCKET
#   ifdef I_NET_ERRNO
#     include <net/errno.h>
#   endif
#endif

#ifdef VMS
#   define SETERRNO(errcode,vmserrcode) \
	STMT_START {			\
	    set_errno(errcode);		\
	    set_vaxc_errno(vmserrcode);	\
	} STMT_END
#else
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#endif

#ifdef USE_THREADS
#  define ERRSV (thr->errsv)
#  define ERRHV (thr->errhv)
#  define DEFSV THREADSV(0)
#  define SAVE_DEFSV save_threadsv(0)
#else
#  define ERRSV GvSV(PL_errgv)
#  define ERRHV GvHV(PL_errgv)
#  define DEFSV GvSV(PL_defgv)
#  define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
#endif /* USE_THREADS */

#ifndef errno
	extern int errno;     /* ANSI allows errno to be an lvalue expr */
#endif

#ifdef HAS_STRERROR
#       ifdef VMS
	char *strerror _((int,...));
#       else
#ifndef DONT_DECLARE_STD
	char *strerror _((int));
#endif
#       endif
#       ifndef Strerror
#           define Strerror strerror
#       endif
#else
#    ifdef HAS_SYS_ERRLIST
	extern int sys_nerr;
	extern char *sys_errlist[];
#       ifndef Strerror
#           define Strerror(e) \
		((e) < 0 || (e) >= sys_nerr ? "(unknown)" : sys_errlist[e])
#       endif
#   endif
#endif

#ifdef I_SYS_IOCTL
#   ifndef _IOCTL_
#	include <sys/ioctl.h>
#   endif
#endif

#if defined(mc300) || defined(mc500) || defined(mc700) || defined(mc6000)
#   ifdef HAS_SOCKETPAIR
#	undef HAS_SOCKETPAIR
#   endif
#   ifdef I_NDBM
#	undef I_NDBM
#   endif
#endif

#if INTSIZE == 2
#   define htoni htons
#   define ntohi ntohs
#else
#   define htoni htonl
#   define ntohi ntohl
#endif

/* Configure already sets Direntry_t */
#if defined(I_DIRENT)
#   include <dirent.h>
#   if defined(NeXT) && defined(I_SYS_DIR) /* NeXT needs dirent + sys/dir.h */
#	include <sys/dir.h>
#   endif
#else
#   ifdef I_SYS_NDIR
#	include <sys/ndir.h>
#   else
#	ifdef I_SYS_DIR
#	    ifdef hp9000s500
#		include <ndir.h>	/* may be wrong in the future */
#	    else
#		include <sys/dir.h>
#	    endif
#	endif
#   endif
#endif

#ifdef FPUTS_BOTCH
/* work around botch in SunOS 4.0.1 and 4.0.2 */
#   ifndef fputs
#	define fputs(sv,fp) fprintf(fp,"%s",sv)
#   endif
#endif

/*
 * The following gobbledygook brought to you on behalf of __STDC__.
 * (I could just use #ifndef __STDC__, but this is more bulletproof
 * in the face of half-implementations.)
 */

#ifndef S_IFMT
#   ifdef _S_IFMT
#	define S_IFMT _S_IFMT
#   else
#	define S_IFMT 0170000
#   endif
#endif

#ifndef S_ISDIR
#   define S_ISDIR(m) ((m & S_IFMT) == S_IFDIR)
#endif

#ifndef S_ISCHR
#   define S_ISCHR(m) ((m & S_IFMT) == S_IFCHR)
#endif

#ifndef S_ISBLK
#   ifdef S_IFBLK
#	define S_ISBLK(m) ((m & S_IFMT) == S_IFBLK)
#   else
#	define S_ISBLK(m) (0)
#   endif
#endif

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

#ifndef S_ISFIFO
#   ifdef S_IFIFO
#	define S_ISFIFO(m) ((m & S_IFMT) == S_IFIFO)
#   else
#	define S_ISFIFO(m) (0)
#   endif
#endif

#ifndef S_ISLNK
#   ifdef _S_ISLNK
#	define S_ISLNK(m) _S_ISLNK(m)
#   else
#	ifdef _S_IFLNK
#	    define S_ISLNK(m) ((m & S_IFMT) == _S_IFLNK)
#	else
#	    ifdef S_IFLNK
#		define S_ISLNK(m) ((m & S_IFMT) == S_IFLNK)
#	    else
#		define S_ISLNK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_ISSOCK
#   ifdef _S_ISSOCK
#	define S_ISSOCK(m) _S_ISSOCK(m)
#   else
#	ifdef _S_IFSOCK
#	    define S_ISSOCK(m) ((m & S_IFMT) == _S_IFSOCK)
#	else
#	    ifdef S_IFSOCK
#		define S_ISSOCK(m) ((m & S_IFMT) == S_IFSOCK)
#	    else
#		define S_ISSOCK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_IRUSR
#   ifdef S_IREAD
#	define S_IRUSR S_IREAD
#	define S_IWUSR S_IWRITE
#	define S_IXUSR S_IEXEC
#   else
#	define S_IRUSR 0400
#	define S_IWUSR 0200
#	define S_IXUSR 0100
#   endif
#   define S_IRGRP (S_IRUSR>>3)
#   define S_IWGRP (S_IWUSR>>3)
#   define S_IXGRP (S_IXUSR>>3)
#   define S_IROTH (S_IRUSR>>6)
#   define S_IWOTH (S_IWUSR>>6)
#   define S_IXOTH (S_IXUSR>>6)
#endif

#ifndef S_ISUID
#   define S_ISUID 04000
#endif

#ifndef S_ISGID
#   define S_ISGID 02000
#endif

#ifdef ff_next
#   undef ff_next
#endif

#if defined(cray) || defined(gould) || defined(i860) || defined(pyr)
#   define SLOPPYDIVIDE
#endif

#ifdef UV
#undef UV
#endif

/*  XXX QUAD stuff is not currently supported on most systems.
    Specifically, perl internals don't support long long.  Among
    the many problems is that some compilers support long long,
    but the underlying library functions (such as sprintf) don't.
    Some things do work (such as quad pack/unpack on convex);
    also some systems use long long for the fpos_t typedef.  That
    seems to work too.

    The IV type is supposed to be long enough to hold any integral
    value or a pointer.
    --Andy Dougherty	August 1996
*/

#ifdef cray
#   define Quad_t int
#else
#   ifdef convex
#	define Quad_t long long
#   else
#	if LONGSIZE == 8
#	    define Quad_t long
#	endif
#   endif
#endif

/* XXX Experimental set-up for long long.  Just add -DUSE_LONG_LONG
   to your ccflags.  --Andy Dougherty   4/1998
*/
#ifdef USE_LONG_LONG
#  if defined(HAS_LONG_LONG) && LONGLONGSIZE == 8
#    define Quad_t long long
#  endif
#endif

#ifdef Quad_t
#   define HAS_QUAD
    typedef Quad_t IV;
    typedef unsigned Quad_t UV;
#   define IV_MAX PERL_QUAD_MAX
#   define IV_MIN PERL_QUAD_MIN
#   define UV_MAX PERL_UQUAD_MAX
#   define UV_MIN PERL_UQUAD_MIN
#else
    typedef long IV;
    typedef unsigned long UV;
#   define IV_MAX PERL_LONG_MAX
#   define IV_MIN PERL_LONG_MIN
#   define UV_MAX PERL_ULONG_MAX
#   define UV_MIN PERL_ULONG_MIN
#endif

/* Previously these definitions used hardcoded figures. 
 * It is hoped these formula are more portable, although
 * no data one way or another is presently known to me.
 * The "PERL_" names are used because these calculated constants
 * do not meet the ANSI requirements for LONG_MAX, etc., which
 * need to be constants acceptable to #if - kja
 *    define PERL_LONG_MAX        2147483647L
 *    define PERL_LONG_MIN        (-LONG_MAX - 1)
 *    define PERL ULONG_MAX       4294967295L
 */

#ifdef I_LIMITS  /* Needed for cast_xxx() functions below. */
#  include <limits.h>
#else
#ifdef I_VALUES
#  include <values.h>
#endif
#endif

/*
 * Try to figure out max and min values for the integral types.  THE CORRECT
 * SOLUTION TO THIS MESS: ADAPT enquire.c FROM GCC INTO CONFIGURE.  The
 * following hacks are used if neither limits.h or values.h provide them:
 * U<TYPE>_MAX: for types >= int: ~(unsigned TYPE)0
 *              for types <  int:  (unsigned TYPE)~(unsigned)0
 *	The argument to ~ must be unsigned so that later signed->unsigned
 *	conversion can't modify the value's bit pattern (e.g. -0 -> +0),
 *	and it must not be smaller than int because ~ does integral promotion.
 * <type>_MAX: (<type>) (U<type>_MAX >> 1)
 * <type>_MIN: -<type>_MAX - <is_twos_complement_architecture: (3 & -1) == 3>.
 *	The latter is a hack which happens to work on some machines but
 *	does *not* catch any random system, or things like integer types
 *	with NaN if that is possible.
 *
 * All of the types are explicitly cast to prevent accidental loss of
 * numeric range, and in the hope that they will be less likely to confuse
 * over-eager optimizers.
 *
 */

#define PERL_UCHAR_MIN ((unsigned char)0)

#ifdef UCHAR_MAX
#  define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#else
#  ifdef MAXUCHAR
#    define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#  else
#    define PERL_UCHAR_MAX       ((unsigned char)~(unsigned)0)
#  endif
#endif
 
/*
 * CHAR_MIN and CHAR_MAX are not included here, as the (char) type may be
 * ambiguous. It may be equivalent to (signed char) or (unsigned char)
 * depending on local options. Until Configure detects this (or at least
 * detects whether the "signed" keyword is available) the CHAR ranges
 * will not be included. UCHAR functions normally.
 *                                                           - kja
 */

#define PERL_USHORT_MIN ((unsigned short)0)

#ifdef USHORT_MAX
#  define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#else
#  ifdef MAXUSHORT
#    define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#  else
#    ifdef USHRT_MAX
#      define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#    else
#      define PERL_USHORT_MAX       ((unsigned short)~(unsigned)0)
#    endif
#  endif
#endif

#ifdef SHORT_MAX
#  define PERL_SHORT_MAX ((short)SHORT_MAX)
#else
#  ifdef MAXSHORT    /* Often used in <values.h> */
#    define PERL_SHORT_MAX ((short)MAXSHORT)
#  else
#    ifdef SHRT_MAX
#      define PERL_SHORT_MAX ((short)SHRT_MAX)
#    else
#      define PERL_SHORT_MAX      ((short) (PERL_USHORT_MAX >> 1))
#    endif
#  endif
#endif

#ifdef SHORT_MIN
#  define PERL_SHORT_MIN ((short)SHORT_MIN)
#else
#  ifdef MINSHORT
#    define PERL_SHORT_MIN ((short)MINSHORT)
#  else
#    ifdef SHRT_MIN
#      define PERL_SHORT_MIN ((short)SHRT_MIN)
#    else
#      define PERL_SHORT_MIN        (-PERL_SHORT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifdef UINT_MAX
#  define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#else
#  ifdef MAXUINT
#    define PERL_UINT_MAX ((unsigned int)MAXUINT)
#  else
#    define PERL_UINT_MAX       (~(unsigned int)0)
#  endif
#endif

#define PERL_UINT_MIN ((unsigned int)0)

#ifdef INT_MAX
#  define PERL_INT_MAX ((int)INT_MAX)
#else
#  ifdef MAXINT    /* Often used in <values.h> */
#    define PERL_INT_MAX ((int)MAXINT)
#  else
#    define PERL_INT_MAX        ((int)(PERL_UINT_MAX >> 1))
#  endif
#endif

#ifdef INT_MIN
#  define PERL_INT_MIN ((int)INT_MIN)
#else
#  ifdef MININT
#    define PERL_INT_MIN ((int)MININT)
#  else
#    define PERL_INT_MIN        (-PERL_INT_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef ULONG_MAX
#  define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#else
#  ifdef MAXULONG
#    define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#  else
#    define PERL_ULONG_MAX       (~(unsigned long)0)
#  endif
#endif

#define PERL_ULONG_MIN ((unsigned long)0L)

#ifdef LONG_MAX
#  define PERL_LONG_MAX ((long)LONG_MAX)
#else
#  ifdef MAXLONG    /* Often used in <values.h> */
#    define PERL_LONG_MAX ((long)MAXLONG)
#  else
#    define PERL_LONG_MAX        ((long) (PERL_ULONG_MAX >> 1))
#  endif
#endif

#ifdef LONG_MIN
#  define PERL_LONG_MIN ((long)LONG_MIN)
#else
#  ifdef MINLONG
#    define PERL_LONG_MIN ((long)MINLONG)
#  else
#    define PERL_LONG_MIN        (-PERL_LONG_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef HAS_QUAD

#  ifdef UQUAD_MAX
#    define PERL_UQUAD_MAX ((UV)UQUAD_MAX)
#  else
#    define PERL_UQUAD_MAX	(~(UV)0)
#  endif

#  define PERL_UQUAD_MIN ((UV)0)

#  ifdef QUAD_MAX
#    define PERL_QUAD_MAX ((IV)QUAD_MAX)
#  else
#    define PERL_QUAD_MAX 	((IV) (PERL_UQUAD_MAX >> 1))
#  endif

#  ifdef QUAD_MIN
#    define PERL_QUAD_MIN ((IV)QUAD_MIN)
#  else
#    define PERL_QUAD_MIN 	(-PERL_QUAD_MAX - ((3 & -1) == 3))
#  endif

#endif

typedef MEM_SIZE STRLEN;

typedef struct op OP;
typedef struct cop COP;
typedef struct unop UNOP;
typedef struct binop BINOP;
typedef struct listop LISTOP;
typedef struct logop LOGOP;
typedef struct condop CONDOP;
typedef struct pmop PMOP;
typedef struct svop SVOP;
typedef struct gvop GVOP;
typedef struct pvop PVOP;
typedef struct loop LOOP;

typedef struct Outrec Outrec;
typedef struct interpreter PerlInterpreter;
#ifndef __BORLANDC__
typedef struct ff FF;		/* XXX not defined anywhere, should go? */
#endif
typedef struct sv SV;
typedef struct av AV;
typedef struct hv HV;
typedef struct cv CV;
typedef struct regexp REGEXP;
typedef struct gp GP;
typedef struct gv GV;
typedef struct io IO;
typedef struct context PERL_CONTEXT;
typedef struct block BLOCK;

typedef struct magic MAGIC;
typedef struct xrv XRV;
typedef struct xpv XPV;
typedef struct xpviv XPVIV;
typedef struct xpvuv XPVUV;
typedef struct xpvnv XPVNV;
typedef struct xpvmg XPVMG;
typedef struct xpvlv XPVLV;
typedef struct xpvav XPVAV;
typedef struct xpvhv XPVHV;
typedef struct xpvgv XPVGV;
typedef struct xpvcv XPVCV;
typedef struct xpvbm XPVBM;
typedef struct xpvfm XPVFM;
typedef struct xpvio XPVIO;
typedef struct mgvtbl MGVTBL;
typedef union any ANY;

#include "handy.h"

#ifdef PERL_OBJECT
typedef I32 (*filter_t) _((CPerlObj*, int, SV *, int));
#else
typedef I32 (*filter_t) _((int, SV *, int));
#endif

#define FILTER_READ(idx, sv, len)  filter_read(idx, sv, len)
#define FILTER_DATA(idx)	   (AvARRAY(PL_rsfp_filters)[idx])
#define FILTER_ISREADER(idx)	   (idx >= AvFILLp(PL_rsfp_filters))

#ifdef DOSISH
# if defined(OS2)
#   include "os2ish.h"
# else
#   include "dosish.h"
# endif
#else
# if defined(VMS)
#   include "vmsish.h"
# else
#   if defined(PLAN9)
#     include "./plan9/plan9ish.h"
#   else
#     if defined(MPE)
#       include "mpeix/mpeixish.h"
#     else
#       if defined(__VOS__)
#         include "vosish.h"
#       else
#         include "unixish.h"
#       endif
#     endif
#   endif
# endif
#endif         

#ifndef FUNC_NAME_TO_PTR
#define FUNC_NAME_TO_PTR(name)		name
#endif

/* 
 * USE_THREADS needs to be after unixish.h as <pthread.h> includes
 * <sys/signal.h> which defines NSIG - which will stop inclusion of <signal.h>
 * this results in many functions being undeclared which bothers C++
 * May make sense to have threads after "*ish.h" anyway
 */

#ifdef USE_THREADS
   /* pending resolution of licensing issues, we avoid the erstwhile
    * atomic.h everywhere */
#  define EMULATE_ATOMIC_REFCOUNTS

#  ifdef FAKE_THREADS
#    include "fakethr.h"
#  else
#    ifdef WIN32
#      include <win32thread.h>
#    else
#      ifdef OS2
#        include "os2thread.h"
#      else
#        ifdef I_MACH_CTHREADS
#          include <mach/cthreads.h>
#          ifdef NeXT
#            define MUTEX_INIT_CALLS_MALLOC
#          endif
typedef cthread_t	perl_os_thread;
typedef mutex_t		perl_mutex;
typedef condition_t	perl_cond;
typedef void *		perl_key;
#        else /* Posix threads */
#          include <pthread.h>
typedef pthread_t	perl_os_thread;
typedef pthread_mutex_t	perl_mutex;
typedef pthread_cond_t	perl_cond;
typedef pthread_key_t	perl_key;
#        endif /* I_MACH_CTHREADS */
#      endif /* OS2 */
#    endif /* WIN32 */
#  endif /* FAKE_THREADS */
#endif /* USE_THREADS */


  
#ifdef VMS
#   define STATUS_NATIVE	PL_statusvalue_vms
#   define STATUS_NATIVE_EXPORT \
	((I32)PL_statusvalue_vms == -1 ? 44 : PL_statusvalue_vms)
#   define STATUS_NATIVE_SET(n)						\
	STMT_START {							\
	    PL_statusvalue_vms = (n);					\
	    if ((I32)PL_statusvalue_vms == -1)				\
		PL_statusvalue = -1;					\
	    else if (PL_statusvalue_vms & STS$M_SUCCESS)		\
		PL_statusvalue = 0;					\
	    else if ((PL_statusvalue_vms & STS$M_SEVERITY) == 0)	\
		PL_statusvalue = 1 << 8;				\
	    else							\
		PL_statusvalue = (PL_statusvalue_vms & STS$M_SEVERITY) << 8;	\
	} STMT_END
#   define STATUS_POSIX	PL_statusvalue
#   ifdef VMSISH_STATUS
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_POSIX)
#   else
#	define STATUS_CURRENT	STATUS_POSIX
#   endif
#   define STATUS_POSIX_SET(n)				\
	STMT_START {					\
	    PL_statusvalue = (n);				\
	    if (PL_statusvalue != -1) {			\
		PL_statusvalue &= 0xFFFF;			\
		PL_statusvalue_vms = PL_statusvalue ? 44 : 1;	\
	    }						\
	    else PL_statusvalue_vms = -1;			\
	} STMT_END
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_vms = 1)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_vms = 44)
#else
#   define STATUS_NATIVE	STATUS_POSIX
#   define STATUS_NATIVE_EXPORT	STATUS_POSIX
#   define STATUS_NATIVE_SET	STATUS_POSIX_SET
#   define STATUS_POSIX		PL_statusvalue
#   define STATUS_POSIX_SET(n)		\
	STMT_START {			\
	    PL_statusvalue = (n);		\
	    if (PL_statusvalue != -1)	\
		PL_statusvalue &= 0xFFFF;	\
	} STMT_END
#   define STATUS_CURRENT STATUS_POSIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1)
#endif

/* Some unistd.h's give a prototype for pause() even though
   HAS_PAUSE ends up undefined.  This causes the #define
   below to be rejected by the compmiler.  Sigh.
*/
#ifdef HAS_PAUSE
#define Pause	pause
#else
#define Pause() sleep((32767<<16)+32767)
#endif

#ifndef IOCPARM_LEN
#   ifdef IOCPARM_MASK
	/* on BSDish systes we're safe */
#	define IOCPARM_LEN(x)  (((x) >> 16) & IOCPARM_MASK)
#   else
	/* otherwise guess at what's safe */
#	define IOCPARM_LEN(x)	256
#   endif
#endif

#ifdef UNION_ANY_DEFINITION
UNION_ANY_DEFINITION;
#else
union any {
    void*	any_ptr;
    I32		any_i32;
    IV		any_iv;
    long	any_long;
    void	(CPERLscope(*any_dptr)) _((void*));
};
#endif

#ifdef USE_THREADS
#define ARGSproto struct perl_thread *thr
#else
#define ARGSproto void
#endif /* USE_THREADS */

/* Work around some cygwin32 problems with importing global symbols */
#if defined(CYGWIN32) && defined(DLLIMPORT) 
#   include "cw32imp.h"
#endif

#include "regexp.h"
#include "sv.h"
#include "util.h"
#include "form.h"
#include "gv.h"
#include "cv.h"
#include "opcode.h"
#include "op.h"
#include "cop.h"
#include "av.h"
#include "hv.h"
#include "mg.h"
#include "scope.h"
#include "bytecode.h"
#include "byterun.h"

/* Current curly descriptor */
typedef struct curcur CURCUR;
struct curcur {
    int		parenfloor;	/* how far back to strip paren data */
    int		cur;		/* how many instances of scan we've matched */
    int		min;		/* the minimal number of scans to match */
    int		max;		/* the maximal number of scans to match */
    int		minmod;		/* whether to work our way up or down */
    regnode *	scan;		/* the thing to match */
    regnode *	next;		/* what has to match after it */
    char *	lastloc;	/* where we started matching this scan */
    CURCUR *	oldcc;		/* current curly before we started this one */
};

typedef struct _sublex_info SUBLEXINFO;
struct _sublex_info {
    I32 super_state;	/* lexer state to save */
    I32 sub_inwhat;	/* "lex_inwhat" to use */
    OP *sub_op;		/* "lex_op" to use */
};

#ifdef PERL_OBJECT
struct magic_state {
    SV* mgs_sv;
    U32 mgs_flags;
};
typedef struct magic_state MGS;

typedef struct {
    I32 len_min;
    I32 len_delta;
    I32 pos_min;
    I32 pos_delta;
    SV *last_found;
    I32 last_end;			/* min value, <0 unless valid. */
    I32 last_start_min;
    I32 last_start_max;
    SV **longest;			/* Either &l_fixed, or &l_float. */
    SV *longest_fixed;
    I32 offset_fixed;
    SV *longest_float;
    I32 offset_float_min;
    I32 offset_float_max;
    I32 flags;
} scan_data_t;

typedef I32 CHECKPOINT;
#endif /* PERL_OBJECT */

/* work around some libPW problems */
#ifdef DOINIT
EXT char Error[1];
#endif

#if defined(iAPX286) || defined(M_I286) || defined(I80286)
#   define I286
#endif

#if defined(htonl) && !defined(HAS_HTONL)
#define HAS_HTONL
#endif
#if defined(htons) && !defined(HAS_HTONS)
#define HAS_HTONS
#endif
#if defined(ntohl) && !defined(HAS_NTOHL)
#define HAS_NTOHL
#endif
#if defined(ntohs) && !defined(HAS_NTOHS)
#define HAS_NTOHS
#endif
#ifndef HAS_HTONL
#if (BYTEORDER & 0xffff) != 0x4321
#define HAS_HTONS
#define HAS_HTONL
#define HAS_NTOHS
#define HAS_NTOHL
#define MYSWAP
#define htons my_swap
#define htonl my_htonl
#define ntohs my_swap
#define ntohl my_ntohl
#endif
#else
#if (BYTEORDER & 0xffff) == 0x4321
#undef HAS_HTONS
#undef HAS_HTONL
#undef HAS_NTOHS
#undef HAS_NTOHL
#endif
#endif

/*
 * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.
 * -DWS
 */
#if BYTEORDER != 0x1234
# define HAS_VTOHL
# define HAS_VTOHS
# define HAS_HTOVL
# define HAS_HTOVS
# if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
#  define vtohl(x)	((((x)&0xFF)<<24)	\
			+(((x)>>24)&0xFF)	\
			+(((x)&0x0000FF00)<<8)	\
			+(((x)&0x00FF0000)>>8)	)
#  define vtohs(x)	((((x)&0xFF)<<8) + (((x)>>8)&0xFF))
#  define htovl(x)	vtohl(x)
#  define htovs(x)	vtohs(x)
# endif
	/* otherwise default to functions in util.c */
#endif

#ifdef CASTNEGFLOAT
#define U_S(what) ((U16)(what))
#define U_I(what) ((unsigned int)(what))
#define U_L(what) ((U32)(what))
#else
EXTERN_C U32 cast_ulong _((double));
#define U_S(what) ((U16)cast_ulong((double)(what)))
#define U_I(what) ((unsigned int)cast_ulong((double)(what)))
#define U_L(what) (cast_ulong((double)(what)))
#endif

#ifdef CASTI32
#define I_32(what) ((I32)(what))
#define I_V(what) ((IV)(what))
#define U_V(what) ((UV)(what))
#else
START_EXTERN_C
I32 cast_i32 _((double));
IV cast_iv _((double));
UV cast_uv _((double));
END_EXTERN_C
#define I_32(what) (cast_i32((double)(what)))
#define I_V(what) (cast_iv((double)(what)))
#define U_V(what) (cast_uv((double)(what)))
#endif

struct Outrec {
    I32		o_lines;
    char	*o_str;
    U32		o_len;
};

#ifndef MAXSYSFD
#   define MAXSYSFD 2
#endif

#ifndef TMPPATH
#  define TMPPATH "/tmp/perl-eXXXXXX"
#endif

#ifndef __cplusplus
Uid_t getuid _((void));
Uid_t geteuid _((void));
Gid_t getgid _((void));
Gid_t getegid _((void));
#endif

#ifdef DEBUGGING
#ifndef Perl_debug_log
#define Perl_debug_log	PerlIO_stderr()
#endif
#undef  YYDEBUG
#define YYDEBUG 1
#define DEB(a)     			a
#define DEBUG(a)   if (PL_debug)		a
#define DEBUG_p(a) if (PL_debug & 1)	a
#define DEBUG_s(a) if (PL_debug & 2)	a
#define DEBUG_l(a) if (PL_debug & 4)	a
#define DEBUG_t(a) if (PL_debug & 8)	a
#define DEBUG_o(a) if (PL_debug & 16)	a
#define DEBUG_c(a) if (PL_debug & 32)	a
#define DEBUG_P(a) if (PL_debug & 64)	a
#define DEBUG_m(a) if (PL_curinterp && PL_debug & 128)	a
#define DEBUG_f(a) if (PL_debug & 256)	a
#define DEBUG_r(a) if (PL_debug & 512)	a
#define DEBUG_x(a) if (PL_debug & 1024)	a
#define DEBUG_u(a) if (PL_debug & 2048)	a
#define DEBUG_L(a) if (PL_debug & 4096)	a
#define DEBUG_H(a) if (PL_debug & 8192)	a
#define DEBUG_X(a) if (PL_debug & 16384)	a
#define DEBUG_D(a) if (PL_debug & 32768)	a
#  ifdef USE_THREADS
#    define DEBUG_S(a) if (PL_debug & (1<<16))	a
#  else
#    define DEBUG_S(a)
#  endif
#else
#define DEB(a)
#define DEBUG(a)
#define DEBUG_p(a)
#define DEBUG_s(a)
#define DEBUG_l(a)
#define DEBUG_t(a)
#define DEBUG_o(a)
#define DEBUG_c(a)
#define DEBUG_P(a)
#define DEBUG_m(a)
#define DEBUG_f(a)
#define DEBUG_r(a)
#define DEBUG_x(a)
#define DEBUG_u(a)
#define DEBUG_S(a)
#define DEBUG_H(a)
#define DEBUG_X(a)
#define DEBUG_D(a)
#define DEBUG_S(a)
#endif
#define YYMAXDEPTH 300

#ifndef assert  /* <assert.h> might have been included somehow */
#define assert(what)	DEB( {						\
	if (!(what)) {							\
	    croak("Assertion failed: file \"%s\", line %d",		\
		__FILE__, __LINE__);					\
	    PerlProc_exit(1);							\
	}})
#endif

struct ufuncs {
    I32 (*uf_val)_((IV, SV*));
    I32 (*uf_set)_((IV, SV*));
    IV uf_index;
};

/* Fix these up for __STDC__ */
#ifndef DONT_DECLARE_STD
char *mktemp _((char*));
double atof _((const char*));
#endif

#ifndef STANDARD_C
/* All of these are in stdlib.h or time.h for ANSI C */
Time_t time();
struct tm *gmtime(), *localtime();
#ifdef OEMVS
char *(strchr)(), *(strrchr)();
char *(strcpy)(), *(strcat)();
#else
char *strchr(), *strrchr();
char *strcpy(), *strcat();
#endif
#endif /* ! STANDARD_C */


#ifdef I_MATH
#    include <math.h>
#else
START_EXTERN_C
	    double exp _((double));
	    double log _((double));
	    double log10 _((double));
	    double sqrt _((double));
	    double frexp _((double,int*));
	    double ldexp _((double,int));
	    double modf _((double,double*));
	    double sin _((double));
	    double cos _((double));
	    double atan2 _((double,double));
	    double pow _((double,double));
END_EXTERN_C
#endif

#ifndef __cplusplus
#  ifdef __NeXT__ /* or whatever catches all NeXTs */
char *crypt ();       /* Maybe more hosts will need the unprototyped version */
#  else
#    if !defined(WIN32) || !defined(HAVE_DES_FCRYPT)
char *crypt _((const char*, const char*));
#    endif /* !WIN32 && !HAVE_CRYPT_SOURCE */
#  endif /* !__NeXT__ */
#  ifndef DONT_DECLARE_STD
#    ifndef getenv
char *getenv _((const char*));
#    endif /* !getenv */
Off_t lseek _((int,Off_t,int));
#  endif /* !DONT_DECLARE_STD */
char *getlogin _((void));
#endif /* !__cplusplus */

#ifdef UNLINK_ALL_VERSIONS /* Currently only makes sense for VMS */
#define UNLINK unlnk
I32 unlnk _((char*));
#else
#define UNLINK PerlLIO_unlink
#endif

#ifndef HAS_SETREUID
#  ifdef HAS_SETRESUID
#    define setreuid(r,e) setresuid(r,e,(Uid_t)-1)
#    define HAS_SETREUID
#  endif
#endif
#ifndef HAS_SETREGID
#  ifdef HAS_SETRESGID
#    define setregid(r,e) setresgid(r,e,(Gid_t)-1)
#    define HAS_SETREGID
#  endif
#endif

typedef Signal_t (*Sighandler_t) _((int));

#ifdef HAS_SIGACTION
typedef struct sigaction Sigsave_t;
#else
typedef Sighandler_t Sigsave_t;
#endif

#define SCAN_DEF 0
#define SCAN_TR 1
#define SCAN_REPL 2

#ifdef DEBUGGING
# ifndef register
#  define register
# endif
# define PAD_SV(po) pad_sv(po)
# define RUNOPS_DEFAULT runops_debug
#else
# define PAD_SV(po) PL_curpad[po]
# define RUNOPS_DEFAULT runops_standard
#endif

#ifdef MYMALLOC
#  ifdef MUTEX_INIT_CALLS_MALLOC
#    define MALLOC_INIT					\
	STMT_START {					\
		PL_malloc_mutex = NULL;			\
		MUTEX_INIT(&PL_malloc_mutex);		\
	} STMT_END
#    define MALLOC_TERM					\
	STMT_START {					\
		perl_mutex tmp = PL_malloc_mutex;	\
		PL_malloc_mutex = NULL;			\
		MUTEX_DESTROY(&tmp);			\
	} STMT_END
#  else
#    define MALLOC_INIT MUTEX_INIT(&PL_malloc_mutex)
#    define MALLOC_TERM MUTEX_DESTROY(&PL_malloc_mutex)
#  endif
#else
#  define MALLOC_INIT
#  define MALLOC_TERM
#endif


/*
 * These need prototyping here because <proto.h> isn't
 * included until after runops is initialised.
 */

#ifndef PERL_OBJECT
typedef int runops_proc_t _((void));
int runops_standard _((void));
#ifdef DEBUGGING
int runops_debug _((void));
#endif
#endif  /* PERL_OBJECT */

/* _ (for $_) must be first in the following list (DEFSV requires it) */
#define THREADSV_NAMES "_123456789&`'+/.,\\\";^-%=|~:\001\005!@"

/* VMS doesn't use environ array and NeXT has problems with crt0.o globals */
#if !defined(VMS) && !(defined(NeXT) && defined(__DYNAMIC__))
#if !defined(DONT_DECLARE_STD) \
	|| (defined(__svr4__) && defined(__GNUC__) && defined(sun)) \
	|| defined(__sgi) || defined(__DGUX)
extern char **	environ;	/* environment variables supplied via exec */
#endif
#else
#  if defined(NeXT) && defined(__DYNAMIC__)

#  include <mach-o/dyld.h>
EXT char *** environ_pointer;
#  define environ (*environ_pointer)
#  endif
#endif /* environ processing */


/* for tmp use in stupid debuggers */
EXT int *	di;
EXT short *	ds;
EXT char *	dc;

/* handy constants */
EXTCONST char warn_uninit[]
  INIT("Use of uninitialized value");
EXTCONST char warn_nosemi[]
  INIT("Semicolon seems to be missing");
EXTCONST char warn_reserved[]
  INIT("Unquoted string \"%s\" may clash with future reserved word");
EXTCONST char warn_nl[]
  INIT("Unsuccessful %s on filename containing newline");
EXTCONST char no_wrongref[]
  INIT("Can't use %s ref as %s ref");
EXTCONST char no_symref[]
  INIT("Can't use string (\"%.32s\") as %s ref while \"strict refs\" in use");
EXTCONST char no_usym[]
  INIT("Can't use an undefined value as %s reference");
EXTCONST char no_aelem[]
  INIT("Modification of non-creatable array value attempted, subscript %d");
EXTCONST char no_helem[]
  INIT("Modification of non-creatable hash value attempted, subscript \"%s\"");
EXTCONST char no_modify[]
  INIT("Modification of a read-only value attempted");
EXTCONST char no_mem[]
  INIT("Out of memory!\n");
EXTCONST char no_security[]
  INIT("Insecure dependency in %s%s");
EXTCONST char no_sock_func[]
  INIT("Unsupported socket function \"%s\" called");
EXTCONST char no_dir_func[]
  INIT("Unsupported directory function \"%s\" called");
EXTCONST char no_func[]
  INIT("The %s function is unimplemented");
EXTCONST char no_myglob[]
  INIT("\"my\" variable %s can't be in a package");

#ifdef DOINIT
EXT char *sig_name[] = { SIG_NAME };
EXT int   sig_num[]  = { SIG_NUM };
#  ifndef PERL_OBJECT
EXT SV	* psig_ptr[sizeof(sig_num)/sizeof(*sig_num)];
EXT SV  * psig_name[sizeof(sig_num)/sizeof(*sig_num)];
#  endif
#else
EXT char *sig_name[];
EXT int   sig_num[];
#  ifndef PERL_OBJECT
EXT SV  * psig_ptr[];
EXT SV  * psig_name[];
#  endif
#endif


/* fast case folding tables */

#ifdef DOINIT
#ifdef EBCDIC
EXT unsigned char fold[] = { /* fast EBCDIC case folding table */
    0,      1,      2,      3,      4,      5,      6,      7,
    8,      9,      10,     11,     12,     13,     14,     15,
    16,     17,     18,     19,     20,     21,     22,     23,
    24,     25,     26,     27,     28,     29,     30,     31,
    32,     33,     34,     35,     36,     37,     38,     39,
    40,     41,     42,     43,     44,     45,     46,     47,
    48,     49,     50,     51,     52,     53,     54,     55,
    56,     57,     58,     59,     60,     61,     62,     63,
    64,     65,     66,     67,     68,     69,     70,     71,
    72,     73,     74,     75,     76,     77,     78,     79,
    80,     81,     82,     83,     84,     85,     86,     87,
    88,     89,     90,     91,     92,     93,     94,     95,
    96,     97,     98,     99,     100,    101,    102,    103,
    104,    105,    106,    107,    108,    109,    110,    111,
    112,    113,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    123,    124,    125,    126,    127,
    128,    'A',    'B',    'C',    'D',    'E',    'F',    'G',
    'H',    'I',    138,    139,    140,    141,    142,    143,
    144,    'J',    'K',    'L',    'M',    'N',    'O',    'P',
    'Q',    'R',    154,    155,    156,    157,    158,    159,
    160,    161,    'S',    'T',    'U',    'V',    'W',    'X',
    'Y',    'Z',    170,    171,    172,    173,    174,    175,
    176,    177,    178,    179,    180,    181,    182,    183,
    184,    185,    186,    187,    188,    189,    190,    191,
    192,    'a',    'b',    'c',    'd',    'e',    'f',    'g',
    'h',    'i',    202,    203,    204,    205,    206,    207,
    208,    'j',    'k',    'l',    'm',    'n',    'o',    'p',
    'q',    'r',    218,    219,    220,    221,    222,    223,
    224,    225,    's',    't',    'u',    'v',    'w',    'x',
    'y',    'z',    234,    235,    236,    237,    238,    239,
    240,    241,    242,    243,    244,    245,    246,    247,
    248,    249,    250,    251,    252,    253,    254,    255
};
#else   /* ascii rather than ebcdic */
EXTCONST  unsigned char fold[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#endif  /* !EBCDIC */
#else
EXTCONST unsigned char fold[];
#endif

#ifdef DOINIT
EXT unsigned char fold_locale[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#else
EXT unsigned char fold_locale[];
#endif

#ifdef DOINIT
#ifdef EBCDIC
EXT unsigned char freq[] = {/* EBCDIC frequencies for mixed English/C */
    1,      2,      84,     151,    154,    155,    156,    157,
    165,    246,    250,    3,      158,    7,      18,     29,
    40,     51,     62,     73,     85,     96,     107,    118,
    129,    140,    147,    148,    149,    150,    152,    153,
    255,      6,      8,      9,     10,     11,     12,     13,
     14,     15,     24,     25,     26,     27,     28,    226,
     29,     30,     31,     32,     33,     43,     44,     45,
     46,     47,     48,     49,     50,     76,     77,     78,
     79,     80,     81,     82,     83,     84,     85,     86,
     87,     94,     95,    234,    181,    233,    187,    190,
    180,     96,     97,     98,     99,    100,    101,    102,
    104,    112,    182,    174,    236,    232,    229,    103,
    228,    226,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    235,    176,    230,    194,    162,
    130,    131,    132,    133,    134,    135,    136,    137,
    138,    139,    201,    205,    163,    217,    220,    224,
    5,      248,    227,    244,    242,    255,    241,    231,
    240,    253,    16,     197,    19,     20,     21,     187,
    23,     169,    210,    245,    237,    249,    247,    239,
    168,    252,    34,     196,    36,     37,     38,     39,
    41,     42,     251,    254,    238,    223,    221,    213,
    225,    177,    52,     53,     54,     55,     56,     57,
    58,     59,     60,     61,     63,     64,     65,     66,
    67,     68,     69,     70,     71,     72,     74,     75,
    205,    208,    186,    202,    200,    218,    198,    179,
    178,    214,    88,     89,     90,     91,     92,     93,
    217,    166,    170,    207,    199,    209,    206,    204,
    160,    212,    105,    106,    108,    109,    110,    111,
    203,    113,    216,    215,    192,    175,    193,    243,
    172,    161,    123,    124,    125,    126,    127,    128,
    222,    219,    211,    195,    188,    193,    185,    184,
    191,    183,    141,    142,    143,    144,    145,    146
};
#else  /* ascii rather than ebcdic */
EXTCONST unsigned char freq[] = {	/* letter frequencies for mixed English/C */
	1,	2,	84,	151,	154,	155,	156,	157,
	165,	246,	250,	3,	158,	7,	18,	29,
	40,	51,	62,	73,	85,	96,	107,	118,
	129,	140,	147,	148,	149,	150,	152,	153,
	255,	182,	224,	205,	174,	176,	180,	217,
	233,	232,	236,	187,	235,	228,	234,	226,
	222,	219,	211,	195,	188,	193,	185,	184,
	191,	183,	201,	229,	181,	220,	194,	162,
	163,	208,	186,	202,	200,	218,	198,	179,
	178,	214,	166,	170,	207,	199,	209,	206,
	204,	160,	212,	216,	215,	192,	175,	173,
	243,	172,	161,	190,	203,	189,	164,	230,
	167,	248,	227,	244,	242,	255,	241,	231,
	240,	253,	169,	210,	245,	237,	249,	247,
	239,	168,	252,	251,	254,	238,	223,	221,
	213,	225,	177,	197,	171,	196,	159,	4,
	5,	6,	8,	9,	10,	11,	12,	13,
	14,	15,	16,	17,	19,	20,	21,	22,
	23,	24,	25,	26,	27,	28,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	41,	42,	43,	44,	45,	46,	47,	48,
	49,	50,	52,	53,	54,	55,	56,	57,
	58,	59,	60,	61,	63,	64,	65,	66,
	67,	68,	69,	70,	71,	72,	74,	75,
	76,	77,	78,	79,	80,	81,	82,	83,
	86,	87,	88,	89,	90,	91,	92,	93,
	94,	95,	97,	98,	99,	100,	101,	102,
	103,	104,	105,	106,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	119,	120,
	121,	122,	123,	124,	125,	126,	127,	128,
	130,	131,	132,	133,	134,	135,	136,	137,
	138,	139,	141,	142,	143,	144,	145,	146
};
#endif
#else
EXTCONST unsigned char freq[];
#endif

#ifdef DEBUGGING
#ifdef DOINIT
EXTCONST char* block_type[] = {
	"NULL",
	"SUB",
	"EVAL",
	"LOOP",
	"SUBST",
	"BLOCK",
};
#else
EXTCONST char* block_type[];
#endif
#endif

/*****************************************************************************/
/* This lexer/parser stuff is currently global since yacc is hard to reenter */
/*****************************************************************************/
/* XXX This needs to be revisited, since BEGIN makes yacc re-enter... */

#include "perly.h"

#define LEX_NOTPARSING		11	/* borrowed from toke.c */

typedef enum {
    XOPERATOR,
    XTERM,
    XREF,
    XSTATE,
    XBLOCK,
    XTERMBLOCK
} expectation;

enum {		/* pass one of these to get_vtbl */
    want_vtbl_sv,
    want_vtbl_env,
    want_vtbl_envelem,
    want_vtbl_sig,
    want_vtbl_sigelem,
    want_vtbl_pack,
    want_vtbl_packelem,
    want_vtbl_dbline,
    want_vtbl_isa,
    want_vtbl_isaelem,
    want_vtbl_arylen,
    want_vtbl_glob,
    want_vtbl_mglob,
    want_vtbl_nkeys,
    want_vtbl_taint,
    want_vtbl_substr,
    want_vtbl_vec,
    want_vtbl_pos,
    want_vtbl_bm,
    want_vtbl_fm,
    want_vtbl_uvar,
    want_vtbl_defelem,
    want_vtbl_regexp,
    want_vtbl_collxfrm,
    want_vtbl_amagic,
    want_vtbl_amagicelem
#ifdef USE_THREADS
    ,
    want_vtbl_mutex
#endif
};


				/* Note: the lowest 8 bits are reserved for
				   stuffing into op->op_private */
#define HINT_INTEGER		0x00000001
#define HINT_STRICT_REFS	0x00000002

#define HINT_BLOCK_SCOPE	0x00000100
#define HINT_STRICT_SUBS	0x00000200
#define HINT_STRICT_VARS	0x00000400
#define HINT_LOCALE		0x00000800

#define HINT_NEW_INTEGER	0x00001000
#define HINT_NEW_FLOAT		0x00002000
#define HINT_NEW_BINARY		0x00004000
#define HINT_NEW_STRING		0x00008000
#define HINT_NEW_RE		0x00010000
#define HINT_LOCALIZE_HH	0x00020000 /* %^H needs to be copied */

#define HINT_RE_TAINT		0x00100000
#define HINT_RE_EVAL		0x00200000

/* Various states of an input record separator SV (rs, nrs) */
#define RsSNARF(sv)   (! SvOK(sv))
#define RsSIMPLE(sv)  (SvOK(sv) && SvCUR(sv))
#define RsPARA(sv)    (SvOK(sv) && ! SvCUR(sv))
#define RsRECORD(sv)  (SvROK(sv) && (SvIV(SvRV(sv)) > 0))

/* Enable variables which are pointers to functions */
#ifdef PERL_OBJECT
typedef regexp*(CPerlObj::*regcomp_t) _((char* exp, char* xend, PMOP* pm));
typedef I32 (CPerlObj::*regexec_t) _((regexp* prog, char* stringarg,
				      char* strend, char* strbeg,
				      I32 minend, SV* screamer, void* data,
				      U32 flags));
#else
typedef regexp*(*regcomp_t) _((char* exp, char* xend, PMOP* pm));
typedef I32 (*regexec_t) _((regexp* prog, char* stringarg, char* strend, char*
			    strbeg, I32 minend, SV* screamer, void* data, 
			    U32 flags));

#endif

/* Set up PERLVAR macros for populating structs */
#define PERLVAR(var,type) type var;
#define PERLVARI(var,type,init) type var;
#define PERLVARIC(var,type,init) type var;

/* Interpreter exitlist entry */
typedef struct exitlistentry {
#ifdef PERL_OBJECT
    void (*fn) _((CPerlObj*, void*));
#else
    void (*fn) _((void*));
#endif
    void *ptr;
} PerlExitListEntry;

#ifdef PERL_OBJECT
extern "C" CPerlObj* perl_alloc _((IPerlMem*, IPerlEnv*, IPerlStdIO*, IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*));

typedef int (CPerlObj::*runops_proc_t) _((void));
#undef EXT
#define EXT
#undef EXTCONST
#define EXTCONST
#undef INIT
#define INIT(x)

const int perl_object_sig_num[]  = { SIG_NUM };
const int PSIG_SIZE = (sizeof(perl_object_sig_num)/sizeof(*perl_object_sig_num));


class CPerlObj {
public:
	CPerlObj(IPerlMem*, IPerlEnv*, IPerlStdIO*, IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*);
	void Init(void);
	void* operator new(size_t nSize, IPerlMem *pvtbl);
#endif /* PERL_OBJECT */

#ifdef PERL_GLOBAL_STRUCT
struct perl_vars {
#include "perlvars.h"
};

#ifdef PERL_CORE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#else /* PERL_CORE */
#if !defined(__GNUC__) || !defined(WIN32)
EXT
#endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#define PL_Vars (*((PL_VarsPtr) ? PL_VarsPtr : (PL_VarsPtr =  Perl_GetVars())))
#endif /* PERL_CORE */
#endif /* PERL_GLOBAL_STRUCT */

#ifdef MULTIPLICITY
/* If we have multiple interpreters define a struct 
   holding variables which must be per-interpreter
   If we don't have threads anything that would have 
   be per-thread is per-interpreter.
*/

struct interpreter {
#ifndef USE_THREADS
#include "thrdvar.h"
#endif
#include "intrpvar.h"
};

#else
struct interpreter {
    char broiled;
};
#endif

#ifdef USE_THREADS
/* If we have threads define a struct with all the variables
 * that have to be per-thread
 */


struct perl_thread {
#include "thrdvar.h"
};

typedef struct perl_thread *Thread;

#else
typedef void *Thread;
#endif

/* Done with PERLVAR macros for now ... */
#undef PERLVAR
#undef PERLVARI
#undef PERLVARIC

#include "thread.h"
#include "pp.h"
#include "proto.h"

#ifdef EMBED
#define Perl_sv_setptrobj(rv,ptr,name) Perl_sv_setref_iv(rv,name,(IV)ptr)
#define Perl_sv_setptrref(rv,ptr) Perl_sv_setref_iv(rv,Nullch,(IV)ptr)
#else
#define sv_setptrobj(rv,ptr,name) sv_setref_iv(rv,name,(IV)ptr)
#define sv_setptrref(rv,ptr) sv_setref_iv(rv,Nullch,(IV)ptr)
#endif

/* The following must follow proto.h as #defines mess up syntax */

#include "embedvar.h"

/* Now include all the 'global' variables 
 * If we don't have threads or multiple interpreters
 * these include variables that would have been their struct-s 
 */
                         
#define PERLVAR(var,type) EXT type PL_##var;
#define PERLVARI(var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(var,type,init) EXTCONST type PL_##var INIT(init);

#ifndef PERL_GLOBAL_STRUCT
#include "perlvars.h"
#endif

#ifndef MULTIPLICITY

#  include "intrpvar.h"
#  ifndef USE_THREADS
#    include "thrdvar.h"
#  endif

#endif

#ifdef PERL_OBJECT
/* from perly.c */
#undef  yydebug
#undef  yynerrs
#undef  yyerrflag
#undef  yychar
#undef  yyssp
#undef  yyvsp
#undef  yyval
#undef  yylval
#define yydebug	    PL_yydebug
#define yynerrs	    PL_yynerrs
#define yyerrflag   PL_yyerrflag
#define yychar	    PL_yychar
#define yyssp	    PL_yyssp
#define yyvsp	    PL_yyvsp
#define yyval	    PL_yyval
#define yylval	    PL_yylval
PERLVAR(yydebug,		int)
PERLVAR(yynerrs,		int)
PERLVAR(yyerrflag,		int)
PERLVAR(yychar,			int)
PERLVAR(yyssp,			short*)
PERLVAR(yyvsp,			YYSTYPE*)
PERLVAR(yyval,			YYSTYPE)
PERLVAR(yylval,			YYSTYPE)

#define efloatbuf		PL_efloatbuf
#define efloatsize		PL_efloatsize
PERLVAR(efloatbuf,		char *)
PERLVAR(efloatsize,		STRLEN)

#define glob_index		PL_glob_index
#define srand_called	PL_srand_called
#define uudmap			PL_uudmap
#define bitcount		PL_bitcount
#define filter_debug	PL_filter_debug
PERLVAR(glob_index,		int)
PERLVAR(srand_called,	bool)
PERLVAR(uudmap[256],	char)
PERLVAR(bitcount,		char*)
PERLVAR(filter_debug,	int)
PERLVAR(super_bufptr,	char*)	/* PL_bufptr that was */
PERLVAR(super_bufend,	char*)	/* PL_bufend that was */

#define psig_ptr		PL_psig_ptr
#define psig_name		PL_psig_name
PERLVAR(psig_ptr[PSIG_SIZE], SV*);
PERLVAR(psig_name[PSIG_SIZE], SV*);

/*
 * The following is a buffer where new variables must
 * be defined to maintain binary compatibility with PERL_OBJECT
 * for 5.005
 */
PERLVAR(object_compatibility[30],	char)
};

#include "objpp.h"
#ifdef DOINIT
#include "INTERN.h"
#else
#include "EXTERN.h"
#endif
#endif  /* PERL_OBJECT */


#undef PERLVAR
#undef PERLVARI
#undef PERLVARIC

#if defined(HASATTRIBUTE) && defined(WIN32)
/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 * It has to go here or #define of printf messes up __attribute__
 * stuff in proto.h  
 */
#ifndef PERL_OBJECT
#  include <win32iop.h>
#endif  /* PERL_OBJECT */
#endif	/* WIN32 */

#ifdef DOINIT

EXT MGVTBL vtbl_sv =	{magic_get,
				magic_set,
					magic_len,
						0,	0};
EXT MGVTBL vtbl_env =	{0,	magic_set_all_env,
				0,	magic_clear_all_env,
							0};
EXT MGVTBL vtbl_envelem =	{0,	magic_setenv,
					0,	magic_clearenv,
							0};
EXT MGVTBL vtbl_sig =	{0,	0,		 0, 0, 0};
EXT MGVTBL vtbl_sigelem =	{magic_getsig,
					magic_setsig,
					0,	magic_clearsig,
							0};
EXT MGVTBL vtbl_pack =	{0,	0,	magic_sizepack,	magic_wipepack,
							0};
EXT MGVTBL vtbl_packelem =	{magic_getpack,
				magic_setpack,
					0,	magic_clearpack,
							0};
EXT MGVTBL vtbl_dbline =	{0,	magic_setdbline,
					0,	0,	0};
EXT MGVTBL vtbl_isa =	{0,	magic_setisa,
					0,	magic_setisa,
							0};
EXT MGVTBL vtbl_isaelem =	{0,	magic_setisa,
					0,	0,	0};
EXT MGVTBL vtbl_arylen =	{magic_getarylen,
				magic_setarylen,
					0,	0,	0};
EXT MGVTBL vtbl_glob =	{magic_getglob,
				magic_setglob,
					0,	0,	0};
EXT MGVTBL vtbl_mglob =	{0,	magic_setmglob,
					0,	0,	0};
EXT MGVTBL vtbl_nkeys =	{magic_getnkeys,
				magic_setnkeys,
					0,	0,	0};
EXT MGVTBL vtbl_taint =	{magic_gettaint,magic_settaint,
					0,	0,	0};
EXT MGVTBL vtbl_substr =	{magic_getsubstr, magic_setsubstr,
					0,	0,	0};
EXT MGVTBL vtbl_vec =	{magic_getvec,
				magic_setvec,
					0,	0,	0};
EXT MGVTBL vtbl_pos =	{magic_getpos,
				magic_setpos,
					0,	0,	0};
EXT MGVTBL vtbl_bm =	{0,	magic_setbm,
					0,	0,	0};
EXT MGVTBL vtbl_fm =	{0,	magic_setfm,
					0,	0,	0};
EXT MGVTBL vtbl_uvar =	{magic_getuvar,
				magic_setuvar,
					0,	0,	0};
#ifdef USE_THREADS
EXT MGVTBL vtbl_mutex =	{0,	0,	0,	0,	magic_mutexfree};
#endif /* USE_THREADS */
EXT MGVTBL vtbl_defelem = {magic_getdefelem,magic_setdefelem,
					0,	0,	0};

EXT MGVTBL vtbl_regexp = {0,0,0,0, magic_freeregexp};

#ifdef USE_LOCALE_COLLATE
EXT MGVTBL vtbl_collxfrm = {0,
				magic_setcollxfrm,
					0,	0,	0};
#endif

#ifdef OVERLOAD
EXT MGVTBL vtbl_amagic =       {0,     magic_setamagic,
                                        0,      0,      magic_setamagic};
EXT MGVTBL vtbl_amagicelem =   {0,     magic_setamagic,
                                        0,      0,      magic_setamagic};
#endif /* OVERLOAD */

#else /* !DOINIT */

EXT MGVTBL vtbl_sv;
EXT MGVTBL vtbl_env;
EXT MGVTBL vtbl_envelem;
EXT MGVTBL vtbl_sig;
EXT MGVTBL vtbl_sigelem;
EXT MGVTBL vtbl_pack;
EXT MGVTBL vtbl_packelem;
EXT MGVTBL vtbl_dbline;
EXT MGVTBL vtbl_isa;
EXT MGVTBL vtbl_isaelem;
EXT MGVTBL vtbl_arylen;
EXT MGVTBL vtbl_glob;
EXT MGVTBL vtbl_mglob;
EXT MGVTBL vtbl_nkeys;
EXT MGVTBL vtbl_taint;
EXT MGVTBL vtbl_substr;
EXT MGVTBL vtbl_vec;
EXT MGVTBL vtbl_pos;
EXT MGVTBL vtbl_bm;
EXT MGVTBL vtbl_fm;
EXT MGVTBL vtbl_uvar;

#ifdef USE_THREADS
EXT MGVTBL vtbl_mutex;
#endif /* USE_THREADS */

EXT MGVTBL vtbl_defelem;
EXT MGVTBL vtbl_regexp;

#ifdef USE_LOCALE_COLLATE
EXT MGVTBL vtbl_collxfrm;
#endif

#ifdef OVERLOAD
EXT MGVTBL vtbl_amagic;
EXT MGVTBL vtbl_amagicelem;
#endif /* OVERLOAD */

#endif /* !DOINIT */

#ifdef OVERLOAD

#define NofAMmeth 58
#ifdef DOINIT
EXTCONST char * AMG_names[NofAMmeth] = {
  "fallback",	"abs",			/* "fallback" should be the first. */
  "bool",	"nomethod",
  "\"\"",	"0+",
  "+",		"+=",
  "-",		"-=",
  "*",		"*=",
  "/",		"/=",
  "%",		"%=",
  "**",		"**=",
  "<<",		"<<=",
  ">>",		">>=",
  "&",		"&=",
  "|",		"|=",
  "^",		"^=",
  "<",		"<=",
  ">",		">=",
  "==",		"!=",
  "<=>",	"cmp",
  "lt",		"le",
  "gt",		"ge",
  "eq",		"ne",
  "!",		"~",
  "++",		"--",
  "atan2",	"cos",
  "sin",	"exp",
  "log",	"sqrt",
  "x",		"x=",
  ".",		".=",
  "=",		"neg"
};
#else
EXTCONST char * AMG_names[NofAMmeth];
#endif /* def INITAMAGIC */

struct am_table {
  long was_ok_sub;
  long was_ok_am;
  U32 flags;
  CV* table[NofAMmeth];
  long fallback;
};
struct am_table_short {
  long was_ok_sub;
  long was_ok_am;
  U32 flags;
};
typedef struct am_table AMT;
typedef struct am_table_short AMTS;

#define AMGfallNEVER	1
#define AMGfallNO	2
#define AMGfallYES	3

#define AMTf_AMAGIC		1
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)

enum {
  fallback_amg,	abs_amg,
  bool__amg,	nomethod_amg,
  string_amg,	numer_amg,
  add_amg,	add_ass_amg,
  subtr_amg,	subtr_ass_amg,
  mult_amg,	mult_ass_amg,
  div_amg,	div_ass_amg,
  modulo_amg,	modulo_ass_amg,
  pow_amg,	pow_ass_amg,
  lshift_amg,	lshift_ass_amg,
  rshift_amg,	rshift_ass_amg,
  band_amg,	band_ass_amg,
  bor_amg,	bor_ass_amg,
  bxor_amg,	bxor_ass_amg,
  lt_amg,	le_amg,
  gt_amg,	ge_amg,
  eq_amg,	ne_amg,
  ncmp_amg,	scmp_amg,
  slt_amg,	sle_amg,
  sgt_amg,	sge_amg,
  seq_amg,	sne_amg,
  not_amg,	compl_amg,
  inc_amg,	dec_amg,
  atan2_amg,	cos_amg,
  sin_amg,	exp_amg,
  log_amg,	sqrt_amg,
  repeat_amg,   repeat_ass_amg,
  concat_amg,	concat_ass_amg,
  copy_amg,	neg_amg
};

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

#endif /* OVERLOAD */

#define PERLDB_ALL	0x3f		/* No _NONAME, _GOTO */
#define PERLDBf_SUB	0x01		/* Debug sub enter/exit. */
#define PERLDBf_LINE	0x02		/* Keep line #. */
#define PERLDBf_NOOPT	0x04		/* Switch off optimizations. */
#define PERLDBf_INTER	0x08		/* Preserve more data for
					   later inspections.  */
#define PERLDBf_SUBLINE	0x10		/* Keep subr source lines. */
#define PERLDBf_SINGLE	0x20		/* Start with single-step on. */
#define PERLDBf_NONAME	0x40		/* For _SUB: no name of the subr. */
#define PERLDBf_GOTO	0x80		/* Report goto: call DB::goto. */

#define PERLDB_SUB	(PL_perldb && (PL_perldb & PERLDBf_SUB))
#define PERLDB_LINE	(PL_perldb && (PL_perldb & PERLDBf_LINE))
#define PERLDB_NOOPT	(PL_perldb && (PL_perldb & PERLDBf_NOOPT))
#define PERLDB_INTER	(PL_perldb && (PL_perldb & PERLDBf_INTER))
#define PERLDB_SUBLINE	(PL_perldb && (PL_perldb & PERLDBf_SUBLINE))
#define PERLDB_SINGLE	(PL_perldb && (PL_perldb & PERLDBf_SINGLE))
#define PERLDB_SUB_NN	(PL_perldb && (PL_perldb & (PERLDBf_NONAME)))
#define PERLDB_GOTO	(PL_perldb && (PL_perldb & PERLDBf_GOTO))


#ifdef USE_LOCALE_NUMERIC

#define SET_NUMERIC_STANDARD() \
    STMT_START {				\
	if (! PL_numeric_standard)			\
	    perl_set_numeric_standard();	\
    } STMT_END

#define SET_NUMERIC_LOCAL() \
    STMT_START {				\
	if (! PL_numeric_local)			\
	    perl_set_numeric_local();		\
    } STMT_END

#else /* !USE_LOCALE_NUMERIC */

#define SET_NUMERIC_STANDARD()  /**/
#define SET_NUMERIC_LOCAL()     /**/

#endif /* !USE_LOCALE_NUMERIC */

#if !defined(PERLIO_IS_STDIO) && defined(HASATTRIBUTE)
/* 
 * Now we have __attribute__ out of the way 
 * Remap printf 
 */
#define printf PerlIO_stdoutf
#endif

#ifndef PERL_SCRIPT_MODE
#define PERL_SCRIPT_MODE "r"
#endif

/*
 * nice_chunk and nice_chunk size need to be set
 * and queried under the protection of sv_mutex
 */
#define offer_nice_chunk(chunk, chunk_size) do {	\
	LOCK_SV_MUTEX;					\
	if (!PL_nice_chunk) {				\
	    PL_nice_chunk = (char*)(chunk);		\
	    PL_nice_chunk_size = (chunk_size);		\
	}						\
	else {						\
	    Safefree(chunk);				\
	}						\
	UNLOCK_SV_MUTEX;				\
    } while (0)

#ifdef HAS_SEM
#   include <sys/ipc.h>
#   include <sys/sem.h>
#   ifndef HAS_UNION_SEMUN	/* Provide the union semun. */
    union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
    };
#   endif
#   ifdef USE_SEMCTL_SEMUN
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   else
#       ifdef USE_SEMCTL_SEMID_DS
#           define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
#       endif
#   endif
#   ifndef Semctl	/* Place our bets on the semun horse. */
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   endif
#endif

#ifdef IAMSUID

#ifdef I_SYS_STATVFS
#   include <sys/statvfs.h>     /* for f?statvfs() */
#endif
#ifdef I_SYS_MOUNT
#   include <sys/mount.h>       /* for *BSD f?statfs() */
#endif
#ifdef I_MNTENT
#   include <mntent.h>          /* for getmntent() */
#endif

#endif /* IAMSUID */

#endif /* Include guard */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlsdio.h ===
/*
 * Although we may not want stdio to be used including <stdio.h> here 
 * avoids issues where stdio.h has strange side effects
 */
#include <stdio.h>

#ifdef PERLIO_IS_STDIO
/*
 * Make this as close to original stdio as possible.
 */
#define PerlIO				FILE 
#define PerlIO_stderr()			stderr
#define PerlIO_stdout()			stdout
#define PerlIO_stdin()			stdin

#define PerlIO_printf			fprintf
#define PerlIO_stdoutf			printf
#define PerlIO_vprintf(f,fmt,a)		vfprintf(f,fmt,a)          
#define PerlIO_write(f,buf,count)	fwrite1(buf,1,count,f)
#define PerlIO_open			fopen
#define PerlIO_fdopen			fdopen
#define PerlIO_reopen		freopen
#define PerlIO_close(f)			fclose(f)
#define PerlIO_puts(f,s)		fputs(s,f)
#define PerlIO_putc(f,c)		fputc(c,f)
#if defined(VMS)
#  if defined(__DECC)
     /* Unusual definition of ungetc() here to accomodate fast_sv_gets()'
      * belief that it can mix getc/ungetc with reads from stdio buffer */
     int decc$ungetc(int __c, FILE *__stream);
#    define PerlIO_ungetc(f,c) ((c) == EOF ? EOF : \
            ((*(f) && !((*(f))->_flag & _IONBF) && \
            ((*(f))->_ptr > (*(f))->_base)) ? \
            ((*(f))->_cnt++, *(--(*(f))->_ptr) = (c)) : decc$ungetc(c,f)))
#  else
#    define PerlIO_ungetc(f,c)		ungetc(c,f)
#  endif
   /* Work around bug in DECCRTL/AXP (DECC v5.x) and some versions of old
    * VAXCRTL which causes read from a pipe after EOF has been returned
    * once to hang.
    */
#  define PerlIO_getc(f) \
		(feof(f) ? EOF : getc(f))
#  define PerlIO_read(f,buf,count) \
		(feof(f) ? 0 : (SSize_t)fread(buf,1,count,f))
#else
#  define PerlIO_ungetc(f,c)		ungetc(c,f)
#  define PerlIO_getc(f)		getc(f)
#  define PerlIO_read(f,buf,count)	(SSize_t)fread(buf,1,count,f)
#endif
#define PerlIO_eof(f)			feof(f)
#define PerlIO_getname(f,b)		fgetname(f,b)
#define PerlIO_error(f)			ferror(f)
#define PerlIO_fileno(f)		fileno(f)
#define PerlIO_clearerr(f)		clearerr(f)
#define PerlIO_flush(f)			Fflush(f)
#define PerlIO_tell(f)			ftell(f)
#if defined(VMS) && !defined(__DECC)
   /* Old VAXC RTL doesn't reset EOF on seek; Perl folk seem to expect this */
#  define PerlIO_seek(f,o,w)	(((f) && (*f) && ((*f)->_flag &= ~_IOEOF)),fseek(f,o,w))
#else
#  define PerlIO_seek(f,o,w)		fseek(f,o,w)
#endif
#ifdef HAS_FGETPOS
#define PerlIO_getpos(f,p)		fgetpos(f,p)
#endif
#ifdef HAS_FSETPOS
#define PerlIO_setpos(f,p)		fsetpos(f,p)
#endif

#define PerlIO_rewind(f)		rewind(f)
#define PerlIO_tmpfile()		tmpfile()

#define PerlIO_importFILE(f,fl)		(f)            
#define PerlIO_exportFILE(f,fl)		(f)            
#define PerlIO_findFILE(f)		(f)            
#define PerlIO_releaseFILE(p,f)		((void) 0)            

#ifdef HAS_SETLINEBUF
#define PerlIO_setlinebuf(f)		setlinebuf(f);
#else
#define PerlIO_setlinebuf(f)		setvbuf(f, Nullch, _IOLBF, 0);
#endif

/* Now our interface to Configure's FILE_xxx macros */

#ifdef USE_STDIO_PTR
#define PerlIO_has_cntptr(f)		1       
#define PerlIO_get_ptr(f)		FILE_ptr(f)          
#define PerlIO_get_cnt(f)		FILE_cnt(f)          

#ifdef STDIO_CNT_LVALUE
#define PerlIO_canset_cnt(f)		1      
#ifdef STDIO_PTR_LVALUE
#define PerlIO_fast_gets(f)		1        
#endif
#define PerlIO_set_cnt(f,c)		(FILE_cnt(f) = (c))          
#else
#define PerlIO_canset_cnt(f)		0      
#define PerlIO_set_cnt(f,c)		abort()
#endif

#ifdef STDIO_PTR_LVALUE
#define PerlIO_set_ptrcnt(f,p,c)	(FILE_ptr(f) = (p), PerlIO_set_cnt(f,c))          
#else
#define PerlIO_set_ptrcnt(f,p,c)	abort()
#endif

#else  /* USE_STDIO_PTR */

#define PerlIO_has_cntptr(f)		0
#define PerlIO_canset_cnt(f)		0
#define PerlIO_get_cnt(f)		(abort(),0)
#define PerlIO_get_ptr(f)		(abort(),(void *)0)
#define PerlIO_set_cnt(f,c)		abort()
#define PerlIO_set_ptrcnt(f,p,c)	abort()

#endif /* USE_STDIO_PTR */

#ifndef PerlIO_fast_gets
#define PerlIO_fast_gets(f)		0        
#endif


#ifdef FILE_base
#define PerlIO_has_base(f)		1         
#define PerlIO_get_base(f)		FILE_base(f)         
#define PerlIO_get_bufsiz(f)		FILE_bufsiz(f)       
#else
#define PerlIO_has_base(f)		0
#define PerlIO_get_base(f)		(abort(),(void *)0)
#define PerlIO_get_bufsiz(f)		(abort(),0)
#endif
#else /* PERLIO_IS_STDIO */
#ifdef PERL_CORE
#ifndef PERLIO_NOT_STDIO
#define PERLIO_NOT_STDIO 1
#endif
#endif
#ifdef PERLIO_NOT_STDIO
#if PERLIO_NOT_STDIO
/*
 * Strong denial of stdio - make all stdio calls (we can think of) errors
 */
#include "nostdio.h"
#undef fprintf
#undef tmpfile
#undef fclose
#undef fopen
#undef vfprintf
#undef fgetc
#undef fputc
#undef fputs
#undef ungetc
#undef fread
#undef fwrite
#undef fgetpos
#undef fseek
#undef fsetpos
#undef ftell
#undef rewind
#undef fdopen
#undef popen
#undef pclose
#undef getw
#undef putw
#undef freopen
#undef setbuf
#undef setvbuf
#undef fscanf
#undef fgets
#undef getc_unlocked
#undef putc_unlocked
#define fprintf    _CANNOT _fprintf_
#define stdin      _CANNOT _stdin_
#define stdout     _CANNOT _stdout_
#define stderr     _CANNOT _stderr_
#define tmpfile()  _CANNOT _tmpfile_
#define fclose(f)  _CANNOT _fclose_
#define fflush(f)  _CANNOT _fflush_
#define fopen(p,m)  _CANNOT _fopen_
#define freopen(p,m,f)  _CANNOT _freopen_
#define setbuf(f,b)  _CANNOT _setbuf_
#define setvbuf(f,b,x,s)  _CANNOT _setvbuf_
#define fscanf  _CANNOT _fscanf_
#define vfprintf(f,fmt,a)  _CANNOT _vfprintf_
#define fgetc(f)  _CANNOT _fgetc_
#define fgets(s,n,f)  _CANNOT _fgets_
#define fputc(c,f)  _CANNOT _fputc_
#define fputs(s,f)  _CANNOT _fputs_
#define getc(f)  _CANNOT _getc_
#define putc(c,f)  _CANNOT _putc_
#define ungetc(c,f)  _CANNOT _ungetc_
#define fread(b,s,c,f)  _CANNOT _fread_
#define fwrite(b,s,c,f)  _CANNOT _fwrite_
#define fgetpos(f,p)  _CANNOT _fgetpos_
#define fseek(f,o,w)  _CANNOT _fseek_
#define fsetpos(f,p)  _CANNOT _fsetpos_
#define ftell(f)  _CANNOT _ftell_
#define rewind(f)  _CANNOT _rewind_
#define clearerr(f)  _CANNOT _clearerr_
#define feof(f)  _CANNOT _feof_
#define ferror(f)  _CANNOT _ferror_
#define __filbuf(f)  _CANNOT __filbuf_
#define __flsbuf(c,f)  _CANNOT __flsbuf_
#define _filbuf(f)  _CANNOT _filbuf_
#define _flsbuf(c,f)  _CANNOT _flsbuf_
#define fdopen(fd,p)  _CANNOT _fdopen_
#define fileno(f)  _CANNOT _fileno_
#define flockfile(f)  _CANNOT _flockfile_
#define ftrylockfile(f)  _CANNOT _ftrylockfile_
#define funlockfile(f)  _CANNOT _funlockfile_
#define getc_unlocked(f)  _CANNOT _getc_unlocked_
#define putc_unlocked(c,f)  _CANNOT _putc_unlocked_
#define popen(c,m)  _CANNOT _popen_
#define getw(f)  _CANNOT _getw_
#define putw(v,f)  _CANNOT _putw_
#define pclose(f)  _CANNOT _pclose_

#else /* if PERLIO_NOT_STDIO */
/*
 * PERLIO_NOT_STDIO defined as 0 
 * Declares that both PerlIO and stdio can be used
 */
#endif /* if PERLIO_NOT_STDIO */
#else  /* ifdef PERLIO_NOT_STDIO */
/*
 * PERLIO_NOT_STDIO not defined 
 * This is "source level" stdio compatibility mode.
 */
#include "nostdio.h"
#undef FILE
#define FILE			PerlIO 
#undef fprintf
#undef tmpfile
#undef fclose
#undef fopen
#undef vfprintf
#undef fgetc
#undef getc_unlocked
#undef fputc
#undef putc_unlocked
#undef fputs
#undef ungetc
#undef fread
#undef fwrite
#undef fgetpos
#undef fseek
#undef fsetpos
#undef ftell
#undef rewind
#undef fdopen
#undef popen
#undef pclose
#undef getw
#undef putw
#undef freopen
#undef setbuf
#undef setvbuf
#undef fscanf
#undef fgets
#define fprintf			PerlIO_printf
#define stdin			PerlIO_stdin()
#define stdout			PerlIO_stdout()
#define stderr			PerlIO_stderr()
#define tmpfile()		PerlIO_tmpfile()
#define fclose(f)		PerlIO_close(f)
#define fflush(f)		PerlIO_flush(f)
#define fopen(p,m)		PerlIO_open(p,m)
#define vfprintf(f,fmt,a)	PerlIO_vprintf(f,fmt,a)
#define fgetc(f)		PerlIO_getc(f)
#define fputc(c,f)		PerlIO_putc(f,c)
#define fputs(s,f)		PerlIO_puts(f,s)
#define getc(f)			PerlIO_getc(f)
#ifdef getc_unlocked
#undef getc_unlocked
#endif
#define getc_unlocked(f)	PerlIO_getc(f)
#define putc(c,f)		PerlIO_putc(f,c)
#ifdef putc_unlocked
#undef putc_unlocked
#endif
#define putc_unlocked(c,f)	PerlIO_putc(c,f)
#define ungetc(c,f)		PerlIO_ungetc(f,c)
#if 0
/* return values of read/write need work */
#define fread(b,s,c,f)		PerlIO_read(f,b,(s*c))
#define fwrite(b,s,c,f)		PerlIO_write(f,b,(s*c))
#else
#define fread(b,s,c,f)		_CANNOT fread
#define fwrite(b,s,c,f)		_CANNOT fwrite
#endif
#define fgetpos(f,p)		PerlIO_getpos(f,p)
#define fseek(f,o,w)		PerlIO_seek(f,o,w)
#define fsetpos(f,p)		PerlIO_setpos(f,p)
#define ftell(f)		PerlIO_tell(f)
#define rewind(f)		PerlIO_rewind(f)
#define clearerr(f)		PerlIO_clearerr(f)
#define feof(f)			PerlIO_eof(f)
#define ferror(f)		PerlIO_error(f)
#define fdopen(fd,p)		PerlIO_fdopen(fd,p)
#define fileno(f)		PerlIO_fileno(f)
#define popen(c,m)		my_popen(c,m)
#define pclose(f)		my_pclose(f)

#define __filbuf(f)		_CANNOT __filbuf_
#define _filbuf(f)		_CANNOT _filbuf_
#define __flsbuf(c,f)		_CANNOT __flsbuf_
#define _flsbuf(c,f)		_CANNOT _flsbuf_
#define getw(f)			_CANNOT _getw_
#define putw(v,f)		_CANNOT _putw_
#define flockfile(f)		_CANNOT _flockfile_
#define ftrylockfile(f)		_CANNOT _ftrylockfile_
#define funlockfile(f)		_CANNOT _funlockfile_
#define freopen(p,m,f)		_CANNOT _freopen_
#define setbuf(f,b)		_CANNOT _setbuf_
#define setvbuf(f,b,x,s)	_CANNOT _setvbuf_
#define fscanf			_CANNOT _fscanf_
#define fgets(s,n,f)		_CANNOT _fgets_

#endif /* ifdef PERLIO_NOT_STDIO */
#endif /* PERLIO_IS_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlsfio.h ===
/* The next #ifdef should be redundant if Configure behaves ... */
#ifdef I_SFIO
#include <sfio.h>
#endif

extern Sfio_t*	_stdopen _ARG_((int, const char*));
extern int	_stdprintf _ARG_((const char*, ...));

#define PerlIO				Sfio_t
#define PerlIO_stderr()			sfstderr
#define PerlIO_stdout()			sfstdout
#define PerlIO_stdin()			sfstdin

#define PerlIO_printf			sfprintf
#define PerlIO_stdoutf			_stdprintf
#define PerlIO_vprintf(f,fmt,a)		sfvprintf(f,fmt,a)          
#define PerlIO_read(f,buf,count)	sfread(f,buf,count)
#define PerlIO_write(f,buf,count)	sfwrite(f,buf,count)
#define PerlIO_open(path,mode)		sfopen(NULL,path,mode)
#define PerlIO_fdopen(fd,mode)		_stdopen(fd,mode)
#define PerlIO_close(f)			sfclose(f)
#define PerlIO_puts(f,s)		sfputr(f,s,-1)
#define PerlIO_putc(f,c)		sfputc(f,c)
#define PerlIO_ungetc(f,c)		sfungetc(f,c)
#define PerlIO_sprintf			sfsprintf
#define PerlIO_getc(f)			sfgetc(f)
#define PerlIO_eof(f)			sfeof(f)
#define PerlIO_error(f)			sferror(f)
#define PerlIO_fileno(f)		sffileno(f)
#define PerlIO_clearerr(f)		sfclrerr(f)
#define PerlIO_flush(f)			sfsync(f)
#define PerlIO_tell(f)			sftell(f)
#define PerlIO_seek(f,o,w)		sfseek(f,o,w)
#define PerlIO_rewind(f)		(void) sfseek((f),0L,0)
#define PerlIO_tmpfile()		sftmp(0)

#define PerlIO_importFILE(f,fl)		croak("Import from FILE * unimplemeted")
#define PerlIO_exportFILE(f,fl)		croak("Export to FILE * unimplemeted")
#define PerlIO_findFILE(f)		NULL
#define PerlIO_releaseFILE(p,f)		croak("Release of FILE * unimplemeted")

#define PerlIO_setlinebuf(f)		sfset(f,SF_LINE,1)

/* Now our interface to equivalent of Configure's FILE_xxx macros */

#define PerlIO_has_cntptr(f)		1       
#define PerlIO_get_ptr(f)		((f)->next)
#define PerlIO_get_cnt(f)		((f)->endr - (f)->next)
#define PerlIO_canset_cnt(f)		1      
#define PerlIO_fast_gets(f)		1        
#define PerlIO_set_ptrcnt(f,p,c)	((f)->next = (p))          
#define PerlIO_set_cnt(f,c)		1

#define PerlIO_has_base(f)		1         
#define PerlIO_get_base(f)		((f)->data)
#define PerlIO_get_bufsiz(f)		((f)->endr - (f)->data)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perly.h ===
#define WORD 257
#define METHOD 258
#define FUNCMETH 259
#define THING 260
#define PMFUNC 261
#define PRIVATEREF 262
#define FUNC0SUB 263
#define UNIOPSUB 264
#define LSTOPSUB 265
#define LABEL 266
#define FORMAT 267
#define SUB 268
#define ANONSUB 269
#define PACKAGE 270
#define USE 271
#define WHILE 272
#define UNTIL 273
#define IF 274
#define UNLESS 275
#define ELSE 276
#define ELSIF 277
#define CONTINUE 278
#define FOR 279
#define LOOPEX 280
#define DOTDOT 281
#define FUNC0 282
#define FUNC1 283
#define FUNC 284
#define UNIOP 285
#define LSTOP 286
#define RELOP 287
#define EQOP 288
#define MULOP 289
#define ADDOP 290
#define DOLSHARP 291
#define DO 292
#define HASHBRACK 293
#define NOAMP 294
#define LOCAL 295
#define MY 296
#define OROP 297
#define ANDOP 298
#define NOTOP 299
#define ASSIGNOP 300
#define OROR 301
#define ANDAND 302
#define BITOROP 303
#define BITANDOP 304
#define SHIFTOP 305
#define MATCHOP 306
#define UMINUS 307
#define REFGEN 308
#define POWOP 309
#define PREINC 310
#define PREDEC 311
#define POSTINC 312
#define POSTDEC 313
#define ARROW 314
typedef union {
    I32	ival;
    char *pval;
    OP *opval;
    GV *gvval;
} YYSTYPE;
extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\pp_proto.h ===
PPDEF(pp_null)
PPDEF(pp_stub)
PPDEF(pp_scalar)
PPDEF(pp_pushmark)
PPDEF(pp_wantarray)
PPDEF(pp_const)
PPDEF(pp_gvsv)
PPDEF(pp_gv)
PPDEF(pp_gelem)
PPDEF(pp_padsv)
PPDEF(pp_padav)
PPDEF(pp_padhv)
PPDEF(pp_padany)
PPDEF(pp_pushre)
PPDEF(pp_rv2gv)
PPDEF(pp_rv2sv)
PPDEF(pp_av2arylen)
PPDEF(pp_rv2cv)
PPDEF(pp_anoncode)
PPDEF(pp_prototype)
PPDEF(pp_refgen)
PPDEF(pp_srefgen)
PPDEF(pp_ref)
PPDEF(pp_bless)
PPDEF(pp_backtick)
PPDEF(pp_glob)
PPDEF(pp_readline)
PPDEF(pp_rcatline)
PPDEF(pp_regcmaybe)
PPDEF(pp_regcreset)
PPDEF(pp_regcomp)
PPDEF(pp_match)
PPDEF(pp_qr)
PPDEF(pp_subst)
PPDEF(pp_substcont)
PPDEF(pp_trans)
PPDEF(pp_sassign)
PPDEF(pp_aassign)
PPDEF(pp_chop)
PPDEF(pp_schop)
PPDEF(pp_chomp)
PPDEF(pp_schomp)
PPDEF(pp_defined)
PPDEF(pp_undef)
PPDEF(pp_study)
PPDEF(pp_pos)
PPDEF(pp_preinc)
PPDEF(pp_predec)
PPDEF(pp_postinc)
PPDEF(pp_postdec)
PPDEF(pp_pow)
PPDEF(pp_multiply)
PPDEF(pp_i_multiply)
PPDEF(pp_divide)
PPDEF(pp_i_divide)
PPDEF(pp_modulo)
PPDEF(pp_i_modulo)
PPDEF(pp_repeat)
PPDEF(pp_add)
PPDEF(pp_i_add)
PPDEF(pp_subtract)
PPDEF(pp_i_subtract)
PPDEF(pp_concat)
PPDEF(pp_stringify)
PPDEF(pp_left_shift)
PPDEF(pp_right_shift)
PPDEF(pp_lt)
PPDEF(pp_i_lt)
PPDEF(pp_gt)
PPDEF(pp_i_gt)
PPDEF(pp_le)
PPDEF(pp_i_le)
PPDEF(pp_ge)
PPDEF(pp_i_ge)
PPDEF(pp_eq)
PPDEF(pp_i_eq)
PPDEF(pp_ne)
PPDEF(pp_i_ne)
PPDEF(pp_ncmp)
PPDEF(pp_i_ncmp)
PPDEF(pp_slt)
PPDEF(pp_sgt)
PPDEF(pp_sle)
PPDEF(pp_sge)
PPDEF(pp_seq)
PPDEF(pp_sne)
PPDEF(pp_scmp)
PPDEF(pp_bit_and)
PPDEF(pp_bit_xor)
PPDEF(pp_bit_or)
PPDEF(pp_negate)
PPDEF(pp_i_negate)
PPDEF(pp_not)
PPDEF(pp_complement)
PPDEF(pp_atan2)
PPDEF(pp_sin)
PPDEF(pp_cos)
PPDEF(pp_rand)
PPDEF(pp_srand)
PPDEF(pp_exp)
PPDEF(pp_log)
PPDEF(pp_sqrt)
PPDEF(pp_int)
PPDEF(pp_hex)
PPDEF(pp_oct)
PPDEF(pp_abs)
PPDEF(pp_length)
PPDEF(pp_substr)
PPDEF(pp_vec)
PPDEF(pp_index)
PPDEF(pp_rindex)
PPDEF(pp_sprintf)
PPDEF(pp_formline)
PPDEF(pp_ord)
PPDEF(pp_chr)
PPDEF(pp_crypt)
PPDEF(pp_ucfirst)
PPDEF(pp_lcfirst)
PPDEF(pp_uc)
PPDEF(pp_lc)
PPDEF(pp_quotemeta)
PPDEF(pp_rv2av)
PPDEF(pp_aelemfast)
PPDEF(pp_aelem)
PPDEF(pp_aslice)
PPDEF(pp_each)
PPDEF(pp_values)
PPDEF(pp_keys)
PPDEF(pp_delete)
PPDEF(pp_exists)
PPDEF(pp_rv2hv)
PPDEF(pp_helem)
PPDEF(pp_hslice)
PPDEF(pp_unpack)
PPDEF(pp_pack)
PPDEF(pp_split)
PPDEF(pp_join)
PPDEF(pp_list)
PPDEF(pp_lslice)
PPDEF(pp_anonlist)
PPDEF(pp_anonhash)
PPDEF(pp_splice)
PPDEF(pp_push)
PPDEF(pp_pop)
PPDEF(pp_shift)
PPDEF(pp_unshift)
PPDEF(pp_sort)
PPDEF(pp_reverse)
PPDEF(pp_grepstart)
PPDEF(pp_grepwhile)
PPDEF(pp_mapstart)
PPDEF(pp_mapwhile)
PPDEF(pp_range)
PPDEF(pp_flip)
PPDEF(pp_flop)
PPDEF(pp_and)
PPDEF(pp_or)
PPDEF(pp_xor)
PPDEF(pp_cond_expr)
PPDEF(pp_andassign)
PPDEF(pp_orassign)
PPDEF(pp_method)
PPDEF(pp_entersub)
PPDEF(pp_leavesub)
PPDEF(pp_caller)
PPDEF(pp_warn)
PPDEF(pp_die)
PPDEF(pp_reset)
PPDEF(pp_lineseq)
PPDEF(pp_nextstate)
PPDEF(pp_dbstate)
PPDEF(pp_unstack)
PPDEF(pp_enter)
PPDEF(pp_leave)
PPDEF(pp_scope)
PPDEF(pp_enteriter)
PPDEF(pp_iter)
PPDEF(pp_enterloop)
PPDEF(pp_leaveloop)
PPDEF(pp_return)
PPDEF(pp_last)
PPDEF(pp_next)
PPDEF(pp_redo)
PPDEF(pp_dump)
PPDEF(pp_goto)
PPDEF(pp_exit)
PPDEF(pp_open)
PPDEF(pp_close)
PPDEF(pp_pipe_op)
PPDEF(pp_fileno)
PPDEF(pp_umask)
PPDEF(pp_binmode)
PPDEF(pp_tie)
PPDEF(pp_untie)
PPDEF(pp_tied)
PPDEF(pp_dbmopen)
PPDEF(pp_dbmclose)
PPDEF(pp_sselect)
PPDEF(pp_select)
PPDEF(pp_getc)
PPDEF(pp_read)
PPDEF(pp_enterwrite)
PPDEF(pp_leavewrite)
PPDEF(pp_prtf)
PPDEF(pp_print)
PPDEF(pp_sysopen)
PPDEF(pp_sysseek)
PPDEF(pp_sysread)
PPDEF(pp_syswrite)
PPDEF(pp_send)
PPDEF(pp_recv)
PPDEF(pp_eof)
PPDEF(pp_tell)
PPDEF(pp_seek)
PPDEF(pp_truncate)
PPDEF(pp_fcntl)
PPDEF(pp_ioctl)
PPDEF(pp_flock)
PPDEF(pp_socket)
PPDEF(pp_sockpair)
PPDEF(pp_bind)
PPDEF(pp_connect)
PPDEF(pp_listen)
PPDEF(pp_accept)
PPDEF(pp_shutdown)
PPDEF(pp_gsockopt)
PPDEF(pp_ssockopt)
PPDEF(pp_getsockname)
PPDEF(pp_getpeername)
PPDEF(pp_lstat)
PPDEF(pp_stat)
PPDEF(pp_ftrread)
PPDEF(pp_ftrwrite)
PPDEF(pp_ftrexec)
PPDEF(pp_fteread)
PPDEF(pp_ftewrite)
PPDEF(pp_fteexec)
PPDEF(pp_ftis)
PPDEF(pp_fteowned)
PPDEF(pp_ftrowned)
PPDEF(pp_ftzero)
PPDEF(pp_ftsize)
PPDEF(pp_ftmtime)
PPDEF(pp_ftatime)
PPDEF(pp_ftctime)
PPDEF(pp_ftsock)
PPDEF(pp_ftchr)
PPDEF(pp_ftblk)
PPDEF(pp_ftfile)
PPDEF(pp_ftdir)
PPDEF(pp_ftpipe)
PPDEF(pp_ftlink)
PPDEF(pp_ftsuid)
PPDEF(pp_ftsgid)
PPDEF(pp_ftsvtx)
PPDEF(pp_fttty)
PPDEF(pp_fttext)
PPDEF(pp_ftbinary)
PPDEF(pp_chdir)
PPDEF(pp_chown)
PPDEF(pp_chroot)
PPDEF(pp_unlink)
PPDEF(pp_chmod)
PPDEF(pp_utime)
PPDEF(pp_rename)
PPDEF(pp_link)
PPDEF(pp_symlink)
PPDEF(pp_readlink)
PPDEF(pp_mkdir)
PPDEF(pp_rmdir)
PPDEF(pp_open_dir)
PPDEF(pp_readdir)
PPDEF(pp_telldir)
PPDEF(pp_seekdir)
PPDEF(pp_rewinddir)
PPDEF(pp_closedir)
PPDEF(pp_fork)
PPDEF(pp_wait)
PPDEF(pp_waitpid)
PPDEF(pp_system)
PPDEF(pp_exec)
PPDEF(pp_kill)
PPDEF(pp_getppid)
PPDEF(pp_getpgrp)
PPDEF(pp_setpgrp)
PPDEF(pp_getpriority)
PPDEF(pp_setpriority)
PPDEF(pp_time)
PPDEF(pp_tms)
PPDEF(pp_localtime)
PPDEF(pp_gmtime)
PPDEF(pp_alarm)
PPDEF(pp_sleep)
PPDEF(pp_shmget)
PPDEF(pp_shmctl)
PPDEF(pp_shmread)
PPDEF(pp_shmwrite)
PPDEF(pp_msgget)
PPDEF(pp_msgctl)
PPDEF(pp_msgsnd)
PPDEF(pp_msgrcv)
PPDEF(pp_semget)
PPDEF(pp_semctl)
PPDEF(pp_semop)
PPDEF(pp_require)
PPDEF(pp_dofile)
PPDEF(pp_entereval)
PPDEF(pp_leaveeval)
PPDEF(pp_entertry)
PPDEF(pp_leavetry)
PPDEF(pp_ghbyname)
PPDEF(pp_ghbyaddr)
PPDEF(pp_ghostent)
PPDEF(pp_gnbyname)
PPDEF(pp_gnbyaddr)
PPDEF(pp_gnetent)
PPDEF(pp_gpbyname)
PPDEF(pp_gpbynumber)
PPDEF(pp_gprotoent)
PPDEF(pp_gsbyname)
PPDEF(pp_gsbyport)
PPDEF(pp_gservent)
PPDEF(pp_shostent)
PPDEF(pp_snetent)
PPDEF(pp_sprotoent)
PPDEF(pp_sservent)
PPDEF(pp_ehostent)
PPDEF(pp_enetent)
PPDEF(pp_eprotoent)
PPDEF(pp_eservent)
PPDEF(pp_gpwnam)
PPDEF(pp_gpwuid)
PPDEF(pp_gpwent)
PPDEF(pp_spwent)
PPDEF(pp_epwent)
PPDEF(pp_ggrnam)
PPDEF(pp_ggrgid)
PPDEF(pp_ggrent)
PPDEF(pp_sgrent)
PPDEF(pp_egrent)
PPDEF(pp_getlogin)
PPDEF(pp_syscall)
PPDEF(pp_lock)
PPDEF(pp_threadsv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\perlvars.h ===
/****************/
/* Truly global */
/****************/

/* Don't forget to re-run embed.pl to propagate changes! */

/* This file describes the "global" variables used by perl
 * This used to be in perl.h directly but we want to abstract out into
 * distinct files which are per-thread, per-interpreter or really global,
 * and how they're initialized.
 *
 * The 'G' prefix is only needed for vars that need appropriate #defines
 * generated when built with or without EMBED.  It is also used to generate
 * the appropriate export list for win32.
 *
 * Avoid build-specific #ifdefs here, like DEBUGGING.  That way,
 * we can keep binary compatibility of the curinterp structure */


/* global state */
PERLVAR(Gcurinterp,	PerlInterpreter *)
					/* currently running interpreter */
#ifdef USE_THREADS
PERLVAR(Gthr_key,	perl_key)	/* For per-thread struct perl_thread* */
PERLVAR(Gsv_mutex,	perl_mutex)	/* Mutex for allocating SVs in sv.c */
PERLVAR(Gmalloc_mutex,	perl_mutex)	/* Mutex for malloc */
PERLVAR(Geval_mutex,	perl_mutex)	/* Mutex for doeval */
PERLVAR(Geval_cond,	perl_cond)	/* Condition variable for doeval */
PERLVAR(Geval_owner,	struct perl_thread *)
					/* Owner thread for doeval */
PERLVAR(Gnthreads,	int)		/* Number of threads currently */
PERLVAR(Gthreads_mutex,	perl_mutex)	/* Mutex for nthreads and thread list */
PERLVAR(Gnthreads_cond,	perl_cond)	/* Condition variable for nthreads */
PERLVAR(Gsvref_mutex,	perl_mutex)	/* Mutex for SvREFCNT_{inc,dec} */
PERLVARI(Gthreadsv_names,char *,	THREADSV_NAMES)
#ifdef FAKE_THREADS
PERLVAR(Gcurthr,	struct perl_thread *)
					/* Currently executing (fake) thread */
#endif
#endif /* USE_THREADS */

PERLVAR(Gninterps,	int)		/* number of active interpreters */

PERLVAR(Guid,		int)		/* current real user id */
PERLVAR(Geuid,		int)		/* current effective user id */
PERLVAR(Ggid,		int)		/* current real group id */
PERLVAR(Gegid,		int)		/* current effective group id */
PERLVAR(Gnomemok,	bool)		/* let malloc context handle nomem */
PERLVAR(Gan,		U32)		/* malloc sequence number */
PERLVAR(Gcop_seqmax,	U32)		/* statement sequence number */
PERLVAR(Gop_seqmax,	U16)		/* op sequence number */
PERLVAR(Gevalseq,	U32)		/* eval sequence number */
PERLVAR(Gorigenviron,	char **)
PERLVAR(Gorigalen,	U32)
PERLVAR(Gpidstatus,	HV *)		/* pid-to-status mappings for waitpid */
PERLVARI(Gmaxo,	int,	MAXO)		/* maximum number of ops */
PERLVAR(Gosname,	char *)		/* operating system */
PERLVARI(Gsh_path,	char *,	SH_PATH)/* full path of shell */
PERLVAR(Gsighandlerp,	Sighandler_t)

PERLVAR(Gxiv_arenaroot,	XPV*)		/* list of allocated xiv areas */
PERLVAR(Gxiv_root,	IV *)		/* free xiv list--shared by interpreters */
PERLVAR(Gxnv_root,	double *)	/* free xnv list--shared by interpreters */
PERLVAR(Gxrv_root,	XRV *)		/* free xrv list--shared by interpreters */
PERLVAR(Gxpv_root,	XPV *)		/* free xpv list--shared by interpreters */
PERLVAR(Ghe_root,	HE *)		/* free he list--shared by interpreters */
PERLVAR(Gnice_chunk,	char *)		/* a nice chunk of memory to reuse */
PERLVAR(Gnice_chunk_size,	U32)	/* how nice the chunk of memory is */

#ifdef PERL_OBJECT
PERLVARI(Grunops,	runops_proc_t,	FUNC_NAME_TO_PTR(RUNOPS_DEFAULT))
#else
PERLVARI(Grunops,	runops_proc_t *,	RUNOPS_DEFAULT)
#endif

PERLVAR(Gtokenbuf[256],	char)
PERLVAR(Gna,		STRLEN)		/* for use in SvPV when length is
					   Not Applicable */

PERLVAR(Gsv_undef,	SV)
PERLVAR(Gsv_no,		SV)
PERLVAR(Gsv_yes,	SV)
#ifdef CSH
PERLVARI(Gcshname,	char *,	CSH)
PERLVAR(Gcshlen,	I32)
#endif

PERLVAR(Glex_state,	U32)		/* next token is determined */
PERLVAR(Glex_defer,	U32)		/* state after determined token */
PERLVAR(Glex_expect,	expectation)	/* expect after determined token */
PERLVAR(Glex_brackets,	I32)		/* bracket count */
PERLVAR(Glex_formbrack,	I32)		/* bracket count at outer format level */
PERLVAR(Glex_fakebrack,	I32)		/* outer bracket is mere delimiter */
PERLVAR(Glex_casemods,	I32)		/* casemod count */
PERLVAR(Glex_dojoin,	I32)		/* doing an array interpolation */
PERLVAR(Glex_starts,	I32)		/* how many interps done on level */
PERLVAR(Glex_stuff,	SV *)		/* runtime pattern from m// or s/// */
PERLVAR(Glex_repl,	SV *)		/* runtime replacement from s/// */
PERLVAR(Glex_op,	OP *)		/* extra info to pass back on op */
PERLVAR(Glex_inpat,	OP *)		/* in pattern $) and $| are special */
PERLVAR(Glex_inwhat,	I32)		/* what kind of quoting are we in */
PERLVAR(Glex_brackstack,char *)		/* what kind of brackets to pop */
PERLVAR(Glex_casestack,	char *)		/* what kind of case mods in effect */

/* What we know when we're in LEX_KNOWNEXT state. */
PERLVAR(Gnextval[5],	YYSTYPE)	/* value of next token, if any */
PERLVAR(Gnexttype[5],	I32)		/* type of next token */
PERLVAR(Gnexttoke,	I32)

PERLVAR(Glinestr,	SV *)
PERLVAR(Gbufptr,	char *)
PERLVAR(Goldbufptr,	char *)
PERLVAR(Goldoldbufptr,	char *)
PERLVAR(Gbufend,	char *)
PERLVARI(Gexpect,expectation,	XSTATE)	/* how to interpret ambiguous tokens */

PERLVAR(Gmulti_start,	I32)		/* 1st line of multi-line string */
PERLVAR(Gmulti_end,	I32)		/* last line of multi-line string */
PERLVAR(Gmulti_open,	I32)		/* delimiter of said string */
PERLVAR(Gmulti_close,	I32)		/* delimiter of said string */

PERLVAR(Gerror_count,	I32)		/* how many errors so far, max 10 */
PERLVAR(Gsubline,	I32)		/* line this subroutine began on */
PERLVAR(Gsubname,	SV *)		/* name of current subroutine */

PERLVAR(Gmin_intro_pending,	I32)	/* start of vars to introduce */
PERLVAR(Gmax_intro_pending,	I32)	/* end of vars to introduce */
PERLVAR(Gpadix,		I32)		/* max used index in current "register" pad */
PERLVAR(Gpadix_floor,	I32)		/* how low may inner block reset padix */
PERLVAR(Gpad_reset_pending,	I32)	/* reset pad on next attempted alloc */

PERLVAR(Gthisexpr,	I32)		/* name id for nothing_in_common() */
PERLVAR(Glast_uni,	char *)		/* position of last named-unary op */
PERLVAR(Glast_lop,	char *)		/* position of last list operator */
PERLVAR(Glast_lop_op,	OPCODE)		/* last list operator */
PERLVAR(Gin_my,	bool)			/* we're compiling a "my" declaration */
PERLVAR(Gin_my_stash,	HV *)		/* declared class of this "my" declaration */
#ifdef FCRYPT
PERLVAR(Gcryptseen,	I32)		/* has fast crypt() been initialized? */
#endif

PERLVAR(Ghints,	U32)			/* pragma-tic compile-time flags */

PERLVAR(Gdo_undump,	bool)		/* -u or dump seen? */
PERLVAR(Gdebug,		VOL U32)	/* flags given to -D switch */


#ifdef OVERLOAD

PERLVAR(Gamagic_generation,	long)

#endif

#ifdef USE_LOCALE_COLLATE
PERLVAR(Gcollation_ix,	U32)		/* Collation generation index */
PERLVAR(Gcollation_name,char *)		/* Name of current collation */
PERLVARI(Gcollation_standard, bool,	TRUE)
					/* Assume simple collation */
PERLVAR(Gcollxfrm_base,	Size_t)		/* Basic overhead in *xfrm() */
PERLVARI(Gcollxfrm_mult,Size_t,	2)	/* Expansion factor in *xfrm() */
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC

PERLVAR(Gnumeric_name,	char *)		/* Name of current numeric locale */
PERLVARI(Gnumeric_standard,	bool,	TRUE)
					/* Assume simple numerics */
PERLVARI(Gnumeric_local,	bool,	TRUE)
					/* Assume local numerics */

#endif /* !USE_LOCALE_NUMERIC */

/* constants (these are not literals to facilitate pointer comparisons) */
PERLVARIC(GYes,		char *, "1")
PERLVARIC(GNo,		char *, "")
PERLVARIC(Ghexdigit,	char *, "0123456789abcdef0123456789ABCDEF")
PERLVARIC(Gpatleave,	char *, "\\.^$@dDwWsSbB+*?|()-nrtfeaxc0123456789[{]}")

PERLVAR(Gspecialsv_list[4],SV *)	/* from byterun.h */

#ifdef USE_THREADS
PERLVAR(Gcred_mutex,      perl_mutex)     /* altered credentials in effect */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\proto.h ===
#ifndef PERL_CALLCONV
#  define PERL_CALLCONV
#endif 

#ifdef PERL_OBJECT
#define VIRTUAL virtual PERL_CALLCONV
#else
#define VIRTUAL PERL_CALLCONV
START_EXTERN_C
#endif

/* NOTE!!! When new virtual functions are added, they must be added at
 * the end of this file to maintain binary compatibility with PERL_OBJECT
 */


#ifndef NEXT30_NO_ATTRIBUTE
#ifndef HASATTRIBUTE       /* disable GNU-cc attribute checking? */
#ifdef  __attribute__      /* Avoid possible redefinition errors */
#undef  __attribute__
#endif
#define __attribute__(attr)
#endif
#endif
#ifdef OVERLOAD
VIRTUAL SV*	amagic_call _((SV* left,SV* right,int method,int dir));
VIRTUAL bool	Gv_AMupdate _((HV* stash));
#endif /* OVERLOAD */
VIRTUAL OP*	append_elem _((I32 optype, OP* head, OP* tail));
VIRTUAL OP*	append_list _((I32 optype, LISTOP* first, LISTOP* last));
VIRTUAL I32	apply _((I32 type, SV** mark, SV** sp));
VIRTUAL void	assertref _((OP* o));
VIRTUAL bool	avhv_exists_ent _((AV *ar, SV* keysv, U32 hash));
VIRTUAL SV**	avhv_fetch_ent _((AV *ar, SV* keysv, I32 lval, U32 hash));
VIRTUAL HE*	avhv_iternext _((AV *ar));
VIRTUAL SV*	avhv_iterval _((AV *ar, HE* entry));
VIRTUAL HV*	avhv_keys _((AV *ar));
VIRTUAL void	av_clear _((AV* ar));
VIRTUAL void	av_extend _((AV* ar, I32 key));
VIRTUAL AV*	av_fake _((I32 size, SV** svp));
VIRTUAL SV**	av_fetch _((AV* ar, I32 key, I32 lval));
VIRTUAL void	av_fill _((AV* ar, I32 fill));
VIRTUAL I32	av_len _((AV* ar));
VIRTUAL AV*	av_make _((I32 size, SV** svp));
VIRTUAL SV*	av_pop _((AV* ar));
VIRTUAL void	av_push _((AV* ar, SV* val));
VIRTUAL void	av_reify _((AV* ar));
VIRTUAL SV*	av_shift _((AV* ar));
VIRTUAL SV**	av_store _((AV* ar, I32 key, SV* val));
VIRTUAL void	av_undef _((AV* ar));
VIRTUAL void	av_unshift _((AV* ar, I32 num));
VIRTUAL OP*	bind_match _((I32 type, OP* left, OP* pat));
VIRTUAL OP*	block_end _((I32 floor, OP* seq));
VIRTUAL I32	block_gimme _((void));
VIRTUAL int	block_start _((int full));
VIRTUAL void	boot_core_UNIVERSAL _((void));
VIRTUAL void	call_list _((I32 oldscope, AV* av_list));
VIRTUAL I32	cando _((I32 bit, I32 effective, Stat_t* statbufp));
#ifndef CASTNEGFLOAT
VIRTUAL U32	cast_ulong _((double f));
#endif
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
VIRTUAL I32	my_chsize _((int fd, Off_t length));
#endif
VIRTUAL OP*	ck_gvconst _((OP*  o));
VIRTUAL OP*	ck_retarget _((OP* o));
#ifdef USE_THREADS
VIRTUAL MAGIC *	condpair_magic _((SV *sv));
#endif
VIRTUAL OP*	convert _((I32 optype, I32 flags, OP* o));
VIRTUAL void	croak _((const char* pat,...)) __attribute__((noreturn));
VIRTUAL void	cv_ckproto _((CV* cv, GV* gv, char* p));
VIRTUAL CV*	cv_clone _((CV* proto));
VIRTUAL SV*	cv_const_sv _((CV* cv));
VIRTUAL SV*	op_const_sv _((OP* o, CV* cv));
VIRTUAL void	cv_undef _((CV* cv));
VIRTUAL void	cx_dump _((PERL_CONTEXT* cs));
VIRTUAL SV*	filter_add _((filter_t funcp, SV* datasv));
VIRTUAL void	filter_del _((filter_t funcp));
VIRTUAL I32	filter_read _((int idx, SV* buffer, int maxlen));
VIRTUAL char **	get_op_descs _((void));
VIRTUAL char **	get_op_names _((void));
VIRTUAL char *	get_no_modify _((void));
VIRTUAL U32 *	get_opargs _((void));
VIRTUAL I32	cxinc _((void));
VIRTUAL void	deb _((const char* pat,...));
VIRTUAL void	deb_growlevel _((void));
VIRTUAL void	debprofdump _((void));
VIRTUAL I32	debop _((OP* o));
VIRTUAL I32	debstack _((void));
VIRTUAL I32	debstackptrs _((void));
VIRTUAL char*	delimcpy _((char* to, char* toend, char* from, char* fromend,
		    int delim, I32* retlen));
VIRTUAL void	deprecate _((char* s));
VIRTUAL OP*	die _((const char* pat,...));
VIRTUAL OP*	die_where _((char* message));
VIRTUAL void	dounwind _((I32 cxix));
VIRTUAL bool	do_aexec _((SV* really, SV** mark, SV** sp));
VIRTUAL int	do_binmode _((PerlIO *fp, int iotype, int flag));
VIRTUAL void    do_chop _((SV* asv, SV* sv));
VIRTUAL bool	do_close _((GV* gv, bool not_implicit));
VIRTUAL bool	do_eof _((GV* gv));
VIRTUAL bool	do_exec _((char* cmd));
VIRTUAL void	do_execfree _((void));
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
I32	do_ipcctl _((I32 optype, SV** mark, SV** sp));
I32	do_ipcget _((I32 optype, SV** mark, SV** sp));
#endif
VIRTUAL void	do_join _((SV* sv, SV* del, SV** mark, SV** sp));
VIRTUAL OP*	do_kv _((ARGSproto));
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
I32	do_msgrcv _((SV** mark, SV** sp));
I32	do_msgsnd _((SV** mark, SV** sp));
#endif
VIRTUAL bool	do_open _((GV* gv, char* name, I32 len,
		   int as_raw, int rawmode, int rawperm, PerlIO* supplied_fp));
VIRTUAL void	do_pipe _((SV* sv, GV* rgv, GV* wgv));
VIRTUAL bool	do_print _((SV* sv, PerlIO* fp));
VIRTUAL OP*	do_readline _((void));
VIRTUAL I32	do_chomp _((SV* sv));
VIRTUAL bool	do_seek _((GV* gv, long pos, int whence));
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
I32	do_semop _((SV** mark, SV** sp));
I32	do_shmio _((I32 optype, SV** mark, SV** sp));
#endif
VIRTUAL void	do_sprintf _((SV* sv, I32 len, SV** sarg));
VIRTUAL long	do_sysseek _((GV* gv, long pos, int whence));
VIRTUAL long	do_tell _((GV* gv));
VIRTUAL I32	do_trans _((SV* sv, OP* arg));
VIRTUAL void	do_vecset _((SV* sv));
VIRTUAL void	do_vop _((I32 optype, SV* sv, SV* left, SV* right));
VIRTUAL I32	dowantarray _((void));
VIRTUAL void	dump_all _((void));
VIRTUAL void	dump_eval _((void));
#ifdef DUMP_FDS  /* See util.c */
VIRTUAL void	dump_fds _((char* s));
#endif
VIRTUAL void	dump_form _((GV* gv));
VIRTUAL void	dump_gv _((GV* gv));
#ifdef MYMALLOC
VIRTUAL void	dump_mstats _((char* s));
#endif
VIRTUAL void	dump_op _((OP* arg));
VIRTUAL void	dump_pm _((PMOP* pm));
VIRTUAL void	dump_packsubs _((HV* stash));
VIRTUAL void	dump_sub _((GV* gv));
VIRTUAL void	fbm_compile _((SV* sv, U32 flags));
VIRTUAL char*	fbm_instr _((unsigned char* big, unsigned char* bigend, SV* littlesv, U32 flags));
VIRTUAL char*	find_script _((char *scriptname, bool dosearch, char **search_ext, I32 flags));
#ifdef USE_THREADS
VIRTUAL PADOFFSET	find_threadsv _((char *name));
#endif
VIRTUAL OP*	force_list _((OP* arg));
VIRTUAL OP*	fold_constants _((OP* arg));
VIRTUAL char*	form _((const char* pat, ...));
VIRTUAL void	free_tmps _((void));
VIRTUAL OP*	gen_constant_list _((OP* o));
VIRTUAL void	gp_free _((GV* gv));
VIRTUAL GP*	gp_ref _((GP* gp));
VIRTUAL GV*	gv_AVadd _((GV* gv));
VIRTUAL GV*	gv_HVadd _((GV* gv));
VIRTUAL GV*	gv_IOadd _((GV* gv));
VIRTUAL GV*	gv_autoload4 _((HV* stash, char* name, STRLEN len, I32 method));
VIRTUAL void	gv_check _((HV* stash));
VIRTUAL void	gv_efullname _((SV* sv, GV* gv));
VIRTUAL void	gv_efullname3 _((SV* sv, GV* gv, char* prefix));
VIRTUAL GV*	gv_fetchfile _((char* name));
VIRTUAL GV*	gv_fetchmeth _((HV* stash, char* name, STRLEN len, I32 level));
VIRTUAL GV*	gv_fetchmethod _((HV* stash, char* name));
VIRTUAL GV*	gv_fetchmethod_autoload _((HV* stash, char* name, I32 autoload));
VIRTUAL GV*	gv_fetchpv _((char* name, I32 add, I32 sv_type));
VIRTUAL void	gv_fullname _((SV* sv, GV* gv));
VIRTUAL void	gv_fullname3 _((SV* sv, GV* gv, char* prefix));
VIRTUAL void	gv_init _((GV* gv, HV* stash, char* name, STRLEN len, int multi));
VIRTUAL HV*	gv_stashpv _((char* name, I32 create));
VIRTUAL HV*	gv_stashpvn _((char* name, U32 namelen, I32 create));
VIRTUAL HV*	gv_stashsv _((SV* sv, I32 create));
VIRTUAL void	hv_clear _((HV* tb));
VIRTUAL void	hv_delayfree_ent _((HV* hv, HE* entry));
VIRTUAL SV*	hv_delete _((HV* tb, char* key, U32 klen, I32 flags));
VIRTUAL SV*	hv_delete_ent _((HV* tb, SV* key, I32 flags, U32 hash));
VIRTUAL bool	hv_exists _((HV* tb, char* key, U32 klen));
VIRTUAL bool	hv_exists_ent _((HV* tb, SV* key, U32 hash));
VIRTUAL SV**	hv_fetch _((HV* tb, char* key, U32 klen, I32 lval));
VIRTUAL HE*	hv_fetch_ent _((HV* tb, SV* key, I32 lval, U32 hash));
VIRTUAL void	hv_free_ent _((HV* hv, HE* entry));
VIRTUAL I32	hv_iterinit _((HV* tb));
VIRTUAL char*	hv_iterkey _((HE* entry, I32* retlen));
VIRTUAL SV*	hv_iterkeysv _((HE* entry));
VIRTUAL HE*	hv_iternext _((HV* tb));
VIRTUAL SV*	hv_iternextsv _((HV* hv, char** key, I32* retlen));
VIRTUAL SV*	hv_iterval _((HV* tb, HE* entry));
VIRTUAL void	hv_ksplit _((HV* hv, IV newmax));
VIRTUAL void	hv_magic _((HV* hv, GV* gv, int how));
VIRTUAL SV**	hv_store _((HV* tb, char* key, U32 klen, SV* val, U32 hash));
VIRTUAL HE*	hv_store_ent _((HV* tb, SV* key, SV* val, U32 hash));
VIRTUAL void	hv_undef _((HV* tb));
VIRTUAL I32	ibcmp _((char* a, char* b, I32 len));
VIRTUAL I32	ibcmp_locale _((char* a, char* b, I32 len));
VIRTUAL I32	ingroup _((I32 testgid, I32 effective));
VIRTUAL void	init_stacks _((ARGSproto));
VIRTUAL U32	intro_my _((void));
VIRTUAL char*	instr _((char* big, char* little));
VIRTUAL bool	io_close _((IO* io));
VIRTUAL OP*	invert _((OP* cmd));
VIRTUAL OP*	jmaybe _((OP* arg));
VIRTUAL I32	keyword _((char* d, I32 len));
VIRTUAL void	leave_scope _((I32 base));
VIRTUAL void	lex_end _((void));
VIRTUAL void	lex_start _((SV* line));
VIRTUAL OP*	linklist _((OP* o));
VIRTUAL OP*	list _((OP* o));
VIRTUAL OP*	listkids _((OP* o));
VIRTUAL OP*	localize _((OP* arg, I32 lexical));
VIRTUAL I32	looks_like_number _((SV* sv));
VIRTUAL int	magic_clearenv	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_clear_all_env _((SV* sv, MAGIC* mg));
VIRTUAL int	magic_clearpack	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_clearsig	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_existspack _((SV* sv, MAGIC* mg));
VIRTUAL int	magic_freeregexp _((SV* sv, MAGIC* mg));
VIRTUAL int	magic_get	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getarylen	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getdefelem _((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getglob	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getnkeys	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getpack	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getpos	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getsig	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getsubstr	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_gettaint	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getuvar	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_getvec	_((SV* sv, MAGIC* mg));
VIRTUAL U32	magic_len	_((SV* sv, MAGIC* mg));
#ifdef USE_THREADS
VIRTUAL int	magic_mutexfree	_((SV* sv, MAGIC* mg));
#endif /* USE_THREADS */
VIRTUAL int	magic_nextpack	_((SV* sv, MAGIC* mg, SV* key));
VIRTUAL int	magic_set	_((SV* sv, MAGIC* mg));
#ifdef OVERLOAD
VIRTUAL int	magic_setamagic	_((SV* sv, MAGIC* mg));
#endif /* OVERLOAD */
VIRTUAL int	magic_setarylen	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setbm	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setdbline	_((SV* sv, MAGIC* mg));
#ifdef USE_LOCALE_COLLATE
VIRTUAL int	magic_setcollxfrm _((SV* sv, MAGIC* mg));
#endif
VIRTUAL int	magic_setdefelem _((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setenv	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setfm	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setisa	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setglob	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setmglob	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setnkeys	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setpack	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setpos	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setsig	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setsubstr	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_settaint	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setuvar	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_setvec	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_set_all_env _((SV* sv, MAGIC* mg));
VIRTUAL U32	magic_sizepack	_((SV* sv, MAGIC* mg));
VIRTUAL int	magic_wipepack	_((SV* sv, MAGIC* mg));
VIRTUAL void	magicname _((char* sym, char* name, I32 namlen));
int	main _((int argc, char** argv, char** env));
#ifdef MYMALLOC
VIRTUAL MEM_SIZE	malloced_size _((void *p));
#endif
VIRTUAL void	markstack_grow _((void));
#ifdef USE_LOCALE_COLLATE
VIRTUAL char*	mem_collxfrm _((const char* s, STRLEN len, STRLEN* xlen));
#endif
VIRTUAL char*	mess _((const char* pat, va_list* args));
VIRTUAL int	mg_clear _((SV* sv));
VIRTUAL int	mg_copy _((SV* sv, SV* nsv, char* key, I32 klen));
VIRTUAL MAGIC*	mg_find _((SV* sv, int type));
VIRTUAL int	mg_free _((SV* sv));
VIRTUAL int	mg_get _((SV* sv));
VIRTUAL U32	mg_length _((SV* sv));
VIRTUAL void	mg_magical _((SV* sv));
VIRTUAL int	mg_set _((SV* sv));
VIRTUAL I32	mg_size _((SV* sv));
VIRTUAL OP*	mod _((OP* o, I32 type));
VIRTUAL char*	moreswitches _((char* s));
VIRTUAL OP*	my _((OP* o));
#if !defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)
VIRTUAL char*	my_bcopy _((char* from, char* to, I32 len));
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
char*	my_bzero _((char* loc, I32 len));
#endif
VIRTUAL void	my_exit _((U32 status)) __attribute__((noreturn));
VIRTUAL void	my_failure_exit _((void)) __attribute__((noreturn));
VIRTUAL I32	my_lstat _((ARGSproto));
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
VIRTUAL I32	my_memcmp _((char* s1, char* s2, I32 len));
#endif
#if !defined(HAS_MEMSET)
VIRTUAL void*	my_memset _((char* loc, I32 ch, I32 len));
#endif
#ifndef PERL_OBJECT
VIRTUAL I32	my_pclose _((PerlIO* ptr));
VIRTUAL PerlIO*	my_popen _((char* cmd, char* mode));
#endif
VIRTUAL void	my_setenv _((char* nam, char* val));
VIRTUAL I32	my_stat _((ARGSproto));
#ifdef MYSWAP
VIRTUAL short	my_swap _((short s));
VIRTUAL long	my_htonl _((long l));
VIRTUAL long	my_ntohl _((long l));
#endif
VIRTUAL void	my_unexec _((void));
VIRTUAL OP*	newANONLIST _((OP* o));
VIRTUAL OP*	newANONHASH _((OP* o));
VIRTUAL OP*	newANONSUB _((I32 floor, OP* proto, OP* block));
VIRTUAL OP*	newASSIGNOP _((I32 flags, OP* left, I32 optype, OP* right));
VIRTUAL OP*	newCONDOP _((I32 flags, OP* expr, OP* trueop, OP* falseop));
VIRTUAL void	newCONSTSUB _((HV* stash, char* name, SV* sv));
VIRTUAL void	newFORM _((I32 floor, OP* o, OP* block));
VIRTUAL OP*	newFOROP _((I32 flags, char* label, line_t forline, OP* sclr, OP* expr, OP*block, OP*cont));
VIRTUAL OP*	newLOGOP _((I32 optype, I32 flags, OP* left, OP* right));
VIRTUAL OP*	newLOOPEX _((I32 type, OP* label));
VIRTUAL OP*	newLOOPOP _((I32 flags, I32 debuggable, OP* expr, OP* block));
VIRTUAL OP*	newNULLLIST _((void));
VIRTUAL OP*	newOP _((I32 optype, I32 flags));
VIRTUAL void	newPROG _((OP* o));
VIRTUAL OP*	newRANGE _((I32 flags, OP* left, OP* right));
VIRTUAL OP*	newSLICEOP _((I32 flags, OP* subscript, OP* list));
VIRTUAL OP*	newSTATEOP _((I32 flags, char* label, OP* o));
VIRTUAL CV*	newSUB _((I32 floor, OP* o, OP* proto, OP* block));
VIRTUAL CV*	newXS _((char* name, void (*subaddr)(CV* cv _CPERLproto), char* filename));
VIRTUAL AV*	newAV _((void));
VIRTUAL OP*	newAVREF _((OP* o));
VIRTUAL OP*	newBINOP _((I32 type, I32 flags, OP* first, OP* last));
VIRTUAL OP*	newCVREF _((I32 flags, OP* o));
VIRTUAL OP*	newGVOP _((I32 type, I32 flags, GV* gv));
VIRTUAL GV*	newGVgen _((char* pack));
VIRTUAL OP*	newGVREF _((I32 type, OP* o));
VIRTUAL OP*	newHVREF _((OP* o));
VIRTUAL HV*	newHV _((void));
VIRTUAL HV*	newHVhv _((HV* hv));
VIRTUAL IO*	newIO _((void));
VIRTUAL OP*	newLISTOP _((I32 type, I32 flags, OP* first, OP* last));
VIRTUAL OP*	newPMOP _((I32 type, I32 flags));
VIRTUAL OP*	newPVOP _((I32 type, I32 flags, char* pv));
VIRTUAL SV*	newRV _((SV* pref));
VIRTUAL SV*	newRV_noinc _((SV *sv));
VIRTUAL SV*	newSV _((STRLEN len));
VIRTUAL OP*	newSVREF _((OP* o));
VIRTUAL OP*	newSVOP _((I32 type, I32 flags, SV* sv));
VIRTUAL SV*	newSViv _((IV i));
VIRTUAL SV*	newSVnv _((double n));
VIRTUAL SV*	newSVpv _((char* s, STRLEN len));
VIRTUAL SV*	newSVpvn _((char *s, STRLEN len));
VIRTUAL SV*	newSVpvf _((const char* pat, ...));
VIRTUAL SV*	newSVrv _((SV* rv, char* classname));
VIRTUAL SV*	newSVsv _((SV* old));
VIRTUAL OP*	newUNOP _((I32 type, I32 flags, OP* first));
VIRTUAL OP*	newWHILEOP _((I32 flags, I32 debuggable, LOOP* loop,
		      I32 whileline, OP* expr, OP* block, OP* cont));
#ifdef USE_THREADS
VIRTUAL struct perl_thread *	new_struct_thread _((struct perl_thread *t));
#endif
VIRTUAL PERL_SI *	new_stackinfo _((I32 stitems, I32 cxitems));
VIRTUAL PerlIO*	nextargv _((GV* gv));
VIRTUAL char*	ninstr _((char* big, char* bigend, char* little, char* lend));
VIRTUAL OP*	oopsCV _((OP* o));
VIRTUAL void	op_free _((OP* arg));
VIRTUAL void	package _((OP* o));
VIRTUAL PADOFFSET	pad_alloc _((I32 optype, U32 tmptype));
VIRTUAL PADOFFSET	pad_allocmy _((char* name));
VIRTUAL PADOFFSET	pad_findmy _((char* name));
VIRTUAL OP*	oopsAV _((OP* o));
VIRTUAL OP*	oopsHV _((OP* o));
VIRTUAL void	pad_leavemy _((I32 fill));
VIRTUAL SV*	pad_sv _((PADOFFSET po));
VIRTUAL void	pad_free _((PADOFFSET po));
VIRTUAL void	pad_reset _((void));
VIRTUAL void	pad_swipe _((PADOFFSET po));
VIRTUAL void	peep _((OP* o));
#ifndef PERL_OBJECT
PerlInterpreter*	perl_alloc _((void));
#endif
#ifdef PERL_OBJECT
VIRTUAL void    perl_atexit _((void(*fn)(CPerlObj *, void *), void* ptr));
#else
void    perl_atexit _((void(*fn)(void *), void*));
#endif
VIRTUAL I32	perl_call_argv _((char* sub_name, I32 flags, char** argv));
VIRTUAL I32	perl_call_method _((char* methname, I32 flags));
VIRTUAL I32	perl_call_pv _((char* sub_name, I32 flags));
VIRTUAL I32	perl_call_sv _((SV* sv, I32 flags));
#ifdef PERL_OBJECT
VIRTUAL void	perl_construct _((void));
VIRTUAL void	perl_destruct _((void));
#else
void	perl_construct _((PerlInterpreter* sv_interp));
void	perl_destruct _((PerlInterpreter* sv_interp));
#endif
VIRTUAL SV*	perl_eval_pv _((char* p, I32 croak_on_error));
VIRTUAL I32	perl_eval_sv _((SV* sv, I32 flags));
#ifdef PERL_OBJECT
VIRTUAL void	perl_free _((void));
#else
void	perl_free _((PerlInterpreter* sv_interp));
#endif
VIRTUAL SV*	perl_get_sv _((char* name, I32 create));
VIRTUAL AV*	perl_get_av _((char* name, I32 create));
VIRTUAL HV*	perl_get_hv _((char* name, I32 create));
VIRTUAL CV*	perl_get_cv _((char* name, I32 create));
VIRTUAL int	perl_init_i18nl10n _((int printwarn));
VIRTUAL int	perl_init_i18nl14n _((int printwarn));
VIRTUAL void	perl_new_collate _((char* newcoll));
VIRTUAL void	perl_new_ctype _((char* newctype));
VIRTUAL void	perl_new_numeric _((char* newcoll));
VIRTUAL void	perl_set_numeric_local _((void));
VIRTUAL void	perl_set_numeric_standard _((void));
#ifdef PERL_OBJECT
VIRTUAL int	perl_parse _((void(*xsinit)(CPerlObj*), int argc, char** argv, char** env));
#else
int	perl_parse _((PerlInterpreter* sv_interp, void(*xsinit)(void), int argc, char** argv, char** env));
#endif
VIRTUAL void	perl_require_pv _((char* pv));
#define perl_requirepv perl_require_pv
#ifdef PERL_OBJECT
VIRTUAL int	perl_run _((void));
#else
int	perl_run _((PerlInterpreter* sv_interp));
#endif
VIRTUAL void	pidgone _((int pid, int status));
VIRTUAL void	pmflag _((U16* pmfl, int ch));
VIRTUAL OP*	pmruntime _((OP* pm, OP* expr, OP* repl));
VIRTUAL OP*	pmtrans _((OP* o, OP* expr, OP* repl));
VIRTUAL OP*	pop_return _((void));
VIRTUAL void	pop_scope _((void));
VIRTUAL OP*	prepend_elem _((I32 optype, OP* head, OP* tail));
VIRTUAL void	push_return _((OP* o));
VIRTUAL void	push_scope _((void));
VIRTUAL OP*	ref _((OP* o, I32 type));
VIRTUAL OP*	refkids _((OP* o, I32 type));
VIRTUAL void	regdump _((regexp* r));
VIRTUAL I32	pregexec _((regexp* prog, char* stringarg, char* strend, char* strbeg, I32 minend, SV* screamer, U32 nosave));
VIRTUAL void	pregfree _((struct regexp* r));
VIRTUAL regexp*	pregcomp _((char* exp, char* xend, PMOP* pm));
VIRTUAL I32	regexec_flags _((regexp* prog, char* stringarg, char* strend,
			 char* strbeg, I32 minend, SV* screamer,
			 void* data, U32 flags));
VIRTUAL regnode* regnext _((regnode* p));
VIRTUAL void	regprop _((SV* sv, regnode* o));
VIRTUAL void	repeatcpy _((char* to, char* from, I32 len, I32 count));
VIRTUAL char*	rninstr _((char* big, char* bigend, char* little, char* lend));
VIRTUAL Sighandler_t rsignal _((int i, Sighandler_t t));
VIRTUAL int	rsignal_restore _((int i, Sigsave_t* t));
VIRTUAL int	rsignal_save _((int i, Sighandler_t t1, Sigsave_t* t2));
VIRTUAL Sighandler_t rsignal_state _((int i));
VIRTUAL void	rxres_free _((void** rsp));
VIRTUAL void	rxres_restore _((void** rsp, REGEXP* prx));
VIRTUAL void	rxres_save _((void** rsp, REGEXP* prx));
#ifndef HAS_RENAME
VIRTUAL I32	same_dirent _((char* a, char* b));
#endif
VIRTUAL char*	savepv _((char* sv));
VIRTUAL char*	savepvn _((char* sv, I32 len));
VIRTUAL void	savestack_grow _((void));
VIRTUAL void	save_aelem _((AV* av, I32 idx, SV **sptr));
VIRTUAL void	save_aptr _((AV** aptr));
VIRTUAL AV*	save_ary _((GV* gv));
VIRTUAL void	save_clearsv _((SV** svp));
VIRTUAL void	save_delete _((HV* hv, char* key, I32 klen));
#ifndef titan  /* TitanOS cc can't handle this */
#ifdef PERL_OBJECT
typedef void (CPerlObj::*DESTRUCTORFUNC) _((void*));
VIRTUAL void	save_destructor _((DESTRUCTORFUNC f, void* p));
#else
void	save_destructor _((void (*f)(void*), void* p));
#endif
#endif /* titan */
VIRTUAL void	save_freesv _((SV* sv));
VIRTUAL void	save_freeop _((OP* o));
VIRTUAL void	save_freepv _((char* pv));
VIRTUAL void	save_gp _((GV* gv, I32 empty));
VIRTUAL HV*	save_hash _((GV* gv));
VIRTUAL void	save_helem _((HV* hv, SV *key, SV **sptr));
VIRTUAL void	save_hints _((void));
VIRTUAL void	save_hptr _((HV** hptr));
VIRTUAL void	save_I16 _((I16* intp));
VIRTUAL void	save_I32 _((I32* intp));
VIRTUAL void	save_int _((int* intp));
VIRTUAL void	save_item _((SV* item));
VIRTUAL void	save_iv _((IV* iv));
VIRTUAL void	save_list _((SV** sarg, I32 maxsarg));
VIRTUAL void	save_long _((long* longp));
VIRTUAL void	save_nogv _((GV* gv));
VIRTUAL void	save_op _((void));
VIRTUAL SV*	save_scalar _((GV* gv));
VIRTUAL void	save_pptr _((char** pptr));
VIRTUAL void	save_sptr _((SV** sptr));
VIRTUAL SV*	save_svref _((SV** sptr));
VIRTUAL SV**	save_threadsv _((PADOFFSET i));
VIRTUAL OP*	sawparens _((OP* o));
VIRTUAL OP*	scalar _((OP* o));
VIRTUAL OP*	scalarkids _((OP* o));
VIRTUAL OP*	scalarseq _((OP* o));
VIRTUAL OP*	scalarvoid _((OP* o));
VIRTUAL UV	scan_hex _((char* start, I32 len, I32* retlen));
VIRTUAL char*	scan_num _((char* s));
VIRTUAL UV	scan_oct _((char* start, I32 len, I32* retlen));
VIRTUAL OP*	scope _((OP* o));
VIRTUAL char*	screaminstr _((SV* bigsv, SV* littlesv, I32 start_shift, I32 end_shift, I32 *state, I32 last));
#ifndef VMS
VIRTUAL I32	setenv_getix _((char* nam));
#endif
VIRTUAL void	setdefout _((GV* gv));
VIRTUAL char*	sharepvn _((char* sv, I32 len, U32 hash));
VIRTUAL HEK*	share_hek _((char* sv, I32 len, U32 hash));
VIRTUAL Signal_t sighandler _((int sig));
VIRTUAL SV**	stack_grow _((SV** sp, SV**p, int n));
VIRTUAL I32	start_subparse _((I32 is_format, U32 flags));
VIRTUAL void	sub_crush_depth _((CV* cv));
VIRTUAL bool	sv_2bool _((SV* sv));
VIRTUAL CV*	sv_2cv _((SV* sv, HV** st, GV** gvp, I32 lref));
VIRTUAL IO*	sv_2io _((SV* sv));
VIRTUAL IV	sv_2iv _((SV* sv));
VIRTUAL SV*	sv_2mortal _((SV* sv));
VIRTUAL double	sv_2nv _((SV* sv));
VIRTUAL char*	sv_2pv _((SV* sv, STRLEN* lp));
VIRTUAL UV	sv_2uv _((SV* sv));
VIRTUAL IV	sv_iv _((SV* sv));
VIRTUAL UV	sv_uv _((SV* sv));
VIRTUAL double	sv_nv _((SV* sv));
VIRTUAL char *	sv_pvn _((SV *sv, STRLEN *len));
VIRTUAL I32	sv_true _((SV *sv));
VIRTUAL void	sv_add_arena _((char* ptr, U32 size, U32 flags));
VIRTUAL int	sv_backoff _((SV* sv));
VIRTUAL SV*	sv_bless _((SV* sv, HV* stash));
VIRTUAL void	sv_catpvf _((SV* sv, const char* pat, ...));
VIRTUAL void	sv_catpv _((SV* sv, char* ptr));
VIRTUAL void	sv_catpvn _((SV* sv, char* ptr, STRLEN len));
VIRTUAL void	sv_catsv _((SV* dsv, SV* ssv));
VIRTUAL void	sv_chop _((SV* sv, char* ptr));
VIRTUAL void	sv_clean_all _((void));
VIRTUAL void	sv_clean_objs _((void));
VIRTUAL void	sv_clear _((SV* sv));
VIRTUAL I32	sv_cmp _((SV* sv1, SV* sv2));
VIRTUAL I32	sv_cmp_locale _((SV* sv1, SV* sv2));
#ifdef USE_LOCALE_COLLATE
VIRTUAL char*	sv_collxfrm _((SV* sv, STRLEN* nxp));
#endif
VIRTUAL OP*	sv_compile_2op _((SV* sv, OP** startp, char* code, AV** avp));
VIRTUAL void	sv_dec _((SV* sv));
VIRTUAL void	sv_dump _((SV* sv));
VIRTUAL bool	sv_derived_from _((SV* sv, char* name));
VIRTUAL I32	sv_eq _((SV* sv1, SV* sv2));
VIRTUAL void	sv_free _((SV* sv));
VIRTUAL void	sv_free_arenas _((void));
VIRTUAL char*	sv_gets _((SV* sv, PerlIO* fp, I32 append));
#ifndef DOSISH
VIRTUAL char*	sv_grow _((SV* sv, I32 newlen));
#else
VIRTUAL char*	sv_grow _((SV* sv, unsigned long newlen));
#endif
VIRTUAL void	sv_inc _((SV* sv));
VIRTUAL void	sv_insert _((SV* bigsv, STRLEN offset, STRLEN len, char* little, STRLEN littlelen));
VIRTUAL int	sv_isa _((SV* sv, char* name));
VIRTUAL int	sv_isobject _((SV* sv));
VIRTUAL STRLEN	sv_len _((SV* sv));
VIRTUAL void	sv_magic _((SV* sv, SV* obj, int how, char* name, I32 namlen));
VIRTUAL SV*	sv_mortalcopy _((SV* oldsv));
VIRTUAL SV*	sv_newmortal _((void));
VIRTUAL SV*	sv_newref _((SV* sv));
VIRTUAL char*	sv_peek _((SV* sv));
VIRTUAL char*	sv_pvn_force _((SV* sv, STRLEN* lp));
VIRTUAL char*	sv_reftype _((SV* sv, int ob));
VIRTUAL void	sv_replace _((SV* sv, SV* nsv));
VIRTUAL void	sv_report_used _((void));
VIRTUAL void	sv_reset _((char* s, HV* stash));
VIRTUAL void	sv_setpvf _((SV* sv, const char* pat, ...));
VIRTUAL void	sv_setiv _((SV* sv, IV num));
VIRTUAL void	sv_setpviv _((SV* sv, IV num));
VIRTUAL void	sv_setuv _((SV* sv, UV num));
VIRTUAL void	sv_setnv _((SV* sv, double num));
VIRTUAL SV*	sv_setref_iv _((SV* rv, char* classname, IV iv));
VIRTUAL SV*	sv_setref_nv _((SV* rv, char* classname, double nv));
VIRTUAL SV*	sv_setref_pv _((SV* rv, char* classname, void* pv));
VIRTUAL SV*	sv_setref_pvn _((SV* rv, char* classname, char* pv, I32 n));
VIRTUAL void	sv_setpv _((SV* sv, const char* ptr));
VIRTUAL void	sv_setpvn _((SV* sv, const char* ptr, STRLEN len));
VIRTUAL void	sv_setsv _((SV* dsv, SV* ssv));
VIRTUAL void	sv_taint _((SV* sv));
VIRTUAL bool	sv_tainted _((SV* sv));
VIRTUAL int	sv_unmagic _((SV* sv, int type));
VIRTUAL void	sv_unref _((SV* sv));
VIRTUAL void	sv_untaint _((SV* sv));
VIRTUAL bool	sv_upgrade _((SV* sv, U32 mt));
VIRTUAL void	sv_usepvn _((SV* sv, char* ptr, STRLEN len));
VIRTUAL void	sv_vcatpvfn _((SV* sv, const char* pat, STRLEN patlen,
		       va_list* args, SV** svargs, I32 svmax,
		       bool *used_locale));
VIRTUAL void	sv_vsetpvfn _((SV* sv, const char* pat, STRLEN patlen,
		       va_list* args, SV** svargs, I32 svmax,
		       bool *used_locale));
VIRTUAL void	taint_env _((void));
VIRTUAL void	taint_proper _((const char* f, char* s));
#ifdef UNLINK_ALL_VERSIONS
VIRTUAL I32	unlnk _((char* f));
#endif
#ifdef USE_THREADS
VIRTUAL void	unlock_condpair _((void* svv));
#endif
VIRTUAL void	unsharepvn _((char* sv, I32 len, U32 hash));
VIRTUAL void	unshare_hek _((HEK* hek));
VIRTUAL void	utilize _((int aver, I32 floor, OP* version, OP* id, OP* arg));
VIRTUAL void	vivify_defelem _((SV* sv));
VIRTUAL void	vivify_ref _((SV* sv, U32 to_what));
VIRTUAL I32	wait4pid _((int pid, int* statusp, int flags));
VIRTUAL void	warn _((const char* pat,...));
VIRTUAL void	watch _((char** addr));
VIRTUAL I32	whichsig _((char* sig));
VIRTUAL int	yyerror _((char* s));
VIRTUAL int	yylex _((void));
VIRTUAL int	yyparse _((void));
VIRTUAL int	yywarn _((char* s));

#ifndef MYMALLOC
VIRTUAL Malloc_t safemalloc _((MEM_SIZE nbytes));
VIRTUAL Malloc_t safecalloc _((MEM_SIZE elements, MEM_SIZE size));
VIRTUAL Malloc_t saferealloc _((Malloc_t where, MEM_SIZE nbytes));
VIRTUAL Free_t   safefree _((Malloc_t where));
#endif

#ifdef LEAKTEST
VIRTUAL Malloc_t safexmalloc _((I32 x, MEM_SIZE size));
VIRTUAL Malloc_t safexcalloc _((I32 x, MEM_SIZE elements, MEM_SIZE size));
VIRTUAL Malloc_t safexrealloc _((Malloc_t where, MEM_SIZE size));
VIRTUAL void     safexfree _((Malloc_t where));
#endif

#ifdef PERL_GLOBAL_STRUCT
VIRTUAL struct perl_vars *Perl_GetVars _((void));
#endif

#ifdef PERL_OBJECT
protected:
void hsplit _((HV *hv));
void hfreeentries _((HV *hv));
void more_he _((void));
HE* new_he _((void));
void del_he _((HE *p));
HEK *save_hek _((char *str, I32 len, U32 hash));
SV *mess_alloc _((void));
void gv_init_sv _((GV *gv, I32 sv_type));
SV *save_scalar_at _((SV **sptr));
IV asIV _((SV* sv));
UV asUV _((SV* sv));
SV *more_sv _((void));
void more_xiv _((void));
void more_xnv _((void));
void more_xpv _((void));
void more_xrv _((void));
XPVIV *new_xiv _((void));
XPVNV *new_xnv _((void));
XPV *new_xpv _((void));
XRV *new_xrv _((void));
void del_xiv _((XPVIV* p));
void del_xnv _((XPVNV* p));
void del_xpv _((XPV* p));
void del_xrv _((XRV* p));
void sv_mortalgrow _((void));
void sv_unglob _((SV* sv));
void sv_check_thinkfirst _((SV *sv));
I32 avhv_index_sv _((SV* sv));

void do_report_used _((SV *sv));
void do_clean_objs _((SV *sv));
void do_clean_named_objs _((SV *sv));
void do_clean_all _((SV *sv));
void not_a_number _((SV *sv));
void* my_safemalloc _((MEM_SIZE size));

typedef void (CPerlObj::*SVFUNC) _((SV*));
void visit _((SVFUNC f));

typedef I32 (CPerlObj::*SVCOMPARE) _((SV*, SV*));
void qsortsv _((SV ** array, size_t num_elts, SVCOMPARE f));
I32 sortcv _((SV *a, SV *b));
void save_magic _((MGS *mgs, SV *sv));
int magic_methpack _((SV *sv, MAGIC *mg, char *meth));
int magic_methcall _((SV *sv, MAGIC *mg, char *meth, I32 flags, int n, SV *val));
OP * doform _((CV *cv, GV *gv, OP *retop));
void doencodes _((SV* sv, char* s, I32 len));
SV* refto _((SV* sv));
U32 seed _((void));
OP *docatch _((OP *o));
OP *dofindlabel _((OP *o, char *label, OP **opstack, OP **oplimit));
void doparseform _((SV *sv));
I32 dopoptoeval _((I32 startingblock));
I32 dopoptolabel _((char *label));
I32 dopoptoloop _((I32 startingblock));
I32 dopoptosub _((I32 startingblock));
I32 dopoptosub_at _((PERL_CONTEXT* cxstk, I32 startingblock));
void save_lines _((AV *array, SV *sv));
OP *doeval _((int gimme, OP** startop));
SV *mul128 _((SV *sv, U8 m));
SV *is_an_int _((char *s, STRLEN l));
int div128 _((SV *pnum, bool *done));

int runops_standard _((void));
int runops_debug _((void));

void check_uni _((void));
void  force_next _((I32 type));
char *force_version _((char *start));
char *force_word _((char *start, int token, int check_keyword, int allow_pack, int allow_tick));
SV *tokeq _((SV *sv));
char *scan_const _((char *start));
char *scan_formline _((char *s));
char *scan_heredoc _((char *s));
char *scan_ident _((char *s, char *send, char *dest, STRLEN destlen, I32 ck_uni));
char *scan_inputsymbol _((char *start));
char *scan_pat _((char *start, I32 type));
char *scan_str _((char *start));
char *scan_subst _((char *start));
char *scan_trans _((char *start));
char *scan_word _((char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp));
char *skipspace _((char *s));
void checkcomma _((char *s, char *name, char *what));
void force_ident _((char *s, int kind));
void incline _((char *s));
int intuit_method _((char *s, GV *gv));
int intuit_more _((char *s));
I32 lop _((I32 f, expectation x, char *s));
void missingterm _((char *s));
void no_op _((char *what, char *s));
void set_csh _((void));
I32 sublex_done _((void));
I32 sublex_push _((void));
I32 sublex_start _((void));
#ifdef CRIPPLED_CC
int uni _((I32 f, char *s));
#endif
char * filter_gets _((SV *sv, PerlIO *fp, STRLEN append));
SV *new_constant _((char *s, STRLEN len, char *key, SV *sv, SV *pv, char *type));
int ao _((int toketype));
void depcom _((void));
#ifdef WIN32
I32 win32_textfilter _((int idx, SV *sv, int maxlen));
#endif
char* incl_perldb _((void));
SV *isa_lookup _((HV *stash, char *name, int len, int level));
CV *get_db_sub _((SV **svp, CV *cv));
I32 list_assignment _((OP *o));
void bad_type _((I32 n, char *t, char *name, OP *kid));
OP *modkids _((OP *o, I32 type));
void no_bareword_allowed _((OP *o));
OP *no_fh_allowed _((OP *o));
OP *scalarboolean _((OP *o));
OP *too_few_arguments _((OP *o, char* name));
OP *too_many_arguments _((OP *o, char* name));
void null _((OP* o));
PADOFFSET pad_findlex _((char* name, PADOFFSET newoff, U32 seq, CV* startcv, I32 cx_ix, I32 saweval, U32 flags));
OP *newDEFSVOP _((void));
char* gv_ename _((GV *gv));
CV *cv_clone2 _((CV *proto, CV *outside));

void find_beginning _((void));
void forbid_setid _((char *));
void incpush _((char *, int));
void init_interp _((void));
void init_ids _((void));
void init_debugger _((void));
void init_lexer _((void));
void init_main_stash _((void));
#ifdef USE_THREADS
struct perl_thread * init_main_thread _((void));
#endif /* USE_THREADS */
void init_perllib _((void));
void init_postdump_symbols _((int, char **, char **));
void init_predump_symbols _((void));
void my_exit_jump _((void)) __attribute__((noreturn));
void nuke_stacks _((void));
void open_script _((char *, bool, SV *, int *fd));
void usage _((char *));
void validate_suid _((char *, char*, int));

regnode *reg _((I32, I32 *));
regnode *reganode _((U8, U32));
regnode *regatom _((I32 *));
regnode *regbranch _((I32 *, I32));
void regc _((U8, char *));
regnode *regclass _((void));
I32 regcurly _((char *));
regnode *reg_node _((U8));
regnode *regpiece _((I32 *));
void reginsert _((U8, regnode *));
void regoptail _((regnode *, regnode *));
void regset _((char *, I32));
void regtail _((regnode *, regnode *));
char* regwhite _((char *, char *));
char* nextchar _((void));
regnode *dumpuntil _((regnode *start, regnode *node, regnode *last, SV* sv, I32 l));
void scan_commit _((scan_data_t *data));
I32 study_chunk _((regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags));
I32 add_data _((I32 n, char *s));
void	re_croak2 _((const char* pat1,const char* pat2,...)) __attribute__((noreturn));
I32 regmatch _((regnode *prog));
I32 regrepeat _((regnode *p, I32 max));
I32 regrepeat_hard _((regnode *p, I32 max, I32 *lp));
I32 regtry _((regexp *prog, char *startpos));
bool reginclass _((char *p, I32 c));
CHECKPOINT regcppush _((I32 parenfloor));
char * regcppop _((void));
void dump _((char *pat,...));
#ifdef WIN32
int do_aspawn _((void *vreally, void **vmark, void **vsp));
#endif

#ifdef DEBUGGING
void del_sv _((SV *p));
#endif
void debprof _((OP *o));

void *bset_obj_store _((void *obj, I32 ix));
OP *new_logop _((I32 type, I32 flags, OP **firstp, OP **otherp));
I32     amagic_cmp _((register SV *str1, register SV *str2));
I32     amagic_cmp_locale _((register SV *str1, register SV *str2));

#define PPDEF(s) OP* CPerlObj::s _((ARGSproto));
public:

#include "pp_proto.h"

OP * ck_ftst _((OP *o));
OP *ck_anoncode _((OP *o));
OP *ck_bitop _((OP *o));
OP *ck_concat _((OP *o));
OP *ck_spair _((OP *o));
OP *ck_delete _((OP *o));
OP *ck_eof _((OP *o));
OP *ck_eval _((OP *o));
OP *ck_exec _((OP *o));
OP *ck_exists _((OP *o));
OP *ck_rvconst _((OP *o));
OP *ck_fun _((OP *o));
OP *ck_glob _((OP *o));
OP *ck_grep _((OP *o));
OP *ck_index _((OP *o));
OP *ck_lengthconst _((OP *o));
OP *ck_lfun _((OP *o));
OP *ck_rfun _((OP *o));
OP *ck_listiob _((OP *o));
OP *ck_fun_locale _((OP *o));
OP *ck_scmp _((OP *o));
OP *ck_match _((OP *o));
OP *ck_null _((OP *o));
OP *ck_repeat _((OP *o));
OP *ck_require _((OP *o));
OP *ck_select _((OP *o));
OP *ck_shift _((OP *o));
OP *ck_sort _((OP *o));
OP *ck_split _((OP *o));
OP *ck_subr _((OP *o));
OP *ck_svconst _((OP *o));
OP *ck_trunc _((OP *o));
void unwind_handler_stack _((void *p));
void restore_magic _((void *p));
void restore_rsfp _((void *f));
void restore_expect _((void *e));
void restore_lex_expect _((void *e));
void yydestruct _((void *ptr));

VIRTUAL int fprintf _((PerlIO *pf, const char *pat, ...));
VIRTUAL SV**	get_specialsv_list _((void));

#ifdef WIN32
VIRTUAL int&	ErrorNo _((void));
#endif	/* WIN32 */
#else	/* !PERL_OBJECT */
END_EXTERN_C
#endif	/* PERL_OBJECT */

#ifdef INDIRECT_BGET_MACROS
VIRTUAL void byterun _((struct bytestream bs));
#else
VIRTUAL void byterun _((PerlIO *fp));
#endif /* INDIRECT_BGET_MACROS */

VIRTUAL void	sv_catpvf_mg _((SV *sv, const char* pat, ...));
VIRTUAL void	sv_catpv_mg _((SV *sv, char *ptr));
VIRTUAL void	sv_catpvn_mg _((SV *sv, char *ptr, STRLEN len));
VIRTUAL void	sv_catsv_mg _((SV *dstr, SV *sstr));
VIRTUAL void	sv_setpvf_mg _((SV *sv, const char* pat, ...));
VIRTUAL void	sv_setiv_mg _((SV *sv, IV i));
VIRTUAL void	sv_setpviv_mg _((SV *sv, IV iv));
VIRTUAL void	sv_setuv_mg _((SV *sv, UV u));
VIRTUAL void	sv_setnv_mg _((SV *sv, double num));
VIRTUAL void	sv_setpv_mg _((SV *sv, const char *ptr));
VIRTUAL void	sv_setpvn_mg _((SV *sv, const char *ptr, STRLEN len));
VIRTUAL void	sv_setsv_mg _((SV *dstr, SV *sstr));
VIRTUAL void	sv_usepvn_mg _((SV *sv, char *ptr, STRLEN len));

VIRTUAL MGVTBL*	get_vtbl _((int vtbl_id));
VIRTUAL OP*	dofile _((OP* term));
VIRTUAL void	save_generic_svref _((SV** sptr));
 
/* New virtual functions must be added here to maintain binary
 * compatablity with PERL_OBJECT
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\pp.h ===
/*    pp.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef USE_THREADS
#define ARGS thr
#define dARGS struct perl_thread *thr;
#else
#define ARGS
#define dARGS
#endif /* USE_THREADS */
#ifdef PERL_OBJECT
#define PP(s) OP * CPerlObj::s(ARGSproto)
#else
#define PP(s) OP * s(ARGSproto)
#endif

#define SP sp
#define MARK mark
#define TARG targ

#define PUSHMARK(p) if (++PL_markstack_ptr == PL_markstack_max)	\
			markstack_grow();			\
		    *PL_markstack_ptr = (p) - PL_stack_base

#define TOPMARK		(*PL_markstack_ptr)
#define POPMARK		(*PL_markstack_ptr--)

#define djSP		register SV **sp = PL_stack_sp
#define dSP		dTHR; djSP
#define dMARK		register SV **mark = PL_stack_base + POPMARK
#define dORIGMARK	I32 origmark = mark - PL_stack_base
#define SETORIGMARK	origmark = mark - PL_stack_base
#define ORIGMARK	(PL_stack_base + origmark)

#define SPAGAIN		sp = PL_stack_sp
#define MSPAGAIN	sp = PL_stack_sp; mark = ORIGMARK

#define GETTARGETSTACKED targ = (PL_op->op_flags & OPf_STACKED ? POPs : PAD_SV(PL_op->op_targ))
#define dTARGETSTACKED SV * GETTARGETSTACKED

#define GETTARGET targ = PAD_SV(PL_op->op_targ)
#define dTARGET SV * GETTARGET

#define GETATARGET targ = (PL_op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(PL_op->op_targ))
#define dATARGET SV * GETATARGET

#define dTARG SV *targ

#define NORMAL PL_op->op_next
#define DIE return die

#define PUTBACK		PL_stack_sp = sp
#define RETURN		return PUTBACK, NORMAL
#define RETURNOP(o)	return PUTBACK, o
#define RETURNX(x)	return x, PUTBACK, NORMAL

#define POPs		(*sp--)
#define POPp		(SvPVx(POPs, PL_na))		/* deprecated */
#define POPpx		(SvPVx(POPs, n_a))
#define POPn		(SvNVx(POPs))
#define POPi		((IV)SvIVx(POPs))
#define POPu		((UV)SvUVx(POPs))
#define POPl		((long)SvIVx(POPs))

#define TOPs		(*sp)
#define TOPp		(SvPV(TOPs, PL_na))		/* deprecated */
#define TOPpx		(SvPV(TOPs, n_a))
#define TOPn		(SvNV(TOPs))
#define TOPi		((IV)SvIV(TOPs))
#define TOPu		((UV)SvUV(TOPs))
#define TOPl		((long)SvIV(TOPs))

/* Go to some pains in the rare event that we must extend the stack. */
#define EXTEND(p,n)	STMT_START { if (PL_stack_max - p < (n)) {		\
			    sp = stack_grow(sp,p, (int) (n));		\
			} } STMT_END

/* Same thing, but update mark register too. */
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (n)) {		\
			    int markoff = mark - PL_stack_base;		\
			    sp = stack_grow(sp,p,(int) (n));		\
			    mark = PL_stack_base + markoff;		\
			} } STMT_END

#define PUSHs(s)	(*++sp = (s))
#define PUSHTARG	STMT_START { SvSETMAGIC(TARG); PUSHs(TARG); } STMT_END
#define PUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); PUSHTARG; } STMT_END
#define PUSHn(n)	STMT_START { sv_setnv(TARG, (double)(n)); PUSHTARG; } STMT_END
#define PUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); PUSHTARG; } STMT_END
#define PUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG; } STMT_END

#define XPUSHs(s)	STMT_START { EXTEND(sp,1); (*++sp = (s)); } STMT_END
#define XPUSHTARG	STMT_START { SvSETMAGIC(TARG); XPUSHs(TARG); } STMT_END
#define XPUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); XPUSHTARG; } STMT_END
#define XPUSHn(n)	STMT_START { sv_setnv(TARG, (double)(n)); XPUSHTARG; } STMT_END
#define XPUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); XPUSHTARG; } STMT_END
#define XPUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END

#define SETs(s)		(*sp = s)
#define SETTARG		STMT_START { SvSETMAGIC(TARG); SETs(TARG); } STMT_END
#define SETp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); SETTARG; } STMT_END
#define SETn(n)		STMT_START { sv_setnv(TARG, (double)(n)); SETTARG; } STMT_END
#define SETi(i)		STMT_START { sv_setiv(TARG, (IV)(i)); SETTARG; } STMT_END
#define SETu(u)		STMT_START { sv_setuv(TARG, (UV)(u)); SETTARG; } STMT_END

#define dTOPss		SV *sv = TOPs
#define dPOPss		SV *sv = POPs
#define dTOPnv		double value = TOPn
#define dPOPnv		double value = POPn
#define dTOPiv		IV value = TOPi
#define dPOPiv		IV value = POPi
#define dTOPuv		UV value = TOPu
#define dPOPuv		UV value = POPu

#define dPOPXssrl(X)	SV *right = POPs; SV *left = CAT2(X,s)
#define dPOPXnnrl(X)	double right = POPn; double left = CAT2(X,n)
#define dPOPXiirl(X)	IV right = POPi; IV left = CAT2(X,i)

#define USE_LEFT(sv) \
	(SvOK(sv) || SvGMAGICAL(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXnnrl_ul(X)	\
    double right = POPn;				\
    SV *leftsv = CAT2(X,s);				\
    double left = USE_LEFT(leftsv) ? SvNV(leftsv) : 0.0
#define dPOPXiirl_ul(X) \
    IV right = POPi;					\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV(leftsv) : 0

#define dPOPPOPssrl	dPOPXssrl(POP)
#define dPOPPOPnnrl	dPOPXnnrl(POP)
#define dPOPPOPnnrl_ul	dPOPXnnrl_ul(POP)
#define dPOPPOPiirl	dPOPXiirl(POP)
#define dPOPPOPiirl_ul	dPOPXiirl_ul(POP)

#define dPOPTOPssrl	dPOPXssrl(TOP)
#define dPOPTOPnnrl	dPOPXnnrl(TOP)
#define dPOPTOPnnrl_ul	dPOPXnnrl_ul(TOP)
#define dPOPTOPiirl	dPOPXiirl(TOP)
#define dPOPTOPiirl_ul	dPOPXiirl_ul(TOP)

#define RETPUSHYES	RETURNX(PUSHs(&PL_sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&PL_sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&PL_sv_undef))

#define RETSETYES	RETURNX(SETs(&PL_sv_yes))
#define RETSETNO	RETURNX(SETs(&PL_sv_no))
#define RETSETUNDEF	RETURNX(SETs(&PL_sv_undef))

#define ARGTARG		PL_op->op_targ
#define MAXARG		PL_op->op_private

#define SWITCHSTACK(f,t) \
    STMT_START {							\
	AvFILLp(f) = sp - PL_stack_base;					\
	PL_stack_base = AvARRAY(t);					\
	PL_stack_max = PL_stack_base + AvMAX(t);				\
	sp = PL_stack_sp = PL_stack_base + AvFILLp(t);			\
	PL_curstack = t;							\
    } STMT_END

#define EXTEND_MORTAL(n) \
	STMT_START { \
	    if (PL_tmps_ix + (n) >= PL_tmps_max) \
		Renew(PL_tmps_stack, PL_tmps_max = PL_tmps_ix + (n) + 1, SV*); \
	} STMT_END

#ifdef OVERLOAD

#define AMGf_noright	1
#define AMGf_noleft	2
#define AMGf_assign	4
#define AMGf_unary	8

#define tryAMAGICbinW(meth,assign,set) STMT_START { \
          if (PL_amagic_generation) { \
	    SV* tmpsv; \
	    SV* right= *(sp); SV* left= *(sp-1);\
	    if ((SvAMAGIC(left)||SvAMAGIC(right))&&\
		(tmpsv=amagic_call(left, \
				   right, \
				   CAT2(meth,_amg), \
				   (assign)? AMGf_assign: 0))) {\
	       SPAGAIN;	\
	       (void)POPs; set(tmpsv); RETURN; } \
	  } \
	} STMT_END

#define tryAMAGICbin(meth,assign) tryAMAGICbinW(meth,assign,SETsv)
#define tryAMAGICbinSET(meth,assign) tryAMAGICbinW(meth,assign,SETs)

#define AMG_CALLun(sv,meth) amagic_call(sv,&PL_sv_undef,  \
					CAT2(meth,_amg),AMGf_noright | AMGf_unary)
#define AMG_CALLbinL(left,right,meth) \
            amagic_call(left,right,CAT2(meth,_amg),AMGf_noright)

#define tryAMAGICunW(meth,set) STMT_START { \
          if (PL_amagic_generation) { \
	    SV* tmpsv; \
	    SV* arg= *(sp); \
	    if ((SvAMAGIC(arg))&&\
		(tmpsv=AMG_CALLun(arg,meth))) {\
	       SPAGAIN;	\
	       set(tmpsv); RETURN; } \
	  } \
	} STMT_END

#define tryAMAGICun	tryAMAGICunSET
#define tryAMAGICunSET(meth) tryAMAGICunW(meth,SETs)

#define opASSIGN (PL_op->op_flags & OPf_STACKED)
#define SETsv(sv)	STMT_START {					\
		if (opASSIGN) { sv_setsv(TARG, (sv)); SETTARG; }	\
		else SETs(sv); } STMT_END

/* newSVsv does not behave as advertised, so we copy missing
 * information by hand */

/* SV* ref causes confusion with the member variable
   changed SV* ref to SV* tmpRef */
#define RvDEEPCP(rv) STMT_START { SV* tmpRef=SvRV(rv);      \
  if (SvREFCNT(tmpRef)>1) {                 \
    SvREFCNT_dec(tmpRef);                   \
    SvRV(rv)=AMG_CALLun(rv,copy);        \
  } } STMT_END
#else

#define tryAMAGICbin(a,b)
#define tryAMAGICbinSET(a,b)
#define tryAMAGICun(a)
#define tryAMAGICunSET(a)

#endif /* OVERLOAD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\regnodes.h ===
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regcomp.pl from regcomp.sym.  
   Any changes made here will be lost!
*/

#define	END	0	/*    0 End of program. */
#define	SUCCEED	1	/*  0x1 Return from a subroutine, basically. */
#define	BOL	2	/*  0x2 Match "" at beginning of line. */
#define	MBOL	3	/*  0x3 Same, assuming multiline. */
#define	SBOL	4	/*  0x4 Same, assuming singleline. */
#define	EOS	5	/*  0x5 Match "" at end of string. */
#define	EOL	6	/*  0x6 Match "" at end of line. */
#define	MEOL	7	/*  0x7 Same, assuming multiline. */
#define	SEOL	8	/*  0x8 Same, assuming singleline. */
#define	BOUND	9	/*  0x9 Match "" at any word boundary */
#define	BOUNDL	10	/*  0xa Match "" at any word boundary */
#define	NBOUND	11	/*  0xb Match "" at any word non-boundary */
#define	NBOUNDL	12	/*  0xc Match "" at any word non-boundary */
#define	GPOS	13	/*  0xd Matches where last m//g left off. */
#define	ANY	14	/*  0xe Match any one character (except newline). */
#define	SANY	15	/*  0xf Match any one character. */
#define	ANYOF	16	/* 0x10 Match character in (or not in) this class. */
#define	ALNUM	17	/* 0x11 Match any alphanumeric character */
#define	ALNUML	18	/* 0x12 Match any alphanumeric char in locale */
#define	NALNUM	19	/* 0x13 Match any non-alphanumeric character */
#define	NALNUML	20	/* 0x14 Match any non-alphanumeric char in locale */
#define	SPACE	21	/* 0x15 Match any whitespace character */
#define	SPACEL	22	/* 0x16 Match any whitespace char in locale */
#define	NSPACE	23	/* 0x17 Match any non-whitespace character */
#define	NSPACEL	24	/* 0x18 Match any non-whitespace char in locale */
#define	DIGIT	25	/* 0x19 Match any numeric character */
#define	NDIGIT	26	/* 0x1a Match any non-numeric character */
#define	BRANCH	27	/* 0x1b Match this alternative, or the next... */
#define	BACK	28	/* 0x1c Match "", "next" ptr points backward. */
#define	EXACT	29	/* 0x1d Match this string (preceded by length). */
#define	EXACTF	30	/* 0x1e Match this string, folded (prec. by length). */
#define	EXACTFL	31	/* 0x1f Match this string, folded in locale (w/len). */
#define	NOTHING	32	/* 0x20 Match empty string. */
#define	TAIL	33	/* 0x21 Match empty string. Can jump here from outside. */
#define	STAR	34	/* 0x22 Match this (simple) thing 0 or more times. */
#define	PLUS	35	/* 0x23 Match this (simple) thing 1 or more times. */
#define	CURLY	36	/* 0x24 Match this simple thing {n,m} times. */
#define	CURLYN	37	/* 0x25 Match next-after-this simple thing  */
#define	CURLYM	38	/* 0x26 Match this medium-complex thing {n,m} times. */
#define	CURLYX	39	/* 0x27 Match this complex thing {n,m} times. */
#define	WHILEM	40	/* 0x28 Do curly processing and see if rest matches. */
#define	OPEN	41	/* 0x29 Mark this point in input as start of #n. */
#define	CLOSE	42	/* 0x2a Analogous to OPEN. */
#define	REF	43	/* 0x2b Match some already matched string */
#define	REFF	44	/* 0x2c Match already matched string, folded */
#define	REFFL	45	/* 0x2d Match already matched string, folded in loc. */
#define	IFMATCH	46	/* 0x2e Succeeds if the following matches. */
#define	UNLESSM	47	/* 0x2f Fails if the following matches. */
#define	SUSPEND	48	/* 0x30 "Independent" sub-RE. */
#define	IFTHEN	49	/* 0x31 Switch, should be preceeded by switcher . */
#define	GROUPP	50	/* 0x32 Whether the group matched. */
#define	LONGJMP	51	/* 0x33 Jump far away. */
#define	BRANCHJ	52	/* 0x34 BRANCH with long offset. */
#define	EVAL	53	/* 0x35 Execute some Perl code. */
#define	MINMOD	54	/* 0x36 Next operator is not greedy. */
#define	LOGICAL	55	/* 0x37 Next opcode should set the flag only. */
#define	RENUM	56	/* 0x38 Group with independently numbered parens. */
#define	OPTIMIZED	57	/* 0x39 Placeholder for dump. */

#ifndef DOINIT
EXTCONST U8 regkind[];
#else
EXTCONST U8 regkind[] = {
	END,		/* END */
	END,		/* SUCCEED */
	BOL,		/* BOL */
	BOL,		/* MBOL */
	BOL,		/* SBOL */
	EOL,		/* EOS */
	EOL,		/* EOL */
	EOL,		/* MEOL */
	EOL,		/* SEOL */
	BOUND,		/* BOUND */
	BOUND,		/* BOUNDL */
	NBOUND,		/* NBOUND */
	NBOUND,		/* NBOUNDL */
	GPOS,		/* GPOS */
	ANY,		/* ANY */
	ANY,		/* SANY */
	ANYOF,		/* ANYOF */
	ALNUM,		/* ALNUM */
	ALNUM,		/* ALNUML */
	NALNUM,		/* NALNUM */
	NALNUM,		/* NALNUML */
	SPACE,		/* SPACE */
	SPACE,		/* SPACEL */
	NSPACE,		/* NSPACE */
	NSPACE,		/* NSPACEL */
	DIGIT,		/* DIGIT */
	NDIGIT,		/* NDIGIT */
	BRANCH,		/* BRANCH */
	BACK,		/* BACK */
	EXACT,		/* EXACT */
	EXACT,		/* EXACTF */
	EXACT,		/* EXACTFL */
	NOTHING,		/* NOTHING */
	NOTHING,		/* TAIL */
	STAR,		/* STAR */
	PLUS,		/* PLUS */
	CURLY,		/* CURLY */
	CURLY,		/* CURLYN */
	CURLY,		/* CURLYM */
	CURLY,		/* CURLYX */
	WHILEM,		/* WHILEM */
	OPEN,		/* OPEN */
	CLOSE,		/* CLOSE */
	REF,		/* REF */
	REF,		/* REFF */
	REF,		/* REFFL */
	BRANCHJ,		/* IFMATCH */
	BRANCHJ,		/* UNLESSM */
	BRANCHJ,		/* SUSPEND */
	BRANCHJ,		/* IFTHEN */
	GROUPP,		/* GROUPP */
	LONGJMP,		/* LONGJMP */
	BRANCHJ,		/* BRANCHJ */
	EVAL,		/* EVAL */
	MINMOD,		/* MINMOD */
	LOGICAL,		/* LOGICAL */
	BRANCHJ,		/* RENUM */
	NOTHING,		/* OPTIMIZED */
};
#endif


#ifdef REG_COMP_C
const static U8 regarglen[] = {
	0,		/* END */
	0,		/* SUCCEED */
	0,		/* BOL */
	0,		/* MBOL */
	0,		/* SBOL */
	0,		/* EOS */
	0,		/* EOL */
	0,		/* MEOL */
	0,		/* SEOL */
	0,		/* BOUND */
	0,		/* BOUNDL */
	0,		/* NBOUND */
	0,		/* NBOUNDL */
	0,		/* GPOS */
	0,		/* ANY */
	0,		/* SANY */
	0,		/* ANYOF */
	0,		/* ALNUM */
	0,		/* ALNUML */
	0,		/* NALNUM */
	0,		/* NALNUML */
	0,		/* SPACE */
	0,		/* SPACEL */
	0,		/* NSPACE */
	0,		/* NSPACEL */
	0,		/* DIGIT */
	0,		/* NDIGIT */
	0,		/* BRANCH */
	0,		/* BACK */
	0,		/* EXACT */
	0,		/* EXACTF */
	0,		/* EXACTFL */
	0,		/* NOTHING */
	0,		/* TAIL */
	0,		/* STAR */
	0,		/* PLUS */
	EXTRA_SIZE(struct regnode_2),		/* CURLY */
	EXTRA_SIZE(struct regnode_2),		/* CURLYN */
	EXTRA_SIZE(struct regnode_2),		/* CURLYM */
	EXTRA_SIZE(struct regnode_2),		/* CURLYX */
	0,		/* WHILEM */
	EXTRA_SIZE(struct regnode_1),		/* OPEN */
	EXTRA_SIZE(struct regnode_1),		/* CLOSE */
	EXTRA_SIZE(struct regnode_1),		/* REF */
	EXTRA_SIZE(struct regnode_1),		/* REFF */
	EXTRA_SIZE(struct regnode_1),		/* REFFL */
	EXTRA_SIZE(struct regnode_1),		/* IFMATCH */
	EXTRA_SIZE(struct regnode_1),		/* UNLESSM */
	EXTRA_SIZE(struct regnode_1),		/* SUSPEND */
	EXTRA_SIZE(struct regnode_1),		/* IFTHEN */
	EXTRA_SIZE(struct regnode_1),		/* GROUPP */
	EXTRA_SIZE(struct regnode_1),		/* LONGJMP */
	EXTRA_SIZE(struct regnode_1),		/* BRANCHJ */
	EXTRA_SIZE(struct regnode_1),		/* EVAL */
	0,		/* MINMOD */
	0,		/* LOGICAL */
	EXTRA_SIZE(struct regnode_1),		/* RENUM */
	0,		/* OPTIMIZED */
};

const static char reg_off_by_arg[] = {
	0,		/* END */
	0,		/* SUCCEED */
	0,		/* BOL */
	0,		/* MBOL */
	0,		/* SBOL */
	0,		/* EOS */
	0,		/* EOL */
	0,		/* MEOL */
	0,		/* SEOL */
	0,		/* BOUND */
	0,		/* BOUNDL */
	0,		/* NBOUND */
	0,		/* NBOUNDL */
	0,		/* GPOS */
	0,		/* ANY */
	0,		/* SANY */
	0,		/* ANYOF */
	0,		/* ALNUM */
	0,		/* ALNUML */
	0,		/* NALNUM */
	0,		/* NALNUML */
	0,		/* SPACE */
	0,		/* SPACEL */
	0,		/* NSPACE */
	0,		/* NSPACEL */
	0,		/* DIGIT */
	0,		/* NDIGIT */
	0,		/* BRANCH */
	0,		/* BACK */
	0,		/* EXACT */
	0,		/* EXACTF */
	0,		/* EXACTFL */
	0,		/* NOTHING */
	0,		/* TAIL */
	0,		/* STAR */
	0,		/* PLUS */
	0,		/* CURLY */
	0,		/* CURLYN */
	0,		/* CURLYM */
	0,		/* CURLYX */
	0,		/* WHILEM */
	0,		/* OPEN */
	0,		/* CLOSE */
	0,		/* REF */
	0,		/* REFF */
	0,		/* REFFL */
	2,		/* IFMATCH */
	2,		/* UNLESSM */
	1,		/* SUSPEND */
	1,		/* IFTHEN */
	0,		/* GROUPP */
	1,		/* LONGJMP */
	1,		/* BRANCHJ */
	0,		/* EVAL */
	0,		/* MINMOD */
	0,		/* LOGICAL */
	1,		/* RENUM */
	0,		/* OPTIMIZED */
};
#endif /* REG_COMP_C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\regcomp.h ===
/*    regcomp.h
 */

typedef OP OP_4tree;			/* Will be redefined later. */

/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart	sv that must begin a match; Nullch if none obvious
 * reganch	is the match anchored (at beginning-of-line only)?
 * regmust	string (pointer into program) that match must include, or NULL
 *  [regmust changed to SV* for bminstr()--law]
 * regmlen	length of regmust string
 *  [regmlen not used currently]
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that pregcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in pregexec() needs it and pregcomp() is computing
 * it anyway.
 * [regmust is now supplied always.  The tests that use regmust have a
 * heuristic that disables the test if it usually matches.]
 *
 * [In fact, we now use regmust in many cases to locate where the search
 * starts in the string, so if regback is >= 0, the regmust search is never
 * wasted effort.  The regback variable says how many characters back from
 * where regmust matched is the earliest possible start of the match.
 * For instance, /[a-z].foo/ has a regmust of 'foo' and a regback of 2.]
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are:
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 *
 * [The "next" pointer is always aligned on an even
 * boundary, and reads the offset directly as a short.  Also, there is no
 * special test to reverse the sign of BACK pointers since the offset is
 * stored negative.]
 */

struct regnode_string {
    U8	flags;
    U8  type;
    U16 next_off;
    U8 string[1];
};

struct regnode_1 {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
};

struct regnode_2 {
    U8	flags;
    U8  type;
    U16 next_off;
    U16 arg1;
    U16 arg2;
};

/* XXX fix this description.
   Impose a limit of REG_INFTY on various pattern matching operations
   to limit stack growth and to avoid "infinite" recursions.
*/
/* The default size for REG_INFTY is I16_MAX, which is the same as
   SHORT_MAX (see perl.h).  Unfortunately I16 isn't necessarily 16 bits
   (see handy.h).  On the Cray C90, sizeof(short)==4 and hence I16_MAX is
   ((1<<31)-1), while on the Cray T90, sizeof(short)==8 and I16_MAX is
   ((1<<63)-1).  To limit stack growth to reasonable sizes, supply a
   smaller default.
	--Andy Dougherty  11 June 1998
*/
#if SHORTSIZE > 2
#  ifndef REG_INFTY
#    define REG_INFTY ((1<<15)-1)
#  endif
#endif

#ifndef REG_INFTY
#  define REG_INFTY I16_MAX
#endif

#define ARG_VALUE(arg) (arg)
#define ARG__SET(arg,val) ((arg) = (val))

#define ARG(p) ARG_VALUE(ARG_LOC(p))
#define ARG1(p) ARG_VALUE(ARG1_LOC(p))
#define ARG2(p) ARG_VALUE(ARG2_LOC(p))
#define ARG_SET(p, val) ARG__SET(ARG_LOC(p), (val))
#define ARG1_SET(p, val) ARG__SET(ARG1_LOC(p), (val))
#define ARG2_SET(p, val) ARG__SET(ARG2_LOC(p), (val))

#ifndef lint
#  define NEXT_OFF(p) ((p)->next_off)
#  define NODE_ALIGN(node)
#  define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */
#else /* lint */
#  define NEXT_OFF(p) 0
#  define NODE_ALIGN(node)
#  define NODE_ALIGN_FILL(node)
#endif /* lint */

#define SIZE_ALIGN NODE_ALIGN

#define	OP(p)		((p)->type)
#define	OPERAND(p)	(((struct regnode_string *)p)->string)
#define	NODE_ALIGN(node)
#define	ARG_LOC(p)	(((struct regnode_1 *)p)->arg1)
#define	ARG1_LOC(p)	(((struct regnode_2 *)p)->arg1)
#define	ARG2_LOC(p)	(((struct regnode_2 *)p)->arg2)
#define NODE_STEP_REGNODE	1	/* sizeof(regnode)/sizeof(regnode) */
#define EXTRA_STEP_2ARGS	EXTRA_SIZE(struct regnode_2)

#define NODE_STEP_B	4

#define	NEXTOPER(p)	((p) + NODE_STEP_REGNODE)
#define	PREVOPER(p)	((p) - NODE_STEP_REGNODE)

#define FILL_ADVANCE_NODE(ptr, op) STMT_START { \
    (ptr)->type = op;    (ptr)->next_off = 0;   (ptr)++; } STMT_END
#define FILL_ADVANCE_NODE_ARG(ptr, op, arg) STMT_START { \
    ARG_SET(ptr, arg);  FILL_ADVANCE_NODE(ptr, op); (ptr) += 1; } STMT_END

#define MAGIC 0234

#define SIZE_ONLY (PL_regcode == &PL_regdummy)

/* Flags for first parameter byte of ANYOF */
#define ANYOF_INVERT	0x40
#define ANYOF_FOLD	0x20
#define ANYOF_LOCALE	0x10
#define ANYOF_ISA	0x0F
#define ANYOF_ALNUML	 0x08
#define ANYOF_NALNUML	 0x04
#define ANYOF_SPACEL	 0x02
#define ANYOF_NSPACEL	 0x01

/* Utility macros for bitmap of ANYOF */
#define ANYOF_BYTE(p,c)     (p)[1 + (((c) >> 3) & 31)]
#define ANYOF_BIT(c)        (1 << ((c) & 7))
#define ANYOF_SET(p,c)      (ANYOF_BYTE(p,c) |=  ANYOF_BIT(c))
#define ANYOF_CLEAR(p,c)    (ANYOF_BYTE(p,c) &= ~ANYOF_BIT(c))
#define ANYOF_TEST(p,c)     (ANYOF_BYTE(p,c) &   ANYOF_BIT(c))

#define ANY_SKIP ((33 - 1)/sizeof(regnode) + 1)

/*
 * Utility definitions.
 */
#ifndef lint
#ifndef CHARMASK
#define	UCHARAT(p)	((int)*(unsigned char *)(p))
#else
#define	UCHARAT(p)	((int)*(p)&CHARMASK)
#endif
#else /* lint */
#define UCHARAT(p)	PL_regdummy
#endif /* lint */

#define	FAIL(m)		croak    ("/%.127s/: %s",  PL_regprecomp,m)
#define	FAIL2(pat,m)	re_croak2("/%.127s/: ",pat,PL_regprecomp,m)

#define EXTRA_SIZE(guy) ((sizeof(guy)-1)/sizeof(struct regnode))

#define REG_SEEN_ZERO_LEN	1
#define REG_SEEN_LOOKBEHIND	2
#define REG_SEEN_GPOS		4
#define REG_SEEN_EVAL		8

#include "regnodes.h"

/* The following have no fixed length. char* since we do strchr on it. */
#ifndef DOINIT
EXTCONST char varies[];
#else
EXTCONST char varies[] = {
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL, 
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, 0
};
#endif

/* The following always have a length of 1. char* since we do strchr on it. */
#ifndef DOINIT
EXTCONST char simple[];
#else
EXTCONST char simple[] = {
    ANY, SANY, ANYOF,
    ALNUM, ALNUML, NALNUM, NALNUML,
    SPACE, SPACEL, NSPACE, NSPACEL,
    DIGIT, NDIGIT, 0
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\regexp.h ===
/*    regexp.h
 */

/*
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 */


struct regnode {
    U8	flags;
    U8  type;
    U16 next_off;
};

typedef struct regnode regnode;

struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;
};

struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};

typedef struct regexp {
	I32 refcnt;
	char **startp;
	char **endp;
	regnode *regstclass;
	I32 minlen;		/* mininum possible length of $& */
	I32 prelen;		/* length of precomp */
	U32 nparens;		/* number of parentheses */
	U32 lastparen;		/* last paren matched */
	char *precomp;		/* pre-compilation regular expression */
	char *subbase;		/* saved string so \digit works forever */
	char *subbeg;		/* same, but not responsible for allocation */
	char *subend;		/* end of subbase */
	U16 naughty;		/* how exponential is this pattern? */
	U16 reganch;		/* Internal use only +
				   Tainted information used by regexec? */
#if 0
        SV *anchored_substr;	/* Substring at fixed position wrt start. */
	I32 anchored_offset;	/* Position of it. */
        SV *float_substr;	/* Substring at variable position wrt start. */
	I32 float_min_offset;	/* Minimal position of it. */
	I32 float_max_offset;	/* Maximal position of it. */
        SV *check_substr;	/* Substring to check before matching. */
        I32 check_offset_min;	/* Offset of the above. */
        I32 check_offset_max;	/* Offset of the above. */
#else
        struct reg_substr_data *substrs;
#endif
        struct reg_data *data;	/* Additional data. */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
} regexp;

#define anchored_substr substrs->data[0].substr
#define anchored_offset substrs->data[0].min_offset
#define float_substr substrs->data[1].substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define check_substr substrs->data[2].substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset

#define ROPT_ANCH		(ROPT_ANCH_BOL|ROPT_ANCH_MBOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_SINGLE	(ROPT_ANCH_BOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_BOL	 	1
#define ROPT_ANCH_MBOL	 	2
#define ROPT_ANCH_GPOS	 	4
#define ROPT_SKIP		8
#define ROPT_IMPLICIT		0x10	/* Converted .* to ^.* */
#define ROPT_NOSCAN		0x20	/* Check-string always at start. */
#define ROPT_GPOS_SEEN		0x40
#define ROPT_CHECK_ALL		0x80
#define ROPT_LOOKBEHIND_SEEN	0x100
#define ROPT_EVAL_SEEN		0x200
#define ROPT_TAINTED_SEEN	0x400
/* 0xf800 of reganch is used by PMf_COMPILETIME */

#define RX_MATCH_TAINTED(prog)	((prog)->reganch & ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) ((prog)->reganch |= ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) ((prog)->reganch &= ~ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_set(prog, t) ((t) \
				       ? RX_MATCH_TAINTED_on(prog) \
				       : RX_MATCH_TAINTED_off(prog))

#define REXEC_COPY_STR	1		/* Need to copy the string. */
#define REXEC_CHECKED	2		/* check_substr already checked. */

#define ReREFCNT_inc(re) ((re && re->refcnt++), re)
#define ReREFCNT_dec(re) pregfree(re)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\scope.h ===
#define SAVEt_ITEM	0
#define SAVEt_SV	1
#define SAVEt_AV	2
#define SAVEt_HV	3
#define SAVEt_INT	4
#define SAVEt_LONG	5
#define SAVEt_I32	6
#define SAVEt_IV	7
#define SAVEt_SPTR	8
#define SAVEt_APTR	9
#define SAVEt_HPTR	10
#define SAVEt_PPTR	11
#define SAVEt_NSTAB	12
#define SAVEt_SVREF	13
#define SAVEt_GP	14
#define SAVEt_FREESV	15
#define SAVEt_FREEOP	16
#define SAVEt_FREEPV	17
#define SAVEt_CLEARSV	18
#define SAVEt_DELETE	19
#define SAVEt_DESTRUCTOR 20
#define SAVEt_REGCONTEXT 21
#define SAVEt_STACK_POS  22
#define SAVEt_I16	23
#define SAVEt_AELEM     24
#define SAVEt_HELEM     25
#define SAVEt_OP	26
#define SAVEt_HINTS	27
/* #define SAVEt_ALLOC		28 */ /* defined in 5.005_5x */
#define SAVEt_GENERIC_SVREF	29

#define SSCHECK(need) if (PL_savestack_ix + need > PL_savestack_max) savestack_grow()
#define SSPUSHINT(i) (PL_savestack[PL_savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (PL_savestack[PL_savestack_ix++].any_long = (long)(i))
#define SSPUSHIV(i) (PL_savestack[PL_savestack_ix++].any_iv = (IV)(i))
#define SSPUSHPTR(p) (PL_savestack[PL_savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (PL_savestack[PL_savestack_ix++].any_dptr = (p))
#define SSPOPINT (PL_savestack[--PL_savestack_ix].any_i32)
#define SSPOPLONG (PL_savestack[--PL_savestack_ix].any_long)
#define SSPOPIV (PL_savestack[--PL_savestack_ix].any_iv)
#define SSPOPPTR (PL_savestack[--PL_savestack_ix].any_ptr)
#define SSPOPDPTR (PL_savestack[--PL_savestack_ix].any_dptr)

#define SAVETMPS save_int((int*)&PL_tmps_floor), PL_tmps_floor = PL_tmps_ix
#define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps()

#ifdef DEBUGGING
#define ENTER							\
    STMT_START {						\
	push_scope();						\
	DEBUG_l(WITH_THR(deb("ENTER scope %ld at %s:%d\n",	\
		    PL_scopestack_ix, __FILE__, __LINE__)));	\
    } STMT_END
#define LEAVE							\
    STMT_START {						\
	DEBUG_l(WITH_THR(deb("LEAVE scope %ld at %s:%d\n",	\
		    PL_scopestack_ix, __FILE__, __LINE__)));	\
	pop_scope();						\
    } STMT_END
#else
#define ENTER push_scope()
#define LEAVE pop_scope()
#endif
#define LEAVE_SCOPE(old) if (PL_savestack_ix > old) leave_scope(old)

/*
 * Not using SOFT_CAST on SAVESPTR, SAVEGENERICSV and SAVEFREESV
 * because these are used for several kinds of pointer values
 */
#define SAVEI16(i)	save_I16(SOFT_CAST(I16*)&(i))
#define SAVEI32(i)	save_I32(SOFT_CAST(I32*)&(i))
#define SAVEINT(i)	save_int(SOFT_CAST(int*)&(i))
#define SAVEIV(i)	save_iv(SOFT_CAST(IV*)&(i))
#define SAVELONG(l)	save_long(SOFT_CAST(long*)&(l))
#define SAVESPTR(s)	save_sptr((SV**)&(s))
#define SAVEPPTR(s)	save_pptr(SOFT_CAST(char**)&(s))
#define SAVEFREESV(s)	save_freesv((SV*)(s))
#define SAVEFREEOP(o)	save_freeop(SOFT_CAST(OP*)(o))
#define SAVEFREEPV(p)	save_freepv(SOFT_CAST(char*)(p))
#define SAVECLEARSV(sv)	save_clearsv(SOFT_CAST(SV**)&(sv))
#define SAVEGENERICSV(s)	save_generic_svref((SV**)&(s))
#define SAVEDELETE(h,k,l) \
	  save_delete(SOFT_CAST(HV*)(h), SOFT_CAST(char*)(k), (I32)(l))
#ifdef PERL_OBJECT
#define CALLDESTRUCTOR this->*SSPOPDPTR
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor((DESTRUCTORFUNC)(FUNC_NAME_TO_PTR(f)),	\
			  SOFT_CAST(void*)(p))
#else
#define CALLDESTRUCTOR *SSPOPDPTR
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor(SOFT_CAST(void(*)_((void*)))(FUNC_NAME_TO_PTR(f)), \
			  SOFT_CAST(void*)(p))
#endif

#define SAVESTACK_POS() \
    STMT_START {				\
	SSCHECK(2);				\
	SSPUSHINT(PL_stack_sp - PL_stack_base);	\
	SSPUSHINT(SAVEt_STACK_POS);		\
    } STMT_END

#define SAVEOP()	save_op()

#define SAVEHINTS() \
    STMT_START {				\
	if (PL_hints & HINT_LOCALIZE_HH)	\
	    save_hints();			\
	else {					\
	    SSCHECK(2);				\
	    SSPUSHINT(PL_hints);		\
	    SSPUSHINT(SAVEt_HINTS);		\
	}					\
    } STMT_END

/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a start_env initialized when perl starts, and top_env
 * points to this initially, so top_env should always be non-null.
 *
 * Existence of a non-null top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		
    int			je_ret;		/* return value of last setjmp() */
    bool		je_mustcatch;	/* longjmp()s must be caught locally */
};

typedef struct jmpenv JMPENV;

#ifdef OP_IN_REGISTER
#define OP_REG_TO_MEM	PL_opsave = op
#define OP_MEM_TO_REG	op = PL_opsave
#else
#define OP_REG_TO_MEM	NOOP
#define OP_MEM_TO_REG	NOOP
#endif

#define dJMPENV		JMPENV cur_env
#define JMPENV_PUSH(v) \
    STMT_START {					\
	cur_env.je_prev = PL_top_env;			\
	OP_REG_TO_MEM;					\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, 1);	\
	OP_MEM_TO_REG;					\
	PL_top_env = &cur_env;				\
	cur_env.je_mustcatch = FALSE;			\
	(v) = cur_env.je_ret;				\
    } STMT_END
#define JMPENV_POP \
    STMT_START { PL_top_env = cur_env.je_prev; } STMT_END
#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev)					\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));			\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_NATIVE_EXPORT);				\
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");	\
	PerlProc_exit(1);						\
    } STMT_END
   
#define CATCH_GET	(PL_top_env->je_mustcatch)
#define CATCH_SET(v)	(PL_top_env->je_mustcatch = (v))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\thread.h ===
#ifdef USE_THREADS

#ifdef WIN32
#  include <win32thread.h>
#else

#ifndef DJGPP
/* POSIXish threads */
#ifdef OLD_PTHREADS_API
#  define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#  define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#  define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#  define YIELD pthread_yield()
#  define DETACH(t)				\
    STMT_START {				\
	if (pthread_detach(&(t)->self)) {	\
	    MUTEX_UNLOCK(&(t)->mutex);		\
	    croak("panic: DETACH");		\
	}					\
    } STMT_END
#else
#  define pthread_mutexattr_default NULL
#  define pthread_condattr_default NULL
#endif /* OLD_PTHREADS_API */
#endif
#endif

#ifdef PTHREADS_CREATED_JOINABLE
#  define ATTR_JOINABLE PTHREAD_CREATE_JOINABLE
#else
#  ifdef PTHREAD_CREATE_UNDETACHED
#    define ATTR_JOINABLE PTHREAD_CREATE_UNDETACHED
#  else
#    define ATTR_JOINABLE PTHREAD_CREATE_JOINABLE
#  endif
#endif

#ifdef I_MACH_CTHREADS

/* cthreads interface */

/* #include <mach/cthreads.h> is in perl.h #ifdef I_MACH_CTHREADS */

#define MUTEX_INIT(m)					\
	STMT_START {					\
		*m = mutex_alloc();			\
		if (*m) {				\
			mutex_init(*m);			\
		} else {				\
			croak("panic: MUTEX_INIT");	\
		}					\
	} STMT_END

#define MUTEX_LOCK(m)		mutex_lock(*m)
#define MUTEX_UNLOCK(m)		mutex_unlock(*m)
#define MUTEX_DESTROY(m)				\
	STMT_START {					\
		mutex_free(*m);				\
		*m = 0;					\
	} STMT_END

#define COND_INIT(c)					\
	STMT_START {					\
		*c = condition_alloc();			\
		if (*c) {				\
			condition_init(*c);		\
		} else {				\
			croak("panic: COND_INIT");	\
		}					\
	} STMT_END

#define COND_SIGNAL(c)		condition_signal(*c)
#define COND_BROADCAST(c)	condition_broadcast(*c)
#define COND_WAIT(c, m)		condition_wait(*c, *m)
#define COND_DESTROY(c)				\
	STMT_START {				\
		condition_free(*c);		\
		*c = 0;				\
	} STMT_END

#define THREAD_CREATE(thr, f)	(thr->self = cthread_fork(f, thr), 0)
#define THREAD_POST_CREATE(thr)

#define THREAD_RET_TYPE		any_t
#define THREAD_RET_CAST(x)	((any_t) x)

#define DETACH(t)		cthread_detach(t->self)
#define JOIN(t, avp)		(*(avp) = (AV *)cthread_join(t->self))

#define SET_THR(thr)		cthread_set_data(cthread_self(), thr)
#define THR			cthread_data(cthread_self())

#define INIT_THREADS		cthread_init()
#define YIELD			cthread_yield()
#define ALLOC_THREAD_KEY
#define SET_THREAD_SELF(thr)	(thr->self = cthread_self())

#endif /* I_MACH_CTHREADS */

#ifndef YIELD
#  ifdef HAS_SCHED_YIELD
#    define YIELD sched_yield()
#  else
#    ifdef HAS_PTHREAD_YIELD
#      define YIELD pthread_yield()
#    endif
#  endif
#endif

#ifdef __hpux
#  define MUTEX_INIT_NEEDS_MUTEX_ZEROED
#endif

#ifndef MUTEX_INIT
#ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
    /* Temporary workaround, true bug is deeper. --jhi 1999-02-25 */
#define MUTEX_INIT(m)						\
    STMT_START {						\
	Zero((m), 1, perl_mutex);                               \
 	if (pthread_mutex_init((m), pthread_mutexattr_default))	\
	    croak("panic: MUTEX_INIT");				\
    } STMT_END
#else
#define MUTEX_INIT(m)						\
    STMT_START {						\
	if (pthread_mutex_init((m), pthread_mutexattr_default))	\
	    croak("panic: MUTEX_INIT");				\
    } STMT_END
#endif
#define MUTEX_LOCK(m)				\
    STMT_START {				\
	if (pthread_mutex_lock((m)))		\
	    croak("panic: MUTEX_LOCK");		\
    } STMT_END
#define MUTEX_UNLOCK(m)				\
    STMT_START {				\
	if (pthread_mutex_unlock((m)))		\
	    croak("panic: MUTEX_UNLOCK");	\
    } STMT_END
#define MUTEX_DESTROY(m)			\
    STMT_START {				\
	if (pthread_mutex_destroy((m)))		\
	    croak("panic: MUTEX_DESTROY");	\
    } STMT_END
#endif /* MUTEX_INIT */

#ifndef COND_INIT
#define COND_INIT(c)						\
    STMT_START {						\
	if (pthread_cond_init((c), pthread_condattr_default))	\
	    croak("panic: COND_INIT");				\
    } STMT_END
#define COND_SIGNAL(c)				\
    STMT_START {				\
	if (pthread_cond_signal((c)))		\
	    croak("panic: COND_SIGNAL");	\
    } STMT_END
#define COND_BROADCAST(c)			\
    STMT_START {				\
	if (pthread_cond_broadcast((c)))	\
	    croak("panic: COND_BROADCAST");	\
    } STMT_END
#define COND_WAIT(c, m)				\
    STMT_START {				\
	if (pthread_cond_wait((c), (m)))	\
	    croak("panic: COND_WAIT");		\
    } STMT_END
#define COND_DESTROY(c)				\
    STMT_START {				\
	if (pthread_cond_destroy((c)))		\
	    croak("panic: COND_DESTROY");	\
    } STMT_END
#endif /* COND_INIT */

/* DETACH(t) must only be called while holding t->mutex */
#ifndef DETACH
#define DETACH(t)				\
    STMT_START {				\
	if (pthread_detach((t)->self)) {	\
	    MUTEX_UNLOCK(&(t)->mutex);		\
	    croak("panic: DETACH");		\
	}					\
    } STMT_END
#endif /* DETACH */

#ifndef JOIN
#define JOIN(t, avp) 					\
    STMT_START {					\
	if (pthread_join((t)->self, (void**)(avp)))	\
	    croak("panic: pthread_join");		\
    } STMT_END
#endif /* JOIN */

#ifndef SET_THR
#define SET_THR(t)					\
    STMT_START {					\
	if (pthread_setspecific(PL_thr_key, (void *) (t)))	\
	    croak("panic: pthread_setspecific");	\
    } STMT_END
#endif /* SET_THR */

#ifndef THR
#  ifdef OLD_PTHREADS_API
struct perl_thread *getTHR _((void));
#    define THR getTHR()
#  else
#    define THR ((struct perl_thread *) pthread_getspecific(PL_thr_key))
#  endif /* OLD_PTHREADS_API */
#endif /* THR */

/*
 * dTHR is performance-critical. Here, we only do the pthread_get_specific
 * if there may be more than one thread in existence, otherwise we get thr
 * from thrsv which is cached in the per-interpreter structure.
 * Systems with very fast pthread_get_specific (which should be all systems
 * but unfortunately isn't) may wish to simplify to "...*thr = THR".
 *
 * The use of PL_threadnum should be safe here.
 */
#ifndef dTHR
#  define dTHR \
    struct perl_thread *thr = PL_threadnum? THR : (struct perl_thread*)SvPVX(PL_thrsv)
#endif /* dTHR */

#ifndef INIT_THREADS
#  ifdef NEED_PTHREAD_INIT
#    define INIT_THREADS pthread_init()
#  else
#    define INIT_THREADS NOOP
#  endif
#endif

/* Accessor for per-thread SVs */
#define THREADSV(i) (thr->threadsvp[i])

/*
 * LOCK_SV_MUTEX and UNLOCK_SV_MUTEX are performance-critical. Here, we
 * try only locking them if there may be more than one thread in existence.
 * Systems with very fast mutexes (and/or slow conditionals) may wish to
 * remove the "if (threadnum) ..." test.
 * XXX do NOT use C<if (PL_threadnum) ...> -- it sets up race conditions!
 */
#define LOCK_SV_MUTEX				\
    STMT_START {				\
	MUTEX_LOCK(&PL_sv_mutex);		\
    } STMT_END

#define UNLOCK_SV_MUTEX				\
    STMT_START {				\
	MUTEX_UNLOCK(&PL_sv_mutex);		\
    } STMT_END

/* Likewise for strtab_mutex */
#define LOCK_STRTAB_MUTEX			\
    STMT_START {				\
	MUTEX_LOCK(&PL_strtab_mutex);	\
    } STMT_END

#define UNLOCK_STRTAB_MUTEX			\
    STMT_START {				\
	MUTEX_UNLOCK(&PL_strtab_mutex);	\
    } STMT_END

#ifndef THREAD_RET_TYPE
#  define THREAD_RET_TYPE	void *
#  define THREAD_RET_CAST(p)	((void *)(p))
#endif /* THREAD_RET */


/* Values and macros for thr->flags */
#define THRf_STATE_MASK	7
#define THRf_R_JOINABLE	0
#define THRf_R_JOINED	1
#define THRf_R_DETACHED	2
#define THRf_ZOMBIE	3
#define THRf_DEAD	4

#define THRf_DID_DIE	8

/* ThrSTATE(t) and ThrSETSTATE(t) must only be called while holding t->mutex */
#define ThrSTATE(t) ((t)->flags & THRf_STATE_MASK)
#define ThrSETSTATE(t, s) STMT_START {		\
	(t)->flags &= ~THRf_STATE_MASK;		\
	(t)->flags |= (s);			\
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),	\
			      "thread %p set to state %d\n", (t), (s))); \
    } STMT_END

typedef struct condpair {
    perl_mutex	mutex;		/* Protects all other fields */
    perl_cond	owner_cond;	/* For when owner changes at all */
    perl_cond	cond;		/* For cond_signal and cond_broadcast */
    Thread	owner;		/* Currently owning thread */
} condpair_t;

#define MgMUTEXP(mg) (&((condpair_t *)(mg->mg_ptr))->mutex)
#define MgOWNERCONDP(mg) (&((condpair_t *)(mg->mg_ptr))->owner_cond)
#define MgCONDP(mg) (&((condpair_t *)(mg->mg_ptr))->cond)
#define MgOWNER(mg) ((condpair_t *)(mg->mg_ptr))->owner

#else
/* USE_THREADS is not defined */
#define MUTEX_LOCK(m)
#define MUTEX_UNLOCK(m)
#define MUTEX_INIT(m)
#define MUTEX_DESTROY(m)
#define COND_INIT(c)
#define COND_SIGNAL(c)
#define COND_BROADCAST(c)
#define COND_WAIT(c, m)
#define COND_DESTROY(c)
#define LOCK_SV_MUTEX
#define UNLOCK_SV_MUTEX
#define LOCK_STRTAB_MUTEX
#define UNLOCK_STRTAB_MUTEX

#define THR
/* Rats: if dTHR is just blank then the subsequent ";" throws an error */
#ifdef WIN32
#define dTHR extern int Perl___notused
#else
#define dTHR extern int errno
#endif
#endif /* USE_THREADS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\sv.h ===
/*    sv.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef sv_flags
#undef sv_flags		/* Convex has this in <signal.h> for sigvec() */
#endif

typedef enum {
	SVt_NULL,	/* 0 */
	SVt_IV,		/* 1 */
	SVt_NV,		/* 2 */
	SVt_RV,		/* 3 */
	SVt_PV,		/* 4 */
	SVt_PVIV,	/* 5 */
	SVt_PVNV,	/* 6 */
	SVt_PVMG,	/* 7 */
	SVt_PVBM,	/* 8 */
	SVt_PVLV,	/* 9 */
	SVt_PVAV,	/* 10 */
	SVt_PVHV,	/* 11 */
	SVt_PVCV,	/* 12 */
	SVt_PVGV,	/* 13 */
	SVt_PVFM,	/* 14 */
	SVt_PVIO	/* 15 */
} svtype;

/* Using C's structural equivalence to help emulate C++ inheritance here... */

struct sv {
    void*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
};

struct gv {
    XPVGV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
};

struct cv {
    XPVCV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
};

struct av {
    XPVAV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
};

struct hv {
    XPVHV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
};

struct io {
    XPVIO*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
};

#define SvANY(sv)	(sv)->sv_any
#define SvFLAGS(sv)	(sv)->sv_flags
#define SvREFCNT(sv)	(sv)->sv_refcnt

#ifdef USE_THREADS

#  ifdef EMULATE_ATOMIC_REFCOUNTS
#    define ATOMIC_INC(count) STMT_START {	\
	MUTEX_LOCK(&PL_svref_mutex);		\
	++count;				\
	MUTEX_UNLOCK(&PL_svref_mutex);		\
     } STMT_END
#    define ATOMIC_DEC_AND_TEST(res,count) STMT_START {	\
	MUTEX_LOCK(&PL_svref_mutex);			\
	res = (--count == 0);				\
	MUTEX_UNLOCK(&PL_svref_mutex);			\
     } STMT_END
#  else
#    define ATOMIC_INC(count) atomic_inc(&count)
#    define ATOMIC_DEC_AND_TEST(res,count) (res = atomic_dec_and_test(&count))
#  endif /* EMULATE_ATOMIC_REFCOUNTS */
#else
#  define ATOMIC_INC(count) (++count)
#  define ATOMIC_DEC_AND_TEST(res, count) (res = (--count == 0))
#endif /* USE_THREADS */

#ifdef __GNUC__
#  define SvREFCNT_inc(sv)		\
    ({					\
	SV *nsv = (SV*)(sv);		\
	if (nsv)			\
	     ATOMIC_INC(SvREFCNT(nsv));	\
	nsv;				\
    })
#else
#  if defined(CRIPPLED_CC) || defined(USE_THREADS)
#    define SvREFCNT_inc(sv) sv_newref((SV*)sv)
#  else
#    define SvREFCNT_inc(sv)	\
	((PL_Sv=(SV*)(sv)), (PL_Sv && ATOMIC_INC(SvREFCNT(PL_Sv))), (SV*)PL_Sv)
#  endif
#endif

#define SvREFCNT_dec(sv)	sv_free((SV*)sv)

#define SVTYPEMASK	0xff
#define SvTYPE(sv)	((sv)->sv_flags & SVTYPEMASK)

#define SvUPGRADE(sv, mt) (SvTYPE(sv) >= mt || sv_upgrade(sv, mt))

#define SVs_PADBUSY	0x00000100	/* reserved for tmp or my already */
#define SVs_PADTMP	0x00000200	/* in use as tmp */
#define SVs_PADMY	0x00000400	/* in use a "my" variable */
#define SVs_TEMP	0x00000800	/* string is stealable? */
#define SVs_OBJECT	0x00001000	/* is "blessed" */
#define SVs_GMG		0x00002000	/* has magical get method */
#define SVs_SMG		0x00004000	/* has magical set method */
#define SVs_RMG		0x00008000	/* has random magical methods */

#define SVf_IOK		0x00010000	/* has valid public integer value */
#define SVf_NOK		0x00020000	/* has valid public numeric value */
#define SVf_POK		0x00040000	/* has valid public pointer value */
#define SVf_ROK		0x00080000	/* has a valid reference pointer */

#define SVf_FAKE	0x00100000	/* glob or lexical is just a copy */
#define SVf_OOK		0x00200000	/* has valid offset value */
#define SVf_BREAK	0x00400000	/* refcnt is artificially low */
#define SVf_READONLY	0x00800000	/* may not be modified */

#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK)

#define SVp_IOK		0x01000000	/* has valid non-public integer value */
#define SVp_NOK		0x02000000	/* has valid non-public numeric value */
#define SVp_POK		0x04000000	/* has valid non-public pointer value */
#define SVp_SCREAM	0x08000000	/* has been studied? */

#define SVf_OK		(SVf_IOK|SVf_NOK|SVf_POK|SVf_ROK| \
			 SVp_IOK|SVp_NOK|SVp_POK)

#ifdef OVERLOAD
#define SVf_AMAGIC    0x10000000      /* has magical overloaded methods */
#else
#define SVf_AMAGIC    0               /* can be or-ed without effect */
#endif /* OVERLOAD */

#define PRIVSHIFT 8

/* Some private flags. */

#define SVpfm_COMPILED	0x80000000

#define SVpbm_VALID	0x80000000
#define SVpbm_TAIL	0x40000000

#define SVphv_SHAREKEYS 0x20000000	/* keys live on shared string table */
#define SVphv_LAZYDEL	0x40000000	/* entry in xhv_eiter must be deleted */

struct xrv {
    SV *	xrv_rv;		/* pointer to another SV */
};

struct xpv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
};

struct xpviv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
};

struct xpvuv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    UV		xuv_uv;		/* unsigned value or pv offset */
};

struct xpvnv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
};

/* These structure must match the beginning of struct xpvhv in hv.h. */
struct xpvmg {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */
};

struct xpvlv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */

    STRLEN	xlv_targoff;
    STRLEN	xlv_targlen;
    SV*		xlv_targ;
    char	xlv_type;
};

struct xpvgv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */

    GP*		xgv_gp;
    char*	xgv_name;
    STRLEN	xgv_namelen;
    HV*		xgv_stash;
    U8		xgv_flags;
};

struct xpvbm {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */

    I32		xbm_useful;	/* is this constant pattern being useful? */
    U16		xbm_previous;	/* how many characters in string before rare? */
    U8		xbm_rare;	/* rarest character in string */
};

/* This structure much match XPVCV */

typedef U16 cv_flags_t;

struct xpvfm {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    OP *	xcv_start;
    OP *	xcv_root;
    void      (*xcv_xsub)_((CV* _CPERLproto));
    ANY		xcv_xsubany;
    GV *	xcv_gv;
    GV *	xcv_filegv;
    long	xcv_depth;		/* >= 2 indicates recursive call */
    AV *	xcv_padlist;
    CV *	xcv_outside;
#ifdef USE_THREADS
    perl_mutex *xcv_mutexp;	/* protects xcv_owner */
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_THREADS */
    cv_flags_t	xcv_flags;

    I32		xfm_lines;
};

struct xpvio {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */

    PerlIO *	xio_ifp;	/* ifp and ofp are normally the same */
    PerlIO *	xio_ofp;	/* but sockets need separate streams */
    DIR *	xio_dirp;	/* for opendir, readdir, etc */
    long	xio_lines;	/* $. */
    long	xio_page;	/* $% */
    long	xio_page_len;	/* $= */
    long	xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    short	xio_subprocess;	/* -| or |- */
    char	xio_type;
    char	xio_flags;
};

#define IOf_ARGV 1	/* this fp iterates over ARGV */
#define IOf_START 2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH 4	/* this fp wants a flush after write op */
#define IOf_DIDTOP 8	/* just did top of form */
#define IOf_UNTAINT 16  /* consider this fp (and its data) "safe" */
#define IOf_NOLINE  32	/* slurped a pseudo-line from empty file */

/* The following macros define implementation-independent predicates on SVs. */

#define SvNIOK(sv)		(SvFLAGS(sv) & (SVf_IOK|SVf_NOK))
#define SvNIOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK))
#define SvNIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK| \
						  SVp_IOK|SVp_NOK))

#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK)
#define SvOK_off(sv)		(SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC),	\
							SvOOK_off(sv))

#define SvOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK))
#define SvIOKp(sv)		(SvFLAGS(sv) & SVp_IOK)
#define SvIOKp_on(sv)		(SvOOK_off(sv), SvFLAGS(sv) |= SVp_IOK)
#define SvNOKp(sv)		(SvFLAGS(sv) & SVp_NOK)
#define SvNOKp_on(sv)		(SvFLAGS(sv) |= SVp_NOK)
#define SvPOKp(sv)		(SvFLAGS(sv) & SVp_POK)
#define SvPOKp_on(sv)		(SvFLAGS(sv) |= SVp_POK)

#define SvIOK(sv)		(SvFLAGS(sv) & SVf_IOK)
#define SvIOK_on(sv)		(SvOOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK))
#define SvIOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvNOK(sv)		(SvFLAGS(sv) & SVf_NOK)
#define SvNOK_on(sv)		(SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
#define SvNOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_NOK|SVp_NOK))
#define SvNOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC),	\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		(SvIOK_off(sv), SvFLAGS(sv) |= SVf_OOK)
#define SvOOK_off(sv)		(SvOOK(sv) && sv_backoff(sv))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK|SVf_AMAGIC))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

#ifdef OVERLOAD
#define SvAMAGIC(sv)         (SvFLAGS(sv) & SVf_AMAGIC)
#define SvAMAGIC_on(sv)      (SvFLAGS(sv) |= SVf_AMAGIC)
#define SvAMAGIC_off(sv)     (SvFLAGS(sv) &= ~SVf_AMAGIC)

/*
#define Gv_AMG(stash) \
        (HV_AMAGICmb(stash) && \
         ((!HV_AMAGICbad(stash) && HV_AMAGIC(stash)) || Gv_AMupdate(stash)))
*/
#define Gv_AMG(stash)           (PL_amagic_generation && Gv_AMupdate(stash))
#endif /* OVERLOAD */

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SvPADBUSY(sv)		(SvFLAGS(sv) & SVs_PADBUSY)

#define SvPADTMP(sv)		(SvFLAGS(sv) & SVs_PADTMP)
#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP|SVs_PADBUSY)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)

#define SvPADMY(sv)		(SvFLAGS(sv) & SVs_PADMY)
#define SvPADMY_on(sv)		(SvFLAGS(sv) |= SVs_PADMY|SVs_PADBUSY)

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

#define SvREADONLY(sv)		(SvFLAGS(sv) & SVf_READONLY)
#define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
#define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)

#define SvSCREAM(sv)		(SvFLAGS(sv) & SVp_SCREAM)
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#define SvCOMPILED(sv)		(SvFLAGS(sv) & SVpfm_COMPILED)
#define SvCOMPILED_on(sv)	(SvFLAGS(sv) |= SVpfm_COMPILED)
#define SvCOMPILED_off(sv)	(SvFLAGS(sv) &= ~SVpfm_COMPILED)

#define SvTAIL(sv)		(SvFLAGS(sv) & SVpbm_TAIL)
#define SvTAIL_on(sv)		(SvFLAGS(sv) |= SVpbm_TAIL)
#define SvTAIL_off(sv)		(SvFLAGS(sv) &= ~SVpbm_TAIL)

#define SvVALID(sv)		(SvFLAGS(sv) & SVpbm_VALID)
#define SvVALID_on(sv)		(SvFLAGS(sv) |= SVpbm_VALID)
#define SvVALID_off(sv)		(SvFLAGS(sv) &= ~SVpbm_VALID)

#define SvRV(sv) ((XRV*)  SvANY(sv))->xrv_rv
#define SvRVx(sv) SvRV(sv)

#define SvIVX(sv) ((XPVIV*)  SvANY(sv))->xiv_iv
#define SvIVXx(sv) SvIVX(sv)
#define SvUVX(sv) ((XPVUV*)  SvANY(sv))->xuv_uv
#define SvUVXx(sv) SvUVX(sv)
#define SvNVX(sv)  ((XPVNV*)SvANY(sv))->xnv_nv
#define SvNVXx(sv) SvNVX(sv)
#define SvPVX(sv)  ((XPV*)  SvANY(sv))->xpv_pv
#define SvPVXx(sv) SvPVX(sv)
#define SvCUR(sv) ((XPV*)  SvANY(sv))->xpv_cur
#define SvLEN(sv) ((XPV*)  SvANY(sv))->xpv_len
#define SvLENx(sv) SvLEN(sv)
#define SvEND(sv)(((XPV*)  SvANY(sv))->xpv_pv + ((XPV*)SvANY(sv))->xpv_cur)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))
#define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_magic
#define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash

#define SvIV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
		(((XPVIV*)  SvANY(sv))->xiv_iv = val); } STMT_END
#define SvNV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) == SVt_NV || SvTYPE(sv) >= SVt_PVNV); \
		(((XPVNV*)  SvANY(sv))->xnv_nv = val); } STMT_END
#define SvPV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(((XPV*)  SvANY(sv))->xpv_pv = val); } STMT_END
#define SvCUR_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(((XPV*)  SvANY(sv))->xpv_cur = val); } STMT_END
#define SvLEN_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(((XPV*)  SvANY(sv))->xpv_len = val); } STMT_END
#define SvEND_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(((XPV*)  SvANY(sv))->xpv_cur = val - SvPVX(sv)); } STMT_END

#define BmRARE(sv)	((XPVBM*)  SvANY(sv))->xbm_rare
#define BmUSEFUL(sv)	((XPVBM*)  SvANY(sv))->xbm_useful
#define BmPREVIOUS(sv)	((XPVBM*)  SvANY(sv))->xbm_previous

#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xfm_lines

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen

#define IoIFP(sv)	((XPVIO*)  SvANY(sv))->xio_ifp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xio_lines
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoSUBPROCESS(sv)((XPVIO*)  SvANY(sv))->xio_subprocess
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

#define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#define SvTAINTED_on(sv)  STMT_START{ if(PL_tainting){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(PL_tainting){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
	if (PL_tainting) {		\
	    dTHR;			\
	    if (PL_tainted)		\
		SvTAINTED_on(sv);	\
	}				\
    } STMT_END

#define SvPV_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPV(sv, lp) sv_pvn(sv, &lp)
#define SvIVx(sv) sv_iv(sv)
#define SvUVx(sv) sv_uv(sv)
#define SvNVx(sv) sv_nv(sv)
#define SvPVx(sv, lp) sv_pvn(sv, &lp)
#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvTRUEx(sv) sv_true(sv)

#define SvIV(sv) SvIVx(sv)
#define SvNV(sv) SvNVx(sv)
#define SvUV(sv) SvIVx(sv)
#define SvTRUE(sv) SvTRUEx(sv)

#ifndef CRIPPLED_CC
/* redefine some things to more efficient inlined versions */

#undef SvIV
#define SvIV(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv))

#undef SvUV
#define SvUV(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))

#undef SvNV
#define SvNV(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv))

#undef SvPV
#define SvPV(sv, lp) \
    (SvPOK(sv) ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))

#undef SvPV_force
#define SvPV_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force(sv, &lp))

#ifdef __GNUC__
#  undef SvIVx
#  undef SvUVx
#  undef SvNVx
#  undef SvPVx
#  undef SvTRUE
#  undef SvTRUEx
#  define SvIVx(sv) ({SV *nsv = (SV*)(sv); SvIV(nsv); })
#  define SvUVx(sv) ({SV *nsv = (SV*)(sv); SvUV(nsv); })
#  define SvNVx(sv) ({SV *nsv = (SV*)(sv); SvNV(nsv); })
#  define SvPVx(sv, lp) ({SV *nsv = (sv); SvPV(nsv, lp); })
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   (({XPV *nxpv = (XPV*)SvANY(sv);			\
	     nxpv &&						\
	     (*nxpv->xpv_pv > '0' ||				\
	      nxpv->xpv_cur > 1 ||				\
	      (nxpv->xpv_cur && *nxpv->xpv_pv != '0')); })	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUEx(sv) ({SV *nsv = (sv); SvTRUE(nsv); })
#else /* __GNUC__ */
#ifndef USE_THREADS
/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  undef SvIVx
#  undef SvUVx
#  undef SvNVx
#  undef SvPVx
#  undef SvTRUE
#  undef SvTRUEx
#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   ((PL_Xpv = (XPV*)SvANY(sv)) &&			\
	     (*PL_Xpv->xpv_pv > '0' ||				\
	      PL_Xpv->xpv_cur > 1 ||				\
	      (PL_Xpv->xpv_cur && *PL_Xpv->xpv_pv != '0'))	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#endif /* !USE_THREADS */
#endif /* !__GNU__ */
#endif /* !CRIPPLED_CC */

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this sv is associated with */

#define SvGETMAGIC(x) STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
#define SvSETMAGIC(x) STMT_START { if (SvSMAGICAL(x)) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
	STMT_START {					\
	    if ((dst) != (src)) {			\
		sv_setsv(dst, src);			\
		finally;				\
	    }						\
	} STMT_END
#define SvSetSV_nosteal_and(dst,src,finally) \
	STMT_START {					\
	    if ((dst) != (src)) {			\
		U32 tMpF = SvFLAGS(src) & SVs_TEMP;	\
		SvTEMP_off(src);			\
		sv_setsv(dst, src);			\
		SvFLAGS(src) |= tMpF;			\
		finally;				\
	    }						\
	} STMT_END

#define SvSetSV(dst,src) \
		SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
		SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))

#define SvPEEK(sv) sv_peek(sv)

#define SvIMMORTAL(sv) ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no)

#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)

#define isGV(sv) (SvTYPE(sv) == SVt_PVGV)

#ifndef DOSISH
#  define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#  define Sv_Grow sv_grow
#else
    /* extra parentheses intentionally NOT placed around "len"! */
#  define SvGROW(sv,len) ((SvLEN(sv) < (unsigned long)len) \
		? sv_grow(sv,(unsigned long)len) : SvPVX(sv))
#  define Sv_Grow(sv,len) sv_grow(sv,(unsigned long)(len))
#endif /* DOSISH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\thrdvar.h ===
/***********************************************/
/* Global only to current thread               */
/***********************************************/

/* Don't forget to re-run embed.pl to propagate changes! */

/* The 'T' prefix is only needed for vars that need appropriate #defines
 * generated when built with or without USE_THREADS.  It is also used
 * to generate the appropriate export list for win32.
 *
 * When building without USE_THREADS, these variables will be truly global.
 * When building without USE_THREADS but with MULTIPLICITY, these variables
 * will be global per-interpreter.
 *
 * Avoid build-specific #ifdefs here, like DEBUGGING.  That way,
 * we can keep binary compatibility of the curinterp structure */

/* Important ones in the first cache line (if alignment is done right) */

PERLVAR(Tstack_sp,	SV **)		/* top of the stack */
#ifdef OP_IN_REGISTER
PERLVAR(Topsave,	OP *)
#else
PERLVAR(Top,		OP *)		/* currently executing op */
#endif
PERLVAR(Tcurpad,	SV **)		/* active pad (lexicals+tmps) */

PERLVAR(Tstack_base,	SV **)
PERLVAR(Tstack_max,	SV **)

PERLVAR(Tscopestack,	I32 *)		/* scopes we've ENTERed */
PERLVAR(Tscopestack_ix,	I32)
PERLVAR(Tscopestack_max,I32)

PERLVAR(Tsavestack,	ANY *)		/* items that need to be restored
					   when LEAVEing scopes we've ENTERed */
PERLVAR(Tsavestack_ix,	I32)
PERLVAR(Tsavestack_max,	I32)

PERLVAR(Ttmps_stack,	SV **)		/* mortals we've made */
PERLVARI(Ttmps_ix,	I32,	-1)
PERLVARI(Ttmps_floor,	I32,	-1)
PERLVAR(Ttmps_max,	I32)

PERLVAR(Tmarkstack,	I32 *)		/* stack_sp locations we're remembering */
PERLVAR(Tmarkstack_ptr,	I32 *)
PERLVAR(Tmarkstack_max,	I32 *)

PERLVAR(Tretstack,	OP **)		/* OPs we have postponed executing */
PERLVAR(Tretstack_ix,	I32)
PERLVAR(Tretstack_max,	I32)

PERLVAR(TSv,		SV *)		/* used to hold temporary values */
PERLVAR(TXpv,		XPV *)		/* used to hold temporary values */

/* stat stuff */
PERLVAR(Tstatbuf,	Stat_t)
PERLVAR(Tstatcache,	Stat_t)		/* _ */
PERLVAR(Tstatgv,	GV *)
PERLVARI(Tstatname,	SV *,	Nullsv)

#ifdef HAS_TIMES
PERLVAR(Ttimesbuf,	struct tms)
#endif

/* Fields used by magic variables such as $@, $/ and so on */
PERLVAR(Ttainted,	bool)		/* using variables controlled by $< */
PERLVAR(Tcurpm,		PMOP *)		/* what to do \ interps in REs from */
PERLVAR(Tnrs,		SV *)
PERLVAR(Trs,		SV *)		/* input record separator $/ */
PERLVAR(Tlast_in_gv,	GV *)		/* GV used in last <FH> */
PERLVAR(Tofs,		char *)		/* output field separator $, */
PERLVAR(Tofslen,	STRLEN)
PERLVAR(Tdefoutgv,	GV *)		/* default FH for output */
PERLVARI(Tchopset,	char *,	" \n-")	/* $: */
PERLVAR(Tformtarget,	SV *)
PERLVAR(Tbodytarget,	SV *)
PERLVAR(Ttoptarget,	SV *)

/* Stashes */
PERLVAR(Tdefstash,	HV *)		/* main symbol table */
PERLVAR(Tcurstash,	HV *)		/* symbol table for current package */

PERLVAR(Trestartop,	OP *)		/* propagating an error from croak? */
PERLVARI(Tcurcop,	COP * VOL,	&PL_compiling)
PERLVAR(Tin_eval,	VOL int)	/* trap "fatal" errors? */
PERLVAR(Tdelaymagic,	int)		/* ($<,$>) = ... */
PERLVAR(Tdirty,		bool)		/* in the middle of tearing things down? */
PERLVAR(Tlocalizing,	int)		/* are we processing a local() list? */

PERLVAR(Tcurstack,	AV *)		/* THE STACK */
PERLVAR(Tcurstackinfo,	PERL_SI *)	/* current stack + context */
PERLVAR(Tmainstack,	AV *)		/* the stack when nothing funny is happening */
PERLVAR(Ttop_env,	JMPENV *)	/* ptr. to current sigjmp() environment */
PERLVAR(Tstart_env,	JMPENV)		/* empty startup sigjmp() environment */

/* statics "owned" by various functions */
PERLVAR(Tav_fetch_sv,	SV *)		/* owned by av_fetch() */
PERLVAR(Thv_fetch_sv,	SV *)		/* owned by hv_fetch() */
PERLVAR(Thv_fetch_ent_mh, HE)		/* owned by hv_fetch_ent() */

PERLVAR(Tmodcount,	I32)		/* how much mod()ification in assignment? */

PERLVAR(Tlastgotoprobe,	OP*)		/* from pp_ctl.c */

/* sort stuff */
PERLVAR(Tsortcop,	OP *)		/* user defined sort routine */
PERLVAR(Tsortstash,	HV *)		/* which is in some package or other */
PERLVAR(Tfirstgv,	GV *)		/* $a */
PERLVAR(Tsecondgv,	GV *)		/* $b */
PERLVAR(Tsortcxix,	I32)		/* from pp_ctl.c */

/* regex stuff */

PERLVAR(Tscreamfirst,	I32 *)
PERLVAR(Tscreamnext,	I32 *)
PERLVARI(Tmaxscream,	I32,	-1)
PERLVAR(Tlastscream,	SV *)

PERLVAR(Tregdummy,	regnode)	/* from regcomp.c */
PERLVAR(Tregcomp_parse,	char*)		/* Input-scan pointer. */
PERLVAR(Tregxend,	char*)		/* End of input for compile */
PERLVAR(Tregcode,	regnode*)	/* Code-emit pointer; &regdummy = don't */
PERLVAR(Tregnaughty,	I32)		/* How bad is this pattern? */
PERLVAR(Tregsawback,	I32)		/* Did we see \1, ...? */
PERLVAR(Tregprecomp,	char *)		/* uncompiled string. */
PERLVAR(Tregnpar,	I32)		/* () count. */
PERLVAR(Tregsize,	I32)		/* Code size. */
PERLVAR(Tregflags,	U16)		/* are we folding, multilining? */
PERLVAR(Tregseen,	U32)		/* from regcomp.c */
PERLVAR(Tseen_zerolen,	I32)		/* from regcomp.c */
PERLVAR(Tseen_evals,	I32)		/* from regcomp.c */
PERLVAR(Tregcomp_rx,	regexp *)	/* from regcomp.c */
PERLVAR(Textralen,	I32)		/* from regcomp.c */
PERLVAR(Tcolorset,	int)		/* from regcomp.c */
PERLVAR(Tcolors[4],	char *)		/* from regcomp.c */
PERLVAR(Treginput,	char *)		/* String-input pointer. */
PERLVAR(Tregbol,	char *)		/* Beginning of input, for ^ check. */
PERLVAR(Tregeol,	char *)		/* End of input, for $ check. */
PERLVAR(Tregstartp,	char **)	/* Pointer to startp array. */
PERLVAR(Tregendp,	char **)	/* Ditto for endp. */
PERLVAR(Treglastparen,	U32 *)		/* Similarly for lastparen. */
PERLVAR(Tregtill,	char *)		/* How far we are required to go. */
PERLVAR(Tregprev,	char)		/* char before regbol, \n if none */
PERLVAR(Treg_start_tmp,	char **)	/* from regexec.c */
PERLVAR(Treg_start_tmpl,U32)		/* from regexec.c */
PERLVAR(Tregdata,	struct reg_data *)
					/* from regexec.c renamed was data */
PERLVAR(Tbostr,		char *)		/* from regexec.c */
PERLVAR(Treg_flags,	U32)		/* from regexec.c */
PERLVAR(Treg_eval_set,	I32)		/* from regexec.c */
PERLVAR(Tregnarrate,	I32)		/* from regexec.c */
PERLVAR(Tregprogram,	regnode *)	/* from regexec.c */
PERLVARI(Tregindent,	int,	    0)	/* from regexec.c */
PERLVAR(Tregcc,		CURCUR *)	/* from regexec.c */

PERLVARI(Tregcompp,	regcomp_t, FUNC_NAME_TO_PTR(pregcomp))
					/* Pointer to RE compiler */
PERLVARI(Tregexecp,	regexec_t, FUNC_NAME_TO_PTR(regexec_flags))
					/* Pointer to RE executer */
PERLVARI(Treginterp_cnt,int,	    0)	/* Whether `Regexp'
						   was interpolated. */


/* Note that the variables below are all explicitly referenced in the code
 * as thr->whatever and therefore don't need the 'T' prefix. */

#ifdef USE_THREADS

PERLVAR(oursv,		SV *)
PERLVAR(cvcache,	HV *)
PERLVAR(self,		perl_os_thread)	/* Underlying thread object */
PERLVAR(flags,		U32)
PERLVAR(threadsv,	AV *)		/* Per-thread SVs ($_, $@ etc.) */
PERLVAR(threadsvp,	SV **)		/* AvARRAY(threadsv) */
PERLVAR(specific,	AV *)		/* Thread-specific user data */
PERLVAR(errsv,		SV *)		/* Backing SV for $@ */
PERLVAR(errhv,		HV *)		/* HV for what was %@ in pp_ctl.c */
PERLVAR(mutex,		perl_mutex)	/* For the fields others can change */
PERLVAR(tid,		U32)
PERLVAR(prev,		struct perl_thread *)
PERLVAR(next,		struct perl_thread *)
					/* Circular linked list of threads */

#ifdef HAVE_THREAD_INTERN
PERLVAR(i,		struct thread_intern)
					/* Platform-dependent internals */
#endif

PERLVAR(trailing_nul,	char)		/* For the sake of thrsv and oursv */

#endif /* USE_THREADS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\unixish.h ===
/*
 * The following symbols are defined if your operating system supports
 * functions by that name.  All Unixes I know of support them, thus they
 * are not checked by the configuration script, but are directly defined
 * here.
 */

/* HAS_IOCTL:
 *	This symbol, if defined, indicates that the ioctl() routine is
 *	available to set I/O characteristics
 */
#define	HAS_IOCTL		/ **/
 
/* HAS_UTIME:
 *	This symbol, if defined, indicates that the routine utime() is
 *	available to update the access and modification times of files.
 */
#define HAS_UTIME		/ **/

/* HAS_GROUP
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
 */
#define HAS_GROUP		/ **/

/* HAS_PASSWD
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
 */
#define HAS_PASSWD		/ **/

#define HAS_KILL
#define HAS_WAIT
  
/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#define Stat_t struct stat

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/ **/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* UNLINK_ALL_VERSIONS:
 *	This symbol, if defined, indicates that the program should arrange
 *	to remove all versions of a file if unlink() is called.  This is
 *	probably only relevant for VMS.
 */
/* #define UNLINK_ALL_VERSIONS		/ **/

/* VMS:
 *	This symbol, if defined, indicates that the program is running under
 *	VMS.  It is currently automatically set by cpps running under VMS,
 *	and is included here for completeness only.
 */
/* #define VMS		/ **/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if if finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
/* #define ALTERNATE_SHEBANG "#!" / **/

#if !defined(NSIG) || defined(M_UNIX) || defined(M_XENIX)  || defined(__NetBSD__)
# include <signal.h>
#endif

#ifndef SIGABRT
#    define SIGABRT SIGILL
#endif
#ifndef SIGILL
#    define SIGILL 6         /* blech */
#endif
#define ABORT() kill(getpid(),SIGABRT);

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define Stat(fname,bufptr) stat((fname),(bufptr))
#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#define Fflush(fp)         fflush(fp)
#define Mkdir(path,mode)   mkdir((path),(mode))

#ifndef PERL_SYS_INIT
#ifdef PERL_SCO5
/* this should be set in a hint file, not here */
#  define PERL_SYS_INIT(c,v)	fpsetmask(0); MALLOC_INIT
#else
#  define PERL_SYS_INIT(c,v)	MALLOC_INIT
#endif
#endif

#ifndef PERL_SYS_TERM
#define PERL_SYS_TERM()		MALLOC_TERM
#endif

#define BIT_BUCKET "/dev/null"

#define dXSUB_SYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\util.h ===
/*    util.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\win32.h ===
/* WIN32.H
 *
 * (c) 1995 Microsoft Corporation. All rights reserved. 
 * 		Developed by hip communications inc., http://info.hip.com/info/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */
#ifndef  _INC_WIN32_PERL5
#define  _INC_WIN32_PERL5

#include "BuildInfo.h"

#ifdef PERL_OBJECT
#  define DYNAMIC_ENV_FETCH
#  define ENV_HV_NAME "___ENV_HV_NAME___"
#  define prime_env_iter()
#  define WIN32IO_IS_STDIO		/* don't pull in custom stdio layer */
#  ifdef PERL_GLOBAL_STRUCT
#    error PERL_GLOBAL_STRUCT cannot be defined with PERL_OBJECT
#  endif
#  define win32_get_privlib PerlEnv_lib_path
#  define win32_get_sitelib PerlEnv_sitelib_path
#endif

#ifdef __GNUC__
typedef long long __int64;
#  define Win32_Winsock
/* GCC does not do __declspec() - render it a nop 
 * and turn on options to avoid importing data 
 */
#ifndef __declspec
#  define __declspec(x)
#endif
#  ifndef PERL_OBJECT
#    define PERL_GLOBAL_STRUCT
#    define MULTIPLICITY
#  endif
#endif

/* Define DllExport akin to perl's EXT, 
 * If we are in the DLL or mimicing the DLL for Win95 work round
 * then Export the symbol, 
 * otherwise import it.
 */

#if defined(PERL_OBJECT)
#define DllExport
#else
#if defined(PERLDLL) || defined(WIN95FIX)
#define DllExport
/*#define DllExport __declspec(dllexport)*/	/* noises with VC5+sp3 */
#else 
#define DllExport __declspec(dllimport)
#endif
#endif

#define  WIN32_LEAN_AND_MEAN
#include <windows.h>

#ifdef   WIN32_LEAN_AND_MEAN		/* C file is NOT a Perl5 original. */
#define  CONTEXT	PERL_CONTEXT	/* Avoid conflict of CONTEXT defs. */
#endif /*WIN32_LEAN_AND_MEAN */

#ifndef TLS_OUT_OF_INDEXES
#define TLS_OUT_OF_INDEXES (DWORD)0xFFFFFFFF
#endif

#include <dirent.h>
#include <io.h>
#include <process.h>
#include <stdio.h>
#include <direct.h>
#include <stdlib.h>
#ifndef EXT
#include "EXTERN.h"
#endif

struct tms {
	long	tms_utime;
	long	tms_stime;
	long	tms_cutime;
	long	tms_cstime;
};

#ifndef SYS_NMLN
#define SYS_NMLN	257
#endif

struct utsname {
    char sysname[SYS_NMLN];
    char nodename[SYS_NMLN];
    char release[SYS_NMLN];
    char version[SYS_NMLN];
    char machine[SYS_NMLN];
};

#ifndef START_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C 
#  define END_EXTERN_C 
#  define EXTERN_C
#endif
#endif

#define  STANDARD_C	1
#define  DOSISH		1		/* no escaping our roots */
#define  OP_BINARY	O_BINARY	/* mistake in in pp_sys.c? */

/* Define USE_SOCKETS_AS_HANDLES to enable emulation of windows sockets as
 * real filehandles. XXX Should always be defined (the other version is untested) */
#define USE_SOCKETS_AS_HANDLES

/* read() and write() aren't transparent for socket handles */
#define PERL_SOCK_SYSREAD_IS_RECV
#define PERL_SOCK_SYSWRITE_IS_SEND


/* if USE_WIN32_RTL_ENV is not defined, Perl uses direct Win32 calls
 * to read the environment, bypassing the runtime's (usually broken)
 * facilities for accessing the same.  See note in util.c/my_setenv(). */
/*#define USE_WIN32_RTL_ENV */

/* Define USE_FIXED_OSFHANDLE to fix VC's _open_osfhandle() on W95.
 * Can only enable it if not using the DLL CRT (it doesn't expose internals) */
#if defined(_MSC_VER) && !defined(_DLL) && defined(_M_IX86)
#define USE_FIXED_OSFHANDLE
#endif

#define ENV_IS_CASELESS

#ifndef VER_PLATFORM_WIN32_WINDOWS	/* VC-2.0 headers don't have this */
#define VER_PLATFORM_WIN32_WINDOWS	1
#endif

#ifndef FILE_SHARE_DELETE		/* VC-4.0 headers don't have this */
#define FILE_SHARE_DELETE		0x00000004
#endif

/* Compiler-specific stuff. */

#ifdef __BORLANDC__		/* Borland C++ */

#define _access access
#define _chdir chdir
#include <sys/types.h>

#ifndef DllMain
#define DllMain DllEntryPoint
#endif

#pragma warn -ccc	/* "condition is always true/false" */
#pragma warn -rch	/* "unreachable code" */
#pragma warn -sig	/* "conversion may lose significant digits" */
#pragma warn -pia	/* "possibly incorrect assignment" */
#pragma warn -par	/* "parameter 'foo' is never used" */
#pragma warn -aus	/* "'foo' is assigned a value that is never used" */
#pragma warn -use	/* "'foo' is declared but never used" */
#pragma warn -csu	/* "comparing signed and unsigned values" */
#pragma warn -pro	/* "call to function with no prototype" */

/* Borland is picky about a bare member function name used as its ptr */
#ifdef PERL_OBJECT
#define FUNC_NAME_TO_PTR(name)	&(name)
#endif

#endif

#ifdef _MSC_VER			/* Microsoft Visual C++ */

typedef long		uid_t;
typedef long		gid_t;
typedef unsigned short	mode_t;
#pragma  warning(disable: 4018 4035 4101 4102 4244 4245 4761)

#ifndef PERL_OBJECT

/* Visual C thinks that a pointer to a member variable is 16 bytes in size. */
#define STRUCT_MGVTBL_DEFINITION					\
struct mgvtbl {								\
    union {								\
	int	    (CPERLscope(*svt_get))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem1[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_set))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem2[16];				\
    };									\
    union {								\
	U32	    (CPERLscope(*svt_len))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem3[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_clear))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem4[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_free))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem5[16];				\
    };									\
}

#define BASEOP_DEFINITION		\
    OP*		op_next;		\
    OP*		op_sibling;		\
    OP*		(CPERLscope(*op_ppaddr))_((ARGSproto));		\
    char	handle_VC_problem[12];	\
    PADOFFSET	op_targ;		\
    OPCODE	op_type;		\
    U16		op_seq;			\
    U8		op_flags;		\
    U8		op_private;

#define UNION_ANY_DEFINITION union any {		\
    void*	any_ptr;				\
    I32		any_i32;				\
    IV		any_iv;					\
    long	any_long;				\
    void	(CPERLscope(*any_dptr)) _((void*));	\
    char	handle_VC_problem[16];			\
}

#endif /* PERL_OBJECT */

#endif /* _MSC_VER */

#ifdef __MINGW32__		/* Minimal Gnu-Win32 */

typedef long		uid_t;
typedef long		gid_t;
#ifndef _environ
#define _environ	environ
#endif
#define flushall	_flushall
#define fcloseall	_fcloseall

#ifdef PERL_OBJECT
#define FUNC_NAME_TO_PTR(name)	&(name)
#endif

#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
#endif

#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
#endif

#endif /* __MINGW32__ */

/* compatibility stuff for other compilers goes here */


START_EXTERN_C

/* For UNIX compatibility. */

extern  uid_t	getuid(void);
extern  gid_t	getgid(void);
extern  uid_t	geteuid(void);
extern  gid_t	getegid(void);
extern  int	setuid(uid_t uid);
extern  int	setgid(gid_t gid);
extern  int	kill(int pid, int sig);
extern  void	*sbrk(int need);
extern	char *	getlogin(void);
extern	int	chown(const char *p, uid_t o, gid_t g);

#undef	 Stat
#define  Stat		win32_stat

#undef   init_os_extras
#define  init_os_extras Perl_init_os_extras

DllExport void		Perl_win32_init(int *argcp, char ***argvp);
DllExport void		Perl_init_os_extras(void);
DllExport void		win32_str_os_error(void *sv, DWORD err);

#ifndef USE_SOCKETS_AS_HANDLES
extern FILE *		my_fdopen(int, char *);
#endif
extern int		my_fclose(FILE *);
extern int		do_aspawn(void *really, void **mark, void **sp);
extern int		do_spawn(char *cmd);
extern int		do_spawn_nowait(char *cmd);
extern char		do_exec(char *cmd);
extern char *		win32_get_privlib(char *pl);
extern char *		win32_get_sitelib(char *pl);
extern int		IsWin95(void);
extern int		IsWinNT(void);

extern char *		staticlinkmodules[];

END_EXTERN_C

typedef  char *		caddr_t;	/* In malloc.c (core address). */

/*
 * handle socket stuff, assuming socket is always available
 */
#include <sys/socket.h>
#include <netdb.h>

#ifdef MYMALLOC
#define EMBEDMYMALLOC	/**/
/* #define USE_PERL_SBRK	/**/
/* #define PERL_SBRK_VIA_MALLOC	/**/
#endif

#if defined(PERLDLL) && !defined(PERL_CORE)
#define PERL_CORE
#endif

#ifdef USE_BINMODE_SCRIPTS
#define PERL_SCRIPT_MODE "rb"
EXT void win32_strip_return(struct sv *sv);
#else
#define PERL_SCRIPT_MODE "r"
#define win32_strip_return(sv) NOOP
#endif

#define HAVE_INTERP_INTERN
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
} child_tab;

struct interp_intern {
    char *	perlshell_tokens;
    char **	perlshell_vec;
    long	perlshell_items;
    struct av *	fdpid;
    child_tab *	children;
    HANDLE	child_handles[MAXIMUM_WAIT_OBJECTS];
};


#define w32_perlshell_tokens	(PL_sys_intern.perlshell_tokens)
#define w32_perlshell_vec	(PL_sys_intern.perlshell_vec)
#define w32_perlshell_items	(PL_sys_intern.perlshell_items)
#define w32_fdpid		(PL_sys_intern.fdpid)
#define w32_children		(PL_sys_intern.children)
#define w32_num_children	(w32_children->num)
#define w32_child_pids		(w32_children->pids)
#define w32_child_handles	(PL_sys_intern.child_handles)

/* 
 * Now Win32 specific per-thread data stuff 
 */

#ifdef USE_THREADS
#  ifndef USE_DECLSPEC_THREAD
#    define HAVE_THREAD_INTERN

struct thread_intern {
    /* XXX can probably use one buffer instead of several */
    char		Wstrerror_buffer[512];
    struct servent	Wservent;
    char		Wgetlogin_buffer[128];
    char		Ww32_perllib_root[MAX_PATH+1];
#    ifdef USE_SOCKETS_AS_HANDLES
    int			Winit_socktype;
#    endif
#    ifdef HAVE_DES_FCRYPT
    char		Wcrypt_buffer[30];
#    endif
#    ifdef USE_RTL_THREAD_API
    void *		retv;	/* slot for thread return value */
#    endif
};
#  endif /* !USE_DECLSPEC_THREAD */
#endif /* USE_THREADS */

#endif /* _INC_WIN32_PERL5 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\win32iop.h ===
#ifndef WIN32IOP_H
#define WIN32IOP_H

#ifndef START_EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C 
#  define END_EXTERN_C 
#  define EXTERN_C
#endif
#endif

#if defined(_MSC_VER) || defined(__MINGW32__)
#  include <sys/utime.h>
#else
#  include <utime.h>
#endif

/*
 * defines for flock emulation
 */
#define LOCK_SH 1
#define LOCK_EX 2
#define LOCK_NB 4
#define LOCK_UN 8

/*
 * Make this as close to original stdio as possible.
 */

/*
 * function prototypes for our own win32io layer
 */
START_EXTERN_C

DllExport  int * 	win32_errno(void);
DllExport  char *** 	win32_environ(void);
DllExport  FILE*	win32_stdin(void);
DllExport  FILE*	win32_stdout(void);
DllExport  FILE*	win32_stderr(void);
DllExport  int		win32_ferror(FILE *fp);
DllExport  int		win32_feof(FILE *fp);
DllExport  char*	win32_strerror(int e);

DllExport  int		win32_fprintf(FILE *pf, const char *format, ...);
DllExport  int		win32_printf(const char *format, ...);
DllExport  int		win32_vfprintf(FILE *pf, const char *format, va_list arg);
DllExport  int		win32_vprintf(const char *format, va_list arg);
DllExport  size_t	win32_fread(void *buf, size_t size, size_t count, FILE *pf);
DllExport  size_t	win32_fwrite(const void *buf, size_t size, size_t count, FILE *pf);
DllExport  FILE*	win32_fopen(const char *path, const char *mode);
DllExport  FILE*	win32_fdopen(int fh, const char *mode);
DllExport  FILE*	win32_freopen(const char *path, const char *mode, FILE *pf);
DllExport  int		win32_fclose(FILE *pf);
DllExport  int		win32_fputs(const char *s,FILE *pf);
DllExport  int		win32_fputc(int c,FILE *pf);
DllExport  int		win32_ungetc(int c,FILE *pf);
DllExport  int		win32_getc(FILE *pf);
DllExport  int		win32_fileno(FILE *pf);
DllExport  void		win32_clearerr(FILE *pf);
DllExport  int		win32_fflush(FILE *pf);
DllExport  long		win32_ftell(FILE *pf);
DllExport  int		win32_fseek(FILE *pf,long offset,int origin);
DllExport  int		win32_fgetpos(FILE *pf,fpos_t *p);
DllExport  int		win32_fsetpos(FILE *pf,const fpos_t *p);
DllExport  void		win32_rewind(FILE *pf);
DllExport  FILE*	win32_tmpfile(void);
DllExport  void		win32_abort(void);
DllExport  int  	win32_fstat(int fd,struct stat *sbufptr);
DllExport  int  	win32_stat(const char *name,struct stat *sbufptr);
DllExport  int		win32_pipe( int *phandles, unsigned int psize, int textmode );
DllExport  FILE*	win32_popen( const char *command, const char *mode );
DllExport  int		win32_pclose( FILE *pf);
DllExport  int		win32_rename( const char *oname, const char *newname);
DllExport  int		win32_setmode( int fd, int mode);
DllExport  long		win32_lseek( int fd, long offset, int origin);
DllExport  long		win32_tell( int fd);
DllExport  int		win32_dup( int fd);
DllExport  int		win32_dup2(int h1, int h2);
DllExport  int		win32_open(const char *path, int oflag,...);
DllExport  int		win32_close(int fd);
DllExport  int		win32_eof(int fd);
DllExport  int		win32_read(int fd, void *buf, unsigned int cnt);
DllExport  int		win32_write(int fd, const void *buf, unsigned int cnt);
DllExport  int		win32_spawnvp(int mode, const char *cmdname,
			      const char *const *argv);
DllExport  int		win32_mkdir(const char *dir, int mode);
DllExport  int		win32_rmdir(const char *dir);
DllExport  int		win32_chdir(const char *dir);
DllExport  int		win32_flock(int fd, int oper);
DllExport  int		win32_execv(const char *cmdname, const char *const *argv);
DllExport  int		win32_execvp(const char *cmdname, const char *const *argv);
DllExport  void		win32_perror(const char *str);
DllExport  void		win32_setbuf(FILE *pf, char *buf);
DllExport  int		win32_setvbuf(FILE *pf, char *buf, int type, size_t size);
DllExport  int		win32_flushall(void);
DllExport  int		win32_fcloseall(void);
DllExport  char*	win32_fgets(char *s, int n, FILE *pf);
DllExport  char*	win32_gets(char *s);
DllExport  int		win32_fgetc(FILE *pf);
DllExport  int		win32_putc(int c, FILE *pf);
DllExport  int		win32_puts(const char *s);
DllExport  int		win32_getchar(void);
DllExport  int		win32_putchar(int c);
DllExport  void*	win32_malloc(size_t size);
DllExport  void*	win32_calloc(size_t numitems, size_t size);
DllExport  void*	win32_realloc(void *block, size_t size);
DllExport  void		win32_free(void *block);

DllExport  int		win32_open_osfhandle(long handle, int flags);
DllExport  long		win32_get_osfhandle(int fd);

#ifndef USE_WIN32_RTL_ENV
DllExport  char*	win32_getenv(const char *name);
DllExport  int		win32_putenv(const char *name);
#endif

DllExport  unsigned 	win32_sleep(unsigned int);
DllExport  int		win32_times(struct tms *timebuf);
DllExport  unsigned 	win32_alarm(unsigned int sec);
DllExport  int		win32_stat(const char *path, struct stat *buf);
DllExport  char*	win32_longpath(char *path);
DllExport  int		win32_ioctl(int i, unsigned int u, char *data);
DllExport  int		win32_utime(const char *f, struct utimbuf *t);
DllExport  int		win32_uname(struct utsname *n);
DllExport  int		win32_wait(int *status);
DllExport  int		win32_waitpid(int pid, int *status, int flags);
DllExport  int		win32_kill(int pid, int sig);

#if defined(HAVE_DES_FCRYPT) || defined(PERL_OBJECT)
DllExport char *	win32_crypt(const char *txt, const char *salt);
#endif

END_EXTERN_C

/*
 * the following six(6) is #define in stdio.h
 */
#ifndef WIN32IO_IS_STDIO
#undef errno
#undef environ
#undef stderr
#undef stdin
#undef stdout
#undef ferror
#undef feof
#undef fclose
#undef pipe
#undef pause
#undef sleep
#undef times
#undef alarm
#undef ioctl
#undef utime
#undef uname
#undef wait

#ifdef __BORLANDC__
#undef ungetc
#undef getc
#undef putc
#undef getchar
#undef putchar
#undef fileno
#endif

#define stderr				win32_stderr()
#define stdout				win32_stdout()
#define	stdin				win32_stdin()
#define feof(f)				win32_feof(f)
#define ferror(f)			win32_ferror(f)
#define errno 				(*win32_errno())
#define environ				(*win32_environ())
#define strerror			win32_strerror

/*
 * redirect to our own version
 */
#undef fprintf
#define	fprintf			win32_fprintf
#define	vfprintf		win32_vfprintf
#define	printf			win32_printf
#define	vprintf			win32_vprintf
#define fread(buf,size,count,f)	win32_fread(buf,size,count,f)
#define fwrite(buf,size,count,f)	win32_fwrite(buf,size,count,f)
#define fopen			win32_fopen
#undef fdopen
#define fdopen			win32_fdopen
#define freopen			win32_freopen
#define	fclose(f)		win32_fclose(f)
#define fputs(s,f)		win32_fputs(s,f)
#define fputc(c,f)		win32_fputc(c,f)
#define ungetc(c,f)		win32_ungetc(c,f)
#undef getc
#define getc(f)			win32_getc(f)
#define fileno(f)		win32_fileno(f)
#define clearerr(f)		win32_clearerr(f)
#define fflush(f)		win32_fflush(f)
#define ftell(f)		win32_ftell(f)
#define fseek(f,o,w)		win32_fseek(f,o,w)
#define fgetpos(f,p)		win32_fgetpos(f,p)
#define fsetpos(f,p)		win32_fsetpos(f,p)
#define rewind(f)		win32_rewind(f)
#define tmpfile()		win32_tmpfile()
#define abort()			win32_abort()
#define fstat(fd,bufptr)   	win32_fstat(fd,bufptr)
#define stat(pth,bufptr)   	win32_stat(pth,bufptr)
#define longpath(pth)   	win32_longpath(pth)
#define rename(old,new)		win32_rename(old,new)
#define setmode(fd,mode)	win32_setmode(fd,mode)
#define lseek(fd,offset,orig)	win32_lseek(fd,offset,orig)
#define tell(fd)		win32_tell(fd)
#define dup(fd)			win32_dup(fd)
#define dup2(fd1,fd2)		win32_dup2(fd1,fd2)
#define open			win32_open
#define close(fd)		win32_close(fd)
#define eof(fd)			win32_eof(fd)
#define read(fd,b,s)		win32_read(fd,b,s)
#define write(fd,b,s)		win32_write(fd,b,s)
#define _open_osfhandle		win32_open_osfhandle
#define _get_osfhandle		win32_get_osfhandle
#define spawnvp			win32_spawnvp
#define mkdir			win32_mkdir
#define rmdir			win32_rmdir
#define chdir			win32_chdir
#define flock(fd,o)		win32_flock(fd,o)
#define execv			win32_execv
#define execvp			win32_execvp
#define perror			win32_perror
#define setbuf			win32_setbuf
#define setvbuf			win32_setvbuf
#undef flushall
#define flushall		win32_flushall
#undef fcloseall
#define fcloseall		win32_fcloseall
#define fgets			win32_fgets
#define gets			win32_gets
#define fgetc			win32_fgetc
#undef putc
#define putc			win32_putc
#define puts			win32_puts
#undef getchar
#define getchar			win32_getchar
#undef putchar
#define putchar			win32_putchar

#if !defined(MYMALLOC) || !defined(PERL_CORE)
#undef malloc
#undef calloc
#undef realloc
#undef free
#define malloc			win32_malloc
#define calloc			win32_calloc
#define realloc			win32_realloc
#define free			win32_free
#endif

#define pipe(fd)		win32_pipe((fd), 512, O_BINARY)
#define pause()			win32_sleep((32767L << 16) + 32767)
#define sleep			win32_sleep
#define times			win32_times
#define alarm			win32_alarm
#define ioctl			win32_ioctl
#define utime			win32_utime
#define uname			win32_uname
#define wait			win32_wait
#define waitpid			win32_waitpid
#define kill			win32_kill

#define opendir			win32_opendir
#define readdir			win32_readdir
#define telldir			win32_telldir
#define seekdir			win32_seekdir
#define rewinddir		win32_rewinddir
#define closedir		win32_closedir

#ifdef HAVE_DES_FCRYPT
#undef crypt
#define crypt			win32_crypt
#endif

#ifndef USE_WIN32_RTL_ENV
#undef getenv
#define getenv win32_getenv
#undef putenv
#define putenv win32_putenv
#endif

#endif /* WIN32IO_IS_STDIO */
#endif /* WIN32IOP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\arpa\inet.h ===
/* 
 * this is a dummy header file for Socket.xs 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\xslock.h ===
#ifndef __XSlock_h__
#define __XSlock_h__

class XSLockManager
{
public:
	XSLockManager() { InitializeCriticalSection(&cs); };
	~XSLockManager() { DeleteCriticalSection(&cs); };
	void Enter(void) { EnterCriticalSection(&cs); };
	void Leave(void) { LeaveCriticalSection(&cs); };
protected:
	CRITICAL_SECTION cs;
};

XSLockManager g_XSLock;
CPerlObj* pPerl;

class XSLock
{
public:
	XSLock(CPerlObj *p) {
	    g_XSLock.Enter();
	    ::pPerl = p;
	};
	~XSLock() { g_XSLock.Leave(); };
};

/* PERL_CAPI does its own locking in xs_handler() */
#if defined(PERL_OBJECT) && !defined(PERL_CAPI)
#undef dXSARGS
#define dXSARGS	\
	XSLock localLock(pPerl);			\
	dSP; dMARK;					\
	I32 ax = mark - PL_stack_base + 1;		\
	I32 items = sp - mark
#endif	/* PERL_OBJECT && !PERL_CAPI */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\sys\socket.h ===
// sys/socket.h

// djl
// Provide UNIX compatibility

#ifndef  _INC_SYS_SOCKET
#define  _INC_SYS_SOCKET

#ifdef __cplusplus
extern "C" {
#endif

#ifndef  _WINDOWS_
#ifdef   __GNUC__
#define WIN32_LEAN_AND_MEAN
#ifdef __GNUC__
#define Win32_Winsock
#endif
#include <windows.h>
#else
#define  _WINDOWS_

#define  FAR
#define  PASCAL     __stdcall
#define  WINAPI     __stdcall

#undef WORD
typedef  int        BOOL;
typedef  unsigned short WORD;
typedef  void*      HANDLE;
typedef  void*      HWND;
typedef  int (FAR WINAPI *FARPROC)();

typedef unsigned long       DWORD;
typedef void *PVOID;

#define IN
#define OUT

typedef struct _OVERLAPPED {
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

#endif
#endif //_WINDOWS_
#ifndef __GNUC__
#include <winsock.h>
#endif

#define  ENOTSOCK	WSAENOTSOCK
#undef   HOST_NOT_FOUND

#ifdef USE_SOCKETS_AS_HANDLES

#ifndef PERL_FD_SETSIZE
#define PERL_FD_SETSIZE		64
#endif

#define PERL_BITS_PER_BYTE	8
#define	PERL_NFDBITS		(sizeof(Perl_fd_mask)*PERL_BITS_PER_BYTE)

typedef int			Perl_fd_mask;

typedef struct	Perl_fd_set {
    Perl_fd_mask bits[(PERL_FD_SETSIZE+PERL_NFDBITS-1)/PERL_NFDBITS];
}				Perl_fd_set;

#define PERL_FD_CLR(n,p) \
    ((p)->bits[(n)/PERL_NFDBITS] &= ~((unsigned)1 << ((n)%PERL_NFDBITS)))

#define PERL_FD_SET(n,p) \
    ((p)->bits[(n)/PERL_NFDBITS] |=  ((unsigned)1 << ((n)%PERL_NFDBITS)))

#define PERL_FD_ZERO(p) memset((char *)(p),0,sizeof(*(p)))

#define PERL_FD_ISSET(n,p) \
    ((p)->bits[(n)/PERL_NFDBITS] &   ((unsigned)1 << ((n)%PERL_NFDBITS)))

#else	/* USE_SOCKETS_AS_HANDLES */

#define Perl_fd_set	fd_set
#define PERL_FD_SET(n,p)	FD_SET(n,p)
#define PERL_FD_CLR(n,p)	FD_CLR(n,p)
#define PERL_FD_ISSET(n,p)	FD_ISSET(n,p)
#define PERL_FD_ZERO(p)		FD_ZERO(p)

#endif	/* USE_SOCKETS_AS_HANDLES */

SOCKET win32_accept (SOCKET s, struct sockaddr *addr, int *addrlen);
int win32_bind (SOCKET s, const struct sockaddr *addr, int namelen);
int win32_closesocket (SOCKET s);
int win32_connect (SOCKET s, const struct sockaddr *name, int namelen);
int win32_ioctlsocket (SOCKET s, long cmd, u_long *argp);
int win32_getpeername (SOCKET s, struct sockaddr *name, int * namelen);
int win32_getsockname (SOCKET s, struct sockaddr *name, int * namelen);
int win32_getsockopt (SOCKET s, int level, int optname, char * optval, int *optlen);
u_long win32_htonl (u_long hostlong);
u_short win32_htons (u_short hostshort);
unsigned long win32_inet_addr (const char * cp);
char * win32_inet_ntoa (struct in_addr in);
int win32_listen (SOCKET s, int backlog);
u_long win32_ntohl (u_long netlong);
u_short win32_ntohs (u_short netshort);
int win32_recv (SOCKET s, char * buf, int len, int flags);
int win32_recvfrom (SOCKET s, char * buf, int len, int flags,
                         struct sockaddr *from, int * fromlen);
int win32_select (int nfds, Perl_fd_set *rfds, Perl_fd_set *wfds, Perl_fd_set *xfds,
		  const struct timeval *timeout);
int win32_send (SOCKET s, const char * buf, int len, int flags);
int win32_sendto (SOCKET s, const char * buf, int len, int flags,
                       const struct sockaddr *to, int tolen);
int win32_setsockopt (SOCKET s, int level, int optname,
                           const char * optval, int optlen);
SOCKET win32_socket (int af, int type, int protocol);
int win32_shutdown (SOCKET s, int how);

/* Database function prototypes */

struct hostent * win32_gethostbyaddr(const char * addr, int len, int type);
struct hostent * win32_gethostbyname(const char * name);
int win32_gethostname (char * name, int namelen);
struct servent * win32_getservbyport(int port, const char * proto);
struct servent * win32_getservbyname(const char * name, const char * proto);
struct protoent * win32_getprotobynumber(int proto);
struct protoent * win32_getprotobyname(const char * name);
struct protoent *win32_getprotoent(void);
struct servent *win32_getservent(void);
void win32_sethostent(int stayopen);
void win32_setnetent(int stayopen);
struct netent * win32_getnetent(void);
struct netent * win32_getnetbyname(char *name);
struct netent * win32_getnetbyaddr(long net, int type);
void win32_setprotoent(int stayopen);
void win32_setservent(int stayopen);
void win32_endhostent(void);
void win32_endnetent(void);
void win32_endprotoent(void);
void win32_endservent(void);

#ifndef WIN32SCK_IS_STDSCK
#ifndef PERL_OBJECT
//
// direct to our version
//
#define htonl		win32_htonl
#define htons		win32_htons
#define ntohl		win32_ntohl
#define ntohs		win32_ntohs
#define inet_addr	win32_inet_addr
#define inet_ntoa	win32_inet_ntoa

#define socket		win32_socket
#define bind		win32_bind
#define listen		win32_listen
#define accept		win32_accept
#define connect		win32_connect
#define send		win32_send
#define sendto		win32_sendto
#define recv		win32_recv
#define recvfrom	win32_recvfrom
#define shutdown	win32_shutdown
#define closesocket	win32_closesocket
#define ioctlsocket	win32_ioctlsocket
#define setsockopt	win32_setsockopt
#define getsockopt	win32_getsockopt
#define getpeername	win32_getpeername
#define getsockname	win32_getsockname
#define gethostname	win32_gethostname
#define gethostbyname	win32_gethostbyname
#define gethostbyaddr	win32_gethostbyaddr
#define getprotobyname	win32_getprotobyname
#define getprotobynumber win32_getprotobynumber
#define getservbyname	win32_getservbyname
#define getservbyport	win32_getservbyport
#define select		win32_select
#define endhostent	win32_endhostent
#define endnetent	win32_endnetent
#define endprotoent	win32_endprotoent
#define endservent	win32_endservent
#define getnetent	win32_getnetent
#define getnetbyname	win32_getnetbyname
#define getnetbyaddr	win32_getnetbyaddr
#define getprotoent	win32_getprotoent
#define getservent	win32_getservent
#define sethostent	win32_sethostent
#define setnetent	win32_setnetent
#define setprotoent	win32_setprotoent
#define setservent	win32_setservent

#ifdef USE_SOCKETS_AS_HANDLES
#undef fd_set
#undef FD_SET
#undef FD_CLR
#undef FD_ISSET
#undef FD_ZERO
#define fd_set		Perl_fd_set
#define FD_SET(n,p)	PERL_FD_SET(n,p)
#define FD_CLR(n,p)	PERL_FD_CLR(n,p)
#define FD_ISSET(n,p)	PERL_FD_ISSET(n,p)
#define FD_ZERO(p)	PERL_FD_ZERO(p)
#endif	/* USE_SOCKETS_AS_HANDLES */

#endif  /* PERL_OBJECT */
#endif	/* WIN32SCK_IS_STDSCK */

#ifdef __cplusplus
}
#endif

#endif	// _INC_SYS_SOCKET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\xsub.h ===
#define ST(off) PL_stack_base[ax + (off)]

#ifdef CAN_PROTOTYPE
#ifdef PERL_OBJECT
#define XS(name) void name(CV* cv, CPerlObj* pPerl)
#else
#define XS(name) void name(CV* cv)
#endif
#else
#define XS(name) void name(cv) CV* cv;
#endif

#define dXSARGS				\
	dSP; dMARK;			\
	I32 ax = mark - PL_stack_base + 1;	\
	I32 items = sp - mark

#define XSANY CvXSUBANY(cv)

#define dXSI32 I32 ix = XSANY.any_i32

#ifdef __cplusplus
#  define XSINTERFACE_CVT(ret,name) ret (*name)(...)
#else
#  define XSINTERFACE_CVT(ret,name) ret (*name)()
#endif
#define dXSFUNCTION(ret)		XSINTERFACE_CVT(ret,XSFUNCTION)
#define XSINTERFACE_FUNC(ret,cv,f)	((XSINTERFACE_CVT(ret,))(f))
#define XSINTERFACE_FUNC_SET(cv,f)	\
		CvXSUBANY(cv).any_dptr = (void (*) _((void*)))(f)

#define XSRETURN(off)					\
    STMT_START {					\
	PL_stack_sp = PL_stack_base + ax + ((off) - 1);	\
	return;						\
    } STMT_END

/* Simple macros to put new mortal values onto the stack.   */
/* Typically used to return values from XS functions.       */
#define XST_mIV(i,v)  (ST(i) = sv_2mortal(newSViv(v))  )
#define XST_mNV(i,v)  (ST(i) = sv_2mortal(newSVnv(v))  )
#define XST_mPV(i,v)  (ST(i) = sv_2mortal(newSVpv(v,0)))
#define XST_mNO(i)    (ST(i) = &PL_sv_no   )
#define XST_mYES(i)   (ST(i) = &PL_sv_yes  )
#define XST_mUNDEF(i) (ST(i) = &PL_sv_undef)
 
#define XSRETURN_IV(v) STMT_START { XST_mIV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_NV(v) STMT_START { XST_mNV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_PV(v) STMT_START { XST_mPV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_NO    STMT_START { XST_mNO(0);    XSRETURN(1); } STMT_END
#define XSRETURN_YES   STMT_START { XST_mYES(0);   XSRETURN(1); } STMT_END
#define XSRETURN_UNDEF STMT_START { XST_mUNDEF(0); XSRETURN(1); } STMT_END
#define XSRETURN_EMPTY STMT_START {                XSRETURN(0); } STMT_END

#define newXSproto(a,b,c,d)	sv_setpv((SV*)newXS(a,b,c), d)

#ifdef XS_VERSION
# define XS_VERSION_BOOTCHECK \
    STMT_START {							\
	SV *tmpsv; STRLEN n_a;						\
	char *vn = Nullch, *module = SvPV(ST(0),n_a);			\
	if (items >= 2)	 /* version supplied as bootstrap arg */	\
	    tmpsv = ST(1);						\
	else {								\
	    /* XXX GV_ADDWARN */					\
	    tmpsv = perl_get_sv(form("%s::%s", module,			\
				  vn = "XS_VERSION"), FALSE);		\
	    if (!tmpsv || !SvOK(tmpsv))					\
		tmpsv = perl_get_sv(form("%s::%s", module,		\
				      vn = "VERSION"), FALSE);		\
	}								\
	if (tmpsv && (!SvOK(tmpsv) || strNE(XS_VERSION, SvPV(tmpsv, n_a))))	\
	    croak("%s object version %s does not match %s%s%s%s %_",	\
		  module, XS_VERSION,					\
		  vn ? "$" : "", vn ? module : "", vn ? "::" : "",	\
		  vn ? vn : "bootstrap parameter", tmpsv);		\
    } STMT_END
#else
# define XS_VERSION_BOOTCHECK
#endif

#ifdef PERL_CAPI
#  define VTBL_sv		get_vtbl(want_vtbl_sv)
#  define VTBL_env		get_vtbl(want_vtbl_env)
#  define VTBL_envelem		get_vtbl(want_vtbl_envelem)
#  define VTBL_sig		get_vtbl(want_vtbl_sig)
#  define VTBL_sigelem		get_vtbl(want_vtbl_sigelem)
#  define VTBL_pack		get_vtbl(want_vtbl_pack)
#  define VTBL_packelem		get_vtbl(want_vtbl_packelem)
#  define VTBL_dbline		get_vtbl(want_vtbl_dbline)
#  define VTBL_isa		get_vtbl(want_vtbl_isa)
#  define VTBL_isaelem		get_vtbl(want_vtbl_isaelem)
#  define VTBL_arylen		get_vtbl(want_vtbl_arylen)
#  define VTBL_glob		get_vtbl(want_vtbl_glob)
#  define VTBL_mglob		get_vtbl(want_vtbl_mglob)
#  define VTBL_nkeys		get_vtbl(want_vtbl_nkeys)
#  define VTBL_taint		get_vtbl(want_vtbl_taint)
#  define VTBL_substr		get_vtbl(want_vtbl_substr)
#  define VTBL_vec		get_vtbl(want_vtbl_vec)
#  define VTBL_pos		get_vtbl(want_vtbl_pos)
#  define VTBL_bm		get_vtbl(want_vtbl_bm)
#  define VTBL_fm		get_vtbl(want_vtbl_fm)
#  define VTBL_uvar		get_vtbl(want_vtbl_uvar)
#  define VTBL_defelem		get_vtbl(want_vtbl_defelem)
#  define VTBL_regexp		get_vtbl(want_vtbl_regexp)
#  ifdef USE_LOCALE_COLLATE
#    define VTBL_collxfrm	get_vtbl(want_vtbl_collxfrm)
#  endif
#  ifdef OVERLOAD
#    define VTBL_amagic		get_vtbl(want_vtbl_amagic)
#    define VTBL_amagicelem	get_vtbl(want_vtbl_amagicelem)
#  endif
#else
#  define VTBL_sv		&vtbl_sv
#  define VTBL_env		&vtbl_env
#  define VTBL_envelem		&vtbl_envelem
#  define VTBL_sig		&vtbl_sig
#  define VTBL_sigelem		&vtbl_sigelem
#  define VTBL_pack		&vtbl_pack
#  define VTBL_packelem		&vtbl_packelem
#  define VTBL_dbline		&vtbl_dbline
#  define VTBL_isa		&vtbl_isa
#  define VTBL_isaelem		&vtbl_isaelem
#  define VTBL_arylen		&vtbl_arylen
#  define VTBL_glob		&vtbl_glob
#  define VTBL_mglob		&vtbl_mglob
#  define VTBL_nkeys		&vtbl_nkeys
#  define VTBL_taint		&vtbl_taint
#  define VTBL_substr		&vtbl_substr
#  define VTBL_vec		&vtbl_vec
#  define VTBL_pos		&vtbl_pos
#  define VTBL_bm		&vtbl_bm
#  define VTBL_fm		&vtbl_fm
#  define VTBL_uvar		&vtbl_uvar
#  define VTBL_defelem		&vtbl_defelem
#  define VTBL_regexp		&vtbl_regexp
#  ifdef USE_LOCALE_COLLATE
#    define VTBL_collxfrm	&vtbl_collxfrm
#  endif
#  ifdef OVERLOAD
#    define VTBL_amagic		&vtbl_amagic
#    define VTBL_amagicelem	&vtbl_amagicelem
#  endif
#endif

#ifdef PERL_OBJECT
#include "objXSUB.h"
#ifndef NO_XSLOCKS
#ifdef WIN32
#include "XSlock.h"
#endif  /* WIN32 */
#endif  /* NO_XSLOCKS */
#else
#ifdef PERL_CAPI
#include "perlCAPI.h"
#endif
#endif	/* PERL_OBJECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\win32thread.h ===
#ifndef _WIN32THREAD_H
#define _WIN32THREAD_H
typedef struct win32_cond { LONG waiters; HANDLE sem; } perl_cond;
typedef DWORD perl_key;
typedef HANDLE perl_os_thread;

#ifndef DONT_USE_CRITICAL_SECTION

/* Critical Sections used instead of mutexes: lightweight,
 * but can't be communicated to child processes, and can't get
 * HANDLE to it for use elsewhere.
 */
typedef CRITICAL_SECTION perl_mutex;
#define MUTEX_INIT(m) InitializeCriticalSection(m)
#define MUTEX_LOCK(m) EnterCriticalSection(m)
#define MUTEX_UNLOCK(m) LeaveCriticalSection(m)
#define MUTEX_DESTROY(m) DeleteCriticalSection(m)

#else

typedef HANDLE perl_mutex;
#define MUTEX_INIT(m) \
    STMT_START {						\
	if ((*(m) = CreateMutex(NULL,FALSE,NULL)) == NULL)	\
	    croak("panic: MUTEX_INIT");				\
    } STMT_END
#define MUTEX_LOCK(m) \
    STMT_START {						\
	if (WaitForSingleObject(*(m),INFINITE) == WAIT_FAILED)	\
	    croak("panic: MUTEX_LOCK");				\
    } STMT_END
#define MUTEX_UNLOCK(m) \
    STMT_START {						\
	if (ReleaseMutex(*(m)) == 0)				\
	    croak("panic: MUTEX_UNLOCK");			\
    } STMT_END
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	if (CloseHandle(*(m)) == 0)				\
	    croak("panic: MUTEX_DESTROY");			\
    } STMT_END

#endif

/* These macros assume that the mutex associated with the condition
 * will always be held before COND_{SIGNAL,BROADCAST,WAIT,DESTROY},
 * so there's no separate mutex protecting access to (c)->waiters
 */
#define COND_INIT(c) \
    STMT_START {						\
	(c)->waiters = 0;					\
	(c)->sem = CreateSemaphore(NULL,0,LONG_MAX,NULL);	\
	if ((c)->sem == NULL)					\
	    croak("panic: COND_INIT (%ld)",GetLastError());	\
    } STMT_END

#define COND_SIGNAL(c) \
    STMT_START {						\
	if ((c)->waiters > 0 &&					\
	    ReleaseSemaphore((c)->sem,1,NULL) == 0)		\
	    croak("panic: COND_SIGNAL (%ld)",GetLastError());	\
    } STMT_END

#define COND_BROADCAST(c) \
    STMT_START {						\
	if ((c)->waiters > 0 &&					\
	    ReleaseSemaphore((c)->sem,(c)->waiters,NULL) == 0)	\
	    croak("panic: COND_BROADCAST (%ld)",GetLastError());\
    } STMT_END

#define COND_WAIT(c, m) \
    STMT_START {						\
	(c)->waiters++;						\
	MUTEX_UNLOCK(m);					\
	/* Note that there's no race here, since a		\
	 * COND_BROADCAST() on another thread will have seen the\
	 * right number of waiters (i.e. including this one) */	\
	if (WaitForSingleObject((c)->sem,INFINITE)==WAIT_FAILED)\
	    croak("panic: COND_WAIT (%ld)",GetLastError());	\
	/* XXX there may be an inconsequential race here */	\
	MUTEX_LOCK(m);						\
	(c)->waiters--;						\
    } STMT_END

#define COND_DESTROY(c) \
    STMT_START {						\
	(c)->waiters = 0;					\
	if (CloseHandle((c)->sem) == 0)				\
	    croak("panic: COND_DESTROY (%ld)",GetLastError());	\
    } STMT_END

#define DETACH(t) \
    STMT_START {						\
	if (CloseHandle((t)->self) == 0) {			\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    croak("panic: DETACH");				\
	}							\
    } STMT_END


#define THREAD_CREATE(t, f)	Perl_thread_create(t, f)
#define THREAD_POST_CREATE(t)	NOOP

/* XXX Docs mention that the RTL versions of thread creation routines
 * should be used, but that advice only seems applicable when the RTL
 * is not in a DLL.  RTL DLLs in both Borland and VC seem to do all of
 * the init/deinit required upon DLL_THREAD_ATTACH/DETACH.  So we seem
 * to be completely safe using straight Win32 API calls, rather than
 * the RTL calls.
 *
 * _beginthread() in the RTLs call CloseHandle() just after the thread
 * function returns, which means: 1) we have a race on our hands
 * 2) it is impossible to implement join() semantics.
 *
 * IOW, do *NOT* turn on USE_RTL_THREAD_API!  It is here
 * for experimental purposes only. GSAR 98-01-02
 */
#ifdef USE_RTL_THREAD_API
#  include <process.h>
#  if defined(__BORLANDC__)
     /* Borland RTL doesn't allow a return value from thread function! */
#    define THREAD_RET_TYPE	void _USERENTRY
#    define THREAD_RET_CAST(p)	((void)(thr->i.retv = (void *)(p)))
#  elif defined (_MSC_VER)
#    define THREAD_RET_TYPE	unsigned __stdcall
#    define THREAD_RET_CAST(p)	((unsigned)(p))
#  else
     /* CRTDLL.DLL doesn't allow a return value from thread function! */
#    define THREAD_RET_TYPE	void __cdecl
#    define THREAD_RET_CAST(p)	((void)(thr->i.retv = (void *)(p)))
#  endif
#else	/* !USE_RTL_THREAD_API */
#  define THREAD_RET_TYPE	DWORD WINAPI
#  define THREAD_RET_CAST(p)	((DWORD)(p))
#endif	/* !USE_RTL_THREAD_API */

typedef THREAD_RET_TYPE thread_func_t(void *);


START_EXTERN_C

#if defined(PERLDLL) && defined(USE_DECLSPEC_THREAD) && (!defined(__BORLANDC__) || defined(_DLL))
extern __declspec(thread) struct perl_thread *Perl_current_thread;
#define SET_THR(t)   		(Perl_current_thread = t)
#define THR			Perl_current_thread
#else
#define THR			Perl_getTHR()
#define SET_THR(t)		Perl_setTHR(t)
#endif
struct perl_thread;

void Perl_alloc_thread_key _((void));
int Perl_thread_create _((struct perl_thread *thr, thread_func_t *fn));
void Perl_set_thread_self _((struct perl_thread *thr));
struct perl_thread *Perl_getTHR _((void));
void Perl_setTHR _((struct perl_thread *t));
void Perl_init_thread_intern _((struct perl_thread *t));

END_EXTERN_C

#define INIT_THREADS NOOP
#define ALLOC_THREAD_KEY Perl_alloc_thread_key()
#define SET_THREAD_SELF(thr) Perl_set_thread_self(thr)

#if defined(USE_RTL_THREAD_API) && !defined(_MSC_VER)
#define JOIN(t, avp)							\
    STMT_START {							\
	if ((WaitForSingleObject((t)->self,INFINITE) == WAIT_FAILED)	\
	     || (GetExitCodeThread((t)->self,(LPDWORD)(avp)) == 0)	\
	     || (CloseHandle((t)->self) == 0))				\
	    croak("panic: JOIN");					\
	*avp = (AV *)((t)->i.retv);					\
    } STMT_END
#else	/* !USE_RTL_THREAD_API || _MSC_VER */
#define JOIN(t, avp)							\
    STMT_START {							\
	if ((WaitForSingleObject((t)->self,INFINITE) == WAIT_FAILED)	\
	     || (GetExitCodeThread((t)->self,(LPDWORD)(avp)) == 0)	\
	     || (CloseHandle((t)->self) == 0))				\
	    croak("panic: JOIN");					\
    } STMT_END
#endif	/* !USE_RTL_THREAD_API || _MSC_VER */

#define YIELD			Sleep(0)

#endif /* _WIN32THREAD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\gennmtab\gennmtab.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include <string.h>
#include <stdio.h>
#include <stddef.h>

struct range {
  int start;
  int end;
};

struct range nmstrt[] = {
  { '_' },
  { ':' },
  /* BaseChar */
  { 0x0041, 0x005a },
  { 0x0061, 0x007a },
  { 0x00c0, 0x00d6 },
  { 0x00d8, 0x00f6 },
  { 0x00f8, 0x00ff },
  { 0x0100, 0x0131 },
  { 0x0134, 0x013e },
  { 0x0141, 0x0148 },
  { 0x014a, 0x017e },
  { 0x0180, 0x01c3 },
  { 0x01cd, 0x01f0 },
  { 0x01f4, 0x01f5 },
  { 0x01fa, 0x0217 },
  { 0x0250, 0x02a8 },
  { 0x02bb, 0x02c1 },
  { 0x0386 },
  { 0x0388, 0x038a },
  { 0x038c },
  { 0x038e, 0x03a1 },
  { 0x03a3, 0x03ce },
  { 0x03d0, 0x03d6 },
  { 0x03da },
  { 0x03dc },
  { 0x03de },
  { 0x03e0 },
  { 0x03e2, 0x03f3 },
  { 0x0401, 0x040c },
  { 0x040e, 0x044f },
  { 0x0451, 0x045c },
  { 0x045e, 0x0481 },
  { 0x0490, 0x04c4 },
  { 0x04c7, 0x04c8 },
  { 0x04cb, 0x04cc },
  { 0x04d0, 0x04eb },
  { 0x04ee, 0x04f5 },
  { 0x04f8, 0x04f9 },
  { 0x0531, 0x0556 },
  { 0x0559 },
  { 0x0561, 0x0586 },
  { 0x05d0, 0x05ea },
  { 0x05f0, 0x05f2 },
  { 0x0621, 0x063a },
  { 0x0641, 0x064a },
  { 0x0671, 0x06b7 },
  { 0x06ba, 0x06be },
  { 0x06c0, 0x06ce },
  { 0x06d0, 0x06d3 },
  { 0x06d5 },
  { 0x06e5, 0x06e6 },
  { 0x0905, 0x0939 },
  { 0x093d },
  { 0x0958, 0x0961 },
  { 0x0985, 0x098c },
  { 0x098f, 0x0990 },
  { 0x0993, 0x09a8 },
  { 0x09aa, 0x09b0 },
  { 0x09b2 },
  { 0x09b6, 0x09b9 },
  { 0x09dc, 0x09dd },
  { 0x09df, 0x09e1 },
  { 0x09f0, 0x09f1 },
  { 0x0a05, 0x0a0a },
  { 0x0a0f, 0x0a10 },
  { 0x0a13, 0x0a28 },
  { 0x0a2a, 0x0a30 },
  { 0x0a32, 0x0a33 },
  { 0x0a35, 0x0a36 },
  { 0x0a38, 0x0a39 },
  { 0x0a59, 0x0a5c },
  { 0x0a5e },
  { 0x0a72, 0x0a74 },
  { 0x0a85, 0x0a8b },
  { 0x0a8d },
  { 0x0a8f, 0x0a91 },
  { 0x0a93, 0x0aa8 },
  { 0x0aaa, 0x0ab0 },
  { 0x0ab2, 0x0ab3 },
  { 0x0ab5, 0x0ab9 },
  { 0x0abd },
  { 0x0ae0 },
  { 0x0b05, 0x0b0c },
  { 0x0b0f, 0x0b10 },
  { 0x0b13, 0x0b28 },
  { 0x0b2a, 0x0b30 },
  { 0x0b32, 0x0b33 },
  { 0x0b36, 0x0b39 },
  { 0x0b3d },
  { 0x0b5c, 0x0b5d },
  { 0x0b5f, 0x0b61 },
  { 0x0b85, 0x0b8a },
  { 0x0b8e, 0x0b90 },
  { 0x0b92, 0x0b95 },
  { 0x0b99, 0x0b9a },
  { 0x0b9c },
  { 0x0b9e, 0x0b9f },
  { 0x0ba3, 0x0ba4 },
  { 0x0ba8, 0x0baa },
  { 0x0bae, 0x0bb5 },
  { 0x0bb7, 0x0bb9 },
  { 0x0c05, 0x0c0c },
  { 0x0c0e, 0x0c10 },
  { 0x0c12, 0x0c28 },
  { 0x0c2a, 0x0c33 },
  { 0x0c35, 0x0c39 },
  { 0x0c60, 0x0c61 },
  { 0x0c85, 0x0c8c },
  { 0x0c8e, 0x0c90 },
  { 0x0c92, 0x0ca8 },
  { 0x0caa, 0x0cb3 },
  { 0x0cb5, 0x0cb9 },
  { 0x0cde },
  { 0x0ce0, 0x0ce1 },
  { 0x0d05, 0x0d0c },
  { 0x0d0e, 0x0d10 },
  { 0x0d12, 0x0d28 },
  { 0x0d2a, 0x0d39 },
  { 0x0d60, 0x0d61 },
  { 0x0e01, 0x0e2e },
  { 0x0e30 },
  { 0x0e32, 0x0e33 },
  { 0x0e40, 0x0e45 },
  { 0x0e81, 0x0e82 },
  { 0x0e84 },
  { 0x0e87, 0x0e88 },
  { 0x0e8a },
  { 0x0e8d },
  { 0x0e94, 0x0e97 },
  { 0x0e99, 0x0e9f },
  { 0x0ea1, 0x0ea3 },
  { 0x0ea5 },
  { 0x0ea7 },
  { 0x0eaa, 0x0eab },
  { 0x0ead, 0x0eae },
  { 0x0eb0 },
  { 0x0eb2, 0x0eb3 },
  { 0x0ebd },
  { 0x0ec0, 0x0ec4 },
  { 0x0f40, 0x0f47 },
  { 0x0f49, 0x0f69 },
  { 0x10a0, 0x10c5 },
  { 0x10d0, 0x10f6 },
  { 0x1100 },
  { 0x1102, 0x1103 },
  { 0x1105, 0x1107 },
  { 0x1109 },
  { 0x110b, 0x110c },
  { 0x110e, 0x1112 },
  { 0x113c },
  { 0x113e },
  { 0x1140 },
  { 0x114c },
  { 0x114e },
  { 0x1150 },
  { 0x1154, 0x1155 },
  { 0x1159 },
  { 0x115f, 0x1161 },
  { 0x1163 },
  { 0x1165 },
  { 0x1167 },
  { 0x1169 },
  { 0x116d, 0x116e },
  { 0x1172, 0x1173 },
  { 0x1175 },
  { 0x119e },
  { 0x11a8 },
  { 0x11ab },
  { 0x11ae, 0x11af },
  { 0x11b7, 0x11b8 },
  { 0x11ba },
  { 0x11bc, 0x11c2 },
  { 0x11eb },
  { 0x11f0 },
  { 0x11f9 },
  { 0x1e00, 0x1e9b },
  { 0x1ea0, 0x1ef9 },
  { 0x1f00, 0x1f15 },
  { 0x1f18, 0x1f1d },
  { 0x1f20, 0x1f45 },
  { 0x1f48, 0x1f4d },
  { 0x1f50, 0x1f57 },
  { 0x1f59 },
  { 0x1f5b },
  { 0x1f5d },
  { 0x1f5f, 0x1f7d },
  { 0x1f80, 0x1fb4 },
  { 0x1fb6, 0x1fbc },
  { 0x1fbe },
  { 0x1fc2, 0x1fc4 },
  { 0x1fc6, 0x1fcc },
  { 0x1fd0, 0x1fd3 },
  { 0x1fd6, 0x1fdb },
  { 0x1fe0, 0x1fec },
  { 0x1ff2, 0x1ff4 },
  { 0x1ff6, 0x1ffc },
  { 0x2126 },
  { 0x212a, 0x212b },
  { 0x212e },
  { 0x2180, 0x2182 },
  { 0x3041, 0x3094 },
  { 0x30a1, 0x30fa },
  { 0x3105, 0x312c },
  { 0xac00, 0xd7a3 },
  /* Ideographic */
  { 0x4e00, 0x9fa5 },
  { 0x3007 },
  { 0x3021, 0x3029 },
};

/* name chars that are not name start chars */
struct range name[] = {
  { '.' },
  { '-' },
  /* CombiningChar */
  { 0x0300, 0x0345 },
  { 0x0360, 0x0361 },
  { 0x0483, 0x0486 },
  { 0x0591, 0x05a1 },
  { 0x05a3, 0x05b9 },
  { 0x05bb, 0x05bd },
  { 0x05bf },
  { 0x05c1, 0x05c2 },
  { 0x05c4 },
  { 0x064b, 0x0652 },
  { 0x0670 },
  { 0x06d6, 0x06dc },
  { 0x06dd, 0x06df },
  { 0x06e0, 0x06e4 },
  { 0x06e7, 0x06e8 },
  { 0x06ea, 0x06ed },
  { 0x0901, 0x0903 },
  { 0x093c },
  { 0x093e, 0x094c },
  { 0x094d },
  { 0x0951, 0x0954 },
  { 0x0962, 0x0963 },
  { 0x0981, 0x0983 },
  { 0x09bc },
  { 0x09be },
  { 0x09bf },
  { 0x09c0, 0x09c4 },
  { 0x09c7, 0x09c8 },
  { 0x09cb, 0x09cd },
  { 0x09d7 },
  { 0x09e2, 0x09e3 },
  { 0x0a02 },
  { 0x0a3c },
  { 0x0a3e },
  { 0x0a3f },
  { 0x0a40, 0x0a42 },
  { 0x0a47, 0x0a48 },
  { 0x0a4b, 0x0a4d },
  { 0x0a70, 0x0a71 },
  { 0x0a81, 0x0a83 },
  { 0x0abc },
  { 0x0abe, 0x0ac5 },
  { 0x0ac7, 0x0ac9 },
  { 0x0acb, 0x0acd },
  { 0x0b01, 0x0b03 },
  { 0x0b3c },
  { 0x0b3e, 0x0b43 },
  { 0x0b47, 0x0b48 },
  { 0x0b4b, 0x0b4d },
  { 0x0b56, 0x0b57 },
  { 0x0b82, 0x0b83 },
  { 0x0bbe, 0x0bc2 },
  { 0x0bc6, 0x0bc8 },
  { 0x0bca, 0x0bcd },
  { 0x0bd7 },
  { 0x0c01, 0x0c03 },
  { 0x0c3e, 0x0c44 },
  { 0x0c46, 0x0c48 },
  { 0x0c4a, 0x0c4d },
  { 0x0c55, 0x0c56 },
  { 0x0c82, 0x0c83 },
  { 0x0cbe, 0x0cc4 },
  { 0x0cc6, 0x0cc8 },
  { 0x0cca, 0x0ccd },
  { 0x0cd5, 0x0cd6 },
  { 0x0d02, 0x0d03 },
  { 0x0d3e, 0x0d43 },
  { 0x0d46, 0x0d48 },
  { 0x0d4a, 0x0d4d },
  { 0x0d57 },
  { 0x0e31 },
  { 0x0e34, 0x0e3a },
  { 0x0e47, 0x0e4e },
  { 0x0eb1 },
  { 0x0eb4, 0x0eb9 },
  { 0x0ebb, 0x0ebc },
  { 0x0ec8, 0x0ecd },
  { 0x0f18, 0x0f19 },
  { 0x0f35 },
  { 0x0f37 },
  { 0x0f39 },
  { 0x0f3e },
  { 0x0f3f },
  { 0x0f71, 0x0f84 },
  { 0x0f86, 0x0f8b },
  { 0x0f90, 0x0f95 },
  { 0x0f97 },
  { 0x0f99, 0x0fad },
  { 0x0fb1, 0x0fb7 },
  { 0x0fb9 },
  { 0x20d0, 0x20dc },
  { 0x20e1 },
  { 0x302a, 0x302f },
  { 0x3099 },
  { 0x309a },
  /* Digit */
  { 0x0030, 0x0039 },
  { 0x0660, 0x0669 },
  { 0x06f0, 0x06f9 },
  { 0x0966, 0x096f },
  { 0x09e6, 0x09ef },
  { 0x0a66, 0x0a6f },
  { 0x0ae6, 0x0aef },
  { 0x0b66, 0x0b6f },
  { 0x0be7, 0x0bef },
  { 0x0c66, 0x0c6f },
  { 0x0ce6, 0x0cef },
  { 0x0d66, 0x0d6f },
  { 0x0e50, 0x0e59 },
  { 0x0ed0, 0x0ed9 },
  { 0x0f20, 0x0f29 },
  /* Extender */
  { 0xb7 },
  { 0x02d0 },
  { 0x02d1 },
  { 0x0387 },
  { 0x0640 },
  { 0x0e46 },
  { 0x0ec6 },
  { 0x3005 },
  { 0x3031, 0x3035 },
  { 0x309d, 0x309e },
  { 0x30fc, 0x30fe },
};

void setTab(char *tab, struct range *ranges, size_t nRanges)
{
  size_t i;
  int j;
  for (i = 0; i < nRanges; i++) {
    if (ranges[i].end) {
      for (j = ranges[i].start; j <= ranges[i].end; j++)
	tab[j] = 1;
    }
    else
      tab[ranges[i].start] = 1;
  }
}

void printTabs(char *tab)
{ 
  int nBitmaps = 2;
  int i, j, k;
  unsigned char pageIndex[512];

  printf(
"static const unsigned namingBitmap[] = {\n\
0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\
0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\n\
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\n");
  for (i = 0; i < 512; i++) {
    int kind = tab[i*256];
    for (j = 1; j < 256; j++)
      if (tab[i*256 +j] != kind) {
	kind = -1;
	break;
      }
    if (i >= 256 &&  memcmp(tab + (i - 256)*256, tab + i*256, 256) == 0)
      pageIndex[i] = pageIndex[i - 256];
    else if (kind == -1) { 
      pageIndex[i] = nBitmaps++;
      for (j = 0; j < 8; j++) {
	unsigned val = 0;
	for (k = 0; k < 32; k++) {
	  if (tab[i*256 + j*32 +k])
	    val |= (1 << k);
	}
	printf("0x%08X,", val);
	putchar((((j + 1) & 3) == 0) ? '\n' : ' ');
      }
    }
    else
      pageIndex[i] = kind;
  }
  printf("};\n");
  printf("static const unsigned char nmstrtPages[] = {\n");
  for (i = 0; i < 512; i++) {
    if (i == 256)
      printf("};\nstatic const unsigned char namePages[] = {\n");
    printf("0x%02X,", pageIndex[i]);
    putchar((((i + 1) & 7) == 0) ? '\n' : ' ');
  }
  printf("};\n");
}

int main()
{ 
  char tab[2*65536];
  memset(tab, 0, 65536);
  setTab(tab, nmstrt, sizeof(nmstrt)/sizeof(nmstrt[0]));
  memcpy(tab + 65536, tab, 65536);
  setTab(tab + 65536, name, sizeof(name)/sizeof(name[0]));
  printTabs(tab);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlparse\hashtable.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
csompliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include "xmldef.h"

#ifdef XML_UNICODE_WCHAR_T
#ifndef XML_UNICODE
#define XML_UNICODE
#endif
#endif

#include "hashtable.h"

#define INIT_SIZE 64

static
int keyeq(KEY s1, KEY s2)
{
  for (; *s1 == *s2; s1++, s2++)
    if (*s1 == 0)
      return 1;
  return 0;
}

static
unsigned long hash(KEY s)
{
  unsigned long h = 0;
  while (*s)
    h = (h << 5) + h + (unsigned char)*s++;
  return h;
}

NAMED *lookup(HASH_TABLE *table, KEY name, size_t createSize)
{
  size_t i;
  if (table->size == 0) {
    if (!createSize)
      return 0;
    table->v = calloc(INIT_SIZE, sizeof(NAMED *));
    if (!table->v)
      return 0;
    table->size = INIT_SIZE;
    table->usedLim = INIT_SIZE / 2;
    i = hash(name) & (table->size - 1);
  }
  else {
    unsigned long h = hash(name);
    for (i = h & (table->size - 1);
         table->v[i];
         i == 0 ? i = table->size - 1 : --i) {
      if (keyeq(name, table->v[i]->name))
	return table->v[i];
    }
    if (!createSize)
      return 0;
    if (table->used == table->usedLim) {
      /* check for overflow */
      size_t newSize = table->size * 2;
      NAMED **newV = calloc(newSize, sizeof(NAMED *));
      if (!newV)
	return 0;
      for (i = 0; i < table->size; i++)
	if (table->v[i]) {
	  size_t j;
	  for (j = hash(table->v[i]->name) & (newSize - 1);
	       newV[j];
	       j == 0 ? j = newSize - 1 : --j)
	    ;
	  newV[j] = table->v[i];
	}
      free(table->v);
      table->v = newV;
      table->size = newSize;
      table->usedLim = newSize/2;
      for (i = h & (table->size - 1);
	   table->v[i];
	   i == 0 ? i = table->size - 1 : --i)
	;
    }
  }
  table->v[i] = calloc(1, createSize);
  if (!table->v[i])
    return 0;
  table->v[i]->name = name;
  (table->used)++;
  return table->v[i];
}

void hashTableDestroy(HASH_TABLE *table)
{
  size_t i;
  for (i = 0; i < table->size; i++) {
    NAMED *p = table->v[i];
    if (p)
      free(p);
  }
  free(table->v);
}

void hashTableInit(HASH_TABLE *p)
{
  p->size = 0;
  p->usedLim = 0;
  p->used = 0;
  p->v = 0;
}

void hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
{
  iter->p = table->v;
  iter->end = iter->p + table->size;
}

NAMED *hashTableIterNext(HASH_TABLE_ITER *iter)
{
  while (iter->p != iter->end) {
    NAMED *tem = *(iter->p)++;
    if (tem)
      return tem;
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlparse\hashtable.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/


#include <stddef.h>

#ifdef XML_UNICODE

#ifdef XML_UNICODE_WCHAR_T
typedef const wchar_t *KEY;
#else /* not XML_UNICODE_WCHAR_T */
typedef const unsigned short *KEY;
#endif /* not XML_UNICODE_WCHAR_T */

#else /* not XML_UNICODE */

typedef const char *KEY;

#endif /* not XML_UNICODE */

typedef struct {
  KEY name;
} NAMED;

typedef struct {
  NAMED **v;
  size_t size;
  size_t used;
  size_t usedLim;
} HASH_TABLE;

NAMED *lookup(HASH_TABLE *table, KEY name, size_t createSize);
void hashTableInit(HASH_TABLE *);
void hashTableDestroy(HASH_TABLE *);

typedef struct {
  NAMED **p;
  NAMED **end;
} HASH_TABLE_ITER;

void hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);
NAMED *hashTableIterNext(HASH_TABLE_ITER *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\sample\elements.c ===
/* This is simple demonstration of how to use expat. This program
reads an XML document from standard input and writes a line with the
name of each element to standard output indenting child elements by
one tab stop more than their parent element. */

#include <stdio.h>
#include "xmlparse.h"

void startElement(void *userData, const char *name, const char **atts)
{
  int i;
  int *depthPtr = userData;
  for (i = 0; i < *depthPtr; i++)
    putchar('\t');
  puts(name);
  *depthPtr += 1;
}

void endElement(void *userData, const char *name)
{
  int *depthPtr = userData;
  *depthPtr -= 1;
}

int main()
{
  char buf[BUFSIZ];
  XML_Parser parser = XML_ParserCreate(NULL);
  int done;
  int depth = 0;
  XML_SetUserData(parser, &depth);
  XML_SetElementHandler(parser, startElement, endElement);
  do {
    size_t len = fread(buf, 1, sizeof(buf), stdin);
    done = len < sizeof(buf);
    if (!XML_Parse(parser, buf, len, done)) {
      fprintf(stderr,
	      "%s at line %d\n",
	      XML_ErrorString(XML_GetErrorCode(parser)),
	      XML_GetCurrentLineNumber(parser));
      return 1;
    }
  } while (!done);
  XML_ParserFree(parser);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\asciitab.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

/* 0x00 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x04 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x08 */ BT_NONXML, BT_S, BT_LF, BT_NONXML,
/* 0x0C */ BT_NONXML, BT_CR, BT_NONXML, BT_NONXML,
/* 0x10 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x14 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x18 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x1C */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x20 */ BT_S, BT_EXCL, BT_QUOT, BT_NUM,
/* 0x24 */ BT_OTHER, BT_PERCNT, BT_AMP, BT_APOS,
/* 0x28 */ BT_LPAR, BT_RPAR, BT_AST, BT_PLUS,
/* 0x2C */ BT_COMMA, BT_MINUS, BT_NAME, BT_SOL,
/* 0x30 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
/* 0x34 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
/* 0x38 */ BT_DIGIT, BT_DIGIT, BT_COLON, BT_SEMI,
/* 0x3C */ BT_LT, BT_EQUALS, BT_GT, BT_QUEST,
/* 0x40 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
/* 0x44 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
/* 0x48 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x4C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x50 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x54 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x58 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_LSQB,
/* 0x5C */ BT_OTHER, BT_RSQB, BT_OTHER, BT_NMSTRT,
/* 0x60 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
/* 0x64 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
/* 0x68 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x6C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x70 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x74 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x78 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
/* 0x7C */ BT_VERBAR, BT_OTHER, BT_OTHER, BT_OTHER,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlparse\xmlparse.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#ifndef XmlParse_INCLUDED
#define XmlParse_INCLUDED 1

#ifdef __cplusplus
extern "C" {
#endif

#ifndef XMLPARSEAPI
#define XMLPARSEAPI /* as nothing */
#endif

typedef void *XML_Parser;

#ifdef XML_UNICODE_WCHAR_T

/* XML_UNICODE_WCHAR_T will work only if sizeof(wchar_t) == 2 and wchar_t
uses Unicode. */
/* Information is UTF-16 encoded as wchar_ts */

#ifndef XML_UNICODE
#define XML_UNICODE
#endif

#include <stddef.h>
typedef wchar_t XML_Char;
typedef wchar_t XML_LChar;

#else /* not XML_UNICODE_WCHAR_T */

#ifdef XML_UNICODE

/* Information is UTF-16 encoded as unsigned shorts */
typedef unsigned short XML_Char;
typedef char XML_LChar;

#else /* not XML_UNICODE */

/* Information is UTF-8 encoded. */
typedef char XML_Char;
typedef char XML_LChar;

#endif /* not XML_UNICODE */

#endif /* not XML_UNICODE_WCHAR_T */


/* Constructs a new parser; encoding is the encoding specified by the external
protocol or null if there is none specified. */

XML_Parser XMLPARSEAPI
XML_ParserCreate(const XML_Char *encoding);

/* Constructs a new parser and namespace processor.  Element type names
and attribute names that belong to a namespace will be expanded;
unprefixed attribute names are never expanded; unprefixed element type
names are expanded only if there is a default namespace. The expanded
name is the concatenation of the namespace URI, the namespace separator character,
and the local part of the name.  If the namespace separator is '\0' then
the namespace URI and the local part will be concatenated without any
separator.  When a namespace is not declared, the name and prefix will be
passed through without expansion. */

XML_Parser XMLPARSEAPI
XML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);


/* atts is array of name/value pairs, terminated by 0;
   names and values are 0 terminated. */

typedef void (*XML_StartElementHandler)(void *userData,
					const XML_Char *name,
					const XML_Char **atts);

typedef void (*XML_EndElementHandler)(void *userData,
				      const XML_Char *name);

/* s is not 0 terminated. */
typedef void (*XML_CharacterDataHandler)(void *userData,
					 const XML_Char *s,
					 int len);

/* target and data are 0 terminated */
typedef void (*XML_ProcessingInstructionHandler)(void *userData,
						 const XML_Char *target,
						 const XML_Char *data);

/* data is 0 terminated */
typedef void (*XML_CommentHandler)(void *userData, const XML_Char *data);

typedef void (*XML_StartCdataSectionHandler)(void *userData);
typedef void (*XML_EndCdataSectionHandler)(void *userData);

/* This is called for any characters in the XML document for
which there is no applicable handler.  This includes both
characters that are part of markup which is of a kind that is
not reported (comments, markup declarations), or characters
that are part of a construct which could be reported but
for which no handler has been supplied. The characters are passed
exactly as they were in the XML document except that
they will be encoded in UTF-8.  Line boundaries are not normalized.
Note that a byte order mark character is not passed to the default handler.
There are no guarantees about how characters are divided between calls
to the default handler: for example, a comment might be split between
multiple calls. */

typedef void (*XML_DefaultHandler)(void *userData,
				   const XML_Char *s,
				   int len);

/* This is called for the start of the DOCTYPE declaration when the
name of the DOCTYPE is encountered. */
typedef void (*XML_StartDoctypeDeclHandler)(void *userData,
					    const XML_Char *doctypeName);

/* This is called for the start of the DOCTYPE declaration when the
closing > is encountered, but after processing any external subset. */
typedef void (*XML_EndDoctypeDeclHandler)(void *userData);

/* This is called for a declaration of an unparsed (NDATA)
entity.  The base argument is whatever was set by XML_SetBase.
The entityName, systemId and notationName arguments will never be null.
The other arguments may be. */

typedef void (*XML_UnparsedEntityDeclHandler)(void *userData,
					      const XML_Char *entityName,
					      const XML_Char *base,
					      const XML_Char *systemId,
					      const XML_Char *publicId,
					      const XML_Char *notationName);

/* This is called for a declaration of notation.
The base argument is whatever was set by XML_SetBase.
The notationName will never be null.  The other arguments can be. */

typedef void (*XML_NotationDeclHandler)(void *userData,
					const XML_Char *notationName,
					const XML_Char *base,
					const XML_Char *systemId,
					const XML_Char *publicId);

/* When namespace processing is enabled, these are called once for
each namespace declaration. The call to the start and end element
handlers occur between the calls to the start and end namespace
declaration handlers. For an xmlns attribute, prefix will be null.
For an xmlns="" attribute, uri will be null. */

typedef void (*XML_StartNamespaceDeclHandler)(void *userData,
					      const XML_Char *prefix,
					      const XML_Char *uri);

typedef void (*XML_EndNamespaceDeclHandler)(void *userData,
					    const XML_Char *prefix);

/* This is called if the document is not standalone (it has an
external subset or a reference to a parameter entity, but does not
have standalone="yes"). If this handler returns 0, then processing
will not continue, and the parser will return a
XML_ERROR_NOT_STANDALONE error. */

typedef int (*XML_NotStandaloneHandler)(void *userData);

/* This is called for a reference to an external parsed general entity.
The referenced entity is not automatically parsed.
The application can parse it immediately or later using
XML_ExternalEntityParserCreate.
The parser argument is the parser parsing the entity containing the reference;
it can be passed as the parser argument to XML_ExternalEntityParserCreate.
The systemId argument is the system identifier as specified in the entity declaration;
it will not be null.
The base argument is the system identifier that should be used as the base for
resolving systemId if systemId was relative; this is set by XML_SetBase;
it may be null.
The publicId argument is the public identifier as specified in the entity declaration,
or null if none was specified; the whitespace in the public identifier
will have been normalized as required by the XML spec.
The context argument specifies the parsing context in the format
expected by the context argument to
XML_ExternalEntityParserCreate; context is valid only until the handler
returns, so if the referenced entity is to be parsed later, it must be copied.
The handler should return 0 if processing should not continue because of
a fatal error in the handling of the external entity.
In this case the calling parser will return an XML_ERROR_EXTERNAL_ENTITY_HANDLING
error.
Note that unlike other handlers the first argument is the parser, not userData. */

typedef int (*XML_ExternalEntityRefHandler)(XML_Parser parser,
					    const XML_Char *context,
					    const XML_Char *base,
					    const XML_Char *systemId,
					    const XML_Char *publicId);

/* This structure is filled in by the XML_UnknownEncodingHandler
to provide information to the parser about encodings that are unknown
to the parser.
The map[b] member gives information about byte sequences
whose first byte is b.
If map[b] is c where c is >= 0, then b by itself encodes the Unicode scalar value c.
If map[b] is -1, then the byte sequence is malformed.
If map[b] is -n, where n >= 2, then b is the first byte of an n-byte
sequence that encodes a single Unicode scalar value.
The data member will be passed as the first argument to the convert function.
The convert function is used to convert multibyte sequences;
s will point to a n-byte sequence where map[(unsigned char)*s] == -n.
The convert function must return the Unicode scalar value
represented by this byte sequence or -1 if the byte sequence is malformed.
The convert function may be null if the encoding is a single-byte encoding,
that is if map[b] >= -1 for all bytes b.
When the parser is finished with the encoding, then if release is not null,
it will call release passing it the data member;
once release has been called, the convert function will not be called again.

Expat places certain restrictions on the encodings that are supported
using this mechanism.

1. Every ASCII character that can appear in a well-formed XML document,
other than the characters

  $@\^`{}~

must be represented by a single byte, and that byte must be the
same byte that represents that character in ASCII.

2. No character may require more than 4 bytes to encode.

3. All characters encoded must have Unicode scalar values <= 0xFFFF,
(ie characters that would be encoded by surrogates in UTF-16
are  not allowed).  Note that this restriction doesn't apply to
the built-in support for UTF-8 and UTF-16.

4. No Unicode character may be encoded by more than one distinct sequence
of bytes. */

typedef struct {
  int map[256];
  void *data;
  int (*convert)(void *data, const char *s);
  void (*release)(void *data);
} XML_Encoding;

/* This is called for an encoding that is unknown to the parser.
The encodingHandlerData argument is that which was passed as the
second argument to XML_SetUnknownEncodingHandler.
The name argument gives the name of the encoding as specified in
the encoding declaration.
If the callback can provide information about the encoding,
it must fill in the XML_Encoding structure, and return 1.
Otherwise it must return 0.
If info does not describe a suitable encoding,
then the parser will return an XML_UNKNOWN_ENCODING error. */

typedef int (*XML_UnknownEncodingHandler)(void *encodingHandlerData,
					  const XML_Char *name,
					  XML_Encoding *info);

void XMLPARSEAPI
XML_SetElementHandler(XML_Parser parser,
		      XML_StartElementHandler start,
		      XML_EndElementHandler end);

void XMLPARSEAPI
XML_SetCharacterDataHandler(XML_Parser parser,
			    XML_CharacterDataHandler handler);

void XMLPARSEAPI
XML_SetProcessingInstructionHandler(XML_Parser parser,
				    XML_ProcessingInstructionHandler handler);
void XMLPARSEAPI
XML_SetCommentHandler(XML_Parser parser,
                      XML_CommentHandler handler);

void XMLPARSEAPI
XML_SetCdataSectionHandler(XML_Parser parser,
			   XML_StartCdataSectionHandler start,
			   XML_EndCdataSectionHandler end);

/* This sets the default handler and also inhibits expansion of internal entities.
The entity reference will be passed to the default handler. */

void XMLPARSEAPI
XML_SetDefaultHandler(XML_Parser parser,
		      XML_DefaultHandler handler);

/* This sets the default handler but does not inhibit expansion of internal entities.
The entity reference will not be passed to the default handler. */

void XMLPARSEAPI
XML_SetDefaultHandlerExpand(XML_Parser parser,
		            XML_DefaultHandler handler);

void XMLPARSEAPI
XML_SetDoctypeDeclHandler(XML_Parser parser,
			  XML_StartDoctypeDeclHandler start,
			  XML_EndDoctypeDeclHandler end);

void XMLPARSEAPI
XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
				 XML_UnparsedEntityDeclHandler handler);

void XMLPARSEAPI
XML_SetNotationDeclHandler(XML_Parser parser,
			   XML_NotationDeclHandler handler);

void XMLPARSEAPI
XML_SetNamespaceDeclHandler(XML_Parser parser,
			    XML_StartNamespaceDeclHandler start,
			    XML_EndNamespaceDeclHandler end);

void XMLPARSEAPI
XML_SetNotStandaloneHandler(XML_Parser parser,
			    XML_NotStandaloneHandler handler);

void XMLPARSEAPI
XML_SetExternalEntityRefHandler(XML_Parser parser,
				XML_ExternalEntityRefHandler handler);

/* If a non-null value for arg is specified here, then it will be passed
as the first argument to the external entity ref handler instead
of the parser object. */
void XMLPARSEAPI
XML_SetExternalEntityRefHandlerArg(XML_Parser, void *arg);

void XMLPARSEAPI
XML_SetUnknownEncodingHandler(XML_Parser parser,
			      XML_UnknownEncodingHandler handler,
			      void *encodingHandlerData);

/* This can be called within a handler for a start element, end element,
processing instruction or character data.  It causes the corresponding
markup to be passed to the default handler. */
void XMLPARSEAPI XML_DefaultCurrent(XML_Parser parser);

/* This value is passed as the userData argument to callbacks. */
void XMLPARSEAPI
XML_SetUserData(XML_Parser parser, void *userData);

/* Returns the last value set by XML_SetUserData or null. */
#define XML_GetUserData(parser) (*(void **)(parser))

/* This is equivalent to supplying an encoding argument
to XML_CreateParser. It must not be called after XML_Parse
or XML_ParseBuffer. */

int XMLPARSEAPI
XML_SetEncoding(XML_Parser parser, const XML_Char *encoding);

/* If this function is called, then the parser will be passed
as the first argument to callbacks instead of userData.
The userData will still be accessible using XML_GetUserData. */

void XMLPARSEAPI
XML_UseParserAsHandlerArg(XML_Parser parser);

/* Sets the base to be used for resolving relative URIs in system identifiers in
declarations.  Resolving relative identifiers is left to the application:
this value will be passed through as the base argument to the
XML_ExternalEntityRefHandler, XML_NotationDeclHandler
and XML_UnparsedEntityDeclHandler. The base argument will be copied.
Returns zero if out of memory, non-zero otherwise. */

int XMLPARSEAPI
XML_SetBase(XML_Parser parser, const XML_Char *base);

const XML_Char XMLPARSEAPI *
XML_GetBase(XML_Parser parser);

/* Returns the number of the attributes passed in last call to the
XML_StartElementHandler that were specified in the start-tag rather
than defaulted. */

int XMLPARSEAPI XML_GetSpecifiedAttributeCount(XML_Parser parser);

/* Parses some input. Returns 0 if a fatal error is detected.
The last call to XML_Parse must have isFinal true;
len may be zero for this call (or any other). */
int XMLPARSEAPI
XML_Parse(XML_Parser parser, const char *s, int len, int isFinal);

void XMLPARSEAPI *
XML_GetBuffer(XML_Parser parser, int len);

int XMLPARSEAPI
XML_ParseBuffer(XML_Parser parser, int len, int isFinal);

/* Creates an XML_Parser object that can parse an external general entity;
context is a '\0'-terminated string specifying the parse context;
encoding is a '\0'-terminated string giving the name of the externally specified encoding,
or null if there is no externally specified encoding.
The context string consists of a sequence of tokens separated by formfeeds (\f);
a token consisting of a name specifies that the general entity of the name
is open; a token of the form prefix=uri specifies the namespace for a particular
prefix; a token of the form =uri specifies the default namespace.
This can be called at any point after the first call to an ExternalEntityRefHandler
so longer as the parser has not yet been freed.
The new parser is completely independent and may safely be used in a separate thread.
The handlers and userData are initialized from the parser argument.
Returns 0 if out of memory.  Otherwise returns a new XML_Parser object. */
XML_Parser XMLPARSEAPI
XML_ExternalEntityParserCreate(XML_Parser parser,
			       const XML_Char *context,
			       const XML_Char *encoding);

enum XML_ParamEntityParsing {
  XML_PARAM_ENTITY_PARSING_NEVER,
  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,
  XML_PARAM_ENTITY_PARSING_ALWAYS
};

/* Controls parsing of parameter entities (including the external DTD
subset). If parsing of parameter entities is enabled, then references
to external parameter entities (including the external DTD subset)
will be passed to the handler set with
XML_SetExternalEntityRefHandler.  The context passed will be 0.
Unlike external general entities, external parameter entities can only
be parsed synchronously.  If the external parameter entity is to be
parsed, it must be parsed during the call to the external entity ref
handler: the complete sequence of XML_ExternalEntityParserCreate,
XML_Parse/XML_ParseBuffer and XML_ParserFree calls must be made during
this call.  After XML_ExternalEntityParserCreate has been called to
create the parser for the external parameter entity (context must be 0
for this call), it is illegal to make any calls on the old parser
until XML_ParserFree has been called on the newly created parser.  If
the library has been compiled without support for parameter entity
parsing (ie without XML_DTD being defined), then
XML_SetParamEntityParsing will return 0 if parsing of parameter
entities is requested; otherwise it will return non-zero. */

int XMLPARSEAPI
XML_SetParamEntityParsing(XML_Parser parser,
			  enum XML_ParamEntityParsing parsing);

enum XML_Error {
  XML_ERROR_NONE,
  XML_ERROR_NO_MEMORY,
  XML_ERROR_SYNTAX,
  XML_ERROR_NO_ELEMENTS,
  XML_ERROR_INVALID_TOKEN,
  XML_ERROR_UNCLOSED_TOKEN,
  XML_ERROR_PARTIAL_CHAR,
  XML_ERROR_TAG_MISMATCH,
  XML_ERROR_DUPLICATE_ATTRIBUTE,
  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,
  XML_ERROR_PARAM_ENTITY_REF,
  XML_ERROR_UNDEFINED_ENTITY,
  XML_ERROR_RECURSIVE_ENTITY_REF,
  XML_ERROR_ASYNC_ENTITY,
  XML_ERROR_BAD_CHAR_REF,
  XML_ERROR_BINARY_ENTITY_REF,
  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,
  XML_ERROR_MISPLACED_XML_PI,
  XML_ERROR_UNKNOWN_ENCODING,
  XML_ERROR_INCORRECT_ENCODING,
  XML_ERROR_UNCLOSED_CDATA_SECTION,
  XML_ERROR_EXTERNAL_ENTITY_HANDLING,
  XML_ERROR_NOT_STANDALONE
};

/* If XML_Parse or XML_ParseBuffer have returned 0, then XML_GetErrorCode
returns information about the error. */

enum XML_Error XMLPARSEAPI XML_GetErrorCode(XML_Parser parser);

/* These functions return information about the current parse location.
They may be called when XML_Parse or XML_ParseBuffer return 0;
in this case the location is the location of the character at which
the error was detected.
They may also be called from any other callback called to report
some parse event; in this the location is the location of the first
of the sequence of characters that generated the event. */

int XMLPARSEAPI XML_GetCurrentLineNumber(XML_Parser parser);
int XMLPARSEAPI XML_GetCurrentColumnNumber(XML_Parser parser);
long XMLPARSEAPI XML_GetCurrentByteIndex(XML_Parser parser);

/* Return the number of bytes in the current event.
Returns 0 if the event is in an internal entity. */

int XMLPARSEAPI XML_GetCurrentByteCount(XML_Parser parser);

/* If XML_CONTEXT_BYTES is defined, returns the input buffer, sets
   the integer pointed to by offset to the offset within this buffer
   of the current parse position, and sets the integer pointed to by size
   to the size of this buffer (the number of input bytes). Otherwise
   returns a null pointer. Also returns a null pointer if a parse isn't active.

   NOTE: The character pointer returned should not be used outside
   the handler that makes the call. */

const char XMLPARSEAPI * XML_GetInputContext(XML_Parser parser,
					     int *offset,
					     int *size);

/* For backwards compatibility with previous versions. */
#define XML_GetErrorLineNumber XML_GetCurrentLineNumber
#define XML_GetErrorColumnNumber XML_GetCurrentColumnNumber
#define XML_GetErrorByteIndex XML_GetCurrentByteIndex

/* Frees memory used by the parser. */
void XMLPARSEAPI
XML_ParserFree(XML_Parser parser);

/* Returns a string describing the error. */
const XML_LChar XMLPARSEAPI *XML_ErrorString(int code);

#ifdef __cplusplus
}
#endif

#endif /* not XmlParse_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\dllmain.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#define STRICT 1
#define WIN32_LEAN_AND_MEAN 1

#include <windows.h>

BOOL WINAPI DllMain(HANDLE hInst, ULONG ul_reason_for_call, LPVOID lpReserved)
{
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\iasciitab.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

/* Like asciitab.h, except that 0xD has code BT_S rather than BT_CR */
/* 0x00 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x04 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x08 */ BT_NONXML, BT_S, BT_LF, BT_NONXML,
/* 0x0C */ BT_NONXML, BT_S, BT_NONXML, BT_NONXML,
/* 0x10 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x14 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x18 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x1C */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0x20 */ BT_S, BT_EXCL, BT_QUOT, BT_NUM,
/* 0x24 */ BT_OTHER, BT_PERCNT, BT_AMP, BT_APOS,
/* 0x28 */ BT_LPAR, BT_RPAR, BT_AST, BT_PLUS,
/* 0x2C */ BT_COMMA, BT_MINUS, BT_NAME, BT_SOL,
/* 0x30 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
/* 0x34 */ BT_DIGIT, BT_DIGIT, BT_DIGIT, BT_DIGIT,
/* 0x38 */ BT_DIGIT, BT_DIGIT, BT_COLON, BT_SEMI,
/* 0x3C */ BT_LT, BT_EQUALS, BT_GT, BT_QUEST,
/* 0x40 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
/* 0x44 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
/* 0x48 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x4C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x50 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x54 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x58 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_LSQB,
/* 0x5C */ BT_OTHER, BT_RSQB, BT_OTHER, BT_NMSTRT,
/* 0x60 */ BT_OTHER, BT_HEX, BT_HEX, BT_HEX,
/* 0x64 */ BT_HEX, BT_HEX, BT_HEX, BT_NMSTRT,
/* 0x68 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x6C */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x70 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x74 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0x78 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
/* 0x7C */ BT_VERBAR, BT_OTHER, BT_OTHER, BT_OTHER,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlparse\xmlparse.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include "xmldef.h"
#include "xmlparse.h"

#ifdef XML_UNICODE
#define XML_ENCODE_MAX XML_UTF16_ENCODE_MAX
#define XmlConvert XmlUtf16Convert
#define XmlGetInternalEncoding XmlGetUtf16InternalEncoding
#define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS
#define XmlEncode XmlUtf16Encode
#define MUST_CONVERT(enc, s) (!(enc)->isUtf16 || (((unsigned long)s) & 1))
typedef unsigned short ICHAR;
#else
#define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX
#define XmlConvert XmlUtf8Convert
#define XmlGetInternalEncoding XmlGetUtf8InternalEncoding
#define XmlGetInternalEncodingNS XmlGetUtf8InternalEncodingNS
#define XmlEncode XmlUtf8Encode
#define MUST_CONVERT(enc, s) (!(enc)->isUtf8)
typedef char ICHAR;
#endif


#ifndef XML_NS

#define XmlInitEncodingNS XmlInitEncoding
#define XmlInitUnknownEncodingNS XmlInitUnknownEncoding
#undef XmlGetInternalEncodingNS
#define XmlGetInternalEncodingNS XmlGetInternalEncoding
#define XmlParseXmlDeclNS XmlParseXmlDecl

#endif

#ifdef XML_UNICODE_WCHAR_T
#define XML_T(x) L ## x
#else
#define XML_T(x) x
#endif

/* Round up n to be a multiple of sz, where sz is a power of 2. */
#define ROUND_UP(n, sz) (((n) + ((sz) - 1)) & ~((sz) - 1))

#include "xmltok.h"
#include "xmlrole.h"
#include "hashtable.h"

#define INIT_TAG_BUF_SIZE 32  /* must be a multiple of sizeof(XML_Char) */
#define INIT_DATA_BUF_SIZE 1024
#define INIT_ATTS_SIZE 16
#define INIT_BLOCK_SIZE 1024
#define INIT_BUFFER_SIZE 1024

#define EXPAND_SPARE 24

typedef struct binding {
  struct prefix *prefix;
  struct binding *nextTagBinding;
  struct binding *prevPrefixBinding;
  const struct attribute_id *attId;
  XML_Char *uri;
  int uriLen;
  int uriAlloc;
} BINDING;

typedef struct prefix {
  const XML_Char *name;
  BINDING *binding;
} PREFIX;

typedef struct {
  const XML_Char *str;
  const XML_Char *localPart;
  int uriLen;
} TAG_NAME;

typedef struct tag {
  struct tag *parent;
  const char *rawName;
  int rawNameLength;
  TAG_NAME name;
  char *buf;
  char *bufEnd;
  BINDING *bindings;
} TAG;

typedef struct {
  const XML_Char *name;
  const XML_Char *textPtr;
  int textLen;
  const XML_Char *systemId;
  const XML_Char *base;
  const XML_Char *publicId;
  const XML_Char *notation;
  char open;
} ENTITY;

typedef struct block {
  struct block *next;
  int size;
  XML_Char s[1];
} BLOCK;

typedef struct {
  BLOCK *blocks;
  BLOCK *freeBlocks;
  const XML_Char *end;
  XML_Char *ptr;
  XML_Char *start;
} STRING_POOL;

/* The XML_Char before the name is used to determine whether
an attribute has been specified. */
typedef struct attribute_id {
  XML_Char *name;
  PREFIX *prefix;
  char maybeTokenized;
  char xmlns;
} ATTRIBUTE_ID;

typedef struct {
  const ATTRIBUTE_ID *id;
  char isCdata;
  const XML_Char *value;
} DEFAULT_ATTRIBUTE;

typedef struct {
  const XML_Char *name;
  PREFIX *prefix;
  int nDefaultAtts;
  int allocDefaultAtts;
  DEFAULT_ATTRIBUTE *defaultAtts;
} ELEMENT_TYPE;

typedef struct {
  HASH_TABLE generalEntities;
  HASH_TABLE elementTypes;
  HASH_TABLE attributeIds;
  HASH_TABLE prefixes;
  STRING_POOL pool;
  int complete;
  int standalone;
#ifdef XML_DTD
  HASH_TABLE paramEntities;
#endif /* XML_DTD */
  PREFIX defaultPrefix;
} DTD;

typedef struct open_internal_entity {
  const char *internalEventPtr;
  const char *internalEventEndPtr;
  struct open_internal_entity *next;
  ENTITY *entity;
} OPEN_INTERNAL_ENTITY;

typedef enum XML_Error Processor(XML_Parser parser,
				 const char *start,
				 const char *end,
				 const char **endPtr);

static Processor prologProcessor;
static Processor prologInitProcessor;
static Processor contentProcessor;
static Processor cdataSectionProcessor;
#ifdef XML_DTD
static Processor ignoreSectionProcessor;
#endif /* XML_DTD */
static Processor epilogProcessor;
static Processor errorProcessor;
static Processor externalEntityInitProcessor;
static Processor externalEntityInitProcessor2;
static Processor externalEntityInitProcessor3;
static Processor externalEntityContentProcessor;

static enum XML_Error
handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName);
static enum XML_Error
processXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *, const char *);
static enum XML_Error
initializeEncoding(XML_Parser parser);
static enum XML_Error
doProlog(XML_Parser parser, const ENCODING *enc, const char *s,
	 const char *end, int tok, const char *next, const char **nextPtr);
static enum XML_Error
processInternalParamEntity(XML_Parser parser, ENTITY *entity);
static enum XML_Error
doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,
	  const char *start, const char *end, const char **endPtr);
static enum XML_Error
doCdataSection(XML_Parser parser, const ENCODING *, const char **startPtr, const char *end, const char **nextPtr);
#ifdef XML_DTD
static enum XML_Error
doIgnoreSection(XML_Parser parser, const ENCODING *, const char **startPtr, const char *end, const char **nextPtr);
#endif /* XML_DTD */
static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *, const char *s,
				TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
static
int addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId, const XML_Char *uri, BINDING **bindingsPtr);
static int
defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *, int isCdata, const XML_Char *dfltValue);
static enum XML_Error
storeAttributeValue(XML_Parser parser, const ENCODING *, int isCdata, const char *, const char *,
		    STRING_POOL *);
static enum XML_Error
appendAttributeValue(XML_Parser parser, const ENCODING *, int isCdata, const char *, const char *,
		    STRING_POOL *);
static ATTRIBUTE_ID *
getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
static enum XML_Error
storeEntityValue(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static int
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static int
reportComment(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static void
reportDefault(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);

static const XML_Char *getContext(XML_Parser parser);
static int setContext(XML_Parser parser, const XML_Char *context);
static void normalizePublicId(XML_Char *s);
static int dtdInit(DTD *);
static void dtdDestroy(DTD *);
static int dtdCopy(DTD *newDtd, const DTD *oldDtd);
static int copyEntityTable(HASH_TABLE *, STRING_POOL *, const HASH_TABLE *);
#ifdef XML_DTD
static void dtdSwap(DTD *, DTD *);
#endif /* XML_DTD */
static void poolInit(STRING_POOL *);
static void poolClear(STRING_POOL *);
static void poolDestroy(STRING_POOL *);
static XML_Char *poolAppend(STRING_POOL *pool, const ENCODING *enc,
			    const char *ptr, const char *end);
static XML_Char *poolStoreString(STRING_POOL *pool, const ENCODING *enc,
				  const char *ptr, const char *end);
static int poolGrow(STRING_POOL *pool);
static const XML_Char *poolCopyString(STRING_POOL *pool, const XML_Char *s);
static const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n);

#define poolStart(pool) ((pool)->start)
#define poolEnd(pool) ((pool)->ptr)
#define poolLength(pool) ((pool)->ptr - (pool)->start)
#define poolChop(pool) ((void)--(pool->ptr))
#define poolLastChar(pool) (((pool)->ptr)[-1])
#define poolDiscard(pool) ((pool)->ptr = (pool)->start)
#define poolFinish(pool) ((pool)->start = (pool)->ptr)
#define poolAppendChar(pool, c) \
  (((pool)->ptr == (pool)->end && !poolGrow(pool)) \
   ? 0 \
   : ((*((pool)->ptr)++ = c), 1))

typedef struct {
  /* The first member must be userData so that the XML_GetUserData macro works. */
  void *m_userData;
  void *m_handlerArg;
  char *m_buffer;
  /* first character to be parsed */
  const char *m_bufferPtr;
  /* past last character to be parsed */
  char *m_bufferEnd;
  /* allocated end of buffer */
  const char *m_bufferLim;
  long m_parseEndByteIndex;
  const char *m_parseEndPtr;
  XML_Char *m_dataBuf;
  XML_Char *m_dataBufEnd;
  XML_StartElementHandler m_startElementHandler;
  XML_EndElementHandler m_endElementHandler;
  XML_CharacterDataHandler m_characterDataHandler;
  XML_ProcessingInstructionHandler m_processingInstructionHandler;
  XML_CommentHandler m_commentHandler;
  XML_StartCdataSectionHandler m_startCdataSectionHandler;
  XML_EndCdataSectionHandler m_endCdataSectionHandler;
  XML_DefaultHandler m_defaultHandler;
  XML_StartDoctypeDeclHandler m_startDoctypeDeclHandler;
  XML_EndDoctypeDeclHandler m_endDoctypeDeclHandler;
  XML_UnparsedEntityDeclHandler m_unparsedEntityDeclHandler;
  XML_NotationDeclHandler m_notationDeclHandler;
  XML_StartNamespaceDeclHandler m_startNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler m_endNamespaceDeclHandler;
  XML_NotStandaloneHandler m_notStandaloneHandler;
  XML_ExternalEntityRefHandler m_externalEntityRefHandler;
  void *m_externalEntityRefHandlerArg;
  XML_UnknownEncodingHandler m_unknownEncodingHandler;
  const ENCODING *m_encoding;
  INIT_ENCODING m_initEncoding;
  const ENCODING *m_internalEncoding;
  const XML_Char *m_protocolEncodingName;
  int m_ns;
  void *m_unknownEncodingMem;
  void *m_unknownEncodingData;
  void *m_unknownEncodingHandlerData;
  void (*m_unknownEncodingRelease)(void *);
  PROLOG_STATE m_prologState;
  Processor *m_processor;
  enum XML_Error m_errorCode;
  const char *m_eventPtr;
  const char *m_eventEndPtr;
  const char *m_positionPtr;
  OPEN_INTERNAL_ENTITY *m_openInternalEntities;
  int m_defaultExpandInternalEntities;
  int m_tagLevel;
  ENTITY *m_declEntity;
  const XML_Char *m_declNotationName;
  const XML_Char *m_declNotationPublicId;
  ELEMENT_TYPE *m_declElementType;
  ATTRIBUTE_ID *m_declAttributeId;
  char m_declAttributeIsCdata;
  DTD m_dtd;
  const XML_Char *m_curBase;
  TAG *m_tagStack;
  TAG *m_freeTagList;
  BINDING *m_inheritedBindings;
  BINDING *m_freeBindingList;
  int m_attsSize;
  int m_nSpecifiedAtts;
  ATTRIBUTE *m_atts;
  POSITION m_position;
  STRING_POOL m_tempPool;
  STRING_POOL m_temp2Pool;
  char *m_groupConnector;
  unsigned m_groupSize;
  int m_hadExternalDoctype;
  XML_Char m_namespaceSeparator;
#ifdef XML_DTD
  enum XML_ParamEntityParsing m_paramEntityParsing;
  XML_Parser m_parentParser;
#endif
} Parser;

#define userData (((Parser *)parser)->m_userData)
#define handlerArg (((Parser *)parser)->m_handlerArg)
#define startElementHandler (((Parser *)parser)->m_startElementHandler)
#define endElementHandler (((Parser *)parser)->m_endElementHandler)
#define characterDataHandler (((Parser *)parser)->m_characterDataHandler)
#define processingInstructionHandler (((Parser *)parser)->m_processingInstructionHandler)
#define commentHandler (((Parser *)parser)->m_commentHandler)
#define startCdataSectionHandler (((Parser *)parser)->m_startCdataSectionHandler)
#define endCdataSectionHandler (((Parser *)parser)->m_endCdataSectionHandler)
#define defaultHandler (((Parser *)parser)->m_defaultHandler)
#define startDoctypeDeclHandler (((Parser *)parser)->m_startDoctypeDeclHandler)
#define endDoctypeDeclHandler (((Parser *)parser)->m_endDoctypeDeclHandler)
#define unparsedEntityDeclHandler (((Parser *)parser)->m_unparsedEntityDeclHandler)
#define notationDeclHandler (((Parser *)parser)->m_notationDeclHandler)
#define startNamespaceDeclHandler (((Parser *)parser)->m_startNamespaceDeclHandler)
#define endNamespaceDeclHandler (((Parser *)parser)->m_endNamespaceDeclHandler)
#define notStandaloneHandler (((Parser *)parser)->m_notStandaloneHandler)
#define externalEntityRefHandler (((Parser *)parser)->m_externalEntityRefHandler)
#define externalEntityRefHandlerArg (((Parser *)parser)->m_externalEntityRefHandlerArg)
#define unknownEncodingHandler (((Parser *)parser)->m_unknownEncodingHandler)
#define encoding (((Parser *)parser)->m_encoding)
#define initEncoding (((Parser *)parser)->m_initEncoding)
#define internalEncoding (((Parser *)parser)->m_internalEncoding)
#define unknownEncodingMem (((Parser *)parser)->m_unknownEncodingMem)
#define unknownEncodingData (((Parser *)parser)->m_unknownEncodingData)
#define unknownEncodingHandlerData \
  (((Parser *)parser)->m_unknownEncodingHandlerData)
#define unknownEncodingRelease (((Parser *)parser)->m_unknownEncodingRelease)
#define protocolEncodingName (((Parser *)parser)->m_protocolEncodingName)
#define ns (((Parser *)parser)->m_ns)
#define prologState (((Parser *)parser)->m_prologState)
#define processor (((Parser *)parser)->m_processor)
#define errorCode (((Parser *)parser)->m_errorCode)
#define eventPtr (((Parser *)parser)->m_eventPtr)
#define eventEndPtr (((Parser *)parser)->m_eventEndPtr)
#define positionPtr (((Parser *)parser)->m_positionPtr)
#define position (((Parser *)parser)->m_position)
#define openInternalEntities (((Parser *)parser)->m_openInternalEntities)
#define defaultExpandInternalEntities (((Parser *)parser)->m_defaultExpandInternalEntities)
#define tagLevel (((Parser *)parser)->m_tagLevel)
#define buffer (((Parser *)parser)->m_buffer)
#define bufferPtr (((Parser *)parser)->m_bufferPtr)
#define bufferEnd (((Parser *)parser)->m_bufferEnd)
#define parseEndByteIndex (((Parser *)parser)->m_parseEndByteIndex)
#define parseEndPtr (((Parser *)parser)->m_parseEndPtr)
#define bufferLim (((Parser *)parser)->m_bufferLim)
#define dataBuf (((Parser *)parser)->m_dataBuf)
#define dataBufEnd (((Parser *)parser)->m_dataBufEnd)
#define dtd (((Parser *)parser)->m_dtd)
#define curBase (((Parser *)parser)->m_curBase)
#define declEntity (((Parser *)parser)->m_declEntity)
#define declNotationName (((Parser *)parser)->m_declNotationName)
#define declNotationPublicId (((Parser *)parser)->m_declNotationPublicId)
#define declElementType (((Parser *)parser)->m_declElementType)
#define declAttributeId (((Parser *)parser)->m_declAttributeId)
#define declAttributeIsCdata (((Parser *)parser)->m_declAttributeIsCdata)
#define freeTagList (((Parser *)parser)->m_freeTagList)
#define freeBindingList (((Parser *)parser)->m_freeBindingList)
#define inheritedBindings (((Parser *)parser)->m_inheritedBindings)
#define tagStack (((Parser *)parser)->m_tagStack)
#define atts (((Parser *)parser)->m_atts)
#define attsSize (((Parser *)parser)->m_attsSize)
#define nSpecifiedAtts (((Parser *)parser)->m_nSpecifiedAtts)
#define tempPool (((Parser *)parser)->m_tempPool)
#define temp2Pool (((Parser *)parser)->m_temp2Pool)
#define groupConnector (((Parser *)parser)->m_groupConnector)
#define groupSize (((Parser *)parser)->m_groupSize)
#define hadExternalDoctype (((Parser *)parser)->m_hadExternalDoctype)
#define namespaceSeparator (((Parser *)parser)->m_namespaceSeparator)
#ifdef XML_DTD
#define parentParser (((Parser *)parser)->m_parentParser)
#define paramEntityParsing (((Parser *)parser)->m_paramEntityParsing)
#endif /* XML_DTD */

#ifdef _MSC_VER
#ifdef _DEBUG
Parser *asParser(XML_Parser parser)
{
  return parser;
}
#endif
#endif

XML_Parser XML_ParserCreate(const XML_Char *encodingName)
{
  XML_Parser parser = malloc(sizeof(Parser));
  if (!parser)
    return parser;
  processor = prologInitProcessor;
  XmlPrologStateInit(&prologState);
  userData = 0;
  handlerArg = 0;
  startElementHandler = 0;
  endElementHandler = 0;
  characterDataHandler = 0;
  processingInstructionHandler = 0;
  commentHandler = 0;
  startCdataSectionHandler = 0;
  endCdataSectionHandler = 0;
  defaultHandler = 0;
  startDoctypeDeclHandler = 0;
  endDoctypeDeclHandler = 0;
  unparsedEntityDeclHandler = 0;
  notationDeclHandler = 0;
  startNamespaceDeclHandler = 0;
  endNamespaceDeclHandler = 0;
  notStandaloneHandler = 0;
  externalEntityRefHandler = 0;
  externalEntityRefHandlerArg = parser;
  unknownEncodingHandler = 0;
  buffer = 0;
  bufferPtr = 0;
  bufferEnd = 0;
  parseEndByteIndex = 0;
  parseEndPtr = 0;
  bufferLim = 0;
  declElementType = 0;
  declAttributeId = 0;
  declEntity = 0;
  declNotationName = 0;
  declNotationPublicId = 0;
  memset(&position, 0, sizeof(POSITION));
  errorCode = XML_ERROR_NONE;
  eventPtr = 0;
  eventEndPtr = 0;
  positionPtr = 0;
  openInternalEntities = 0;
  tagLevel = 0;
  tagStack = 0;
  freeTagList = 0;
  freeBindingList = 0;
  inheritedBindings = 0;
  attsSize = INIT_ATTS_SIZE;
  atts = malloc(attsSize * sizeof(ATTRIBUTE));
  nSpecifiedAtts = 0;
  dataBuf = malloc(INIT_DATA_BUF_SIZE * sizeof(XML_Char));
  groupSize = 0;
  groupConnector = 0;
  hadExternalDoctype = 0;
  unknownEncodingMem = 0;
  unknownEncodingRelease = 0;
  unknownEncodingData = 0;
  unknownEncodingHandlerData = 0;
  namespaceSeparator = '!';
#ifdef XML_DTD
  parentParser = 0;
  paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
#endif
  ns = 0;
  poolInit(&tempPool);
  poolInit(&temp2Pool);
  protocolEncodingName = encodingName ? poolCopyString(&tempPool, encodingName) : 0;
  curBase = 0;
  if (!dtdInit(&dtd) || !atts || !dataBuf
      || (encodingName && !protocolEncodingName)) {
    XML_ParserFree(parser);
    return 0;
  }
  dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;
  XmlInitEncoding(&initEncoding, &encoding, 0);
  internalEncoding = XmlGetInternalEncoding();
  return parser;
}

XML_Parser XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
{
  static
  const XML_Char implicitContext[] = {
    XML_T('x'), XML_T('m'), XML_T('l'), XML_T('='),
    XML_T('h'), XML_T('t'), XML_T('t'), XML_T('p'), XML_T(':'),
    XML_T('/'), XML_T('/'), XML_T('w'), XML_T('w'), XML_T('w'),
    XML_T('.'), XML_T('w'), XML_T('3'),
    XML_T('.'), XML_T('o'), XML_T('r'), XML_T('g'),
    XML_T('/'), XML_T('X'), XML_T('M'), XML_T('L'),
    XML_T('/'), XML_T('1'), XML_T('9'), XML_T('9'), XML_T('8'),
    XML_T('/'), XML_T('n'), XML_T('a'), XML_T('m'), XML_T('e'),
    XML_T('s'), XML_T('p'), XML_T('a'), XML_T('c'), XML_T('e'),
    XML_T('\0')
  };

  XML_Parser parser = XML_ParserCreate(encodingName);
  if (parser) {
    XmlInitEncodingNS(&initEncoding, &encoding, 0);
    ns = 1;
    internalEncoding = XmlGetInternalEncodingNS();
    namespaceSeparator = nsSep;
  }
  if (!setContext(parser, implicitContext)) {
    XML_ParserFree(parser);
    return 0;
  }
  return parser;
}

int XML_SetEncoding(XML_Parser parser, const XML_Char *encodingName)
{
  if (!encodingName)
    protocolEncodingName = 0;
  else {
    protocolEncodingName = poolCopyString(&tempPool, encodingName);
    if (!protocolEncodingName)
      return 0;
  }
  return 1;
}

XML_Parser XML_ExternalEntityParserCreate(XML_Parser oldParser,
					  const XML_Char *context,
					  const XML_Char *encodingName)
{
  XML_Parser parser = oldParser;
  DTD *oldDtd = &dtd;
  XML_StartElementHandler oldStartElementHandler = startElementHandler;
  XML_EndElementHandler oldEndElementHandler = endElementHandler;
  XML_CharacterDataHandler oldCharacterDataHandler = characterDataHandler;
  XML_ProcessingInstructionHandler oldProcessingInstructionHandler = processingInstructionHandler;
  XML_CommentHandler oldCommentHandler = commentHandler;
  XML_StartCdataSectionHandler oldStartCdataSectionHandler = startCdataSectionHandler;
  XML_EndCdataSectionHandler oldEndCdataSectionHandler = endCdataSectionHandler;
  XML_DefaultHandler oldDefaultHandler = defaultHandler;
  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler = startNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler = endNamespaceDeclHandler;
  XML_NotStandaloneHandler oldNotStandaloneHandler = notStandaloneHandler;
  XML_ExternalEntityRefHandler oldExternalEntityRefHandler = externalEntityRefHandler;
  XML_UnknownEncodingHandler oldUnknownEncodingHandler = unknownEncodingHandler;
  void *oldUserData = userData;
  void *oldHandlerArg = handlerArg;
  int oldDefaultExpandInternalEntities = defaultExpandInternalEntities;
  void *oldExternalEntityRefHandlerArg = externalEntityRefHandlerArg;
#ifdef XML_DTD
  int oldParamEntityParsing = paramEntityParsing;
#endif
  parser = (ns
            ? XML_ParserCreateNS(encodingName, namespaceSeparator)
	    : XML_ParserCreate(encodingName));
  if (!parser)
    return 0;
  startElementHandler = oldStartElementHandler;
  endElementHandler = oldEndElementHandler;
  characterDataHandler = oldCharacterDataHandler;
  processingInstructionHandler = oldProcessingInstructionHandler;
  commentHandler = oldCommentHandler;
  startCdataSectionHandler = oldStartCdataSectionHandler;
  endCdataSectionHandler = oldEndCdataSectionHandler;
  defaultHandler = oldDefaultHandler;
  startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
  endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
  notStandaloneHandler = oldNotStandaloneHandler;
  externalEntityRefHandler = oldExternalEntityRefHandler;
  unknownEncodingHandler = oldUnknownEncodingHandler;
  userData = oldUserData;
  if (oldUserData == oldHandlerArg)
    handlerArg = userData;
  else
    handlerArg = parser;
  if (oldExternalEntityRefHandlerArg != oldParser)
    externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
  defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
#ifdef XML_DTD
  paramEntityParsing = oldParamEntityParsing;
  if (context) {
#endif /* XML_DTD */
    if (!dtdCopy(&dtd, oldDtd) || !setContext(parser, context)) {
      XML_ParserFree(parser);
      return 0;
    }
    processor = externalEntityInitProcessor;
#ifdef XML_DTD
  }
  else {
    dtdSwap(&dtd, oldDtd);
    parentParser = oldParser;
    XmlPrologStateInitExternalEntity(&prologState);
    dtd.complete = 1;
    hadExternalDoctype = 1;
  }
#endif /* XML_DTD */
  return parser;
}

static
void destroyBindings(BINDING *bindings)
{
  for (;;) {
    BINDING *b = bindings;
    if (!b)
      break;
    bindings = b->nextTagBinding;
    free(b->uri);
    free(b);
  }
}

void XML_ParserFree(XML_Parser parser)
{
  for (;;) {
    TAG *p;
    if (tagStack == 0) {
      if (freeTagList == 0)
	break;
      tagStack = freeTagList;
      freeTagList = 0;
    }
    p = tagStack;
    tagStack = tagStack->parent;
    free(p->buf);
    destroyBindings(p->bindings);
    free(p);
  }
  destroyBindings(freeBindingList);
  destroyBindings(inheritedBindings);
  poolDestroy(&tempPool);
  poolDestroy(&temp2Pool);
#ifdef XML_DTD
  if (parentParser) {
    if (hadExternalDoctype)
      dtd.complete = 0;
    dtdSwap(&dtd, &((Parser *)parentParser)->m_dtd);
  }
#endif /* XML_DTD */
  dtdDestroy(&dtd);
  free((void *)atts);
  free(groupConnector);
  free(buffer);
  free(dataBuf);
  free(unknownEncodingMem);
  if (unknownEncodingRelease)
    unknownEncodingRelease(unknownEncodingData);
  free(parser);
}

void XML_UseParserAsHandlerArg(XML_Parser parser)
{
  handlerArg = parser;
}

void XML_SetUserData(XML_Parser parser, void *p)
{
  if (handlerArg == userData)
    handlerArg = userData = p;
  else
    userData = p;
}

int XML_SetBase(XML_Parser parser, const XML_Char *p)
{
  if (p) {
    p = poolCopyString(&dtd.pool, p);
    if (!p)
      return 0;
    curBase = p;
  }
  else
    curBase = 0;
  return 1;
}

const XML_Char *XML_GetBase(XML_Parser parser)
{
  return curBase;
}

int XML_GetSpecifiedAttributeCount(XML_Parser parser)
{
  return nSpecifiedAtts;
}

void XML_SetElementHandler(XML_Parser parser,
			   XML_StartElementHandler start,
			   XML_EndElementHandler end)
{
  startElementHandler = start;
  endElementHandler = end;
}

void XML_SetCharacterDataHandler(XML_Parser parser,
				 XML_CharacterDataHandler handler)
{
  characterDataHandler = handler;
}

void XML_SetProcessingInstructionHandler(XML_Parser parser,
					 XML_ProcessingInstructionHandler handler)
{
  processingInstructionHandler = handler;
}

void XML_SetCommentHandler(XML_Parser parser,
			   XML_CommentHandler handler)
{
  commentHandler = handler;
}

void XML_SetCdataSectionHandler(XML_Parser parser,
				XML_StartCdataSectionHandler start,
			        XML_EndCdataSectionHandler end)
{
  startCdataSectionHandler = start;
  endCdataSectionHandler = end;
}

void XML_SetDefaultHandler(XML_Parser parser,
			   XML_DefaultHandler handler)
{
  defaultHandler = handler;
  defaultExpandInternalEntities = 0;
}

void XML_SetDefaultHandlerExpand(XML_Parser parser,
				 XML_DefaultHandler handler)
{
  defaultHandler = handler;
  defaultExpandInternalEntities = 1;
}

void XML_SetDoctypeDeclHandler(XML_Parser parser,
			       XML_StartDoctypeDeclHandler start,
			       XML_EndDoctypeDeclHandler end)
{
  startDoctypeDeclHandler = start;
  endDoctypeDeclHandler = end;
}

void XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
				      XML_UnparsedEntityDeclHandler handler)
{
  unparsedEntityDeclHandler = handler;
}

void XML_SetNotationDeclHandler(XML_Parser parser,
				XML_NotationDeclHandler handler)
{
  notationDeclHandler = handler;
}

void XML_SetNamespaceDeclHandler(XML_Parser parser,
				 XML_StartNamespaceDeclHandler start,
				 XML_EndNamespaceDeclHandler end)
{
  startNamespaceDeclHandler = start;
  endNamespaceDeclHandler = end;
}

void XML_SetNotStandaloneHandler(XML_Parser parser,
				 XML_NotStandaloneHandler handler)
{
  notStandaloneHandler = handler;
}

void XML_SetExternalEntityRefHandler(XML_Parser parser,
				     XML_ExternalEntityRefHandler handler)
{
  externalEntityRefHandler = handler;
}

void XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg)
{
  if (arg)
    externalEntityRefHandlerArg = arg;
  else
    externalEntityRefHandlerArg = parser;
}

void XML_SetUnknownEncodingHandler(XML_Parser parser,
				   XML_UnknownEncodingHandler handler,
				   void *data)
{
  unknownEncodingHandler = handler;
  unknownEncodingHandlerData = data;
}

int XML_SetParamEntityParsing(XML_Parser parser,
			      enum XML_ParamEntityParsing parsing)
{
#ifdef XML_DTD
  paramEntityParsing = parsing;
  return 1;
#else
  return parsing == XML_PARAM_ENTITY_PARSING_NEVER;
#endif
}

int XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
{
  if (len == 0) {
    if (!isFinal)
      return 1;
    positionPtr = bufferPtr;
    errorCode = processor(parser, bufferPtr, parseEndPtr = bufferEnd, 0);
    if (errorCode == XML_ERROR_NONE)
      return 1;
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return 0;
  }
#ifndef XML_CONTEXT_BYTES
  else if (bufferPtr == bufferEnd) {
    const char *end;
    int nLeftOver;
    parseEndByteIndex += len;
    positionPtr = s;
    if (isFinal) {
      errorCode = processor(parser, s, parseEndPtr = s + len, 0);
      if (errorCode == XML_ERROR_NONE)
	return 1;
      eventEndPtr = eventPtr;
      processor = errorProcessor;
      return 0;
    }
    errorCode = processor(parser, s, parseEndPtr = s + len, &end);
    if (errorCode != XML_ERROR_NONE) {
      eventEndPtr = eventPtr;
      processor = errorProcessor;
      return 0;
    }
    XmlUpdatePosition(encoding, positionPtr, end, &position);
    nLeftOver = s + len - end;
    if (nLeftOver) {
      if (buffer == 0 || nLeftOver > bufferLim - buffer) {
	/* FIXME avoid integer overflow */
	buffer = buffer == 0 ? malloc(len * 2) : realloc(buffer, len * 2);
	/* FIXME storage leak if realloc fails */
	if (!buffer) {
	  errorCode = XML_ERROR_NO_MEMORY;
	  eventPtr = eventEndPtr = 0;
	  processor = errorProcessor;
	  return 0;
	}
	bufferLim = buffer + len * 2;
      }
      memcpy(buffer, end, nLeftOver);
      bufferPtr = buffer;
      bufferEnd = buffer + nLeftOver;
    }
    return 1;
  }
#endif  /* not defined XML_CONTEXT_BYTES */
  else {
    memcpy(XML_GetBuffer(parser, len), s, len);
    return XML_ParseBuffer(parser, len, isFinal);
  }
}

int XML_ParseBuffer(XML_Parser parser, int len, int isFinal)
{
  const char *start = bufferPtr;
  positionPtr = start;
  bufferEnd += len;
  parseEndByteIndex += len;
  errorCode = processor(parser, start, parseEndPtr = bufferEnd,
			isFinal ? (const char **)0 : &bufferPtr);
  if (errorCode == XML_ERROR_NONE) {
    if (!isFinal)
      XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
    return 1;
  }
  else {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return 0;
  }
}

void *XML_GetBuffer(XML_Parser parser, int len)
{
  if (len > bufferLim - bufferEnd) {
    /* FIXME avoid integer overflow */
    int neededSize = len + (bufferEnd - bufferPtr);
#ifdef XML_CONTEXT_BYTES
    int keep = bufferPtr - buffer;

    if (keep > XML_CONTEXT_BYTES)
      keep = XML_CONTEXT_BYTES;
    neededSize += keep;
#endif  /* defined XML_CONTEXT_BYTES */
    if (neededSize  <= bufferLim - buffer) {
#ifdef XML_CONTEXT_BYTES
      if (keep < bufferPtr - buffer) {
	int offset = (bufferPtr - buffer) - keep;
	memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);
	bufferEnd -= offset;
	bufferPtr -= offset;
      }
#else
      memmove(buffer, bufferPtr, bufferEnd - bufferPtr);
      bufferEnd = buffer + (bufferEnd - bufferPtr);
      bufferPtr = buffer;
#endif  /* not defined XML_CONTEXT_BYTES */
    }
    else {
      char *newBuf;
      int bufferSize = bufferLim - bufferPtr;
      if (bufferSize == 0)
	bufferSize = INIT_BUFFER_SIZE;
      do {
	bufferSize *= 2;
      } while (bufferSize < neededSize);
      newBuf = malloc(bufferSize);
      if (newBuf == 0) {
	errorCode = XML_ERROR_NO_MEMORY;
	return 0;
      }
      bufferLim = newBuf + bufferSize;
#ifdef XML_CONTEXT_BYTES
      if (bufferPtr) {
	int keep = bufferPtr - buffer;
	if (keep > XML_CONTEXT_BYTES)
	  keep = XML_CONTEXT_BYTES;
	memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);
	free(buffer);
	buffer = newBuf;
	bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;
	bufferPtr = buffer + keep;
      }
      else {
	bufferEnd = newBuf + (bufferEnd - bufferPtr);
	bufferPtr = buffer = newBuf;
      }
#else
      if (bufferPtr) {
	memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);
	free(buffer);
      }
      bufferEnd = newBuf + (bufferEnd - bufferPtr);
      bufferPtr = buffer = newBuf;
#endif  /* not defined XML_CONTEXT_BYTES */
    }
  }
  return bufferEnd;
}

enum XML_Error XML_GetErrorCode(XML_Parser parser)
{
  return errorCode;
}

long XML_GetCurrentByteIndex(XML_Parser parser)
{
  if (eventPtr)
    return parseEndByteIndex - (parseEndPtr - eventPtr);
  return -1;
}

int XML_GetCurrentByteCount(XML_Parser parser)
{
  if (eventEndPtr && eventPtr)
    return eventEndPtr - eventPtr;
  return 0;
}

const char * XML_GetInputContext(XML_Parser parser, int *offset, int *size)
{
#ifdef XML_CONTEXT_BYTES
  if (eventPtr && buffer) {
    *offset = eventPtr - buffer;
    *size   = bufferEnd - buffer;
    return buffer;
  }
#endif /* defined XML_CONTEXT_BYTES */
  return (char *) 0;
}

int XML_GetCurrentLineNumber(XML_Parser parser)
{
  if (eventPtr) {
    XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
    positionPtr = eventPtr;
  }
  return position.lineNumber + 1;
}

int XML_GetCurrentColumnNumber(XML_Parser parser)
{
  if (eventPtr) {
    XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
    positionPtr = eventPtr;
  }
  return position.columnNumber;
}

void XML_DefaultCurrent(XML_Parser parser)
{
  if (defaultHandler) {
    if (openInternalEntities)
      reportDefault(parser,
	            internalEncoding,
		    openInternalEntities->internalEventPtr,
		    openInternalEntities->internalEventEndPtr);
    else
      reportDefault(parser, encoding, eventPtr, eventEndPtr);
  }
}

const XML_LChar *XML_ErrorString(int code)
{
  static const XML_LChar *message[] = {
    0,
    XML_T("out of memory"),
    XML_T("syntax error"),
    XML_T("no element found"),
    XML_T("not well-formed"),
    XML_T("unclosed token"),
    XML_T("unclosed token"),
    XML_T("mismatched tag"),
    XML_T("duplicate attribute"),
    XML_T("junk after document element"),
    XML_T("illegal parameter entity reference"),
    XML_T("undefined entity"),
    XML_T("recursive entity reference"),
    XML_T("asynchronous entity"),
    XML_T("reference to invalid character number"),
    XML_T("reference to binary entity"),
    XML_T("reference to external entity in attribute"),
    XML_T("xml processing instruction not at start of external entity"),
    XML_T("unknown encoding"),
    XML_T("encoding specified in XML declaration is incorrect"),
    XML_T("unclosed CDATA section"),
    XML_T("error in processing external entity reference"),
    XML_T("document is not standalone")
  };
  if (code > 0 && code < sizeof(message)/sizeof(message[0]))
    return message[code];
  return 0;
}

static
enum XML_Error contentProcessor(XML_Parser parser,
				const char *start,
				const char *end,
				const char **endPtr)
{
  return doContent(parser, 0, encoding, start, end, endPtr);
}

static
enum XML_Error externalEntityInitProcessor(XML_Parser parser,
					   const char *start,
					   const char *end,
					   const char **endPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;
  processor = externalEntityInitProcessor2;
  return externalEntityInitProcessor2(parser, start, end, endPtr);
}

static
enum XML_Error externalEntityInitProcessor2(XML_Parser parser,
					    const char *start,
					    const char *end,
					    const char **endPtr)
{
  const char *next;
  int tok = XmlContentTok(encoding, start, end, &next);
  switch (tok) {
  case XML_TOK_BOM:
    start = next;
    break;
  case XML_TOK_PARTIAL:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_UNCLOSED_TOKEN;
  case XML_TOK_PARTIAL_CHAR:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_PARTIAL_CHAR;
  }
  processor = externalEntityInitProcessor3;
  return externalEntityInitProcessor3(parser, start, end, endPtr);
}

static
enum XML_Error externalEntityInitProcessor3(XML_Parser parser,
					    const char *start,
					    const char *end,
					    const char **endPtr)
{
  const char *next;
  int tok = XmlContentTok(encoding, start, end, &next);
  switch (tok) {
  case XML_TOK_XML_DECL:
    {
      enum XML_Error result = processXmlDecl(parser, 1, start, next);
      if (result != XML_ERROR_NONE)
	return result;
      start = next;
    }
    break;
  case XML_TOK_PARTIAL:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_UNCLOSED_TOKEN;
  case XML_TOK_PARTIAL_CHAR:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_PARTIAL_CHAR;
  }
  processor = externalEntityContentProcessor;
  tagLevel = 1;
  return doContent(parser, 1, encoding, start, end, endPtr);
}

static
enum XML_Error externalEntityContentProcessor(XML_Parser parser,
					      const char *start,
					      const char *end,
					      const char **endPtr)
{
  return doContent(parser, 1, encoding, start, end, endPtr);
}

static enum XML_Error
doContent(XML_Parser parser,
	  int startTagLevel,
	  const ENCODING *enc,
	  const char *s,
	  const char *end,
	  const char **nextPtr)
{
  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  *eventPP = s;
  for (;;) {
    const char *next = s; /* XmlContentTok doesn't always set the last arg */
    int tok = XmlContentTok(enc, s, end, &next);
    *eventEndPP = next;
    switch (tok) {
    case XML_TOK_TRAILING_CR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      *eventEndPP = end;
      if (characterDataHandler) {
	XML_Char c = 0xA;
	characterDataHandler(handlerArg, &c, 1);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, end);
      if (startTagLevel == 0)
	return XML_ERROR_NO_ELEMENTS;
      if (tagLevel != startTagLevel)
	return XML_ERROR_ASYNC_ENTITY;
      return XML_ERROR_NONE;
    case XML_TOK_NONE:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      if (startTagLevel > 0) {
	if (tagLevel != startTagLevel)
	  return XML_ERROR_ASYNC_ENTITY;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_NO_ELEMENTS;
    case XML_TOK_INVALID:
      *eventPP = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_UNCLOSED_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_PARTIAL_CHAR;
    case XML_TOK_ENTITY_REF:
      {
	const XML_Char *name;
	ENTITY *entity;
	XML_Char ch = XmlPredefinedEntityName(enc,
					      s + enc->minBytesPerChar,
					      next - enc->minBytesPerChar);
	if (ch) {
	  if (characterDataHandler)
	    characterDataHandler(handlerArg, &ch, 1);
	  else if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	  break;
	}
	name = poolStoreString(&dtd.pool, enc,
				s + enc->minBytesPerChar,
				next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.generalEntities, name, 0);
	poolDiscard(&dtd.pool);
	if (!entity) {
	  if (dtd.complete || dtd.standalone)
	    return XML_ERROR_UNDEFINED_ENTITY;
	  if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	  break;
	}
	if (entity->open)
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	if (entity->notation)
	  return XML_ERROR_BINARY_ENTITY_REF;
	if (entity) {
	  if (entity->textPtr) {
	    enum XML_Error result;
	    OPEN_INTERNAL_ENTITY openEntity;
	    if (defaultHandler && !defaultExpandInternalEntities) {
	      reportDefault(parser, enc, s, next);
	      break;
	    }
	    entity->open = 1;
	    openEntity.next = openInternalEntities;
	    openInternalEntities = &openEntity;
	    openEntity.entity = entity;
	    openEntity.internalEventPtr = 0;
	    openEntity.internalEventEndPtr = 0;
	    result = doContent(parser,
			       tagLevel,
			       internalEncoding,
			       (char *)entity->textPtr,
			       (char *)(entity->textPtr + entity->textLen),
			       0);
	    entity->open = 0;
	    openInternalEntities = openEntity.next;
	    if (result)
	      return result;
	  }
	  else if (externalEntityRefHandler) {
	    const XML_Char *context;
	    entity->open = 1;
	    context = getContext(parser);
	    entity->open = 0;
	    if (!context)
	      return XML_ERROR_NO_MEMORY;
	    if (!externalEntityRefHandler(externalEntityRefHandlerArg,
				          context,
					  entity->base,
					  entity->systemId,
					  entity->publicId))
	      return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
	    poolDiscard(&tempPool);
	  }
	  else if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	}
	break;
      }
    case XML_TOK_START_TAG_WITH_ATTS:
      if (!startElementHandler) {
	enum XML_Error result = storeAtts(parser, enc, s, 0, 0);
	if (result)
	  return result;
      }
      /* fall through */
    case XML_TOK_START_TAG_NO_ATTS:
      {
	TAG *tag;
	if (freeTagList) {
	  tag = freeTagList;
	  freeTagList = freeTagList->parent;
	}
	else {
	  tag = malloc(sizeof(TAG));
	  if (!tag)
	    return XML_ERROR_NO_MEMORY;
	  tag->buf = malloc(INIT_TAG_BUF_SIZE);
	  if (!tag->buf)
	    return XML_ERROR_NO_MEMORY;
	  tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;
	}
	tag->bindings = 0;
	tag->parent = tagStack;
	tagStack = tag;
	tag->name.localPart = 0;
	tag->rawName = s + enc->minBytesPerChar;
	tag->rawNameLength = XmlNameLength(enc, tag->rawName);
	if (nextPtr) {
	  /* Need to guarantee that:
	     tag->buf + ROUND_UP(tag->rawNameLength, sizeof(XML_Char)) <= tag->bufEnd - sizeof(XML_Char) */
	  if (tag->rawNameLength + (int)(sizeof(XML_Char) - 1) + (int)sizeof(XML_Char) > tag->bufEnd - tag->buf) {
	    int bufSize = tag->rawNameLength * 4;
	    bufSize = ROUND_UP(bufSize, sizeof(XML_Char));
	    tag->buf = realloc(tag->buf, bufSize);
	    if (!tag->buf)
	      return XML_ERROR_NO_MEMORY;
	    tag->bufEnd = tag->buf + bufSize;
	  }
	  memcpy(tag->buf, tag->rawName, tag->rawNameLength);
	  tag->rawName = tag->buf;
	}
	++tagLevel;
	if (startElementHandler) {
	  enum XML_Error result;
	  XML_Char *toPtr;
	  for (;;) {
	    const char *rawNameEnd = tag->rawName + tag->rawNameLength;
	    const char *fromPtr = tag->rawName;
	    int bufSize;
	    if (nextPtr)
	      toPtr = (XML_Char *)(tag->buf + ROUND_UP(tag->rawNameLength, sizeof(XML_Char)));
	    else
	      toPtr = (XML_Char *)tag->buf;
	    tag->name.str = toPtr;
	    XmlConvert(enc,
		       &fromPtr, rawNameEnd,
		       (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
	    if (fromPtr == rawNameEnd)
	      break;
	    bufSize = (tag->bufEnd - tag->buf) << 1;
	    tag->buf = realloc(tag->buf, bufSize);
	    if (!tag->buf)
	      return XML_ERROR_NO_MEMORY;
	    tag->bufEnd = tag->buf + bufSize;
	    if (nextPtr)
	      tag->rawName = tag->buf;
	  }
	  *toPtr = XML_T('\0');
	  result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
	  if (result)
	    return result;
	  startElementHandler(handlerArg, tag->name.str, (const XML_Char **)atts);
	  poolClear(&tempPool);
	}
	else {
	  tag->name.str = 0;
	  if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	}
	break;
      }
    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS:
      if (!startElementHandler) {
	enum XML_Error result = storeAtts(parser, enc, s, 0, 0);
	if (result)
	  return result;
      }
      /* fall through */
    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:
      if (startElementHandler || endElementHandler) {
	const char *rawName = s + enc->minBytesPerChar;
	enum XML_Error result;
	BINDING *bindings = 0;
	TAG_NAME name;
	name.str = poolStoreString(&tempPool, enc, rawName,
				   rawName + XmlNameLength(enc, rawName));
	if (!name.str)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
	result = storeAtts(parser, enc, s, &name, &bindings);
	if (result)
	  return result;
	poolFinish(&tempPool);
	if (startElementHandler)
	  startElementHandler(handlerArg, name.str, (const XML_Char **)atts);
	if (endElementHandler) {
	  if (startElementHandler)
	    *eventPP = *eventEndPP;
	  endElementHandler(handlerArg, name.str);
	}
	poolClear(&tempPool);
	while (bindings) {
	  BINDING *b = bindings;
	  if (endNamespaceDeclHandler)
	    endNamespaceDeclHandler(handlerArg, b->prefix->name);
	  bindings = bindings->nextTagBinding;
	  b->nextTagBinding = freeBindingList;
	  freeBindingList = b;
	  b->prefix->binding = b->prevPrefixBinding;
	}
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      if (tagLevel == 0)
	return epilogProcessor(parser, next, end, nextPtr);
      break;
    case XML_TOK_END_TAG:
      if (tagLevel == startTagLevel)
        return XML_ERROR_ASYNC_ENTITY;
      else {
	int len;
	const char *rawName;
	TAG *tag = tagStack;
	tagStack = tag->parent;
	tag->parent = freeTagList;
	freeTagList = tag;
	rawName = s + enc->minBytesPerChar*2;
	len = XmlNameLength(enc, rawName);
	if (len != tag->rawNameLength
	    || memcmp(tag->rawName, rawName, len) != 0) {
	  *eventPP = rawName;
	  return XML_ERROR_TAG_MISMATCH;
	}
	--tagLevel;
	if (endElementHandler && tag->name.str) {
	  if (tag->name.localPart) {
	    XML_Char *to = (XML_Char *)tag->name.str + tag->name.uriLen;
	    const XML_Char *from = tag->name.localPart;
	    while ((*to++ = *from++) != 0)
	      ;
	  }
	  endElementHandler(handlerArg, tag->name.str);
	}
	else if (defaultHandler)
	  reportDefault(parser, enc, s, next);
	while (tag->bindings) {
	  BINDING *b = tag->bindings;
	  if (endNamespaceDeclHandler)
	    endNamespaceDeclHandler(handlerArg, b->prefix->name);
	  tag->bindings = tag->bindings->nextTagBinding;
	  b->nextTagBinding = freeBindingList;
	  freeBindingList = b;
	  b->prefix->binding = b->prevPrefixBinding;
	}
	if (tagLevel == 0)
	  return epilogProcessor(parser, next, end, nextPtr);
      }
      break;
    case XML_TOK_CHAR_REF:
      {
	int n = XmlCharRefNumber(enc, s);
	if (n < 0)
	  return XML_ERROR_BAD_CHAR_REF;
	if (characterDataHandler) {
	  XML_Char buf[XML_ENCODE_MAX];
	  characterDataHandler(handlerArg, buf, XmlEncode(n, (ICHAR *)buf));
	}
	else if (defaultHandler)
	  reportDefault(parser, enc, s, next);
      }
      break;
    case XML_TOK_XML_DECL:
      return XML_ERROR_MISPLACED_XML_PI;
    case XML_TOK_DATA_NEWLINE:
      if (characterDataHandler) {
	XML_Char c = 0xA;
	characterDataHandler(handlerArg, &c, 1);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_CDATA_SECT_OPEN:
      {
	enum XML_Error result;
	if (startCdataSectionHandler)
  	  startCdataSectionHandler(handlerArg);
#if 0
	/* Suppose you doing a transformation on a document that involves
	   changing only the character data.  You set up a defaultHandler
	   and a characterDataHandler.  The defaultHandler simply copies
	   characters through.  The characterDataHandler does the transformation
	   and writes the characters out escaping them as necessary.  This case
	   will fail to work if we leave out the following two lines (because &
	   and < inside CDATA sections will be incorrectly escaped).

	   However, now we have a start/endCdataSectionHandler, so it seems
	   easier to let the user deal with this. */

	else if (characterDataHandler)
  	  characterDataHandler(handlerArg, dataBuf, 0);
#endif
	else if (defaultHandler)
	  reportDefault(parser, enc, s, next);
	result = doCdataSection(parser, enc, &next, end, nextPtr);
	if (!next) {
	  processor = cdataSectionProcessor;
	  return result;
	}
      }
      break;
    case XML_TOK_TRAILING_RSQB:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      if (characterDataHandler) {
	if (MUST_CONVERT(enc, s)) {
	  ICHAR *dataPtr = (ICHAR *)dataBuf;
	  XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
	  characterDataHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
	}
	else
	  characterDataHandler(handlerArg,
		  	       (XML_Char *)s,
			       (XML_Char *)end - (XML_Char *)s);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, end);
      if (startTagLevel == 0) {
        *eventPP = end;
	return XML_ERROR_NO_ELEMENTS;
      }
      if (tagLevel != startTagLevel) {
	*eventPP = end;
	return XML_ERROR_ASYNC_ENTITY;
      }
      return XML_ERROR_NONE;
    case XML_TOK_DATA_CHARS:
      if (characterDataHandler) {
	if (MUST_CONVERT(enc, s)) {
	  for (;;) {
	    ICHAR *dataPtr = (ICHAR *)dataBuf;
	    XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
	    *eventEndPP = s;
	    characterDataHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
	    if (s == next)
	      break;
	    *eventPP = s;
	  }
	}
	else
	  characterDataHandler(handlerArg,
			       (XML_Char *)s,
			       (XML_Char *)next - (XML_Char *)s);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_PI:
      if (!reportProcessingInstruction(parser, enc, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_COMMENT:
      if (!reportComment(parser, enc, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    default:
      if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    }
    *eventPP = s = next;
  }
  /* not reached */
}

/* If tagNamePtr is non-null, build a real list of attributes,
otherwise just check the attributes for well-formedness. */

static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *enc,
				const char *attStr, TAG_NAME *tagNamePtr,
				BINDING **bindingsPtr)
{
  ELEMENT_TYPE *elementType = 0;
  int nDefaultAtts = 0;
  const XML_Char **appAtts;
  int attIndex = 0;
  int i;
  int n;
  int nPrefixes = 0;
  BINDING *binding;
  const XML_Char *localPart;

  if (tagNamePtr) {
    elementType = (ELEMENT_TYPE *)lookup(&dtd.elementTypes, tagNamePtr->str, 0);
    if (!elementType) {
      tagNamePtr->str = poolCopyString(&dtd.pool, tagNamePtr->str);
      if (!tagNamePtr->str)
	return XML_ERROR_NO_MEMORY;
      elementType = (ELEMENT_TYPE *)lookup(&dtd.elementTypes, tagNamePtr->str, sizeof(ELEMENT_TYPE));
      if (!elementType)
        return XML_ERROR_NO_MEMORY;
      if (ns && !setElementTypePrefix(parser, elementType))
        return XML_ERROR_NO_MEMORY;
    }
    nDefaultAtts = elementType->nDefaultAtts;
  }
  n = XmlGetAttributes(enc, attStr, attsSize, atts);
  if (n + nDefaultAtts > attsSize) {
    int oldAttsSize = attsSize;
    attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
    atts = realloc((void *)atts, attsSize * sizeof(ATTRIBUTE));
    if (!atts)
      return XML_ERROR_NO_MEMORY;
    if (n > oldAttsSize)
      XmlGetAttributes(enc, attStr, n, atts);
  }
  appAtts = (const XML_Char **)atts;
  for (i = 0; i < n; i++) {
    ATTRIBUTE_ID *attId = getAttributeId(parser, enc, atts[i].name,
					 atts[i].name
					 + XmlNameLength(enc, atts[i].name));
    if (!attId)
      return XML_ERROR_NO_MEMORY;
    if ((attId->name)[-1]) {
      if (enc == encoding)
	eventPtr = atts[i].name;
      return XML_ERROR_DUPLICATE_ATTRIBUTE;
    }
    (attId->name)[-1] = 1;
    appAtts[attIndex++] = attId->name;
    if (!atts[i].normalized) {
      enum XML_Error result;
      int isCdata = 1;

      if (attId->maybeTokenized) {
	int j;
	for (j = 0; j < nDefaultAtts; j++) {
	  if (attId == elementType->defaultAtts[j].id) {
	    isCdata = elementType->defaultAtts[j].isCdata;
	    break;
	  }
	}
      }

      result = storeAttributeValue(parser, enc, isCdata,
				   atts[i].valuePtr, atts[i].valueEnd,
			           &tempPool);
      if (result)
	return result;
      if (tagNamePtr) {
	appAtts[attIndex] = poolStart(&tempPool);
	poolFinish(&tempPool);
      }
      else
	poolDiscard(&tempPool);
    }
    else if (tagNamePtr) {
      appAtts[attIndex] = poolStoreString(&tempPool, enc, atts[i].valuePtr, atts[i].valueEnd);
      if (appAtts[attIndex] == 0)
	return XML_ERROR_NO_MEMORY;
      poolFinish(&tempPool);
    }
    if (attId->prefix && tagNamePtr) {
      if (attId->xmlns) {
        if (!addBinding(parser, attId->prefix, attId, appAtts[attIndex], bindingsPtr))
          return XML_ERROR_NO_MEMORY;
        --attIndex;
      }
      else {
        attIndex++;
        nPrefixes++;
        (attId->name)[-1] = 2;
      }
    }
    else
      attIndex++;
  }
  nSpecifiedAtts = attIndex;
  if (tagNamePtr) {
    int j;
    for (j = 0; j < nDefaultAtts; j++) {
      const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + j;
      if (!(da->id->name)[-1] && da->value) {
        if (da->id->prefix) {
          if (da->id->xmlns) {
	    if (!addBinding(parser, da->id->prefix, da->id, da->value, bindingsPtr))
	      return XML_ERROR_NO_MEMORY;
	  }
          else {
	    (da->id->name)[-1] = 2;
	    nPrefixes++;
  	    appAtts[attIndex++] = da->id->name;
	    appAtts[attIndex++] = da->value;
	  }
	}
	else {
	  (da->id->name)[-1] = 1;
	  appAtts[attIndex++] = da->id->name;
	  appAtts[attIndex++] = da->value;
	}
      }
    }
    appAtts[attIndex] = 0;
  }
  i = 0;
  if (nPrefixes) {
    for (; i < attIndex; i += 2) {
      if (appAtts[i][-1] == 2) {
        ATTRIBUTE_ID *id;
        ((XML_Char *)(appAtts[i]))[-1] = 0;
	id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, appAtts[i], 0);
	if (id->prefix->binding) {
	  int j;
	  const BINDING *b = id->prefix->binding;
	  const XML_Char *s = appAtts[i];
	  for (j = 0; j < b->uriLen; j++) {
	    if (!poolAppendChar(&tempPool, b->uri[j]))
	      return XML_ERROR_NO_MEMORY;
	  }
	  while (*s++ != ':')
	    ;
	  do {
	    if (!poolAppendChar(&tempPool, *s))
	      return XML_ERROR_NO_MEMORY;
	  } while (*s++);
	  appAtts[i] = poolStart(&tempPool);
	  poolFinish(&tempPool);
	}
	if (!--nPrefixes)
	  break;
      }
      else
	((XML_Char *)(appAtts[i]))[-1] = 0;
    }
  }
  for (; i < attIndex; i += 2)
    ((XML_Char *)(appAtts[i]))[-1] = 0;
  if (!tagNamePtr)
    return XML_ERROR_NONE;
  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)
    binding->attId->name[-1] = 0;
  if (elementType->prefix) {
    binding = elementType->prefix->binding;
    if (!binding)
      return XML_ERROR_NONE;
    localPart = tagNamePtr->str;
    while (*localPart++ != XML_T(':'))
      ;
  }
  else if (dtd.defaultPrefix.binding) {
    binding = dtd.defaultPrefix.binding;
    localPart = tagNamePtr->str;
  }
  else
    return XML_ERROR_NONE;
  tagNamePtr->localPart = localPart;
  tagNamePtr->uriLen = binding->uriLen;
  i = binding->uriLen;
  do {
    if (i == binding->uriAlloc) {
      binding->uri = realloc(binding->uri, binding->uriAlloc *= 2);
      if (!binding->uri)
	return XML_ERROR_NO_MEMORY;
    }
    binding->uri[i++] = *localPart;
  } while (*localPart++);
  tagNamePtr->str = binding->uri;
  return XML_ERROR_NONE;
}

static
int addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId, const XML_Char *uri, BINDING **bindingsPtr)
{
  BINDING *b;
  int len;
  for (len = 0; uri[len]; len++)
    ;
  if (namespaceSeparator)
    len++;
  if (freeBindingList) {
    b = freeBindingList;
    if (len > b->uriAlloc) {
      b->uri = realloc(b->uri, len + EXPAND_SPARE);
      if (!b->uri)
	return 0;
      b->uriAlloc = len + EXPAND_SPARE;
    }
    freeBindingList = b->nextTagBinding;
  }
  else {
    b = malloc(sizeof(BINDING));
    if (!b)
      return 0;
    b->uri = malloc(sizeof(XML_Char) * len + EXPAND_SPARE);
    if (!b->uri) {
      free(b);
      return 0;
    }
    b->uriAlloc = len;
  }
  b->uriLen = len;
  memcpy(b->uri, uri, len * sizeof(XML_Char));
  if (namespaceSeparator)
    b->uri[len - 1] = namespaceSeparator;
  b->prefix = prefix;
  b->attId = attId;
  b->prevPrefixBinding = prefix->binding;
  if (*uri == XML_T('\0') && prefix == &dtd.defaultPrefix)
    prefix->binding = 0;
  else
    prefix->binding = b;
  b->nextTagBinding = *bindingsPtr;
  *bindingsPtr = b;
  if (startNamespaceDeclHandler)
    startNamespaceDeclHandler(handlerArg, prefix->name,
			      prefix->binding ? uri : 0);
  return 1;
}

/* The idea here is to avoid using stack for each CDATA section when
the whole file is parsed with one call. */

static
enum XML_Error cdataSectionProcessor(XML_Parser parser,
				     const char *start,
			    	     const char *end,
				     const char **endPtr)
{
  enum XML_Error result = doCdataSection(parser, encoding, &start, end, endPtr);
  if (start) {
    processor = contentProcessor;
    return contentProcessor(parser, start, end, endPtr);
  }
  return result;
}

/* startPtr gets set to non-null is the section is closed, and to null if
the section is not yet closed. */

static
enum XML_Error doCdataSection(XML_Parser parser,
			      const ENCODING *enc,
			      const char **startPtr,
			      const char *end,
			      const char **nextPtr)
{
  const char *s = *startPtr;
  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    *eventPP = s;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  *eventPP = s;
  *startPtr = 0;
  for (;;) {
    const char *next;
    int tok = XmlCdataSectionTok(enc, s, end, &next);
    *eventEndPP = next;
    switch (tok) {
    case XML_TOK_CDATA_SECT_CLOSE:
      if (endCdataSectionHandler)
	endCdataSectionHandler(handlerArg);
#if 0
      /* see comment under XML_TOK_CDATA_SECT_OPEN */
      else if (characterDataHandler)
	characterDataHandler(handlerArg, dataBuf, 0);
#endif
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      *startPtr = next;
      return XML_ERROR_NONE;
    case XML_TOK_DATA_NEWLINE:
      if (characterDataHandler) {
	XML_Char c = 0xA;
	characterDataHandler(handlerArg, &c, 1);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_DATA_CHARS:
      if (characterDataHandler) {
	if (MUST_CONVERT(enc, s)) {
	  for (;;) {
  	    ICHAR *dataPtr = (ICHAR *)dataBuf;
	    XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
	    *eventEndPP = next;
	    characterDataHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
	    if (s == next)
	      break;
	    *eventPP = s;
	  }
	}
	else
	  characterDataHandler(handlerArg,
		  	       (XML_Char *)s,
			       (XML_Char *)next - (XML_Char *)s);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_INVALID:
      *eventPP = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_PARTIAL_CHAR;
    case XML_TOK_PARTIAL:
    case XML_TOK_NONE:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_UNCLOSED_CDATA_SECTION;
    default:
      abort();
    }
    *eventPP = s = next;
  }
  /* not reached */
}

#ifdef XML_DTD

/* The idea here is to avoid using stack for each IGNORE section when
the whole file is parsed with one call. */

static
enum XML_Error ignoreSectionProcessor(XML_Parser parser,
				      const char *start,
				      const char *end,
				      const char **endPtr)
{
  enum XML_Error result = doIgnoreSection(parser, encoding, &start, end, endPtr);
  if (start) {
    processor = prologProcessor;
    return prologProcessor(parser, start, end, endPtr);
  }
  return result;
}

/* startPtr gets set to non-null is the section is closed, and to null if
the section is not yet closed. */

static
enum XML_Error doIgnoreSection(XML_Parser parser,
			       const ENCODING *enc,
			       const char **startPtr,
			       const char *end,
			       const char **nextPtr)
{
  const char *next;
  int tok;
  const char *s = *startPtr;
  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    *eventPP = s;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  *eventPP = s;
  *startPtr = 0;
  tok = XmlIgnoreSectionTok(enc, s, end, &next);
  *eventEndPP = next;
  switch (tok) {
  case XML_TOK_IGNORE_SECT:
    if (defaultHandler)
      reportDefault(parser, enc, s, next);
    *startPtr = next;
    return XML_ERROR_NONE;
  case XML_TOK_INVALID:
    *eventPP = next;
    return XML_ERROR_INVALID_TOKEN;
  case XML_TOK_PARTIAL_CHAR:
    if (nextPtr) {
      *nextPtr = s;
      return XML_ERROR_NONE;
    }
    return XML_ERROR_PARTIAL_CHAR;
  case XML_TOK_PARTIAL:
  case XML_TOK_NONE:
    if (nextPtr) {
      *nextPtr = s;
      return XML_ERROR_NONE;
    }
    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */
  default:
    abort();
  }
  /* not reached */
}

#endif /* XML_DTD */

static enum XML_Error
initializeEncoding(XML_Parser parser)
{
  const char *s;
#ifdef XML_UNICODE
  char encodingBuf[128];
  if (!protocolEncodingName)
    s = 0;
  else {
    int i;
    for (i = 0; protocolEncodingName[i]; i++) {
      if (i == sizeof(encodingBuf) - 1
	  || protocolEncodingName[i] >= 0x80
	  || protocolEncodingName[i] < 0) {
	encodingBuf[0] = '\0';
	break;
      }
      encodingBuf[i] = (char)protocolEncodingName[i];
    }
    encodingBuf[i] = '\0';
    s = encodingBuf;
  }
#else
  s = protocolEncodingName;
#endif
  if ((ns ? XmlInitEncodingNS : XmlInitEncoding)(&initEncoding, &encoding, s))
    return XML_ERROR_NONE;
  return handleUnknownEncoding(parser, protocolEncodingName);
}

static enum XML_Error
processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
	       const char *s, const char *next)
{
  const char *encodingName = 0;
  const ENCODING *newEncoding = 0;
  const char *version;
  int standalone = -1;
  if (!(ns
        ? XmlParseXmlDeclNS
	: XmlParseXmlDecl)(isGeneralTextEntity,
		           encoding,
		           s,
		           next,
		           &eventPtr,
		           &version,
		           &encodingName,
		           &newEncoding,
		           &standalone))
    return XML_ERROR_SYNTAX;
  if (!isGeneralTextEntity && standalone == 1) {
    dtd.standalone = 1;
#ifdef XML_DTD
    if (paramEntityParsing == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)
      paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
#endif /* XML_DTD */
  }
  if (defaultHandler)
    reportDefault(parser, encoding, s, next);
  if (!protocolEncodingName) {
    if (newEncoding) {
      if (newEncoding->minBytesPerChar != encoding->minBytesPerChar) {
	eventPtr = encodingName;
	return XML_ERROR_INCORRECT_ENCODING;
      }
      encoding = newEncoding;
    }
    else if (encodingName) {
      enum XML_Error result;
      const XML_Char *s = poolStoreString(&tempPool,
					  encoding,
					  encodingName,
					  encodingName
					  + XmlNameLength(encoding, encodingName));
      if (!s)
	return XML_ERROR_NO_MEMORY;
      result = handleUnknownEncoding(parser, s);
      poolDiscard(&tempPool);
      if (result == XML_ERROR_UNKNOWN_ENCODING)
	eventPtr = encodingName;
      return result;
    }
  }
  return XML_ERROR_NONE;
}

static enum XML_Error
handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName)
{
  if (unknownEncodingHandler) {
    XML_Encoding info;
    int i;
    for (i = 0; i < 256; i++)
      info.map[i] = -1;
    info.convert = 0;
    info.data = 0;
    info.release = 0;
    if (unknownEncodingHandler(unknownEncodingHandlerData, encodingName, &info)) {
      ENCODING *enc;
      unknownEncodingMem = malloc(XmlSizeOfUnknownEncoding());
      if (!unknownEncodingMem) {
	if (info.release)
	  info.release(info.data);
	return XML_ERROR_NO_MEMORY;
      }
      enc = (ns
	     ? XmlInitUnknownEncodingNS
	     : XmlInitUnknownEncoding)(unknownEncodingMem,
				       info.map,
				       info.convert,
				       info.data);
      if (enc) {
	unknownEncodingData = info.data;
	unknownEncodingRelease = info.release;
	encoding = enc;
	return XML_ERROR_NONE;
      }
    }
    if (info.release)
      info.release(info.data);
  }
  return XML_ERROR_UNKNOWN_ENCODING;
}

static enum XML_Error
prologInitProcessor(XML_Parser parser,
		    const char *s,
		    const char *end,
		    const char **nextPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;
  processor = prologProcessor;
  return prologProcessor(parser, s, end, nextPtr);
}

static enum XML_Error
prologProcessor(XML_Parser parser,
		const char *s,
		const char *end,
		const char **nextPtr)
{
  const char *next;
  int tok = XmlPrologTok(encoding, s, end, &next);
  return doProlog(parser, encoding, s, end, tok, next, nextPtr);
}

static enum XML_Error
doProlog(XML_Parser parser,
	 const ENCODING *enc,
	 const char *s,
	 const char *end,
	 int tok,
	 const char *next,
	 const char **nextPtr)
{
#ifdef XML_DTD
  static const XML_Char externalSubsetName[] = { '#' , '\0' };
#endif /* XML_DTD */

  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  for (;;) {
    int role;
    *eventPP = s;
    *eventEndPP = next;
    if (tok <= 0) {
      if (nextPtr != 0 && tok != XML_TOK_INVALID) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
	*eventPP = next;
	return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
	return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
	return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:
#ifdef XML_DTD
	if (enc != encoding)
	  return XML_ERROR_NONE;
	if (parentParser) {
	  if (XmlTokenRole(&prologState, XML_TOK_NONE, end, end, enc)
	      == XML_ROLE_ERROR)
	    return XML_ERROR_SYNTAX;
	  hadExternalDoctype = 0;
	  return XML_ERROR_NONE;
	}
#endif /* XML_DTD */
	return XML_ERROR_NO_ELEMENTS;
      default:
	tok = -tok;
	next = end;
	break;
      }
    }
    role = XmlTokenRole(&prologState, tok, s, next, enc);
    switch (role) {
    case XML_ROLE_XML_DECL:
      {
	enum XML_Error result = processXmlDecl(parser, 0, s, next);
	if (result != XML_ERROR_NONE)
	  return result;
	enc = encoding;
      }
      break;
    case XML_ROLE_DOCTYPE_NAME:
      if (startDoctypeDeclHandler) {
	const XML_Char *name = poolStoreString(&tempPool, enc, s, next);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	startDoctypeDeclHandler(handlerArg, name);
	poolClear(&tempPool);
      }
      break;
#ifdef XML_DTD
    case XML_ROLE_TEXT_DECL:
      {
	enum XML_Error result = processXmlDecl(parser, 1, s, next);
	if (result != XML_ERROR_NONE)
	  return result;
	enc = encoding;
      }
      break;
#endif /* XML_DTD */
    case XML_ROLE_DOCTYPE_PUBLIC_ID:
#ifdef XML_DTD
      declEntity = (ENTITY *)lookup(&dtd.paramEntities,
				    externalSubsetName,
				    sizeof(ENTITY));
      if (!declEntity)
	return XML_ERROR_NO_MEMORY;
#endif /* XML_DTD */
      /* fall through */
    case XML_ROLE_ENTITY_PUBLIC_ID:
      if (!XmlIsPublicId(enc, s, next, eventPP))
	return XML_ERROR_SYNTAX;
      if (declEntity) {
	XML_Char *tem = poolStoreString(&dtd.pool,
	                                enc,
					s + enc->minBytesPerChar,
	  				next - enc->minBytesPerChar);
	if (!tem)
	  return XML_ERROR_NO_MEMORY;
	normalizePublicId(tem);
	declEntity->publicId = tem;
	poolFinish(&dtd.pool);
      }
      break;
    case XML_ROLE_DOCTYPE_CLOSE:
      if (dtd.complete && hadExternalDoctype) {
	dtd.complete = 0;
#ifdef XML_DTD
	if (paramEntityParsing && externalEntityRefHandler) {
	  ENTITY *entity = (ENTITY *)lookup(&dtd.paramEntities,
					    externalSubsetName,
					    0);
	  if (!externalEntityRefHandler(externalEntityRefHandlerArg,
					0,
					entity->base,
					entity->systemId,
					entity->publicId))
	   return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
	}
#endif /* XML_DTD */
	if (!dtd.complete
	    && !dtd.standalone
	    && notStandaloneHandler
	    && !notStandaloneHandler(handlerArg))
	  return XML_ERROR_NOT_STANDALONE;
      }
      if (endDoctypeDeclHandler)
	endDoctypeDeclHandler(handlerArg);
      break;
    case XML_ROLE_INSTANCE_START:
      processor = contentProcessor;
      return contentProcessor(parser, s, end, nextPtr);
    case XML_ROLE_ATTLIST_ELEMENT_NAME:
      {
	const XML_Char *name = poolStoreString(&dtd.pool, enc, s, next);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	declElementType = (ELEMENT_TYPE *)lookup(&dtd.elementTypes, name, sizeof(ELEMENT_TYPE));
	if (!declElementType)
	  return XML_ERROR_NO_MEMORY;
	if (declElementType->name != name)
	  poolDiscard(&dtd.pool);
	else {
	  poolFinish(&dtd.pool);
	  if (!setElementTypePrefix(parser, declElementType))
            return XML_ERROR_NO_MEMORY;
	}
	break;
      }
    case XML_ROLE_ATTRIBUTE_NAME:
      declAttributeId = getAttributeId(parser, enc, s, next);
      if (!declAttributeId)
	return XML_ERROR_NO_MEMORY;
      declAttributeIsCdata = 0;
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_CDATA:
      declAttributeIsCdata = 1;
      break;
    case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:
    case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:
      if (dtd.complete
	  && !defineAttribute(declElementType, declAttributeId, declAttributeIsCdata, 0))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:
    case XML_ROLE_FIXED_ATTRIBUTE_VALUE:
      {
	const XML_Char *attVal;
	enum XML_Error result
	  = storeAttributeValue(parser, enc, declAttributeIsCdata,
				s + enc->minBytesPerChar,
			        next - enc->minBytesPerChar,
			        &dtd.pool);
	if (result)
	  return result;
	attVal = poolStart(&dtd.pool);
	poolFinish(&dtd.pool);
	if (dtd.complete
	    && !defineAttribute(declElementType, declAttributeId, declAttributeIsCdata, attVal))
	  return XML_ERROR_NO_MEMORY;
	break;
      }
    case XML_ROLE_ENTITY_VALUE:
      {
	enum XML_Error result = storeEntityValue(parser, enc,
						 s + enc->minBytesPerChar,
						 next - enc->minBytesPerChar);
	if (declEntity) {
	  declEntity->textPtr = poolStart(&dtd.pool);
	  declEntity->textLen = poolLength(&dtd.pool);
	  poolFinish(&dtd.pool);
	}
	else
	  poolDiscard(&dtd.pool);
	if (result != XML_ERROR_NONE)
	  return result;
      }
      break;
    case XML_ROLE_DOCTYPE_SYSTEM_ID:
      if (!dtd.standalone
#ifdef XML_DTD
	  && !paramEntityParsing
#endif /* XML_DTD */
	  && notStandaloneHandler
	  && !notStandaloneHandler(handlerArg))
	return XML_ERROR_NOT_STANDALONE;
      hadExternalDoctype = 1;
#ifndef XML_DTD
      break;
#else /* XML_DTD */
      if (!declEntity) {
	declEntity = (ENTITY *)lookup(&dtd.paramEntities,
				      externalSubsetName,
				      sizeof(ENTITY));
	if (!declEntity)
	  return XML_ERROR_NO_MEMORY;
      }
      /* fall through */
#endif /* XML_DTD */
    case XML_ROLE_ENTITY_SYSTEM_ID:
      if (declEntity) {
	declEntity->systemId = poolStoreString(&dtd.pool, enc,
	                                       s + enc->minBytesPerChar,
	  				       next - enc->minBytesPerChar);
	if (!declEntity->systemId)
	  return XML_ERROR_NO_MEMORY;
	declEntity->base = curBase;
	poolFinish(&dtd.pool);
      }
      break;
    case XML_ROLE_ENTITY_NOTATION_NAME:
      if (declEntity) {
	declEntity->notation = poolStoreString(&dtd.pool, enc, s, next);
	if (!declEntity->notation)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&dtd.pool);
	if (unparsedEntityDeclHandler) {
	  *eventEndPP = s;
	  unparsedEntityDeclHandler(handlerArg,
				    declEntity->name,
				    declEntity->base,
				    declEntity->systemId,
				    declEntity->publicId,
				    declEntity->notation);
	}

      }
      break;
    case XML_ROLE_GENERAL_ENTITY_NAME:
      {
	const XML_Char *name;
	if (XmlPredefinedEntityName(enc, s, next)) {
	  declEntity = 0;
	  break;
	}
	name = poolStoreString(&dtd.pool, enc, s, next);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	if (dtd.complete) {
	  declEntity = (ENTITY *)lookup(&dtd.generalEntities, name, sizeof(ENTITY));
	  if (!declEntity)
	    return XML_ERROR_NO_MEMORY;
	  if (declEntity->name != name) {
	    poolDiscard(&dtd.pool);
	    declEntity = 0;
	  }
	  else
	    poolFinish(&dtd.pool);
	}
	else {
	  poolDiscard(&dtd.pool);
	  declEntity = 0;
	}
      }
      break;
    case XML_ROLE_PARAM_ENTITY_NAME:
#ifdef XML_DTD
      if (dtd.complete) {
	const XML_Char *name = poolStoreString(&dtd.pool, enc, s, next);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	declEntity = (ENTITY *)lookup(&dtd.paramEntities, name, sizeof(ENTITY));
	if (!declEntity)
	  return XML_ERROR_NO_MEMORY;
	if (declEntity->name != name) {
	  poolDiscard(&dtd.pool);
	  declEntity = 0;
	}
	else
	  poolFinish(&dtd.pool);
      }
#else /* not XML_DTD */
      declEntity = 0;
#endif /* not XML_DTD */
      break;
    case XML_ROLE_NOTATION_NAME:
      declNotationPublicId = 0;
      declNotationName = 0;
      if (notationDeclHandler) {
	declNotationName = poolStoreString(&tempPool, enc, s, next);
	if (!declNotationName)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
      }
      break;
    case XML_ROLE_NOTATION_PUBLIC_ID:
      if (!XmlIsPublicId(enc, s, next, eventPP))
	return XML_ERROR_SYNTAX;
      if (declNotationName) {
	XML_Char *tem = poolStoreString(&tempPool,
	                                enc,
					s + enc->minBytesPerChar,
	  				next - enc->minBytesPerChar);
	if (!tem)
	  return XML_ERROR_NO_MEMORY;
	normalizePublicId(tem);
	declNotationPublicId = tem;
	poolFinish(&tempPool);
      }
      break;
    case XML_ROLE_NOTATION_SYSTEM_ID:
      if (declNotationName && notationDeclHandler) {
	const XML_Char *systemId
	  = poolStoreString(&tempPool, enc,
			    s + enc->minBytesPerChar,
	  		    next - enc->minBytesPerChar);
	if (!systemId)
	  return XML_ERROR_NO_MEMORY;
	*eventEndPP = s;
	notationDeclHandler(handlerArg,
			    declNotationName,
			    curBase,
			    systemId,
			    declNotationPublicId);
      }
      poolClear(&tempPool);
      break;
    case XML_ROLE_NOTATION_NO_SYSTEM_ID:
      if (declNotationPublicId && notationDeclHandler) {
	*eventEndPP = s;
	notationDeclHandler(handlerArg,
			    declNotationName,
			    curBase,
			    0,
			    declNotationPublicId);
      }
      poolClear(&tempPool);
      break;
    case XML_ROLE_ERROR:
      switch (tok) {
      case XML_TOK_PARAM_ENTITY_REF:
	return XML_ERROR_PARAM_ENTITY_REF;
      case XML_TOK_XML_DECL:
	return XML_ERROR_MISPLACED_XML_PI;
      default:
	return XML_ERROR_SYNTAX;
      }
#ifdef XML_DTD
    case XML_ROLE_IGNORE_SECT:
      {
	enum XML_Error result;
	if (defaultHandler)
	  reportDefault(parser, enc, s, next);
	result = doIgnoreSection(parser, enc, &next, end, nextPtr);
	if (!next) {
	  processor = ignoreSectionProcessor;
	  return result;
	}
      }
      break;
#endif /* XML_DTD */
    case XML_ROLE_GROUP_OPEN:
      if (prologState.level >= groupSize) {
	if (groupSize)
	  groupConnector = realloc(groupConnector, groupSize *= 2);
	else
	  groupConnector = malloc(groupSize = 32);
	if (!groupConnector)
	  return XML_ERROR_NO_MEMORY;
      }
      groupConnector[prologState.level] = 0;
      break;
    case XML_ROLE_GROUP_SEQUENCE:
      if (groupConnector[prologState.level] == '|')
	return XML_ERROR_SYNTAX;
      groupConnector[prologState.level] = ',';
      break;
    case XML_ROLE_GROUP_CHOICE:
      if (groupConnector[prologState.level] == ',')
	return XML_ERROR_SYNTAX;
      groupConnector[prologState.level] = '|';
      break;
    case XML_ROLE_PARAM_ENTITY_REF:
#ifdef XML_DTD
    case XML_ROLE_INNER_PARAM_ENTITY_REF:
      if (paramEntityParsing
	  && (dtd.complete || role == XML_ROLE_INNER_PARAM_ENTITY_REF)) {
	const XML_Char *name;
	ENTITY *entity;
	name = poolStoreString(&dtd.pool, enc,
				s + enc->minBytesPerChar,
				next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.paramEntities, name, 0);
	poolDiscard(&dtd.pool);
	if (!entity) {
	  /* FIXME what to do if !dtd.complete? */
	  return XML_ERROR_UNDEFINED_ENTITY;
	}
	if (entity->open)
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	if (entity->textPtr) {
	  enum XML_Error result;
	  result = processInternalParamEntity(parser, entity);
	  if (result != XML_ERROR_NONE)
	    return result;
	  break;
	}
	if (role == XML_ROLE_INNER_PARAM_ENTITY_REF)
	  return XML_ERROR_PARAM_ENTITY_REF;
	if (externalEntityRefHandler) {
	  dtd.complete = 0;
	  entity->open = 1;
	  if (!externalEntityRefHandler(externalEntityRefHandlerArg,
					0,
					entity->base,
					entity->systemId,
					entity->publicId)) {
	    entity->open = 0;
	    return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
	  }
	  entity->open = 0;
	  if (dtd.complete)
	    break;
	}
      }
#endif /* XML_DTD */
      if (!dtd.standalone
	  && notStandaloneHandler
	  && !notStandaloneHandler(handlerArg))
	return XML_ERROR_NOT_STANDALONE;
      dtd.complete = 0;
      if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_ROLE_NONE:
      switch (tok) {
      case XML_TOK_PI:
	if (!reportProcessingInstruction(parser, enc, s, next))
	  return XML_ERROR_NO_MEMORY;
	break;
      case XML_TOK_COMMENT:
	if (!reportComment(parser, enc, s, next))
	  return XML_ERROR_NO_MEMORY;
	break;
      }
      break;
    }
    if (defaultHandler) {
      switch (tok) {
      case XML_TOK_PI:
      case XML_TOK_COMMENT:
      case XML_TOK_BOM:
      case XML_TOK_XML_DECL:
#ifdef XML_DTD
      case XML_TOK_IGNORE_SECT:
#endif /* XML_DTD */
      case XML_TOK_PARAM_ENTITY_REF:
	break;
      default:
	if (role != XML_ROLE_IGNORE_SECT)
	  reportDefault(parser, enc, s, next);
      }
    }
    s = next;
    tok = XmlPrologTok(enc, s, end, &next);
  }
  /* not reached */
}

static
enum XML_Error epilogProcessor(XML_Parser parser,
			       const char *s,
			       const char *end,
			       const char **nextPtr)
{
  processor = epilogProcessor;
  eventPtr = s;
  for (;;) {
    const char *next;
    int tok = XmlPrologTok(encoding, s, end, &next);
    eventEndPtr = next;
    switch (tok) {
    case -XML_TOK_PROLOG_S:
      if (defaultHandler) {
	eventEndPtr = end;
	reportDefault(parser, encoding, s, end);
      }
      /* fall through */
    case XML_TOK_NONE:
      if (nextPtr)
	*nextPtr = end;
      return XML_ERROR_NONE;
    case XML_TOK_PROLOG_S:
      if (defaultHandler)
	reportDefault(parser, encoding, s, next);
      break;
    case XML_TOK_PI:
      if (!reportProcessingInstruction(parser, encoding, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_COMMENT:
      if (!reportComment(parser, encoding, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_INVALID:
      eventPtr = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_UNCLOSED_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_PARTIAL_CHAR;
    default:
      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;
    }
    eventPtr = s = next;
  }
}

#ifdef XML_DTD

static enum XML_Error
processInternalParamEntity(XML_Parser parser, ENTITY *entity)
{
  const char *s, *end, *next;
  int tok;
  enum XML_Error result;
  OPEN_INTERNAL_ENTITY openEntity;
  entity->open = 1;
  openEntity.next = openInternalEntities;
  openInternalEntities = &openEntity;
  openEntity.entity = entity;
  openEntity.internalEventPtr = 0;
  openEntity.internalEventEndPtr = 0;
  s = (char *)entity->textPtr;
  end = (char *)(entity->textPtr + entity->textLen);
  tok = XmlPrologTok(internalEncoding, s, end, &next);
  result = doProlog(parser, internalEncoding, s, end, tok, next, 0);
  entity->open = 0;
  openInternalEntities = openEntity.next;
  return result;
}

#endif /* XML_DTD */

static
enum XML_Error errorProcessor(XML_Parser parser,
			      const char *s,
			      const char *end,
			      const char **nextPtr)
{
  return errorCode;
}

static enum XML_Error
storeAttributeValue(XML_Parser parser, const ENCODING *enc, int isCdata,
		    const char *ptr, const char *end,
		    STRING_POOL *pool)
{
  enum XML_Error result = appendAttributeValue(parser, enc, isCdata, ptr, end, pool);
  if (result)
    return result;
  if (!isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)
    poolChop(pool);
  if (!poolAppendChar(pool, XML_T('\0')))
    return XML_ERROR_NO_MEMORY;
  return XML_ERROR_NONE;
}

static enum XML_Error
appendAttributeValue(XML_Parser parser, const ENCODING *enc, int isCdata,
		     const char *ptr, const char *end,
		     STRING_POOL *pool)
{
  for (;;) {
    const char *next;
    int tok = XmlAttributeValueTok(enc, ptr, end, &next);
    switch (tok) {
    case XML_TOK_NONE:
      return XML_ERROR_NONE;
    case XML_TOK_INVALID:
      if (enc == encoding)
	eventPtr = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      if (enc == encoding)
	eventPtr = ptr;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_CHAR_REF:
      {
	XML_Char buf[XML_ENCODE_MAX];
	int i;
	int n = XmlCharRefNumber(enc, ptr);
	if (n < 0) {
	  if (enc == encoding)
	    eventPtr = ptr;
      	  return XML_ERROR_BAD_CHAR_REF;
	}
	if (!isCdata
	    && n == 0x20 /* space */
	    && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
	  break;
	n = XmlEncode(n, (ICHAR *)buf);
	if (!n) {
	  if (enc == encoding)
	    eventPtr = ptr;
	  return XML_ERROR_BAD_CHAR_REF;
	}
	for (i = 0; i < n; i++) {
	  if (!poolAppendChar(pool, buf[i]))
	    return XML_ERROR_NO_MEMORY;
	}
      }
      break;
    case XML_TOK_DATA_CHARS:
      if (!poolAppend(pool, enc, ptr, next))
	return XML_ERROR_NO_MEMORY;
      break;
      break;
    case XML_TOK_TRAILING_CR:
      next = ptr + enc->minBytesPerChar;
      /* fall through */
    case XML_TOK_ATTRIBUTE_VALUE_S:
    case XML_TOK_DATA_NEWLINE:
      if (!isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
	break;
      if (!poolAppendChar(pool, 0x20))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_ENTITY_REF:
      {
	const XML_Char *name;
	ENTITY *entity;
	XML_Char ch = XmlPredefinedEntityName(enc,
					      ptr + enc->minBytesPerChar,
					      next - enc->minBytesPerChar);
	if (ch) {
	  if (!poolAppendChar(pool, ch))
  	    return XML_ERROR_NO_MEMORY;
	  break;
	}
	name = poolStoreString(&temp2Pool, enc,
			       ptr + enc->minBytesPerChar,
			       next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.generalEntities, name, 0);
	poolDiscard(&temp2Pool);
	if (!entity) {
	  if (dtd.complete) {
	    if (enc == encoding)
	      eventPtr = ptr;
	    return XML_ERROR_UNDEFINED_ENTITY;
	  }
	}
	else if (entity->open) {
	  if (enc == encoding)
	    eventPtr = ptr;
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	}
	else if (entity->notation) {
	  if (enc == encoding)
	    eventPtr = ptr;
	  return XML_ERROR_BINARY_ENTITY_REF;
	}
	else if (!entity->textPtr) {
	  if (enc == encoding)
	    eventPtr = ptr;
  	  return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;
	}
	else {
	  enum XML_Error result;
	  const XML_Char *textEnd = entity->textPtr + entity->textLen;
	  entity->open = 1;
	  result = appendAttributeValue(parser, internalEncoding, isCdata, (char *)entity->textPtr, (char *)textEnd, pool);
	  entity->open = 0;
	  if (result)
	    return result;
	}
      }
      break;
    default:
      abort();
    }
    ptr = next;
  }
  /* not reached */
}

static
enum XML_Error storeEntityValue(XML_Parser parser,
				const ENCODING *enc,
				const char *entityTextPtr,
				const char *entityTextEnd)
{
  STRING_POOL *pool = &(dtd.pool);
  for (;;) {
    const char *next;
    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);
    switch (tok) {
    case XML_TOK_PARAM_ENTITY_REF:
#ifdef XML_DTD
      if (parentParser || enc != encoding) {
	enum XML_Error result;
	const XML_Char *name;
	ENTITY *entity;
	name = poolStoreString(&tempPool, enc,
			       entityTextPtr + enc->minBytesPerChar,
			       next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.paramEntities, name, 0);
	poolDiscard(&tempPool);
	if (!entity) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_UNDEFINED_ENTITY;
	}
	if (entity->open) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	}
	if (entity->systemId) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_PARAM_ENTITY_REF;
	}
	entity->open = 1;
	result = storeEntityValue(parser,
				  internalEncoding,
				  (char *)entity->textPtr,
				  (char *)(entity->textPtr + entity->textLen));
	entity->open = 0;
	if (result)
	  return result;
	break;
      }
#endif /* XML_DTD */
      eventPtr = entityTextPtr;
      return XML_ERROR_SYNTAX;
    case XML_TOK_NONE:
      return XML_ERROR_NONE;
    case XML_TOK_ENTITY_REF:
    case XML_TOK_DATA_CHARS:
      if (!poolAppend(pool, enc, entityTextPtr, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_TRAILING_CR:
      next = entityTextPtr + enc->minBytesPerChar;
      /* fall through */
    case XML_TOK_DATA_NEWLINE:
      if (pool->end == pool->ptr && !poolGrow(pool))
	return XML_ERROR_NO_MEMORY;
      *(pool->ptr)++ = 0xA;
      break;
    case XML_TOK_CHAR_REF:
      {
	XML_Char buf[XML_ENCODE_MAX];
	int i;
	int n = XmlCharRefNumber(enc, entityTextPtr);
	if (n < 0) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_BAD_CHAR_REF;
	}
	n = XmlEncode(n, (ICHAR *)buf);
	if (!n) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_BAD_CHAR_REF;
	}
	for (i = 0; i < n; i++) {
	  if (pool->end == pool->ptr && !poolGrow(pool))
	    return XML_ERROR_NO_MEMORY;
	  *(pool->ptr)++ = buf[i];
	}
      }
      break;
    case XML_TOK_PARTIAL:
      if (enc == encoding)
	eventPtr = entityTextPtr;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_INVALID:
      if (enc == encoding)
	eventPtr = next;
      return XML_ERROR_INVALID_TOKEN;
    default:
      abort();
    }
    entityTextPtr = next;
  }
  /* not reached */
}

static void
normalizeLines(XML_Char *s)
{
  XML_Char *p;
  for (;; s++) {
    if (*s == XML_T('\0'))
      return;
    if (*s == 0xD)
      break;
  }
  p = s;
  do {
    if (*s == 0xD) {
      *p++ = 0xA;
      if (*++s == 0xA)
        s++;
    }
    else
      *p++ = *s++;
  } while (*s);
  *p = XML_T('\0');
}

static int
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc, const char *start, const char *end)
{
  const XML_Char *target;
  XML_Char *data;
  const char *tem;
  if (!processingInstructionHandler) {
    if (defaultHandler)
      reportDefault(parser, enc, start, end);
    return 1;
  }
  start += enc->minBytesPerChar * 2;
  tem = start + XmlNameLength(enc, start);
  target = poolStoreString(&tempPool, enc, start, tem);
  if (!target)
    return 0;
  poolFinish(&tempPool);
  data = poolStoreString(&tempPool, enc,
			XmlSkipS(enc, tem),
			end - enc->minBytesPerChar*2);
  if (!data)
    return 0;
  normalizeLines(data);
  processingInstructionHandler(handlerArg, target, data);
  poolClear(&tempPool);
  return 1;
}

static int
reportComment(XML_Parser parser, const ENCODING *enc, const char *start, const char *end)
{
  XML_Char *data;
  if (!commentHandler) {
    if (defaultHandler)
      reportDefault(parser, enc, start, end);
    return 1;
  }
  data = poolStoreString(&tempPool,
                         enc,
                         start + enc->minBytesPerChar * 4, 
			 end - enc->minBytesPerChar * 3);
  if (!data)
    return 0;
  normalizeLines(data);
  commentHandler(handlerArg, data);
  poolClear(&tempPool);
  return 1;
}

static void
reportDefault(XML_Parser parser, const ENCODING *enc, const char *s, const char *end)
{
  if (MUST_CONVERT(enc, s)) {
    const char **eventPP;
    const char **eventEndPP;
    if (enc == encoding) {
      eventPP = &eventPtr;
      eventEndPP = &eventEndPtr;
    }
    else {
      eventPP = &(openInternalEntities->internalEventPtr);
      eventEndPP = &(openInternalEntities->internalEventEndPtr);
    }
    do {
      ICHAR *dataPtr = (ICHAR *)dataBuf;
      XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
      *eventEndPP = s;
      defaultHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
      *eventPP = s;
    } while (s != end);
  }
  else
    defaultHandler(handlerArg, (XML_Char *)s, (XML_Char *)end - (XML_Char *)s);
}


static int
defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, int isCdata, const XML_Char *value)
{
  DEFAULT_ATTRIBUTE *att;
  if (value) {
    /* The handling of default attributes gets messed up if we have
       a default which duplicates a non-default. */
    int i;
    for (i = 0; i < type->nDefaultAtts; i++)
      if (attId == type->defaultAtts[i].id)
	return 1;
  }
  if (type->nDefaultAtts == type->allocDefaultAtts) {
    if (type->allocDefaultAtts == 0) {
      type->allocDefaultAtts = 8;
      type->defaultAtts = malloc(type->allocDefaultAtts*sizeof(DEFAULT_ATTRIBUTE));
    }
    else {
      type->allocDefaultAtts *= 2;
      type->defaultAtts = realloc(type->defaultAtts,
				  type->allocDefaultAtts*sizeof(DEFAULT_ATTRIBUTE));
    }
    if (!type->defaultAtts)
      return 0;
  }
  att = type->defaultAtts + type->nDefaultAtts;
  att->id = attId;
  att->value = value;
  att->isCdata = isCdata;
  if (!isCdata)
    attId->maybeTokenized = 1;
  type->nDefaultAtts += 1;
  return 1;
}

static int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
{
  const XML_Char *name;
  for (name = elementType->name; *name; name++) {
    if (*name == XML_T(':')) {
      PREFIX *prefix;
      const XML_Char *s;
      for (s = elementType->name; s != name; s++) {
	if (!poolAppendChar(&dtd.pool, *s))
	  return 0;
      }
      if (!poolAppendChar(&dtd.pool, XML_T('\0')))
	return 0;
      prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&dtd.pool), sizeof(PREFIX));
      if (!prefix)
	return 0;
      if (prefix->name == poolStart(&dtd.pool))
	poolFinish(&dtd.pool);
      else
	poolDiscard(&dtd.pool);
      elementType->prefix = prefix;

    }
  }
  return 1;
}

static ATTRIBUTE_ID *
getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start, const char *end)
{
  ATTRIBUTE_ID *id;
  const XML_Char *name;
  if (!poolAppendChar(&dtd.pool, XML_T('\0')))
    return 0;
  name = poolStoreString(&dtd.pool, enc, start, end);
  if (!name)
    return 0;
  ++name;
  id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, name, sizeof(ATTRIBUTE_ID));
  if (!id)
    return 0;
  if (id->name != name)
    poolDiscard(&dtd.pool);
  else {
    poolFinish(&dtd.pool);
    if (!ns)
      ;
    else if (name[0] == 'x'
	&& name[1] == 'm'
	&& name[2] == 'l'
	&& name[3] == 'n'
	&& name[4] == 's'
	&& (name[5] == XML_T('\0') || name[5] == XML_T(':'))) {
      if (name[5] == '\0')
	id->prefix = &dtd.defaultPrefix;
      else
	id->prefix = (PREFIX *)lookup(&dtd.prefixes, name + 6, sizeof(PREFIX));
      id->xmlns = 1;
    }
    else {
      int i;
      for (i = 0; name[i]; i++) {
	if (name[i] == XML_T(':')) {
	  int j;
	  for (j = 0; j < i; j++) {
	    if (!poolAppendChar(&dtd.pool, name[j]))
	      return 0;
	  }
	  if (!poolAppendChar(&dtd.pool, XML_T('\0')))
	    return 0;
	  id->prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&dtd.pool), sizeof(PREFIX));
	  if (id->prefix->name == poolStart(&dtd.pool))
	    poolFinish(&dtd.pool);
	  else
	    poolDiscard(&dtd.pool);
	  break;
	}
      }
    }
  }
  return id;
}

#define CONTEXT_SEP XML_T('\f')

static
const XML_Char *getContext(XML_Parser parser)
{
  HASH_TABLE_ITER iter;
  int needSep = 0;

  if (dtd.defaultPrefix.binding) {
    int i;
    int len;
    if (!poolAppendChar(&tempPool, XML_T('=')))
      return 0;
    len = dtd.defaultPrefix.binding->uriLen;
    if (namespaceSeparator != XML_T('\0'))
      len--;
    for (i = 0; i < len; i++)
      if (!poolAppendChar(&tempPool, dtd.defaultPrefix.binding->uri[i]))
  	return 0;
    needSep = 1;
  }

  hashTableIterInit(&iter, &(dtd.prefixes));
  for (;;) {
    int i;
    int len;
    const XML_Char *s;
    PREFIX *prefix = (PREFIX *)hashTableIterNext(&iter);
    if (!prefix)
      break;
    if (!prefix->binding)
      continue;
    if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
      return 0;
    for (s = prefix->name; *s; s++)
      if (!poolAppendChar(&tempPool, *s))
        return 0;
    if (!poolAppendChar(&tempPool, XML_T('=')))
      return 0;
    len = prefix->binding->uriLen;
    if (namespaceSeparator != XML_T('\0'))
      len--;
    for (i = 0; i < len; i++)
      if (!poolAppendChar(&tempPool, prefix->binding->uri[i]))
        return 0;
    needSep = 1;
  }


  hashTableIterInit(&iter, &(dtd.generalEntities));
  for (;;) {
    const XML_Char *s;
    ENTITY *e = (ENTITY *)hashTableIterNext(&iter);
    if (!e)
      break;
    if (!e->open)
      continue;
    if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
      return 0;
    for (s = e->name; *s; s++)
      if (!poolAppendChar(&tempPool, *s))
        return 0;
    needSep = 1;
  }

  if (!poolAppendChar(&tempPool, XML_T('\0')))
    return 0;
  return tempPool.start;
}

static
int setContext(XML_Parser parser, const XML_Char *context)
{
  const XML_Char *s = context;

  while (*context != XML_T('\0')) {
    if (*s == CONTEXT_SEP || *s == XML_T('\0')) {
      ENTITY *e;
      if (!poolAppendChar(&tempPool, XML_T('\0')))
	return 0;
      e = (ENTITY *)lookup(&dtd.generalEntities, poolStart(&tempPool), 0);
      if (e)
	e->open = 1;
      if (*s != XML_T('\0'))
	s++;
      context = s;
      poolDiscard(&tempPool);
    }
    else if (*s == '=') {
      PREFIX *prefix;
      if (poolLength(&tempPool) == 0)
	prefix = &dtd.defaultPrefix;
      else {
	if (!poolAppendChar(&tempPool, XML_T('\0')))
	  return 0;
	prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&tempPool), sizeof(PREFIX));
	if (!prefix)
	  return 0;
        if (prefix->name == poolStart(&tempPool))
          poolFinish(&tempPool);
        else
	  poolDiscard(&tempPool);
      }
      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\0'); context++)
        if (!poolAppendChar(&tempPool, *context))
          return 0;
      if (!poolAppendChar(&tempPool, XML_T('\0')))
	return 0;
      if (!addBinding(parser, prefix, 0, poolStart(&tempPool), &inheritedBindings))
	return 0;
      poolDiscard(&tempPool);
      if (*context != XML_T('\0'))
	++context;
      s = context;
    }
    else {
      if (!poolAppendChar(&tempPool, *s))
	return 0;
      s++;
    }
  }
  return 1;
}


static
void normalizePublicId(XML_Char *publicId)
{
  XML_Char *p = publicId;
  XML_Char *s;
  for (s = publicId; *s; s++) {
    switch (*s) {
    case 0x20:
    case 0xD:
    case 0xA:
      if (p != publicId && p[-1] != 0x20)
	*p++ = 0x20;
      break;
    default:
      *p++ = *s;
    }
  }
  if (p != publicId && p[-1] == 0x20)
    --p;
  *p = XML_T('\0');
}

static int dtdInit(DTD *p)
{
  poolInit(&(p->pool));
  hashTableInit(&(p->generalEntities));
  hashTableInit(&(p->elementTypes));
  hashTableInit(&(p->attributeIds));
  hashTableInit(&(p->prefixes));
  p->complete = 1;
  p->standalone = 0;
#ifdef XML_DTD
  hashTableInit(&(p->paramEntities));
#endif /* XML_DTD */
  p->defaultPrefix.name = 0;
  p->defaultPrefix.binding = 0;
  return 1;
}

#ifdef XML_DTD

static void dtdSwap(DTD *p1, DTD *p2)
{
  DTD tem;
  memcpy(&tem, p1, sizeof(DTD));
  memcpy(p1, p2, sizeof(DTD));
  memcpy(p2, &tem, sizeof(DTD));
}

#endif /* XML_DTD */

static void dtdDestroy(DTD *p)
{
  HASH_TABLE_ITER iter;
  hashTableIterInit(&iter, &(p->elementTypes));
  for (;;) {
    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    if (!e)
      break;
    if (e->allocDefaultAtts != 0)
      free(e->defaultAtts);
  }
  hashTableDestroy(&(p->generalEntities));
#ifdef XML_DTD
  hashTableDestroy(&(p->paramEntities));
#endif /* XML_DTD */
  hashTableDestroy(&(p->elementTypes));
  hashTableDestroy(&(p->attributeIds));
  hashTableDestroy(&(p->prefixes));
  poolDestroy(&(p->pool));
}

/* Do a deep copy of the DTD.  Return 0 for out of memory; non-zero otherwise.
The new DTD has already been initialized. */

static int dtdCopy(DTD *newDtd, const DTD *oldDtd)
{
  HASH_TABLE_ITER iter;

  /* Copy the prefix table. */

  hashTableIterInit(&iter, &(oldDtd->prefixes));
  for (;;) {
    const XML_Char *name;
    const PREFIX *oldP = (PREFIX *)hashTableIterNext(&iter);
    if (!oldP)
      break;
    name = poolCopyString(&(newDtd->pool), oldP->name);
    if (!name)
      return 0;
    if (!lookup(&(newDtd->prefixes), name, sizeof(PREFIX)))
      return 0;
  }

  hashTableIterInit(&iter, &(oldDtd->attributeIds));

  /* Copy the attribute id table. */

  for (;;) {
    ATTRIBUTE_ID *newA;
    const XML_Char *name;
    const ATTRIBUTE_ID *oldA = (ATTRIBUTE_ID *)hashTableIterNext(&iter);

    if (!oldA)
      break;
    /* Remember to allocate the scratch byte before the name. */
    if (!poolAppendChar(&(newDtd->pool), XML_T('\0')))
      return 0;
    name = poolCopyString(&(newDtd->pool), oldA->name);
    if (!name)
      return 0;
    ++name;
    newA = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), name, sizeof(ATTRIBUTE_ID));
    if (!newA)
      return 0;
    newA->maybeTokenized = oldA->maybeTokenized;
    if (oldA->prefix) {
      newA->xmlns = oldA->xmlns;
      if (oldA->prefix == &oldDtd->defaultPrefix)
	newA->prefix = &newDtd->defaultPrefix;
      else
	newA->prefix = (PREFIX *)lookup(&(newDtd->prefixes), oldA->prefix->name, 0);
    }
  }

  /* Copy the element type table. */

  hashTableIterInit(&iter, &(oldDtd->elementTypes));

  for (;;) {
    int i;
    ELEMENT_TYPE *newE;
    const XML_Char *name;
    const ELEMENT_TYPE *oldE = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    if (!oldE)
      break;
    name = poolCopyString(&(newDtd->pool), oldE->name);
    if (!name)
      return 0;
    newE = (ELEMENT_TYPE *)lookup(&(newDtd->elementTypes), name, sizeof(ELEMENT_TYPE));
    if (!newE)
      return 0;
    if (oldE->nDefaultAtts) {
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)malloc(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
      if (!newE->defaultAtts)
	return 0;
    }
    newE->allocDefaultAtts = newE->nDefaultAtts = oldE->nDefaultAtts;
    if (oldE->prefix)
      newE->prefix = (PREFIX *)lookup(&(newDtd->prefixes), oldE->prefix->name, 0);
    for (i = 0; i < newE->nDefaultAtts; i++) {
      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);
      newE->defaultAtts[i].isCdata = oldE->defaultAtts[i].isCdata;
      if (oldE->defaultAtts[i].value) {
	newE->defaultAtts[i].value = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);
	if (!newE->defaultAtts[i].value)
  	  return 0;
      }
      else
	newE->defaultAtts[i].value = 0;
    }
  }

  /* Copy the entity tables. */
  if (!copyEntityTable(&(newDtd->generalEntities),
		       &(newDtd->pool),
		       &(oldDtd->generalEntities)))
      return 0;

#ifdef XML_DTD
  if (!copyEntityTable(&(newDtd->paramEntities),
		       &(newDtd->pool),
		       &(oldDtd->paramEntities)))
      return 0;
#endif /* XML_DTD */

  newDtd->complete = oldDtd->complete;
  newDtd->standalone = oldDtd->standalone;
  return 1;
}

static int copyEntityTable(HASH_TABLE *newTable,
			   STRING_POOL *newPool,
			   const HASH_TABLE *oldTable)
{
  HASH_TABLE_ITER iter;
  const XML_Char *cachedOldBase = 0;
  const XML_Char *cachedNewBase = 0;

  hashTableIterInit(&iter, oldTable);

  for (;;) {
    ENTITY *newE;
    const XML_Char *name;
    const ENTITY *oldE = (ENTITY *)hashTableIterNext(&iter);
    if (!oldE)
      break;
    name = poolCopyString(newPool, oldE->name);
    if (!name)
      return 0;
    newE = (ENTITY *)lookup(newTable, name, sizeof(ENTITY));
    if (!newE)
      return 0;
    if (oldE->systemId) {
      const XML_Char *tem = poolCopyString(newPool, oldE->systemId);
      if (!tem)
	return 0;
      newE->systemId = tem;
      if (oldE->base) {
	if (oldE->base == cachedOldBase)
	  newE->base = cachedNewBase;
	else {
	  cachedOldBase = oldE->base;
	  tem = poolCopyString(newPool, cachedOldBase);
	  if (!tem)
	    return 0;
	  cachedNewBase = newE->base = tem;
	}
      }
    }
    else {
      const XML_Char *tem = poolCopyStringN(newPool, oldE->textPtr, oldE->textLen);
      if (!tem)
	return 0;
      newE->textPtr = tem;
      newE->textLen = oldE->textLen;
    }
    if (oldE->notation) {
      const XML_Char *tem = poolCopyString(newPool, oldE->notation);
      if (!tem)
	return 0;
      newE->notation = tem;
    }
  }
  return 1;
}

static
void poolInit(STRING_POOL *pool)
{
  pool->blocks = 0;
  pool->freeBlocks = 0;
  pool->start = 0;
  pool->ptr = 0;
  pool->end = 0;
}

static
void poolClear(STRING_POOL *pool)
{
  if (!pool->freeBlocks)
    pool->freeBlocks = pool->blocks;
  else {
    BLOCK *p = pool->blocks;
    while (p) {
      BLOCK *tem = p->next;
      p->next = pool->freeBlocks;
      pool->freeBlocks = p;
      p = tem;
    }
  }
  pool->blocks = 0;
  pool->start = 0;
  pool->ptr = 0;
  pool->end = 0;
}

static
void poolDestroy(STRING_POOL *pool)
{
  BLOCK *p = pool->blocks;
  while (p) {
    BLOCK *tem = p->next;
    free(p);
    p = tem;
  }
  pool->blocks = 0;
  p = pool->freeBlocks;
  while (p) {
    BLOCK *tem = p->next;
    free(p);
    p = tem;
  }
  pool->freeBlocks = 0;
  pool->ptr = 0;
  pool->start = 0;
  pool->end = 0;
}

static
XML_Char *poolAppend(STRING_POOL *pool, const ENCODING *enc,
		     const char *ptr, const char *end)
{
  if (!pool->ptr && !poolGrow(pool))
    return 0;
  for (;;) {
    XmlConvert(enc, &ptr, end, (ICHAR **)&(pool->ptr), (ICHAR *)pool->end);
    if (ptr == end)
      break;
    if (!poolGrow(pool))
      return 0;
  }
  return pool->start;
}

static const XML_Char *poolCopyString(STRING_POOL *pool, const XML_Char *s)
{
  do {
    if (!poolAppendChar(pool, *s))
      return 0;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}

static const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
{
  if (!pool->ptr && !poolGrow(pool))
    return 0;
  for (; n > 0; --n, s++) {
    if (!poolAppendChar(pool, *s))
      return 0;

  }
  s = pool->start;
  poolFinish(pool);
  return s;
}

static
XML_Char *poolStoreString(STRING_POOL *pool, const ENCODING *enc,
			  const char *ptr, const char *end)
{
  if (!poolAppend(pool, enc, ptr, end))
    return 0;
  if (pool->ptr == pool->end && !poolGrow(pool))
    return 0;
  *(pool->ptr)++ = 0;
  return pool->start;
}

static
int poolGrow(STRING_POOL *pool)
{
  if (pool->freeBlocks) {
    if (pool->start == 0) {
      pool->blocks = pool->freeBlocks;
      pool->freeBlocks = pool->freeBlocks->next;
      pool->blocks->next = 0;
      pool->start = pool->blocks->s;
      pool->end = pool->start + pool->blocks->size;
      pool->ptr = pool->start;
      return 1;
    }
    if (pool->end - pool->start < pool->freeBlocks->size) {
      BLOCK *tem = pool->freeBlocks->next;
      pool->freeBlocks->next = pool->blocks;
      pool->blocks = pool->freeBlocks;
      pool->freeBlocks = tem;
      memcpy(pool->blocks->s, pool->start, (pool->end - pool->start) * sizeof(XML_Char));
      pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
      pool->start = pool->blocks->s;
      pool->end = pool->start + pool->blocks->size;
      return 1;
    }
  }
  if (pool->blocks && pool->start == pool->blocks->s) {
    int blockSize = (pool->end - pool->start)*2;
    pool->blocks = realloc(pool->blocks, offsetof(BLOCK, s) + blockSize * sizeof(XML_Char));
    if (!pool->blocks)
      return 0;
    pool->blocks->size = blockSize;
    pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
    pool->start = pool->blocks->s;
    pool->end = pool->start + blockSize;
  }
  else {
    BLOCK *tem;
    int blockSize = pool->end - pool->start;
    if (blockSize < INIT_BLOCK_SIZE)
      blockSize = INIT_BLOCK_SIZE;
    else
      blockSize *= 2;
    tem = malloc(offsetof(BLOCK, s) + blockSize * sizeof(XML_Char));
    if (!tem)
      return 0;
    tem->size = blockSize;
    tem->next = pool->blocks;
    pool->blocks = tem;
    memcpy(tem->s, pool->start, (pool->ptr - pool->start) * sizeof(XML_Char));
    pool->ptr = tem->s + (pool->ptr - pool->start);
    pool->start = tem->s;
    pool->end = tem->s + blockSize;
  }
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\latin1tab.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

/* 0x80 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x84 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x88 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x8C */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x90 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x94 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x98 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0x9C */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0xA0 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0xA4 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0xA8 */ BT_OTHER, BT_OTHER, BT_NMSTRT, BT_OTHER,
/* 0xAC */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0xB0 */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0xB4 */ BT_OTHER, BT_NMSTRT, BT_OTHER, BT_NAME,
/* 0xB8 */ BT_OTHER, BT_OTHER, BT_NMSTRT, BT_OTHER,
/* 0xBC */ BT_OTHER, BT_OTHER, BT_OTHER, BT_OTHER,
/* 0xC0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xC4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xC8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xCC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xD0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xD4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
/* 0xD8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xDC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xE0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xE4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xE8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xEC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xF0 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xF4 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_OTHER,
/* 0xF8 */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
/* 0xFC */ BT_NMSTRT, BT_NMSTRT, BT_NMSTRT, BT_NMSTRT,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\nametab.h ===
static const unsigned namingBitmap[] = {
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
0x00000000, 0x04000000, 0x87FFFFFE, 0x07FFFFFE,
0x00000000, 0x00000000, 0xFF7FFFFF, 0xFF7FFFFF,
0xFFFFFFFF, 0x7FF3FFFF, 0xFFFFFDFE, 0x7FFFFFFF,
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFE00F, 0xFC31FFFF,
0x00FFFFFF, 0x00000000, 0xFFFF0000, 0xFFFFFFFF,
0xFFFFFFFF, 0xF80001FF, 0x00000003, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0xFFFFD740, 0xFFFFFFFB, 0x547F7FFF, 0x000FFFFD,
0xFFFFDFFE, 0xFFFFFFFF, 0xDFFEFFFF, 0xFFFFFFFF,
0xFFFF0003, 0xFFFFFFFF, 0xFFFF199F, 0x033FCFFF,
0x00000000, 0xFFFE0000, 0x027FFFFF, 0xFFFFFFFE,
0x0000007F, 0x00000000, 0xFFFF0000, 0x000707FF,
0x00000000, 0x07FFFFFE, 0x000007FE, 0xFFFE0000,
0xFFFFFFFF, 0x7CFFFFFF, 0x002F7FFF, 0x00000060,
0xFFFFFFE0, 0x23FFFFFF, 0xFF000000, 0x00000003,
0xFFF99FE0, 0x03C5FDFF, 0xB0000000, 0x00030003,
0xFFF987E0, 0x036DFDFF, 0x5E000000, 0x001C0000,
0xFFFBAFE0, 0x23EDFDFF, 0x00000000, 0x00000001,
0xFFF99FE0, 0x23CDFDFF, 0xB0000000, 0x00000003,
0xD63DC7E0, 0x03BFC718, 0x00000000, 0x00000000,
0xFFFDDFE0, 0x03EFFDFF, 0x00000000, 0x00000003,
0xFFFDDFE0, 0x03EFFDFF, 0x40000000, 0x00000003,
0xFFFDDFE0, 0x03FFFDFF, 0x00000000, 0x00000003,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0xFFFFFFFE, 0x000D7FFF, 0x0000003F, 0x00000000,
0xFEF02596, 0x200D6CAE, 0x0000001F, 0x00000000,
0x00000000, 0x00000000, 0xFFFFFEFF, 0x000003FF,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0xFFFFFFFF, 0xFFFF003F, 0x007FFFFF,
0x0007DAED, 0x50000000, 0x82315001, 0x002C62AB,
0x40000000, 0xF580C900, 0x00000007, 0x02010800,
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
0x0FFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x03FFFFFF,
0x3F3FFFFF, 0xFFFFFFFF, 0xAAFF3F3F, 0x3FFFFFFF,
0xFFFFFFFF, 0x5FDFFFFF, 0x0FCF1FDC, 0x1FDC1FFF,
0x00000000, 0x00004C40, 0x00000000, 0x00000000,
0x00000007, 0x00000000, 0x00000000, 0x00000000,
0x00000080, 0x000003FE, 0xFFFFFFFE, 0xFFFFFFFF,
0x001FFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0x07FFFFFF,
0xFFFFFFE0, 0x00001FFF, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
0xFFFFFFFF, 0x0000003F, 0x00000000, 0x00000000,
0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
0xFFFFFFFF, 0x0000000F, 0x00000000, 0x00000000,
0x00000000, 0x07FF6000, 0x87FFFFFE, 0x07FFFFFE,
0x00000000, 0x00800000, 0xFF7FFFFF, 0xFF7FFFFF,
0x00FFFFFF, 0x00000000, 0xFFFF0000, 0xFFFFFFFF,
0xFFFFFFFF, 0xF80001FF, 0x00030003, 0x00000000,
0xFFFFFFFF, 0xFFFFFFFF, 0x0000003F, 0x00000003,
0xFFFFD7C0, 0xFFFFFFFB, 0x547F7FFF, 0x000FFFFD,
0xFFFFDFFE, 0xFFFFFFFF, 0xDFFEFFFF, 0xFFFFFFFF,
0xFFFF007B, 0xFFFFFFFF, 0xFFFF199F, 0x033FCFFF,
0x00000000, 0xFFFE0000, 0x027FFFFF, 0xFFFFFFFE,
0xFFFE007F, 0xBBFFFFFB, 0xFFFF0016, 0x000707FF,
0x00000000, 0x07FFFFFE, 0x0007FFFF, 0xFFFF03FF,
0xFFFFFFFF, 0x7CFFFFFF, 0xFFEF7FFF, 0x03FF3DFF,
0xFFFFFFEE, 0xF3FFFFFF, 0xFF1E3FFF, 0x0000FFCF,
0xFFF99FEE, 0xD3C5FDFF, 0xB080399F, 0x0003FFCF,
0xFFF987E4, 0xD36DFDFF, 0x5E003987, 0x001FFFC0,
0xFFFBAFEE, 0xF3EDFDFF, 0x00003BBF, 0x0000FFC1,
0xFFF99FEE, 0xF3CDFDFF, 0xB0C0398F, 0x0000FFC3,
0xD63DC7EC, 0xC3BFC718, 0x00803DC7, 0x0000FF80,
0xFFFDDFEE, 0xC3EFFDFF, 0x00603DDF, 0x0000FFC3,
0xFFFDDFEC, 0xC3EFFDFF, 0x40603DDF, 0x0000FFC3,
0xFFFDDFEC, 0xC3FFFDFF, 0x00803DCF, 0x0000FFC3,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0xFFFFFFFE, 0x07FF7FFF, 0x03FF7FFF, 0x00000000,
0xFEF02596, 0x3BFF6CAE, 0x03FF3F5F, 0x00000000,
0x03000000, 0xC2A003FF, 0xFFFFFEFF, 0xFFFE03FF,
0xFEBF0FDF, 0x02FE3FFF, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x1FFF0000, 0x00000002,
0x000000A0, 0x003EFFFE, 0xFFFFFFFE, 0xFFFFFFFF,
0x661FFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0x77FFFFFF,
};
static const unsigned char nmstrtPages[] = {
0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00,
0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x13,
0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x15, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x17,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x18,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const unsigned char namePages[] = {
0x19, 0x03, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x00,
0x00, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x13,
0x26, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x27, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x17,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x18,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\utf8tab.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/


/* 0x80 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x84 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x88 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x8C */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x90 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x94 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x98 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0x9C */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xA0 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xA4 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xA8 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xAC */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xB0 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xB4 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xB8 */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xBC */ BT_TRAIL, BT_TRAIL, BT_TRAIL, BT_TRAIL,
/* 0xC0 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xC4 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xC8 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xCC */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xD0 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xD4 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xD8 */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xDC */ BT_LEAD2, BT_LEAD2, BT_LEAD2, BT_LEAD2,
/* 0xE0 */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
/* 0xE4 */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
/* 0xE8 */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
/* 0xEC */ BT_LEAD3, BT_LEAD3, BT_LEAD3, BT_LEAD3,
/* 0xF0 */ BT_LEAD4, BT_LEAD4, BT_LEAD4, BT_LEAD4,
/* 0xF4 */ BT_LEAD4, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0xF8 */ BT_NONXML, BT_NONXML, BT_NONXML, BT_NONXML,
/* 0xFC */ BT_NONXML, BT_NONXML, BT_MALFORM, BT_MALFORM,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmldef.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include <string.h>

#ifdef XML_WINLIB

#define WIN32_LEAN_AND_MEAN
#define STRICT
#include <windows.h>

#define malloc(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define calloc(x, y) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (x)*(y))
#define free(x) HeapFree(GetProcessHeap(), 0, (x))
#define realloc(x, y) HeapReAlloc(GetProcessHeap(), 0, x, y)
#define abort() /* as nothing */

#else /* not XML_WINLIB */

#include <stdlib.h>

#endif /* not XML_WINLIB */

/* This file can be used for any definitions needed in
particular environments. */

#ifdef MOZILLA

#include "nspr.h"
#define malloc(x) PR_Malloc(x)
#define realloc(x, y) PR_Realloc((x), (y))
#define calloc(x, y) PR_Calloc((x),(y))
#define free(x) PR_Free(x)
#define int int32

#endif /* MOZILLA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmltok.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include "xmldef.h"
#include "xmltok.h"
#include "nametab.h"

#ifdef XML_DTD
#define IGNORE_SECTION_TOK_VTABLE , PREFIX(ignoreSectionTok)
#else
#define IGNORE_SECTION_TOK_VTABLE /* as nothing */
#endif

#define VTABLE1 \
  { PREFIX(prologTok), PREFIX(contentTok), \
    PREFIX(cdataSectionTok) IGNORE_SECTION_TOK_VTABLE }, \
  { PREFIX(attributeValueTok), PREFIX(entityValueTok) }, \
  PREFIX(sameName), \
  PREFIX(nameMatchesAscii), \
  PREFIX(nameLength), \
  PREFIX(skipS), \
  PREFIX(getAtts), \
  PREFIX(charRefNumber), \
  PREFIX(predefinedEntityName), \
  PREFIX(updatePosition), \
  PREFIX(isPublicId)

#define VTABLE VTABLE1, PREFIX(toUtf8), PREFIX(toUtf16)

#define UCS2_GET_NAMING(pages, hi, lo) \
   (namingBitmap[(pages[hi] << 3) + ((lo) >> 5)] & (1 << ((lo) & 0x1F)))

/* A 2 byte UTF-8 representation splits the characters 11 bits
between the bottom 5 and 6 bits of the bytes.
We need 8 bits to index into pages, 3 bits to add to that index and
5 bits to generate the mask. */
#define UTF8_GET_NAMING2(pages, byte) \
    (namingBitmap[((pages)[(((byte)[0]) >> 2) & 7] << 3) \
                      + ((((byte)[0]) & 3) << 1) \
                      + ((((byte)[1]) >> 5) & 1)] \
         & (1 << (((byte)[1]) & 0x1F)))

/* A 3 byte UTF-8 representation splits the characters 16 bits
between the bottom 4, 6 and 6 bits of the bytes.
We need 8 bits to index into pages, 3 bits to add to that index and
5 bits to generate the mask. */
#define UTF8_GET_NAMING3(pages, byte) \
  (namingBitmap[((pages)[((((byte)[0]) & 0xF) << 4) \
                             + ((((byte)[1]) >> 2) & 0xF)] \
		       << 3) \
                      + ((((byte)[1]) & 3) << 1) \
                      + ((((byte)[2]) >> 5) & 1)] \
         & (1 << (((byte)[2]) & 0x1F)))

#define UTF8_GET_NAMING(pages, p, n) \
  ((n) == 2 \
  ? UTF8_GET_NAMING2(pages, (const unsigned char *)(p)) \
  : ((n) == 3 \
     ? UTF8_GET_NAMING3(pages, (const unsigned char *)(p)) \
     : 0))

#define UTF8_INVALID3(p) \
  ((*p) == 0xED \
  ? (((p)[1] & 0x20) != 0) \
  : ((*p) == 0xEF \
     ? ((p)[1] == 0xBF && ((p)[2] == 0xBF || (p)[2] == 0xBE)) \
     : 0))

#define UTF8_INVALID4(p) ((*p) == 0xF4 && ((p)[1] & 0x30) != 0)

static
int isNever(const ENCODING *enc, const char *p)
{
  return 0;
}

static
int utf8_isName2(const ENCODING *enc, const char *p)
{
  return UTF8_GET_NAMING2(namePages, (const unsigned char *)p);
}

static
int utf8_isName3(const ENCODING *enc, const char *p)
{
  return UTF8_GET_NAMING3(namePages, (const unsigned char *)p);
}

#define utf8_isName4 isNever

static
int utf8_isNmstrt2(const ENCODING *enc, const char *p)
{
  return UTF8_GET_NAMING2(nmstrtPages, (const unsigned char *)p);
}

static
int utf8_isNmstrt3(const ENCODING *enc, const char *p)
{
  return UTF8_GET_NAMING3(nmstrtPages, (const unsigned char *)p);
}

#define utf8_isNmstrt4 isNever

#define utf8_isInvalid2 isNever

static
int utf8_isInvalid3(const ENCODING *enc, const char *p)
{
  return UTF8_INVALID3((const unsigned char *)p);
}

static
int utf8_isInvalid4(const ENCODING *enc, const char *p)
{
  return UTF8_INVALID4((const unsigned char *)p);
}

struct normal_encoding {
  ENCODING enc;
  unsigned char type[256];
#ifdef XML_MIN_SIZE
  int (*byteType)(const ENCODING *, const char *);
  int (*isNameMin)(const ENCODING *, const char *);
  int (*isNmstrtMin)(const ENCODING *, const char *);
  int (*byteToAscii)(const ENCODING *, const char *);
  int (*charMatches)(const ENCODING *, const char *, int);
#endif /* XML_MIN_SIZE */
  int (*isName2)(const ENCODING *, const char *);
  int (*isName3)(const ENCODING *, const char *);
  int (*isName4)(const ENCODING *, const char *);
  int (*isNmstrt2)(const ENCODING *, const char *);
  int (*isNmstrt3)(const ENCODING *, const char *);
  int (*isNmstrt4)(const ENCODING *, const char *);
  int (*isInvalid2)(const ENCODING *, const char *);
  int (*isInvalid3)(const ENCODING *, const char *);
  int (*isInvalid4)(const ENCODING *, const char *);
};

#ifdef XML_MIN_SIZE

#define STANDARD_VTABLE(E) \
 E ## byteType, \
 E ## isNameMin, \
 E ## isNmstrtMin, \
 E ## byteToAscii, \
 E ## charMatches,

#else

#define STANDARD_VTABLE(E) /* as nothing */

#endif

#define NORMAL_VTABLE(E) \
 E ## isName2, \
 E ## isName3, \
 E ## isName4, \
 E ## isNmstrt2, \
 E ## isNmstrt3, \
 E ## isNmstrt4, \
 E ## isInvalid2, \
 E ## isInvalid3, \
 E ## isInvalid4

static int checkCharRefNumber(int);

#include "xmltok_impl.h"

#ifdef XML_MIN_SIZE
#define sb_isNameMin isNever
#define sb_isNmstrtMin isNever
#endif

#ifdef XML_MIN_SIZE
#define MINBPC(enc) ((enc)->minBytesPerChar)
#else
/* minimum bytes per character */
#define MINBPC(enc) 1
#endif

#define SB_BYTE_TYPE(enc, p) \
  (((struct normal_encoding *)(enc))->type[(unsigned char)*(p)])

#ifdef XML_MIN_SIZE
static
int sb_byteType(const ENCODING *enc, const char *p)
{
  return SB_BYTE_TYPE(enc, p);
}
#define BYTE_TYPE(enc, p) \
 (((const struct normal_encoding *)(enc))->byteType(enc, p))
#else
#define BYTE_TYPE(enc, p) SB_BYTE_TYPE(enc, p)
#endif

#ifdef XML_MIN_SIZE
#define BYTE_TO_ASCII(enc, p) \
 (((const struct normal_encoding *)(enc))->byteToAscii(enc, p))
static
int sb_byteToAscii(const ENCODING *enc, const char *p)
{
  return *p;
}
#else
#define BYTE_TO_ASCII(enc, p) (*p)
#endif

#define IS_NAME_CHAR(enc, p, n) \
 (((const struct normal_encoding *)(enc))->isName ## n(enc, p))
#define IS_NMSTRT_CHAR(enc, p, n) \
 (((const struct normal_encoding *)(enc))->isNmstrt ## n(enc, p))
#define IS_INVALID_CHAR(enc, p, n) \
 (((const struct normal_encoding *)(enc))->isInvalid ## n(enc, p))

#ifdef XML_MIN_SIZE
#define IS_NAME_CHAR_MINBPC(enc, p) \
 (((const struct normal_encoding *)(enc))->isNameMin(enc, p))
#define IS_NMSTRT_CHAR_MINBPC(enc, p) \
 (((const struct normal_encoding *)(enc))->isNmstrtMin(enc, p))
#else
#define IS_NAME_CHAR_MINBPC(enc, p) (0)
#define IS_NMSTRT_CHAR_MINBPC(enc, p) (0)
#endif

#ifdef XML_MIN_SIZE
#define CHAR_MATCHES(enc, p, c) \
 (((const struct normal_encoding *)(enc))->charMatches(enc, p, c))
static
int sb_charMatches(const ENCODING *enc, const char *p, int c)
{
  return *p == c;
}
#else
/* c is an ASCII character */
#define CHAR_MATCHES(enc, p, c) (*(p) == c)
#endif

#define PREFIX(ident) normal_ ## ident
#include "xmltok_impl.c"

#undef MINBPC
#undef BYTE_TYPE
#undef BYTE_TO_ASCII
#undef CHAR_MATCHES
#undef IS_NAME_CHAR
#undef IS_NAME_CHAR_MINBPC
#undef IS_NMSTRT_CHAR
#undef IS_NMSTRT_CHAR_MINBPC
#undef IS_INVALID_CHAR

enum {  /* UTF8_cvalN is value of masked first byte of N byte sequence */
  UTF8_cval1 = 0x00,
  UTF8_cval2 = 0xc0,
  UTF8_cval3 = 0xe0,
  UTF8_cval4 = 0xf0
};

static
void utf8_toUtf8(const ENCODING *enc,
		 const char **fromP, const char *fromLim,
		 char **toP, const char *toLim)
{
  char *to;
  const char *from;
  if (fromLim - *fromP > toLim - *toP) {
    /* Avoid copying partial characters. */
    for (fromLim = *fromP + (toLim - *toP); fromLim > *fromP; fromLim--)
      if (((unsigned char)fromLim[-1] & 0xc0) != 0x80)
	break;
  }
  for (to = *toP, from = *fromP; from != fromLim; from++, to++)
    *to = *from;
  *fromP = from;
  *toP = to;
}

static
void utf8_toUtf16(const ENCODING *enc,
		  const char **fromP, const char *fromLim,
		  unsigned short **toP, const unsigned short *toLim)
{
  unsigned short *to = *toP;
  const char *from = *fromP;
  while (from != fromLim && to != toLim) {
    switch (((struct normal_encoding *)enc)->type[(unsigned char)*from]) {
    case BT_LEAD2:
      *to++ = ((from[0] & 0x1f) << 6) | (from[1] & 0x3f);
      from += 2;
      break;
    case BT_LEAD3:
      *to++ = ((from[0] & 0xf) << 12) | ((from[1] & 0x3f) << 6) | (from[2] & 0x3f);
      from += 3;
      break;
    case BT_LEAD4:
      {
	unsigned long n;
	if (to + 1 == toLim)
	  break;
	n = ((from[0] & 0x7) << 18) | ((from[1] & 0x3f) << 12) | ((from[2] & 0x3f) << 6) | (from[3] & 0x3f);
	n -= 0x10000;
	to[0] = (unsigned short)((n >> 10) | 0xD800);
	to[1] = (unsigned short)((n & 0x3FF) | 0xDC00);
	to += 2;
	from += 4;
      }
      break;
    default:
      *to++ = *from++;
      break;
    }
  }
  *fromP = from;
  *toP = to;
}

#ifdef XML_NS
static const struct normal_encoding utf8_encoding_ns = {
  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
  {
#include "asciitab.h"
#include "utf8tab.h"
  },
  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
};
#endif

static const struct normal_encoding utf8_encoding = {
  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
  {
#define BT_COLON BT_NMSTRT
#include "asciitab.h"
#undef BT_COLON
#include "utf8tab.h"
  },
  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
};

#ifdef XML_NS

static const struct normal_encoding internal_utf8_encoding_ns = {
  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
  {
#include "iasciitab.h"
#include "utf8tab.h"
  },
  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
};

#endif

static const struct normal_encoding internal_utf8_encoding = {
  { VTABLE1, utf8_toUtf8, utf8_toUtf16, 1, 1, 0 },
  {
#define BT_COLON BT_NMSTRT
#include "iasciitab.h"
#undef BT_COLON
#include "utf8tab.h"
  },
  STANDARD_VTABLE(sb_) NORMAL_VTABLE(utf8_)
};

static
void latin1_toUtf8(const ENCODING *enc,
		   const char **fromP, const char *fromLim,
		   char **toP, const char *toLim)
{
  for (;;) {
    unsigned char c;
    if (*fromP == fromLim)
      break;
    c = (unsigned char)**fromP;
    if (c & 0x80) {
      if (toLim - *toP < 2)
	break;
      *(*toP)++ = ((c >> 6) | UTF8_cval2);
      *(*toP)++ = ((c & 0x3f) | 0x80);
      (*fromP)++;
    }
    else {
      if (*toP == toLim)
	break;
      *(*toP)++ = *(*fromP)++;
    }
  }
}

static
void latin1_toUtf16(const ENCODING *enc,
		    const char **fromP, const char *fromLim,
		    unsigned short **toP, const unsigned short *toLim)
{
  while (*fromP != fromLim && *toP != toLim)
    *(*toP)++ = (unsigned char)*(*fromP)++;
}

#ifdef XML_NS

static const struct normal_encoding latin1_encoding_ns = {
  { VTABLE1, latin1_toUtf8, latin1_toUtf16, 1, 0, 0 },
  {
#include "asciitab.h"
#include "latin1tab.h"
  },
  STANDARD_VTABLE(sb_)
};

#endif

static const struct normal_encoding latin1_encoding = {
  { VTABLE1, latin1_toUtf8, latin1_toUtf16, 1, 0, 0 },
  {
#define BT_COLON BT_NMSTRT
#include "asciitab.h"
#undef BT_COLON
#include "latin1tab.h"
  },
  STANDARD_VTABLE(sb_)
};

static
void ascii_toUtf8(const ENCODING *enc,
		  const char **fromP, const char *fromLim,
		  char **toP, const char *toLim)
{
  while (*fromP != fromLim && *toP != toLim)
    *(*toP)++ = *(*fromP)++;
}

#ifdef XML_NS

static const struct normal_encoding ascii_encoding_ns = {
  { VTABLE1, ascii_toUtf8, latin1_toUtf16, 1, 1, 0 },
  {
#include "asciitab.h"
/* BT_NONXML == 0 */
  },
  STANDARD_VTABLE(sb_)
};

#endif

static const struct normal_encoding ascii_encoding = {
  { VTABLE1, ascii_toUtf8, latin1_toUtf16, 1, 1, 0 },
  {
#define BT_COLON BT_NMSTRT
#include "asciitab.h"
#undef BT_COLON
/* BT_NONXML == 0 */
  },
  STANDARD_VTABLE(sb_)
};

static int unicode_byte_type(char hi, char lo)
{
  switch ((unsigned char)hi) {
  case 0xD8: case 0xD9: case 0xDA: case 0xDB:
    return BT_LEAD4;
  case 0xDC: case 0xDD: case 0xDE: case 0xDF:
    return BT_TRAIL;
  case 0xFF:
    switch ((unsigned char)lo) {
    case 0xFF:
    case 0xFE:
      return BT_NONXML;
    }
    break;
  }
  return BT_NONASCII;
}

#define DEFINE_UTF16_TO_UTF8(E) \
static \
void E ## toUtf8(const ENCODING *enc, \
		 const char **fromP, const char *fromLim, \
		 char **toP, const char *toLim) \
{ \
  const char *from; \
  for (from = *fromP; from != fromLim; from += 2) { \
    int plane; \
    unsigned char lo2; \
    unsigned char lo = GET_LO(from); \
    unsigned char hi = GET_HI(from); \
    switch (hi) { \
    case 0: \
      if (lo < 0x80) { \
        if (*toP == toLim) { \
          *fromP = from; \
	  return; \
        } \
        *(*toP)++ = lo; \
        break; \
      } \
      /* fall through */ \
    case 0x1: case 0x2: case 0x3: \
    case 0x4: case 0x5: case 0x6: case 0x7: \
      if (toLim -  *toP < 2) { \
        *fromP = from; \
	return; \
      } \
      *(*toP)++ = ((lo >> 6) | (hi << 2) |  UTF8_cval2); \
      *(*toP)++ = ((lo & 0x3f) | 0x80); \
      break; \
    default: \
      if (toLim -  *toP < 3)  { \
        *fromP = from; \
	return; \
      } \
      /* 16 bits divided 4, 6, 6 amongst 3 bytes */ \
      *(*toP)++ = ((hi >> 4) | UTF8_cval3); \
      *(*toP)++ = (((hi & 0xf) << 2) | (lo >> 6) | 0x80); \
      *(*toP)++ = ((lo & 0x3f) | 0x80); \
      break; \
    case 0xD8: case 0xD9: case 0xDA: case 0xDB: \
      if (toLim -  *toP < 4) { \
	*fromP = from; \
	return; \
      } \
      plane = (((hi & 0x3) << 2) | ((lo >> 6) & 0x3)) + 1; \
      *(*toP)++ = ((plane >> 2) | UTF8_cval4); \
      *(*toP)++ = (((lo >> 2) & 0xF) | ((plane & 0x3) << 4) | 0x80); \
      from += 2; \
      lo2 = GET_LO(from); \
      *(*toP)++ = (((lo & 0x3) << 4) \
	           | ((GET_HI(from) & 0x3) << 2) \
		   | (lo2 >> 6) \
		   | 0x80); \
      *(*toP)++ = ((lo2 & 0x3f) | 0x80); \
      break; \
    } \
  } \
  *fromP = from; \
}

#define DEFINE_UTF16_TO_UTF16(E) \
static \
void E ## toUtf16(const ENCODING *enc, \
		  const char **fromP, const char *fromLim, \
		  unsigned short **toP, const unsigned short *toLim) \
{ \
  /* Avoid copying first half only of surrogate */ \
  if (fromLim - *fromP > ((toLim - *toP) << 1) \
      && (GET_HI(fromLim - 2) & 0xF8) == 0xD8) \
    fromLim -= 2; \
  for (; *fromP != fromLim && *toP != toLim; *fromP += 2) \
    *(*toP)++ = (GET_HI(*fromP) << 8) | GET_LO(*fromP); \
}

#define SET2(ptr, ch) \
  (((ptr)[0] = ((ch) & 0xff)), ((ptr)[1] = ((ch) >> 8)))
#define GET_LO(ptr) ((unsigned char)(ptr)[0])
#define GET_HI(ptr) ((unsigned char)(ptr)[1])

DEFINE_UTF16_TO_UTF8(little2_)
DEFINE_UTF16_TO_UTF16(little2_)

#undef SET2
#undef GET_LO
#undef GET_HI

#define SET2(ptr, ch) \
  (((ptr)[0] = ((ch) >> 8)), ((ptr)[1] = ((ch) & 0xFF)))
#define GET_LO(ptr) ((unsigned char)(ptr)[1])
#define GET_HI(ptr) ((unsigned char)(ptr)[0])

DEFINE_UTF16_TO_UTF8(big2_)
DEFINE_UTF16_TO_UTF16(big2_)

#undef SET2
#undef GET_LO
#undef GET_HI

#define LITTLE2_BYTE_TYPE(enc, p) \
 ((p)[1] == 0 \
  ? ((struct normal_encoding *)(enc))->type[(unsigned char)*(p)] \
  : unicode_byte_type((p)[1], (p)[0]))
#define LITTLE2_BYTE_TO_ASCII(enc, p) ((p)[1] == 0 ? (p)[0] : -1)
#define LITTLE2_CHAR_MATCHES(enc, p, c) ((p)[1] == 0 && (p)[0] == c)
#define LITTLE2_IS_NAME_CHAR_MINBPC(enc, p) \
  UCS2_GET_NAMING(namePages, (unsigned char)p[1], (unsigned char)p[0])
#define LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p) \
  UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[1], (unsigned char)p[0])

#ifdef XML_MIN_SIZE

static
int little2_byteType(const ENCODING *enc, const char *p)
{
  return LITTLE2_BYTE_TYPE(enc, p);
}

static
int little2_byteToAscii(const ENCODING *enc, const char *p)
{
  return LITTLE2_BYTE_TO_ASCII(enc, p);
}

static
int little2_charMatches(const ENCODING *enc, const char *p, int c)
{
  return LITTLE2_CHAR_MATCHES(enc, p, c);
}

static
int little2_isNameMin(const ENCODING *enc, const char *p)
{
  return LITTLE2_IS_NAME_CHAR_MINBPC(enc, p);
}

static
int little2_isNmstrtMin(const ENCODING *enc, const char *p)
{
  return LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p);
}

#undef VTABLE
#define VTABLE VTABLE1, little2_toUtf8, little2_toUtf16

#else /* not XML_MIN_SIZE */

#undef PREFIX
#define PREFIX(ident) little2_ ## ident
#define MINBPC(enc) 2
/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
#define BYTE_TYPE(enc, p) LITTLE2_BYTE_TYPE(enc, p)
#define BYTE_TO_ASCII(enc, p) LITTLE2_BYTE_TO_ASCII(enc, p) 
#define CHAR_MATCHES(enc, p, c) LITTLE2_CHAR_MATCHES(enc, p, c)
#define IS_NAME_CHAR(enc, p, n) 0
#define IS_NAME_CHAR_MINBPC(enc, p) LITTLE2_IS_NAME_CHAR_MINBPC(enc, p)
#define IS_NMSTRT_CHAR(enc, p, n) (0)
#define IS_NMSTRT_CHAR_MINBPC(enc, p) LITTLE2_IS_NMSTRT_CHAR_MINBPC(enc, p)

#include "xmltok_impl.c"

#undef MINBPC
#undef BYTE_TYPE
#undef BYTE_TO_ASCII
#undef CHAR_MATCHES
#undef IS_NAME_CHAR
#undef IS_NAME_CHAR_MINBPC
#undef IS_NMSTRT_CHAR
#undef IS_NMSTRT_CHAR_MINBPC
#undef IS_INVALID_CHAR

#endif /* not XML_MIN_SIZE */

#ifdef XML_NS

static const struct normal_encoding little2_encoding_ns = { 
  { VTABLE, 2, 0,
#if XML_BYTE_ORDER == 12
    1
#else
    0
#endif
  },
  {
#include "asciitab.h"
#include "latin1tab.h"
  },
  STANDARD_VTABLE(little2_)
};

#endif

static const struct normal_encoding little2_encoding = { 
  { VTABLE, 2, 0,
#if XML_BYTE_ORDER == 12
    1
#else
    0
#endif
  },
  {
#define BT_COLON BT_NMSTRT
#include "asciitab.h"
#undef BT_COLON
#include "latin1tab.h"
  },
  STANDARD_VTABLE(little2_)
};

#if XML_BYTE_ORDER != 21

#ifdef XML_NS

static const struct normal_encoding internal_little2_encoding_ns = { 
  { VTABLE, 2, 0, 1 },
  {
#include "iasciitab.h"
#include "latin1tab.h"
  },
  STANDARD_VTABLE(little2_)
};

#endif

static const struct normal_encoding internal_little2_encoding = { 
  { VTABLE, 2, 0, 1 },
  {
#define BT_COLON BT_NMSTRT
#include "iasciitab.h"
#undef BT_COLON
#include "latin1tab.h"
  },
  STANDARD_VTABLE(little2_)
};

#endif


#define BIG2_BYTE_TYPE(enc, p) \
 ((p)[0] == 0 \
  ? ((struct normal_encoding *)(enc))->type[(unsigned char)(p)[1]] \
  : unicode_byte_type((p)[0], (p)[1]))
#define BIG2_BYTE_TO_ASCII(enc, p) ((p)[0] == 0 ? (p)[1] : -1)
#define BIG2_CHAR_MATCHES(enc, p, c) ((p)[0] == 0 && (p)[1] == c)
#define BIG2_IS_NAME_CHAR_MINBPC(enc, p) \
  UCS2_GET_NAMING(namePages, (unsigned char)p[0], (unsigned char)p[1])
#define BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p) \
  UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[0], (unsigned char)p[1])

#ifdef XML_MIN_SIZE

static
int big2_byteType(const ENCODING *enc, const char *p)
{
  return BIG2_BYTE_TYPE(enc, p);
}

static
int big2_byteToAscii(const ENCODING *enc, const char *p)
{
  return BIG2_BYTE_TO_ASCII(enc, p);
}

static
int big2_charMatches(const ENCODING *enc, const char *p, int c)
{
  return BIG2_CHAR_MATCHES(enc, p, c);
}

static
int big2_isNameMin(const ENCODING *enc, const char *p)
{
  return BIG2_IS_NAME_CHAR_MINBPC(enc, p);
}

static
int big2_isNmstrtMin(const ENCODING *enc, const char *p)
{
  return BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p);
}

#undef VTABLE
#define VTABLE VTABLE1, big2_toUtf8, big2_toUtf16

#else /* not XML_MIN_SIZE */

#undef PREFIX
#define PREFIX(ident) big2_ ## ident
#define MINBPC(enc) 2
/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
#define BYTE_TYPE(enc, p) BIG2_BYTE_TYPE(enc, p)
#define BYTE_TO_ASCII(enc, p) BIG2_BYTE_TO_ASCII(enc, p) 
#define CHAR_MATCHES(enc, p, c) BIG2_CHAR_MATCHES(enc, p, c)
#define IS_NAME_CHAR(enc, p, n) 0
#define IS_NAME_CHAR_MINBPC(enc, p) BIG2_IS_NAME_CHAR_MINBPC(enc, p)
#define IS_NMSTRT_CHAR(enc, p, n) (0)
#define IS_NMSTRT_CHAR_MINBPC(enc, p) BIG2_IS_NMSTRT_CHAR_MINBPC(enc, p)

#include "xmltok_impl.c"

#undef MINBPC
#undef BYTE_TYPE
#undef BYTE_TO_ASCII
#undef CHAR_MATCHES
#undef IS_NAME_CHAR
#undef IS_NAME_CHAR_MINBPC
#undef IS_NMSTRT_CHAR
#undef IS_NMSTRT_CHAR_MINBPC
#undef IS_INVALID_CHAR

#endif /* not XML_MIN_SIZE */

#ifdef XML_NS

static const struct normal_encoding big2_encoding_ns = {
  { VTABLE, 2, 0,
#if XML_BYTE_ORDER == 21
  1
#else
  0
#endif
  },
  {
#include "asciitab.h"
#include "latin1tab.h"
  },
  STANDARD_VTABLE(big2_)
};

#endif

static const struct normal_encoding big2_encoding = {
  { VTABLE, 2, 0,
#if XML_BYTE_ORDER == 21
  1
#else
  0
#endif
  },
  {
#define BT_COLON BT_NMSTRT
#include "asciitab.h"
#undef BT_COLON
#include "latin1tab.h"
  },
  STANDARD_VTABLE(big2_)
};

#if XML_BYTE_ORDER != 12

#ifdef XML_NS

static const struct normal_encoding internal_big2_encoding_ns = {
  { VTABLE, 2, 0, 1 },
  {
#include "iasciitab.h"
#include "latin1tab.h"
  },
  STANDARD_VTABLE(big2_)
};

#endif

static const struct normal_encoding internal_big2_encoding = {
  { VTABLE, 2, 0, 1 },
  {
#define BT_COLON BT_NMSTRT
#include "iasciitab.h"
#undef BT_COLON
#include "latin1tab.h"
  },
  STANDARD_VTABLE(big2_)
};

#endif

#undef PREFIX

static
int streqci(const char *s1, const char *s2)
{
  for (;;) {
    char c1 = *s1++;
    char c2 = *s2++;
    if ('a' <= c1 && c1 <= 'z')
      c1 += 'A' - 'a';
    if ('a' <= c2 && c2 <= 'z')
      c2 += 'A' - 'a';
    if (c1 != c2)
      return 0;
    if (!c1)
      break;
  }
  return 1;
}

static
void initUpdatePosition(const ENCODING *enc, const char *ptr,
			const char *end, POSITION *pos)
{
  normal_updatePosition(&utf8_encoding.enc, ptr, end, pos);
}

static
int toAscii(const ENCODING *enc, const char *ptr, const char *end)
{
  char buf[1];
  char *p = buf;
  XmlUtf8Convert(enc, &ptr, end, &p, p + 1);
  if (p == buf)
    return -1;
  else
    return buf[0];
}

static
int isSpace(int c)
{
  switch (c) {
  case 0x20:
  case 0xD:
  case 0xA:
  case 0x9:	
    return 1;
  }
  return 0;
}

/* Return 1 if there's just optional white space
or there's an S followed by name=val. */
static
int parsePseudoAttribute(const ENCODING *enc,
			 const char *ptr,
			 const char *end,
			 const char **namePtr,
			 const char **nameEndPtr,
			 const char **valPtr,
			 const char **nextTokPtr)
{
  int c;
  char open;
  if (ptr == end) {
    *namePtr = 0;
    return 1;
  }
  if (!isSpace(toAscii(enc, ptr, end))) {
    *nextTokPtr = ptr;
    return 0;
  }
  do {
    ptr += enc->minBytesPerChar;
  } while (isSpace(toAscii(enc, ptr, end)));
  if (ptr == end) {
    *namePtr = 0;
    return 1;
  }
  *namePtr = ptr;
  for (;;) {
    c = toAscii(enc, ptr, end);
    if (c == -1) {
      *nextTokPtr = ptr;
      return 0;
    }
    if (c == '=') {
      *nameEndPtr = ptr;
      break;
    }
    if (isSpace(c)) {
      *nameEndPtr = ptr;
      do {
	ptr += enc->minBytesPerChar;
      } while (isSpace(c = toAscii(enc, ptr, end)));
      if (c != '=') {
	*nextTokPtr = ptr;
	return 0;
      }
      break;
    }
    ptr += enc->minBytesPerChar;
  }
  if (ptr == *namePtr) {
    *nextTokPtr = ptr;
    return 0;
  }
  ptr += enc->minBytesPerChar;
  c = toAscii(enc, ptr, end);
  while (isSpace(c)) {
    ptr += enc->minBytesPerChar;
    c = toAscii(enc, ptr, end);
  }
  if (c != '"' && c != '\'') {
    *nextTokPtr = ptr;
    return 0;
  }
  open = c;
  ptr += enc->minBytesPerChar;
  *valPtr = ptr;
  for (;; ptr += enc->minBytesPerChar) {
    c = toAscii(enc, ptr, end);
    if (c == open)
      break;
    if (!('a' <= c && c <= 'z')
	&& !('A' <= c && c <= 'Z')
	&& !('0' <= c && c <= '9')
	&& c != '.'
	&& c != '-'
	&& c != '_') {
      *nextTokPtr = ptr;
      return 0;
    }
  }
  *nextTokPtr = ptr + enc->minBytesPerChar;
  return 1;
}

static
int doParseXmlDecl(const ENCODING *(*encodingFinder)(const ENCODING *,
		                                     const char *,
						     const char *),
		   int isGeneralTextEntity,
		   const ENCODING *enc,
		   const char *ptr,
		   const char *end,
		   const char **badPtr,
		   const char **versionPtr,
		   const char **encodingName,
		   const ENCODING **encoding,
		   int *standalone)
{
  const char *val = 0;
  const char *name = 0;
  const char *nameEnd = 0;
  ptr += 5 * enc->minBytesPerChar;
  end -= 2 * enc->minBytesPerChar;
  if (!parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr) || !name) {
    *badPtr = ptr;
    return 0;
  }
  if (!XmlNameMatchesAscii(enc, name, nameEnd, "version")) {
    if (!isGeneralTextEntity) {
      *badPtr = name;
      return 0;
    }
  }
  else {
    if (versionPtr)
      *versionPtr = val;
    if (!parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)) {
      *badPtr = ptr;
      return 0;
    }
    if (!name) {
      if (isGeneralTextEntity) {
	/* a TextDecl must have an EncodingDecl */
	*badPtr = ptr;
	return 0;
      }
      return 1;
    }
  }
  if (XmlNameMatchesAscii(enc, name, nameEnd, "encoding")) {
    int c = toAscii(enc, val, end);
    if (!('a' <= c && c <= 'z') && !('A' <= c && c <= 'Z')) {
      *badPtr = val;
      return 0;
    }
    if (encodingName)
      *encodingName = val;
    if (encoding)
      *encoding = encodingFinder(enc, val, ptr - enc->minBytesPerChar);
    if (!parsePseudoAttribute(enc, ptr, end, &name, &nameEnd, &val, &ptr)) {
      *badPtr = ptr;
      return 0;
    }
    if (!name)
      return 1;
  }
  if (!XmlNameMatchesAscii(enc, name, nameEnd, "standalone") || isGeneralTextEntity) {
    *badPtr = name;
    return 0;
  }
  if (XmlNameMatchesAscii(enc, val, ptr - enc->minBytesPerChar, "yes")) {
    if (standalone)
      *standalone = 1;
  }
  else if (XmlNameMatchesAscii(enc, val, ptr - enc->minBytesPerChar, "no")) {
    if (standalone)
      *standalone = 0;
  }
  else {
    *badPtr = val;
    return 0;
  }
  while (isSpace(toAscii(enc, ptr, end)))
    ptr += enc->minBytesPerChar;
  if (ptr != end) {
    *badPtr = ptr;
    return 0;
  }
  return 1;
}

static
int checkCharRefNumber(int result)
{
  switch (result >> 8) {
  case 0xD8: case 0xD9: case 0xDA: case 0xDB:
  case 0xDC: case 0xDD: case 0xDE: case 0xDF:
    return -1;
  case 0:
    if (latin1_encoding.type[result] == BT_NONXML)
      return -1;
    break;
  case 0xFF:
    if (result == 0xFFFE || result == 0xFFFF)
      return -1;
    break;
  }
  return result;
}

int XmlUtf8Encode(int c, char *buf)
{
  enum {
    /* minN is minimum legal resulting value for N byte sequence */
    min2 = 0x80,
    min3 = 0x800,
    min4 = 0x10000
  };

  if (c < 0)
    return 0;
  if (c < min2) {
    buf[0] = (c | UTF8_cval1);
    return 1;
  }
  if (c < min3) {
    buf[0] = ((c >> 6) | UTF8_cval2);
    buf[1] = ((c & 0x3f) | 0x80);
    return 2;
  }
  if (c < min4) {
    buf[0] = ((c >> 12) | UTF8_cval3);
    buf[1] = (((c >> 6) & 0x3f) | 0x80);
    buf[2] = ((c & 0x3f) | 0x80);
    return 3;
  }
  if (c < 0x110000) {
    buf[0] = ((c >> 18) | UTF8_cval4);
    buf[1] = (((c >> 12) & 0x3f) | 0x80);
    buf[2] = (((c >> 6) & 0x3f) | 0x80);
    buf[3] = ((c & 0x3f) | 0x80);
    return 4;
  }
  return 0;
}

int XmlUtf16Encode(int charNum, unsigned short *buf)
{
  if (charNum < 0)
    return 0;
  if (charNum < 0x10000) {
    buf[0] = charNum;
    return 1;
  }
  if (charNum < 0x110000) {
    charNum -= 0x10000;
    buf[0] = (charNum >> 10) + 0xD800;
    buf[1] = (charNum & 0x3FF) + 0xDC00;
    return 2;
  }
  return 0;
}

struct unknown_encoding {
  struct normal_encoding normal;
  int (*convert)(void *userData, const char *p);
  void *userData;
  unsigned short utf16[256];
  char utf8[256][4];
};

int XmlSizeOfUnknownEncoding(void)
{
  return sizeof(struct unknown_encoding);
}

static
int unknown_isName(const ENCODING *enc, const char *p)
{
  int c = ((const struct unknown_encoding *)enc)
	  ->convert(((const struct unknown_encoding *)enc)->userData, p);
  if (c & ~0xFFFF)
    return 0;
  return UCS2_GET_NAMING(namePages, c >> 8, c & 0xFF);
}

static
int unknown_isNmstrt(const ENCODING *enc, const char *p)
{
  int c = ((const struct unknown_encoding *)enc)
	  ->convert(((const struct unknown_encoding *)enc)->userData, p);
  if (c & ~0xFFFF)
    return 0;
  return UCS2_GET_NAMING(nmstrtPages, c >> 8, c & 0xFF);
}

static
int unknown_isInvalid(const ENCODING *enc, const char *p)
{
  int c = ((const struct unknown_encoding *)enc)
	   ->convert(((const struct unknown_encoding *)enc)->userData, p);
  return (c & ~0xFFFF) || checkCharRefNumber(c) < 0;
}

static
void unknown_toUtf8(const ENCODING *enc,
		    const char **fromP, const char *fromLim,
		    char **toP, const char *toLim)
{
  char buf[XML_UTF8_ENCODE_MAX];
  for (;;) {
    const char *utf8;
    int n;
    if (*fromP == fromLim)
      break;
    utf8 = ((const struct unknown_encoding *)enc)->utf8[(unsigned char)**fromP];
    n = *utf8++;
    if (n == 0) {
      int c = ((const struct unknown_encoding *)enc)
	      ->convert(((const struct unknown_encoding *)enc)->userData, *fromP);
      n = XmlUtf8Encode(c, buf);
      if (n > toLim - *toP)
	break;
      utf8 = buf;
      *fromP += ((const struct normal_encoding *)enc)->type[(unsigned char)**fromP]
	         - (BT_LEAD2 - 2);
    }
    else {
      if (n > toLim - *toP)
	break;
      (*fromP)++;
    }
    do {
      *(*toP)++ = *utf8++;
    } while (--n != 0);
  }
}

static
void unknown_toUtf16(const ENCODING *enc,
		     const char **fromP, const char *fromLim,
		     unsigned short **toP, const unsigned short *toLim)
{
  while (*fromP != fromLim && *toP != toLim) {
    unsigned short c
      = ((const struct unknown_encoding *)enc)->utf16[(unsigned char)**fromP];
    if (c == 0) {
      c = (unsigned short)((const struct unknown_encoding *)enc)
	   ->convert(((const struct unknown_encoding *)enc)->userData, *fromP);
      *fromP += ((const struct normal_encoding *)enc)->type[(unsigned char)**fromP]
	         - (BT_LEAD2 - 2);
    }
    else
      (*fromP)++;
    *(*toP)++ = c;
  }
}

ENCODING *
XmlInitUnknownEncoding(void *mem,
		       int *table,
		       int (*convert)(void *userData, const char *p),
		       void *userData)
{
  int i;
  struct unknown_encoding *e = mem;
  for (i = 0; i < sizeof(struct normal_encoding); i++)
    ((char *)mem)[i] = ((char *)&latin1_encoding)[i];
  for (i = 0; i < 128; i++)
    if (latin1_encoding.type[i] != BT_OTHER
        && latin1_encoding.type[i] != BT_NONXML
	&& table[i] != i)
      return 0;
  for (i = 0; i < 256; i++) {
    int c = table[i];
    if (c == -1) {
      e->normal.type[i] = BT_MALFORM;
      /* This shouldn't really get used. */
      e->utf16[i] = 0xFFFF;
      e->utf8[i][0] = 1;
      e->utf8[i][1] = 0;
    }
    else if (c < 0) {
      if (c < -4)
	return 0;
      e->normal.type[i] = BT_LEAD2 - (c + 2);
      e->utf8[i][0] = 0;
      e->utf16[i] = 0;
    }
    else if (c < 0x80) {
      if (latin1_encoding.type[c] != BT_OTHER
	  && latin1_encoding.type[c] != BT_NONXML
	  && c != i)
	return 0;
      e->normal.type[i] = latin1_encoding.type[c];
      e->utf8[i][0] = 1;
      e->utf8[i][1] = (char)c;
      e->utf16[i] = c == 0 ? 0xFFFF : c;
    }
    else if (checkCharRefNumber(c) < 0) {
      e->normal.type[i] = BT_NONXML;
      /* This shouldn't really get used. */
      e->utf16[i] = 0xFFFF;
      e->utf8[i][0] = 1;
      e->utf8[i][1] = 0;
    }
    else {
      if (c > 0xFFFF)
	return 0;
      if (UCS2_GET_NAMING(nmstrtPages, c >> 8, c & 0xff))
	e->normal.type[i] = BT_NMSTRT;
      else if (UCS2_GET_NAMING(namePages, c >> 8, c & 0xff))
	e->normal.type[i] = BT_NAME;
      else
	e->normal.type[i] = BT_OTHER;
      e->utf8[i][0] = (char)XmlUtf8Encode(c, e->utf8[i] + 1);
      e->utf16[i] = c;
    }
  }
  e->userData = userData;
  e->convert = convert;
  if (convert) {
    e->normal.isName2 = unknown_isName;
    e->normal.isName3 = unknown_isName;
    e->normal.isName4 = unknown_isName;
    e->normal.isNmstrt2 = unknown_isNmstrt;
    e->normal.isNmstrt3 = unknown_isNmstrt;
    e->normal.isNmstrt4 = unknown_isNmstrt;
    e->normal.isInvalid2 = unknown_isInvalid;
    e->normal.isInvalid3 = unknown_isInvalid;
    e->normal.isInvalid4 = unknown_isInvalid;
  }
  e->normal.enc.utf8Convert = unknown_toUtf8;
  e->normal.enc.utf16Convert = unknown_toUtf16;
  return &(e->normal.enc);
}

/* If this enumeration is changed, getEncodingIndex and encodings
must also be changed. */
enum {
  UNKNOWN_ENC = -1,
  ISO_8859_1_ENC = 0,
  US_ASCII_ENC,
  UTF_8_ENC,
  UTF_16_ENC,
  UTF_16BE_ENC,
  UTF_16LE_ENC,
  /* must match encodingNames up to here */
  NO_ENC
};

static
int getEncodingIndex(const char *name)
{
  static const char *encodingNames[] = {
    "ISO-8859-1",
    "US-ASCII",
    "UTF-8",
    "UTF-16",
    "UTF-16BE"
    "UTF-16LE",
  };
  int i;
  if (name == 0)
    return NO_ENC;
  for (i = 0; i < sizeof(encodingNames)/sizeof(encodingNames[0]); i++)
    if (streqci(name, encodingNames[i]))
      return i;
  return UNKNOWN_ENC;
}

/* For binary compatibility, we store the index of the encoding specified
at initialization in the isUtf16 member. */

#define INIT_ENC_INDEX(enc) ((int)(enc)->initEnc.isUtf16)
#define SET_INIT_ENC_INDEX(enc, i) ((enc)->initEnc.isUtf16 = (char)i)

/* This is what detects the encoding.
encodingTable maps from encoding indices to encodings;
INIT_ENC_INDEX(enc) is the index of the external (protocol) specified encoding;
state is XML_CONTENT_STATE if we're parsing an external text entity,
and XML_PROLOG_STATE otherwise.
*/


static
int initScan(const ENCODING **encodingTable,
	     const INIT_ENCODING *enc,
	     int state,
	     const char *ptr,
	     const char *end,
	     const char **nextTokPtr)
{
  const ENCODING **encPtr;

  if (ptr == end)
    return XML_TOK_NONE;
  encPtr = enc->encPtr;
  if (ptr + 1 == end) {
    /* only a single byte available for auto-detection */
#ifndef XML_DTD /* FIXME */
    /* a well-formed document entity must have more than one byte */
    if (state != XML_CONTENT_STATE)
      return XML_TOK_PARTIAL;
#endif
    /* so we're parsing an external text entity... */
    /* if UTF-16 was externally specified, then we need at least 2 bytes */
    switch (INIT_ENC_INDEX(enc)) {
    case UTF_16_ENC:
    case UTF_16LE_ENC:
    case UTF_16BE_ENC:
      return XML_TOK_PARTIAL;
    }
    switch ((unsigned char)*ptr) {
    case 0xFE:
    case 0xFF:
    case 0xEF: /* possibly first byte of UTF-8 BOM */
      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC
	  && state == XML_CONTENT_STATE)
	break;
      /* fall through */
    case 0x00:
    case 0x3C:
      return XML_TOK_PARTIAL;
    }
  }
  else {
    switch (((unsigned char)ptr[0] << 8) | (unsigned char)ptr[1]) {
    case 0xFEFF:
      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC
	  && state == XML_CONTENT_STATE)
	break;
      *nextTokPtr = ptr + 2;
      *encPtr = encodingTable[UTF_16BE_ENC];
      return XML_TOK_BOM;
    /* 00 3C is handled in the default case */
    case 0x3C00:
      if ((INIT_ENC_INDEX(enc) == UTF_16BE_ENC
	   || INIT_ENC_INDEX(enc) == UTF_16_ENC)
	  && state == XML_CONTENT_STATE)
	break;
      *encPtr = encodingTable[UTF_16LE_ENC];
      return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
    case 0xFFFE:
      if (INIT_ENC_INDEX(enc) == ISO_8859_1_ENC
	  && state == XML_CONTENT_STATE)
	break;
      *nextTokPtr = ptr + 2;
      *encPtr = encodingTable[UTF_16LE_ENC];
      return XML_TOK_BOM;
    case 0xEFBB:
      /* Maybe a UTF-8 BOM (EF BB BF) */
      /* If there's an explicitly specified (external) encoding
         of ISO-8859-1 or some flavour of UTF-16
         and this is an external text entity,
	 don't look for the BOM,
         because it might be a legal data. */
      if (state == XML_CONTENT_STATE) {
	int e = INIT_ENC_INDEX(enc);
	if (e == ISO_8859_1_ENC || e == UTF_16BE_ENC || e == UTF_16LE_ENC || e == UTF_16_ENC)
	  break;
      }
      if (ptr + 2 == end)
	return XML_TOK_PARTIAL;
      if ((unsigned char)ptr[2] == 0xBF) {
	*encPtr = encodingTable[UTF_8_ENC];
	return XML_TOK_BOM;
      }
      break;
    default:
      if (ptr[0] == '\0') {
	/* 0 isn't a legal data character. Furthermore a document entity can only
	   start with ASCII characters.  So the only way this can fail to be big-endian
	   UTF-16 if it it's an external parsed general entity that's labelled as
	   UTF-16LE. */
	if (state == XML_CONTENT_STATE && INIT_ENC_INDEX(enc) == UTF_16LE_ENC)
	  break;
	*encPtr = encodingTable[UTF_16BE_ENC];
	return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
      }
      else if (ptr[1] == '\0') {
	/* We could recover here in the case:
	    - parsing an external entity
	    - second byte is 0
	    - no externally specified encoding
	    - no encoding declaration
	   by assuming UTF-16LE.  But we don't, because this would mean when
	   presented just with a single byte, we couldn't reliably determine
	   whether we needed further bytes. */
	if (state == XML_CONTENT_STATE)
	  break;
	*encPtr = encodingTable[UTF_16LE_ENC];
	return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
      }
      break;
    }
  }
  *encPtr = encodingTable[INIT_ENC_INDEX(enc)];
  return XmlTok(*encPtr, state, ptr, end, nextTokPtr);
}


#define NS(x) x
#define ns(x) x
#include "xmltok_ns.c"
#undef NS
#undef ns

#ifdef XML_NS

#define NS(x) x ## NS
#define ns(x) x ## _ns

#include "xmltok_ns.c"

#undef NS
#undef ns

ENCODING *
XmlInitUnknownEncodingNS(void *mem,
		         int *table,
		         int (*convert)(void *userData, const char *p),
		         void *userData)
{
  ENCODING *enc = XmlInitUnknownEncoding(mem, table, convert, userData);
  if (enc)
    ((struct normal_encoding *)enc)->type[':'] = BT_COLON;
  return enc;
}

#endif /* XML_NS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmltok.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#ifndef XmlTok_INCLUDED
#define XmlTok_INCLUDED 1

#ifdef __cplusplus
extern "C" {
#endif

#ifndef XMLTOKAPI
#define XMLTOKAPI /* as nothing */
#endif

/* The following token may be returned by XmlContentTok */
#define XML_TOK_TRAILING_RSQB -5 /* ] or ]] at the end of the scan; might be start of
                                    illegal ]]> sequence */
/* The following tokens may be returned by both XmlPrologTok and XmlContentTok */
#define XML_TOK_NONE -4    /* The string to be scanned is empty */
#define XML_TOK_TRAILING_CR -3 /* A CR at the end of the scan;
                                  might be part of CRLF sequence */ 
#define XML_TOK_PARTIAL_CHAR -2 /* only part of a multibyte sequence */
#define XML_TOK_PARTIAL -1 /* only part of a token */
#define XML_TOK_INVALID 0

/* The following tokens are returned by XmlContentTok; some are also
  returned by XmlAttributeValueTok, XmlEntityTok, XmlCdataSectionTok */

#define XML_TOK_START_TAG_WITH_ATTS 1
#define XML_TOK_START_TAG_NO_ATTS 2
#define XML_TOK_EMPTY_ELEMENT_WITH_ATTS 3 /* empty element tag <e/> */
#define XML_TOK_EMPTY_ELEMENT_NO_ATTS 4
#define XML_TOK_END_TAG 5
#define XML_TOK_DATA_CHARS 6
#define XML_TOK_DATA_NEWLINE 7
#define XML_TOK_CDATA_SECT_OPEN 8
#define XML_TOK_ENTITY_REF 9
#define XML_TOK_CHAR_REF 10     /* numeric character reference */

/* The following tokens may be returned by both XmlPrologTok and XmlContentTok */
#define XML_TOK_PI 11      /* processing instruction */
#define XML_TOK_XML_DECL 12 /* XML decl or text decl */
#define XML_TOK_COMMENT 13
#define XML_TOK_BOM 14     /* Byte order mark */

/* The following tokens are returned only by XmlPrologTok */
#define XML_TOK_PROLOG_S 15
#define XML_TOK_DECL_OPEN 16 /* <!foo */
#define XML_TOK_DECL_CLOSE 17 /* > */
#define XML_TOK_NAME 18
#define XML_TOK_NMTOKEN 19
#define XML_TOK_POUND_NAME 20 /* #name */
#define XML_TOK_OR 21 /* | */
#define XML_TOK_PERCENT 22
#define XML_TOK_OPEN_PAREN 23
#define XML_TOK_CLOSE_PAREN 24
#define XML_TOK_OPEN_BRACKET 25
#define XML_TOK_CLOSE_BRACKET 26
#define XML_TOK_LITERAL 27
#define XML_TOK_PARAM_ENTITY_REF 28
#define XML_TOK_INSTANCE_START 29

/* The following occur only in element type declarations */
#define XML_TOK_NAME_QUESTION 30 /* name? */
#define XML_TOK_NAME_ASTERISK 31 /* name* */
#define XML_TOK_NAME_PLUS 32 /* name+ */
#define XML_TOK_COND_SECT_OPEN 33 /* <![ */
#define XML_TOK_COND_SECT_CLOSE 34 /* ]]> */
#define XML_TOK_CLOSE_PAREN_QUESTION 35 /* )? */
#define XML_TOK_CLOSE_PAREN_ASTERISK 36 /* )* */
#define XML_TOK_CLOSE_PAREN_PLUS 37 /* )+ */
#define XML_TOK_COMMA 38

/* The following token is returned only by XmlAttributeValueTok */
#define XML_TOK_ATTRIBUTE_VALUE_S 39

/* The following token is returned only by XmlCdataSectionTok */
#define XML_TOK_CDATA_SECT_CLOSE 40

/* With namespace processing this is returned by XmlPrologTok
   for a name with a colon. */
#define XML_TOK_PREFIXED_NAME 41

#ifdef XML_DTD
#define XML_TOK_IGNORE_SECT 42
#endif /* XML_DTD */

#ifdef XML_DTD
#define XML_N_STATES 4
#else /* not XML_DTD */
#define XML_N_STATES 3
#endif /* not XML_DTD */

#define XML_PROLOG_STATE 0
#define XML_CONTENT_STATE 1
#define XML_CDATA_SECTION_STATE 2
#ifdef XML_DTD
#define XML_IGNORE_SECTION_STATE 3
#endif /* XML_DTD */

#define XML_N_LITERAL_TYPES 2
#define XML_ATTRIBUTE_VALUE_LITERAL 0
#define XML_ENTITY_VALUE_LITERAL 1

/* The size of the buffer passed to XmlUtf8Encode must be at least this. */
#define XML_UTF8_ENCODE_MAX 4
/* The size of the buffer passed to XmlUtf16Encode must be at least this. */
#define XML_UTF16_ENCODE_MAX 2

typedef struct position {
  /* first line and first column are 0 not 1 */
  unsigned long lineNumber;
  unsigned long columnNumber;
} POSITION;

typedef struct {
  const char *name;
  const char *valuePtr;
  const char *valueEnd;
  char normalized;
} ATTRIBUTE;

struct encoding;
typedef struct encoding ENCODING;

struct encoding {
  int (*scanners[XML_N_STATES])(const ENCODING *,
			        const char *,
			        const char *,
			        const char **);
  int (*literalScanners[XML_N_LITERAL_TYPES])(const ENCODING *,
					      const char *,
					      const char *,
					      const char **);
  int (*sameName)(const ENCODING *,
	          const char *, const char *);
  int (*nameMatchesAscii)(const ENCODING *,
			  const char *, const char *, const char *);
  int (*nameLength)(const ENCODING *, const char *);
  const char *(*skipS)(const ENCODING *, const char *);
  int (*getAtts)(const ENCODING *enc, const char *ptr,
	         int attsMax, ATTRIBUTE *atts);
  int (*charRefNumber)(const ENCODING *enc, const char *ptr);
  int (*predefinedEntityName)(const ENCODING *, const char *, const char *);
  void (*updatePosition)(const ENCODING *,
			 const char *ptr,
			 const char *end,
			 POSITION *);
  int (*isPublicId)(const ENCODING *enc, const char *ptr, const char *end,
		    const char **badPtr);
  void (*utf8Convert)(const ENCODING *enc,
		      const char **fromP,
		      const char *fromLim,
		      char **toP,
		      const char *toLim);
  void (*utf16Convert)(const ENCODING *enc,
		       const char **fromP,
		       const char *fromLim,
		       unsigned short **toP,
		       const unsigned short *toLim);
  int minBytesPerChar;
  char isUtf8;
  char isUtf16;
};

/*
Scan the string starting at ptr until the end of the next complete token,
but do not scan past eptr.  Return an integer giving the type of token.

Return XML_TOK_NONE when ptr == eptr; nextTokPtr will not be set.

Return XML_TOK_PARTIAL when the string does not contain a complete token;
nextTokPtr will not be set.

Return XML_TOK_INVALID when the string does not start a valid token; nextTokPtr
will be set to point to the character which made the token invalid.

Otherwise the string starts with a valid token; nextTokPtr will be set to point
to the character following the end of that token.

Each data character counts as a single token, but adjacent data characters
may be returned together.  Similarly for characters in the prolog outside
literals, comments and processing instructions.
*/


#define XmlTok(enc, state, ptr, end, nextTokPtr) \
  (((enc)->scanners[state])(enc, ptr, end, nextTokPtr))

#define XmlPrologTok(enc, ptr, end, nextTokPtr) \
   XmlTok(enc, XML_PROLOG_STATE, ptr, end, nextTokPtr)

#define XmlContentTok(enc, ptr, end, nextTokPtr) \
   XmlTok(enc, XML_CONTENT_STATE, ptr, end, nextTokPtr)

#define XmlCdataSectionTok(enc, ptr, end, nextTokPtr) \
   XmlTok(enc, XML_CDATA_SECTION_STATE, ptr, end, nextTokPtr)

#ifdef XML_DTD

#define XmlIgnoreSectionTok(enc, ptr, end, nextTokPtr) \
   XmlTok(enc, XML_IGNORE_SECTION_STATE, ptr, end, nextTokPtr)

#endif /* XML_DTD */

/* This is used for performing a 2nd-level tokenization on
the content of a literal that has already been returned by XmlTok. */ 

#define XmlLiteralTok(enc, literalType, ptr, end, nextTokPtr) \
  (((enc)->literalScanners[literalType])(enc, ptr, end, nextTokPtr))

#define XmlAttributeValueTok(enc, ptr, end, nextTokPtr) \
   XmlLiteralTok(enc, XML_ATTRIBUTE_VALUE_LITERAL, ptr, end, nextTokPtr)

#define XmlEntityValueTok(enc, ptr, end, nextTokPtr) \
   XmlLiteralTok(enc, XML_ENTITY_VALUE_LITERAL, ptr, end, nextTokPtr)

#define XmlSameName(enc, ptr1, ptr2) (((enc)->sameName)(enc, ptr1, ptr2))

#define XmlNameMatchesAscii(enc, ptr1, end1, ptr2) \
  (((enc)->nameMatchesAscii)(enc, ptr1, end1, ptr2))

#define XmlNameLength(enc, ptr) \
  (((enc)->nameLength)(enc, ptr))

#define XmlSkipS(enc, ptr) \
  (((enc)->skipS)(enc, ptr))

#define XmlGetAttributes(enc, ptr, attsMax, atts) \
  (((enc)->getAtts)(enc, ptr, attsMax, atts))

#define XmlCharRefNumber(enc, ptr) \
  (((enc)->charRefNumber)(enc, ptr))

#define XmlPredefinedEntityName(enc, ptr, end) \
  (((enc)->predefinedEntityName)(enc, ptr, end))

#define XmlUpdatePosition(enc, ptr, end, pos) \
  (((enc)->updatePosition)(enc, ptr, end, pos))

#define XmlIsPublicId(enc, ptr, end, badPtr) \
  (((enc)->isPublicId)(enc, ptr, end, badPtr))

#define XmlUtf8Convert(enc, fromP, fromLim, toP, toLim) \
  (((enc)->utf8Convert)(enc, fromP, fromLim, toP, toLim))

#define XmlUtf16Convert(enc, fromP, fromLim, toP, toLim) \
  (((enc)->utf16Convert)(enc, fromP, fromLim, toP, toLim))

typedef struct {
  ENCODING initEnc;
  const ENCODING **encPtr;
} INIT_ENCODING;

int XMLTOKAPI XmlParseXmlDecl(int isGeneralTextEntity,
			      const ENCODING *enc,
			      const char *ptr,
	  		      const char *end,
			      const char **badPtr,
			      const char **versionPtr,
			      const char **encodingNamePtr,
			      const ENCODING **namedEncodingPtr,
			      int *standalonePtr);

int XMLTOKAPI XmlInitEncoding(INIT_ENCODING *, const ENCODING **, const char *name);
const ENCODING XMLTOKAPI *XmlGetUtf8InternalEncoding(void);
const ENCODING XMLTOKAPI *XmlGetUtf16InternalEncoding(void);
int XMLTOKAPI XmlUtf8Encode(int charNumber, char *buf);
int XMLTOKAPI XmlUtf16Encode(int charNumber, unsigned short *buf);

int XMLTOKAPI XmlSizeOfUnknownEncoding(void);
ENCODING XMLTOKAPI *
XmlInitUnknownEncoding(void *mem,
		       int *table,
		       int (*conv)(void *userData, const char *p),
		       void *userData);

int XMLTOKAPI XmlParseXmlDeclNS(int isGeneralTextEntity,
			        const ENCODING *enc,
			        const char *ptr,
	  		        const char *end,
			        const char **badPtr,
			        const char **versionPtr,
			        const char **encodingNamePtr,
			        const ENCODING **namedEncodingPtr,
			        int *standalonePtr);
int XMLTOKAPI XmlInitEncodingNS(INIT_ENCODING *, const ENCODING **, const char *name);
const ENCODING XMLTOKAPI *XmlGetUtf8InternalEncodingNS();
const ENCODING XMLTOKAPI *XmlGetUtf16InternalEncodingNS();
ENCODING XMLTOKAPI *
XmlInitUnknownEncodingNS(void *mem,
		         int *table,
		         int (*conv)(void *userData, const char *p),
		         void *userData);
#ifdef __cplusplus
}
#endif

#endif /* not XmlTok_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmltok_impl.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#ifndef IS_INVALID_CHAR
#define IS_INVALID_CHAR(enc, ptr, n) (0)
#endif

#define INVALID_LEAD_CASE(n, ptr, nextTokPtr) \
    case BT_LEAD ## n: \
      if (end - ptr < n) \
	return XML_TOK_PARTIAL_CHAR; \
      if (IS_INVALID_CHAR(enc, ptr, n)) { \
        *(nextTokPtr) = (ptr); \
        return XML_TOK_INVALID; \
      } \
      ptr += n; \
      break;

#define INVALID_CASES(ptr, nextTokPtr) \
  INVALID_LEAD_CASE(2, ptr, nextTokPtr) \
  INVALID_LEAD_CASE(3, ptr, nextTokPtr) \
  INVALID_LEAD_CASE(4, ptr, nextTokPtr) \
  case BT_NONXML: \
  case BT_MALFORM: \
  case BT_TRAIL: \
    *(nextTokPtr) = (ptr); \
    return XML_TOK_INVALID;

#define CHECK_NAME_CASE(n, enc, ptr, end, nextTokPtr) \
   case BT_LEAD ## n: \
     if (end - ptr < n) \
       return XML_TOK_PARTIAL_CHAR; \
     if (!IS_NAME_CHAR(enc, ptr, n)) { \
       *nextTokPtr = ptr; \
       return XML_TOK_INVALID; \
     } \
     ptr += n; \
     break;

#define CHECK_NAME_CASES(enc, ptr, end, nextTokPtr) \
  case BT_NONASCII: \
    if (!IS_NAME_CHAR_MINBPC(enc, ptr)) { \
      *nextTokPtr = ptr; \
      return XML_TOK_INVALID; \
    } \
  case BT_NMSTRT: \
  case BT_HEX: \
  case BT_DIGIT: \
  case BT_NAME: \
  case BT_MINUS: \
    ptr += MINBPC(enc); \
    break; \
  CHECK_NAME_CASE(2, enc, ptr, end, nextTokPtr) \
  CHECK_NAME_CASE(3, enc, ptr, end, nextTokPtr) \
  CHECK_NAME_CASE(4, enc, ptr, end, nextTokPtr)

#define CHECK_NMSTRT_CASE(n, enc, ptr, end, nextTokPtr) \
   case BT_LEAD ## n: \
     if (end - ptr < n) \
       return XML_TOK_PARTIAL_CHAR; \
     if (!IS_NMSTRT_CHAR(enc, ptr, n)) { \
       *nextTokPtr = ptr; \
       return XML_TOK_INVALID; \
     } \
     ptr += n; \
     break;

#define CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr) \
  case BT_NONASCII: \
    if (!IS_NMSTRT_CHAR_MINBPC(enc, ptr)) { \
      *nextTokPtr = ptr; \
      return XML_TOK_INVALID; \
    } \
  case BT_NMSTRT: \
  case BT_HEX: \
    ptr += MINBPC(enc); \
    break; \
  CHECK_NMSTRT_CASE(2, enc, ptr, end, nextTokPtr) \
  CHECK_NMSTRT_CASE(3, enc, ptr, end, nextTokPtr) \
  CHECK_NMSTRT_CASE(4, enc, ptr, end, nextTokPtr)

#ifndef PREFIX
#define PREFIX(ident) ident
#endif

/* ptr points to character following "<!-" */

static
int PREFIX(scanComment)(const ENCODING *enc, const char *ptr, const char *end,
			const char **nextTokPtr)
{
  if (ptr != end) {
    if (!CHAR_MATCHES(enc, ptr, '-')) {
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
    ptr += MINBPC(enc);
    while (ptr != end) {
      switch (BYTE_TYPE(enc, ptr)) {
      INVALID_CASES(ptr, nextTokPtr)
      case BT_MINUS:
	if ((ptr += MINBPC(enc)) == end)
	  return XML_TOK_PARTIAL;
	if (CHAR_MATCHES(enc, ptr, '-')) {
	  if ((ptr += MINBPC(enc)) == end)
	    return XML_TOK_PARTIAL;
	  if (!CHAR_MATCHES(enc, ptr, '>')) {
	    *nextTokPtr = ptr;
	    return XML_TOK_INVALID;
	  }
	  *nextTokPtr = ptr + MINBPC(enc);
	  return XML_TOK_COMMENT;
	}
	break;
      default:
	ptr += MINBPC(enc);
	break;
      }
    }
  }
  return XML_TOK_PARTIAL;
}

/* ptr points to character following "<!" */

static
int PREFIX(scanDecl)(const ENCODING *enc, const char *ptr, const char *end,
		     const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  case BT_MINUS:
    return PREFIX(scanComment)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_LSQB:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_COND_SECT_OPEN;
  case BT_NMSTRT:
  case BT_HEX:
    ptr += MINBPC(enc);
    break;
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_PERCNT:
      if (ptr + MINBPC(enc) == end)
	return XML_TOK_PARTIAL;
      /* don't allow <!ENTITY% foo "whatever"> */
      switch (BYTE_TYPE(enc, ptr + MINBPC(enc))) {
      case BT_S: case BT_CR: case BT_LF: case BT_PERCNT:
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      /* fall through */
    case BT_S: case BT_CR: case BT_LF:
      *nextTokPtr = ptr;
      return XML_TOK_DECL_OPEN;
    case BT_NMSTRT:
    case BT_HEX:
      ptr += MINBPC(enc);
      break;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}

static
int PREFIX(checkPiTarget)(const ENCODING *enc, const char *ptr, const char *end, int *tokPtr)
{
  int upper = 0;
  *tokPtr = XML_TOK_PI;
  if (end - ptr != MINBPC(enc)*3)
    return 1;
  switch (BYTE_TO_ASCII(enc, ptr)) {
  case 'x':
    break;
  case 'X':
    upper = 1;
    break;
  default:
    return 1;
  }
  ptr += MINBPC(enc);
  switch (BYTE_TO_ASCII(enc, ptr)) {
  case 'm':
    break;
  case 'M':
    upper = 1;
    break;
  default:
    return 1;
  }
  ptr += MINBPC(enc);
  switch (BYTE_TO_ASCII(enc, ptr)) {
  case 'l':
    break;
  case 'L':
    upper = 1;
    break;
  default:
    return 1;
  }
  if (upper)
    return 0;
  *tokPtr = XML_TOK_XML_DECL;
  return 1;
}

/* ptr points to character following "<?" */

static
int PREFIX(scanPi)(const ENCODING *enc, const char *ptr, const char *end,
		   const char **nextTokPtr)
{
  int tok;
  const char *target = ptr;
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
    case BT_S: case BT_CR: case BT_LF:
      if (!PREFIX(checkPiTarget)(enc, target, ptr, &tok)) {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      ptr += MINBPC(enc);
      while (ptr != end) {
        switch (BYTE_TYPE(enc, ptr)) {
        INVALID_CASES(ptr, nextTokPtr)
	case BT_QUEST:
	  ptr += MINBPC(enc);
	  if (ptr == end)
	    return XML_TOK_PARTIAL;
	  if (CHAR_MATCHES(enc, ptr, '>')) {
	    *nextTokPtr = ptr + MINBPC(enc);
	    return tok;
	  }
	  break;
	default:
	  ptr += MINBPC(enc);
	  break;
	}
      }
      return XML_TOK_PARTIAL;
    case BT_QUEST:
      if (!PREFIX(checkPiTarget)(enc, target, ptr, &tok)) {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      ptr += MINBPC(enc);
      if (ptr == end)
	return XML_TOK_PARTIAL;
      if (CHAR_MATCHES(enc, ptr, '>')) {
	*nextTokPtr = ptr + MINBPC(enc);
	return tok;
      }
      /* fall through */
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}


static
int PREFIX(scanCdataSection)(const ENCODING *enc, const char *ptr, const char *end,
			     const char **nextTokPtr)
{
  int i;
  /* CDATA[ */
  if (end - ptr < 6 * MINBPC(enc))
    return XML_TOK_PARTIAL;
  for (i = 0; i < 6; i++, ptr += MINBPC(enc)) {
    if (!CHAR_MATCHES(enc, ptr, "CDATA["[i])) {
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  *nextTokPtr = ptr;
  return XML_TOK_CDATA_SECT_OPEN;
}

static
int PREFIX(cdataSectionTok)(const ENCODING *enc, const char *ptr, const char *end,
			    const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_NONE;
  if (MINBPC(enc) > 1) {
    size_t n = end - ptr;
    if (n & (MINBPC(enc) - 1)) {
      n &= ~(MINBPC(enc) - 1);
      if (n == 0)
	return XML_TOK_PARTIAL;
      end = ptr + n;
    }
  }
  switch (BYTE_TYPE(enc, ptr)) {
  case BT_RSQB:
    ptr += MINBPC(enc);
    if (ptr == end)
      return XML_TOK_PARTIAL;
    if (!CHAR_MATCHES(enc, ptr, ']'))
      break;
    ptr += MINBPC(enc);
    if (ptr == end)
      return XML_TOK_PARTIAL;
    if (!CHAR_MATCHES(enc, ptr, '>')) {
      ptr -= MINBPC(enc);
      break;
    }
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_CDATA_SECT_CLOSE;
  case BT_CR:
    ptr += MINBPC(enc);
    if (ptr == end)
      return XML_TOK_PARTIAL;
    if (BYTE_TYPE(enc, ptr) == BT_LF)
      ptr += MINBPC(enc);
    *nextTokPtr = ptr;
    return XML_TOK_DATA_NEWLINE;
  case BT_LF:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_DATA_NEWLINE;
  INVALID_CASES(ptr, nextTokPtr)
  default:
    ptr += MINBPC(enc);
    break;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: \
      if (end - ptr < n || IS_INVALID_CHAR(enc, ptr, n)) { \
	*nextTokPtr = ptr; \
	return XML_TOK_DATA_CHARS; \
      } \
      ptr += n; \
      break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_NONXML:
    case BT_MALFORM:
    case BT_TRAIL:
    case BT_CR:
    case BT_LF:
    case BT_RSQB:
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    default:
      ptr += MINBPC(enc);
      break;
    }
  }
  *nextTokPtr = ptr;
  return XML_TOK_DATA_CHARS;
}

/* ptr points to character following "</" */

static
int PREFIX(scanEndTag)(const ENCODING *enc, const char *ptr, const char *end,
		       const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
    case BT_S: case BT_CR: case BT_LF:
      for (ptr += MINBPC(enc); ptr != end; ptr += MINBPC(enc)) {
	switch (BYTE_TYPE(enc, ptr)) {
	case BT_S: case BT_CR: case BT_LF:
	  break;
	case BT_GT:
	  *nextTokPtr = ptr + MINBPC(enc);
          return XML_TOK_END_TAG;
	default:
	  *nextTokPtr = ptr;
	  return XML_TOK_INVALID;
	}
      }
      return XML_TOK_PARTIAL;
#ifdef XML_NS
    case BT_COLON:
      /* no need to check qname syntax here, since end-tag must match exactly */
      ptr += MINBPC(enc);
      break;
#endif
    case BT_GT:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_END_TAG;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}

/* ptr points to character following "&#X" */

static
int PREFIX(scanHexCharRef)(const ENCODING *enc, const char *ptr, const char *end,
			   const char **nextTokPtr)
{
  if (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_DIGIT:
    case BT_HEX:
      break;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
    for (ptr += MINBPC(enc); ptr != end; ptr += MINBPC(enc)) {
      switch (BYTE_TYPE(enc, ptr)) {
      case BT_DIGIT:
      case BT_HEX:
	break;
      case BT_SEMI:
	*nextTokPtr = ptr + MINBPC(enc);
	return XML_TOK_CHAR_REF;
      default:
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
    }
  }
  return XML_TOK_PARTIAL;
}

/* ptr points to character following "&#" */

static
int PREFIX(scanCharRef)(const ENCODING *enc, const char *ptr, const char *end,
			const char **nextTokPtr)
{
  if (ptr != end) {
    if (CHAR_MATCHES(enc, ptr, 'x'))
      return PREFIX(scanHexCharRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_DIGIT:
      break;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
    for (ptr += MINBPC(enc); ptr != end; ptr += MINBPC(enc)) {
      switch (BYTE_TYPE(enc, ptr)) {
      case BT_DIGIT:
	break;
      case BT_SEMI:
	*nextTokPtr = ptr + MINBPC(enc);
	return XML_TOK_CHAR_REF;
      default:
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
    }
  }
  return XML_TOK_PARTIAL;
}

/* ptr points to character following "&" */

static
int PREFIX(scanRef)(const ENCODING *enc, const char *ptr, const char *end,
		    const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
  case BT_NUM:
    return PREFIX(scanCharRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
    case BT_SEMI:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_ENTITY_REF;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}

/* ptr points to character following first character of attribute name */

static
int PREFIX(scanAtts)(const ENCODING *enc, const char *ptr, const char *end,
		     const char **nextTokPtr)
{
#ifdef XML_NS
  int hadColon = 0;
#endif
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
#ifdef XML_NS
    case BT_COLON:
      if (hadColon) {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      hadColon = 1;
      ptr += MINBPC(enc);
      if (ptr == end)
	return XML_TOK_PARTIAL;
      switch (BYTE_TYPE(enc, ptr)) {
      CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
      default:
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      break;
#endif
    case BT_S: case BT_CR: case BT_LF:
      for (;;) {
	int t;

	ptr += MINBPC(enc);
	if (ptr == end)
	  return XML_TOK_PARTIAL;
	t = BYTE_TYPE(enc, ptr);
	if (t == BT_EQUALS)
	  break;
	switch (t) {
	case BT_S:
	case BT_LF:
	case BT_CR:
	  break;
	default:
	  *nextTokPtr = ptr;
	  return XML_TOK_INVALID;
	}
      }
    /* fall through */
    case BT_EQUALS:
      {
	int open;
#ifdef XML_NS
	hadColon = 0;
#endif
	for (;;) {
	  
	  ptr += MINBPC(enc);
	  if (ptr == end)
	    return XML_TOK_PARTIAL;
	  open = BYTE_TYPE(enc, ptr);
	  if (open == BT_QUOT || open == BT_APOS)
	    break;
	  switch (open) {
	  case BT_S:
	  case BT_LF:
	  case BT_CR:
	    break;
	  default:
	    *nextTokPtr = ptr;
	    return XML_TOK_INVALID;
	  }
	}
	ptr += MINBPC(enc);
	/* in attribute value */
	for (;;) {
	  int t;
	  if (ptr == end)
	    return XML_TOK_PARTIAL;
	  t = BYTE_TYPE(enc, ptr);
	  if (t == open)
	    break;
	  switch (t) {
	  INVALID_CASES(ptr, nextTokPtr)
	  case BT_AMP:
	    {
	      int tok = PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, &ptr);
	      if (tok <= 0) {
		if (tok == XML_TOK_INVALID)
		  *nextTokPtr = ptr;
		return tok;
	      }
	      break;
	    }
	  case BT_LT:
	    *nextTokPtr = ptr;
	    return XML_TOK_INVALID;
	  default:
	    ptr += MINBPC(enc);
	    break;
	  }
	}
	ptr += MINBPC(enc);
	if (ptr == end)
	  return XML_TOK_PARTIAL;
	switch (BYTE_TYPE(enc, ptr)) {
	case BT_S:
	case BT_CR:
	case BT_LF:
	  break;
	case BT_SOL:
	  goto sol;
	case BT_GT:
	  goto gt;
	default:
	  *nextTokPtr = ptr;
	  return XML_TOK_INVALID;
	}
	/* ptr points to closing quote */
	for (;;) {
	  ptr += MINBPC(enc);
	  if (ptr == end)
	    return XML_TOK_PARTIAL;
	  switch (BYTE_TYPE(enc, ptr)) {
	  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
	  case BT_S: case BT_CR: case BT_LF:
	    continue;
	  case BT_GT:
          gt:
	    *nextTokPtr = ptr + MINBPC(enc);
	    return XML_TOK_START_TAG_WITH_ATTS;
	  case BT_SOL:
          sol:
	    ptr += MINBPC(enc);
	    if (ptr == end)
	      return XML_TOK_PARTIAL;
	    if (!CHAR_MATCHES(enc, ptr, '>')) {
	      *nextTokPtr = ptr;
	      return XML_TOK_INVALID;
	    }
	    *nextTokPtr = ptr + MINBPC(enc);
	    return XML_TOK_EMPTY_ELEMENT_WITH_ATTS;
	  default:
	    *nextTokPtr = ptr;
	    return XML_TOK_INVALID;
	  }
	  break;
	}
	break;
      }
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}

/* ptr points to character following "<" */

static
int PREFIX(scanLt)(const ENCODING *enc, const char *ptr, const char *end,
		   const char **nextTokPtr)
{
#ifdef XML_NS
  int hadColon;
#endif
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
  case BT_EXCL:
    if ((ptr += MINBPC(enc)) == end)
      return XML_TOK_PARTIAL;
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_MINUS:
      return PREFIX(scanComment)(enc, ptr + MINBPC(enc), end, nextTokPtr);
    case BT_LSQB:
      return PREFIX(scanCdataSection)(enc, ptr + MINBPC(enc), end, nextTokPtr);
    }
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  case BT_QUEST:
    return PREFIX(scanPi)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_SOL:
    return PREFIX(scanEndTag)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
#ifdef XML_NS
  hadColon = 0;
#endif
  /* we have a start-tag */
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
#ifdef XML_NS
    case BT_COLON:
      if (hadColon) {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      hadColon = 1;
      ptr += MINBPC(enc);
      if (ptr == end)
	return XML_TOK_PARTIAL;
      switch (BYTE_TYPE(enc, ptr)) {
      CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
      default:
        *nextTokPtr = ptr;
        return XML_TOK_INVALID;
      }
      break;
#endif
    case BT_S: case BT_CR: case BT_LF:
      {
        ptr += MINBPC(enc);
	while (ptr != end) {
	  switch (BYTE_TYPE(enc, ptr)) {
	  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
	  case BT_GT:
	    goto gt;
	  case BT_SOL:
	    goto sol;
	  case BT_S: case BT_CR: case BT_LF:
	    ptr += MINBPC(enc);
	    continue;
	  default:
	    *nextTokPtr = ptr;
	    return XML_TOK_INVALID;
	  }
	  return PREFIX(scanAtts)(enc, ptr, end, nextTokPtr);
	}
	return XML_TOK_PARTIAL;
      }
    case BT_GT:
    gt:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_START_TAG_NO_ATTS;
    case BT_SOL:
    sol:
      ptr += MINBPC(enc);
      if (ptr == end)
	return XML_TOK_PARTIAL;
      if (!CHAR_MATCHES(enc, ptr, '>')) {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_EMPTY_ELEMENT_NO_ATTS;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}

static
int PREFIX(contentTok)(const ENCODING *enc, const char *ptr, const char *end,
		       const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_NONE;
  if (MINBPC(enc) > 1) {
    size_t n = end - ptr;
    if (n & (MINBPC(enc) - 1)) {
      n &= ~(MINBPC(enc) - 1);
      if (n == 0)
	return XML_TOK_PARTIAL;
      end = ptr + n;
    }
  }
  switch (BYTE_TYPE(enc, ptr)) {
  case BT_LT:
    return PREFIX(scanLt)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_AMP:
    return PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_CR:
    ptr += MINBPC(enc);
    if (ptr == end)
      return XML_TOK_TRAILING_CR;
    if (BYTE_TYPE(enc, ptr) == BT_LF)
      ptr += MINBPC(enc);
    *nextTokPtr = ptr;
    return XML_TOK_DATA_NEWLINE;
  case BT_LF:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_DATA_NEWLINE;
  case BT_RSQB:
    ptr += MINBPC(enc);
    if (ptr == end)
      return XML_TOK_TRAILING_RSQB;
    if (!CHAR_MATCHES(enc, ptr, ']'))
      break;
    ptr += MINBPC(enc);
    if (ptr == end)
      return XML_TOK_TRAILING_RSQB;
    if (!CHAR_MATCHES(enc, ptr, '>')) {
      ptr -= MINBPC(enc);
      break;
    }
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  INVALID_CASES(ptr, nextTokPtr)
  default:
    ptr += MINBPC(enc);
    break;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: \
      if (end - ptr < n || IS_INVALID_CHAR(enc, ptr, n)) { \
	*nextTokPtr = ptr; \
	return XML_TOK_DATA_CHARS; \
      } \
      ptr += n; \
      break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_RSQB:
      if (ptr + MINBPC(enc) != end) {
	 if (!CHAR_MATCHES(enc, ptr + MINBPC(enc), ']')) {
	   ptr += MINBPC(enc);
	   break;
	 }
	 if (ptr + 2*MINBPC(enc) != end) {
	   if (!CHAR_MATCHES(enc, ptr + 2*MINBPC(enc), '>')) {
	     ptr += MINBPC(enc);
	     break;
	   }
	   *nextTokPtr = ptr + 2*MINBPC(enc);
	   return XML_TOK_INVALID;
	 }
      }
      /* fall through */
    case BT_AMP:
    case BT_LT:
    case BT_NONXML:
    case BT_MALFORM:
    case BT_TRAIL:
    case BT_CR:
    case BT_LF:
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    default:
      ptr += MINBPC(enc);
      break;
    }
  }
  *nextTokPtr = ptr;
  return XML_TOK_DATA_CHARS;
}

/* ptr points to character following "%" */

static
int PREFIX(scanPercent)(const ENCODING *enc, const char *ptr, const char *end,
			const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
  case BT_S: case BT_LF: case BT_CR: case BT_PERCNT:
    *nextTokPtr = ptr;
    return XML_TOK_PERCENT;
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
    case BT_SEMI:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_PARAM_ENTITY_REF;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return XML_TOK_PARTIAL;
}

static
int PREFIX(scanPoundName)(const ENCODING *enc, const char *ptr, const char *end,
			  const char **nextTokPtr)
{
  if (ptr == end)
    return XML_TOK_PARTIAL;
  switch (BYTE_TYPE(enc, ptr)) {
  CHECK_NMSTRT_CASES(enc, ptr, end, nextTokPtr)
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
    case BT_CR: case BT_LF: case BT_S:
    case BT_RPAR: case BT_GT: case BT_PERCNT: case BT_VERBAR:
      *nextTokPtr = ptr;
      return XML_TOK_POUND_NAME;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return -XML_TOK_POUND_NAME;
}

static
int PREFIX(scanLit)(int open, const ENCODING *enc,
		    const char *ptr, const char *end,
		    const char **nextTokPtr)
{
  while (ptr != end) {
    int t = BYTE_TYPE(enc, ptr);
    switch (t) {
    INVALID_CASES(ptr, nextTokPtr)
    case BT_QUOT:
    case BT_APOS:
      ptr += MINBPC(enc);
      if (t != open)
	break;
      if (ptr == end)
	return -XML_TOK_LITERAL;
      *nextTokPtr = ptr;
      switch (BYTE_TYPE(enc, ptr)) {
      case BT_S: case BT_CR: case BT_LF:
      case BT_GT: case BT_PERCNT: case BT_LSQB:
	return XML_TOK_LITERAL;
      default:
	return XML_TOK_INVALID;
      }
    default:
      ptr += MINBPC(enc);
      break;
    }
  }
  return XML_TOK_PARTIAL;
}

static
int PREFIX(prologTok)(const ENCODING *enc, const char *ptr, const char *end,
		      const char **nextTokPtr)
{
  int tok;
  if (ptr == end)
    return XML_TOK_NONE;
  if (MINBPC(enc) > 1) {
    size_t n = end - ptr;
    if (n & (MINBPC(enc) - 1)) {
      n &= ~(MINBPC(enc) - 1);
      if (n == 0)
	return XML_TOK_PARTIAL;
      end = ptr + n;
    }
  }
  switch (BYTE_TYPE(enc, ptr)) {
  case BT_QUOT:
    return PREFIX(scanLit)(BT_QUOT, enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_APOS:
    return PREFIX(scanLit)(BT_APOS, enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_LT:
    {
      ptr += MINBPC(enc);
      if (ptr == end)
	return XML_TOK_PARTIAL;
      switch (BYTE_TYPE(enc, ptr)) {
      case BT_EXCL:
	return PREFIX(scanDecl)(enc, ptr + MINBPC(enc), end, nextTokPtr);
      case BT_QUEST:
	return PREFIX(scanPi)(enc, ptr + MINBPC(enc), end, nextTokPtr);
      case BT_NMSTRT:
      case BT_HEX:
      case BT_NONASCII:
      case BT_LEAD2:
      case BT_LEAD3:
      case BT_LEAD4:
	*nextTokPtr = ptr - MINBPC(enc);
	return XML_TOK_INSTANCE_START;
      }
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  case BT_CR:
    if (ptr + MINBPC(enc) == end)
      return -XML_TOK_PROLOG_S;
    /* fall through */
  case BT_S: case BT_LF:
    for (;;) {
      ptr += MINBPC(enc);
      if (ptr == end)
	break;
      switch (BYTE_TYPE(enc, ptr)) {
      case BT_S: case BT_LF:
	break;
      case BT_CR:
	/* don't split CR/LF pair */
	if (ptr + MINBPC(enc) != end)
	  break;
	/* fall through */
      default:
	*nextTokPtr = ptr;
	return XML_TOK_PROLOG_S;
      }
    }
    *nextTokPtr = ptr;
    return XML_TOK_PROLOG_S;
  case BT_PERCNT:
    return PREFIX(scanPercent)(enc, ptr + MINBPC(enc), end, nextTokPtr);
  case BT_COMMA:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_COMMA;
  case BT_LSQB:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_OPEN_BRACKET;
  case BT_RSQB:
    ptr += MINBPC(enc);
    if (ptr == end)
      return -XML_TOK_CLOSE_BRACKET;
    if (CHAR_MATCHES(enc, ptr, ']')) {
      if (ptr + MINBPC(enc) == end)
	return XML_TOK_PARTIAL;
      if (CHAR_MATCHES(enc, ptr + MINBPC(enc), '>')) {
	*nextTokPtr = ptr + 2*MINBPC(enc);
	return XML_TOK_COND_SECT_CLOSE;
      }
    }
    *nextTokPtr = ptr;
    return XML_TOK_CLOSE_BRACKET;
  case BT_LPAR:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_OPEN_PAREN;
  case BT_RPAR:
    ptr += MINBPC(enc);
    if (ptr == end)
      return -XML_TOK_CLOSE_PAREN;
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_AST:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_CLOSE_PAREN_ASTERISK;
    case BT_QUEST:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_CLOSE_PAREN_QUESTION;
    case BT_PLUS:
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_CLOSE_PAREN_PLUS;
    case BT_CR: case BT_LF: case BT_S:
    case BT_GT: case BT_COMMA: case BT_VERBAR:
    case BT_RPAR:
      *nextTokPtr = ptr;
      return XML_TOK_CLOSE_PAREN;
    }
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  case BT_VERBAR:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_OR;
  case BT_GT:
    *nextTokPtr = ptr + MINBPC(enc);
    return XML_TOK_DECL_CLOSE;
  case BT_NUM:
    return PREFIX(scanPoundName)(enc, ptr + MINBPC(enc), end, nextTokPtr);
#define LEAD_CASE(n) \
  case BT_LEAD ## n: \
    if (end - ptr < n) \
      return XML_TOK_PARTIAL_CHAR; \
    if (IS_NMSTRT_CHAR(enc, ptr, n)) { \
      ptr += n; \
      tok = XML_TOK_NAME; \
      break; \
    } \
    if (IS_NAME_CHAR(enc, ptr, n)) { \
      ptr += n; \
      tok = XML_TOK_NMTOKEN; \
      break; \
    } \
    *nextTokPtr = ptr; \
    return XML_TOK_INVALID;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
  case BT_NMSTRT:
  case BT_HEX:
    tok = XML_TOK_NAME;
    ptr += MINBPC(enc);
    break;
  case BT_DIGIT:
  case BT_NAME:
  case BT_MINUS:
#ifdef XML_NS
  case BT_COLON:
#endif
    tok = XML_TOK_NMTOKEN;
    ptr += MINBPC(enc);
    break;
  case BT_NONASCII:
    if (IS_NMSTRT_CHAR_MINBPC(enc, ptr)) {
      ptr += MINBPC(enc);
      tok = XML_TOK_NAME;
      break;
    }
    if (IS_NAME_CHAR_MINBPC(enc, ptr)) {
      ptr += MINBPC(enc);
      tok = XML_TOK_NMTOKEN;
      break;
    }
    /* fall through */
  default:
    *nextTokPtr = ptr;
    return XML_TOK_INVALID;
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
    case BT_GT: case BT_RPAR: case BT_COMMA:
    case BT_VERBAR: case BT_LSQB: case BT_PERCNT:
    case BT_S: case BT_CR: case BT_LF:
      *nextTokPtr = ptr;
      return tok;
#ifdef XML_NS
    case BT_COLON:
      ptr += MINBPC(enc);
      switch (tok) {
      case XML_TOK_NAME:
	if (ptr == end)
	  return XML_TOK_PARTIAL;
	tok = XML_TOK_PREFIXED_NAME;
	switch (BYTE_TYPE(enc, ptr)) {
	CHECK_NAME_CASES(enc, ptr, end, nextTokPtr)
	default:
	  tok = XML_TOK_NMTOKEN;
	  break;
	}
	break;
      case XML_TOK_PREFIXED_NAME:
	tok = XML_TOK_NMTOKEN;
	break;
      }
      break;
#endif
    case BT_PLUS:
      if (tok == XML_TOK_NMTOKEN)  {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_NAME_PLUS;
    case BT_AST:
      if (tok == XML_TOK_NMTOKEN)  {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_NAME_ASTERISK;
    case BT_QUEST:
      if (tok == XML_TOK_NMTOKEN)  {
	*nextTokPtr = ptr;
	return XML_TOK_INVALID;
      }
      *nextTokPtr = ptr + MINBPC(enc);
      return XML_TOK_NAME_QUESTION;
    default:
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    }
  }
  return -tok;
}

static
int PREFIX(attributeValueTok)(const ENCODING *enc, const char *ptr, const char *end,
			      const char **nextTokPtr)
{
  const char *start;
  if (ptr == end)
    return XML_TOK_NONE;
  start = ptr;
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: ptr += n; break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_AMP:
      if (ptr == start)
	return PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    case BT_LT:
      /* this is for inside entity references */
      *nextTokPtr = ptr;
      return XML_TOK_INVALID;
    case BT_LF:
      if (ptr == start) {
	*nextTokPtr = ptr + MINBPC(enc);
	return XML_TOK_DATA_NEWLINE;
      }
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    case BT_CR:
      if (ptr == start) {
	ptr += MINBPC(enc);
	if (ptr == end)
	  return XML_TOK_TRAILING_CR;
	if (BYTE_TYPE(enc, ptr) == BT_LF)
	  ptr += MINBPC(enc);
	*nextTokPtr = ptr;
	return XML_TOK_DATA_NEWLINE;
      }
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    case BT_S:
      if (ptr == start) {
	*nextTokPtr = ptr + MINBPC(enc);
	return XML_TOK_ATTRIBUTE_VALUE_S;
      }
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    default:
      ptr += MINBPC(enc);
      break;
    }
  }
  *nextTokPtr = ptr;
  return XML_TOK_DATA_CHARS;
}

static
int PREFIX(entityValueTok)(const ENCODING *enc, const char *ptr, const char *end,
			   const char **nextTokPtr)
{
  const char *start;
  if (ptr == end)
    return XML_TOK_NONE;
  start = ptr;
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: ptr += n; break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_AMP:
      if (ptr == start)
	return PREFIX(scanRef)(enc, ptr + MINBPC(enc), end, nextTokPtr);
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    case BT_PERCNT:
      if (ptr == start)
	return PREFIX(scanPercent)(enc, ptr + MINBPC(enc), end, nextTokPtr);
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    case BT_LF:
      if (ptr == start) {
	*nextTokPtr = ptr + MINBPC(enc);
	return XML_TOK_DATA_NEWLINE;
      }
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    case BT_CR:
      if (ptr == start) {
	ptr += MINBPC(enc);
	if (ptr == end)
	  return XML_TOK_TRAILING_CR;
	if (BYTE_TYPE(enc, ptr) == BT_LF)
	  ptr += MINBPC(enc);
	*nextTokPtr = ptr;
	return XML_TOK_DATA_NEWLINE;
      }
      *nextTokPtr = ptr;
      return XML_TOK_DATA_CHARS;
    default:
      ptr += MINBPC(enc);
      break;
    }
  }
  *nextTokPtr = ptr;
  return XML_TOK_DATA_CHARS;
}

#ifdef XML_DTD

static
int PREFIX(ignoreSectionTok)(const ENCODING *enc, const char *ptr, const char *end,
			     const char **nextTokPtr)
{
  int level = 0;
  if (MINBPC(enc) > 1) {
    size_t n = end - ptr;
    if (n & (MINBPC(enc) - 1)) {
      n &= ~(MINBPC(enc) - 1);
      end = ptr + n;
    }
  }
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
    INVALID_CASES(ptr, nextTokPtr)
    case BT_LT:
      if ((ptr += MINBPC(enc)) == end)
	return XML_TOK_PARTIAL;
      if (CHAR_MATCHES(enc, ptr, '!')) {
	if ((ptr += MINBPC(enc)) == end)
	  return XML_TOK_PARTIAL;
	if (CHAR_MATCHES(enc, ptr, '[')) {
	  ++level;
	  ptr += MINBPC(enc);
	}
      }
      break;
    case BT_RSQB:
      if ((ptr += MINBPC(enc)) == end)
	return XML_TOK_PARTIAL;
      if (CHAR_MATCHES(enc, ptr, ']')) {
	if ((ptr += MINBPC(enc)) == end)
	  return XML_TOK_PARTIAL;
	if (CHAR_MATCHES(enc, ptr, '>')) {
	  ptr += MINBPC(enc);
	  if (level == 0) {
	    *nextTokPtr = ptr;
	    return XML_TOK_IGNORE_SECT;
	  }
	  --level;
	}
      }
      break;
    default:
      ptr += MINBPC(enc);
      break;
    }
  }
  return XML_TOK_PARTIAL;
}

#endif /* XML_DTD */

static
int PREFIX(isPublicId)(const ENCODING *enc, const char *ptr, const char *end,
		       const char **badPtr)
{
  ptr += MINBPC(enc);
  end -= MINBPC(enc);
  for (; ptr != end; ptr += MINBPC(enc)) {
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_DIGIT:
    case BT_HEX:
    case BT_MINUS:
    case BT_APOS:
    case BT_LPAR:
    case BT_RPAR:
    case BT_PLUS:
    case BT_COMMA:
    case BT_SOL:
    case BT_EQUALS:
    case BT_QUEST:
    case BT_CR:
    case BT_LF:
    case BT_SEMI:
    case BT_EXCL:
    case BT_AST:
    case BT_PERCNT:
    case BT_NUM:
#ifdef XML_NS
    case BT_COLON:
#endif
      break;
    case BT_S:
      if (CHAR_MATCHES(enc, ptr, '\t')) {
	*badPtr = ptr;
	return 0;
      }
      break;
    case BT_NAME:
    case BT_NMSTRT:
      if (!(BYTE_TO_ASCII(enc, ptr) & ~0x7f))
	break;
    default:
      switch (BYTE_TO_ASCII(enc, ptr)) {
      case 0x24: /* $ */
      case 0x40: /* @ */
	break;
      default:
	*badPtr = ptr;
	return 0;
      }
      break;
    }
  }
  return 1;
}

/* This must only be called for a well-formed start-tag or empty element tag.
Returns the number of attributes.  Pointers to the first attsMax attributes 
are stored in atts. */

static
int PREFIX(getAtts)(const ENCODING *enc, const char *ptr,
		    int attsMax, ATTRIBUTE *atts)
{
  enum { other, inName, inValue } state = inName;
  int nAtts = 0;
  int open = 0; /* defined when state == inValue;
		   initialization just to shut up compilers */

  for (ptr += MINBPC(enc);; ptr += MINBPC(enc)) {
    switch (BYTE_TYPE(enc, ptr)) {
#define START_NAME \
      if (state == other) { \
	if (nAtts < attsMax) { \
	  atts[nAtts].name = ptr; \
	  atts[nAtts].normalized = 1; \
	} \
	state = inName; \
      }
#define LEAD_CASE(n) \
    case BT_LEAD ## n: START_NAME ptr += (n - MINBPC(enc)); break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_NONASCII:
    case BT_NMSTRT:
    case BT_HEX:
      START_NAME
      break;
#undef START_NAME
    case BT_QUOT:
      if (state != inValue) {
	if (nAtts < attsMax)
	  atts[nAtts].valuePtr = ptr + MINBPC(enc);
        state = inValue;
        open = BT_QUOT;
      }
      else if (open == BT_QUOT) {
        state = other;
	if (nAtts < attsMax)
	  atts[nAtts].valueEnd = ptr;
	nAtts++;
      }
      break;
    case BT_APOS:
      if (state != inValue) {
	if (nAtts < attsMax)
	  atts[nAtts].valuePtr = ptr + MINBPC(enc);
        state = inValue;
        open = BT_APOS;
      }
      else if (open == BT_APOS) {
        state = other;
	if (nAtts < attsMax)
	  atts[nAtts].valueEnd = ptr;
	nAtts++;
      }
      break;
    case BT_AMP:
      if (nAtts < attsMax)
	atts[nAtts].normalized = 0;
      break;
    case BT_S:
      if (state == inName)
        state = other;
      else if (state == inValue
	       && nAtts < attsMax
	       && atts[nAtts].normalized
	       && (ptr == atts[nAtts].valuePtr
		   || BYTE_TO_ASCII(enc, ptr) != ' '
		   || BYTE_TO_ASCII(enc, ptr + MINBPC(enc)) == ' '
	           || BYTE_TYPE(enc, ptr + MINBPC(enc)) == open))
	atts[nAtts].normalized = 0;
      break;
    case BT_CR: case BT_LF:
      /* This case ensures that the first attribute name is counted
         Apart from that we could just change state on the quote. */
      if (state == inName)
        state = other;
      else if (state == inValue && nAtts < attsMax)
	atts[nAtts].normalized = 0;
      break;
    case BT_GT:
    case BT_SOL:
      if (state != inValue)
	return nAtts;
      break;
    default:
      break;
    }
  }
  /* not reached */
}

static
int PREFIX(charRefNumber)(const ENCODING *enc, const char *ptr)
{
  int result = 0;
  /* skip &# */
  ptr += 2*MINBPC(enc);
  if (CHAR_MATCHES(enc, ptr, 'x')) {
    for (ptr += MINBPC(enc); !CHAR_MATCHES(enc, ptr, ';'); ptr += MINBPC(enc)) {
      int c = BYTE_TO_ASCII(enc, ptr);
      switch (c) {
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
	result <<= 4;
	result |= (c - '0');
	break;
      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
	result <<= 4;
	result += 10 + (c - 'A');
	break;
      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
	result <<= 4;
	result += 10 + (c - 'a');
	break;
      }
      if (result >= 0x110000)
	return -1;
    }
  }
  else {
    for (; !CHAR_MATCHES(enc, ptr, ';'); ptr += MINBPC(enc)) {
      int c = BYTE_TO_ASCII(enc, ptr);
      result *= 10;
      result += (c - '0');
      if (result >= 0x110000)
	return -1;
    }
  }
  return checkCharRefNumber(result);
}

static
int PREFIX(predefinedEntityName)(const ENCODING *enc, const char *ptr, const char *end)
{
  switch ((end - ptr)/MINBPC(enc)) {
  case 2:
    if (CHAR_MATCHES(enc, ptr + MINBPC(enc), 't')) {
      switch (BYTE_TO_ASCII(enc, ptr)) {
      case 'l':
	return '<';
      case 'g':
	return '>';
      }
    }
    break;
  case 3:
    if (CHAR_MATCHES(enc, ptr, 'a')) {
      ptr += MINBPC(enc);
      if (CHAR_MATCHES(enc, ptr, 'm')) {
	ptr += MINBPC(enc);
	if (CHAR_MATCHES(enc, ptr, 'p'))
	  return '&';
      }
    }
    break;
  case 4:
    switch (BYTE_TO_ASCII(enc, ptr)) {
    case 'q':
      ptr += MINBPC(enc);
      if (CHAR_MATCHES(enc, ptr, 'u')) {
	ptr += MINBPC(enc);
	if (CHAR_MATCHES(enc, ptr, 'o')) {
	  ptr += MINBPC(enc);
  	  if (CHAR_MATCHES(enc, ptr, 't'))
	    return '"';
	}
      }
      break;
    case 'a':
      ptr += MINBPC(enc);
      if (CHAR_MATCHES(enc, ptr, 'p')) {
	ptr += MINBPC(enc);
	if (CHAR_MATCHES(enc, ptr, 'o')) {
	  ptr += MINBPC(enc);
  	  if (CHAR_MATCHES(enc, ptr, 's'))
	    return '\'';
	}
      }
      break;
    }
  }
  return 0;
}

static
int PREFIX(sameName)(const ENCODING *enc, const char *ptr1, const char *ptr2)
{
  for (;;) {
    switch (BYTE_TYPE(enc, ptr1)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: \
      if (*ptr1++ != *ptr2++) \
	return 0;
    LEAD_CASE(4) LEAD_CASE(3) LEAD_CASE(2)
#undef LEAD_CASE
      /* fall through */
      if (*ptr1++ != *ptr2++)
	return 0;
      break;
    case BT_NONASCII:
    case BT_NMSTRT:
#ifdef XML_NS
    case BT_COLON:
#endif
    case BT_HEX:
    case BT_DIGIT:
    case BT_NAME:
    case BT_MINUS:
      if (*ptr2++ != *ptr1++)
	return 0;
      if (MINBPC(enc) > 1) {
	if (*ptr2++ != *ptr1++)
	  return 0;
	if (MINBPC(enc) > 2) {
	  if (*ptr2++ != *ptr1++)
	    return 0;
          if (MINBPC(enc) > 3) {
	    if (*ptr2++ != *ptr1++)
      	      return 0;
	  }
	}
      }
      break;
    default:
      if (MINBPC(enc) == 1 && *ptr1 == *ptr2)
	return 1;
      switch (BYTE_TYPE(enc, ptr2)) {
      case BT_LEAD2:
      case BT_LEAD3:
      case BT_LEAD4:
      case BT_NONASCII:
      case BT_NMSTRT:
#ifdef XML_NS
      case BT_COLON:
#endif
      case BT_HEX:
      case BT_DIGIT:
      case BT_NAME:
      case BT_MINUS:
	return 0;
      default:
	return 1;
      }
    }
  }
  /* not reached */
}

static
int PREFIX(nameMatchesAscii)(const ENCODING *enc, const char *ptr1,
			     const char *end1, const char *ptr2)
{
  for (; *ptr2; ptr1 += MINBPC(enc), ptr2++) {
    if (ptr1 == end1)
      return 0;
    if (!CHAR_MATCHES(enc, ptr1, *ptr2))
      return 0;
  }
  return ptr1 == end1;
}

static
int PREFIX(nameLength)(const ENCODING *enc, const char *ptr)
{
  const char *start = ptr;
  for (;;) {
    switch (BYTE_TYPE(enc, ptr)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: ptr += n; break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_NONASCII:
    case BT_NMSTRT:
#ifdef XML_NS
    case BT_COLON:
#endif
    case BT_HEX:
    case BT_DIGIT:
    case BT_NAME:
    case BT_MINUS:
      ptr += MINBPC(enc);
      break;
    default:
      return ptr - start;
    }
  }
}

static
const char *PREFIX(skipS)(const ENCODING *enc, const char *ptr)
{
  for (;;) {
    switch (BYTE_TYPE(enc, ptr)) {
    case BT_LF:
    case BT_CR:
    case BT_S:
      ptr += MINBPC(enc);
      break;
    default:
      return ptr;
    }
  }
}

static
void PREFIX(updatePosition)(const ENCODING *enc,
			    const char *ptr,
			    const char *end,
			    POSITION *pos)
{
  while (ptr != end) {
    switch (BYTE_TYPE(enc, ptr)) {
#define LEAD_CASE(n) \
    case BT_LEAD ## n: \
      ptr += n; \
      break;
    LEAD_CASE(2) LEAD_CASE(3) LEAD_CASE(4)
#undef LEAD_CASE
    case BT_LF:
      pos->columnNumber = (unsigned)-1;
      pos->lineNumber++;
      ptr += MINBPC(enc);
      break;
    case BT_CR:
      pos->lineNumber++;
      ptr += MINBPC(enc);
      if (ptr != end && BYTE_TYPE(enc, ptr) == BT_LF)
	ptr += MINBPC(enc);
      pos->columnNumber = (unsigned)-1;
      break;
    default:
      ptr += MINBPC(enc);
      break;
    }
    pos->columnNumber++;
  }
}

#undef DO_LEAD_CASE
#undef MULTIBYTE_CASES
#undef INVALID_CASES
#undef CHECK_NAME_CASE
#undef CHECK_NAME_CASES
#undef CHECK_NMSTRT_CASE
#undef CHECK_NMSTRT_CASES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmlrole.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#ifndef XmlRole_INCLUDED
#define XmlRole_INCLUDED 1

#include "xmltok.h"

#ifdef __cplusplus
extern "C" {
#endif

enum {
  XML_ROLE_ERROR = -1,
  XML_ROLE_NONE = 0,
  XML_ROLE_XML_DECL,
  XML_ROLE_INSTANCE_START,
  XML_ROLE_DOCTYPE_NAME,
  XML_ROLE_DOCTYPE_SYSTEM_ID,
  XML_ROLE_DOCTYPE_PUBLIC_ID,
  XML_ROLE_DOCTYPE_CLOSE,
  XML_ROLE_GENERAL_ENTITY_NAME,
  XML_ROLE_PARAM_ENTITY_NAME,
  XML_ROLE_ENTITY_VALUE,
  XML_ROLE_ENTITY_SYSTEM_ID,
  XML_ROLE_ENTITY_PUBLIC_ID,
  XML_ROLE_ENTITY_NOTATION_NAME,
  XML_ROLE_NOTATION_NAME,
  XML_ROLE_NOTATION_SYSTEM_ID,
  XML_ROLE_NOTATION_NO_SYSTEM_ID,
  XML_ROLE_NOTATION_PUBLIC_ID,
  XML_ROLE_ATTRIBUTE_NAME,
  XML_ROLE_ATTRIBUTE_TYPE_CDATA,
  XML_ROLE_ATTRIBUTE_TYPE_ID,
  XML_ROLE_ATTRIBUTE_TYPE_IDREF,
  XML_ROLE_ATTRIBUTE_TYPE_IDREFS,
  XML_ROLE_ATTRIBUTE_TYPE_ENTITY,
  XML_ROLE_ATTRIBUTE_TYPE_ENTITIES,
  XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN,
  XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS,
  XML_ROLE_ATTRIBUTE_ENUM_VALUE,
  XML_ROLE_ATTRIBUTE_NOTATION_VALUE,
  XML_ROLE_ATTLIST_ELEMENT_NAME,
  XML_ROLE_IMPLIED_ATTRIBUTE_VALUE,
  XML_ROLE_REQUIRED_ATTRIBUTE_VALUE,
  XML_ROLE_DEFAULT_ATTRIBUTE_VALUE,
  XML_ROLE_FIXED_ATTRIBUTE_VALUE,
  XML_ROLE_ELEMENT_NAME,
  XML_ROLE_CONTENT_ANY,
  XML_ROLE_CONTENT_EMPTY,
  XML_ROLE_CONTENT_PCDATA,
  XML_ROLE_GROUP_OPEN,
  XML_ROLE_GROUP_CLOSE,
  XML_ROLE_GROUP_CLOSE_REP,
  XML_ROLE_GROUP_CLOSE_OPT,
  XML_ROLE_GROUP_CLOSE_PLUS,
  XML_ROLE_GROUP_CHOICE,
  XML_ROLE_GROUP_SEQUENCE,
  XML_ROLE_CONTENT_ELEMENT,
  XML_ROLE_CONTENT_ELEMENT_REP,
  XML_ROLE_CONTENT_ELEMENT_OPT,
  XML_ROLE_CONTENT_ELEMENT_PLUS,
#ifdef XML_DTD
  XML_ROLE_TEXT_DECL,
  XML_ROLE_IGNORE_SECT,
  XML_ROLE_INNER_PARAM_ENTITY_REF,
#endif /* XML_DTD */
  XML_ROLE_PARAM_ENTITY_REF
};

typedef struct prolog_state {
  int (*handler)(struct prolog_state *state,
	         int tok,
		 const char *ptr,
		 const char *end,
		 const ENCODING *enc);
  unsigned level;
#ifdef XML_DTD
  unsigned includeLevel;
  int documentEntity;
#endif /* XML_DTD */
} PROLOG_STATE;

void XMLTOKAPI XmlPrologStateInit(PROLOG_STATE *);
#ifdef XML_DTD
void XMLTOKAPI XmlPrologStateInitExternalEntity(PROLOG_STATE *);
#endif /* XML_DTD */

#define XmlTokenRole(state, tok, ptr, end, enc) \
 (((state)->handler)(state, tok, ptr, end, enc))

#ifdef __cplusplus
}
#endif

#endif /* not XmlRole_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmltok_ns.c ===
const ENCODING *NS(XmlGetUtf8InternalEncoding)(void)
{
  return &ns(internal_utf8_encoding).enc;
}

const ENCODING *NS(XmlGetUtf16InternalEncoding)(void)
{
#if XML_BYTE_ORDER == 12
  return &ns(internal_little2_encoding).enc;
#elif XML_BYTE_ORDER == 21
  return &ns(internal_big2_encoding).enc;
#else
  const short n = 1;
  return *(const char *)&n ? &ns(internal_little2_encoding).enc : &ns(internal_big2_encoding).enc;
#endif
}

static
const ENCODING *NS(encodings)[] = {
  &ns(latin1_encoding).enc,
  &ns(ascii_encoding).enc,
  &ns(utf8_encoding).enc,
  &ns(big2_encoding).enc,
  &ns(big2_encoding).enc,
  &ns(little2_encoding).enc,
  &ns(utf8_encoding).enc /* NO_ENC */
};

static
int NS(initScanProlog)(const ENCODING *enc, const char *ptr, const char *end,
		       const char **nextTokPtr)
{
  return initScan(NS(encodings), (const INIT_ENCODING *)enc, XML_PROLOG_STATE, ptr, end, nextTokPtr);
}

static
int NS(initScanContent)(const ENCODING *enc, const char *ptr, const char *end,
		       const char **nextTokPtr)
{
  return initScan(NS(encodings), (const INIT_ENCODING *)enc, XML_CONTENT_STATE, ptr, end, nextTokPtr);
}

int NS(XmlInitEncoding)(INIT_ENCODING *p, const ENCODING **encPtr, const char *name)
{
  int i = getEncodingIndex(name);
  if (i == UNKNOWN_ENC)
    return 0;
  SET_INIT_ENC_INDEX(p, i);
  p->initEnc.scanners[XML_PROLOG_STATE] = NS(initScanProlog);
  p->initEnc.scanners[XML_CONTENT_STATE] = NS(initScanContent);
  p->initEnc.updatePosition = initUpdatePosition;
  p->encPtr = encPtr;
  *encPtr = &(p->initEnc);
  return 1;
}

static
const ENCODING *NS(findEncoding)(const ENCODING *enc, const char *ptr, const char *end)
{
#define ENCODING_MAX 128
  char buf[ENCODING_MAX];
  char *p = buf;
  int i;
  XmlUtf8Convert(enc, &ptr, end, &p, p + ENCODING_MAX - 1);
  if (ptr != end)
    return 0;
  *p = 0;
  if (streqci(buf, "UTF-16") && enc->minBytesPerChar == 2)
    return enc;
  i = getEncodingIndex(buf);
  if (i == UNKNOWN_ENC)
    return 0;
  return NS(encodings)[i];
}

int NS(XmlParseXmlDecl)(int isGeneralTextEntity,
			const ENCODING *enc,
			const char *ptr,
			const char *end,
			const char **badPtr,
			const char **versionPtr,
			const char **encodingName,
			const ENCODING **encoding,
			int *standalone)
{
  return doParseXmlDecl(NS(findEncoding),
			isGeneralTextEntity,
			enc,
			ptr,
			end,
			badPtr,
			versionPtr,
			encodingName,
			encoding,
			standalone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmltok_impl.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

enum {
  BT_NONXML,
  BT_MALFORM,
  BT_LT,
  BT_AMP,
  BT_RSQB,
  BT_LEAD2,
  BT_LEAD3,
  BT_LEAD4,
  BT_TRAIL,
  BT_CR,
  BT_LF,
  BT_GT,
  BT_QUOT,
  BT_APOS,
  BT_EQUALS,
  BT_QUEST,
  BT_EXCL,
  BT_SOL,
  BT_SEMI,
  BT_NUM,
  BT_LSQB,
  BT_S,
  BT_NMSTRT,
  BT_COLON,
  BT_HEX,
  BT_DIGIT,
  BT_NAME,
  BT_MINUS,
  BT_OTHER, /* known not to be a name or name start character */
  BT_NONASCII, /* might be a name or name start character */
  BT_PERCNT,
  BT_LPAR,
  BT_RPAR,
  BT_AST,
  BT_PLUS,
  BT_COMMA,
  BT_VERBAR
};

#include <stddef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmltok\xmlrole.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include "xmldef.h"
#include "xmlrole.h"

/* Doesn't check:

 that ,| are not mixed in a model group
 content of literals

*/

#ifndef MIN_BYTES_PER_CHAR
#define MIN_BYTES_PER_CHAR(enc) ((enc)->minBytesPerChar)
#endif

#ifdef XML_DTD
#define setTopLevel(state) \
  ((state)->handler = ((state)->documentEntity \
                       ? internalSubset \
                       : externalSubset1))
#else /* not XML_DTD */
#define setTopLevel(state) ((state)->handler = internalSubset)
#endif /* not XML_DTD */

typedef int PROLOG_HANDLER(PROLOG_STATE *state,
			   int tok,
			   const char *ptr,
			   const char *end,
			   const ENCODING *enc);

static PROLOG_HANDLER
  prolog0, prolog1, prolog2,
  doctype0, doctype1, doctype2, doctype3, doctype4, doctype5,
  internalSubset,
  entity0, entity1, entity2, entity3, entity4, entity5, entity6,
  entity7, entity8, entity9,
  notation0, notation1, notation2, notation3, notation4,
  attlist0, attlist1, attlist2, attlist3, attlist4, attlist5, attlist6,
  attlist7, attlist8, attlist9,
  element0, element1, element2, element3, element4, element5, element6,
  element7,
#ifdef XML_DTD
  externalSubset0, externalSubset1,
  condSect0, condSect1, condSect2,
#endif /* XML_DTD */
  declClose,
  error;

static
int common(PROLOG_STATE *state, int tok);

static
int prolog0(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    state->handler = prolog1;
    return XML_ROLE_NONE;
  case XML_TOK_XML_DECL:
    state->handler = prolog1;
    return XML_ROLE_XML_DECL;
  case XML_TOK_PI:
    state->handler = prolog1;
    return XML_ROLE_NONE;
  case XML_TOK_COMMENT:
    state->handler = prolog1;
  case XML_TOK_BOM:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_OPEN:
    if (!XmlNameMatchesAscii(enc,
			     ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			     end,
			     "DOCTYPE"))
      break;
    state->handler = doctype0;
    return XML_ROLE_NONE;
  case XML_TOK_INSTANCE_START:
    state->handler = error;
    return XML_ROLE_INSTANCE_START;
  }
  return common(state, tok);
}

static
int prolog1(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_PI:
  case XML_TOK_COMMENT:
  case XML_TOK_BOM:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_OPEN:
    if (!XmlNameMatchesAscii(enc,
			     ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			     end,
			     "DOCTYPE"))
      break;
    state->handler = doctype0;
    return XML_ROLE_NONE;
  case XML_TOK_INSTANCE_START:
    state->handler = error;
    return XML_ROLE_INSTANCE_START;
  }
  return common(state, tok);
}

static
int prolog2(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_PI:
  case XML_TOK_COMMENT:
    return XML_ROLE_NONE;
  case XML_TOK_INSTANCE_START:
    state->handler = error;
    return XML_ROLE_INSTANCE_START;
  }
  return common(state, tok);
}

static
int doctype0(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = doctype1;
    return XML_ROLE_DOCTYPE_NAME;
  }
  return common(state, tok);
}

static
int doctype1(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = internalSubset;
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    state->handler = prolog2;
    return XML_ROLE_DOCTYPE_CLOSE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "SYSTEM")) {
      state->handler = doctype3;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "PUBLIC")) {
      state->handler = doctype2;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int doctype2(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = doctype3;
    return XML_ROLE_DOCTYPE_PUBLIC_ID;
  }
  return common(state, tok);
}

static
int doctype3(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = doctype4;
    return XML_ROLE_DOCTYPE_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int doctype4(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = internalSubset;
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    state->handler = prolog2;
    return XML_ROLE_DOCTYPE_CLOSE;
  }
  return common(state, tok);
}

static
int doctype5(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    state->handler = prolog2;
    return XML_ROLE_DOCTYPE_CLOSE;
  }
  return common(state, tok);
}

static
int internalSubset(PROLOG_STATE *state,
		   int tok,
		   const char *ptr,
		   const char *end,
		   const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_OPEN:
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    "ENTITY")) {
      state->handler = entity0;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    "ATTLIST")) {
      state->handler = attlist0;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    "ELEMENT")) {
      state->handler = element0;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    "NOTATION")) {
      state->handler = notation0;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_PI:
  case XML_TOK_COMMENT:
    return XML_ROLE_NONE;
  case XML_TOK_PARAM_ENTITY_REF:
    return XML_ROLE_PARAM_ENTITY_REF;
  case XML_TOK_CLOSE_BRACKET:
    state->handler = doctype5;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

#ifdef XML_DTD

static
int externalSubset0(PROLOG_STATE *state,
		    int tok,
		    const char *ptr,
		    const char *end,
		    const ENCODING *enc)
{
  state->handler = externalSubset1;
  if (tok == XML_TOK_XML_DECL)
    return XML_ROLE_TEXT_DECL;
  return externalSubset1(state, tok, ptr, end, enc);
}

static
int externalSubset1(PROLOG_STATE *state,
		    int tok,
		    const char *ptr,
		    const char *end,
		    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_COND_SECT_OPEN:
    state->handler = condSect0;
    return XML_ROLE_NONE;
  case XML_TOK_COND_SECT_CLOSE:
    if (state->includeLevel == 0)
      break;
    state->includeLevel -= 1;
    return XML_ROLE_NONE;
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_BRACKET:
    break;
  case XML_TOK_NONE:
    if (state->includeLevel)
      break;
    return XML_ROLE_NONE;
  default:
    return internalSubset(state, tok, ptr, end, enc);
  }
  return common(state, tok);
}

#endif /* XML_DTD */

static
int entity0(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_PERCENT:
    state->handler = entity1;
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = entity2;
    return XML_ROLE_GENERAL_ENTITY_NAME;
  }
  return common(state, tok);
}

static
int entity1(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = entity7;
    return XML_ROLE_PARAM_ENTITY_NAME;
  }
  return common(state, tok);
}

static
int entity2(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "SYSTEM")) {
      state->handler = entity4;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "PUBLIC")) {
      state->handler = entity3;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_ENTITY_VALUE;
  }
  return common(state, tok);
}

static
int entity3(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = entity4;
    return XML_ROLE_ENTITY_PUBLIC_ID;
  }
  return common(state, tok);
}


static
int entity4(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = entity5;
    return XML_ROLE_ENTITY_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int entity5(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "NDATA")) {
      state->handler = entity6;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int entity6(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = declClose;
    return XML_ROLE_ENTITY_NOTATION_NAME;
  }
  return common(state, tok);
}

static
int entity7(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "SYSTEM")) {
      state->handler = entity9;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "PUBLIC")) {
      state->handler = entity8;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_ENTITY_VALUE;
  }
  return common(state, tok);
}

static
int entity8(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = entity9;
    return XML_ROLE_ENTITY_PUBLIC_ID;
  }
  return common(state, tok);
}

static
int entity9(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_ENTITY_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int notation0(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = notation1;
    return XML_ROLE_NOTATION_NAME;
  }
  return common(state, tok);
}

static
int notation1(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "SYSTEM")) {
      state->handler = notation3;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "PUBLIC")) {
      state->handler = notation2;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int notation2(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = notation4;
    return XML_ROLE_NOTATION_PUBLIC_ID;
  }
  return common(state, tok);
}

static
int notation3(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_NOTATION_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int notation4(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_NOTATION_SYSTEM_ID;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NOTATION_NO_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int attlist0(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = attlist1;
    return XML_ROLE_ATTLIST_ELEMENT_NAME;
  }
  return common(state, tok);
}

static
int attlist1(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = attlist2;
    return XML_ROLE_ATTRIBUTE_NAME;
  }
  return common(state, tok);
}

static
int attlist2(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    {
      static const char *types[] = {
	"CDATA",
        "ID",
        "IDREF",
        "IDREFS",
        "ENTITY",
        "ENTITIES",
        "NMTOKEN",
        "NMTOKENS",
      };
      int i;
      for (i = 0; i < (int)(sizeof(types)/sizeof(types[0])); i++)
	if (XmlNameMatchesAscii(enc, ptr, end, types[i])) {
	  state->handler = attlist8;
	  return XML_ROLE_ATTRIBUTE_TYPE_CDATA + i;
	}
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "NOTATION")) {
      state->handler = attlist5;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_OPEN_PAREN:
    state->handler = attlist3;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int attlist3(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NMTOKEN:
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = attlist4;
    return XML_ROLE_ATTRIBUTE_ENUM_VALUE;
  }
  return common(state, tok);
}

static
int attlist4(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->handler = attlist8;
    return XML_ROLE_NONE;
  case XML_TOK_OR:
    state->handler = attlist3;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int attlist5(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_PAREN:
    state->handler = attlist6;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}


static
int attlist6(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = attlist7;
    return XML_ROLE_ATTRIBUTE_NOTATION_VALUE;
  }
  return common(state, tok);
}

static
int attlist7(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->handler = attlist8;
    return XML_ROLE_NONE;
  case XML_TOK_OR:
    state->handler = attlist6;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

/* default value */
static
int attlist8(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_POUND_NAME:
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    "IMPLIED")) {
      state->handler = attlist1;
      return XML_ROLE_IMPLIED_ATTRIBUTE_VALUE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    "REQUIRED")) {
      state->handler = attlist1;
      return XML_ROLE_REQUIRED_ATTRIBUTE_VALUE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    "FIXED")) {
      state->handler = attlist9;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_LITERAL:
    state->handler = attlist1;
    return XML_ROLE_DEFAULT_ATTRIBUTE_VALUE;
  }
  return common(state, tok);
}

static
int attlist9(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = attlist1;
    return XML_ROLE_FIXED_ATTRIBUTE_VALUE;
  }
  return common(state, tok);
}

static
int element0(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element1;
    return XML_ROLE_ELEMENT_NAME;
  }
  return common(state, tok);
}

static
int element1(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "EMPTY")) {
      state->handler = declClose;
      return XML_ROLE_CONTENT_EMPTY;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "ANY")) {
      state->handler = declClose;
      return XML_ROLE_CONTENT_ANY;
    }
    break;
  case XML_TOK_OPEN_PAREN:
    state->handler = element2;
    state->level = 1;
    return XML_ROLE_GROUP_OPEN;
  }
  return common(state, tok);
}

static
int element2(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_POUND_NAME:
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    "PCDATA")) {
      state->handler = element3;
      return XML_ROLE_CONTENT_PCDATA;
    }
    break;
  case XML_TOK_OPEN_PAREN:
    state->level = 2;
    state->handler = element6;
    return XML_ROLE_GROUP_OPEN;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT;
  case XML_TOK_NAME_QUESTION:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_OPT;
  case XML_TOK_NAME_ASTERISK:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_REP;
  case XML_TOK_NAME_PLUS:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_PLUS;
  }
  return common(state, tok);
}

static
int element3(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
  case XML_TOK_CLOSE_PAREN_ASTERISK:
    state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_REP;
  case XML_TOK_OR:
    state->handler = element4;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int element4(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element5;
    return XML_ROLE_CONTENT_ELEMENT;
  }
  return common(state, tok);
}

static
int element5(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN_ASTERISK:
    state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_REP;
  case XML_TOK_OR:
    state->handler = element4;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int element6(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_PAREN:
    state->level += 1;
    return XML_ROLE_GROUP_OPEN;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT;
  case XML_TOK_NAME_QUESTION:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_OPT;
  case XML_TOK_NAME_ASTERISK:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_REP;
  case XML_TOK_NAME_PLUS:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_PLUS;
  }
  return common(state, tok);
}

static
int element7(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE;
  case XML_TOK_CLOSE_PAREN_ASTERISK:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_REP;
  case XML_TOK_CLOSE_PAREN_QUESTION:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_OPT;
  case XML_TOK_CLOSE_PAREN_PLUS:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_PLUS;
  case XML_TOK_COMMA:
    state->handler = element6;
    return XML_ROLE_GROUP_SEQUENCE;
  case XML_TOK_OR:
    state->handler = element6;
    return XML_ROLE_GROUP_CHOICE;
  }
  return common(state, tok);
}

#ifdef XML_DTD

static
int condSect0(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, "INCLUDE")) {
      state->handler = condSect1;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, "IGNORE")) {
      state->handler = condSect2;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int condSect1(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = externalSubset1;
    state->includeLevel += 1;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int condSect2(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = externalSubset1;
    return XML_ROLE_IGNORE_SECT;
  }
  return common(state, tok);
}

#endif /* XML_DTD */

static
int declClose(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

#if 0

static
int ignore(PROLOG_STATE *state,
	   int tok,
	   const char *ptr,
	   const char *end,
	   const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_DECL_CLOSE:
    state->handler = internalSubset;
    return 0;
  default:
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}
#endif

static
int error(PROLOG_STATE *state,
	  int tok,
	  const char *ptr,
	  const char *end,
	  const ENCODING *enc)
{
  return XML_ROLE_NONE;
}

static
int common(PROLOG_STATE *state, int tok)
{
#ifdef XML_DTD
  if (!state->documentEntity && tok == XML_TOK_PARAM_ENTITY_REF)
    return XML_ROLE_INNER_PARAM_ENTITY_REF;
#endif
  state->handler = error;
  return XML_ROLE_ERROR;
}

void XmlPrologStateInit(PROLOG_STATE *state)
{
  state->handler = prolog0;
#ifdef XML_DTD
  state->documentEntity = 1;
  state->includeLevel = 0;
#endif /* XML_DTD */
}

#ifdef XML_DTD

void XmlPrologStateInitExternalEntity(PROLOG_STATE *state)
{
  state->handler = externalSubset0;
  state->documentEntity = 0;
  state->includeLevel = 0;
}

#endif /* XML_DTD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\codepage.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include "codepage.h"

#ifdef WIN32
#define STRICT 1
#define WIN32_LEAN_AND_MEAN 1

#include <windows.h>

int codepageMap(int cp, int *map)
{
  int i;
  CPINFO info;
  if (!GetCPInfo(cp, &info) || info.MaxCharSize > 2)
    return 0;
  for (i = 0; i < 256; i++)
    map[i] = -1;
  if (info.MaxCharSize > 1) {
    for (i = 0; i < MAX_LEADBYTES; i++) {
      int j, lim;
      if (info.LeadByte[i] == 0 && info.LeadByte[i + 1] == 0)
        break;
      lim = info.LeadByte[i + 1];
      for (j = info.LeadByte[i]; j < lim; j++)
	map[j] = -2;
    }
  }
  for (i = 0; i < 256; i++) {
   if (map[i] == -1) {
     char c = i;
     unsigned short n;
     if (MultiByteToWideChar(cp, MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
		             &c, 1, &n, 1) == 1)
       map[i] = n;
   }
  }
  return 1;
}

int codepageConvert(int cp, const char *p)
{
  unsigned short c;
  if (MultiByteToWideChar(cp, MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
		          p, 2, &c, 1) == 1)
    return c;
  return -1;
}

#else /* not WIN32 */

int codepageMap(int cp, int *map)
{
  return 0;
}

int codepageConvert(int cp, const char *p)
{
  return -1;
}

#endif /* not WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\codepage.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

int codepageMap(int cp, int *map);
int codepageConvert(int cp, const char *p);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\readfilemap.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef S_ISREG
#ifndef S_IFREG
#define S_IFREG _S_IFREG
#endif
#ifndef S_IFMT
#define S_IFMT _S_IFMT
#endif
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif /* not S_ISREG */

#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#else
#define O_BINARY 0
#endif
#endif

int filemap(const char *name,
	    void (*processor)(const void *, size_t, const char *, void *arg),
	    void *arg)
{
  size_t nbytes;
  int fd;
  int n;
  struct stat sb;
  void *p;

  fd = open(name, O_RDONLY|O_BINARY);
  if (fd < 0) {
    perror(name);
    return 0;
  }
  if (fstat(fd, &sb) < 0) {
    perror(name);
    return 0;
  }
  if (!S_ISREG(sb.st_mode)) {
    fprintf(stderr, "%s: not a regular file\n", name);
    return 0;
  }
  nbytes = sb.st_size;
  p = malloc(nbytes);
  if (!p) {
    fprintf(stderr, "%s: out of memory\n", name);
    return 0;
  }
  n = read(fd, p, nbytes);
  if (n < 0) {
    perror(name);
    close(fd);
    return 0;
  }
  if (n != nbytes) {
    fprintf(stderr, "%s: read unexpected number of bytes\n", name);
    close(fd);
    return 0;
  }
  processor(p, nbytes, name, arg);
  free(p);
  close(fd);
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\filemap.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/


#include <stddef.h>

#ifdef XML_UNICODE
int filemap(const wchar_t *name,
	    void (*processor)(const void *, size_t, const wchar_t *, void *arg),
	    void *arg);
#else
int filemap(const char *name,
	    void (*processor)(const void *, size_t, const char *, void *arg),
	    void *arg);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\xmlfile.h ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#define XML_MAP_FILE 01
#define XML_EXTERNAL_ENTITIES 02

extern int XML_ProcessFile(XML_Parser parser,
			   const XML_Char *filename,
			   unsigned flags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\xmlfile.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <fcntl.h>
#include "xmlparse.h"
#include "xmlfile.h"
#include "xmltchar.h"
#include "filemap.h"

#ifdef _MSC_VER
#include <io.h>
#endif

#ifdef _POSIX_SOURCE
#include <unistd.h>
#endif

#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#else
#define O_BINARY 0
#endif
#endif

#ifdef _DEBUG
#define READ_SIZE 16
#else
#define READ_SIZE (1024*8)
#endif



typedef struct {
  XML_Parser parser;
  int *retPtr;
} PROCESS_ARGS;

static
void reportError(XML_Parser parser, const XML_Char *filename)
{
  int code = XML_GetErrorCode(parser);
  const XML_Char *message = XML_ErrorString(code);
  if (message)
    ftprintf(stdout, T("%s:%d:%ld: %s\n"),
	     filename,
	     XML_GetErrorLineNumber(parser),
	     XML_GetErrorColumnNumber(parser),
	     message);
  else
    ftprintf(stderr, T("%s: (unknown message %d)\n"), filename, code);
}

static
void processFile(const void *data,
		 size_t size,
		 const XML_Char *filename,
		 void *args)
{
  XML_Parser parser = ((PROCESS_ARGS *)args)->parser;
  int *retPtr = ((PROCESS_ARGS *)args)->retPtr;
  if (!XML_Parse(parser, data, size, 1)) {
    reportError(parser, filename);
    *retPtr = 0;
  }
  else
    *retPtr = 1;
}

static
int isAsciiLetter(XML_Char c)
{
  return (T('a') <= c && c <= T('z')) || (T('A') <= c && c <= T('Z'));
}

static
const XML_Char *resolveSystemId(const XML_Char *base, const XML_Char *systemId, XML_Char **toFree)
{
  XML_Char *s;
  *toFree = 0;
  if (!base
      || *systemId == T('/')
#ifdef WIN32
      || *systemId == T('\\')
      || (isAsciiLetter(systemId[0]) && systemId[1] == T(':'))
#endif
     )
    return systemId;
  *toFree = (XML_Char *)malloc((tcslen(base) + tcslen(systemId) + 2)*sizeof(XML_Char));
  if (!*toFree)
    return systemId;
  tcscpy(*toFree, base);
  s = *toFree;
  if (tcsrchr(s, T('/')))
    s = tcsrchr(s, T('/')) + 1;
#ifdef WIN32
  if (tcsrchr(s, T('\\')))
    s = tcsrchr(s, T('\\')) + 1;
#endif
  tcscpy(s, systemId);
  return *toFree;
}

static
int externalEntityRefFilemap(XML_Parser parser,
			     const XML_Char *context,
			     const XML_Char *base,
			     const XML_Char *systemId,
			     const XML_Char *publicId)
{
  int result;
  XML_Char *s;
  const XML_Char *filename;
  XML_Parser entParser = XML_ExternalEntityParserCreate(parser, context, 0);
  PROCESS_ARGS args;
  args.retPtr = &result;
  args.parser = entParser;
  filename = resolveSystemId(base, systemId, &s);
  XML_SetBase(entParser, filename);
  if (!filemap(filename, processFile, &args))
    result = 0;
  free(s);
  XML_ParserFree(entParser);
  return result;
}

static
int processStream(const XML_Char *filename, XML_Parser parser)
{
  int fd = topen(filename, O_BINARY|O_RDONLY);
  if (fd < 0) {
    tperror(filename);
    return 0;
  }
  for (;;) {
    int nread;
    char *buf = XML_GetBuffer(parser, READ_SIZE);
    if (!buf) {
      close(fd);
      ftprintf(stderr, T("%s: out of memory\n"), filename);
      return 0;
    }
    nread = read(fd, buf, READ_SIZE);
    if (nread < 0) {
      tperror(filename);
      close(fd);
      return 0;
    }
    if (!XML_ParseBuffer(parser, nread, nread == 0)) {
      reportError(parser, filename);
      close(fd);
      return 0;
    }
    if (nread == 0) {
      close(fd);
      break;;
    }
  }
  return 1;
}

static
int externalEntityRefStream(XML_Parser parser,
			    const XML_Char *context,
			    const XML_Char *base,
			    const XML_Char *systemId,
			    const XML_Char *publicId)
{
  XML_Char *s;
  const XML_Char *filename;
  int ret;
  XML_Parser entParser = XML_ExternalEntityParserCreate(parser, context, 0);
  filename = resolveSystemId(base, systemId, &s);
  XML_SetBase(entParser, filename);
  ret = processStream(filename, entParser);
  free(s);
  XML_ParserFree(entParser);
  return ret;
}

int XML_ProcessFile(XML_Parser parser,
		    const XML_Char *filename,
		    unsigned flags)
{
  int result;

  if (!XML_SetBase(parser, filename)) {
    ftprintf(stderr, T("%s: out of memory"), filename);
    exit(1);
  }

  if (flags & XML_EXTERNAL_ENTITIES)
      XML_SetExternalEntityRefHandler(parser,
	                              (flags & XML_MAP_FILE)
				      ? externalEntityRefFilemap
				      : externalEntityRefStream);
  if (flags & XML_MAP_FILE) {
    PROCESS_ARGS args;
    args.retPtr = &result;
    args.parser = parser;
    if (!filemap(filename, processFile, &args))
      result = 0;
  }
  else
    result = processStream(filename, parser);
  return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\unixfilemap.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

#ifndef MAP_FILE
#define MAP_FILE 0
#endif

#include "filemap.h"

int filemap(const char *name,
	    void (*processor)(const void *, size_t, const char *, void *arg),
	    void *arg)
{
  int fd;
  size_t nbytes;
  struct stat sb;
  void *p;

  fd = open(name, O_RDONLY);
  if (fd < 0) {
    perror(name);
    return 0;
  }
  if (fstat(fd, &sb) < 0) {
    perror(name);
    close(fd);
    return 0;
  }
  if (!S_ISREG(sb.st_mode)) {
    close(fd);
    fprintf(stderr, "%s: not a regular file\n", name);
    return 0;
  }
  
  nbytes = sb.st_size;
  p = (void *)mmap((caddr_t)0, (size_t)nbytes, PROT_READ,
		   MAP_FILE|MAP_PRIVATE, fd, (off_t)0);
  if (p == (void *)-1) {
    perror(name);
    close(fd);
    return 0;
  }
  processor(p, nbytes, name, arg);
  munmap((caddr_t)p, nbytes);
  close(fd);
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\win32filemap.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#define STRICT 1
#define WIN32_LEAN_AND_MEAN 1

#ifdef XML_UNICODE_WCHAR_T
#ifndef XML_UNICODE
#define XML_UNICODE
#endif
#endif

#ifdef XML_UNICODE
#define UNICODE
#define _UNICODE
#endif /* XML_UNICODE */
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "filemap.h"

static void win32perror(const TCHAR *);

int filemap(const TCHAR *name,
	    void (*processor)(const void *, size_t, const TCHAR *, void *arg),
	    void *arg)
{
  HANDLE f;
  HANDLE m;
  DWORD size;
  DWORD sizeHi;
  void *p;

  f = CreateFile(name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
			  FILE_FLAG_SEQUENTIAL_SCAN, NULL);
  if (f == INVALID_HANDLE_VALUE) {
    win32perror(name);
    return 0;
  }
  size = GetFileSize(f, &sizeHi);
  if (size == (DWORD)-1) {
    win32perror(name);
    return 0;
  }
  if (sizeHi) {
    _ftprintf(stderr, _T("%s: bigger than 2Gb\n"), name);
    return 0;
  }
  /* CreateFileMapping barfs on zero length files */
  if (size == 0) {
    static const char c = '\0';
    processor(&c, 0, name, arg);
    CloseHandle(f);
    return 1;
  }
  m = CreateFileMapping(f, NULL, PAGE_READONLY, 0, 0, NULL);
  if (m == NULL) {
    win32perror(name);
    CloseHandle(f);
    return 0;
  }
  p = MapViewOfFile(m, FILE_MAP_READ, 0, 0, 0);
  if (p == NULL) {
    win32perror(name);
    CloseHandle(m);
    CloseHandle(f);
    return 0;
  }
  processor(p, size, name, arg); 
  UnmapViewOfFile(p);
  CloseHandle(m);
  CloseHandle(f);
  return 1;
}

static
void win32perror(const TCHAR *s)
{
  LPVOID buf;
  if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		    NULL,
		    GetLastError(),
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		    (LPTSTR) &buf,
		    0,
		    NULL)) {
    _ftprintf(stderr, _T("%s: %s"), s, buf);
    fflush(stderr);
    LocalFree(buf);
  }
  else
    _ftprintf(stderr, _T("%s: unknown Windows error\n"), s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\xmltchar.h ===
#ifdef XML_UNICODE
#ifndef XML_UNICODE_WCHAR_T
#error xmlwf requires a 16-bit Unicode-compatible wchar_t 
#endif
#define T(x) L ## x
#define ftprintf fwprintf
#define tfopen _wfopen
#define fputts fputws
#define puttc putwc
#define tcscmp wcscmp
#define tcscpy wcscpy
#define tcscat wcscat
#define tcschr wcschr
#define tcsrchr wcsrchr
#define tcslen wcslen
#define tperror _wperror
#define topen _wopen
#define tmain wmain
#define tremove _wremove
#else /* not XML_UNICODE */
#define T(x) x
#define ftprintf fprintf
#define tfopen fopen
#define fputts fputs
#define puttc putc
#define tcscmp strcmp
#define tcscpy strcpy
#define tcscat strcat
#define tcschr strchr
#define tcsrchr strrchr
#define tcslen strlen
#define tperror perror
#define topen open
#define tmain main
#define tremove remove
#endif /* not XML_UNICODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\common.inc ===
#
# Common include file 'sources' files in the CTF project.
#

#
# Set private paths
#

INCLUDES        = \
    ..;\
    $(WINDOWS_INC_PATH); \
    $(SDK_INC_PATH); \
    $(BASE_INC_PATH);\
    $(QFE_INC_PATH);\
    $(INCLUDES)

#
# Skip these files when determining dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                       atlbase.h  \
                       atlcom.h   \
                       atlconv.h  \
                       atlctl.h   \
                       atlctl.cpp \
                       atliface.h \
                       atlimpl.cpp \
                       atlwin.h   \
                       atlwin.cpp \
                       ia64inst.h \
                       macapi.h   \
                       macname1.h \
                       macname2.h \
                       macocidl.h \
                       macpub.h   \
                       macwin32.h \
                       mainwin.h  \
                       mwversion.h \
                       ntamd64.h \
                       penwin.h \
                       pshpck16.h \
                       rpcerr.h   \
                       rpcmac.h   \
                       setupx.h   \
                       skbapi.h   \
                       statreg.h  \
                       statreg.cpp \
                       unixstuff.h \
                       version.h  \
                       winwlm.h   \
                       ..\inc16\shellapi.h \
                       assertwithstack.h



#
# Do this to assure that we run W2K, NT4, Win9x even with the latest header.
#
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
WIN32_WIN95_VERSION=$(LATEST_WIN32_WIN95_VERSIOIN)
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

#
# Override NT5 settings
#
SUBSYSTEM_VERSION=4.00

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN= 1

#
# Don't link to the runtime libs
#
USE_NOLIBS      = 1

#
# Don't link to NTDLL if this runs on both platforms
#
NO_NTDLL=1

UMTYPE          = windows

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32 -DUSE_MIRRORING -DNT -DCUAS_ENABLE

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif


# ------ Only XPSP1 Defines --------

C_DEFINES = $(C_DEFINES) -DCIC_XPSP1
RC_DEFINES = $(RC_DEFINES) -DCIC_XPSP1

# ------ End Only XPSP1 Defines --------


# ------ Debug Only Defines --------

!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w

# Check for missing PURE directives in interface decls (debug only)
C_DEFINES       = $(C_DEFINES) -DNO_NOVTABLE
!endif

# ------ End Debug Only Defines --------


#
# our target is both Win9x and NT. need map and sym.
#
USE_MAPSYM      = 1


CICERO_DIR       = $(PROJECT_ROOT)\AdvCore\ctf

INCLUDES         = $(INCLUDES);             \
                   $(CICERO_DIR)\inc;       \
                   $(CICERO_DIR)\inc\$(O);  \
                   $(CICERO_DIR)\inc_test

CICERO_LIBS      = $(CICERO_DIR)\uuid\$O\uimuuid.lib    \
                   $(CICERO_DIR)\lib\$O\immxlib.lib     \
                   $(CICERO_DIR)\prvlib\$O\prvlib.lib   \
                   $(CICERO_DIR)\cicmem\$O\cicmem.lib

CICERO_LIBS2     = $(CICERO_LIBS)                       \
                   $(CICERO_DIR)\uim\$O\msctf.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\common.inc ===
#
# include file for aimm project
#

!include $(PROJECT_ROOT)\AdvCore\ctf\common.inc

AIMM_DIR            = $(CICERO_DIR)\aimm1.2
INCLUDES            = $(AIMM_DIR)\inc;$(AIMM_DIR)\uuid\$(O);$(INCLUDES)

C_DEFINES=$(C_DEFINES) -DSLEEPMODE  -DOLD_AIMM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\site\lib\xml\parser\expat\xmlwf\xmlwf.c ===
/*
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is expat.

The Initial Developer of the Original Code is James Clark.
Portions created by James Clark are Copyright (C) 1998, 1999
James Clark. All Rights Reserved.

Contributor(s):

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License (the "GPL"), in which case the
provisions of the GPL are applicable instead of those above.  If you
wish to allow use of your version of this file only under the terms of
the GPL and not to allow others to use your version of this file under
the MPL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the
GPL. If you do not delete the provisions above, a recipient may use
your version of this file under either the MPL or the GPL.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#include "xmlparse.h"
#include "codepage.h"
#include "xmlfile.h"
#include "xmltchar.h"

#ifdef _MSC_VER
#include <crtdbg.h>
#endif

/* This ensures proper sorting. */

#define NSSEP T('\001')

static void characterData(void *userData, const XML_Char *s, int len)
{
  FILE *fp = userData;
  for (; len > 0; --len, ++s) {
    switch (*s) {
    case T('&'):
      fputts(T("&amp;"), fp);
      break;
    case T('<'):
      fputts(T("&lt;"), fp);
      break;
    case T('>'):
      fputts(T("&gt;"), fp);
      break;
#ifdef W3C14N
    case 13:
      fputts(T("&#xD;"), fp);
      break;
#else
    case T('"'):
      fputts(T("&quot;"), fp);
      break;
    case 9:
    case 10:
    case 13:
      ftprintf(fp, T("&#%d;"), *s);
      break;
#endif
    default:
      puttc(*s, fp);
      break;
    }
  }
}

static void attributeValue(FILE *fp, const XML_Char *s)
{
  puttc(T('='), fp);
  puttc(T('"'), fp);
  for (;;) {
    switch (*s) {
    case 0:
    case NSSEP:
      puttc(T('"'), fp);
      return;
    case T('&'):
      fputts(T("&amp;"), fp);
      break;
    case T('<'):
      fputts(T("&lt;"), fp);
      break;
    case T('"'):
      fputts(T("&quot;"), fp);
      break;
#ifdef W3C14N
    case 9:
      fputts(T("&#x9;"), fp);
      break;
    case 10:
      fputts(T("&#xA;"), fp);
      break;
    case 13:
      fputts(T("&#xD;"), fp);
      break;
#else
    case T('>'):
      fputts(T("&gt;"), fp);
      break;
    case 9:
    case 10:
    case 13:
      ftprintf(fp, T("&#%d;"), *s);
      break;
#endif
    default:
      puttc(*s, fp);
      break;
    }
    s++;
  }
}

/* Lexicographically comparing UTF-8 encoded attribute values,
is equivalent to lexicographically comparing based on the character number. */

static int attcmp(const void *att1, const void *att2)
{
  return tcscmp(*(const XML_Char **)att1, *(const XML_Char **)att2);
}

static void startElement(void *userData, const XML_Char *name, const XML_Char **atts)
{
  int nAtts;
  const XML_Char **p;
  FILE *fp = userData;
  puttc(T('<'), fp);
  fputts(name, fp);

  p = atts;
  while (*p)
    ++p;
  nAtts = (p - atts) >> 1;
  if (nAtts > 1)
    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, attcmp);
  while (*atts) {
    puttc(T(' '), fp);
    fputts(*atts++, fp);
    attributeValue(fp, *atts);
    atts++;
  }
  puttc(T('>'), fp);
}

static void endElement(void *userData, const XML_Char *name)
{
  FILE *fp = userData;
  puttc(T('<'), fp);
  puttc(T('/'), fp);
  fputts(name, fp);
  puttc(T('>'), fp);
}

static int nsattcmp(const void *p1, const void *p2)
{
  const XML_Char *att1 = *(const XML_Char **)p1;
  const XML_Char *att2 = *(const XML_Char **)p2;
  int sep1 = (tcsrchr(att1, NSSEP) != 0);
  int sep2 = (tcsrchr(att1, NSSEP) != 0);
  if (sep1 != sep2)
    return sep1 - sep2;
  return tcscmp(att1, att2);
}

static void startElementNS(void *userData, const XML_Char *name, const XML_Char **atts)
{
  int nAtts;
  int nsi;
  const XML_Char **p;
  FILE *fp = userData;
  const XML_Char *sep;
  puttc(T('<'), fp);

  sep = tcsrchr(name, NSSEP);
  if (sep) {
    fputts(T("n1:"), fp);
    fputts(sep + 1, fp);
    fputts(T(" xmlns:n1"), fp);
    attributeValue(fp, name);
    nsi = 2;
  }
  else {
    fputts(name, fp);
    nsi = 1;
  }

  p = atts;
  while (*p)
    ++p;
  nAtts = (p - atts) >> 1;
  if (nAtts > 1)
    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, nsattcmp);
  while (*atts) {
    name = *atts++;
    sep = tcsrchr(name, NSSEP);
    puttc(T(' '), fp);
    if (sep) {
      ftprintf(fp, T("n%d:"), nsi);
      fputts(sep + 1, fp);
    }
    else
      fputts(name, fp);
    attributeValue(fp, *atts);
    if (sep) {
      ftprintf(fp, T(" xmlns:n%d"), nsi++);
      attributeValue(fp, name);
    }
    atts++;
  }
  puttc(T('>'), fp);
}

static void endElementNS(void *userData, const XML_Char *name)
{
  FILE *fp = userData;
  const XML_Char *sep;
  puttc(T('<'), fp);
  puttc(T('/'), fp);
  sep = tcsrchr(name, NSSEP);
  if (sep) {
    fputts(T("n1:"), fp);
    fputts(sep + 1, fp);
  }
  else
    fputts(name, fp);
  puttc(T('>'), fp);
}

#ifndef W3C14N

static void processingInstruction(void *userData, const XML_Char *target, const XML_Char *data)
{
  FILE *fp = userData;
  puttc(T('<'), fp);
  puttc(T('?'), fp);
  fputts(target, fp);
  puttc(T(' '), fp);
  fputts(data, fp);
  puttc(T('?'), fp);
  puttc(T('>'), fp);
}

#endif /* not W3C14N */

static void defaultCharacterData(XML_Parser parser, const XML_Char *s, int len)
{
  XML_DefaultCurrent(parser);
}

static void defaultStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
{
  XML_DefaultCurrent(parser);
}

static void defaultEndElement(XML_Parser parser, const XML_Char *name)
{
  XML_DefaultCurrent(parser);
}

static void defaultProcessingInstruction(XML_Parser parser, const XML_Char *target, const XML_Char *data)
{
  XML_DefaultCurrent(parser);
}

static void nopCharacterData(XML_Parser parser, const XML_Char *s, int len)
{
}

static void nopStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
{
}

static void nopEndElement(XML_Parser parser, const XML_Char *name)
{
}

static void nopProcessingInstruction(XML_Parser parser, const XML_Char *target, const XML_Char *data)
{
}

static void markup(XML_Parser parser, const XML_Char *s, int len)
{
  FILE *fp = XML_GetUserData(parser);
  for (; len > 0; --len, ++s)
    puttc(*s, fp);
}

static
void metaLocation(XML_Parser parser)
{
  const XML_Char *uri = XML_GetBase(parser);
  if (uri)
    ftprintf(XML_GetUserData(parser), T(" uri=\"%s\""), uri);
  ftprintf(XML_GetUserData(parser),
           T(" byte=\"%ld\" nbytes=\"%d\" line=\"%d\" col=\"%d\""),
	   XML_GetCurrentByteIndex(parser),
	   XML_GetCurrentByteCount(parser),
	   XML_GetCurrentLineNumber(parser),
	   XML_GetCurrentColumnNumber(parser));
}

static
void metaStartDocument(XML_Parser parser)
{
  fputts(T("<document>\n"), XML_GetUserData(parser));
}

static
void metaEndDocument(XML_Parser parser)
{
  fputts(T("</document>\n"), XML_GetUserData(parser));
}

static
void metaStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
{
  FILE *fp = XML_GetUserData(parser);
  const XML_Char **specifiedAttsEnd
    = atts + 2*XML_GetSpecifiedAttributeCount(parser);
  ftprintf(fp, T("<starttag name=\"%s\""), name);
  metaLocation(parser);
  if (*atts) {
    fputts(T(">\n"), fp);
    do {
      ftprintf(fp, T("<attribute name=\"%s\" value=\""), atts[0]);
      characterData(fp, atts[1], tcslen(atts[1]));
      if (atts >= specifiedAttsEnd)
	fputts(T("\" defaulted=\"yes\"/>\n"), fp);
      else
	fputts(T("\"/>\n"), fp);
    } while (*(atts += 2));
    fputts(T("</starttag>\n"), fp);
  }
  else
    fputts(T("/>\n"), fp);
}

static
void metaEndElement(XML_Parser parser, const XML_Char *name)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<endtag name=\"%s\""), name);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaProcessingInstruction(XML_Parser parser, const XML_Char *target, const XML_Char *data)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<pi target=\"%s\" data=\""), target);
  characterData(fp, data, tcslen(data));
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaComment(XML_Parser parser, const XML_Char *data)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<comment data=\""), fp);
  characterData(fp, data, tcslen(data));
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaStartCdataSection(XML_Parser parser)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<startcdata"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaEndCdataSection(XML_Parser parser)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<endcdata"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaCharacterData(XML_Parser parser, const XML_Char *s, int len)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<chars str=\""), fp);
  characterData(fp, s, len);
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaStartDoctypeDecl(XML_Parser parser, const XML_Char *doctypeName)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<startdoctype name=\"%s\""), doctypeName);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaEndDoctypeDecl(XML_Parser parser)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<enddoctype"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaUnparsedEntityDecl(XML_Parser parser,
			    const XML_Char *entityName,
			    const XML_Char *base,
			    const XML_Char *systemId,
			    const XML_Char *publicId,
			    const XML_Char *notationName)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<entity name=\"%s\""), entityName);
  if (publicId)
    ftprintf(fp, T(" public=\"%s\""), publicId);
  fputts(T(" system=\""), fp);
  characterData(fp, systemId, tcslen(systemId));
  puttc(T('"'), fp);
  ftprintf(fp, T(" notation=\"%s\""), notationName);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaNotationDecl(XML_Parser parser,
		      const XML_Char *notationName,
		      const XML_Char *base,
		      const XML_Char *systemId,
		      const XML_Char *publicId)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<notation name=\"%s\""), notationName);
  if (publicId)
    ftprintf(fp, T(" public=\"%s\""), publicId);
  if (systemId) {
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
  }
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaStartNamespaceDecl(XML_Parser parser,
			    const XML_Char *prefix,
			    const XML_Char *uri)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<startns"), fp);
  if (prefix)
    ftprintf(fp, T(" prefix=\"%s\""), prefix);
  if (uri) {
    fputts(T(" ns=\""), fp);
    characterData(fp, uri, tcslen(uri));
    fputts(T("\"/>\n"), fp);
  }
  else
    fputts(T("/>\n"), fp);
}

static
void metaEndNamespaceDecl(XML_Parser parser, const XML_Char *prefix)
{
  FILE *fp = XML_GetUserData(parser);
  if (!prefix)
    fputts(T("<endns/>\n"), fp);
  else
    ftprintf(fp, T("<endns prefix=\"%s\"/>\n"), prefix);
}

static
int unknownEncodingConvert(void *data, const char *p)
{
  return codepageConvert(*(int *)data, p);
}

static
int unknownEncoding(void *userData,
		    const XML_Char *name,
		    XML_Encoding *info)
{
  int cp;
  static const XML_Char prefixL[] = T("windows-");
  static const XML_Char prefixU[] = T("WINDOWS-");
  int i;

  for (i = 0; prefixU[i]; i++)
    if (name[i] != prefixU[i] && name[i] != prefixL[i])
      return 0;
  
  cp = 0;
  for (; name[i]; i++) {
    static const XML_Char digits[] = T("0123456789");
    const XML_Char *s = tcschr(digits, name[i]);
    if (!s)
      return 0;
    cp *= 10;
    cp += s - digits;
    if (cp >= 0x10000)
      return 0;
  }
  if (!codepageMap(cp, info->map))
    return 0;
  info->convert = unknownEncodingConvert;
  /* We could just cast the code page integer to a void *,
  and avoid the use of release. */
  info->release = free;
  info->data = malloc(sizeof(int));
  if (!info->data)
    return 0;
  *(int *)info->data = cp;
  return 1;
}

static
int notStandalone(void *userData)
{
  return 0;
}

static
void usage(const XML_Char *prog)
{
  ftprintf(stderr, T("usage: %s [-n] [-p] [-r] [-s] [-w] [-x] [-d output-dir] [-e encoding] file ...\n"), prog);
  exit(1);
}

int tmain(int argc, XML_Char **argv)
{
  int i, j;
  const XML_Char *outputDir = 0;
  const XML_Char *encoding = 0;
  unsigned processFlags = XML_MAP_FILE;
  int windowsCodePages = 0;
  int outputType = 0;
  int useNamespaces = 0;
  int requireStandalone = 0;
  int paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;

#ifdef _MSC_VER
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
#endif

  i = 1;
  j = 0;
  while (i < argc) {
    if (j == 0) {
      if (argv[i][0] != T('-'))
	break;
      if (argv[i][1] == T('-') && argv[i][2] == T('\0')) {
	i++;
	break;
      }
      j++;
    }
    switch (argv[i][j]) {
    case T('r'):
      processFlags &= ~XML_MAP_FILE;
      j++;
      break;
    case T('s'):
      requireStandalone = 1;
      j++;
      break;
    case T('n'):
      useNamespaces = 1;
      j++;
      break;
    case T('p'):
      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;
      /* fall through */
    case T('x'):
      processFlags |= XML_EXTERNAL_ENTITIES;
      j++;
      break;
    case T('w'):
      windowsCodePages = 1;
      j++;
      break;
    case T('m'):
      outputType = 'm';
      j++;
      break;
    case T('c'):
      outputType = 'c';
      useNamespaces = 0;
      j++;
      break;
    case T('t'):
      outputType = 't';
      j++;
      break;
    case T('d'):
      if (argv[i][j + 1] == T('\0')) {
	if (++i == argc)
	  usage(argv[0]);
	outputDir = argv[i];
      }
      else
	outputDir = argv[i] + j + 1;
      i++;
      j = 0;
      break;
    case T('e'):
      if (argv[i][j + 1] == T('\0')) {
	if (++i == argc)
	  usage(argv[0]);
	encoding = argv[i];
      }
      else
	encoding = argv[i] + j + 1;
      i++;
      j = 0;
      break;
    case T('\0'):
      if (j > 1) {
	i++;
	j = 0;
	break;
      }
      /* fall through */
    default:
      usage(argv[0]);
    }
  }
  if (i == argc)
    usage(argv[0]);
  for (; i < argc; i++) {
    FILE *fp = 0;
    XML_Char *outName = 0;
    int result;
    XML_Parser parser;
    if (useNamespaces)
      parser = XML_ParserCreateNS(encoding, NSSEP);
    else
      parser = XML_ParserCreate(encoding);
    if (requireStandalone)
      XML_SetNotStandaloneHandler(parser, notStandalone);
    XML_SetParamEntityParsing(parser, paramEntityParsing);
    if (outputType == 't') {
      /* This is for doing timings; this gives a more realistic estimate of
	 the parsing time. */
      outputDir = 0;
      XML_SetElementHandler(parser, nopStartElement, nopEndElement);
      XML_SetCharacterDataHandler(parser, nopCharacterData);
      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);
    }
    else if (outputDir) {
      const XML_Char *file = argv[i];
      if (tcsrchr(file, T('/')))
	file = tcsrchr(file, T('/')) + 1;
#ifdef WIN32
      if (tcsrchr(file, T('\\')))
	file = tcsrchr(file, T('\\')) + 1;
#endif
      outName = malloc((tcslen(outputDir) + tcslen(file) + 2) * sizeof(XML_Char));
      tcscpy(outName, outputDir);
      tcscat(outName, T("/"));
      tcscat(outName, file);
      fp = tfopen(outName, T("wb"));
      if (!fp) {
	tperror(outName);
	exit(1);
      }
      setvbuf(fp, NULL, _IOFBF, 16384);
#ifdef XML_UNICODE
      puttc(0xFEFF, fp);
#endif
      XML_SetUserData(parser, fp);
      switch (outputType) {
      case 'm':
	XML_UseParserAsHandlerArg(parser);
	XML_SetElementHandler(parser, metaStartElement, metaEndElement);
	XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);
	XML_SetCommentHandler(parser, metaComment);
	XML_SetCdataSectionHandler(parser, metaStartCdataSection, metaEndCdataSection);
	XML_SetCharacterDataHandler(parser, metaCharacterData);
	XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl, metaEndDoctypeDecl);
	XML_SetUnparsedEntityDeclHandler(parser, metaUnparsedEntityDecl);
	XML_SetNotationDeclHandler(parser, metaNotationDecl);
	XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl, metaEndNamespaceDecl);
	metaStartDocument(parser);
	break;
      case 'c':
	XML_UseParserAsHandlerArg(parser);
	XML_SetDefaultHandler(parser, markup);
	XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);
	XML_SetCharacterDataHandler(parser, defaultCharacterData);
	XML_SetProcessingInstructionHandler(parser, defaultProcessingInstruction);
	break;
      default:
	if (useNamespaces)
	  XML_SetElementHandler(parser, startElementNS, endElementNS);
	else
	  XML_SetElementHandler(parser, startElement, endElement);
	XML_SetCharacterDataHandler(parser, characterData);
#ifndef W3C14N
	XML_SetProcessingInstructionHandler(parser, processingInstruction);
#endif /* not W3C14N */
	break;
      }
    }
    if (windowsCodePages)
      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);
    result = XML_ProcessFile(parser, argv[i], processFlags);
    if (outputDir) {
      if (outputType == 'm')
	metaEndDocument(parser);
      fclose(fp);
      if (!result)
	tremove(outName);
      free(outName);
    }
    XML_ParserFree(parser);
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\api.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    api.cpp

Abstract:

    This file implements the CActiveIMMAppEx Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "list.h"
#include "globals.h"


//+---------------------------------------------------------------------------
//
// CGuidMapList
//    Allocated by Global data object !!
//
//----------------------------------------------------------------------------

extern CGuidMapList      *g_pGuidMapList;


//+---------------------------------------------------------------------------
//
// MsimtfIsWindowFiltered
//
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI MsimtfIsWindowFiltered(HWND hwnd)
{
    if (!g_pGuidMapList)
        return FALSE;

    return g_pGuidMapList->_IsWindowFiltered(hwnd);
}

//+---------------------------------------------------------------------------
//
// MsimtfIsGuidMapEnable
//
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI MsimtfIsGuidMapEnable(HIMC himc, BOOL *pbGuidmap)
{
    if (!g_pGuidMapList)
        return FALSE;

    return g_pGuidMapList->_IsGuidMapEnable(himc, pbGuidmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\atom.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    atom.h

Abstract:

    This file defines the CAtomObject Class.

Author:

Revision History:

Notes:

--*/


#ifndef ATOM_H
#define ATOM_H


/////////////////////////////////////////////////////////////////////////////
// CAtomObject

class CAtomObject
{
public:
    CAtomObject() : m_AtomRefCount(0), m_AtomName(NULL), m_Atom(0) { }
    virtual ~CAtomObject()
    {
        if (m_AtomName)
            delete [] m_AtomName;
        if (m_Atom)
            DeleteAtom(m_Atom);
    }

    HRESULT _InitAtom(LPCTSTR lpString);
    HRESULT _Activate();
    HRESULT _Deactivate();

private:
    int        m_AtomRefCount;
    LPTSTR     m_AtomName;
    ATOM       m_Atom;
};

#endif // ATOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\atom.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    atom.cpp

Abstract:

    This file implements the CAtomObject class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "atom.h"
#include "globals.h"

//+---------------------------------------------------------------------------
//
// CAtomObject
//
//----------------------------------------------------------------------------

HRESULT
CAtomObject::_InitAtom(
    LPCTSTR lpString
    )
{
    HRESULT hr;
    size_t  cch;

    if (m_AtomName)
        return S_OK;

    hr = StringCchLength(lpString, 255, &cch);
    if (hr != S_OK)
        return hr;

    m_AtomName = new TCHAR[cch+1];
    if (m_AtomName == NULL)
        return E_OUTOFMEMORY;

    hr = StringCchCopy(m_AtomName, cch+1, lpString);
    return hr;
}

HRESULT
CAtomObject::_Activate()
{
    EnterCriticalSection(g_cs);

    int ref = ++m_AtomRefCount;

    if (ref == 1) {
        //
        // Add AIMM1.2 ATOM
        //
        m_Atom = AddAtom(m_AtomName);
    }

    LeaveCriticalSection(g_cs);

    return S_OK;
}

HRESULT
CAtomObject::_Deactivate()
{
    EnterCriticalSection(g_cs);

    int ref = --m_AtomRefCount;

    if (ref == 0) {
        //
        // Delete AIMM1.2 ATOM
        //
        DeleteAtom(m_Atom);
        m_Atom = 0;
    }

    LeaveCriticalSection(g_cs);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\delay.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    delay.h

Abstract:

    This file defines the IMM32 Namespace.

Author:

Revision History:

Notes:

--*/

#ifndef _DELAY_H_
#define _DELAY_H_

namespace imm32 {
    BOOL FreeLibrary(VOID);

    /*
     * IMM32 Input Context (hIMC) API Interface.
     */
    HIMC WINAPI ImmCreateContext(void);
    BOOL WINAPI ImmDestroyContext(IN HIMC);
    HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
    BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
    HIMC WINAPI ImmGetContext(IN HWND);
    BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
    DWORD WINAPI ImmGetIMCLockCount(IN HIMC);
    LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
    BOOL  WINAPI ImmUnlockIMC(IN HIMC);

    /*
     * IMM32 Input Context Components (hIMCC) API Interface.
     */
    HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
    HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
    DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);
    HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
    DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
    LPVOID WINAPI ImmLockIMCC(IN HIMCC);
    BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);

    /*
     * IMM32 Composition String API Interface
     */
    LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

    /*
     * IMM32 Composition Font API Interface
     */
    BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
    BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
    BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
    BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);

    /*
     * IMM32 Open Status API Interface
     */
    BOOL WINAPI ImmGetOpenStatus(IN HIMC);
    BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

    /*
     * IMM32 Conversion Status API Interface
     */
    BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
    BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);

    /*
     * IMM32 Status Window Pos API Interface
     */
    BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
    BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);


    /*
     * IMM32 Composition Window API Interface
     */
    BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
    BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);

    /*
     * IMM32 Candidate API Interface
     */
    BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
    BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);
    DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
    DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);

    /*
     * IMM32 Generate Message API Interface
     */
    BOOL WINAPI ImmGenerateMessage(IN HIMC);

    /*
     * IMM32 Notify IME API Interface
     */
    BOOL WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

    /*
     * IMM32 Guide Line IME API Interface
     */
    DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);

    /*
     * IMM32 Menu items API Interface
     */
    DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
    DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);

    /*
     * IMM32 Default IME Window API Interface
     */
    HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);
    UINT WINAPI ImmGetVirtualKey(IN HWND);

    /*
     * IMM32 UI message API Interface
     */
    BOOL WINAPI ImmIsUIMessageA(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);
    BOOL WINAPI ImmIsUIMessageW(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);

    /*
     * IMM32 Simulate hotkey API Interface
     */
    BOOL WINAPI ImmSimulateHotKey(HWND hWnd, DWORD dwHotKeyID);
    BOOL WINAPI ImmGetHotKey(DWORD dwHotKeyId, LPUINT lpuModifiers, LPUINT lpuVKey, LPHKL lphKL);
    BOOL WINAPI ImmSetHotKey(DWORD dwHotKeyId, UINT uModifiers, UINT uVKey, HKL hKL);

    /*
     * IMM32 Property API Interface
     */
    DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

    /*
     * IMM32 Description API Interface
     */
    UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameA(HKL hKL, LPSTR lpszFileName, UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameW(HKL hKL, LPWSTR lpszFileName, UINT uBufLen);

    /*
     * IMM32 Conversion List API Interface
     */
    DWORD WINAPI ImmGetConversionListA(HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);
    DWORD WINAPI ImmGetConversionListW(HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);

    /*
     * IMM32 IsIME API Interface
     */
    BOOL WINAPI ImmIsIME(HKL hKL);

    /*
     * IMM32 Escape API Interface
     */
    LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
    LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);

    /*
     * IMM32 Configure IME Interface
     */
    BOOL WINAPI ImmConfigureIMEA(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
    BOOL WINAPI ImmConfigureIMEW(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);

    /*
     * IMM32 Register Word IME Interface
     */
    BOOL WINAPI ImmRegisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister);
    BOOL WINAPI ImmRegisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister);
    BOOL WINAPI ImmUnregisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister);
    BOOL WINAPI ImmUnregisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister);
    UINT WINAPI ImmGetRegisterWordStyleA(HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
    UINT WINAPI ImmGetRegisterWordStyleW(HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);

    /*
     * IMM32 soft kbd API
     */
    HWND WINAPI ImmCreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y);
    BOOL WINAPI ImmDestroySoftKeyboard(HWND hSoftKbdWnd);
    BOOL WINAPI ImmShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    /*
     * IMM32 Enumurate Input Context API
     */
    BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

    /*
     * IMM32 win98/nt5 apis
     */
    BOOL WINAPI ImmDisableIME(DWORD dwId);

    LRESULT WINAPI ImmRequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam);
    LRESULT WINAPI ImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam);

    HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
    HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
}

namespace imm32prev {
    BOOL FreeLibrary(VOID);

    /*
     * IMM32 Private functions.
     */
    HRESULT WINAPI CtfImmGetGuidAtom(IN HIMC hIMC, IN BYTE bAttr, OUT DWORD* pGuidAtom);
    BOOL    WINAPI CtfImmIsGuidMapEnable(IN HIMC hIMC);
    BOOL    WINAPI CtfImmIsCiceroEnabled(VOID);
    BOOL    WINAPI CtfImmIsCiceroStartedInThread(VOID);
    HRESULT WINAPI CtfImmSetCiceroStartInThread(IN BOOL fSet);
    UINT    WINAPI GetKeyboardLayoutCP(IN HKL hKL);
    DWORD   WINAPI ImmGetAppCompatFlags(IN HIMC hIMC);
    VOID    WINAPI CtfImmSetAppCompatFlags(IN DWORD dwFlag);
    HRESULT WINAPI CtfAImmActivate(HMODULE* phMod);
    HRESULT WINAPI CtfAImmDeactivate(HMODULE hMod);
    BOOL    WINAPI CtfAImmIsIME(HKL hkl);
}

//
// ole32
//
HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv);
#define CoCreateInstance Internal_CoCreateInstance

LPVOID  STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb);
#define CoTaskMemAlloc   Internal_CoTaskMemAlloc

LPVOID  STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb);
#define CoTaskMemRealloc Internal_CoTaskMemRealloc

void    STDAPICALLTYPE Internal_CoTaskMemFree(void* pv);
#define CoTaskMemFree    Internal_CoTaskMemFree

#endif // _DELAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSIMTF"
#define SZ_MODULE       "MSIMTF"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmex.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmex.cpp

Abstract:

    This file implements the CActiveIMMAppEx Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "msctfp.h"
#include "dimmex.h"
#include "list.h"
#include "atom.h"
#include "globals.h"
#include "tls.h"
#include "apcompat.h"

//+---------------------------------------------------------------------------
//
// CGuidMapList
//    Allocated by Global data object !!
//
//----------------------------------------------------------------------------

CGuidMapList      *g_pGuidMapList = NULL;

BOOL InitFilterList()
{
    BOOL bRet;
    EnterCriticalSection(g_cs);

    if (!g_pGuidMapList)
        g_pGuidMapList = new CGuidMapList;

    bRet = g_pGuidMapList ? TRUE : FALSE;
    LeaveCriticalSection(g_cs);

    return bRet;
}

void UninitFilterList()
{
    //
    // this function is called in DllMain(). Don't need to be protected by
    // g_cs.
    //
    // EnterCriticalSection(g_cs);

    if (g_pGuidMapList)
        delete g_pGuidMapList;

    g_pGuidMapList = NULL;

    // LeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// CAtomObject
//    Allocated by Global data object !!
//
//----------------------------------------------------------------------------

CAtomObject       *g_pAimmAtomObject = NULL;

BOOL InitAimmAtom()
{
    BOOL bRet;
    EnterCriticalSection(g_cs);

    if (! FindAtom(TF_ENABLE_PROCESS_ATOM)) {
        //
        // This process is not WinWord XP nor Cicero aware application
        //
        bRet = FALSE;
    }
    else {
        if (!g_pAimmAtomObject) {
            g_pAimmAtomObject = new CAtomObject();
            if (g_pAimmAtomObject) {
                if (g_pAimmAtomObject->_InitAtom(AIMM12_PROCESS_ATOM) != S_OK) {
                    delete g_pAimmAtomObject;
                    g_pAimmAtomObject = NULL;
                }
            }
        }
        bRet = g_pAimmAtomObject ? TRUE : FALSE;
    }

    LeaveCriticalSection(g_cs);

    return bRet;
}

void UninitAimmAtom()
{
    //
    // this function is called in DllMain(). Don't need to be protected by
    // g_cs.
    //
    // EnterCriticalSection(g_cs);

    if (g_pAimmAtomObject)
        delete g_pAimmAtomObject;

    g_pAimmAtomObject = NULL;

    // LeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------


STDAPI CComActiveIMMApp::Activate(BOOL fRestoreLayout)
{
    HRESULT hr = S_OK;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (! InitAimmAtom()) {
        if (! FindAtom(AIMM12_PROCESS_ATOM))
            AddAtom(AIMM12_PROCESS_ATOM);
    }
    else {
        g_pAimmAtomObject->_Activate();      // Activate AIMM12 atom
    }

    int cnt = ptls->IncrementAIMMRefCnt();

    #ifndef KACF_DISABLECICERO
    #define KACF_DISABLECICERO 0x00000100    // If set. Cicero support for the current process
                                             // is disabled.
    #endif

    if (! IsOldAImm() && ! IsCUAS_ON() && ! APPCOMPATFLAG(KACF_DISABLECICERO) && cnt == 1)
    {
        hr = imm32prev::CtfAImmActivate(&m_hModCtfIme);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::Deactivate()
{
    HRESULT hr = S_OK;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (InitAimmAtom()) {
        g_pAimmAtomObject->_Deactivate();    // Deactivate AIMM12 atom
    }

    int cnt = ptls->DecrementAIMMRefCnt();

    if (! IsOldAImm() && ! IsCUAS_ON() && ! APPCOMPATFLAG(KACF_DISABLECICERO) && cnt == 0)
    {
        hr = imm32prev::CtfAImmDeactivate(m_hModCtfIme);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// FilterClientWindows
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::FilterClientWindows(ATOM *aaWindowClasses, UINT uSize)
{
    return FilterClientWindowsGUIDMap(aaWindowClasses, uSize, NULL);
}

STDAPI CComActiveIMMApp::FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap)
{
    if (!InitFilterList())
        return E_OUTOFMEMORY;

    return g_pGuidMapList->_Update(aaWindowClasses, uSize, aaGuidMap);
}

//+---------------------------------------------------------------------------
//
// FilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap)
{
    if (!InitFilterList())
        return E_OUTOFMEMORY;

    return g_pGuidMapList->_Update(hWnd, fGuidMap);

}

//+---------------------------------------------------------------------------
//
// UnfilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::UnfilterClientWindowsEx(HWND hWnd)
{
    if (!InitFilterList())
        return E_OUTOFMEMORY;

    return g_pGuidMapList->_Remove(hWnd);
}

//+---------------------------------------------------------------------------
//
// GetGuidAtom
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom)
{
    return imm32prev::CtfImmGetGuidAtom(hImc, bAttr, pGuidAtom);
}

//+---------------------------------------------------------------------------
//
// GetCodePageA
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetCodePageA(HKL hKL, UINT *puCodePage)
{
    if (puCodePage == NULL)
        return E_INVALIDARG;

    TraceMsg(TF_FUNC, "CComActiveIMMApp::GetCodePageA");

    *puCodePage = imm32prev::GetKeyboardLayoutCP(hKL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetLangId
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetLangId(HKL hKL, LANGID *plid)
{
    if (plid == NULL)
        return E_INVALIDARG;

    TraceMsg(TF_FUNC, "CComActiveIMMApp::GetLangId");

    *plid = LOWORD(HandleToUlong(hKL));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::QueryService( 
    REFGUID guidService,
    REFIID riid,
    void **ppv
    )
{
    ITfThreadMgr *ptim = NULL;
    ITfDocumentMgr *pdim = NULL;
    ITfContext *pic = NULL;
    HRESULT hr = E_NOINTERFACE;

    if (ppv == NULL) {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF))
        return E_INVALIDARG;

    if (FAILED(TF_CreateThreadMgr(&ptim)))
        return E_FAIL;

    if (!ptim)
        return E_FAIL;

    if (IsEqualIID(riid, IID_ITfThreadMgr)) {
        *ppv = SAFECAST(ptim, ITfThreadMgr*);
        ptim->AddRef();
        hr = S_OK;
    }
    else {

        if (FAILED(ptim->GetFocus(&pdim)))
            pdim = NULL;

        if (IsEqualIID(riid, IID_ITfDocumentMgr)) {
            if (pdim) {
                *ppv = SAFECAST(pdim, ITfDocumentMgr*);
                pdim->AddRef();
                hr = S_OK;
            }
        }
        else if (IsEqualIID(riid, IID_ITfContext)) {
            if (pdim) {
                if (SUCCEEDED(pdim->GetTop(&pic)) && pic) {
                    *ppv = SAFECAST(pic, ITfContext*);
                    pic->AddRef();
                    hr = S_OK;
                }
            }
        }
    }

    if (ptim)
        ptim->Release();

    if (pdim)
        pdim->Release();

    if (pic)
        pic->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
// SetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::SetThreadCompartmentValue(
    REFGUID rguid,
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;

    ITfThreadMgr *ptim = NULL;
    HRESULT hr = E_FAIL;

    if (FAILED(TF_CreateThreadMgr(&ptim)))
        return hr;

    if (ptim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)ptim, rguid, &pComp)))
        {
            //
            // Hack to get App Client Id.
            //
            TfClientId tid;
            ptim->Activate(&tid);
            ptim->Deactivate();

            hr = pComp->SetValue(tid, pvar);
            pComp->Release();
        }
        ptim->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetThreadCompartmentValue(
    REFGUID rguid,
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    ITfThreadMgr *ptim = NULL;

    if (FAILED(TF_CreateThreadMgr(&ptim)))
        return hr;

    QuickVariantInit(pvar);

    if (ptim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)ptim, rguid, &pComp)))
        {
            hr = pComp->GetValue(pvar);
            pComp->Release();
        }
        ptim->Release();
    }

    return hr;

}

//+---------------------------------------------------------------------------
//
// OnDefWindowProc
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::OnDefWindowProc(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    *plResult = 0;

    BOOL fUnicode = IsWindowUnicode(hWnd);
    HRESULT hr = S_FALSE;   // returns S_FALSE, DefWindowProc should be called.

    //
    // RE4.0 won't call DefWindowProc even returns S_FALSE.
    // This code recover some IME message as same old AIMM code (dimm\aime_wnd.cpp)
    //
    switch (Msg)
    {
        case WM_IME_KEYDOWN:
        case WM_IME_KEYUP:
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_IME_NOTIFY:
        case WM_IME_SETCONTEXT:
            if (fUnicode)
            {
                *plResult = ::DefWindowProcW(hWnd, Msg, wParam, lParam);
            }
            else
            {
                *plResult = ::DefWindowProcA(hWnd, Msg, wParam, lParam);
            }
            hr = S_OK;
            break;

        case WM_IME_REQUEST:
            switch (wParam)
            {
                case IMR_QUERYCHARPOSITION:
                    if (fUnicode)
                    {
                        *plResult = ::DefWindowProcW(hWnd, Msg, wParam, lParam);
                    }
                    else
                    {
                        *plResult = ::DefWindowProcA(hWnd, Msg, wParam, lParam);
                    }
                    hr = S_OK;
                    break;
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmex.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmex.h

Abstract:

    This file defines the CActiveIMMAppEx Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _DIMMEX_H_
#define _DIMMEX_H_

#include "resource.h"
#include "globals.h"
#include "list.h"
#include "atom.h"
#include "delay.h"
#include "oldaimm.h"

extern CGuidMapList      *g_pGuidMapList;

BOOL InitFilterList();
void UninitFilterList();

extern CAtomObject  *g_pAimmAtom;

BOOL InitAimmAtom();
void UninitAimmAtom();


    //
    // 4955DD32-B159-11d0-8FCF-00AA006BCC59
    //
    static const IID IID_IActiveIMMAppTrident4x = {
       0x4955DD32,
       0xB159,
       0x11d0,
       { 0x8F, 0xCF, 0x00, 0xaa, 0x00, 0x6b, 0xcc, 0x59 }
    };

    // 
    // c839a84c-8036-11d3-9270-0060b067b86e
    // 
    static const IID IID_IActiveIMMAppPostNT4 = { 
        0xc839a84c,
        0x8036,
        0x11d3,
        {0x92, 0x70, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e}
    };

//+---------------------------------------------------------------------------
//
// CComActiveIMMApp
//
//----------------------------------------------------------------------------

class CComActiveIMMApp : public IActiveIMMAppEx,
                         public IActiveIMMMessagePumpOwner,
                         public IAImmThreadCompartment,
                         public IServiceProvider
{
public:
    CComActiveIMMApp()
    {
        _fEnableGuidMap = FALSE;
        m_hModCtfIme = NULL;
    }

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        //
        // Look up disabling Text Services status from the registry.
        // If it is disabled, return fail not to support Text Services.
        //
        if (IsDisabledTextServices())
            return FALSE;

        if (RunningInExcludedModule())
            return FALSE;

        if (!IsInteractiveUserLogon())
            return FALSE;

        if (NoTipsInstalled(NULL))
            return FALSE;

        return TRUE;
    }

    //
    // IActiveIMMMessagePumpOwner
    //
    STDMETHODIMP Start() { return E_NOTIMPL; }
    STDMETHODIMP End() { return E_NOTIMPL; }
    STDMETHODIMP OnTranslateMessage(const MSG *pMsg) { return E_NOTIMPL; }
    STDMETHODIMP Pause(DWORD *pdwCookie) { return E_NOTIMPL; }
    STDMETHODIMP Resume(DWORD dwCookie) { return E_NOTIMPL; }

    //
    // IActiveIMMApp/IActiveIMM methods
    //

    /*
     * AIMM Input Context (hIMC) Methods.
     */
    STDMETHODIMP CreateContext(HIMC *phIMC)
    {
        HIMC hIMC = imm32::ImmCreateContext();
        if (hIMC) {
            *phIMC = hIMC;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP DestroyContext(HIMC hIMC)
    {
        return (imm32::ImmDestroyContext(hIMC)) ? S_OK
                                                : E_FAIL;
    }
    STDMETHODIMP AssociateContext(HWND hWnd, HIMC hIMC, HIMC *phPrev)
    {
        *phPrev = imm32::ImmAssociateContext(hWnd, hIMC);
        return S_OK;
    }
    STDMETHODIMP AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags)
    {
        return (imm32::ImmAssociateContextEx(hWnd, hIMC, dwFlags)) ? S_OK
                                                                   : E_FAIL;
    }
    STDMETHODIMP GetContext(HWND hWnd, HIMC *phIMC)
    {
        *phIMC = imm32::ImmGetContext(hWnd);
        return S_OK;
    }
    STDMETHODIMP ReleaseContext(HWND hWnd, HIMC hIMC)
    {
        return (imm32::ImmReleaseContext(hWnd, hIMC)) ? S_OK
                                                      : E_FAIL;
    }
    STDMETHODIMP GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount)
    {
        *pdwLockCount = imm32::ImmGetIMCLockCount(hIMC);
        return S_OK;
    }
    STDMETHODIMP LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC)
    {
        return (*ppIMC = imm32::ImmLockIMC(hIMC)) ? S_OK
                                                  : E_FAIL;
    }
    STDMETHODIMP UnlockIMC(HIMC hIMC)
    {
        imm32::ImmUnlockIMC(hIMC);
        return S_OK;
    }

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    STDMETHODIMP CreateIMCC(DWORD dwSize, HIMCC *phIMCC)
    {
        HIMCC hIMCC = imm32::ImmCreateIMCC(dwSize);
        if (hIMCC) {
            *phIMCC = hIMCC;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP DestroyIMCC(HIMCC hIMCC)
    {
        /*
         * ImmDestroyIMCC maped to LocalFree.
         *   if the function fails, the return value is equal to a handle to the local memory object.
         *   if the function succeeds, the return value is NULL.
         */
        return (imm32::ImmDestroyIMCC(hIMCC)) ? E_FAIL
                                              : S_OK;
    }
    STDMETHODIMP GetIMCCSize(HIMCC hIMCC, DWORD *pdwSize)
    {
        *pdwSize = imm32::ImmGetIMCCSize(hIMCC);
        return S_OK;
    }
    STDMETHODIMP ReSizeIMCC(HIMCC hIMCC, DWORD dwSize, HIMCC *phIMCC)
    {
        HIMCC hNewIMCC = imm32::ImmReSizeIMCC(hIMCC, dwSize);
        if (hNewIMCC) {
            *phIMCC = hNewIMCC;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount)
    {
        *pdwLockCount = imm32::ImmGetIMCCLockCount(hIMCC);
        return S_OK;
    }
    STDMETHODIMP LockIMCC(HIMCC hIMCC, void **ppv)
    {
        return (*ppv = imm32::ImmLockIMCC(hIMCC)) ? S_OK
                                                  : E_FAIL;
    }
    STDMETHODIMP UnlockIMCC(HIMCC hIMCC)
    {
        if (imm32::ImmUnlockIMCC(hIMCC)) {
            // memory object still locked.
            return S_OK;
        }
        else {
            DWORD err = GetLastError();
            if (err == NO_ERROR)
                // memory object is unlocked.
                return S_OK;
            else if (err == ERROR_NOT_LOCKED)
                // memory object is already unlocked.
                return S_OK;
        }
        return E_FAIL;
    }

    /*
     * AIMM Open Status API Methods
     */
    STDMETHODIMP GetOpenStatus(HIMC hIMC)
    {
        return imm32::ImmGetOpenStatus(hIMC) ? S_OK : S_FALSE;
    }
    STDMETHODIMP SetOpenStatus(HIMC hIMC, BOOL fOpen)
    {
        return (imm32::ImmSetOpenStatus(hIMC, fOpen)) ? S_OK
                                                      : E_FAIL;
    }

    /*
     * AIMM Conversion Status API Methods
     */
    STDMETHODIMP GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion, DWORD *lpfdwSentence)
    {
        return (imm32::ImmGetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence)) ? S_OK
                                                                                     : E_FAIL;
    }
    STDMETHODIMP SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence)
    {
        return (imm32::ImmSetConversionStatus(hIMC, fdwConversion, fdwSentence)) ? S_OK
                                                                                 : E_FAIL;
    }

    /*
     * AIMM Status Window Pos API Methods
     */
    STDMETHODIMP GetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
    {
        return (imm32::ImmGetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                             : E_FAIL;
    }
    STDMETHODIMP SetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
    {
        return (imm32::ImmSetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                             : E_FAIL;
    }

    /*
     * AIMM Composition String API Methods
     */
    STDMETHODIMP GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
    {
        LONG lRet;
        if ((dwIndex & GCS_COMPATTR) && IsGuidMapEnable(hIMC))
        {
            dwIndex &= ~GCS_COMPATTR;
            dwIndex |=  GCS_COMPGUIDATTR;
        }
        lRet = imm32::ImmGetCompositionStringA(hIMC, dwIndex, lpBuf, dwBufLen);
        if (lRet < 0)
            return E_FAIL;
        else {
            *plCopied = lRet;
            return S_OK;
        }
    }
    STDMETHODIMP GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
    {
        LONG lRet;
        if ((dwIndex & GCS_COMPATTR) && IsGuidMapEnable(hIMC))
        {
            dwIndex &= ~GCS_COMPATTR;
            dwIndex |=  GCS_COMPGUIDATTR;
        }
        lRet = imm32::ImmGetCompositionStringW(hIMC, dwIndex, lpBuf, dwBufLen);
        if (lRet < 0)
            return E_FAIL;
        else {
            *plCopied = lRet;
            return S_OK;
        }
    }
    STDMETHODIMP SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
    {
        if (imm32::ImmSetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
    {
        if (imm32::ImmSetCompositionStringW(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen))
            return S_OK;
        else
            return E_FAIL;
    }

    /*
     * AIMM Composition Font API Methods
     */
    STDMETHODIMP GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
    {
        if (imm32::ImmGetCompositionFontA(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
    {
        if (imm32::ImmGetCompositionFontW(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
    {
        if (imm32::ImmSetCompositionFontA(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
    {
        if (imm32::ImmSetCompositionFontW(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }

    /*
     * AIMM Composition Window API Methods
     */
    STDMETHODIMP GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
    {
        return (imm32::ImmGetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                                  : E_FAIL;
    }
    STDMETHODIMP SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
    {
        return (imm32::ImmSetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                                  : E_FAIL;
    }

    /*
     * AIMM Candidate List API Methods
     */
    STDMETHODIMP GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListA(hIMC, dwIndex, lpCandList, uBufLen);
        if (dwRet) {
            *puCopied = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListW(hIMC, dwIndex, lpCandList, uBufLen);
        if (dwRet) {
            *puCopied = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListCountA(hIMC, lpdwListSize);
        if (dwRet) {
            *pdwBufLen = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListCountW(hIMC, lpdwListSize);
        if (dwRet) {
            *pdwBufLen = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }

    /*
     * AIMM Candidate Window API Methods
     */
    STDMETHODIMP GetCandidateWindow(HIMC hIMC, DWORD dwIndex, CANDIDATEFORM *lpCandidate)
    {
        return (imm32::ImmGetCandidateWindow(hIMC, dwIndex, lpCandidate)) ? S_OK
                                                                          : E_FAIL;
    }
    STDMETHODIMP SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate)
    {
        return (imm32::ImmSetCandidateWindow(hIMC, lpCandidate)) ? S_OK
                                                                 : E_FAIL;
    }

    /*
     * AIMM Guide Line API Methods
     */
    STDMETHODIMP GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetGuideLineA(hIMC, dwIndex, pBuf, dwBufLen);
        return S_OK;
    }
    STDMETHODIMP GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetGuideLineW(hIMC, dwIndex, pBuf, dwBufLen);
        return S_OK;
    }

    /*
     * AIMM Notify IME API Method
     */
    STDMETHODIMP NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
    {
        return (imm32::ImmNotifyIME(hIMC, dwAction, dwIndex, dwValue)) ? S_OK
                                                                       : E_FAIL;
    }

    /*
     * AIMM Menu Items API Methods
     */
    STDMETHODIMP GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetImeMenuItemsA(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize);
        return S_OK;
    }
    STDMETHODIMP GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetImeMenuItemsW(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize);
        return S_OK;
    }

    /*
     * AIMM Register Word API Methods
     */
    STDMETHODIMP RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister)
    {
        return imm32::ImmRegisterWordA(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister)
    {
        return imm32::ImmRegisterWordW(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister)
    {
        return imm32::ImmUnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister)
    {
        return imm32::ImmUnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum)
    {
        return E_FAIL;
    }
    STDMETHODIMP EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum)
    {
        return E_FAIL;
    }
    STDMETHODIMP GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetRegisterWordStyleA(hKL, nItem, lpStyleBuf);
        return S_OK;
    }
    STDMETHODIMP GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetRegisterWordStyleW(hKL, nItem, lpStyleBuf);
        return S_OK;
    }

    /*
     * AIMM Configuration API Methods.
     */
    STDMETHODIMP ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata)
    {
        return imm32::ImmConfigureIMEA(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
    }
    STDMETHODIMP ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata)
    {
        return imm32::ImmConfigureIMEW(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
    }
    STDMETHODIMP GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetDescriptionA(hKL, lpszDescription, uBufLen);
        return *puCopied ? S_OK : E_FAIL;
    }
    STDMETHODIMP GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetDescriptionW(hKL, lpszDescription, uBufLen);
        return *puCopied ? S_OK : E_FAIL;
    }
    STDMETHODIMP GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetIMEFileNameA(hKL, lpszFileName, uBufLen);
        return S_OK;
    }
    STDMETHODIMP GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetIMEFileNameW(hKL, lpszFileName, uBufLen);
        return S_OK;
    }
    STDMETHODIMP InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL)
    {
        *phKL = imm32::ImmInstallIMEA(lpszIMEFileName, lpszLayoutText);
        return S_OK;
    }
    STDMETHODIMP InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL)
    {
        *phKL = imm32::ImmInstallIMEW(lpszIMEFileName, lpszLayoutText);
        return S_OK;
    }
    STDMETHODIMP GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty)
    {
        *pdwProperty = imm32::ImmGetProperty(hKL, fdwIndex);
        return S_OK;
    }
    STDMETHODIMP IsIME(HKL hKL)
    {
        //
        //
        //
        //
        if (!imm32prev::CtfAImmIsIME(hKL))
            return S_FALSE;

        return imm32::ImmIsIME(hKL) ? S_OK : E_FAIL;
    }

    // others
    STDMETHODIMP EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        *plResult = imm32::ImmEscapeA(hKL, hIMC, uEscape, lpData);
        return S_OK;
    }
    STDMETHODIMP EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        *plResult = imm32::ImmEscapeW(hKL, hIMC, uEscape, lpData);
        return S_OK;
    }
    STDMETHODIMP GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetConversionListA(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
        return S_OK;
    }
    STDMETHODIMP GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetConversionListW(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
        return S_OK;
    }
    STDMETHODIMP GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd)
    {
        *phDefWnd = imm32::ImmGetDefaultIMEWnd(hWnd);
        return S_OK;
    }
    STDMETHODIMP GetVirtualKey(HWND hWnd, UINT *puVirtualKey)
    {
        *puVirtualKey = imm32::ImmGetVirtualKey(hWnd);
        return S_OK;
    }
    STDMETHODIMP IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        return imm32::ImmIsUIMessageA(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
    }
    STDMETHODIMP IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        return imm32::ImmIsUIMessageW(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
    }

    // ime helper methods
    STDMETHODIMP GenerateMessage(HIMC hIMC)
    {
        return (imm32::ImmGenerateMessage(hIMC)) ? S_OK
                                                 : E_FAIL;
    }

    // hot key manipulation api's
    STDMETHODIMP GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL)
    {
        return (imm32::ImmGetHotKey(dwHotKeyID, puModifiers, puVKey, phKL)) ? S_OK
                                                                            : E_FAIL;
    }
    STDMETHODIMP SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL)
    {
        return (imm32::ImmSetHotKey(dwHotKeyID, uModifiers, uVKey, hKL)) ? S_OK
                                                                         : E_FAIL;
    }
    STDMETHODIMP SimulateHotKey(HWND hWnd, DWORD dwHotKeyID)
    {
        return imm32::ImmSimulateHotKey(hWnd, dwHotKeyID) ? S_OK : S_FALSE;
    }

    // soft keyboard api's
    STDMETHODIMP CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd);
    STDMETHODIMP DestroySoftKeyboard(HWND hSoftKbdWnd);
    STDMETHODIMP ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    // win98/nt5 apis
    STDMETHODIMP DisableIME(DWORD idThread)
    {
        return imm32::ImmDisableIME(idThread) ? S_OK : E_FAIL;
    }
    STDMETHODIMP RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
    {
        *plResult = imm32::ImmRequestMessageA(hIMC, wParam, lParam);
        return S_OK;
    }
    STDMETHODIMP RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
    {
        *plResult = imm32::ImmRequestMessageW(hIMC, wParam, lParam);
        return S_OK;
    }
    STDMETHODIMP EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum)
    {
        Assert(0);
        return E_NOTIMPL;
    }

    // methods without corresponding IMM APIs

    //
    // IActiveIMMApp methods
    //

    STDMETHODIMP Activate(BOOL fRestoreLayout);
    STDMETHODIMP Deactivate();

    STDMETHODIMP OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    //
    // FilterClientWindows
    //
    STDMETHODIMP FilterClientWindows(ATOM *aaWindowClasses, UINT uSize);

    //
    //
    //
    STDMETHODIMP GetCodePageA(HKL hKL, UINT *uCodePage);
    STDMETHODIMP GetLangId(HKL hKL, LANGID *plid);

    //
    // IActiveIMMAppEx
    //
    STDMETHODIMP FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap);
    STDMETHODIMP FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);

    STDMETHODIMP GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom);

    STDMETHODIMP UnfilterClientWindowsEx(HWND hWnd);

    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IAImmThreadCompartment,
    //
    STDMETHODIMP SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);
    STDMETHODIMP GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);

protected:
    VOID _EnableGuidMap(BOOL fEnableGuidMap)
    {
        _fEnableGuidMap = fEnableGuidMap;
    }

private:
    BOOL IsGuidMapEnable(HIMC hIMC)
    {
        if (!InitFilterList())
            return FALSE;

        if (_fEnableGuidMap)
        {
            BOOL fGuidMap;

            if (g_pGuidMapList->_IsGuidMapEnable(hIMC, &fGuidMap))
            {
                if (fGuidMap)
                {
                    return imm32prev::CtfImmIsGuidMapEnable(hIMC);
                }
            }
        }
        return FALSE;
    }

private:
    BOOL  _fEnableGuidMap : 1;    // TRUE: Enable GUID Map attribute

    HMODULE m_hModCtfIme;
};

//+---------------------------------------------------------------------------
//
// CActiveIMMAppEx
//
//----------------------------------------------------------------------------

class CActiveIMMAppEx : public CComActiveIMMApp,
                        public CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx>
{
public:
    BEGIN_COM_MAP_IMMX(CActiveIMMAppEx)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppTrident4x, CActiveIMMAppEx)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppPostNT4, CActiveIMMAppEx)
        COM_INTERFACE_ENTRY(IActiveIMMApp)
        COM_INTERFACE_ENTRY_FUNC(IID_IActiveIMMAppEx, TRUE, CActiveIMMAppEx::EnableGuidMap)
        COM_INTERFACE_ENTRY(IActiveIMMMessagePumpOwner)
        COM_INTERFACE_ENTRY(IAImmThreadCompartment)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (IsOldAImm())
        {
            // aimm12 has some whacky CreateIntance rules to support trident
            return CActiveIMM_CreateInstance(pUnkOuter, riid, ppvObj);
        }
        else
        {
            return CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx>::CreateInstance(pUnkOuter, riid, ppvObj);
        }
    }

    static void PostCreateInstance(REFIID riid, void *pvObj)
    {
        imm32prev::CtfImmSetAppCompatFlags(IMECOMPAT_AIMM12);
    }

    static HRESULT WINAPI EnableGuidMap(void* pv, REFIID riid, LPVOID* ppv, DWORD dw)
    {
        if (IsEqualIID(riid, IID_IActiveIMMAppEx))
        {
            CActiveIMMAppEx* _pActiveIMM = (CActiveIMMAppEx*) pv;
            *ppv = SAFECAST(_pActiveIMM, IActiveIMMAppEx*);
            if (*ppv)
            {
                _pActiveIMM->AddRef();
                _pActiveIMM->_EnableGuidMap((BOOL)dw);
                return S_OK;
            }
            return E_NOINTERFACE;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
};

//+---------------------------------------------------------------------------
//
// CActiveIMMAppEx_Trident
//
//----------------------------------------------------------------------------

class CActiveIMMAppEx_Trident : public CComActiveIMMApp,
                                public CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx_Trident>
{
public:
    BEGIN_COM_MAP_IMMX(CActiveIMMAppEx_Trident)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppTrident4x, CActiveIMMAppEx_Trident)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppPostNT4, CActiveIMMAppEx_Trident)
        COM_INTERFACE_ENTRY(IActiveIMMApp)
        COM_INTERFACE_ENTRY(IActiveIMMAppEx)
        COM_INTERFACE_ENTRY(IActiveIMMMessagePumpOwner)
        COM_INTERFACE_ENTRY(IAImmThreadCompartment)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (IsOldAImm())
        {
            // aimm12 has some whacky CreateIntance rules to support trident
            return CActiveIMM_CreateInstance_Trident(pUnkOuter, riid, ppvObj);
        }
        else
        {
            return CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx_Trident>::CreateInstance(pUnkOuter, riid, ppvObj);
        }
    }

    static void PostCreateInstance(REFIID riid, void *pvObj)
    {
        imm32prev::CtfImmSetAppCompatFlags(IMECOMPAT_AIMM12_TRIDENT);
    }
};

#endif // _DIMMEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmwrp.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmwrp.h

Abstract:

    This file defines the CActiveIMMApp Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _DIMMWRP_H_
#define _DIMMWRP_H_

#include "resource.h"
#include "dimmex.h"

//+---------------------------------------------------------------------------
//
// CActiveIMMApp
//
//----------------------------------------------------------------------------

class CActiveIMMApp : public CComActiveIMMApp,
                      public CComObjectRoot_CreateInstance_Verify<CActiveIMMApp>
{
public:
    BEGIN_COM_MAP_IMMX(CActiveIMMApp)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppTrident4x, CActiveIMMApp)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppPostNT4, CActiveIMMApp)
        COM_INTERFACE_ENTRY(IActiveIMMApp)
        COM_INTERFACE_ENTRY(IActiveIMMMessagePumpOwner)
        COM_INTERFACE_ENTRY(IAImmThreadCompartment)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (IsOldAImm())
        {
            // aimm12 has some whacky CreateIntance rules to support trident
            return CActiveIMM_CreateInstance_Legacy(pUnkOuter, riid, ppvObj);
        }
        else
        {
            return CComObjectRoot_CreateInstance_Verify<CActiveIMMApp>::CreateInstance(pUnkOuter, riid, ppvObj);
        }
    }

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    static void PostCreateInstance(REFIID riid, void *pvObj);
};

#endif // _DIMMWRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmwrp.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmwrp.cpp

Abstract:

    This file implements the CActiveIMMApp Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "dimmwrp.h"
#include "resource.h"
#include "cregkey.h"

//
// Check IE5.5 version
//
static BOOL g_fCachedIE = FALSE;
static BOOL g_fNewVerIE = FALSE;

#define IEVERSION55     0x00050032
#define IEVERSION6      0x00060000


//
// REGKEY
//
const TCHAR c_szMSIMTFKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\MSIMTF\\");

// REG_DWORD : 0     // No
//             1     // Only Trident (default)
//             2     // Always AIMM12
const TCHAR c_szUseAIMM12[] = TEXT("UseAIMM12");

// REG_MULTI_SZ
//    Known EXE module list for Trident aware applications.
const TCHAR c_szKnownEXE[] = TEXT("KnownEXE");

//+---------------------------------------------------------------------------
//
// Check registry to decice load AIMM1.2
//
//----------------------------------------------------------------------------

#define DIMM12_NO              0
#define DIMM12_TRIDENTONLY     1
#define DIMM12_ALWAYS          2

DWORD
IsAimm12Enable()
{
    CMyRegKey    Aimm12Reg;
    LONG       lRet;
    lRet = Aimm12Reg.Open(HKEY_LOCAL_MACHINE, c_szMSIMTFKey, KEY_READ);
    if (lRet == ERROR_SUCCESS) {
        DWORD dw;
        lRet = Aimm12Reg.QueryValue(dw, c_szUseAIMM12);
        if (lRet == ERROR_SUCCESS) {
            return dw;
        }
    }

    return DIMM12_TRIDENTONLY;
}

//+---------------------------------------------------------------------------
//
// Is this trident module
//
// We should distinguish what exe module calls CoCreateInstance( CLSID_CActiveIMM ).
// If caller is any 3rd party's or unknown modle,
// then we could not support AIMM 1.2 interface.
//
//----------------------------------------------------------------------------

BOOL
IsTridentModule()
{
    TCHAR szFileName[MAX_PATH + 1];
    if (::GetModuleFileName(NULL,            // handle to module
                            szFileName,      // file name of module
                            ARRAYSIZE(szFileName) - 1) == 0)
        return FALSE;

    szFileName[ARRAYSIZE(szFileName) - 1] = TEXT('\0');

    TCHAR  szModuleName[MAX_PATH + 1];
    LPTSTR pszFilePart = NULL;
    DWORD dwLen;
    dwLen = ::GetFullPathName(szFileName,            // file name
                              ARRAYSIZE(szModuleName) - 1,
                              szModuleName,          // path buffer
                              &pszFilePart);         // address of file name in path
    if (dwLen > ARRAYSIZE(szModuleName) - 1)
        return FALSE;

    if (pszFilePart == NULL)
        return FALSE;

    szModuleName[ARRAYSIZE(szModuleName) - 1] = TEXT('\0');

    //
    // Setup system defines module list from registry value.
    //
    int        len;

    CMyRegKey    Aimm12Reg;
    LONG       lRet;
    lRet = Aimm12Reg.Open(HKEY_LOCAL_MACHINE, c_szMSIMTFKey, KEY_READ);
    if (lRet == ERROR_SUCCESS) {
        TCHAR  szValue[MAX_PATH];

        lRet = Aimm12Reg.QueryValueCch(szValue, c_szKnownEXE, ARRAYSIZE(szValue));

        if (lRet == ERROR_SUCCESS) {
            LPTSTR psz = szValue;
            while (*psz) {
                len = lstrlen(psz);

                if (lstrcmpi(pszFilePart, psz) == 0) {
                    return TRUE;        // This is Trident module.
                }

                psz += len + 1;
            }
        }
    }

    //
    // Setup default module list from resource data (RCDATA)
    //
    LPTSTR  lpName = (LPTSTR) ID_KNOWN_EXE;

    HRSRC hRSrc = FindResourceEx(g_hInst, RT_RCDATA, lpName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    if (hRSrc == NULL)
        return FALSE;

    HGLOBAL hMem = LoadResource(g_hInst, hRSrc);
    if (hMem == NULL)
        return FALSE;

    LPTSTR psz = (LPTSTR)LockResource(hMem);

    while (*psz) {
        len = lstrlen(psz);

        if (lstrcmpi(pszFilePart, psz) == 0) {
            return TRUE;        // This is Trident module.
        }

        psz += len + 1;
    }

    return FALSE;
}

BOOL
IsTridentNewVersion()
{
    BOOL fRet = FALSE;
    TCHAR  szMShtmlName[MAX_PATH + 1];

    if (g_fCachedIE)
    {
        return g_fNewVerIE;
    }

    //
    // Get "mshtml.dll" module from system directory and read version.
    //
    if (GetSystemDirectory(szMShtmlName, ARRAYSIZE(szMShtmlName) - 1))
    {
        UINT cb;
        void *pvData;
        DWORD dwVerHandle;
        VS_FIXEDFILEINFO *pffi;
        HRESULT hr;

        szMShtmlName[ARRAYSIZE(szMShtmlName) - 1] = TEXT('\0');
        hr = StringCchCat(szMShtmlName, ARRAYSIZE(szMShtmlName), TEXT("\\"));
        if (hr != S_OK)
            return FALSE;
        hr = StringCchCat(szMShtmlName, ARRAYSIZE(szMShtmlName), TEXT("mshtml.dll"));
        if (hr != S_OK)
            return FALSE;

        cb = GetFileVersionInfoSize(szMShtmlName, &dwVerHandle);

        if (cb == 0)
            return FALSE;

        if ((pvData = cicMemAlloc(cb)) == NULL)
            return FALSE;

        if (GetFileVersionInfo(szMShtmlName, 0, cb, pvData) &&
            VerQueryValue(pvData, TEXT("\\"), (void **)&pffi, &cb))
        {
            g_fCachedIE = TRUE;

            //fRet = g_fNewVerIE = (pffi->dwProductVersionMS >= IEVERSION55);
            if ((pffi->dwProductVersionMS >= IEVERSION55) &&
                (pffi->dwProductVersionMS <= IEVERSION6))
            {
                fRet = g_fNewVerIE = TRUE;
            }
            else
            {
                fRet = g_fNewVerIE = FALSE;
            }
        }
        else
        {
            fRet = FALSE;
        }

        cicMemFree(pvData);           
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// GetCompatibility
//
//----------------------------------------------------------------------------

VOID GetCompatibility(DWORD* dw, BOOL* fTrident, BOOL* _fTrident55)
{
    //
    // Retrieve AIMM1.2 Enable flag from REGKEY
    //
    *dw = IsAimm12Enable();

    //
    // Retrieve Trident aware application flag from REGKEY and RESOURCE.
    //
    *fTrident = IsTridentModule();

    //
    // Check Trident version with "mshtml.dll" module
    //
    *_fTrident55 = FALSE;

    if (*fTrident)
    {
        *_fTrident55 = IsTridentNewVersion();
    }
}

//+---------------------------------------------------------------------------
//
// VerifyCreateInstance
//
//----------------------------------------------------------------------------

BOOL CActiveIMMApp::VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    DWORD dw;
    BOOL  fTrident;
    BOOL  _fTrident55;
    GetCompatibility(&dw, &fTrident, &_fTrident55);

    if ( (dw == DIMM12_ALWAYS) ||
        ((dw == DIMM12_TRIDENTONLY) && fTrident))
    {
        //
        // CreateInstance AIMM1.2
        //
        return CComActiveIMMApp::VerifyCreateInstance(pUnkOuter, riid, ppvObj);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// PostCreateInstance
//
//----------------------------------------------------------------------------

void CActiveIMMApp::PostCreateInstance(REFIID riid, void *pvObj)
{
    DWORD dw;
    BOOL  fTrident;
    BOOL  _fTrident55;
    GetCompatibility(&dw, &fTrident, &_fTrident55);

    imm32prev::CtfImmSetAppCompatFlags(IMECOMPAT_AIMM_LEGACY_CLSID | (_fTrident55 ? IMECOMPAT_AIMM_TRIDENT55 : 0));
}

#ifdef OLD_AIMM_ENABLED

//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance (Old AIMM1.2)
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM_CreateInstance_Legacy(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj)
{
    DWORD dw;
    BOOL  fTrident;
    BOOL  _fTrident55;
    GetCompatibility(&dw, &fTrident, &_fTrident55);

    if ( (dw == DIMM12_ALWAYS) ||
        ((dw == DIMM12_TRIDENTONLY) && fTrident))
    {
        //
        // CreateInstance AIMM1.2
        //
        g_fInLegacyClsid = TRUE;
        return CActiveIMM_CreateInstance(pUnkOuter, riid, ppvObj);
    }

    return E_NOINTERFACE;
}

#endif // OLD_AIMM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\delay.cpp ===
//
// delay.cpp
//
// Delay load imported functions for perf.
//

#include "private.h"
#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;

FARPROC GetFn(HINSTANCE *phInst, LPCTSTR pchLib, LPCSTR pchFunc)
{
    if (*phInst == 0)
    {
        EnterCriticalSection(g_cs);

        if (*phInst == 0)
        {
            *phInst = LoadSystemLibrary(pchLib);
        }

        LeaveCriticalSection(g_cs);

        if (*phInst == 0)
        {
            Assert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal)   \
_RetType _CallConv _FuncName _Args1                                             \
{                                                                               \
    static FARPROC pfn = NULL;                                                  \
                                                                                \
    if (pfn == NULL || _hInst == NULL)                                          \
    {                                                                           \
        pfn = GetFn(&_hInst, _DllName, #_FuncName);                             \
                                                                                \
        if (pfn == NULL)                                                        \
        {                                                                       \
            Assert(0);                                                          \
            return (_RetType) _ErrVal;                                          \
        }                                                                       \
    }                                                                           \
                                                                                \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                       \
}


//
// imm32.dll
//
namespace imm32 {

    const TCHAR module_imm32[] = TEXT("imm32.dll");

#define IMM32LOAD(_FuncName, _Args1, _Args2, _RetType, _ErrVal) \
    DELAYLOAD(g_hImm32, module_imm32, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal)


    HINSTANCE g_hImm32 = 0;

    BOOL FreeLibrary()
    {
        BOOL ret = FALSE;
        if (g_hImm32 != NULL)
        {
            ret = ::FreeLibrary(g_hImm32);
            g_hImm32 = NULL;
        }
        return ret;
    }

    /*
     * IMM32 Input Context (hIMC) API Interface.
     */
    IMM32LOAD(ImmCreateContext, (void), (), HIMC, 0)
    IMM32LOAD(ImmDestroyContext, (HIMC hIMC), (hIMC), BOOL, FALSE)
    IMM32LOAD(ImmAssociateContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), HIMC, 0)
    IMM32LOAD(ImmAssociateContextEx, (HWND hWnd, HIMC hIMC, DWORD dwFlags), (hWnd, hIMC, dwFlags), BOOL, FALSE)
    IMM32LOAD(ImmGetContext, (HWND hWnd), (hWnd), HIMC, 0)
    IMM32LOAD(ImmReleaseContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), BOOL, FALSE)
    IMM32LOAD(ImmGetIMCLockCount, (HIMC hIMC), (hIMC), DWORD, 0)
    IMM32LOAD(ImmUnlockIMC, (HIMC hIMC), (hIMC), BOOL, FALSE)
    IMM32LOAD(ImmLockIMC, (HIMC hIMC), (hIMC), LPINPUTCONTEXT, NULL)

    /*
     * IMM32 Input Context Components (hIMCC) API Interface.
     */
    IMM32LOAD(ImmCreateIMCC, (DWORD dw), (dw), HIMCC, FALSE)
    IMM32LOAD(ImmDestroyIMCC, (HIMCC hIMCC), (hIMCC), HIMCC, hIMCC)
    IMM32LOAD(ImmGetIMCCSize, (HIMCC hIMCC), (hIMCC), DWORD, 0)
    IMM32LOAD(ImmReSizeIMCC, (HIMCC hIMCC, DWORD dw), (hIMCC, dw), HIMCC, 0)
    IMM32LOAD(ImmGetIMCCLockCount, (HIMCC hIMCC), (hIMCC), DWORD, 0)
    IMM32LOAD(ImmUnlockIMCC, (HIMCC hIMCC), (hIMCC), BOOL, FALSE)
    IMM32LOAD(ImmLockIMCC, (HIMCC hIMCC), (hIMCC), LPVOID, NULL)

    /*
     * IMM32 Composition String API Interface
     */
    IMM32LOAD(ImmGetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), LONG, 0);
    IMM32LOAD(ImmGetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), LONG, 0);
    IMM32LOAD(ImmSetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen), (hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen), BOOL, FALSE);
    IMM32LOAD(ImmSetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen), (hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen), BOOL, FALSE);

    /*
     * IMM32 Composition Font API Interface
     */
    IMM32LOAD(ImmGetCompositionFontA, (HIMC hIMC, LPLOGFONTA lplf), (hIMC, lplf), BOOL, FALSE);
    IMM32LOAD(ImmGetCompositionFontW, (HIMC hIMC, LPLOGFONTW lplf), (hIMC, lplf), BOOL, FALSE);
    IMM32LOAD(ImmSetCompositionFontA, (HIMC hIMC, LPLOGFONTA lplf), (hIMC, lplf), BOOL, FALSE);
    IMM32LOAD(ImmSetCompositionFontW, (HIMC hIMC, LPLOGFONTW lplf), (hIMC, lplf), BOOL, FALSE);

    /*
     * IMM32 Open Status API Interface
     */
    IMM32LOAD(ImmGetOpenStatus, (HIMC hIMC), (hIMC), BOOL, FALSE)
    IMM32LOAD(ImmSetOpenStatus, (HIMC hIMC, BOOL f), (hIMC, f), BOOL, FALSE)

    /*
     * IMM32 Conversion Status API Interface
     */
    IMM32LOAD(ImmGetConversionStatus, (HIMC hIMC, LPDWORD pdw1, LPDWORD pdw2), (hIMC, pdw1, pdw2), BOOL, FALSE)
    IMM32LOAD(ImmSetConversionStatus, (HIMC hIMC, DWORD dw1, DWORD dw2), (hIMC, dw1, dw2), BOOL, FALSE)

    /*
     * IMM32 Status Window Pos API Interface
     */
    IMM32LOAD(ImmGetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE)
    IMM32LOAD(ImmSetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE)


    /*
     * IMM32 Composition Window API Interface
     */
    IMM32LOAD(ImmGetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM lpCompForm), (hIMC, lpCompForm), BOOL, FALSE)
    IMM32LOAD(ImmSetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM lpCompForm), (hIMC, lpCompForm), BOOL, FALSE);


    /*
     * IMM32 Candidate Window API Interface
     */
    IMM32LOAD(ImmGetCandidateWindow, (HIMC hIMC, DWORD dw, LPCANDIDATEFORM pCF), (hIMC, dw, pCF), BOOL, FALSE)
    IMM32LOAD(ImmSetCandidateWindow, (HIMC hIMC, LPCANDIDATEFORM pCF), (hIMC, pCF), BOOL, FALSE)
    IMM32LOAD(ImmGetCandidateListA, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0);
    IMM32LOAD(ImmGetCandidateListW, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0);
    IMM32LOAD(ImmGetCandidateListCountA, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0);
    IMM32LOAD(ImmGetCandidateListCountW, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0);

    /*
     * IMM32 Generate Message API Interface
     */
    IMM32LOAD(ImmGenerateMessage, (HIMC hIMC), (hIMC), BOOL, FALSE);

    /*
     * IMM32 Notify IME API Interface
     */
    IMM32LOAD(ImmNotifyIME, (HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue), (hIMC, dwAction, dwIndex, dwValue), BOOL, FALSE)

    /*
     * IMM32 Guide Line IME API Interface
     */
    IMM32LOAD(ImmGetGuideLineA, (HIMC hIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0);
    IMM32LOAD(ImmGetGuideLineW, (HIMC hIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0);

    /*
     * IMM32 Menu items API Interface
     */
    IMM32LOAD(ImmGetImeMenuItemsA, (HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, lpImeParentMenu, lpImeMenu, dwSize), DWORD, 0);
    IMM32LOAD(ImmGetImeMenuItemsW, (HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, lpImeParentMenu, lpImeMenu, dwSize), DWORD, 0);

    /*
     * IMM32 Default IME Window API Interface
     */
    IMM32LOAD(ImmGetDefaultIMEWnd, (HWND hWnd), (hWnd), HWND, 0);
    IMM32LOAD(ImmGetVirtualKey, (HWND hWnd), (hWnd), UINT, VK_PROCESSKEY);

    /*
     * IMM32 UI message API Interface
     */
    IMM32LOAD(ImmIsUIMessageA, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE);
    IMM32LOAD(ImmIsUIMessageW, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE);

    /*
     * IMM32 Simulate hotkey API Interface
     */
    IMM32LOAD(ImmSimulateHotKey, (HWND hWnd, DWORD dwHotKeyID), (hWnd, dwHotKeyID), BOOL, FALSE);
    IMM32LOAD(ImmGetHotKey, (DWORD dwHotKeyId, LPUINT lpuModifiers, LPUINT lpuVKey, LPHKL lphKL), (dwHotKeyId, lpuModifiers, lpuVKey, lphKL), BOOL, FALSE);
    IMM32LOAD(ImmSetHotKey, (DWORD dwHotKeyId, UINT uModifiers, UINT uVKey, HKL hKL), (dwHotKeyId, uModifiers, uVKey, hKL), BOOL, FALSE);

    /*
     * IMM32 Property API Interface
     */
    IMM32LOAD(ImmGetProperty, (HKL hKL, DWORD dw), (hKL, dw), DWORD, 0);

    /*
     * IMM32 Description API Interface
     */
    IMM32LOAD(ImmGetDescriptionA, (HKL hKL, LPSTR lpszDescription, UINT uBufLen), (hKL, lpszDescription, uBufLen), UINT, 0);
    IMM32LOAD(ImmGetDescriptionW, (HKL hKL, LPWSTR lpszDescription, UINT uBufLen), (hKL, lpszDescription, uBufLen), UINT, 0);
    IMM32LOAD(ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0);
    IMM32LOAD(ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0);

    /*
     * IMM32 Conversion List API Interface
     */
    IMM32LOAD(ImmGetConversionListA, (HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0);
    IMM32LOAD(ImmGetConversionListW, (HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0);

    /*
     * IMM32 IsIME API Interface
     */
    IMM32LOAD(ImmIsIME, (HKL hKL), (hKL), BOOL, FALSE);

    /*
     * IMM32 Escape API Interface
     */
    IMM32LOAD(ImmEscapeA, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0);
    IMM32LOAD(ImmEscapeW, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0);

    /*
     * IMM32 Configure IME Interface
     */
    IMM32LOAD(ImmConfigureIMEA, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE);
    IMM32LOAD(ImmConfigureIMEW, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE);

    /*
     * IMM32 Register Word IME Interface
     */
    IMM32LOAD(ImmRegisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE);
    IMM32LOAD(ImmRegisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE);
    IMM32LOAD(ImmUnregisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE);
    IMM32LOAD(ImmUnregisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE);
    IMM32LOAD(ImmGetRegisterWordStyleA, (HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0);
    IMM32LOAD(ImmGetRegisterWordStyleW, (HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0);

    /*
     * IMM32 soft kbd API
     */
    IMM32LOAD(ImmCreateSoftKeyboard, (UINT uType, HWND hOwner, int x, int y), (uType, hOwner, x, y), HWND, NULL);
    IMM32LOAD(ImmDestroySoftKeyboard, (HWND hSoftKbdWnd), (hSoftKbdWnd), BOOL, FALSE);
    IMM32LOAD(ImmShowSoftKeyboard, (HWND hSoftKbdWnd, int nCmdShow), (hSoftKbdWnd, nCmdShow), BOOL, FALSE);

    /*
     * IMM32 Enumurate Input Context API
     */
    IMM32LOAD(ImmEnumInputContext, (DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam), (idThread, lpfn, lParam), BOOL, FALSE);

    /*
     * IMM32 win98/nt5 apis
     */
    IMM32LOAD(ImmDisableIME, (DWORD dwId), (dwId), BOOL, FALSE);

    IMM32LOAD(ImmRequestMessageA, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0);
    IMM32LOAD(ImmRequestMessageW, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0);

    IMM32LOAD(ImmInstallIMEA, (LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0);
    IMM32LOAD(ImmInstallIMEW, (LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0);
}



//
// imm32.dll
//
namespace imm32prev {

    const TCHAR module_imm32[] = TEXT("imm32.dll");

#define IMM32LOAD(_FuncName, _Args1, _Args2, _RetType, _ErrVal) \
    DELAYLOAD(g_hImm32, module_imm32, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal)


    HINSTANCE g_hImm32 = 0;

    BOOL FreeLibrary()
    {
        BOOL ret = FALSE;
        if (g_hImm32 != NULL)
        {
            ret = ::FreeLibrary(g_hImm32);
            g_hImm32 = NULL;
        }
        return ret;
    }


    IMM32LOAD(CtfImmGetGuidAtom, (HIMC hIMC, BYTE bAttr, DWORD* pGuidAtom), (hIMC, bAttr, pGuidAtom), HRESULT, S_OK);
    IMM32LOAD(CtfImmIsGuidMapEnable, (HIMC hIMC), (hIMC), BOOL, FALSE);
    IMM32LOAD(CtfImmIsCiceroEnabled, (VOID), (), BOOL, FALSE);
    IMM32LOAD(CtfImmIsCiceroStartedInThread, (VOID), (), BOOL, FALSE);
    IMM32LOAD(CtfImmSetCiceroStartInThread, (BOOL fSet), (fSet), HRESULT, S_OK);
    IMM32LOAD(GetKeyboardLayoutCP, (HKL hKL), (hKL), UINT, 0);
    IMM32LOAD(ImmGetAppCompatFlags, (HIMC hIMC), (hIMC), DWORD, 0);
    IMM32LOAD(CtfImmSetAppCompatFlags, (DWORD dwFlag), (dwFlag), VOID, NULL);
    IMM32LOAD(CtfAImmActivate, (HMODULE* phMod), (phMod), HRESULT, E_FAIL);
    IMM32LOAD(CtfAImmDeactivate, (HMODULE hMod), (hMod), HRESULT, E_FAIL);
    IMM32LOAD(CtfAImmIsIME, (HKL hkl), (hkl), BOOL, FALSE);
}


//
// version.dll
//
const TCHAR module_version[] = TEXT("version.dll");

HINSTANCE g_hVersion = 0;


DELAYLOAD(g_hVersion, module_version, WINAPI, GetFileVersionInfoSizeA, (LPTSTR pszFileName, LPDWORD pdwHandle), (pszFileName, pdwHandle), DWORD, 0);
DELAYLOAD(g_hVersion, module_version, WINAPI, GetFileVersionInfoA, (LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData), (lptstrFilename, dwHandle, dwLen, lpData), BOOL, FALSE);
DELAYLOAD(g_hVersion, module_version, WINAPI, VerQueryValueA, (const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen), (pBlock, lpSubBlock, lplpBuffer, puLen), BOOL, FALSE);

//
// msctf.dll
//
const TCHAR module_msctf[] = TEXT("msctf.dll");

HINSTANCE g_hCTF = 0;

DELAYLOAD(g_hCTF, module_msctf, WINAPI, TF_CreateLangBarMgr, (ITfLangBarMgr **pplbm), (pplbm), HRESULT, E_FAIL);

//
// ole32.dll
//
HINSTANCE g_hOle32 = 0;

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoCreateInstance");

        if (pfn == NULL)
        {
            Assert(0);
            if (ppv != NULL)
            {
                *ppv = NULL;
            }
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv))(pfn))(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoTaskMemAlloc");

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(ULONG cb))(pfn))(cb);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoTaskMemRealloc");

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(LPVOID pv, ULONG cb))(pfn))(pv, cb);
}

void STDAPICALLTYPE Internal_CoTaskMemFree(void* pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoTaskMemFree");

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    ((void (STDAPICALLTYPE *)(void* pv))(pfn))(pv);
}



//
// cleanup -- called from process detach
//

void UninitDelayLoadLibraries()
{
    EnterCriticalSection(g_cs);

    imm32::FreeLibrary();
    imm32prev::FreeLibrary();


    if (g_hVersion != 0)
    {
        FreeLibrary(g_hVersion);
        g_hVersion = NULL;
    }

    if (g_hCTF != 0)
    {
        FreeLibrary(g_hCTF);
        g_hCTF = NULL;
    }

    if (g_hOle32 != 0)
    {
        FreeLibrary(g_hOle32);
        g_hOle32 = NULL;
    }

    LeaveCriticalSection(g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dllmain.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dllmain.cpp

Abstract:

    This file implements the DLL MAIN.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "globals.h"
#include "dimmex.h"
#include "dimmwrp.h"
#include "oldaimm.h"
#include "tls.h"

DECLARE_OSVER()

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    CcshellGetDebugFlags();

    g_hInst = hInstance;

    if (!g_cs.Init())
       return FALSE;

    Dbg_MemInit(TEXT("MSIMTF"), NULL);

    InitOSVer();

#ifdef OLD_AIMM_ENABLED
    //
    // Might be required by some library function, so let's initialize
    // it as the first thing.
    //
    TFInitLib_PrivateForCiceroOnly(Internal_CoCreateInstance);
#endif // OLD_AIMM_ENABLED

    if (IsOldAImm())
    {
        return OldAImm_DllProcessAttach(hInstance);
    }
    else
    {
        TLS::Initialize();
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
#ifdef OLD_AIMM_ENABLED
    TFUninitLib();
#endif // OLD_AIMM_ENABLED

    if (! IsOldAImm())
    {
        UninitFilterList();
        UninitAimmAtom();
    }

    if (IsOldAImm())
    {
        OldAImm_DllProcessDetach();
    }
    else
    {
        TLS::DestroyTLS();
        TLS::Uninitialize();
    }

    Dbg_MemUninit();

    g_cs.Delete();
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                return FALSE;
            }
            break;

        case DLL_THREAD_ATTACH:
            if (IsOldAImm())
            {
                return OldAImm_DllThreadAttach();
            }
            break;

        case DLL_THREAD_DETACH:
            if (IsOldAImm())
            {
                OldAImm_DllThreadDetach();
            }
            else
            {
                TLS::DestroyTLS();
            }
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\globals.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This file defines the global data.

Author:

Revision History:

Notes:

--*/


#ifndef _GLOBAL_H_
#define _GLOBAL_H_


#include "ciccs.h"

UINT GetCodePageFromLangId(LCID lcid);
HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp);

#if !defined(OLD_AIMM_ENABLED)
BOOL RunningInExcludedModule();
#endif // OLD_AIMM_ENABLED

extern CCicCriticalSectionStatic g_cs;

extern HINSTANCE g_hInst;

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\makefile.inc ===
imm.h : $(OAK_INC_PATH)\immdev.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\list.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.h

Abstract:

    This file defines the CGuidMapList Class.

Author:

Revision History:

Notes:

--*/


#ifndef LIST_H
#define LIST_H

#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// CGuidMapList

class CGuidMapList
{
public:
    CGuidMapList() { }
    virtual ~CGuidMapList() { }

    HRESULT _Update(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);
    HRESULT _Update(HWND hWnd, BOOL fGuidMap);
    HRESULT _Remove(HWND hWnd);

    BOOL _IsGuidMapEnable(HIMC hIMC, BOOL *pbGuidMap);
    BOOL _IsWindowFiltered(HWND hWnd);

private:
    typedef struct {
        BOOL fGuidMap : 1;
    } GUID_MAP_CLIENT;

    CMap<ATOM,                     // class KEY
         ATOM,                     // class ARG_KEY
         GUID_MAP_CLIENT,          // class VALUE
         GUID_MAP_CLIENT           // class ARG_VALUE
        > m_ClassFilterList;

    CMap<HWND,                     // class KEY
         HWND,                     // class ARG_KEY
         GUID_MAP_CLIENT,          // class VALUE
         GUID_MAP_CLIENT           // class ARG_VALUE
        > m_WndFilterList;
};

#endif // LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\list.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.cpp

Abstract:

    This file implements the CGuidMapList class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "list.h"
#include "globals.h"
#include "delay.h"

//+---------------------------------------------------------------------------
//
// CGuidMapList
//
//----------------------------------------------------------------------------

HRESULT
CGuidMapList::_Update(
    ATOM *aaWindowClasses,
    UINT uSize,
    BOOL *aaGuidMap)
{
    if (aaWindowClasses == NULL && uSize > 0)
        return E_INVALIDARG;

    EnterCriticalSection(g_cs);

    while (uSize--) {
        GUID_MAP_CLIENT filter;
        filter.fGuidMap =  aaGuidMap != NULL ? *aaGuidMap++ : FALSE;
        m_ClassFilterList.SetAt(*aaWindowClasses++, filter);
    }

    LeaveCriticalSection(g_cs);
    return S_OK;
}

HRESULT
CGuidMapList::_Update(
    HWND hWnd,
    BOOL fGuidMap)
{
    EnterCriticalSection(g_cs);

    GUID_MAP_CLIENT filter;
    filter.fGuidMap = fGuidMap;

    m_WndFilterList.SetAt(hWnd, filter);

    LeaveCriticalSection(g_cs);
    return S_OK;
}

HRESULT
CGuidMapList::_Remove(
    HWND hWnd)
{
    EnterCriticalSection(g_cs);

    m_WndFilterList.RemoveKey(hWnd);

    LeaveCriticalSection(g_cs);
    return S_OK;
}

BOOL
CGuidMapList::_IsGuidMapEnable(
    HIMC hIMC,
    BOOL *pbGuidMap)
{
    BOOL fRet = FALSE;

    INPUTCONTEXT* imc = imm32::ImmLockIMC(hIMC);
    if (imc == NULL)
    {
        return fRet;
    }

    EnterCriticalSection(g_cs);

    GUID_MAP_CLIENT filter = { 0 };

    BOOL bGuidMap = FALSE;

    fRet = m_WndFilterList.Lookup(imc->hWnd, filter);
    if (fRet)
    {
        bGuidMap = filter.fGuidMap;
    }
    else
    {
        ATOM aClass = (ATOM)GetClassLong(imc->hWnd, GCW_ATOM);
        fRet = m_ClassFilterList.Lookup(aClass, filter);
        if (fRet)
        {
            bGuidMap = filter.fGuidMap;
        }
    }

    LeaveCriticalSection(g_cs);

    if (pbGuidMap)
        *pbGuidMap = bGuidMap;

    imm32::ImmUnlockIMC(hIMC);

    return fRet;
}

BOOL
CGuidMapList::_IsWindowFiltered(
    HWND hWnd)
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    GUID_MAP_CLIENT filter = { 0 };


    fRet = m_WndFilterList.Lookup(hWnd, filter);
    if (!fRet)
    {
        ATOM aClass = (ATOM)GetClassLong(hWnd, GCW_ATOM);
        fRet = m_ClassFilterList.Lookup(aClass, filter);
    }

    LeaveCriticalSection(g_cs);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\oldaimm.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    oldaimm.cpp

Abstract:

    This file implements the old AIMM Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "oldaimm.h"
#include "delay.h"
#include "cregkey.h"
#include "globals.h"

#ifdef OLD_AIMM_ENABLED

#include "imtls.h"

DWORD g_dwTLSIndex = -1;
BOOL  g_fInLegacyClsid = FALSE;
BOOL  g_fTrident55 = FALSE;
BOOL  g_fAIMM12Trident = FALSE;

typedef enum
{
    CUAS_UNKNOWN = -1,
    CUAS_OFF     = 0,
    CUAS_ON      = 1
} CUAS_SWITCH;

CUAS_SWITCH g_fCUAS = CUAS_UNKNOWN;

//+---------------------------------------------------------------------------
//
// IsCTFIMEEnabled
//
//----------------------------------------------------------------------------

BOOL IsCTFIMEEnabled()
{
    return imm32prev::CtfImmIsCiceroEnabled();
}

//+---------------------------------------------------------------------------
//
// IsOldAImm
//
//----------------------------------------------------------------------------

BOOL IsOldAImm()
{
    if (! GetSystemMetrics( SM_IMMENABLED ))
        return TRUE;

    if (! IsCTFIMEEnabled())
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsCUAS_ON
//
//----------------------------------------------------------------------------

BOOL IsCUAS_ON()
{
    //
    // REGKEY
    //
    const TCHAR c_szCTFSharedKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");

    // REG_DWORD : 0     // No
    //             1     // Yes
    const TCHAR c_szCUAS[] = TEXT("CUAS");

    if (g_fCUAS == CUAS_UNKNOWN)
    {
        CMyRegKey    CtfReg;
        LONG       lRet;
        lRet = CtfReg.Open(HKEY_LOCAL_MACHINE, c_szCTFSharedKey, KEY_READ);
        if (lRet == ERROR_SUCCESS) {
            DWORD dw;
            lRet = CtfReg.QueryValue(dw, c_szCUAS);
            if (lRet == ERROR_SUCCESS) {
                g_fCUAS = (dw == 0 ? CUAS_OFF : CUAS_ON);
            }
        }
    }

    return g_fCUAS == CUAS_ON ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// OldAImm_DllProcessAttach
//
//----------------------------------------------------------------------------

BOOL OldAImm_DllProcessAttach(HINSTANCE hInstance)
{
    g_hInst = hInstance;

    g_dwTLSIndex = TlsAlloc();

    if (!DIMM12_DllProcessAttach())
        return FALSE;

    if (!WIN32LR_DllProcessAttach())
        return FALSE;

    return TRUE;
}

BOOL OldAImm_DllThreadAttach()
{
    WIN32LR_DllThreadAttach();
    return TRUE;
}

VOID OldAImm_DllThreadDetach()
{
    WIN32LR_DllThreadDetach();

    IMTLS_Free();
}

VOID OldAImm_DllProcessDetach()
{
    WIN32LR_DllProcessDetach();

    IMTLS_Free();
    TlsFree(g_dwTLSIndex);
}

#else // OLD_AIMM_ENABLED

BOOL IsOldAImm() { return FALSE; }
BOOL OldAImm_DllProcessAttach(HINSTANCE hInstance) { return FALSE; }
BOOL OldAImm_DllThreadAttach() { return FALSE; }
VOID OldAImm_DllThreadDetach() { }
VOID OldAImm_DllProcessDetach() { }

#endif // OLD_AIMM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\globals.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    This file implements the global data.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "list.h"
#include "tls.h"

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

HINSTANCE g_hInst;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

DWORD TLS::dwTLSIndex = 0;

#if !defined(OLD_AIMM_ENABLED)

//+---------------------------------------------------------------------------
//
// RunningInExcludedModule
//
// Exclude some processes from using the old aimm IIDs/CLSIDs.
//----------------------------------------------------------------------------

BOOL RunningInExcludedModule()
{
    DWORD dwHandle;
    void *pvData;
    VS_FIXEDFILEINFO *pffi;
    UINT cb;
    TCHAR ch;
    TCHAR *pch;
    TCHAR *pchFileName;
    BOOL fRet;
    TCHAR achModule[MAX_PATH + 1];

    if (GetModuleFileName(NULL, achModule, ARRAY_SIZE(achModule) - 1) == 0)
        return FALSE;

    achModule[ARRAYSIZE(achModule) - 1] = TEXT('\0');

    pch = pchFileName = achModule;

    while ((ch = *pch) != 0)
    {
        pch = CharNext(pch);

        if (ch == TEXT('\\'))
        {
            pchFileName = pch;
        }
    }

    fRet = FALSE;

    if (lstrcmpi(pchFileName, TEXT("outlook.exe")) == 0)
    {
        static BOOL s_fCached = FALSE;
        static BOOL s_fOldVersion = TRUE;

        // don't run aimm with versions of outlook before 10.0

        if (s_fCached)
        {
            return s_fOldVersion;
        }

        cb = GetFileVersionInfoSize(achModule, &dwHandle);

        if (cb == 0)
        {
            // can't get ver info...assume the worst
            return TRUE;
        }

        if ((pvData = cicMemAlloc(cb)) == NULL)
            return TRUE; // assume the worst

        if (GetFileVersionInfo(achModule, 0, cb, pvData) &&
            VerQueryValue(pvData, TEXT("\\"), (void **)&pffi, &cb))
        {
            fRet = s_fOldVersion = (HIWORD(pffi->dwProductVersionMS) < 10);
            s_fCached = TRUE; // set this last to be thread safe
        }
        else
        {
            fRet = TRUE; // something went wrong
        }

        cicMemFree(pvData);           
    }

    return fRet;
}

#endif // OLD_AIMM_ENABLED

//+---------------------------------------------------------------------------
//
//  GetCompartment
//
//----------------------------------------------------------------------------

HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;

    if (FAILED(hr = punk->QueryInterface(IID_ITfCompartmentMgr,
                                         (void **)&pCompMgr)))
        goto Exit;

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\oldaimm.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    oldaimm.h

Abstract:

    This file defines the old AIMM Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _OLDAIMM_H_
#define _OLDAIMM_H_

extern BOOL  g_fInLegacyClsid;

/*
 * Proto-type in oldaimm.cpp
 */
BOOL IsOldAImm();
BOOL IsCUAS_ON();
BOOL OldAImm_DllProcessAttach(HINSTANCE hInstance);
BOOL OldAImm_DllThreadAttach();
VOID OldAImm_DllThreadDetach();
VOID OldAImm_DllProcessDetach();

extern HRESULT CActiveIMM_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
extern HRESULT CActiveIMM_CreateInstance_Trident(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
extern HRESULT CActiveIMM_CreateInstance_Legacy(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

void UninitDelayLoadLibraries();

#ifdef OLD_AIMM_ENABLED

/*
 * Proto-type in old aimm lib
 */
extern BOOL DIMM12_DllProcessAttach();

extern BOOL WIN32LR_DllProcessAttach();
extern void WIN32LR_DllThreadAttach();
extern void WIN32LR_DllThreadDetach();
extern void WIN32LR_DllProcessDetach();

extern HRESULT WIN32LR_DllRegisterServer(void);
extern HRESULT WIN32LR_DllUnregisterServer(void);

extern BOOL RunningInExcludedModule();

#endif // OLD_AIMM_ENABLED
#endif // _OLDAIMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for AIMM1.2 WRAPPER project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <immp.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <debug.h>
#include "delay.h"
#include <limits.h>
#include "combase.h"
#if 0
// New NT5 header
#include "immdev.h"
#endif
#define _IMM_
#define _DDKIMM_H_

#include "aimm12.h"
#include "aimmex.h"
#include "aimmp.h"
#include "aimm.h"
#include "msuimw32.h"

#include "immxutil.h"
#include "helpers.h"
#include "osver.h"

#include "mem.h"

#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof(x)/sizeof(x)[0])
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    ARRAY_SIZE(x)
#endif

//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\server.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    server.cpp

Abstract:

    This file implements the CComModule Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "oldaimm.h"
#include "dimmex.h"
#include "dimmwrp.h"

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_CActiveIMM12,         CActiveIMMAppEx,           TEXT("CActiveIMMAppEx"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_CActiveIMM12_Trident, CActiveIMMAppEx_Trident,   TEXT("CActiveIMMAppEx_Trident"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_CActiveIMM,           CActiveIMMApp,             TEXT("CActiveIMMApp"))
END_COCLASSFACTORY_TABLE

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process detach, like
// FreeLibrary calls, COM Releases, or mutexing.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
}

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppvObj
    )
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

STDAPI
DllCanUnloadNow(
    void
    )
{
    return COMBase_DllCanUnloadNow();
}

STDAPI
DllRegisterServer(
    void
    )
{
#ifdef OLD_AIMM_ENABLED
    HRESULT hr;
    if ((hr=WIN32LR_DllRegisterServer()) != S_OK)
        return hr;
#else
    #error Should call RegisterCategories(GUID_PROP_MSIMTF_READONLY)
#endif // OLD_AIMM_ENABLED

    return COMBase_DllRegisterServer();
}

STDAPI
DllUnregisterServer(
    void
    )
{
#ifdef OLD_AIMM_ENABLED
    HRESULT hr;
    if ((hr=WIN32LR_DllUnregisterServer()) != S_OK)
        return hr;
#else
    #error Should call UnregisterCategories(GUID_PROP_MSIMTF_READONLY)
#endif // OLD_AIMM_ENABLED

    return COMBase_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\aimmwrap\tls.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    tls.h

Abstract:

    This file defines the TLS.

Author:

Revision History:

Notes:

--*/

#ifndef _TLS_H_
#define _TLS_H_

class TLS
{
public:
    static inline void Initialize()
    {
        dwTLSIndex = TlsAlloc();
    }

    static inline void Uninitialize()
    {
        TlsFree(dwTLSIndex);
    }

    static inline TLS* GetTLS()
    {
        //
        // Should allocate TLS data if doesn't exist.
        //
        return InternalAllocateTLS();
    }

    static inline TLS* ReferenceTLS()
    {
        //
        // Shouldn't allocate TLS data even TLS data doesn't exist.
        //
        return (TLS*)TlsGetValue(dwTLSIndex);
    }

    static inline BOOL DestroyTLS()
    {
        return InternalDestroyTLS();
    }

    inline int IncrementAIMMRefCnt()
    {
        return ++_fActivateCnt;
    }

    inline int DecrementAIMMRefCnt()
    {
        if (_fActivateCnt)
            return --_fActivateCnt;
        else
            return -1;
    }

private:
    int   _fActivateCnt;

private:
    static inline TLS* InternalAllocateTLS()
    {
        TLS* ptls = (TLS*)TlsGetValue(dwTLSIndex);
        if (ptls == NULL)
        {
            if ((ptls = (TLS*)cicMemAllocClear(sizeof(TLS))) == NULL)
                return NULL;

            if (! TlsSetValue(dwTLSIndex, ptls))
            {
                cicMemFree(ptls);
                return NULL;
            }
        }
        return ptls;
    }

    static BOOL InternalDestroyTLS()
    {
        TLS* ptls = (TLS*)TlsGetValue(dwTLSIndex);
        if (ptls != NULL)
        {
            cicMemFree(ptls);
            TlsSetValue(dwTLSIndex, NULL);
            return TRUE;
        }
        return FALSE;
    }

private:
    static DWORD dwTLSIndex;
};

#endif // _TLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\aime.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime.cpp

Abstract:

    This file implements the Active IME (Cicero) Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "context.h"
#include "defs.h"
#include "cdimm.h"
#include "globals.h"

BOOL
CActiveIMM::_CreateActiveIME()
{
    //
    // do the ImeInquire
    //

    // Inquire IME's information and UI class name.
    _pActiveIME->Inquire(TRUE, &_IMEInfoEx.ImeInfo, _IMEInfoEx.achWndClass, &_IMEInfoEx.dwPrivate);

    // Create default input context.
    _InputContext._CreateDefaultInputContext(_GetIMEProperty(PROP_PRIVATE_DATA_SIZE),
                                             (_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE) ? TRUE : FALSE,
                                             TRUE);

    //
    // Create default IME window.
    //
    _DefaultIMEWindow._CreateDefaultIMEWindow(_InputContext._GetDefaultHIMC());

    return TRUE;
}

BOOL
CActiveIMM::_DestroyActiveIME(
    )
{
    // Destroy default input context.
    _InputContext._DestroyDefaultInputContext();

    // shut down our tip
    _pActiveIME->Destroy(0);

    // Destroy default IME window.
    _DefaultIMEWindow._DestroyDefaultIMEWindow();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _GetCompositionString
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_GetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    DWORD dwCompLen,
    LONG* lpCopied,
    LPVOID lpBuf,
    BOOL fUnicode
    )
{
    HRESULT hr;
    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
    if (FAILED(hr = lpCompStr.GetResult()))
        return hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    BOOL  fSwapGuidMapField = FALSE;
    DWORD dwSwapLen;
    DWORD dwSwapOffset;

    if (IsGuidMapEnable(lpIMC->hWnd) && (lpIMC->fdwInit & INIT_GUID_ATOM)) {
        //
        // Transrate GUID map attribute.
        //
        lpIMC->m_pContext->MapAttributes((HIMC)lpIMC);

        dwSwapLen    = lpCompStr->CompStr.dwCompAttrLen;
        dwSwapOffset = lpCompStr->CompStr.dwCompAttrOffset;
        lpCompStr->CompStr.dwCompAttrLen    = lpCompStr->dwGuidMapAttrLen;
        lpCompStr->CompStr.dwCompAttrOffset = lpCompStr->dwGuidMapAttrOffset;
        fSwapGuidMapField = TRUE;
    }

    if ((!fUnicode && !lpIMC.IsUnicode()) ||
        ( fUnicode &&  lpIMC.IsUnicode())   ) {
        /*
         * Composition string in input context is of ANSI style when fUnicode is FALSE.
         * Composition string in input context is of Unicode style when fUnicode is TRUE.
         */
        if (! dwCompLen) {
            // query required buffer size. not inculde \0.
            if (! fUnicode) {
                hr = _InputContext.GetCompositionString(lpCompStr, dwIndex, lpCopied, sizeof(BYTE));
            }
            else {
                switch (dwIndex) {
                    case GCS_COMPATTR:          // ANSI-only
                    case GCS_COMPREADATTR:      // ANSI-only
                    case GCS_COMPREADCLAUSE:    // ANSI-only
                    case GCS_RESULTCLAUSE:      // ANSI-only
                    case GCS_RESULTREADCLAUSE:  // ANSI-only
                    case GCS_COMPCLAUSE:        // ANSI-only
                        hr = _InputContext.GetCompositionString(lpCompStr, dwIndex, lpCopied, sizeof(BYTE));
                        break;
                    default:
                        hr = _InputContext.GetCompositionString(lpCompStr, dwIndex, lpCopied);
                        break;
                }
            }
        }
        else {
            hr = S_OK;
            switch (dwIndex) {
                case GCS_COMPSTR:
                case GCS_COMPREADSTR:
                case GCS_RESULTSTR:
                case GCS_RESULTREADSTR:
                    if (! fUnicode) {
                        CBCompString bstr(cp, lpCompStr, dwIndex);
                        if (bstr.ReadCompData() != 0) {
                            *lpCopied = (LONG)bstr.ReadCompData((CHAR*)lpBuf,
                                                          dwCompLen / sizeof(CHAR)) * sizeof(CHAR);
                        }
                    }
                    else {
                        CWCompString wstr(cp, lpCompStr, dwIndex);
                        if (wstr.ReadCompData() != 0) {
                            *lpCopied = (LONG)wstr.ReadCompData((WCHAR*)lpBuf,
                                                          dwCompLen / sizeof(WCHAR)) * sizeof(WCHAR);
                        }
                    }
                    break;
                case GCS_COMPATTR:          // ANSI-only
                case GCS_COMPREADATTR:      // ANSI-only
                    {
                        CBCompAttribute battr(cp, lpCompStr, dwIndex);
                        if (battr.ReadCompData() != 0) {
                            *lpCopied = (LONG)battr.ReadCompData((BYTE*)lpBuf,
                                                           dwCompLen / sizeof(BYTE)) * sizeof(CHAR);
                        }
                    }
                    break;
                case GCS_COMPREADCLAUSE:    // ANSI-only
                case GCS_RESULTCLAUSE:      // ANSI-only
                case GCS_RESULTREADCLAUSE:  // ANSI-only
                case GCS_COMPCLAUSE:        // ANSI-only
                    {
                        CBCompClause bclause(cp, lpCompStr, dwIndex);
                        if (bclause.ReadCompData() != 0) {
                            *lpCopied = (LONG)bclause.ReadCompData((DWORD*)lpBuf,
                                                             dwCompLen / sizeof(DWORD)) * sizeof(DWORD);
                        }
                    }
                    break;
                case GCS_CURSORPOS:
                case GCS_DELTASTART:
                    if (! fUnicode) {
                        CBCompCursorPos bpos(cp, lpCompStr, dwIndex);
                    }
                    else {
                        CWCompCursorPos wpos(cp, lpCompStr, dwIndex);
                    }
                    break;
                default:
                    hr = E_INVALIDARG;
                    *lpCopied = IMM_ERROR_GENERAL; // ala Win32
                    break;
            }
        }

        goto _exit;
    }

    /*
     * ANSI caller, Unicode input context/composition string when fUnicode is FALSE.
     * Unicode caller, ANSI input context/composition string when fUnicode is TRUE
     */
    hr = S_OK;
    switch (dwIndex) {
        case GCS_COMPSTR:
        case GCS_COMPREADSTR:
        case GCS_RESULTSTR:
        case GCS_RESULTREADSTR:
            if (! fUnicode) {
                /*
                 * Get ANSI string from Unicode composition string.
                 */
                CWCompString wstr(cp, lpCompStr, dwIndex);
                CBCompString bstr(cp, lpCompStr);
                if (wstr.ReadCompData() != 0) {
                    bstr = wstr;
                    *lpCopied = (LONG)bstr.ReadCompData((CHAR*)lpBuf,
                                                  dwCompLen / sizeof(CHAR)) * sizeof(CHAR);
                }
            }
            else {
                /*
                 * Get Unicode string from ANSI composition string.
                 */
                CBCompString bstr(cp, lpCompStr, dwIndex);
                CWCompString wstr(cp, lpCompStr);
                if (bstr.ReadCompData() != 0) {
                    wstr = bstr;
                    *lpCopied = (LONG)wstr.ReadCompData((WCHAR*)lpBuf,
                                                  dwCompLen / sizeof(WCHAR)) * sizeof(WCHAR);
                }
            }
            break;
        case GCS_COMPATTR:
        case GCS_COMPREADATTR:
            if (! fUnicode) {
                /*
                 * Get ANSI attribute from Unicode composition attribute.
                 */
                CWCompAttribute wattr(cp, lpCompStr, dwIndex);
                CBCompAttribute battr(cp, lpCompStr);
                if (wattr.ReadCompData() != 0 &&
                    wattr.m_wcompstr.ReadCompData() != 0) {
                    battr = wattr;
                    *lpCopied = (LONG)battr.ReadCompData((BYTE*)lpBuf,
                                                   dwCompLen / sizeof(BYTE)) * sizeof(BYTE);
                }
            }
            else {
                /*
                 * Get Unicode attribute from ANSI composition attribute.
                 */
                CBCompAttribute battr(cp, lpCompStr, dwIndex);
                CWCompAttribute wattr(cp, lpCompStr);
                if (battr.ReadCompData() != 0 &&
                    battr.m_bcompstr.ReadCompData() != 0) {
                    wattr = battr;
                    *lpCopied = (LONG)wattr.ReadCompData((BYTE*)lpBuf,
                                                   dwCompLen / sizeof(BYTE)) * sizeof(BYTE);
                }
            }
            break;
        case GCS_COMPREADCLAUSE:
        case GCS_RESULTCLAUSE:
        case GCS_RESULTREADCLAUSE:
        case GCS_COMPCLAUSE:
            if (! fUnicode) {
                /*
                 * Get ANSI clause from Unicode composition clause.
                 */
                CWCompClause wclause(cp, lpCompStr, dwIndex);
                CBCompClause bclause(cp, lpCompStr);
                if (wclause.ReadCompData() != 0 &&
                    wclause.m_wcompstr.ReadCompData() != 0) {
                    bclause = wclause;
                    *lpCopied = (LONG)bclause.ReadCompData((DWORD*)lpBuf,
                                                     dwCompLen / sizeof(DWORD)) * sizeof(DWORD);
                }
            }
            else {
                /*
                 * Get Unicode clause from ANSI composition clause.
                 */
                CBCompClause bclause(cp, lpCompStr, dwIndex);
                CWCompClause wclause(cp, lpCompStr);
                if (bclause.ReadCompData() != 0 &&
                    bclause.m_bcompstr.ReadCompData() != 0) {
                    wclause = bclause;
                    *lpCopied = (LONG)wclause.ReadCompData((DWORD*)lpBuf,
                                                     dwCompLen / sizeof(DWORD)) * sizeof(DWORD);
                }
            }
            break;
        case GCS_CURSORPOS:
        case GCS_DELTASTART:
            if (! fUnicode) {
                /*
                 * Get ANSI cursor/delta start position from Unicode composition string.
                 */
                CWCompCursorPos wpos(cp, lpCompStr, dwIndex);
                CBCompCursorPos bpos(cp, lpCompStr);
                if (wpos.ReadCompData() != 0 &&
                    wpos.m_wcompstr.ReadCompData() != 0) {
                    bpos = wpos;
                    *lpCopied = bpos.GetAt(0);
                }
            }
            else {
                /*
                 * Get Unicode cursor/delta start position from ANSI composition string.
                 */
                CBCompCursorPos bpos(cp, lpCompStr, dwIndex);
                CWCompCursorPos wpos(cp, lpCompStr);
                if (bpos.ReadCompData() != 0 &&
                    bpos.m_bcompstr.ReadCompData() != 0) {
                    wpos = bpos;
                    *lpCopied = wpos.GetAt(0);
                }
            }
            break;
        default:
            hr = E_INVALIDARG;
            *lpCopied = IMM_ERROR_GENERAL; // ala Win32
            break;
    }

_exit:
    if (fSwapGuidMapField) {
        lpCompStr->CompStr.dwCompAttrLen    = dwSwapLen;
        lpCompStr->CompStr.dwCompAttrOffset = dwSwapOffset;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Internal_SetCompositionString
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_Internal_SetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    LPVOID lpComp,
    DWORD dwCompLen,
    LPVOID lpRead,
    DWORD dwReadLen,
    BOOL fUnicode,
    BOOL fNeedAWConversion
    )
{
    HRESULT hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        CBCompString bCompStr(cp, hIMC, (CHAR*)lpComp, dwCompLen);
        CBCompString bCompReadStr(cp, hIMC, (CHAR*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   lpComp, dwCompLen,
                                                   lpRead, dwReadLen);
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CWCompString wCompStr(cp, hIMC);
            if (dwCompLen)
                wCompStr = bCompStr;

            CWCompString wCompReadStr(cp, hIMC);
            if (dwReadLen)
                wCompReadStr = bCompReadStr;

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompStr, (DWORD)(wCompStr.GetSize()),
                                                   wCompReadStr, (DWORD)(wCompReadStr.GetSize()));
        }
    }
    else {
        CWCompString wCompStr(cp, hIMC, (WCHAR*)lpComp, dwCompLen);
        CWCompString wCompReadStr(cp, hIMC, (WCHAR*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   lpComp, dwCompLen,
                                                   lpRead, dwReadLen);
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CBCompString bCompStr(cp, hIMC);
            if (dwCompLen)
                bCompStr = wCompStr;

            CBCompString bCompReadStr(cp, hIMC);
            if (dwReadLen)
                bCompReadStr = wCompReadStr;

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompStr, (DWORD)(bCompStr.GetSize()),
                                                   bCompReadStr, (DWORD)(bCompReadStr.GetSize()));
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Internal_SetCompositionAttribute
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_Internal_SetCompositionAttribute(
    HIMC hIMC,
    DWORD dwIndex,
    LPVOID lpComp,
    DWORD dwCompLen,
    LPVOID lpRead,
    DWORD dwReadLen,
    BOOL fUnicode,
    BOOL fNeedAWConversion
    )
{
    HRESULT hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        CBCompAttribute bCompAttr(cp, hIMC, (BYTE*)lpComp, dwCompLen);
        CBCompAttribute bCompReadAttr(cp, hIMC, (BYTE*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CBCompAttribute himc_battr(cp, lpCompStr, GCS_COMPATTR);
                CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(hr=CheckAttribute(bCompAttr, himc_battr, himc_bclause)))
                    return hr;

                CBCompAttribute himc_breadattr(cp, lpCompStr, GCS_COMPREADATTR);
                CBCompClause    himc_breadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(hr=CheckAttribute(bCompReadAttr, himc_breadattr, himc_breadclause)))
                    return hr;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompAttr, (DWORD)(bCompAttr.GetSize()),
                                                   bCompReadAttr, (DWORD)(bCompReadAttr.GetSize()));
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CWCompAttribute wCompAttr(cp, hIMC);
            CWCompAttribute wCompReadAttr(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    wCompAttr = bCompAttr;

                    CWCompAttribute himc_wattr(cp, lpCompStr, GCS_COMPATTR);
                    CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckAttribute(wCompAttr, himc_wattr, himc_wclause)))
                        return hr;
                }

                if (dwReadLen) {
                    wCompReadAttr = bCompReadAttr;

                    CWCompAttribute himc_wreadattr(cp, lpCompStr, GCS_COMPREADATTR);
                    CWCompClause    himc_wreadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckAttribute(wCompReadAttr, himc_wreadattr, himc_wreadclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompAttr, (DWORD)(wCompAttr.GetSize()),
                                                   wCompReadAttr, (DWORD)(wCompReadAttr.GetSize()));
        }
    }
    else {
        CWCompAttribute wCompAttr(cp, hIMC, (BYTE*)lpComp, dwCompLen);
        CWCompAttribute wCompReadAttr(cp, hIMC, (BYTE*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CWCompAttribute himc_wattr(cp, lpCompStr, GCS_COMPATTR);
                CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(hr=CheckAttribute(wCompAttr, himc_wattr, himc_wclause)))
                    return hr;

                CWCompAttribute himc_wreadattr(cp, lpCompStr, GCS_COMPREADATTR);
                CWCompClause    himc_wreadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(hr=CheckAttribute(wCompReadAttr, himc_wreadattr, himc_wreadclause)))
                    return hr;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompAttr, (DWORD)(wCompAttr.GetSize()),
                                                   wCompReadAttr, (DWORD)(wCompReadAttr.GetSize()));
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CBCompAttribute bCompAttr(cp, hIMC);
            CBCompAttribute bCompReadAttr(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    bCompAttr = wCompAttr;

                    CBCompAttribute himc_battr(cp, lpCompStr, GCS_COMPATTR);
                    CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckAttribute(bCompAttr, himc_battr, himc_bclause)))
                        return hr;
                }

                if (dwReadLen) {
                    bCompReadAttr = wCompReadAttr;

                    CBCompAttribute himc_breadattr(cp, lpCompStr, GCS_COMPREADATTR);
                    CBCompClause    himc_breadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckAttribute(bCompReadAttr, himc_breadattr, himc_breadclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompAttr, (DWORD)(bCompAttr.GetSize()),
                                                   bCompReadAttr, (DWORD)(bCompReadAttr.GetSize()));
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// _Internal_SetCompositionClause
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_Internal_SetCompositionClause(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen,
    IN BOOL fUnicode,
    IN BOOL fNeedAWConversion
    )
{
    HRESULT hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        CBCompClause bCompClause(cp, hIMC, (DWORD*)lpComp, dwCompLen);
        CBCompClause bCompReadClause(cp, hIMC, (DWORD*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CBCompClause himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(hr=CheckClause(bCompClause, himc_bclause)))
                    return hr;

                CBCompClause himc_breadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(hr=CheckClause(bCompReadClause, himc_breadclause)))
                    return hr;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompClause, (DWORD)(bCompClause.GetSize()),
                                                   bCompReadClause, (DWORD)(bCompReadClause.GetSize()));
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CWCompClause wCompClause(cp, hIMC);
            CWCompClause wCompReadClause(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    wCompClause = bCompClause;

                    CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckClause(wCompClause, himc_wclause)))
                        return hr;
                }

                if (dwReadLen) {
                    wCompReadClause = bCompReadClause;

                    CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckClause(wCompReadClause, himc_wclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompClause, (DWORD)(wCompClause.GetSize()),
                                                   wCompReadClause, (DWORD)(wCompReadClause.GetSize()));
        }
    }
    else {
        CWCompClause wCompClause(cp, hIMC, (DWORD*)lpComp, dwCompLen);
        CWCompClause wCompReadClause(cp, hIMC, (DWORD*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CWCompClause himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(CheckClause(wCompClause, himc_wclause)))
                    return E_FAIL;

                CWCompClause himc_wreadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(CheckClause(wCompReadClause, himc_wreadclause)))
                    return E_FAIL;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompClause, (DWORD)(wCompClause.GetSize()),
                                                   wCompReadClause, (DWORD)(wCompReadClause.GetSize()));
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CBCompClause bCompClause(cp, hIMC);
            CBCompClause bCompReadClause(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    bCompClause = wCompClause;

                    CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckClause(bCompClause, himc_bclause)))
                        return hr;
                }

                if (dwReadLen) {
                    bCompReadClause = wCompReadClause;

                    CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckClause(bCompReadClause, himc_bclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompClause, (DWORD)(bCompClause.GetSize()),
                                                   bCompReadClause, (DWORD)(bCompReadClause.GetSize()));
        }
    }

    return hr;
}

HRESULT
CActiveIMM::_Internal_ReconvertString(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen,
    IN BOOL fUnicode,
    IN BOOL fNeedAWConversion,
    OUT LRESULT* plResult           // = NULL
    )
{
    HRESULT hr;
    LPVOID lpOrgComp = lpComp;
    LPVOID lpOrgRead = lpRead;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    HWND hWnd = NULL;
    if (dwIndex == IMR_CONFIRMRECONVERTSTRING ||
        dwIndex == IMR_RECONVERTSTRING ||
        dwIndex == IMR_DOCUMENTFEED) {
        DIMM_IMCLock imc(hIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        hWnd = imc->hWnd;
    }

    if (! fUnicode) {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       lpComp, dwCompLen,
                                                       lpRead, dwReadLen);
            }
            else {
                *plResult = ::SendMessageA(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)lpComp);
            }
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CBReconvertString bReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
            CWReconvertString wReconvStr(cp, hIMC);
            if (bReconvStr.m_bcompstr.ReadCompData()) {
                wReconvStr = bReconvStr;
            }

            CBReconvertString bReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
            CWReconvertString wReconvReadStr(cp, hIMC);
            if (bReconvReadStr.m_bcompstr.ReadCompData()) {
                wReconvReadStr = bReconvReadStr;
            }

            BOOL fCompMem = FALSE, fReadMem = FALSE;
            LPRECONVERTSTRING _lpComp = NULL;
            DWORD _dwCompLen = wReconvStr.ReadCompData();
            if (_dwCompLen) {
                _lpComp = (LPRECONVERTSTRING) new BYTE[ _dwCompLen ];
                if (_lpComp) {
                    fCompMem = TRUE;
                    wReconvStr.ReadCompData(_lpComp, _dwCompLen);
                }
            }
            LPRECONVERTSTRING _lpRead = NULL;
            DWORD _dwReadLen = wReconvReadStr.ReadCompData();
            if (_dwReadLen) {
                _lpRead = (LPRECONVERTSTRING) new BYTE[ _dwReadLen ];
                if (_lpRead) {
                    fReadMem = TRUE;
                    wReconvStr.ReadCompData(_lpRead, _dwReadLen);
                }
            }

            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       _lpComp, _dwCompLen,
                                                       _lpRead, _dwReadLen);
            }
            else {
                *plResult = ::SendMessageA(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)_lpComp);
            }

            if (fCompMem)
                delete [] _lpComp;
            if (fReadMem)
                delete [] _lpRead;
        }
    }
    else {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       lpComp, dwCompLen,
                                                       lpRead, dwReadLen);
            }
            else {
                *plResult = ::SendMessageW(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)lpComp);
            }
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CWReconvertString wReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
            CBReconvertString bReconvStr(cp, hIMC);
            if (wReconvStr.m_wcompstr.ReadCompData()) {
                bReconvStr = wReconvStr;
            }

            CWReconvertString wReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
            CBReconvertString bReconvReadStr(cp, hIMC);
            if (wReconvReadStr.m_wcompstr.ReadCompData()) {
                bReconvReadStr = wReconvReadStr;
            }

            BOOL fCompMem = FALSE, fReadMem = FALSE;
            LPRECONVERTSTRING _lpComp = NULL;
            DWORD _dwCompLen = bReconvStr.ReadCompData();
            if (_dwCompLen) {
                _lpComp = (LPRECONVERTSTRING) new BYTE[ _dwCompLen ];
                if (_lpComp) {
                    fCompMem = TRUE;
                    bReconvStr.ReadCompData(_lpComp, _dwCompLen);
                }
            }
            LPRECONVERTSTRING _lpRead = NULL;
            DWORD _dwReadLen = bReconvReadStr.ReadCompData();
            if (_dwReadLen) {
                _lpRead = (LPRECONVERTSTRING) new BYTE[ _dwReadLen ];
                if (_lpRead) {
                    fReadMem = TRUE;
                    bReconvStr.ReadCompData(_lpRead, _dwReadLen);
                }
            }

            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       _lpComp, _dwCompLen,
                                                       _lpRead, _dwReadLen);
            }
            else {
                *plResult = ::SendMessageW(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)_lpComp);
            }

            if (fCompMem)
                delete [] _lpComp;
            if (fReadMem)
                delete [] _lpRead;
        }
    }

    /*
     * Check if need ANSI/Unicode back conversion
     */
    if (fNeedAWConversion) {
        switch (dwIndex) {
            case SCS_QUERYRECONVERTSTRING:
            case IMR_RECONVERTSTRING:
            case IMR_DOCUMENTFEED:
                if (lpOrgComp) {
                    if (! fUnicode) {
                        CWReconvertString wReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
                        CBReconvertString bReconvStr(cp, hIMC);
                        if (wReconvStr.m_wcompstr.ReadCompData()) {
                            bReconvStr = wReconvStr;
                            bReconvStr.m_bcompstr.ReadCompData((CHAR*)lpOrgComp, (DWORD)bReconvStr.m_bcompstr.ReadCompData());
                        }
                    }
                    else {
                        CBReconvertString bReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
                        CWReconvertString wReconvStr(cp, hIMC);
                        if (bReconvStr.m_bcompstr.ReadCompData()) {
                            wReconvStr = bReconvStr;
                            wReconvStr.m_wcompstr.ReadCompData((WCHAR*)lpOrgComp, (DWORD)wReconvStr.m_wcompstr.ReadCompData());
                        }
                    }
                }
                if (lpOrgRead) {
                    if (! fUnicode) {
                        CWReconvertString wReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
                        CBReconvertString bReconvReadStr(cp, hIMC);
                        if (wReconvReadStr.m_wcompstr.ReadCompData()) {
                            bReconvReadStr = wReconvReadStr;
                            bReconvReadStr.m_bcompstr.ReadCompData((CHAR*)lpOrgComp, (DWORD)bReconvReadStr.m_bcompstr.ReadCompData());
                        }
                    }
                    else {
                        CBReconvertString bReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
                        CWReconvertString wReconvReadStr(cp, hIMC);
                        if (bReconvReadStr.m_bcompstr.ReadCompData()) {
                            wReconvReadStr = bReconvReadStr;
                            wReconvReadStr.m_wcompstr.ReadCompData((WCHAR*)lpOrgComp, (DWORD)wReconvReadStr.m_wcompstr.ReadCompData());
                        }
                    }
                }
                break;
        }
    }

    return hr;
}

HRESULT
CActiveIMM::_Internal_CompositionFont(
    DIMM_IMCLock& imc,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    BOOL fNeedAWConversion,
    LRESULT* plResult
    )
{
    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            LOGFONTA LogFontA;
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)&LogFontA);
            LFontAtoLFontW(&LogFontA, (LOGFONTW*)lParam, cp);
        }
    }
    else {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            LOGFONTW LogFontW;
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)&LogFontW);
            LFontWtoLFontA(&LogFontW, (LOGFONTA*)lParam, cp);
        }
    }

    return S_OK;
}

HRESULT
CActiveIMM::_Internal_QueryCharPosition(
    DIMM_IMCLock& imc,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    BOOL fNeedAWConversion,
    LRESULT* plResult
    )
{
    if (! fUnicode) {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * ANSI caller, Receiver Unicode application.
             */
            IMECHARPOSITION* ipA = (IMECHARPOSITION*)lParam;
            DWORD dwSaveCharPos = ipA->dwCharPos;
            _GetCompositionString((HIMC)imc, GCS_CURSORPOS, 0, (LONG*)&ipA->dwCharPos, NULL, TRUE);
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)ipA);
            ipA->dwCharPos = dwSaveCharPos;
        }
    }
    else {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * Unicode caller, Receiver ANSI application.
             */
            IMECHARPOSITION* ipW = (IMECHARPOSITION*)lParam;
            DWORD dwSaveCharPos = ipW->dwCharPos;
            _GetCompositionString((HIMC)imc, GCS_CURSORPOS, 0, (LONG*)&ipW->dwCharPos, NULL, FALSE);
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)ipW);
            ipW->dwCharPos = dwSaveCharPos;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _SetCompositionString
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_SetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    LPVOID lpComp,
    DWORD dwCompLen,
    LPVOID lpRead,
    DWORD dwReadLen,
    BOOL fUnicode
    )
{
    HRESULT hr;
    BOOL fNeedAWConversion;
    BOOL fIMCUnicode;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    TraceMsg(TF_API, "CActiveIMM::SetCompositionString");

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
        if (FAILED(hr = lpCompStr.GetResult()))
            return hr;

        if (lpCompStr->CompStr.dwSize < sizeof(COMPOSITIONSTRING))
            return E_FAIL;

        fIMCUnicode = lpIMC.IsUnicode();
    }

    /*
     * Check if we need Unicode conversion
     */
    if ((!fUnicode && !fIMCUnicode) ||
        ( fUnicode &&  fIMCUnicode)   ) {
        /*
         * No ANSI conversion needed when fUnicode is FALSE.
         * No Unicode conversion needed when fUnicode is TRUE.
         */
        fNeedAWConversion = FALSE;
    }
    else {
        fNeedAWConversion = TRUE;
    }

    switch (dwIndex) {
        case SCS_SETSTR:
            hr = _Internal_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            break;
        case SCS_CHANGEATTR:
            hr = _Internal_SetCompositionAttribute(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            break;
        case SCS_CHANGECLAUSE:
            hr = _Internal_SetCompositionClause(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            break;
        case SCS_SETRECONVERTSTRING:
        case SCS_QUERYRECONVERTSTRING:

            if (_GetIMEProperty(PROP_SCS_CAPS) & SCS_CAP_SETRECONVERTSTRING) {
                hr = _Internal_ReconvertString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            }
            else if (ptls != NULL) {
                LANGID langid;

                ptls->pAImeProfile->GetLangId(&langid);

                if (PRIMARYLANGID(langid) == LANG_KOREAN) {
                    hr = _Internal_ReconvertString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
                }
            }

            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}


void
CActiveIMM::LFontAtoLFontW(
    LPLOGFONTA lpLogFontA,
    LPLOGFONTW lpLogFontW,
    UINT uCodePage
    )
{
    INT i;

    memcpy(lpLogFontW, lpLogFontA, sizeof(LOGFONTA)-LF_FACESIZE);

    i = MultiByteToWideChar(uCodePage,            // hIMC's code page
                            MB_PRECOMPOSED,
                            lpLogFontA->lfFaceName,
                            strlen(lpLogFontA->lfFaceName),
                            lpLogFontW->lfFaceName,
                            LF_FACESIZE);
    lpLogFontW->lfFaceName[i] = L'\0';
    return;
}

void
CActiveIMM::LFontWtoLFontA(
    LPLOGFONTW lpLogFontW,
    LPLOGFONTA lpLogFontA,
    UINT uCodePage
    )
{
    INT i;

    memcpy(lpLogFontA, lpLogFontW, sizeof(LOGFONTA)-LF_FACESIZE);

    i = WideCharToMultiByte(uCodePage,            // hIMC's code page
                            0,
                            lpLogFontW->lfFaceName,
                            wcslen(lpLogFontW->lfFaceName),
                            lpLogFontA->lfFaceName,
                            LF_FACESIZE-1,
                            NULL,
                            NULL);
    lpLogFontA->lfFaceName[i] = '\0';
    return;
}

HRESULT
CActiveIMM::_GetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    IN BOOL fUnicode
    )

/*++

    AIMM Composition Font API Methods

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionFont");

    DWORD dwProcessId;
    BOOL fImcUnicode;
    UINT uCodePage;

    if (FAILED(_pActiveIME->GetCodePageA(&uCodePage)))
        return E_FAIL;

    if (!_InputContext.ContextLookup(hIMC, &dwProcessId, &fImcUnicode)) {
        TraceMsg(TF_WARNING, "CActiveIMM::_GetCompositionFont: Invalid hIMC %lx", hIMC);
        return E_FAIL;
    }

    if (fUnicode) {
        if (! fImcUnicode) {
            LOGFONTA LogFontA, *pLogFontA;
            pLogFontA = &LogFontA;
            if (SUCCEEDED(_GetCompositionFont(hIMC, (LOGFONTAW*)pLogFontA, FALSE))) {
                LFontAtoLFontW(pLogFontA, &lplf->W, uCodePage);
                return S_OK;
            }

            return E_FAIL;
        }
    }
    else {
        if (fImcUnicode) {
            LOGFONTW LogFontW, *pLogFontW;
            pLogFontW = &LogFontW;
            if (SUCCEEDED(_GetCompositionFont(hIMC, (LOGFONTAW*)pLogFontW, TRUE))) {
                LFontWtoLFontA(pLogFontW, &lplf->A, uCodePage);
                return S_OK;
            }

            return E_FAIL;
        }
    }

    HRESULT hr;
    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    return _InputContext.GetCompositionFont(lpIMC, lplf, fUnicode);
}

HRESULT
CActiveIMM::_SetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    IN BOOL fUnicode
    )

/*++

    AIMM Composition Font API Methods

--*/

{
    HRESULT hr;
    HWND hWnd;

    TraceMsg(TF_API, "CActiveIMM::SetCompositionFont");

    DWORD dwProcessId;
    BOOL fImcUnicode;
    UINT uCodePage;

    if (FAILED(_pActiveIME->GetCodePageA(&uCodePage)))
        return E_FAIL;

    if (!_InputContext.ContextLookup(hIMC, &dwProcessId, &fImcUnicode)) {
        TraceMsg(TF_WARNING, "CActiveIMM::_SetCompositionFont: Invalid hIMC %lx", hIMC);
        return E_FAIL;
    }

    if (fUnicode) {
        if (! fImcUnicode) {
            LOGFONTA LogFontA, *pLogFontA;
            pLogFontA = &LogFontA;
            LFontWtoLFontA(&lplf->W, pLogFontA, uCodePage);

            return _SetCompositionFont(hIMC, (LOGFONTAW*)pLogFontA, FALSE);
        }
    }
    else {
        if (fImcUnicode) {
            LOGFONTW LogFontW, *pLogFontW;
            pLogFontW = &LogFontW;
            LFontAtoLFontW(&lplf->A, pLogFontW, uCodePage);

            return _SetCompositionFont(hIMC, (LOGFONTAW*)pLogFontW, TRUE);
        }
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetCompositionFont(lpIMC, lplf, fUnicode);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of composition font.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETCOMPOSITIONFONT,
                   IMN_SETCOMPOSITIONFONT, 0L);

    return hr;
}

HRESULT
CActiveIMM::_RequestMessage(
    IN HIMC hIMC,
    IN WPARAM wParam,
    IN LPARAM lParam,
    OUT LRESULT *plResult,
    IN BOOL fUnicode
    )

/*++

    AIMM Request Message API Methods

--*/

{
    TraceMsg(TF_API, "CActiveIMM::RequestMessage");

    HRESULT hr;

    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    //
    // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
    // Any string data doesn't convert between ASCII <--> Unicode.
    // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
    // If ASCII wnd proc, then returns ASCII string.
    // Otherwise if Unicode wnd proc, returns Unicode string.
    //
    BOOL bUnicodeTarget = ::IsWindowUnicode(imc->hWnd);

    BOOL fNeedAWConversion;

    /*
     * Check if we need Unicode conversion
     */
    if ((!fUnicode && !bUnicodeTarget) ||
        ( fUnicode &&  bUnicodeTarget)   ) {
        /*
         * No ANSI conversion needed when fUnicode is FALSE.
         * No Unicode conversion needed when fUnicode is TRUE.
         */
        fNeedAWConversion = FALSE;
    }
    else {
        fNeedAWConversion = TRUE;
    }

    switch (wParam) {
        case IMR_CONFIRMRECONVERTSTRING:
        case IMR_RECONVERTSTRING:
        case IMR_DOCUMENTFEED:
            hr = _Internal_ReconvertString(hIMC,
                                           (DWORD)wParam,
                                           (LPVOID)lParam, ((LPRECONVERTSTRING)lParam)->dwSize,
                                           NULL, 0,
                                           fUnicode, fNeedAWConversion,
                                           plResult);
            break;
        case IMR_COMPOSITIONFONT:
            hr = _Internal_CompositionFont(imc,
                                           wParam, lParam,
                                           fUnicode, fNeedAWConversion,
                                           plResult);
            break;
        case IMR_QUERYCHARPOSITION:
            hr = _Internal_QueryCharPosition(imc,
                                             wParam, lParam,
                                             fUnicode, fNeedAWConversion,
                                             plResult);
            break;
    }

    return hr;
}



/*
 * EnumInputContext callback
 */
/* static */
BOOL CALLBACK CActiveIMM::_SelectContextProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    SCE *psce = (SCE *)lParam;
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    BOOL bIsRealIme_SelKL;
    BOOL bIsRealIme_UnSelKL;

    if (bIsRealIme_SelKL = _this->_IsRealIme(psce->hSelKL))
        return FALSE;

    bIsRealIme_UnSelKL = _this->_IsRealIme(psce->hUnSelKL);

    /*
     * Reinitialize the input context for the selected layout.
     */
    DWORD dwPrivateSize = _this->_GetIMEProperty(PROP_PRIVATE_DATA_SIZE);
    _this->_InputContext.UpdateInputContext(hIMC, dwPrivateSize);

    /*
     * Select the input context
     */
    _this->_AImeSelect(hIMC, TRUE, bIsRealIme_SelKL, bIsRealIme_UnSelKL);

    return TRUE;
}

/* static */
BOOL CALLBACK CActiveIMM::_UnSelectContextProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    SCE *psce = (SCE *)lParam;
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    BOOL bIsRealIme_SelKL;
    BOOL bIsRealIme_UnSelKL;

    if (bIsRealIme_UnSelKL = _this->_IsRealIme(psce->hUnSelKL))
        return FALSE;

    bIsRealIme_SelKL = _this->_IsRealIme(psce->hSelKL);

    _this->_AImeSelect(hIMC, FALSE, bIsRealIme_SelKL, bIsRealIme_UnSelKL);

    return TRUE;
}

/* static */
BOOL CALLBACK CActiveIMM::_NotifyIMEProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    if (_this->_IsRealIme())
        return FALSE;

    _this->_AImeNotifyIME(hIMC, NI_COMPOSITIONSTR, (DWORD)lParam, 0);

    return TRUE;
}

#ifdef UNSELECTCHECK
/* static */
BOOL CALLBACK CActiveIMM::_UnSelectCheckProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    _this->_AImeUnSelectCheck(hIMC);

    return TRUE;
}
#endif UNSELECTCHECK

/* static */
BOOL CALLBACK CActiveIMM::_EnumContextProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    CContextList* _hIMC_List = (CContextList*)lParam;
    if (_hIMC_List) {
        CContextList::CLIENT_IMC_FLAG client_flag = CContextList::IMCF_NONE;
        _hIMC_List->SetAt(hIMC, client_flag);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\aime_hook.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime_hook.cpp

Abstract:

    This file implements the Active IME for hook (Cicero)  lass.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"
#include "globals.h"

HRESULT
CActiveIMM::_ProcessKey(
    WPARAM *pwParam,
    LPARAM *plParam,
    BOOL fNoMsgPump
    )

/*+++

Return Value:

    Returns S_OK, KeyboardHook doesn't call CallNextHookEx. This means this key code eaten by dimm.
    Returns S_FALSE, KeyboardHook calls CallNextHookEx.

---*/

{
    HIMC hActiveIMC;
    BYTE abKbdState[256];
    WPARAM wParam;
    LPARAM lParam;
    DWORD fdwProperty;

    wParam = *pwParam; // deref for perf
    lParam = *plParam;

    hActiveIMC = _GetActiveContext();

    HRESULT hr;

    DIMM_IMCLock pIMC(hActiveIMC);
    if (FAILED(hr=pIMC.GetResult())) {
        return hr;
    }

#if 0
    //
    // Disable code for the Office 10 PPT (office bug #110692).
    // But, I never remove this code. because this is very IMPORTANT with IE4.
    //

    HWND hCaptureWnd;

    if (fNoMsgPump &&
        wParam != VK_PROCESSKEY && // korean imes will get VK_PROCESSKEY events after mouse events
        (hCaptureWnd = GetCapture()))
    {
        if (_hFocusWnd == hCaptureWnd)
        {
            // This is a workaround for a limitation of using a keyboard hook proc.  Normally if trident's
            // server window has the mouse capture it insures TranslateMessage isn't called (by returning
            // S_OK to an OLE pre-TranslateAccelerator method).  Thus no
            // WM_IME_*COMPOSITION and no WM_CHAR.  For bug 1174, we were sending WM_IME_STARTCOMPOSITION
            // when trident had the mouse capture.  It ignored the message in this state and then barfed
            // on later WM_IME_COMPOSITIONS.
            //
            // This code will eat all keystrokes destined for an aime when the focus window has the capture.
            // This is not ideal, but hopefully reasonable.  One more reason to use OnTranslateMessage.
            //
            *pwParam = 0; // eat the key!
            fRet = TRUE;
            return fRet;
        }

        // consider: this I think is outlook 98 specific, but we no longer
        // support outlook98 w/ IActiveIMMAppTrident4x
        if (hCaptureWnd != _hFocusWnd /* && !IsAIMEWnd(hCaptureWnd) */ )
            return fRet;
    }
#endif

#if 0
    if (_fMenuSelected)
    {
        // we check for KF_MENUMODE below for robustness, but that won't
        // catch the case where someone left alts to highlight "File" etc
        // then types while a composition string is in progress
        return S_FALSE;
    }
#endif

#if 0
    #define SCANCODE_ALTDN_MASK   (0x00ff0000 | ((DWORD)KF_ALTDOWN << 16))

    // consider: technically we can put this off a little
    // but it's probably worth it to leave the translation here in case we change
    // something that affects further tests
    if (pid->uCodePage == 949)
    {
        BOOL fExt = HIWORD(lParam) & KF_EXTENDED;

        // translate us 101 -> korean specific keys

        if (wParam == VK_RCONTROL || (wParam == VK_CONTROL && fExt))
        {
            // map right ctl to VK_HANJA
            wParam = VK_HANJA;
        }
        else if (wParam == VK_RMENU || (wParam == VK_MENU && fExt))
        {
            // map right alt to VK_HANGUL
            wParam = VK_HANGUL;
            lParam &= ~SCANCODE_ALTDN_MASK;
        }
        else if (((lParam >> 16) & 0xff) == 0xd && (HIWORD(lParam) & KF_ALTDOWN) && !fExt)
        {
            // map left alt-= and left alt-+ to VK_JUNJA
            // note we're assuming a us 101 qwerty layout above, which is correct currently
            wParam = VK_JUNJA;
            lParam &= ~SCANCODE_ALTDN_MASK;
        }
        *pwParam = wParam;
        *plParam = lParam;
    }
#endif

    if (!GetKeyboardState(abKbdState))
        return S_FALSE;

    _KbdTouchUp(abKbdState, wParam, lParam);

    fdwProperty = _GetIMEProperty(PROP_IME_PROPERTY);

    if ((HIWORD(lParam) & KF_MENUMODE) ||
        ((HIWORD(lParam) & KF_UP) && (fdwProperty & IME_PROP_IGNORE_UPKEYS)) ||
        ((HIWORD(lParam) & KF_ALTDOWN) && !(fdwProperty & IME_PROP_NEED_ALTKEY)))
    {
        return S_FALSE;
    }

    hr = _pActiveIME->ProcessKey(hActiveIMC, (UINT)wParam, (DWORD)lParam, abKbdState);

    if (hr == S_OK && !fNoMsgPump)
    {
#if 0
        // save the key the ime wants to eat in case the app is interested
        pPIMC->fSavedVKey = TRUE;
        pPIMC->uSavedVKey = wParam & 0xff;
#endif

        PostMessage(_hFocusWnd, (HIWORD(lParam) & KF_UP) ? WM_KEYUP : WM_KEYDOWN, VK_PROCESSKEY, lParam);
    }

    return hr;
}


const DWORD TRANSMSGCOUNT = 256;

HRESULT
CActiveIMM::_ToAsciiEx(
    WPARAM wParam,
    LPARAM lParam
    )

/*+++

Return Value:

    Returns S_OK, KeyboardHook doesn't call CallNextHookEx. This means this key code eaten by dimm.
    Returns S_FALSE, KeyboardHook calls CallNextHookEx.

---*/

{
    BYTE abKbdState[256];
    UINT uVirKey;

    HRESULT hr;

    HIMC hActiveIMC = _GetActiveContext();

    DIMM_IMCLock lpIMC(hActiveIMC);
    if (FAILED(hr=lpIMC.GetResult())) {
        return hr;
    }

#if 0
    // clear the saved virtual key that corresponded to wParam
    pPIMC->fSavedVKey = FALSE;
#endif

    if (!GetKeyboardState(abKbdState))
        return S_FALSE;

    _KbdTouchUp(abKbdState, wParam, lParam);

    uVirKey = (UINT)wParam & 0xffff;

    DWORD fdwProperty = _GetIMEProperty(PROP_IME_PROPERTY);

    if (fdwProperty & IME_PROP_KBD_CHAR_FIRST) {

        HKL hKL = NULL;
        _GetKeyboardLayout(&hKL);

        WCHAR wc = 0;
        if (IsOnNT()) {
            Assert(g_pfnToUnicodeEx);
            if (g_pfnToUnicodeEx(uVirKey,                  // virtual-key code
                                 WORD(lParam >> 16),       // scan code
                                 abKbdState,               // key-state array
                                 &wc, 1,                   // translated key buffer, size
                                 0,                        // function option
                                 hKL) != 1)
            {
                wc = 0;
            }
        }
        else {
            WORD wChar;

            if (::ToAsciiEx(uVirKey,
                            (UINT)((lParam >> 16) & 0xffff),
                            abKbdState,
                            &wChar, 0,
                            hKL) == 1)
            {
                UINT uCodePage;
                _pActiveIME->GetCodePageA(&uCodePage);
                if (MultiByteToWideChar(uCodePage, 0, (char *)&wChar, 1, &wc, 1) != 1) {
                    wc = 0;
                }
            }
        }
        if (wc) {
            // ime wants translated char in high word of tae uVirKey param
            uVirKey |= ((DWORD)wc << 16);
        }
    }


    UINT  cMsg;
    DWORD dwSize = FIELD_OFFSET(TRANSMSGLIST, TransMsg)
                 + TRANSMSGCOUNT * sizeof(TRANSMSG);

    LPTRANSMSGLIST lpTransMsgList = (LPTRANSMSGLIST) new BYTE[dwSize];
    if (lpTransMsgList == NULL)
        return S_FALSE;

    lpTransMsgList->uMsgCount = TRANSMSGCOUNT;

    hr = S_FALSE;

    if (SUCCEEDED(hr=_pActiveIME->ToAsciiEx(uVirKey,             // virtual key code to be translated
                                                                 // HIWORD(uVirKey) : if IME_PROP_KBD_CHAR_FIRST property, then hiword is translated char code of VKey.
                                                                 // LOWORD(uVirKey) : Virtual Key code.
                                            HIWORD(lParam),      // hardware scan code of the key
                                            abKbdState,          // 256-byte array of keyboard status
                                            0,                   // active menu flag
                                            hActiveIMC,          // handle of the input context
                                            (DWORD*)lpTransMsgList,      // receives the translated result
                                            &cMsg))              // receives the number of messages
       ) {
        if (cMsg > TRANSMSGCOUNT) {

            //
            // The message buffer is not big enough. IME put messages
            // into hMsgBuf in the input context.
            //

            DIMM_IMCCLock<TRANSMSG> pdw(lpIMC->hMsgBuf);
            if (pdw.Valid()) {
                _AimmPostMessage(_hFocusWnd,
                                 cMsg,
                                 pdw,
                                 lpIMC);
            }

        }
        else if (cMsg > 0) {
            _AimmPostMessage(_hFocusWnd,
                             cMsg,
                             &lpTransMsgList->TransMsg[0],
                             lpIMC);
        }
    }

    delete [] lpTransMsgList;

    return hr;
}

void
CActiveIMM::_KbdTouchUp(
    BYTE *abKbdState,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // HACK!
    // win95 bug: VK_L*/VK_R* aren't being set...by any of the key state apis
    // consider: this needs to be fully investigated, instead of this incorrect hack,
    // which among other things is biased towards wParam
    //
    // Probably what's happening is GetKeyboardState is syncronous with the removal of
    // kbd msgs from the queue, so we're seeing the state at the last kbd msg.
    // Need to use async api.

    if (!IsOnNT())
    {
        switch (wParam)
        {
            case VK_CONTROL:
            case VK_MENU:
                if (HIWORD(lParam) & KF_EXTENDED)
                {
                    abKbdState[VK_RMENU] = abKbdState[VK_MENU];
                    abKbdState[VK_RCONTROL] = abKbdState[VK_CONTROL];
                }
                else
                {
                    abKbdState[VK_LMENU] = abKbdState[VK_MENU];
                    abKbdState[VK_LCONTROL] = abKbdState[VK_CONTROL];
                }
                break;
            case VK_SHIFT:
                if ((lParam & 0x00ff0000) == 0x002a0000) // scan code 0x2a == lshift, 0x36 == rshift
                {
                    abKbdState[VK_LSHIFT] = abKbdState[VK_SHIFT];
                }
                else
                {
                    abKbdState[VK_RSHIFT] = abKbdState[VK_SHIFT];
                }
                break;
        }
    }
}

/* static */
#if 0
LRESULT CALLBACK CActiveIMM::_GetMsgProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    /*
     * Hook
     *
     * Check IsRealIme() when receive WM_SETFOCUS/WM_KILLFOCUS and g_msgSetFocus.
     * We need call GetTeb()->SetFocusWindow() method when receive WM_SETFOCUS.
     */
    MSG *pmsg;
    UINT uMsg;

    pmsg = (MSG *)lParam;
    uMsg = pmsg->message;

    if (nCode == HC_ACTION &&
        (wParam & PM_REMOVE))  // bug 29656: sometimes w/ word wParam is set to PM_REMOVE | PM_NOYIELD
                               // PM_NOYIELD is meaningless in win32 and sould be ignored
    {
        if (uMsg == WM_SETFOCUS ||
            uMsg == WM_KILLFOCUS ||
            uMsg == g_msgSetFocus   )
        {
            _this->_OnFocusMessage(uMsg, pmsg->hwnd, pmsg->wParam, pmsg->lParam, _this->_IsRealIme());
        }
#if 0
        else if (uMsg == WM_MENUSELECT)
        {
            // we don't want to feed an ime keystrokes during menu operations
            _this->_fMenuSelected = (HIWORD(pmsg->wParam) != 0xffff || (HMENU)pmsg->lParam != 0);
        }
#endif
    }

    return CallNextHookEx(_this->_hHook[TH_GETMSG], nCode, wParam, lParam);
}
#endif

/*
 * Shell Hook
 */


#if 0
LRESULT
CCiceroIME::ShellHook(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CTeb* _pThread = GetTeb();

    Assert(!IsOnFE()); // only need this hook on non-fe (on fe trap WM_IME_SELECT)

    switch (nCode)
    {
        case HSHELL_LANGUAGE:
            // we need to deactivate any running aime now, before the thread hkl changes
            if (lParam && /* pTS->pid && */ GetIMEKeyboardLayout() != (HKL)lParam)
            {
                TraceMsg(TF_GENERAL, "_ShellProc (%x) shutting down aime", GetCurrentThreadId());
                // _ActivateIME();
            }
            break;
    }

    return CallNextHookEx(hhk, nCode, wParam, lParam);
}
#endif

BOOL
CActiveIMM::_OnFocusMessage(
    UINT uMsg,
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bIsRealIme
    )
{
    if (bIsRealIme) {
        switch (uMsg)
        {
            case WM_SETFOCUS:
                if (! _OnSetFocus(hWnd, bIsRealIme)) {
                    _hFocusWnd = hWnd;
                }
                break;

            case WM_KILLFOCUS:
                _OnKillFocus(hWnd, bIsRealIme);
                break;
        }
    }
    else {
        switch (uMsg)
        {
            case WM_SETFOCUS:
                _OnSetFocus(hWnd, bIsRealIme);
                break;

            case WM_KILLFOCUS:
                _OnKillFocus(hWnd, bIsRealIme);
                break;

                break;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _OnSetFocus
//
//----------------------------------------------------------------------------

BOOL CActiveIMM::_OnSetFocus(HWND hWnd, BOOL bIsRealIme)
{
    BOOL ret = FALSE;
    HIMC hIMC;
    HWND hFocusWnd;

    if (hWnd && (hFocusWnd = GetFocus()) && hWnd != hFocusWnd) // consider: prob this makes all tests below unnecessary...
    {
        return ret;
    }

    _hFocusWnd = hWnd;

    if (SUCCEEDED(_InputContext.GetContext(hWnd, &hIMC))) {
        if (IsPresent(hWnd, TRUE)) {
            //
            // In the case of DIM already associated but _mapWndFocus is not.
            //
            _SetMapWndFocus(hWnd);

            if (_InputContext._IsDefaultContext(hIMC)) {
                DIMM_IMCLock pIMC(hIMC);
                if (pIMC.Valid()) {
                    // set the hWnd since this is a default context
                    pIMC->hWnd = hWnd;
                }
            }

            if (bIsRealIme) {
                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
            }
            else {
                // update the current ime's IMMGWL_IMC
                _UIWindow.SetUIWindowContext(hIMC);

                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
                _SendUIMessage(WM_IME_SETCONTEXT, TRUE, ISC_SHOWUIALL, IsWindowUnicode(hWnd));
            }

            //
            // In the case of DIM associated with _AImeAssociateFocus
            //
            _SetMapWndFocus(hWnd);
        }
        else {
            if (hIMC)
                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS | AIMMP_AFF_SETNULLDIM);
            else
                _AImeAssociateFocus(hWnd, NULL, AIMMP_AFF_SETFOCUS);
        }
        ret = TRUE;
    }
    return ret;
}

void
CActiveIMM::_OnKillFocus(
    HWND hWnd,
    BOOL bIsRealIme
    )
{
    HIMC hIMC;

    if (SUCCEEDED(_InputContext.GetContext(hWnd, &hIMC))) {

        BOOL fPresent = IsPresent(hWnd, FALSE);

        if (fPresent) {
            if (bIsRealIme) {
                _AImeAssociateFocus(hWnd, hIMC, 0);

#ifdef NOLONGER_NEEDIT_BUT_MAYREFERIT_LATER
                /*
                 * Exception for "Internet Explorer_Server" window class.
                 * This window class doesn't have a window focus, so GetFocus() retrieve
                 * different window handle.
                 * In this case, ITfThreadMgr->AssociateFocus doesn't call _SetFocus(NULL),
                 * this code is recover ITfThreadMgr->SetFocus(NULL);
                 */
                if (hWnd != ::GetFocus() && _FilterList.IsExceptionPresent(hWnd)) {
                    _FilterList.OnExceptionKillFocus();
                }
#endif
            }
            else {
                _AImeAssociateFocus(hWnd, hIMC, 0);
                _SendUIMessage(WM_IME_SETCONTEXT, FALSE, ISC_SHOWUIALL, IsWindowUnicode(hWnd));
           }
        }
    }
}

void
CActiveIMM::_SetMapWndFocus(
    HWND hWnd
    )
{
    ITfDocumentMgr* pdim;
    if (_mapWndFocus.Lookup(hWnd, pdim)) { // consider: what is this code doing?
        if (pdim)
           pdim->Release();
    }
    _mapWndFocus.SetAt(hWnd, GetAssociated(hWnd));
}

void
CActiveIMM::_ResetMapWndFocus(
    HWND hWnd
    )
{
    ITfDocumentMgr* pdim;
    if (_mapWndFocus.Lookup(hWnd, pdim)) {
        _mapWndFocus.SetAt(hWnd, FALSE);
        if (pdim)
           pdim->Release();
    }
}


/*
 * Hook
 */


#ifdef CALLWNDPROC_HOOK
/* static */
LRESULT CALLBACK CActiveIMM::_CallWndProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    const CWPSTRUCT *pcwps;
    UINT uMsg;

    pcwps = (const CWPSTRUCT *)lParam;
    uMsg = pcwps->message;

    if (nCode == HC_ACTION)
    {
        if (uMsg == WM_SETFOCUS ||
            uMsg == WM_KILLFOCUS  )
        {
            _this->_OnFocusMessage(uMsg, pcwps->hwnd, pcwps->wParam, pcwps->lParam, _this->_IsRealIme());
        }
#if 0
        else if (uMsg == WM_MENUSELECT)
        {
            // we don't want to feed an ime keystrokes during menu operations
            _this->_fMenuSelected = (HIWORD(wParam) != 0xffff || (HMENU)lParam != 0);
        }
#endif
    }

    return CallNextHookEx(_this->_hHook[TH_WNDPROC], nCode, wParam, lParam);
}
#endif // CALLWNDPROC_HOOK

/* static */
LRESULT CALLBACK CActiveIMM::_DefImeWnd_CallWndProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    /*
     * Default IME Window class hook
     *
     * Never check IsRealIme().
     *
     */
    if (nCode == HC_ACTION) {
        const CWPRETSTRUCT *pcwprets;
        pcwprets = (const CWPRETSTRUCT *)lParam;

#ifndef CALLWNDPROC_HOOK
        if (pcwprets->message == WM_SETFOCUS ||
            pcwprets->message == WM_KILLFOCUS  )
        {
            _this->_OnFocusMessage(pcwprets->message, pcwprets->hwnd, pcwprets->wParam, pcwprets->lParam, _this->_IsRealIme());
        }
#if 0
        else if (pcwprets->message == WM_MENUSELECT)
        {
            // we don't want to feed an ime keystrokes during menu operations
            _this->_fMenuSelected = (HIWORD(wParam) != 0xffff || (HMENU)lParam != 0);
        }
#endif
        else
#endif // CALLWNDPROC_HOOK
            if (_this->_IsImeClass(pcwprets->hwnd)) {
            /*
             * This hook from IME window class
             */
            switch (pcwprets->message) {
                case WM_NCDESTROY:
                    _this->_DefaultIMEWindow.ImeDefWndHook(pcwprets->hwnd);
                    _this->_RemoveHookWndList(pcwprets->hwnd);
                    break;
            }
        }
        else {
            /*
             * This hook from unknown window class
             */
            switch (pcwprets->message) {
                case WM_CREATE:
                    _this->_SetHookWndList(pcwprets->hwnd);
                    break;
            }
        }
    }

    return CallNextHookEx(_this->_hHook[TH_DEFIMEWNDPROC], nCode, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\aime_kl.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime_kl.cpp

Abstract:

    This file implements the Active IME for hKL (Cicero) Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"

const UINT IME_T_EUDC_DIC_SIZE = 80;    // the Tradition Chinese EUDC dictionary.

HRESULT
CActiveIMM::_Escape(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult,
    BOOL fUnicode
    )
{
    if ( (  fUnicode &&  (_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE)) ||
         (! fUnicode && !(_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE))
       ) {
        /*
         * Doesn't need W/A or A/W conversion. Calls directly to IME to
         * bring up the configuration dialog box.
         */
        return _pActiveIME->Escape(hIMC, uEscape, lpData, plResult);
    }

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    /*
     * Unicode caller, ANSI IME, Needs W/A conversion depending on the uEscape
     * ANSI caller, Unicode IME, Needs A/W conversion depending on the uEscape
     */
    HRESULT hr = E_FAIL;
    switch (uEscape) {
        case IME_ESC_GET_EUDC_DICTIONARY:
        case IME_ESC_IME_NAME:
        case IME_ESC_GETHELPFILENAME:
            if (fUnicode) {
                LPSTR bbuf = new char [ sizeof(char) * IME_T_EUDC_DIC_SIZE ];
                if (bbuf) {
                    hr = _Escape(hKL, hIMC, uEscape, (void*)(LPCSTR)bbuf, plResult, FALSE);
                    if (SUCCEEDED(hr)) {
                        CBCompString bstr(cp, hIMC, bbuf, lstrlenA(bbuf));
                        CWCompString wstr(cp);
                        wstr = bstr;

                        wstr.ReadCompData((WCHAR*)lpData, IME_T_EUDC_DIC_SIZE);
                    }

                    delete [] bbuf;
                }
            }
            else {
                LPWSTR wbuf = new WCHAR [ sizeof(WCHAR) * IME_T_EUDC_DIC_SIZE ];
                if (wbuf) {
                    hr = _Escape(hKL, hIMC, uEscape, (void*)(LPCWSTR)wbuf, plResult, TRUE);
                    if (SUCCEEDED(hr)) {
                        CWCompString wstr(cp, hIMC, wbuf, lstrlenW(wbuf));
                        CBCompString bstr(cp);
                        bstr = wstr;

                        bstr.ReadCompData((CHAR*)lpData, IME_T_EUDC_DIC_SIZE);
                    }
                    delete [] wbuf;
                }
            }
            break;
        case IME_ESC_SET_EUDC_DICTIONARY:
        case IME_ESC_HANJA_MODE:
            if (fUnicode) {
                CWCompString wstr(cp, hIMC, (LPWSTR)lpData, lstrlenW((LPWSTR)lpData));
                CBCompString bstr(cp);
                bstr = wstr;

                DWORD dwLenReading = (DWORD)bstr.GetSize();
                LPSTR bbuf = new CHAR [sizeof(CHAR) * dwLenReading];
                if (bbuf) {
                    bstr.ReadCompData(bbuf, dwLenReading);
                    bbuf[dwLenReading] = L'\0';

                    hr = _Escape(hKL, hIMC, uEscape, (void*)bbuf, plResult, FALSE);
                    delete [] bbuf;
                }
            }
            else {
                CBCompString bstr(cp, hIMC, (LPSTR)lpData, lstrlenA((LPSTR)lpData));
                CWCompString wstr(cp);
                wstr = bstr;

                DWORD dwLenReading = (DWORD)wstr.GetSize();
                LPWSTR wbuf = new WCHAR [sizeof(WCHAR) * dwLenReading];
                if (wbuf)
                {
                    wstr.ReadCompData(wbuf, dwLenReading);
                    wbuf[dwLenReading] = L'\0';

                    hr = _Escape(hKL, hIMC, uEscape, (void*)wbuf, plResult, TRUE);
                    delete [] wbuf;
                }
            }
            break;
        case IME_ESC_SEQUENCE_TO_INTERNAL:
            {
                INT i = 0;
                if (fUnicode) {
                    hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
                    if (SUCCEEDED(hr)) {
                        char bbuf[ 2 ];
                        if (HIBYTE(LOWORD(*plResult)))
                            bbuf[i++] = HIBYTE(LOWORD(*plResult));
                        if (LOBYTE(LOWORD(*plResult)))
                            bbuf[i++] = LOBYTE(LOWORD(*plResult));

                        CBCompString bstr(cp, hIMC, bbuf, i);
                        CWCompString wstr(cp);
                        wstr = bstr;

                        switch (wstr.ReadCompData()) {
                            case 1:  *plResult = MAKELONG(wstr[0], 0); break;
                            case 2:  *plResult = MAKELONG(wstr[1], wstr[0]); break;
                            default: *plResult = 0; break;
                        }
                    }
                }
                else {
                    hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
                    if (SUCCEEDED(hr)) {
                        WCHAR wbuf[ 2 ];
                        if (HIWORD(*plResult))
                            wbuf[i++] = HIWORD(*plResult);
                        if (LOWORD(*plResult))
                            wbuf[i++] = LOWORD(*plResult);

                        CWCompString wstr(cp, hIMC, wbuf, i);
                        CBCompString bstr(cp);
                        bstr = wstr;

                        switch (bstr.ReadCompData()) {
                            case 1:  *plResult = MAKELONG(MAKEWORD(bstr[0], 0), 0); break;
                            case 2:  *plResult = MAKELONG(MAKEWORD(bstr[1], bstr[0]), 0); break;
                            case 3:  *plResult = MAKELONG(MAKEWORD(bstr[2], bstr[1]), MAKEWORD(bstr[0], 0)); break;
                            case 4:  *plResult = MAKELONG(MAKEWORD(bstr[3], bstr[2]), MAKEWORD(bstr[1], bstr[0])); break;
                            default: *plResult = 0; break;
                        }
                    }
                }
            }
            break;
        default:
            if (fUnicode)
                hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
            else
                hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
    }

    return hr;
}

HRESULT
CActiveIMM::_ConfigureIMEA(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDA *lpdata
    )
{
    REGISTERWORDW RegDataW;
    RegDataW.lpReading =
    RegDataW.lpWord    = NULL;

    if (dwMode & IME_CONFIG_REGISTERWORD) {
        UINT cp;
        _pActiveIME->GetCodePageA(&cp);

        CBCompString bReadingStr(cp);
        bReadingStr.WriteCompData(lpdata->lpReading, lstrlenA(lpdata->lpReading));
        DWORD dwLenReading = bReadingStr.ConvertUnicodeString();
        RegDataW.lpReading = new WCHAR [ dwLenReading + 1 ];
        if (RegDataW.lpReading == NULL)
            return E_OUTOFMEMORY;

        bReadingStr.ConvertUnicodeString(RegDataW.lpReading, dwLenReading);
        RegDataW.lpReading[ dwLenReading ] = L'\0';

        CBCompString bWordStr(cp);
        bWordStr.WriteCompData(lpdata->lpWord, lstrlenA(lpdata->lpWord));
        DWORD dwLenWord = bWordStr.ConvertUnicodeString();
        RegDataW.lpWord = new WCHAR [ dwLenWord + 1 ];
        if (RegDataW.lpWord == NULL) {
            delete [] RegDataW.lpReading;
            return E_OUTOFMEMORY;
        }

        bWordStr.ConvertUnicodeString(RegDataW.lpWord, dwLenWord);
        RegDataW.lpWord[ dwLenWord ] = L'\0';
    }

    HRESULT hr = _ConfigureIMEW(hKL, hWnd, dwMode, &RegDataW);

    if (RegDataW.lpReading)
        delete [] RegDataW.lpReading;
    if (RegDataW.lpWord)
        delete [] RegDataW.lpWord;
    return hr;
}

HRESULT
CActiveIMM::_ConfigureIMEW(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *lpdata
    )
{
    return _pActiveIME->Configure(hKL, hWnd, dwMode, lpdata);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\aime_wnd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime_wnd.cpp

Abstract:

    This file implements the Active IME for hWnd (Cicero) Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "imewndhd.h"
#include "cdimm.h"


/*++

Method:

    IActiveIMMApp::OnDefWindowProc

Routine Description:

    Replaces the DefWindowProc function

Arguments:

    hWnd - [in] Handle to the window procedure that received this message.
    uMsg - [in] Unsigned integer that specifies the message.
    wParam - [in] WPARAM value that specifies additional message information.
    lParam - [in] LPARAM value that specifies additional message information.
    plResult - [out] Address of an LRESULT value that receives the result of the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

Remarks:

    This method must be called before you would normally call DefWindowProc.
    If IActiveIMMApp::OnDefWindowProc returns S_FALSE, DefWindowProc should be called.

--*/

HRESULT
CActiveIMM::OnDefWindowProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult    
    )
{
    BOOL fUnicode = IsWindowUnicode(hWnd);
    HRESULT hr = S_FALSE; // returns S_FALSE, DefWindowProc should be called.

    Assert(GetCurrentThreadId() == GetWindowThreadProcessId(hWnd, NULL));
    Assert(plResult && *plResult == 0);    

    if (IsOnImm() || _IsRealIme())
        return S_FALSE;

    switch (uMsg)
    {
        case WM_IME_KEYDOWN:
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                PostMessageW(hWnd, WM_KEYDOWN, wParam, lParam);
            }
            else {
                PostMessageA(hWnd, WM_KEYDOWN, wParam, lParam);
            }
            *plResult = 0;
            hr = S_OK;
            break;

        case WM_IME_KEYUP:
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                PostMessageW(hWnd, WM_KEYUP, wParam, lParam);
            }
            else {
                PostMessageA(hWnd, WM_KEYUP, wParam, lParam);
            }
            *plResult = 0;
            hr = S_OK;
            break;

        case WM_IME_CHAR:
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                PostMessageW(hWnd, WM_CHAR, wParam, 1L);
            }
            else {
                UINT uCodePage;
                _pActiveIME->GetCodePageA(&uCodePage);

                if (IsDBCSLeadByteEx(uCodePage, (BYTE)(wParam >> 8))) {
                    PostMessageA(hWnd,
                                 WM_CHAR,
                                 (WPARAM)((BYTE)(wParam >> 8)),    // leading byte
                                 1L);
                    PostMessageA(hWnd,
                                 WM_CHAR,
                                 (WPARAM)((BYTE)wParam),           // trailing byte
                                 1L);
                }
                else {
                    PostMessageA(hWnd, WM_CHAR, wParam, 1L);
                }
            }
            *plResult = 0;
            hr = S_OK;
            break;

        case WM_IME_COMPOSITION:
            if (lParam & GCS_RESULTSTR) {
                HIMC hIMC;

                GetContext(hWnd, &hIMC);
                if (hIMC != NULL) {
                    LONG cbLen;

                    if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                        LPWSTR pwszBuffer;
                        /*
                         * GetCompositionString returns the size of buffer needed in byte
                         */
                        if (SUCCEEDED(_GetCompositionString(hIMC, GCS_RESULTSTR, 0, &cbLen, NULL, fUnicode)) &&
                            cbLen != 0) {
                            pwszBuffer = (LPWSTR)new BYTE[cbLen];
                            if (pwszBuffer != NULL) {
                                _GetCompositionString(hIMC, GCS_RESULTSTR, cbLen, &cbLen, pwszBuffer, fUnicode);
                                DWORD dwIndex;
                                for (dwIndex = 0; dwIndex < cbLen / sizeof(WCHAR); dwIndex++)
                                    SendMessageW(hWnd, WM_IME_CHAR, MAKEWPARAM(pwszBuffer[dwIndex], 0), 1L);
                                delete [] pwszBuffer;
                            }
                        }
                    }
                    else {
                        LPSTR pszBuffer;
                        /*
                         * GetCompositionString returns the size of buffer needed in byte
                         */
                        if (SUCCEEDED(_GetCompositionString(hIMC, GCS_RESULTSTR, 0, &cbLen, NULL, fUnicode)) &&
                            cbLen != 0) {
                            pszBuffer = new CHAR[cbLen];
                            if (pszBuffer != NULL) {
                                _GetCompositionString(hIMC, GCS_RESULTSTR, cbLen, &cbLen, pszBuffer, fUnicode);
                                UINT uCodePage;
                                _pActiveIME->GetCodePageA(&uCodePage);

                                DWORD dwIndex;
                                for (dwIndex = 0; dwIndex < cbLen / sizeof(CHAR); dwIndex++) {
                                    if (IsDBCSLeadByteEx(uCodePage, pszBuffer[dwIndex])) {
                                        if (dwIndex+1 < cbLen / sizeof(CHAR)) {
                                            SendMessageA(hWnd,
                                                         WM_IME_CHAR,
                                                         MAKEWPARAM(MAKEWORD(pszBuffer[dwIndex+1], pszBuffer[dwIndex]), 0),
                                                         1L);
                                            dwIndex++;
                                        }
                                    }
                                    else {
                                        SendMessageA(hWnd,
                                                     WM_IME_CHAR,
                                                     MAKEWPARAM(MAKEWORD(pszBuffer[dwIndex], 0), 0),
                                                     1L);

                                    }
                                }
                                delete [] pszBuffer;
                            }
                        }
                    }
                }
            }
            /*
             * Fall through to send to Default IME Window with checking
             * activated hIMC.
             */
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
            return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);

        case WM_IME_NOTIFY:
            switch (wParam)
            {
                case IMN_OPENSTATUSWINDOW:
                case IMN_CLOSESTATUSWINDOW:
                    return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);
                default:
                    return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);
            }
            break;

        case WM_IME_REQUEST:
            switch (wParam)
            {
                case IMR_QUERYCHARPOSITION:
                    return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);
                default:
                    break;
            }
            break;

        case WM_IME_SETCONTEXT:
            return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode, FALSE);

        case WM_IME_SELECT:
            TraceMsg(TF_WARNING, "OnDefWindowProc should not receive WM_IME_SELECT");
            break;
    }

    return hr;
}

HRESULT
CActiveIMM::_ToIMEWindow(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT*& plResult,
    BOOL fUnicode,
    BOOL fChkIMC
    )
{
    HRESULT hr = E_FAIL;
    HWND hwndDefIme;

    /*
     * We assume this Wnd uses DefaultIMEWindow.
     * If this window has its own IME window, it have to call
     * IsUIMessage()....
     */
    if (SUCCEEDED(_DefaultIMEWindow.GetDefaultIMEWnd(hWnd, &hwndDefIme))) {
        if (hwndDefIme == hWnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME message to DefWindowProc().
             */
            TraceMsg(TF_WARNING, "IME Class window is hooked and IME message [%X] are sent to DefWindowProc", uMsg);
            *plResult = (fUnicode ? ImeWndProcW : ImeWndProcA)(hWnd, uMsg, wParam, lParam);
            return S_OK;
        }

        if (fChkIMC) {
            /*
             * If hImc of this window is not activated for IME window,
             * we don't send WM_IME_NOTIFY.
             */
            HIMC hIMC = NULL;
            _InputContext.GetContext(hWnd, &hIMC);
            CIMEWindowHandler* pimeui = GetImeWndHandler(hwndDefIme);
            if (pimeui == NULL)
                return E_FAIL;

            if (pimeui->ImeGetImc() == hIMC) {
                *plResult = (fUnicode && IsOnNT()    // Because Win9x platform doesn't have PostMessageW
                    ? SendMessageW : SendMessageA)(hwndDefIme, uMsg, wParam, lParam);
                hr = S_OK;
            }
            else {
                TraceMsg(TF_WARNING, "DefWindowProc can not send WM_IME_message [%X] now", uMsg);
                hr = E_FAIL;
            }
        }
        else {
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have PostMessageW
                *plResult = SendMessageW(hwndDefIme, uMsg, wParam, lParam);
            }
            else {
                *plResult = SendMessageA(hwndDefIme, uMsg, wParam, lParam);
            }
            hr = S_OK;
        }
    }

    return hr;
}

VOID
CActiveIMM::_AimmPostMessage(
    HWND hwnd,
    INT iNum,
    LPTRANSMSG lpTransMsg,
    DIMM_IMCLock& lpIMC
    )
{
    while (iNum--) {
        if (lpIMC.IsUnicode() && IsOnNT()) {    // Because Win9x platform doesn't have PostMessageW
            PostMessageW(hwnd,
                         lpTransMsg->message,
                         lpTransMsg->wParam,
                         lpTransMsg->lParam);
        }
        else {
            _AimmPostSendMessageA(hwnd,
                                  lpTransMsg->message,
                                  lpTransMsg->wParam,
                                  lpTransMsg->lParam,
                                  lpIMC,
                                  TRUE);
        }
        lpTransMsg++;
    }
}

VOID
CActiveIMM::_AimmSendMessage(
    HWND hwnd,
    INT iNum,
    LPTRANSMSG lpTransMsg,
    DIMM_IMCLock& lpIMC
    )
{
    while (iNum--) {
        if (lpIMC.IsUnicode() && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
            SendMessageW(hwnd,
                         lpTransMsg->message,
                         lpTransMsg->wParam,
                         lpTransMsg->lParam);
        }
        else {
            _AimmPostSendMessageA(hwnd,
                                  lpTransMsg->message,
                                  lpTransMsg->wParam,
                                  lpTransMsg->lParam,
                                  lpIMC);
        }
        lpTransMsg++;
    }
}

VOID
CActiveIMM::_AimmPostSendMessageA(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    DIMM_IMCLock& lpIMC,
    BOOL fPost
    )
{
    if (IsOnNT() || ((! IsOnNT()) && (! lpIMC.IsUnicode()))) {
        fPost ? PostMessageA(hwnd, msg, wParam, lParam)
              : SendMessageA(hwnd, msg, wParam, lParam);
    }
    else {
        if (msg == WM_IME_COMPOSITION) {

            UINT cp;
            _pActiveIME->GetCodePageA(&cp);

            CWCompString wstr(cp, lpIMC, (LPWSTR)&wParam, 1);
            CBCompString bstr(cp, lpIMC);
            bstr = wstr;
            if (bstr.ReadCompData()) {
                if (bstr.GetSize() > 1)
                    wParam = MAKEWPARAM(bstr.GetAt(0), bstr.GetAt(1));
                else
                    wParam = bstr.GetAt(0);
            }
        }
        fPost ? PostMessageA(hwnd, msg, wParam, lParam)
              : SendMessageA(hwnd, msg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\cimm32.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imm32.cpp

Abstract:

    This file implements the IMM32 class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cimm32.h"

HRESULT
Imm32_CreateContext(
    OUT HIMC *phIMC
    )
{
    HIMC hIMC = imm32::ImmCreateContext();
    if (hIMC) {
        *phIMC = hIMC;
        return S_OK;
    }
    return E_FAIL;
}

HRESULT
Imm32_DestroyContext(
    IN HIMC hIMC
    )
{
    return (imm32::ImmDestroyContext(hIMC)) ? S_OK
                                            : E_FAIL;
}

HRESULT
Imm32_LockIMC(
    HIMC hIMC,
    OUT INPUTCONTEXT **ppIMC
    )
{
    return (*ppIMC = imm32::ImmLockIMC(hIMC)) ? S_OK
                                              : E_FAIL;
}

HRESULT
Imm32_UnlockIMC(
    IN HIMC hIMC
    )
{
    imm32::ImmUnlockIMC(hIMC);
    return S_OK;
}

HRESULT
Imm32_GetIMCLockCount(
    IN HIMC hIMC,
    OUT DWORD* pdwLockCount
    )
{
    *pdwLockCount = imm32::ImmGetIMCLockCount(hIMC);
    return S_OK;
}

HRESULT
Imm32_AssociateContext(
    IN HWND hWnd,
    IN HIMC hIMC,
    OUT HIMC *phPrev
    )
{
    *phPrev = imm32::ImmAssociateContext(hWnd, hIMC);
    return S_OK;
}

HRESULT
Imm32_AssociateContextEx(
    IN HWND hWnd,
    IN HIMC hIMC,
    IN DWORD dwFlags
    )
{
    return (imm32::ImmAssociateContextEx(hWnd, hIMC, dwFlags)) ? S_OK
                                                               : E_FAIL;
}

HRESULT
Imm32_GetContext(
    IN HWND hWnd,
    OUT HIMC *phIMC
    )
{
    *phIMC = imm32::ImmGetContext(hWnd);
    return S_OK;
}

HRESULT
Imm32_ReleaseContext(
    IN HWND hWnd,
    IN HIMC hIMC
    )
{
    return (imm32::ImmReleaseContext(hWnd, hIMC)) ? S_OK
                                                  : E_FAIL;
}

HRESULT
Imm32_CreateIMCC(
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )
{
    HIMCC hIMCC = imm32::ImmCreateIMCC(dwSize);
    if (hIMCC) {
        *phIMCC = hIMCC;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_DestroyIMCC(
    IN HIMCC hIMCC
    )
{
    /*
     * ImmDestroyIMCC maped to LocalFree.
     *   if the function fails, the return value is equal to a handle to the local memory object.
     *   if the function succeeds, the return value is NULL.
     */
    return (imm32::ImmDestroyIMCC(hIMCC)) ? E_FAIL
                                          : S_OK;
}

HRESULT
Imm32_LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )
{
    return (*ppv = imm32::ImmLockIMCC(hIMCC)) ? S_OK
                                              : E_FAIL;
}

HRESULT
Imm32_UnlockIMCC(
    IN HIMCC hIMCC
    )
{
    if (imm32::ImmUnlockIMCC(hIMCC)) {
        // memory object still locked.
        return S_OK;
    }
    else {
        DWORD err = GetLastError();
        if (err == NO_ERROR)
            // memory object is unlocked.
            return S_OK;
        else if (err == ERROR_NOT_LOCKED)
            // memory object is already unlocked.
            return S_OK;
    }
    return E_FAIL;
}

HRESULT
Imm32_GetIMCCSize(
    IN HIMCC hIMCC,
    OUT DWORD *pdwSize
    )
{
    *pdwSize = imm32::ImmGetIMCCSize(hIMCC);
    return S_OK;
}

HRESULT
Imm32_ReSizeIMCC(
    IN HIMCC hIMCC,
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )
{
    HIMCC hNewIMCC = imm32::ImmReSizeIMCC(hIMCC, dwSize);
    if (hNewIMCC) {
        *phIMCC = hNewIMCC;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_GetIMCCLockCount(
    IN HIMCC hIMCC,
    OUT DWORD* pdwLockCount
    )
{
    *pdwLockCount = imm32::ImmGetIMCCLockCount(hIMCC);
    return S_OK;
}

HRESULT
Imm32_GetOpenStatus(
    IN HIMC hIMC
    )
{
    return imm32::ImmGetOpenStatus(hIMC) ? S_OK : S_FALSE;
}

HRESULT
Imm32_SetOpenStatus(
    HIMC hIMC,
    BOOL fOpen
    )
{
    return (imm32::ImmSetOpenStatus(hIMC, fOpen)) ? S_OK
                                                  : E_FAIL;
}

HRESULT
Imm32_GetConversionStatus(
    IN HIMC hIMC,
    OUT DWORD *lpfdwConversion,
    OUT DWORD *lpfdwSentence
    )
{
    return (imm32::ImmGetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence)) ? S_OK
                                                                                 : E_FAIL;
}

HRESULT
Imm32_SetConversionStatus(
    IN HIMC hIMC,
    IN DWORD fdwConversion,
    IN DWORD fdwSentence
    )
{
    return (imm32::ImmSetConversionStatus(hIMC, fdwConversion, fdwSentence)) ? S_OK
                                                                             : E_FAIL;
}

HRESULT
Imm32_GetStatusWindowPos(
    IN HIMC hIMC,
    OUT POINT *lpptPos
    )
{
    return (imm32::ImmGetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                         : E_FAIL;
}

HRESULT
Imm32_SetStatusWindowPos(
    IN HIMC hIMC,
    IN POINT *lpptPos
    )
{
    return (imm32::ImmSetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                         : E_FAIL;
}

HRESULT
Imm32_GetCompositionString(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwCompLen,
    OUT LONG*& lpCopied,
    OUT LPVOID lpBuf,
    BOOL fUnicode
    )
{
    LONG lRet;
    lRet = fUnicode ? imm32::ImmGetCompositionStringW(hIMC, dwIndex, lpBuf, dwCompLen)
                    : imm32::ImmGetCompositionStringA(hIMC, dwIndex, lpBuf, dwCompLen);
    if (lRet < 0)
        return E_FAIL;
    else {
        *lpCopied = lRet;
        return S_OK;
    }
}

HRESULT
Imm32_SetCompositionString(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen,
    BOOL fUnicode
    )
{
    if (fUnicode ? imm32::ImmSetCompositionStringW(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen)
                 : imm32::ImmSetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen)
       )
        return S_OK;
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    BOOL fUnicode
    )
{
    if (fUnicode ? imm32::ImmGetCompositionFontW(hIMC, &lplf->W)
                 : imm32::ImmGetCompositionFontA(hIMC, &lplf->A)
       )
        return S_OK;
    else
        return E_FAIL;
}

HRESULT
Imm32_SetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    BOOL fUnicode
    )
{
    if (fUnicode ? imm32::ImmSetCompositionFontW(hIMC, &lplf->W)
                 : imm32::ImmSetCompositionFontA(hIMC, &lplf->A)
       )
        return S_OK;
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCompositionWindow(
    IN HIMC hIMC,
    OUT COMPOSITIONFORM *lpCompForm
    )
{
    return (imm32::ImmGetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                              : E_FAIL;
}

HRESULT
Imm32_SetCompositionWindow(
    IN HIMC hIMC,
    IN COMPOSITIONFORM *lpCompForm
    )
{
    return (imm32::ImmSetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                              : E_FAIL;
}

HRESULT
Imm32_GetCandidateList(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPCANDIDATELIST lpCandList,
    OUT UINT* puCopied,
    BOOL fUnicode
    )
{
    DWORD dwRet;
    dwRet = fUnicode ? imm32::ImmGetCandidateListW(hIMC, dwIndex, lpCandList, dwBufLen)
                     : imm32::ImmGetCandidateListA(hIMC, dwIndex, lpCandList, dwBufLen);
    if (dwRet) {
        *puCopied = dwRet;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCandidateListCount(
    IN HIMC hIMC,
    OUT DWORD* lpdwListSize,
    OUT DWORD* pdwBufLen,
    BOOL fUnicode
    )
{
    DWORD dwRet;
    dwRet = fUnicode ? imm32::ImmGetCandidateListCountW(hIMC, lpdwListSize)
                     : imm32::ImmGetCandidateListCountA(hIMC, lpdwListSize);
    if (dwRet) {
        *pdwBufLen = dwRet;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCandidateWindow(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT CANDIDATEFORM *lpCandidate
    )
{
    return (imm32::ImmGetCandidateWindow(hIMC, dwIndex, lpCandidate)) ? S_OK
                                                                      : E_FAIL;
}

HRESULT
Imm32_SetCandidateWindow(
    IN HIMC hIMC,
    IN CANDIDATEFORM *lpCandForm
    )
{
    return (imm32::ImmSetCandidateWindow(hIMC, lpCandForm)) ? S_OK
                                                            : E_FAIL;
}

HRESULT
Imm32_GetGuideLine(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT CHARAW* pBuf,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    *pdwResult = fUnicode ? imm32::ImmGetGuideLineW(hIMC, dwIndex, &pBuf->W, dwBufLen)
                          : imm32::ImmGetGuideLineA(hIMC, dwIndex, &pBuf->A, dwBufLen);
    return S_OK;
}

HRESULT
Imm32_NotifyIME(
    IN HIMC hIMC,
    IN DWORD dwAction,
    IN DWORD dwIndex,
    IN DWORD dwValue
    )
{
    return (imm32::ImmNotifyIME(hIMC, dwAction, dwIndex, dwValue)) ? S_OK
                                                                   : E_FAIL;
}

HRESULT
Imm32_GetImeMenuItems(
    IN HIMC hIMC,
    IN DWORD dwFlags,
    IN DWORD dwType,
    IN IMEMENUITEMINFOAW *pImeParentMenu,
    OUT IMEMENUITEMINFOAW *pImeMenu,
    IN DWORD dwSize,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    *pdwResult = fUnicode ? imm32::ImmGetImeMenuItemsW(hIMC, dwFlags, dwType, &pImeParentMenu->W, &pImeMenu->W, dwSize)
                          : imm32::ImmGetImeMenuItemsA(hIMC, dwFlags, dwType, &pImeParentMenu->A, &pImeMenu->A, dwSize);
    return S_OK;
}

HRESULT
Imm32_GenerateMessage(
    IN HIMC hIMC
    )
{
    return (imm32::ImmGenerateMessage(hIMC)) ? S_OK
                                             : E_FAIL;
}

/*
 * hWnd
 */
HRESULT
Imm32_GetDefaultIMEWnd(
    IN HWND hWnd,
    OUT HWND *phDefWnd
    )
{
    *phDefWnd = imm32::ImmGetDefaultIMEWnd(hWnd);
    return S_OK;
}

HRESULT
Imm32_GetVirtualKey(
    HWND hWnd,
    UINT* puVirtualKey
    )
{
    *puVirtualKey = imm32::ImmGetVirtualKey(hWnd);
    return S_OK;
}

HRESULT
Imm32_IsUIMessageA(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return imm32::ImmIsUIMessageA(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
}

HRESULT
Imm32_IsUIMessageW(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return imm32::ImmIsUIMessageW(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
}

HRESULT
Imm32_SimulateHotKey(
    HWND hWnd,
    DWORD dwHotKeyID
    )
{
    return imm32::ImmSimulateHotKey(hWnd, dwHotKeyID) ? S_OK : S_FALSE;
}


/*
 * hKL
 */
HRESULT
Imm32_GetProperty(
    HKL hKL,
    DWORD dwOffset,
    DWORD* pdwProperty
    )
{
    *pdwProperty = imm32::ImmGetProperty(hKL, dwOffset);
    return S_OK;
}

HRESULT
Imm32_Escape(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult,
    BOOL fUnicode
    )
{
    *plResult = (fUnicode) ? imm32::ImmEscapeW(hKL, hIMC, uEscape, lpData)
                           : imm32::ImmEscapeA(hKL, hIMC, uEscape, lpData);
    return S_OK;
}

HRESULT
Imm32_GetDescription(
    HKL hKL,
    UINT uBufLen,
    CHARAW* lpsz,
    UINT* puCopied,
    BOOL fUnicode
    )
{
    *puCopied = (fUnicode) ? imm32::ImmGetDescriptionW(hKL, &lpsz->W, uBufLen)
                           : imm32::ImmGetDescriptionA(hKL, &lpsz->A, uBufLen);
    return *puCopied ? S_OK : E_FAIL;
}

HRESULT
Imm32_IsIME(
    HKL hKL
    )
{
    return imm32::ImmIsIME(hKL) ? S_OK : E_FAIL;
}

/*
 * win98/nt5 apis
 */
HRESULT
Imm32_RequestMessage(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* plResult,
    BOOL fUnicode
    )
{
    *plResult = (fUnicode) ? imm32::ImmRequestMessageW(hIMC, wParam, lParam)
                           : imm32::ImmRequestMessageA(hIMC, wParam, lParam);
    return S_OK;
}

/*
 * Register Word
 */
HRESULT
Imm32_EnumRegisterWordA(
    HKL hKL,
    LPSTR szReading,
    DWORD dwStyle,
    LPSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordA **pEnum
    )
{
    return E_FAIL;
}

HRESULT
Imm32_EnumRegisterWordW(
    HKL hKL,
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordW **pEnum
    )
{
    return E_FAIL;
}

HRESULT
Imm32_GetRegisterWordStyleA(
    HKL hKL,
    UINT nItem,
    STYLEBUFA *lpStyleBuf,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetRegisterWordStyleA(hKL, nItem, lpStyleBuf);
    return S_OK;
}

HRESULT
Imm32_GetRegisterWordStyleW(
    HKL hKL,
    UINT nItem,
    STYLEBUFW *lpStyleBuf,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetRegisterWordStyleW(hKL, nItem, lpStyleBuf);
    return S_OK;
}

HRESULT
Imm32_RegisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszRegister
    )
{
    return imm32::ImmRegisterWordA(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
}

HRESULT
Imm32_RegisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszRegister
    )
{
    return imm32::ImmRegisterWordW(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
}

HRESULT
Imm32_UnregisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszUnregister
    )
{
    return imm32::ImmUnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
}

HRESULT
Imm32_UnregisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszUnregister
    )
{
    return imm32::ImmUnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
}

/*
 *
 */

HRESULT
Imm32_ConfigureIMEA(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDA *lpdata
    )
{
    return imm32::ImmConfigureIMEA(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
}

HRESULT
Imm32_ConfigureIMEW(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *lpdata
    )
{
    return imm32::ImmConfigureIMEW(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
}

HRESULT
Imm32_GetConversionListA(
    HKL hKL,
    HIMC hIMC,
    LPSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetConversionListA(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
    return S_OK;
}

HRESULT
Imm32_GetConversionListW(
    HKL hKL,
    HIMC hIMC,
    LPWSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetConversionListW(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
    return S_OK;
}

HRESULT
Imm32_GetDescriptionA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszDescription,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetDescriptionA(hKL, lpszDescription, uBufLen);
    return S_OK;
}

HRESULT
Imm32_GetDescriptionW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszDescription,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetDescriptionW(hKL, lpszDescription, uBufLen);
    return S_OK;
}

HRESULT
Imm32_GetIMEFileNameA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszFileName,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetIMEFileNameA(hKL, lpszFileName, uBufLen);
    return S_OK;
}

HRESULT
Imm32_GetIMEFileNameW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszFileName,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetIMEFileNameW(hKL, lpszFileName, uBufLen);
    return S_OK;
}

HRESULT
Imm32_InstallIMEA(
    LPSTR lpszIMEFileName,
    LPSTR lpszLayoutText,
    HKL *phKL
    )
{
    *phKL = imm32::ImmInstallIMEA(lpszIMEFileName, lpszLayoutText);
    return S_OK;
}

HRESULT
Imm32_InstallIMEW(
    LPWSTR lpszIMEFileName,
    LPWSTR lpszLayoutText,
    HKL *phKL
    )
{
    *phKL = imm32::ImmInstallIMEW(lpszIMEFileName, lpszLayoutText);
    return S_OK;
}

HRESULT
Imm32_DisableIME(
    DWORD idThread
    )
{
    return imm32::ImmDisableIME(idThread) ? S_OK : E_FAIL;
}

HRESULT
Imm32_GetHotKey(
    DWORD dwHotKeyID,
    UINT *puModifiers,
    UINT *puVKey,
    HKL *phKL
    )
{
    return E_FAIL;
}

HRESULT
Imm32_SetHotKey(
    DWORD dwHotKeyID,
    UINT uModifiers,
    UINT uVKey,
    HKL hKL
    )
{
    return E_FAIL;
}

HRESULT
Imm32_RequestMessageA(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    return E_FAIL;
}

HRESULT
Imm32_RequestMessageW(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\context.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    context.cpp

Abstract:

    This file implements the Input Context Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"
#include "context.h"
#include "globals.h"
#include "defs.h"
#include "delay.h"
#include "computil.h"


BOOL
CInputContext::_CreateDefaultInputContext(
    IN DWORD dwPrivateSize,
    IN BOOL fUnicode,
    IN BOOL fCiceroActivated
    )

/*++

Routine Description:

    Create a default input context

Arguments:

    dwPrivateSize - [in] Unsigned integer long value that contains the size of private IMCC
                         data.

Return Value:

    Returns TRUE if successful, or an error code otherwise.

--*/

{
    // create a default IMC for this thread
    if (IsOnImm()) {
        // On FE systems, we use system allocated HIMCs
        // but here we want to use the thread default HIMC
        // which the system has already allocated.

        CActiveIMM *_pActiveIMM = GetTLS();
        if (_pActiveIMM == NULL)
            return FALSE;

        // consider: find a better way to get the def HIMC!
        HWND hWnd = CreateWindow(TEXT("STATIC"), TEXT(""), WS_DISABLED | WS_POPUP,
                                 0, 0, 0, 0, 0, 0, g_hInst, NULL);
        if (hWnd)
        {
            Imm32_GetContext(hWnd, &_hDefaultIMC);
            if (_hDefaultIMC)
                Imm32_ReleaseContext(hWnd, _hDefaultIMC);

            DestroyWindow(hWnd);
        }

        if (_hDefaultIMC == NULL)
            return FALSE;

        CContextList::CLIENT_IMC_FLAG client_flag = (fUnicode ? CContextList::IMCF_UNICODE
                                                              : CContextList::IMCF_NONE   );
        ContextList.SetAt(_hDefaultIMC, client_flag);

        // we can't create the cicero context until ITfThreadMgr::Activate has been called
        // we'll do this later if we need to
        if (fCiceroActivated)
        {
            if (FAILED(CreateAImeContext(_hDefaultIMC))) {
                ContextList.RemoveKey(_hDefaultIMC);
                return FALSE;
            }
        }

        _pActiveIMM->_ResizePrivateIMCC(_hDefaultIMC, dwPrivateSize);
    }
    else {
        if (FAILED(CreateContext(dwPrivateSize, fUnicode, &_hDefaultIMC, fCiceroActivated)))
            return FALSE;
    }

    return TRUE;
}

BOOL
CInputContext::_DestroyDefaultInputContext(
    )
{
    // destroy a default IMC for this thread
    if (! IsOnImm()) {
        if (FAILED(DestroyContext(_hDefaultIMC)))
            return FALSE;
    }
    else {
        if (FAILED(DestroyAImeContext(_hDefaultIMC)))
            return FALSE;
    }

    return TRUE;
}

HRESULT
CInputContext::UpdateInputContext(
    IN HIMC hIMC,
    IN DWORD dwPrivateDataSize
    )
{
    HRESULT hr;

    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    /*
     * hPrivate
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hPrivate, dwPrivateDataSize))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hRivate failure");
        return hr;
    }

    /*
     * hMsgBuf
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hMsgBuf, sizeof(UINT)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hMsgBuf failure");
        return hr;
    }

    lpIMC->dwNumMsgBuf = 0;

    /*
     * hGuideLine
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hGuideLine, sizeof(GUIDELINE)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hGuideLine failure");
        return hr;
    }

    DIMM_IMCCLock<GUIDELINE> pGuideLine(lpIMC->hGuideLine);
    if (FAILED(hr = pGuideLine.GetResult())) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: can not lock hGuideLine");
        return hr;
    }

    pGuideLine->dwSize = sizeof(GUIDELINE);

    /*
     * hCandInfo
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hCandInfo, sizeof(CANDIDATEINFO)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hCandInfo failure");
        return hr;
    }

    DIMM_IMCCLock<CANDIDATEINFO> pCandInfo(lpIMC->hCandInfo);
    if (FAILED(hr = pCandInfo.GetResult())) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: can not lock hCandInfo");
        return hr;
    }

    pCandInfo->dwSize = sizeof(CANDIDATEINFO);

    /*
     * hCompStr
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hCompStr, sizeof(COMPOSITIONSTRING_AIMM12)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hCompStr failure");
        return hr;
    }

    DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
    if (FAILED(hr = lpCompStr.GetResult())) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: can not lock hCompStr");
        return hr;
    }

    lpCompStr->CompStr.dwSize = sizeof(COMPOSITIONSTRING_AIMM12);

    /*
     * AIME private context.
     */
    if (lpIMC->m_pContext != NULL) {
        hr = lpIMC->m_pContext->UpdateAImeContext(hIMC);
    }

    return hr;
}

HRESULT
CInputContext::ResizePrivateIMCC(
    IN HIMC hIMC,
    IN DWORD dwPrivateSize
    )
{
    HRESULT hr;

    // Make sure Private context data size
    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    return UpdateIMCC(&imc->hPrivate, dwPrivateSize);
}

HRESULT
CInputContext::UpdateIMCC(
    IN HIMCC* phIMCC,
    IN DWORD  dwRequestSize
    )
{
    HRESULT hr;
    DWORD dwSize;
    DWORD dwLockCount;
    const DWORD IMCC_ALLOC_TOOLARGE = 0x1000;

    if (*phIMCC == NULL) {
        hr = CreateIMCC(dwRequestSize, phIMCC);
    }
    else {

        hr = GetIMCCSize(*phIMCC, &dwSize);
        if (SUCCEEDED(hr)) {
            if (dwSize < dwRequestSize ||
                dwSize > IMCC_ALLOC_TOOLARGE) {
                hr = GetIMCCLockCount(*phIMCC, &dwLockCount);
                if (SUCCEEDED(hr)) {
                    ASSERT(dwLockCount == 0);
                    if (dwLockCount != 0) {
                        TraceMsg(TF_ERROR, "CInputContext::UpdateIMCC: Unlock resource");

                        do {
                            if (FAILED(hr = _UnlockIMCC(*phIMCC)))
                                return hr;

                            if (FAILED(hr = GetIMCCLockCount(*phIMCC, &dwLockCount)))
                                return hr;
                        } while(dwLockCount);

                        if (SUCCEEDED(hr = DestroyIMCC(*phIMCC)))
                            hr = CreateIMCC(dwRequestSize, phIMCC);
                    }
                    else {
                        HIMCC hResizeIMCC;
                        hr = ReSizeIMCC(*phIMCC, dwRequestSize, &hResizeIMCC);
                        if (SUCCEEDED(hr)) {
                            *phIMCC = hResizeIMCC;
                        }
                        else {
                            TraceMsg(TF_WARNING, "CInputContext::UpdateIMCC: Resize hIMCC %lX failure", dwRequestSize);

                            if (SUCCEEDED(hr = DestroyIMCC(*phIMCC)))
                                hr = CreateIMCC(dwRequestSize, phIMCC);
                        }
                    }
                }
            }
        }
    }

    return hr;
}


BOOL
CInputContext::EnumInputContext(
    DWORD idThread,
    IMCENUMPROC lpfn,
    LPARAM lParam
    )
{
    UINT cHimc;

    /*
     * Get the hIMC list. It is returned in a block of memory allocated.
     */
    if ((cHimc = BuildHimcList(idThread, NULL)) == 0) {
        return FALSE;
    }

    BOOL fSuccess = FALSE;

    HIMC* pHimc = new HIMC[cHimc];
    if (pHimc) {
        BuildHimcList(idThread, pHimc);

        /*
         * Loop through the input contexts, call the function pointer back for each one.
         * End loop if either FALSE is returned or the end-of-list is reached.
         */
        UINT index;
        for (index = 0; index < cHimc; index++) {
            if (! (fSuccess = (*lpfn)(pHimc[index], lParam)) )
                break;
        }

        /*
         * Free up buffer and return status - TRUE if entire list was enumerated,
         * FALSE otherwise.
         */
        delete [] pHimc;
    }

    return fSuccess;
}

DWORD
CInputContext::BuildHimcList(
    DWORD idThread,
    HIMC pHimc[]
    )
{
    if (idThread != 0 && idThread != GetCurrentThreadId())
        return 0;

    if (pHimc != NULL) {
        POSITION pos = ContextList.GetStartPosition();
        int index;
        for (index = 0; index < ContextList.GetCount(); index++) {
            ContextList.GetNextHimc(pos, &pHimc[index]);
        }
    }
    return (DWORD)(ContextList.GetCount());
}

/*
 * AIMM Input Context (hIMC) API Methods.
 */
HRESULT
CInputContext::CreateContext(
    IN DWORD dwPrivateSize,
    IN BOOL fUnicode,
    OUT HIMC *phIMC,
    IN BOOL fCiceroActivated,
    IN DWORD fdwInitConvMode,
    IN BOOL fInitOpen
    )
{
    TraceMsg(TF_API, TEXT("CInputContext::CreateContext"));

    *phIMC = NULL;

    if (IsOnImm()) {

        // defer to the system IMM
        HRESULT hr;
        CActiveIMM *_pActiveIMM = GetTLS();
        if (_pActiveIMM == NULL)
            return E_FAIL;

        if (FAILED(hr = Imm32_CreateContext(phIMC)))
            return hr;

        CContextList::CLIENT_IMC_FLAG client_flag = (fUnicode ? CContextList::IMCF_UNICODE
                                                              : CContextList::IMCF_NONE   );
        ContextList.SetAt(*phIMC, client_flag);

        // we can't create the cicero context until ITfThreadMgr::Activate has been called
        // we'll do this later if we need to
        if (fCiceroActivated)
        {
            if (FAILED(hr=CreateAImeContext(*phIMC))) {
                Imm32_DestroyContext(*phIMC);
                ContextList.RemoveKey(*phIMC);
                return hr;
            }
        }

        _pActiveIMM->_ResizePrivateIMCC(*phIMC, dwPrivateSize);
    }
    else {
        HIMC hIMC = static_cast<HIMC>(LocalAlloc(LHND, sizeof(INPUTCONTEXT_AIMM12)));

        CContextList::CLIENT_IMC_FLAG client_flag = (fUnicode ? CContextList::IMCF_UNICODE
                                                              : CContextList::IMCF_NONE   );
        ContextList.SetAt(hIMC, client_flag);

        /*
         * Ready to use hIMC
         */
        DIMM_IMCLock lpIMC(hIMC);
        if (lpIMC.Valid()) {
            //
            // Initialize context data.
            //
            lpIMC->dwNumMsgBuf = 0;
            lpIMC->fOpen = fInitOpen;
            lpIMC->fdwConversion = fdwInitConvMode;
            lpIMC->fdwSentence = 0;
            lpIMC->m_pContext = NULL;

            for (UINT i = 0; i < 4; i++) {
                lpIMC->cfCandForm[i].dwIndex = (DWORD)(-1);
            }

            HRESULT hr;

            // we can't create the cicero context until ITfThreadMgr::Activate has been called
            // we'll do this later if we need to
            if (fCiceroActivated)
            {
                if (FAILED(hr=CreateAImeContext(hIMC))) {
                    DestroyContext(hIMC);
                    return hr;
                }
            }

            if (FAILED(CreateIMCC(sizeof(COMPOSITIONSTRING_AIMM12), &lpIMC->hCompStr)) ||
                FAILED(CreateIMCC(sizeof(CANDIDATEINFO), &lpIMC->hCandInfo))           ||
                FAILED(CreateIMCC(sizeof(GUIDELINE), &lpIMC->hGuideLine))              ||
                FAILED(CreateIMCC(sizeof(DWORD), &lpIMC->hMsgBuf))                     ||
                FAILED(CreateIMCC(dwPrivateSize, &lpIMC->hPrivate))                       ) {

                DestroyContext((HIMC)lpIMC);

                return E_OUTOFMEMORY;
            }
            else {
                *phIMC = hIMC;
            }
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

HRESULT
CInputContext::DestroyContext(
    IN HIMC hIMC
    )
{
    TraceMsg(TF_API, "CInputContext::DestroyContext");

    if (IsOnImm()) {
        HRESULT hr;

        if (FAILED(hr=DestroyAImeContext(hIMC)))
            return hr;

        ContextList.RemoveKey(hIMC);

        return Imm32_DestroyContext(hIMC);
    }
    else {
        {
            DIMM_IMCLock pIMC(hIMC);
            if (!pIMC.Valid())
                return E_FAIL;

            if (FAILED(DestroyIMCC(pIMC->hCompStr))   ||
                FAILED(DestroyIMCC(pIMC->hCandInfo))  ||
                FAILED(DestroyIMCC(pIMC->hGuideLine)) ||
                FAILED(DestroyIMCC(pIMC->hMsgBuf))    ||
                FAILED(DestroyIMCC(pIMC->hPrivate))     ) {
                return E_FAIL;
            }
            HRESULT hr;
            if (FAILED(hr=DestroyAImeContext(hIMC)))
                return hr;

            ContextList.RemoveKey(hIMC);
        } // pIMC dtor called here!  We must unlock hIMC before calling LocalFree

        return LocalFree(hIMC) ? E_FAIL : S_OK;
    }
}

HRESULT
CInputContext::AssociateContext(
    IN HWND hWnd,
    IN HIMC hIMC,
    OUT HIMC *phPrev
    )
{
    TraceMsg(TF_API, "CInputContext::AssociateContext");

    if (!IsWindow(hWnd))
        return E_INVALIDARG;

    DWORD dwProcessId;
    if (hIMC && ! ContextLookup(hIMC, &dwProcessId))
        return E_ACCESSDENIED;

    HRESULT hr = GetContext(hWnd, phPrev);

    AssociateList.SetAt(hWnd, hIMC);

    return hr;
}

HRESULT
CInputContext::AssociateContextEx(
    IN HWND hWnd,
    IN HIMC hIMC,
    IN DWORD dwFlags
    )
{
    TraceMsg(TF_API, "CInputContext::AssociateContextEx");
    return E_NOTIMPL;
}

HRESULT
CInputContext::GetContext(
    IN HWND hWnd,
    OUT HIMC* phIMC
    )
{
    TraceMsg(TF_API, "CInputContext::GetContext");

    if (hWnd == NULL || ! IsWindow(hWnd)) {
        TraceMsg(TF_WARNING, "CInputContext::GetContext: Invalid window handle %x", hWnd);
        return E_FAIL;
    }

    HIMC hIMC = _hDefaultIMC;
    BOOL ret = AssociateList.Lookup(hWnd, hIMC);
    if (! ret) {
        if (IsOnImm()) {
            Imm32_GetContext(hWnd, &hIMC);

            if (hIMC) {
                /*
                 * Guaranty of Win98 IMM code that Win98 have a reference count
                 * of GetContext/ReleaseContext. If under ref cnt occurred, then
                 * apps had the AV in the IMM code.
                 * Because it ref cnt keeps the 32bit hIMC data segment for refer
                 * from 16bit code. When ref cnt is zero, hIMC's data segment has been freed.
                 * Of course, AIMM1.2's ReleaseContext nothing else to do.
                 */
                Imm32_ReleaseContext(hWnd, hIMC);
            }
        }
    }
    *phIMC = hIMC;

    return S_OK;
}

HRESULT
CInputContext::GetIMCLockCount(
    IN HIMC hIMC,
    OUT DWORD* pdwLockCount
    )
{
    TraceMsg(TF_API, "CInputContext::GetIMCLockCount");

    if (IsOnImm()) {
        return Imm32_GetIMCLockCount(hIMC, pdwLockCount);
    }
    else {
        *pdwLockCount = LocalFlags(hIMC) & LMEM_LOCKCOUNT;
        return S_OK;
    }
}

HRESULT
CInputContext::CreateAImeContext(
    HIMC hIMC
    )
{
    HRESULT hr;

    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    IAImeContext* pAImeContext;
    extern HRESULT CAImeContext_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    hr = CAImeContext_CreateInstance(NULL, IID_IAImeContext, (void**)&pAImeContext);

    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CreateAImeContext failed");
        return hr;
    }

    return pAImeContext->CreateAImeContext(hIMC, m_pActiveIME);
}

HRESULT
CInputContext::DestroyAImeContext(
    HIMC hIMC
    )
{
    HRESULT hr;
    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    // imc->m_pContext may be NULL if ITfThreadMgr::Activate has not been called
    if (imc->m_pContext == NULL)
        return S_OK;

    //
    // Backup IAImeContext pointer and NULL out in imc->m_pContext.
    // DestroyAImeContext::pdim->Pop maybe calls ActivateAssembly if it is in queueing.
    // ActivateAssembly maybe changes keyboard layout between Cicero and Real IME hKL.
    // It happens called ImeActivateLayout from IMM32 and this function updates input context.
    // However, imc->m_pContext's object already gone and occurred AV when touch NULL object.
    // This NULL out is previent AV in the imc->m_pContext object.
    //
    IAImeContext* pContext = imc->m_pContext;
    imc->m_pContext = NULL;

    hr = pContext->DestroyAImeContext(hIMC);

    pContext->Release();

    return hr;
}


/*
 * AIMM Input Context Components (hIMCC) API Methods.
 */
HRESULT
CInputContext::CreateIMCC(
    IN DWORD dwSize,
    OUT  HIMCC *phIMCC
    )
{
    TraceMsg(TF_API, "CInputContext::CreateIMCC");

    if (IsOnImm()) {
        return Imm32_CreateIMCC(dwSize, phIMCC);
    }
    else {
        if ((*phIMCC = static_cast<HIMCC>(LocalAlloc(LHND, dwSize+sizeof(DWORD)))) == NULL)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CInputContext::DestroyIMCC(
    IN HIMCC hIMCC
    )
{
    TraceMsg(TF_API, "CInputContext::DestroyIMCC");

    if (IsOnImm()) {
        return Imm32_DestroyIMCC(hIMCC);
    }
    else {
        return LocalFree(hIMCC) ? E_FAIL : S_OK;
    }

    return S_OK;
}

HRESULT
CInputContext::GetIMCCSize(
    IN HIMCC hIMCC,
    OUT DWORD *pdwSize
    )
{
    TraceMsg(TF_API, "CInputContext::GetIMCCSize");

    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    if (IsOnImm()) {
        return Imm32_GetIMCCSize(hIMCC, pdwSize);
    }
    else {
        *pdwSize = (DWORD)LocalSize(hIMCC);
    }

    return S_OK;
}

HRESULT
CInputContext::ReSizeIMCC(
    IN HIMCC hIMCC,
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )
{
    TraceMsg(TF_API, "CInputContext::ReSizeIMCC");

    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    if (IsOnImm()) {
        return Imm32_ReSizeIMCC(hIMCC, dwSize, phIMCC);
    }
    else {
        if ((*phIMCC = (HIMCC)LocalReAlloc(hIMCC, dwSize+sizeof(DWORD), LHND)) == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

HRESULT
CInputContext::GetIMCCLockCount(
    IN HIMCC hIMCC,
    OUT DWORD* pdwLockCount
    )
{
    TraceMsg(TF_API, "CInputContext::GetIMCLockCount");

    if (IsOnImm()) {
        return Imm32_GetIMCCLockCount(hIMCC, pdwLockCount);
    }
    else {
        *pdwLockCount = LocalFlags(hIMCC) & LMEM_LOCKCOUNT;
        return S_OK;
    }
}


/*
 * AIMM Open Status API Methods
 */
HRESULT
CInputContext::GetOpenStatus(
    IN HIMC hIMC
    )
{
    TraceMsg(TF_API, "CInputContext::GetOpenStatus");

    DIMM_IMCLock lpIMC(hIMC);
    if (lpIMC.Invalid())
        return E_FAIL;

    return (lpIMC->fOpen ? S_OK : S_FALSE);
}

HRESULT
CInputContext::SetOpenStatus(
    IN DIMM_IMCLock& lpIMC,
    IN BOOL fOpen,
    OUT BOOL* pfOpenChg
    )
{
    DWORD dwOpenStatus;
    DWORD dwConversion;

    TraceMsg(TF_API, "CInputContext::SetOpenStatus");

    *pfOpenChg = FALSE;

    if (lpIMC->fOpen != fOpen) {
        lpIMC->fOpen = fOpen;
        *pfOpenChg = TRUE;
    }

    if (*pfOpenChg) {
        dwOpenStatus = (DWORD)lpIMC->fOpen;
        dwConversion = (DWORD)lpIMC->fdwConversion;
    }

    return S_OK;
}

/*
 * AIMM Conversion Status API Methods
 */
HRESULT
CInputContext::GetConversionStatus(
    IN HIMC hIMC,
    OUT LPDWORD lpfdwConversion,
    OUT LPDWORD lpfdwSentence
    )
{
    TraceMsg(TF_API, "CInputContext::GetConversionStatus");

    if (IsOnImm()) {
        return Imm32_GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
    }

    DIMM_IMCLock pIMC(hIMC);
    if (pIMC.Invalid())
        return E_FAIL;

    *lpfdwSentence = pIMC->fdwSentence;
    *lpfdwConversion = pIMC->fdwConversion;

    return S_OK;
}

HRESULT
CInputContext::SetConversionStatus(
    IN DIMM_IMCLock& lpIMC,
    IN DWORD fdwConversion,
    IN DWORD fdwSentence,
    OUT BOOL* pfConvModeChg,
    OUT BOOL* pfSentenceChg,
    OUT DWORD* pfdwOldConversion,
    OUT DWORD* pfdwOldSentence
    )
{
    DWORD dwOpenStatus;
    DWORD dwConversion;

    TraceMsg(TF_API, "CInputContext::SetConversionStatus");

    if (fdwConversion != lpIMC->fdwConversion) {
        if ((fdwConversion & IME_CMODE_LANGUAGE) == IME_CMODE_KATAKANA) {
            TraceMsg(TF_WARNING, "SetConversionStatus: wrong fdwConversion");
        }
        *pfdwOldConversion = lpIMC->fdwConversion;
        lpIMC->fdwConversion = fdwConversion;
        *pfConvModeChg = TRUE;
    }

    if (fdwSentence != lpIMC->fdwSentence) {
        *pfdwOldSentence = lpIMC->fdwSentence;
        lpIMC->fdwSentence = fdwSentence;
        *pfSentenceChg = TRUE;
    }

    if (*pfConvModeChg) {
        dwOpenStatus = (DWORD)lpIMC->fOpen;
        dwConversion = lpIMC->fdwConversion;
    }

    return S_OK;
}

/*
 * AIMM Status Window Pos API Methods
 */
HRESULT WINAPI
CInputContext::GetStatusWindowPos(
    IN HIMC hIMC,
    OUT LPPOINT lpCandidate
    )
{
    TraceMsg(TF_API, "CInputContext::GetStatusWindowPos");

    if (IsOnImm()) {
        return Imm32_GetStatusWindowPos(hIMC, lpCandidate);
    }

    if (hIMC == NULL)
        return E_INVALIDARG;

    DIMM_IMCLock pIMC(hIMC);
    if (pIMC.Invalid())
        return E_FAIL;

    if (pIMC->fdwInit & INIT_STATUSWNDPOS) {
        *lpCandidate = pIMC->ptStatusWndPos;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT
CInputContext::SetStatusWindowPos(
    IN DIMM_IMCLock& lpIMC,
    IN LPPOINT lpptPos
    )
{
    TraceMsg(TF_API, "CInputContext::SetStatusWindowPos");

    lpIMC->ptStatusWndPos = *lpptPos;
    lpIMC->fdwInit |= INIT_STATUSWNDPOS;

    return S_OK;
}

/*
 * AIMM Composition String API Methods
 */
HRESULT
CInputContext::GetCompositionString(
    IN DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
    IN DWORD dwIndex,
    IN LONG*& lpCopied,
    IN size_t size
    )
{
    HRESULT hr;

    TraceMsg(TF_API, "CInputContext::GetCompositionStringA(LONG*)");

    switch (dwIndex) {
        case GCS_COMPSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompStrLen, lpCopied);
            break;
        case GCS_COMPREADSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompReadStrLen, lpCopied);
            break;
        case GCS_RESULTSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultStrLen, lpCopied);
            break;
        case GCS_RESULTREADSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultReadStrLen, lpCopied);
            break;

        case GCS_COMPATTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompAttrLen, lpCopied);
            break;
        case GCS_COMPREADATTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompReadAttrLen, lpCopied);
            break;
        case GCS_COMPREADCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompReadClauseLen, lpCopied);
            break;
        case GCS_RESULTCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultClauseLen, lpCopied);
            break;
        case GCS_RESULTREADCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultReadClauseLen, lpCopied);
            break;
        case GCS_COMPCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompClauseLen, lpCopied);
            break;

        case GCS_CURSORPOS:
            *lpCopied = lpCompStr->CompStr.dwCursorPos;
            hr = S_OK;
            break;
        case GCS_DELTASTART:
            *lpCopied = lpCompStr->CompStr.dwDeltaStart;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            *lpCopied = IMM_ERROR_GENERAL; // ala Win32
            break;
    }

    return hr;
}


/*
 * AIMM Composition Font API Methods
 */
HRESULT
CInputContext::GetCompositionFont(
    IN DIMM_IMCLock& lpIMC,
    OUT LOGFONTAW* lplf,
    IN BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetCompositionFont");

    if ((lpIMC->fdwInit & INIT_LOGFONT) == INIT_LOGFONT) {
        if (fUnicode)
            *(&lplf->W) = lpIMC->lfFont.W;
        else
            *(&lplf->A) = lpIMC->lfFont.A;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT
CInputContext::SetCompositionFont(
    IN DIMM_IMCLock& lpIMC,
    IN LOGFONTAW* lplf,
    IN BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::SetCompositionFont");

    if (fUnicode)
        lpIMC->lfFont.W = *(&lplf->W);
    else
        lpIMC->lfFont.A = *(&lplf->A);
    lpIMC->fdwInit |= INIT_LOGFONT;

    return S_OK;
}


/*
 * AIMM Composition Window API Method
 */
HRESULT
CInputContext::GetCompositionWindow(
    IN HIMC hIMC,
    OUT LPCOMPOSITIONFORM lpCompForm
    )
{
    TraceMsg(TF_API, "CInputContext::GetCompositionWindow");

    if (IsOnImm()) {
        return Imm32_GetCompositionWindow(hIMC, lpCompForm);
    }
    else {
        HRESULT hr;
        DIMM_IMCLock pIMC(hIMC);
        if (FAILED(hr = pIMC.GetResult()))
            return hr;

        if ((pIMC->fdwInit & INIT_COMPFORM) == INIT_COMPFORM) {
            *lpCompForm = pIMC->cfCompForm;
            return S_OK;
        }
    }
    return E_FAIL;

}

HRESULT
CInputContext::SetCompositionWindow(
    IN DIMM_IMCLock& lpIMC,
    IN LPCOMPOSITIONFORM lpCompForm
    )
{
    TraceMsg(TF_API, "CInputContext::SetCompositionWindow");

    lpIMC->cfCompForm = *lpCompForm;
    lpIMC->fdwInit |= INIT_COMPFORM;

    return S_OK;
}

/*
 * AIMM Candidate List API Methods
 */
HRESULT
CInputContext::GetCandidateList(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPCANDIDATELIST lpCandList,
    OUT UINT* puCopied,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetCandidateList");
    return E_NOTIMPL;
}

HRESULT
CInputContext::GetCandidateListCount(
    IN HIMC hIMC,
    OUT DWORD* lpdwListSize,
    OUT DWORD* pdwBufLen,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetCandidateListCount");
    return E_NOTIMPL;
}

/*
 * AIMM Candidate Window API Methods
 */
HRESULT
CInputContext::GetCandidateWindow(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT LPCANDIDATEFORM lpCandidate
    )
{
    TraceMsg(TF_API, "CInputContext::GetCandidateWindow");

    if (IsOnImm()) {
        return Imm32_GetCandidateWindow(hIMC, dwIndex, lpCandidate);
    }
    else {
        HRESULT hr;
        DIMM_IMCLock pIMC(hIMC);
        if (FAILED(hr = pIMC.GetResult()))
            return hr;

        if (pIMC->cfCandForm[dwIndex].dwIndex == -1) {
            return E_FAIL;
        }

        *lpCandidate = pIMC->cfCandForm[dwIndex];
    }

    return S_OK;
}

HRESULT
CInputContext::SetCandidateWindow(
    IN DIMM_IMCLock& lpIMC,
    IN LPCANDIDATEFORM lpCandForm
    )
{
    TraceMsg(TF_API, "CInputContext::SetCandidateWindow");
    lpIMC->cfCandForm[lpCandForm->dwIndex] = *lpCandForm;
    return S_OK;
}

/*
 * AIMM Guide Line API Methods
 */
HRESULT
CInputContext::GetGuideLine(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT CHARAW* lpBuf,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetGuideLine");
    return E_NOTIMPL;
}


/*
 * AIMM Notify IME API Method
 */
HRESULT
CInputContext::NotifyIME(
    IN HIMC hIMC,
    IN DWORD dwAction,
    IN DWORD dwIndex,
    IN DWORD dwValue
    )
{
    TraceMsg(TF_API, "CInputContext::NotifyIME");

    if (IsOnImm()) {
        return Imm32_NotifyIME(hIMC, dwAction, dwIndex, dwValue);
    }
    return E_NOTIMPL;
}

/*
 * AIMM Menu Items API Methods
 */
HRESULT
CInputContext::GetImeMenuItems(
    IN HIMC hIMC,
    IN DWORD dwFlags,
    IN DWORD dwType,
    IN IMEMENUITEMINFOAW *pImeParentMenu,
    OUT IMEMENUITEMINFOAW *pImeMenu,
    IN DWORD dwSize,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetImeMenuItems");
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\cdimm.h ===
//+---------------------------------------------------------------------------
//
//  File:       cdimm.h
//
//  Contents:   CActiveIMM
//
//----------------------------------------------------------------------------

#ifndef CDIMM_H
#define CDIMM_H

#include "msctfp.h"
#include "cimm32.h"
#include "uiwnd.h"
#include "context.h"
#include "imewnd.h"
#include "globals.h"

typedef struct tagSELECTCONTEXT_ENUM SCE, *PSCE;

#define CALLWNDPROC_HOOK

/*
 * Windows hook
 */
typedef enum {
    // array indices for thread hooks
#if 0
    TH_GETMSG,
#endif
    TH_DEFIMEWNDPROC,
#ifdef CALLWNDPROC_HOOK
    TH_WNDPROC,
#endif // CALLWNDPROC_HOOK
    TH_NUMHOOKS
} HookType;

typedef struct tagIMEINFOEX
{
    IMEINFO      ImeInfo;         // IMEINFO structure.
    WCHAR        achWndClass[16];
    DWORD        dwPrivate;
} IMEINFOEX;

//+---------------------------------------------------------------------------
//
// CActiveIMM
//
//----------------------------------------------------------------------------

class CActiveIMM : public IActiveIMMIME_Private,
                   public ITfSysHookSink
{
public:
    CActiveIMM();
    ~CActiveIMM();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IActiveIMMApp/IActiveIMM methods
    //

    /*
     * AIMM Input Context (hIMC) Methods.
     */
    STDMETHODIMP CreateContext(HIMC *phIMC);
    STDMETHODIMP DestroyContext(HIMC hIME);
    STDMETHODIMP AssociateContext(HWND hWnd, HIMC hIME, HIMC *phPrev);
    STDMETHODIMP AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags);
    STDMETHODIMP GetContext(HWND hWnd, HIMC *phIMC);
    STDMETHODIMP ReleaseContext(HWND hWnd, HIMC hIMC);
    STDMETHODIMP GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC);
    STDMETHODIMP UnlockIMC(HIMC hIMC);

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    STDMETHODIMP CreateIMCC(DWORD dwSize, HIMCC *phIMCC);
    STDMETHODIMP DestroyIMCC(HIMCC hIMCC);
    STDMETHODIMP GetIMCCSize(HIMCC hIMCC,  DWORD *pdwSize);
    STDMETHODIMP ReSizeIMCC(HIMCC hIMCC, DWORD dwSize,  HIMCC *phIMCC);
    STDMETHODIMP GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMCC(HIMCC hIMCC, void **ppv);
    STDMETHODIMP UnlockIMCC(HIMCC hIMCC);

    /*
     * AIMM Open Status API Methods
     */
    STDMETHODIMP GetOpenStatus(HIMC hIMC);
    STDMETHODIMP SetOpenStatus(HIMC hIMC, BOOL fOpen);

    /*
     * AIMM Conversion Status API Methods
     */
    STDMETHODIMP GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion,  DWORD *lpfdwSentence);
    STDMETHODIMP SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence);

    /*
     * AIMM Status Window Pos API Methods
     */
    STDMETHODIMP GetStatusWindowPos(HIMC hIMC, POINT *lpptPos);
    STDMETHODIMP SetStatusWindowPos(HIMC hIMC, POINT *lpptPos);

    /*
     * AIMM Composition String API Methods
     */
    STDMETHODIMP GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
    STDMETHODIMP SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);

    /*
     * AIMM Composition Font API Methods
     */
    STDMETHODIMP GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);
    STDMETHODIMP SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);

    /*
     * AIMM Composition Window API Methods
     */
    STDMETHODIMP GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);
    STDMETHODIMP SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);

    /*
     * AIMM Candidate List API Methods
     */
    STDMETHODIMP GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);
    STDMETHODIMP GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);

    /*
     * AIMM Candidate Window API Methods
     */
    STDMETHODIMP GetCandidateWindow(HIMC hIMC, DWORD dwBufLen, CANDIDATEFORM *lpCandidate);
    STDMETHODIMP SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate);

    /*
     * AIMM Guide Line API Methods
     */
    STDMETHODIMP GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult);
    STDMETHODIMP GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult);

    /*
     * AIMM Notify IME API Method
     */
    STDMETHODIMP NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    /*
     * AIMM Menu Items API Methods
     */
    STDMETHODIMP GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult);
    STDMETHODIMP GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult);

    /*
     * AIMM Register Word API Methods
     */
    STDMETHODIMP RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister);
    STDMETHODIMP RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister);
    STDMETHODIMP UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister);
    STDMETHODIMP UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister);
    STDMETHODIMP EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum);
    STDMETHODIMP EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum);
    STDMETHODIMP GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied);
    STDMETHODIMP GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied);

    /*
     * AIMM Configuration API Methods.
     */
    STDMETHODIMP ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
    STDMETHODIMP ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);
    STDMETHODIMP GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty);
    STDMETHODIMP IsIME(HKL hKL);

    // others
    STDMETHODIMP EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd);
    STDMETHODIMP GetVirtualKey(HWND hWnd, UINT *puVirtualKey);
    STDMETHODIMP IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);

    // ime helper methods
    STDMETHODIMP GenerateMessage(HIMC hIMC);

    // hot key manipulation api's
    STDMETHODIMP GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL);
    STDMETHODIMP SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL);
    STDMETHODIMP SimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

    // win98/nt5 apis
    STDMETHODIMP DisableIME(DWORD idThread);
    STDMETHODIMP RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum);

    // methods without corresponding IMM APIs

    //
    // IActiveIMMApp methods
    //

    HRESULT Activate(BOOL fRestoreLayout);
    HRESULT Deactivate();

    HRESULT OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    //
    // ITfPreFocusDIM methods
    //
    STDMETHODIMP OnPreFocusDIM(HWND hWnd);
    STDMETHODIMP OnSysKeyboardProc(WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnSysShellProc(int nCode, WPARAM wParam, LPARAM lParam);

    HRESULT QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IActiveIMMAppEx
    //
    STDMETHODIMP FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap);
    STDMETHODIMP FilterClientWindows(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);
    STDMETHODIMP GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom);
    STDMETHODIMP UnfilterClientWindowsEx(HWND hWnd);

    HRESULT SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
    {
        if (!_pActiveIME)
            return E_FAIL;

        return _pActiveIME->SetThreadCompartmentValue(rguid, pvar);
    }

    HRESULT GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
    {
        if (!_pActiveIME)
            return E_FAIL;

        return _pActiveIME->GetThreadCompartmentValue(rguid, pvar);
    }

    HRESULT _Init();

    void _ActivateLayout(HKL hSelKL = NULL, HKL hUnSelKL = NULL);
    void _DeactivateLayout(HKL hSelKL = NULL, HKL hUnSelKL = NULL);

    HRESULT _GetKeyboardLayout(HKL* phkl);

    HRESULT _AImeAssociateFocus(HWND hWnd, HIMC hIMC, DWORD dwFlags);

    BOOL _ContextLookup(HIMC hIMC, DWORD* pdwProcess, BOOL* pfUnicode = NULL)
    {
        return _InputContext.ContextLookup(hIMC, pdwProcess, pfUnicode);
    }
    BOOL _ContextLookup(HIMC hIMC, HWND* phImeWnd)
    {
        return _InputContext.ContextLookup(hIMC, phImeWnd);
    }

    void _ContextUpdate(HIMC hIMC, HWND& hImeWnd)
    {
        if (!_IsRealIme())
        {
            _InputContext.ContextUpdate(hIMC, hImeWnd);
        }
    }

    HRESULT GetContextInternal(HWND hWnd, HIMC *phIMC, BOOL fGetDefIMC);

    HRESULT _ResizePrivateIMCC(IN HIMC hIMC, IN DWORD dwPrivateSize);

    DWORD _GetIMEWndClassName(HKL hKL, LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate);

    LRESULT _CallWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT _ImeSelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, HIMC hIMC);
    void _ImeWndFinalDestroyHandler();

    LRESULT _SendUIMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE);

    BOOL _IsRealIme(HKL hkl = NULL);

    STDMETHODIMP IsRealImePublic(BOOL *pfReal);

private:

    // windows hooks
#if 0
    static LRESULT CALLBACK _GetMsgProc(int nCode, WPARAM wParam, LPARAM lParam);
#endif
    static LRESULT CALLBACK _CallWndProc(int nCode, WPARAM wParam, LPARAM lParam);

    // windows WH_CALLWNDPROCRET hook for Default IME Window
    static LRESULT CALLBACK _DefImeWnd_CallWndProc(int nCode, WPARAM wParam, LPARAM lParam);

    // EnumInputContext call back methods
    static BOOL _SelectContextProc(HIMC hIMC, LPARAM lParam);
    static BOOL _UnSelectContextProc(HIMC hIMC, LPARAM lParam);
    static BOOL _NotifyIMEProc(HIMC hIMC, LPARAM lParam);
    static BOOL _EnumContextProc(HIMC hIMC, LPARAM lParam);
#ifdef UNSELECTCHECK
    static BOOL _UnSelectCheckProc(HIMC hIMC, LPARAM lParam);
#endif UNSELECTCHECK

    HRESULT _ProcessKey(WPARAM *pwParam, LPARAM *plParam, BOOL fNoMsgPump);
    HRESULT _ToAsciiEx(WPARAM wParam, LPARAM lParam);
    void _KbdTouchUp(BYTE *abKbdState, WPARAM wParam, LPARAM lParam);


    void _AimmPostMessage(HWND, INT, LPTRANSMSG, DIMM_IMCLock&);
    void _AimmSendMessage(HWND, INT, LPTRANSMSG, DIMM_IMCLock&);
    void _AimmPostSendMessageA(HWND, UINT, WPARAM, LPARAM, DIMM_IMCLock&, BOOL fPost = FALSE);

    BOOL IsPresent(HWND hWnd, BOOL fExcludeAIMM)
    {
        BOOL fGuidMap;

        if (_mapFilterWndEx.Lookup(hWnd, fGuidMap)) {
            return TRUE;
        }
        if (g_ProcessIMM)
        {
            return g_ProcessIMM->_FilterList._IsPresent(hWnd, _mapWndFocus, fExcludeAIMM, GetAssociated(hWnd));
        }
        return FALSE;
    }

    BOOL IsGuidMapEnable(HWND hWnd)
    {
        if (_fEnableGuidMap) {
            BOOL fGuidMap;

            if (_mapFilterWndEx.Lookup(hWnd, fGuidMap)) {
                return fGuidMap;
            }
            if (g_ProcessIMM &&
                g_ProcessIMM->_FilterList._IsGuidMapEnable(hWnd, fGuidMap)) {
                return fGuidMap;
            }
        }

        return FALSE;
    }

    HIMC _GetActiveContext()
    {
        HIMC hIMC;

        if (_hFocusWnd == 0)
            return 0;

        return _InputContext.GetContext(_hFocusWnd, &hIMC) == S_OK ? hIMC : 0;
    }

    void _OnImeSelect(HKL hSelKL);
    void _OnImeUnselect(HKL hUnSelKL);
    void _OnImeActivateThreadLayout(HKL hSelKL);

    BOOL _InitHooks();
    void _UninitHooks();

    HRESULT _AImeSelect(HIMC hIMC, DWORD fSelect, BOOL bIsRealIme_SelKL = TRUE, BOOL bIsRealIme_UnSelKL = TRUE)
    {
        DWORD dwFlags = 0;

        if (hIMC == DEFAULT_HIMC)
            hIMC = _InputContext._GetDefaultHIMC();

        if (fSelect)
            dwFlags |= AIMMP_SE_SELECT;

        if (hIMC)
        {
            HRESULT hr;
            DIMM_IMCLock lpIMC(hIMC);
            if (FAILED(hr = lpIMC.GetResult()))
                return hr;

            if (IsPresent(lpIMC->hWnd, TRUE))
                dwFlags |= AIMMP_SE_ISPRESENT;
 
        }
        else
        {
            //
            // Select NULL-hIMC, aimm won't do nothing... So we don't need to
            // set this flag.
            //
            // dwFlags |= AIMMP_SE_ISPRESENT;
        }

        return _pActiveIME->SelectEx(hIMC, dwFlags, bIsRealIme_SelKL, bIsRealIme_UnSelKL);
    }

#ifdef UNSELECTCHECK
    HRESULT _AImeUnSelectCheck(HIMC hIMC)
    {

        if (hIMC == DEFAULT_HIMC)
            hIMC = _InputContext._GetDefaultHIMC();

        return _pActiveIME->UnSelectCheck(hIMC);
    }
#endif UNSELECTCHECK


    HRESULT _AImeNotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
    {
        return _pActiveIME->Notify(hIMC == DEFAULT_HIMC ? _InputContext._GetDefaultHIMC() : hIMC,
                                   dwAction, dwIndex, dwValue);
    }

    HRESULT _ToIMEWindow(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT*& plResult, BOOL fUnicode, BOOL fChkIMC = TRUE);

    void _SetMapWndFocus(HWND hWnd);
    void _ResetMapWndFocus(HWND hWnd);

    BOOL _SetHookWndList(HWND hwnd);
    void _RemoveHookWndList(HWND hwnd)
    {
        _HookWndList.RemoveKey(hwnd);
    }

    typedef enum {
        PROP_PRIVATE_DATA_SIZE,
        PROP_IME_PROPERTY,
        PROP_CONVERSION_CAPS,
        PROP_SENTENCE_CAPS,
        PROP_UI_CAPS,
        PROP_SCS_CAPS,
        PROP_SELECT_CAPS
    } PROPERTY_TYPE;

    DWORD _GetIMEProperty(PROPERTY_TYPE iType);

    DWORD _GetIMEWndClassName(LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate);

    BOOL _IsImeClass(HWND hwnd)
    {
        BOOL bIsImeClass;
        if (_HookWndList.Lookup(hwnd, bIsImeClass))
        {
            return bIsImeClass;
        }
        return _SetHookWndList(hwnd);
    }

    LONG _AddActivate()       { return InterlockedIncrement(&_ActivateRefCount); }
    LONG _ReleaseActivate()   { return InterlockedDecrement(&_ActivateRefCount); }
    BOOL _IsAlreadyActivate() { return (_ActivateRefCount != 0); }

    BOOL _OnSetFocus(HWND hWnd, BOOL bIsRealIme);
    void _OnKillFocus(HWND hWnd, BOOL bIsRealIme);

    BOOL _OnFocusMessage(UINT uMsg, HWND hWnd, WPARAM wParam, LPARAM lParam, BOOL bIsRealIme);

    HRESULT _SendIMENotify(HIMC hImc, HWND hWnd, DWORD dwAction, DWORD dwIndex, DWORD dwValue, WPARAM wParam, LPARAM lParam);

    HRESULT _GetCompositionString(HIMC hIMC,
                                  DWORD dwIndex,
                                  DWORD dwCompLen, LONG* lpCopied, LPVOID lpBuf,
                                  BOOL fUnicode);
    HRESULT _SetCompositionString(HIMC hIMC,
                                  DWORD dwIndex,
                                  LPVOID lpComp, DWORD dwCompLen,
                                  LPVOID lpRead, DWORD dwReadLen,
                                  BOOL fUnicode);

    HRESULT _Internal_SetCompositionString(HIMC hIMC,
                                           DWORD dwIndex,
                                           LPVOID lpComp, DWORD dwCompLen,
                                           LPVOID lpRead, DWORD dwReadLen,
                                           BOOL fUnicode,BOOL fNeedAWConversion);
    HRESULT _Internal_SetCompositionAttribute(HIMC hIMC,
                                              DWORD dwIndex,
                                              LPVOID lpComp, DWORD dwCompLen,
                                              LPVOID lpRead, DWORD dwReadLen,
                                              BOOL fUnicode, BOOL fNeedAWConversion);
    HRESULT _Internal_SetCompositionClause(HIMC hIMC,
                                           DWORD dwIndex,
                                           LPVOID lpComp, DWORD dwCompLen,
                                           LPVOID lpRead, DWORD dwReadLen,
                                           BOOL fUnicode, BOOL fNeedAWConversion);
    HRESULT _Internal_ReconvertString(HIMC hIMC,
                                      DWORD dwIndex,
                                      LPVOID lpComp, DWORD dwCompLen,
                                      LPVOID lpRead, DWORD dwReadLen,
                                      BOOL fUnicode, BOOL fNeedAWConversion,
                                      LRESULT* plResult = NULL);
    HRESULT _Internal_CompositionFont(DIMM_IMCLock& imc,
                                      WPARAM wParam, LPARAM lParam,
                                      BOOL fUnicode, BOOL fNeedAWConversion,
                                      LRESULT* plResult);
    HRESULT _Internal_QueryCharPosition(DIMM_IMCLock& imc,
                                        WPARAM wParam, LPARAM lParam,
                                        BOOL fUnicode, BOOL fNeedAWConversion,
                                        LRESULT* plResult);

    HRESULT _GetCompositionFont(HIMC hIMC, LOGFONTAW* lplf, BOOL fUnicode);
    HRESULT _SetCompositionFont(HIMC hIMC, LOGFONTAW* lplf, BOOL fUnicode);
    HRESULT _Escape(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult, BOOL fUnicode);
    HRESULT _ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
    HRESULT _ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);

    HRESULT _RequestMessage(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult, BOOL fUnicode);

    BOOL _CreateActiveIME();
    BOOL _DestroyActiveIME();

    void LFontAtoLFontW(LPLOGFONTA lpLogFontA, LPLOGFONTW lpLogFontW, UINT uCodePage);
    void LFontWtoLFontA(LPLOGFONTW lpLogFontW, LPLOGFONTA lpLogFontA, UINT uCodePage);


    CMap<HWND, HWND, ITfDocumentMgr *, ITfDocumentMgr *> _mapWndFocus;


public:
    void HideOrRestoreToolbarWnd(BOOL fRestore);

    VOID _EnableGuidMap(BOOL fEnableGuidMap)
    {
        _fEnableGuidMap = fEnableGuidMap;
    }

public:
    BOOL _ConnectTIM(IUnknown *punk)
    {
        ITfThreadMgr *tim = NULL;             
        IServiceProvider *psp;

        Assert(_timp == NULL);

        if (punk->QueryInterface(IID_IServiceProvider, (void **)&psp) == S_OK)
        {
            psp->QueryService(GUID_SERVICE_TF, IID_ITfThreadMgr, (void **)&tim);
            psp->Release();
        }

        if (tim)
        {
            tim->QueryInterface(IID_ITfThreadMgr_P, (void **)&_timp);
            tim->Release();
        }

        return _timp != NULL;
    }

    void _UnconnectTIM()
    {
        SafeReleaseClear(_timp);
    }

    ITfDocumentMgr *GetAssociated(HWND hWnd)
    {
        ITfDocumentMgr *dim = NULL;

        if (_timp != NULL)
        {
            _timp->GetAssociated(hWnd, &dim);
        }
        return dim;
    }

    VOID OnExceptionKillFocus()
    {
        if (_timp != NULL)
        {
            _timp->SetFocus(NULL);
        }
    }

    ITfThreadMgr_P *GetTimP() {return _timp;}

private:
    ITfThreadMgr_P *_timp;

public:
    LONG SetUIWindowContext(HIMC hIMC) {
        return _UIWindow.SetUIWindowContext(hIMC);
    }

private:
    CMap<HWND, HWND, BOOL, BOOL>                         _mapFilterWndEx;


    LONG                        _ActivateRefCount;      // Activate reference count.
#if 0
    BOOL                        _fMenuSelected : 1;     // TRUE: windows menu is opened
#endif
    BOOL                        _fEnableGuidMap : 1;    // TRUE: Enable GUID Map attribute

    HWND                        _hFocusWnd;
    HHOOK                       _hHook[TH_NUMHOOKS];
    CMap<HKL, HKL, BOOL, BOOL>  _RealImeList;

    IAImeProfile*               _AImeProfile;

    IActiveIME_Private *        _pActiveIME;
    CMap<HWND, HWND, BOOL, BOOL> _HookWndList;
    CUIWindow                   _UIWindow;
    CDefaultIMEWindow           _DefaultIMEWindow;
    CInputContext               _InputContext; // consider: take a back pointer, make this a derived class or merge
    IMEINFOEX                   _IMEInfoEx;

    LONG                        _cRef;

    // for HideOrRestoreToolbar
    DWORD _dwPrevToolbarStatus;
};

#endif // CDIMM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\context.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    context.h

Abstract:

    This file defines the Input Context Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#include "imclock2.h"
#include "template.h"
#include "delay.h"
#include "ctxtlist.h"
#include "imccomp.h"

const  HIMC  DEFAULT_HIMC = (HIMC)-2;

class CInputContext : public DIMM_IMCLock,
                      public DIMM_InternalIMCCLock
{
public:
    CInputContext();
    virtual ~CInputContext();

    BOOL _IsDefaultContext(IN HIMC hIMC) {
        return hIMC == _hDefaultIMC ? TRUE : FALSE;
    }

    /*
     * AIMM Input Context (hIMC) API Methods.
     */
    HRESULT CreateContext(IN DWORD dwPrivateSize, BOOL fUnicode, OUT HIMC *phIMC, IN BOOL fCiceroActivated, DWORD fdwInitConvMode = 0, BOOL fInitOpen = FALSE);
    HRESULT DestroyContext(IN HIMC hIMC);
    HRESULT AssociateContext(IN HWND, IN HIMC, OUT HIMC *phPrev);
    HRESULT AssociateContextEx(IN HWND, IN HIMC, IN DWORD);
    HRESULT GetContext(IN HWND, OUT HIMC*);
    HRESULT GetIMCLockCount(IN HIMC, OUT DWORD*);

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    HRESULT CreateIMCC(IN DWORD dwSize, OUT HIMCC *phIMCC);
    HRESULT DestroyIMCC(IN HIMCC hIMCC);
    HRESULT GetIMCCSize(IN HIMCC hIMCC, OUT DWORD *pdwSize);
    HRESULT ReSizeIMCC(IN HIMCC hIMCC, IN DWORD dwSize, OUT HIMCC *phIMCC);
    HRESULT GetIMCCLockCount(IN HIMCC, OUT DWORD*);

    /*
     * AIMM Open Status API Methods
     */
    HRESULT GetOpenStatus(IN HIMC);
    HRESULT SetOpenStatus(IN DIMM_IMCLock&, IN BOOL, OUT BOOL*);

    /*
     * AIMM Conversion Status API Methods
     */
    HRESULT GetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
    HRESULT SetConversionStatus(IN DIMM_IMCLock&, IN DWORD, IN DWORD, OUT BOOL*, OUT BOOL*, OUT DWORD*, OUT DWORD*);

    /*
     * AIMM Status Window Pos API Methods
     */
    HRESULT WINAPI GetStatusWindowPos(IN HIMC, OUT LPPOINT);
    HRESULT SetStatusWindowPos(IN DIMM_IMCLock&, IN LPPOINT);

    /*
     * AIMM Composition String API Methods
     */
    HRESULT GetCompositionString(IN DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>&,
                                 IN DWORD, IN LONG*&, IN size_t = sizeof(WORD));
 
    /*
     * AIMM Composition Font API Methods
     */
    HRESULT GetCompositionFont(IN DIMM_IMCLock&, OUT LOGFONTAW* lplf, BOOL fUnicode);
    HRESULT SetCompositionFont(IN DIMM_IMCLock&, IN LOGFONTAW* lplf, BOOL fUnicode);

    /*
     * AIMM Composition Window API Methods
     */
    HRESULT GetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
    HRESULT SetCompositionWindow(IN DIMM_IMCLock&, IN LPCOMPOSITIONFORM);

    /*
     * AIMM Candidate List API Methods
     */
    HRESULT GetCandidateList(IN HIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT LPCANDIDATELIST lpCandList, OUT UINT* puCopied, BOOL fUnicode);
    HRESULT GetCandidateListCount(IN HIMC, OUT DWORD* lpdwListSize, OUT DWORD* pdwBufLen, BOOL fUnicode);

    /*
     * AIMM Candidate Window API Methods
     */
    HRESULT GetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
    HRESULT SetCandidateWindow(IN DIMM_IMCLock&, IN LPCANDIDATEFORM);

    /*
     * AIMM Guide Line API Methods
     */
    HRESULT GetGuideLine(IN HIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT CHARAW* pBuf, OUT DWORD* pdwResult, BOOL fUnicode);

    /*
     * AIMM Notify IME API Method
     */
    HRESULT NotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

    /*
     * AIMM Menu Items API Methods
     */
    HRESULT GetImeMenuItems(IN HIMC, IN DWORD dwFlags, IN DWORD dwType, IN IMEMENUITEMINFOAW *pImeParentMenu, OUT IMEMENUITEMINFOAW *pImeMenu, IN DWORD dwSize, OUT DWORD* pdwResult, BOOL fUnicode);

    /*
     * Context Methods
     */
    BOOL ContextLookup(HIMC hIMC, DWORD* pdwProcess, BOOL* pfUnicode = NULL)
    {
        CContextList::CLIENT_IMC_FLAG client_imc;
        BOOL ret = ContextList.Lookup(hIMC, pdwProcess, &client_imc);
        if (ret && pfUnicode)
            *pfUnicode = (client_imc & CContextList::IMCF_UNICODE ? TRUE : FALSE);
        return ret;
    }

    BOOL ContextLookup(HIMC hIMC, HWND* phImeWnd)
    {
        return ContextList.Lookup(hIMC, phImeWnd);
    }

    VOID ContextUpdate(HIMC hIMC, HWND& hImeWnd)
    {
        ContextList.Update(hIMC, hImeWnd);
    }

    BOOL EnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

    HRESULT ResizePrivateIMCC(IN HIMC hIMC, IN DWORD dwPrivateSize);

public:
    BOOL _CreateDefaultInputContext(IN DWORD dwPrivateSize, BOOL fUnicode, BOOL fCiceroActivated);
    BOOL _DestroyDefaultInputContext();

    void _Init(IActiveIME_Private *pActiveIME)
    {
        Assert(m_pActiveIME == NULL);
        m_pActiveIME = pActiveIME;
        m_pActiveIME->AddRef();
    }

public:
    HRESULT UpdateInputContext(IN HIMC hIMC, DWORD dwPrivateSize);

public:
    HIMC _GetDefaultHIMC() {
        return _hDefaultIMC;
    }

    CContextList    ContextList;   // Context list of client IMC.

private:
    HRESULT UpdateIMCC(IN HIMCC* phIMCC, IN DWORD  dwRequestSize);
    DWORD BuildHimcList(DWORD idThread, HIMC pHimc[]);

    HRESULT CreateAImeContext(HIMC hIMC);
    HRESULT DestroyAImeContext(HIMC hIMC);

private:
    IActiveIME_Private*  m_pActiveIME;      // Pointer to IActiveIME interface.

    HIMC         _hDefaultIMC;     // Default input context handle.

    CMap<HWND,                     // class KEY
         HWND,                     // class ARG_KEY
         HIMC,                     // class VALUE
         HIMC                      // class ARG_VALUE
        > AssociateList;
};

inline CInputContext::CInputContext()
{
    m_pActiveIME = NULL;
    _hDefaultIMC = NULL;
}

inline CInputContext::~CInputContext(
    )
{
    SafeRelease(m_pActiveIME);
}

#endif // _CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

void *MemAlloc(UINT uCount); // util.cpp
void MemFree(void *ptr);

void *  __cdecl operator new(unsigned int nSize)
{
    return MemAlloc(nSize);
}

void  __cdecl operator delete(void *pv)
{
    MemFree(pv);
}

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\cimm32.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imm32.h

Abstract:

    This file defines the IMM32 class.

Author:

Revision History:

Notes:

--*/

#ifndef _CIMM32_H_
#define _CIMM32_H_

#include "delay.h"

// consider: why not just not link imm32.lib, and implement the wrappers with the
// same API names?  We could get rid of the Imm32_ prefix, and we could get
// rid of the imm32 namespace in delay.h.
//
// This would also prevent anyone from accidently not delay loading a currently
// unused imm32 api -- they'd get a link error.

/*
 * IMM32 Input Context (hIMC) API Interface.
 */
HRESULT Imm32_CreateContext(OUT HIMC *phIMC);
HRESULT Imm32_DestroyContext(IN HIMC hIMC);
HRESULT Imm32_AssociateContext(IN HWND hWnd, IN HIMC hIMC, OUT HIMC *phPrev);
HRESULT Imm32_AssociateContextEx(IN HWND hWnd, IN HIMC hIMC, IN DWORD dwFlags);
HRESULT Imm32_GetContext(IN HWND hWnd, OUT HIMC *phIMC);
HRESULT Imm32_ReleaseContext(IN HWND hWnd, IN HIMC hIMC);
HRESULT Imm32_GetIMCLockCount(IN HIMC hIMC, OUT DWORD* pdwLockCount);
HRESULT Imm32_LockIMC(HIMC hIMC, OUT INPUTCONTEXT **ppIMC);
HRESULT Imm32_UnlockIMC(IN HIMC hIMC);

/*
 * IMM32 Input Context Components (hIMCC) API Interface.
 */
HRESULT Imm32_CreateIMCC(IN DWORD dwSize, OUT HIMCC *phIMCC);
HRESULT Imm32_DestroyIMCC(IN HIMCC hIMCC);
HRESULT Imm32_GetIMCCSize(IN HIMCC hIMCC, OUT DWORD *pdwSize);
HRESULT Imm32_ReSizeIMCC(IN HIMCC hIMCC, IN DWORD dwSize, OUT HIMCC *phIMCC);
HRESULT Imm32_GetIMCCLockCount(IN HIMCC, OUT DWORD*);
HRESULT Imm32_LockIMCC(IN HIMCC hIMCC, OUT void **ppv);
HRESULT Imm32_UnlockIMCC(IN HIMCC hIMCC);

/*
 * IMM32 Open Status API Interface
 */
HRESULT Imm32_GetOpenStatus(IN HIMC hIMC);
HRESULT Imm32_SetOpenStatus(HIMC hIMC, BOOL fOpen);

/*
 * IMM32 Conversion Status API Interface
 */
HRESULT Imm32_GetConversionStatus(IN HIMC hIMC, OUT DWORD *lpfdwConversion, OUT DWORD *lpfdwSentence);
HRESULT Imm32_SetConversionStatus(IN HIMC hIMC, IN DWORD fdwConversion, IN DWORD fdwSentence);

/*
 * IMM32 Status Window Pos API Interface
 */
HRESULT Imm32_GetStatusWindowPos(IN HIMC hIMC, OUT POINT *lpptPos);
HRESULT Imm32_SetStatusWindowPos(IN HIMC hIMC, IN POINT *lpptPos);

/*
 * IMM32 Composition Window API Interface
 */
HRESULT Imm32_GetCompositionWindow(IN HIMC hIMC, OUT COMPOSITIONFORM *lpCompForm);
HRESULT Imm32_SetCompositionWindow(IN HIMC hIMC, IN COMPOSITIONFORM *lpCompForm);

/*
 * IMM32 Candidate Window API Interface
 */
HRESULT Imm32_GetCandidateWindow(IN HIMC hIMC, IN DWORD dwIndex, OUT CANDIDATEFORM *lpCandidate);
HRESULT Imm32_SetCandidateWindow(IN HIMC hIMC, IN CANDIDATEFORM *lpCandForm);

/*
 * IMM32 Notify IME API Interface
 */
HRESULT Imm32_NotifyIME(IN HIMC hIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);



HRESULT Imm32_GetCompositionString(IN HIMC hIMC, IN DWORD dwIndex, IN DWORD dwCompLen, OUT LONG*& lpCopied, OUT LPVOID lpBuf, BOOL fUnicode);
HRESULT Imm32_SetCompositionString(IN HIMC hIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD dwCompLen, IN LPVOID lpRead, IN DWORD dwReadLen, BOOL fUnicode);
HRESULT Imm32_GetCompositionFont(IN HIMC hIMC, IN LOGFONTAW* lplf, BOOL fUnicode);
HRESULT Imm32_SetCompositionFont(IN HIMC hIMC, IN LOGFONTAW* lplf, BOOL fUnicode);
HRESULT Imm32_GetCandidateList(IN HIMC hIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT LPCANDIDATELIST lpCandList, OUT UINT* puCopied, BOOL fUnicode);
HRESULT Imm32_GetCandidateListCount(IN HIMC, OUT DWORD* lpdwListSize, OUT DWORD* pdwBufLen, BOOL fUnicode);
HRESULT Imm32_GetGuideLine(IN HIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT CHARAW* pBuf, OUT DWORD* pdwResult, BOOL fUnicode);
HRESULT Imm32_GetImeMenuItems(IN HIMC hIMC, IN DWORD dwFlags, IN DWORD dwType, IN IMEMENUITEMINFOAW *pImeParentMenu, OUT IMEMENUITEMINFOAW *pImeMenu, IN DWORD dwSize, OUT DWORD* pdwResult, BOOL fUnicode);
HRESULT Imm32_GenerateMessage(IN HIMC hIMC);

/*
 * hWnd
 */
HRESULT Imm32_GetDefaultIMEWnd(IN HWND hWnd, OUT HWND *phDefWnd);
HRESULT Imm32_GetVirtualKey(HWND hWnd, UINT* puVirtualKey);
HRESULT Imm32_IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT Imm32_IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT Imm32_SimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

/*
 * hKL
 */
HRESULT Imm32_GetProperty(HKL hKL, DWORD dwOffset, DWORD* pdwProperty);
HRESULT Imm32_Escape(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult, BOOL fUnicode);
HRESULT Imm32_GetDescription(HKL hKL, UINT uBufLen, CHARAW* lpsz, UINT* puCopied, BOOL fUnicode);
HRESULT Imm32_IsIME(HKL hKL);

/*
 * soft kbd
 */
inline HRESULT Imm32_CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd)
{
    *phSoftKbdWnd = imm32::ImmCreateSoftKeyboard(uType, hOwner, x, y);
    return S_OK;
}
inline HRESULT Imm32_DestroySoftKeyboard(HWND hSoftKbdWnd)
{
    return imm32::ImmDestroySoftKeyboard(hSoftKbdWnd) ? S_OK : E_FAIL;
}
inline HRESULT Imm32_ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow)
{
    return imm32::ImmShowSoftKeyboard(hSoftKbdWnd, nCmdShow) ? S_OK : E_FAIL;
} 

/*
 * win98/nt5 apis
 */
HRESULT Imm32_RequestMessage(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL fUnicode);

/*
 * Register Word
 */
HRESULT Imm32_EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum);
HRESULT Imm32_EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum);
HRESULT Imm32_GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied);
HRESULT Imm32_GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied);
HRESULT Imm32_RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister);
HRESULT Imm32_RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister);
HRESULT Imm32_UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister);
HRESULT Imm32_UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister);

/*
 *
 */
HRESULT Imm32_ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
HRESULT Imm32_ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);

HRESULT Imm32_GetConversionListA(HKL hKL, HIMC hIMC, LPSTR pSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *pDst, UINT *puCopied);
HRESULT Imm32_GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);

HRESULT Imm32_GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied);
HRESULT Imm32_GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied);
HRESULT Imm32_GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied);
HRESULT Imm32_GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied);
HRESULT Imm32_InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL);
HRESULT Imm32_InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL);
HRESULT Imm32_DisableIME(DWORD idThread);

HRESULT Imm32_GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL);
HRESULT Imm32_SetHotKey(DWORD dwHotKeyID, UINT uModifiers, UINT uVKey, HKL hKL);

HRESULT Imm32_RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
HRESULT Imm32_RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

#endif // _CIMM32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\ctxtlist.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ctxtlist.h

Abstract:

    This file defines the CContextList Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CTXTLIST_H_
#define _CTXTLIST_H_

#include "template.h"

class CContextList
{
public:
    CContextList() { };
    virtual ~CContextList() { };

    enum CLIENT_IMC_FLAG {
        IMCF_NONE            = 0x0000,
        IMCF_UNICODE         = 0x0001,
        IMCF_CMODE_GUID_NULL = 0x0002,
        IMCF_SMODE_GUID_NULL = 0x0004
    };

    void SetAt(HIMC hIMC, CLIENT_IMC_FLAG client_flag)
    {
        CLIENTIMC clientimc;

        memset((void*)&clientimc, 0, sizeof(clientimc));

        clientimc.dwProcessId = GetCurrentProcessId();
        clientimc.flag = client_flag;

        ClientIMC_List.SetAt(hIMC, clientimc);
    }

    BOOL Lookup(HIMC hIMC, DWORD* pdwProcess, CLIENT_IMC_FLAG* pclient_flag = NULL) const
    {
        BOOL ret;
        CLIENTIMC clientimc;

        ret = ClientIMC_List.Lookup(hIMC, clientimc);
        if (ret) {
            *pdwProcess = clientimc.dwProcessId;
            if (pclient_flag)
                *pclient_flag  = clientimc.flag;
        }
        return ret;
    }

    BOOL Lookup(HIMC hIMC, HWND* phImeWnd)
    {
        BOOL ret;
        CLIENTIMC clientimc;

        ret = ClientIMC_List.Lookup(hIMC, clientimc);
        if (ret) {
            *phImeWnd = clientimc.hImeWnd;
        }
        return ret;
    }

    VOID Update(HIMC hIMC, HWND& hImeWnd)
    {
        CLIENTIMC clientimc;

        clientimc = ClientIMC_List[hIMC];
        clientimc.hImeWnd = hImeWnd;
    }

    BOOL RemoveKey(HIMC hIMC)
    {
        return ClientIMC_List.RemoveKey(hIMC);
    }

    INT_PTR GetCount() const
    {
        return ClientIMC_List.GetCount();
    }

    POSITION GetStartPosition() const
    {
        return ClientIMC_List.GetStartPosition();
    }

    void GetNextHimc(POSITION& rNextPosition, HIMC* hImc, CLIENT_IMC_FLAG* pclient_imc = NULL) const
    {
        HIMC _hIMC;
        CLIENTIMC clientimc;
        ClientIMC_List.GetNextAssoc(rNextPosition, _hIMC, clientimc);
        *hImc = _hIMC;
        if (pclient_imc)
            *pclient_imc  = clientimc.flag;
    }

    //
    // Copy constructor
    //
    CContextList(const CContextList& src)
    {
        POSITION pos = src.GetStartPosition();
        for (INT_PTR index = 0; index < src.GetCount(); index++) {
            HIMC hIMC;
            CLIENT_IMC_FLAG client_imc;
            src.GetNextHimc(pos, &hIMC, &client_imc);
            SetAt(hIMC, client_imc);
        }
    }

private:
    struct CLIENTIMC {
        DWORD            dwProcessId;         // Process ID.
        CLIENT_IMC_FLAG  flag;                // flags.
        HWND             hImeWnd;             // in use IME Window
    };

private:
    CMap<HIMC,                     // class KEY
         HIMC,                     // class ARG_KEY
         CLIENTIMC,                // class VALUE
         CLIENTIMC                 // class ARG_VALUE
        > ClientIMC_List;
};

#endif // _CTXTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "DIMM12"
#define SZ_MODULE       "DIMM12"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\delay.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    delay.h

Abstract:

    This file defines the IMM32 Namespace.

Author:

Revision History:

Notes:

--*/

#ifndef _DELAY_H_
#define _DELAY_H_

namespace imm32 {

    extern HINSTANCE g_hImm32;

    /*
     * IMM32 Input Context (hIMC) API Interface.
     */
    HIMC WINAPI ImmCreateContext(void);
    BOOL WINAPI ImmDestroyContext(IN HIMC);
    HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
    BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
    HIMC WINAPI ImmGetContext(IN HWND);
    BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
    DWORD WINAPI ImmGetIMCLockCount(IN HIMC);
    LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
    BOOL  WINAPI ImmUnlockIMC(IN HIMC);

    /*
     * IMM32 Input Context Components (hIMCC) API Interface.
     */
    HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
    HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
    DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);
    HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
    DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
    LPVOID WINAPI ImmLockIMCC(IN HIMCC);
    BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);

    /*
     * IMM32 Composition String API Interface
     */
    LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

    /*
     * IMM32 Composition Font API Interface
     */
    BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
    BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
    BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
    BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);

    /*
     * IMM32 Open Status API Interface
     */
    BOOL WINAPI ImmGetOpenStatus(IN HIMC);
    BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

    /*
     * IMM32 Conversion Status API Interface
     */
    BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
    BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);

    /*
     * IMM32 Status Window Pos API Interface
     */
    BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
    BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);


    /*
     * IMM32 Composition Window API Interface
     */
    BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
    BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);

    /*
     * IMM32 Candidate API Interface
     */
    BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
    BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);
    DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
    DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);

    /*
     * IMM32 Generate Message API Interface
     */
    BOOL WINAPI ImmGenerateMessage(IN HIMC);

    /*
     * IMM32 Notify IME API Interface
     */
    BOOL WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

    /*
     * IMM32 Guide Line IME API Interface
     */
    DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);

    /*
     * IMM32 Menu items API Interface
     */
    DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
    DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);

    /*
     * IMM32 Default IME Window API Interface
     */
    HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);
    UINT WINAPI ImmGetVirtualKey(IN HWND);

    /*
     * IMM32 UI message API Interface
     */
    BOOL WINAPI ImmIsUIMessageA(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);
    BOOL WINAPI ImmIsUIMessageW(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);

    /*
     * IMM32 Simulate hotkey API Interface
     */
    BOOL WINAPI ImmSimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

    /*
     * IMM32 Property API Interface
     */
    DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

    /*
     * IMM32 Description API Interface
     */
    UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameA(HKL hKL, LPSTR lpszFileName, UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameW(HKL hKL, LPWSTR lpszFileName, UINT uBufLen);

    /*
     * IMM32 Conversion List API Interface
     */
    DWORD WINAPI ImmGetConversionListA(HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);
    DWORD WINAPI ImmGetConversionListW(HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);

    /*
     * IMM32 IsIME API Interface
     */
    BOOL WINAPI ImmIsIME(HKL hKL);

    /*
     * IMM32 Escape API Interface
     */
    LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
    LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);

    /*
     * IMM32 Configure IME Interface
     */
    BOOL WINAPI ImmConfigureIMEA(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
    BOOL WINAPI ImmConfigureIMEW(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);

    /*
     * IMM32 Register Word IME Interface
     */
    BOOL WINAPI ImmRegisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister);
    BOOL WINAPI ImmRegisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister);
    BOOL WINAPI ImmUnregisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister);
    BOOL WINAPI ImmUnregisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister);
    UINT WINAPI ImmGetRegisterWordStyleA(HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
    UINT WINAPI ImmGetRegisterWordStyleW(HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);

    /*
     * IMM32 soft kbd API
     */
    HWND WINAPI ImmCreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y);
    BOOL WINAPI ImmDestroySoftKeyboard(HWND hSoftKbdWnd);
    BOOL WINAPI ImmShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    /*
     * IMM32 win98/nt5 apis
     */
    BOOL WINAPI ImmDisableIME(DWORD dwId);

    LRESULT WINAPI ImmRequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam);
    LRESULT WINAPI ImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam);

    HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
    HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
}

#endif // _DELAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\defs.h ===
//+---------------------------------------------------------------------------
//
//  File:       defs.h
//
//  Contents:   Constant definitions.
//
//----------------------------------------------------------------------------

#ifndef DEFS_H
#define DEFS_H

#undef MAX
#define MAX(a, b) ( (a) >= (b) ? a : b )
#undef MIN
#define MIN(a, b) ( (a) <= (b) ? a : b )

#ifndef ABS
#define ABS(x) ( (x) < 0 ? -(x) : x )
#endif

// debugging api calls
#define TF_API      0x10
#define TF_IMEAPI   0x20

#endif // DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\dimm.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       dimm.cpp
//
//  Contents:   CActiveIMM methods without win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "util.h"

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CActiveIMM::CActiveIMM()
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_Init()
{
    extern HRESULT CIME_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    HRESULT hr;

    if (FAILED(hr=CIME_CreateInstance(NULL, IID_IActiveIME_Private, (void **)&_pActiveIME)))
    {
        _pActiveIME = NULL;
        return hr;
    }

    _pActiveIME->ConnectIMM(this);

    _InputContext._Init(_pActiveIME);

    _ConnectTIM(_pActiveIME);

    return hr;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CActiveIMM::~CActiveIMM()
{
    //
    // unload the hooks
    //
    _UninitHooks();

    POSITION pos = _mapWndFocus.GetStartPosition();
    int index;
    for (index = 0; index < _mapWndFocus.GetCount(); index++) {
        HWND hWnd;
        ITfDocumentMgr* pdim;
        _mapWndFocus.GetNextAssoc(pos, hWnd, pdim);
        if (pdim)
        {
            pdim->Release();
        }
    }

    if (GetTimP())
    {
        _UnconnectTIM();
    }

    if (_pActiveIME != NULL)
    {
        _pActiveIME->UnconnectIMM();
        SafeReleaseClear(_pActiveIME);
    }

    IMTLS_SetActiveIMM(NULL);
}

//+---------------------------------------------------------------------------
//
// IsRealIme
//
//----------------------------------------------------------------------------

inline BOOL _IsIMEHKL(HKL hkl)
{
    return ((((DWORD)(UINT_PTR)hkl) & 0xf0000000) == 0xe0000000) ? TRUE : FALSE;
}

BOOL CActiveIMM::_IsRealIme(HKL hkl)
{
    if (! hkl) {
        HRESULT hr = _GetKeyboardLayout(&hkl);
        if (FAILED(hr))
            return FALSE;
    }

    if (!_IsIMEHKL(hkl))
        return FALSE;

    BOOL fRet;
    if (_RealImeList.Lookup(hkl, fRet))
        return fRet;

    char szDesc[MAX_PATH +1];
    char szDumbDesc[MAX_PATH +1];

    UINT uCopied;
    if (FAILED(Imm32_GetDescription(hkl, ARRAYSIZE(szDesc), (CHARAW*)szDesc, &uCopied, FALSE)))
        return FALSE;

    szDesc[ARRAYSIZE(szDesc) -1] = '\0';

    wsprintf(szDumbDesc, "hkl%04x", LOWORD((UINT_PTR)hkl));
    fRet = lstrcmp(szDumbDesc, szDesc) ? TRUE : FALSE;

    _RealImeList.SetAt(hkl, fRet);
    return fRet;
}

HRESULT CActiveIMM::IsRealImePublic(BOOL *pfReal)
{
    if (pfReal)
    {
        *pfReal = _IsRealIme(0);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr;
    IServiceProvider* pISP;

    Assert(ppv != NULL && *ppv == NULL);

    hr = E_FAIL;

    if (_pActiveIME->QueryInterface(IID_IServiceProvider, (void**)&pISP) == S_OK)
    {
        hr = pISP->QueryService(guidService, riid, ppv);
        pISP->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetKeyboardLayout
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_GetKeyboardLayout(HKL* phkl)
{
    extern HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    HRESULT hr;

    if (_IsAlreadyActivate())
    {
        //
        // Already called IActiveIMMApp::Activate
        //
        if (_AImeProfile == NULL) {

            hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&_AImeProfile);

            if (FAILED(hr)) {
                TraceMsg(TF_ERROR, "CreateInstance(CAImeProfile) failed");
                return hr;
            }
        }
        return _AImeProfile->GetKeyboardLayout(phkl);
    }
    else {
        //
        // Not yet called IActiveIMMApp::Activate
        // or
        // called IActiveIMMApp::Deactivate
        //
        if (_AImeProfile == NULL) {
            hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&_AImeProfile);

            if (FAILED(hr)) {
                TraceMsg(TF_ERROR, "CreateInstance(CAImeProfile) failed");
                return hr;
            }
            hr = _AImeProfile->GetKeyboardLayout(phkl);
            //
            // Prevent memory leak when not ready Activate.
            //
            _AImeProfile->Release();
            _AImeProfile = NULL;
            //
            return hr;
        }
        else {
            return _AImeProfile->GetKeyboardLayout(phkl);
        }
    }
}

//+---------------------------------------------------------------------------
//
// _ImeSelectHandler
//
//----------------------------------------------------------------------------

LRESULT CActiveIMM::_ImeSelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, HIMC hIMC)

/*
 * If return TRUE: no call previous window procedure of IME window class.
 * In case of CCiceroIME::ActivateLayout/DeactivateLayout, return value might be
 * TRUE.
 * Otherwise, WM_IME_SELECT become from another module. In this case, should be
 * call previous window proc.
 */

{
    //
    // on FE-Win98, IMS_ACTIVATETHREADLAYOUT needs to be generate at ImeSelect.
    // otherwise we may update InputContext before IME get ImeSelect(FALSE);
    //
    if (wParam && !IsOnNT() && IsOnImm())
        _DefaultIMEWindow.SendIMEMessage(WM_IME_SYSTEM, (WPARAM)IMS_ACTIVATETHREADLAYOUT, lParam, IsWindowUnicode(_hFocusWnd), FALSE);

    if (!_IsRealIme((HKL)lParam)) {
        /*
         * We must re-create UI window of newly selected IME.
         */
        if ((BOOL)wParam == TRUE) {
            //
            // Create IME UI window.
            //
            if (_UIWindow.CreateUIWindow((HKL)lParam)) {
                //
                // Set context and send notification to UI window.
                //
                _UIWindow.SetUIWindowContext(hIMC);
                _UIWindow.SendUIMessage(uMsg, wParam, lParam, fUnicode);
            }
        }
        else {
            _UIWindow.SendUIMessage(uMsg, wParam, lParam, fUnicode);
            _UIWindow.DestroyUIWindow();
        }
        return TRUE;
    }
    else if (_DefaultIMEWindow.IsAIMEHandler())
        return TRUE;
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
// _ImeWndFinalDestroyHandler
//
//----------------------------------------------------------------------------

void CActiveIMM::_ImeWndFinalDestroyHandler()
{
    if (!_IsRealIme()) {
        //
        // Destroy IME UI window.
        //
        _UIWindow.DestroyUIWindow();
    }
}

//+---------------------------------------------------------------------------
//
// _ActivateLayout
//
//----------------------------------------------------------------------------

void CActiveIMM::_ActivateLayout(HKL hSelKL, HKL hUnSelKL)
{
    BOOL fUnicode = IsWindowUnicode(_hFocusWnd);
    BOOL bIsRealIme = _IsRealIme(hSelKL);

    /*
     * Select input context(s).
     */
    SCE sce;
    sce.hSelKL   = hSelKL;
    sce.hUnSelKL = hUnSelKL;

    _InputContext.EnumInputContext(0, _SelectContextProc, (LPARAM)&sce);

    if (! bIsRealIme || ! IsOnImm()) {
        if (hSelKL == NULL) {
            HRESULT hr = _GetKeyboardLayout(&hSelKL);
        }

        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, TRUE, (LPARAM)(hSelKL), fUnicode);
    }
}

//+---------------------------------------------------------------------------
//
// _DeactivateLayout
//
//----------------------------------------------------------------------------

void CActiveIMM::_DeactivateLayout(HKL hSelKL, HKL hUnSelKL)
{
    BOOL fUnicode = IsWindowUnicode(_hFocusWnd); 
    BOOL bIsRealIme = _IsRealIme(hUnSelKL);

    if ((! bIsRealIme || ! IsOnImm()) &&
          (hUnSelKL != hSelKL ||
           (hUnSelKL == NULL && hSelKL == NULL))) {

#ifdef UNSELECTCHECK
        //
        // If hSelKL is real IME, All hIMC is already initialized by the IME
        // we can not touch them from now on. We should stop doing in next
        // NotifyIME calls.
        //
        if (_IsRealIme(hSelKL) && !IsOnNT())
        {
            _InputContext.EnumInputContext(0, _UnSelectCheckProc, 0);
        }
#endif UNSELECTCHECK

        DWORD dwCPS = _GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_COMPLETE_ON_UNSELECT ? CPS_COMPLETE : CPS_CANCEL;

        _InputContext.EnumInputContext(0, _NotifyIMEProc, dwCPS);

        if (hUnSelKL == NULL) {
            HRESULT hr = _GetKeyboardLayout(&hUnSelKL);
        }

        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, FALSE, (LPARAM)(hUnSelKL), fUnicode);
    }

    /*
     * Unselect input context(s).
     */
    SCE sce;
    sce.hSelKL   = hSelKL;
    sce.hUnSelKL = hUnSelKL;
    _InputContext.EnumInputContext(0, _UnSelectContextProc, (LPARAM)&sce);
}

//+---------------------------------------------------------------------------
//
// _InitHooks
//
//----------------------------------------------------------------------------

BOOL CActiveIMM::_InitHooks()
{
    GetTimP()->SetSysHookSink(this);

    DWORD dwThreadId = GetCurrentThreadId();

#if 0
    if (!_hHook[TH_GETMSG]) {
        _hHook[TH_GETMSG] = SetWindowsHookEx(WH_GETMESSAGE, _GetMsgProc, NULL, dwThreadId);
    }
#endif

#ifdef CALLWNDPROC_HOOK
    if (!_hHook[TH_WNDPROC]) {
        _hHook[TH_WNDPROC] = SetWindowsHookEx(WH_CALLWNDPROC, _CallWndProc, NULL, dwThreadId);
    }
#endif // CALLWNDPROC_HOOK

#ifdef CALLWNDPROC_HOOK
    if (!_hHook[TH_DEFIMEWNDPROC] &&
        _DefaultIMEWindow.IsNeedRecovIMEWndProc()) 
#else
    if (!_hHook[TH_DEFIMEWNDPROC])
#endif // CALLWNDPROC_HOOK
    {
        _hHook[TH_DEFIMEWNDPROC] = SetWindowsHookEx(WH_CALLWNDPROCRET,
                                                   _DefImeWnd_CallWndProc,
                                                   NULL,
                                                   dwThreadId);
    }

#if 0
    if (g_uACP != 932 && g_uACP != 949 && g_uACP != 950 && g_uACP != 936 &&
        ! hShellHook) {
        hShellHook = SetWindowsHookEx(WH_SHELL, _ShellProc, NULL, dwThreadId);
    }
#endif

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _UninitHooks
//
//----------------------------------------------------------------------------

void CActiveIMM::_UninitHooks()
{
#if 0
    if (_hHook[TH_GETMSG]) {
        UnhookWindowsHookEx(_hHook[TH_GETMSG]);
        _hHook[TH_GETMSG] = NULL;
    }
#endif

#ifdef CALLWNDPROC_HOOK
    if (_hHook[TH_WNDPROC]) {
        UnhookWindowsHookEx(_hHook[TH_WNDPROC]);
        _hHook[TH_WNDPROC] = NULL;
    }
#endif // CALLWNDPROC_HOOK

    if (_hHook[TH_DEFIMEWNDPROC]) {
        UnhookWindowsHookEx(_hHook[TH_DEFIMEWNDPROC]);
        _hHook[TH_DEFIMEWNDPROC] = NULL;
    }

#if 0
    if (g_uACP != 932 && g_uACP != 949 && g_uACP != 950 && g_uACP != 936 &&
        hShellHook != NULL) {
        UnhookWindowsHookEx(hShellHook);
        hShellHook = NULL;
    }
#endif

    if (GetTimP())
    {
        GetTimP()->SetSysHookSink(NULL);
    }
}

//+---------------------------------------------------------------------------
//
// _OnImeSelect
//
//----------------------------------------------------------------------------

void CActiveIMM::_OnImeSelect(HKL hSelKL)
{
    if (!_IsRealIme(hSelKL))
    {
        // Don't check IMM32
        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, TRUE, (LPARAM)(hSelKL), IsWindowUnicode(_hFocusWnd), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
// _OnImeUnselect
//
//----------------------------------------------------------------------------

void CActiveIMM::_OnImeUnselect(HKL hUnSelKL)
{
    if (!_IsRealIme(hUnSelKL))
    {
        // Don't check IMM32
        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, FALSE, (LPARAM)(hUnSelKL), IsWindowUnicode(_hFocusWnd), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
// _OnImeActivateThreadLayout
//
//----------------------------------------------------------------------------

void CActiveIMM::_OnImeActivateThreadLayout(HKL hSelKL)
{
    //
    // on FE-Win98, IMS_ACTIVATETHREADLAYOUT needs to be generate at ImeSelect.
    // otherwise we may update InputContext before IME get ImeSelect(FALSE);
    //
    if (!IsOnNT() && IsOnImm())
        return;

    // Don't check IMM32
    _DefaultIMEWindow.SendIMEMessage(WM_IME_SYSTEM, (WPARAM)IMS_ACTIVATETHREADLAYOUT, (LPARAM)(hSelKL), IsWindowUnicode(_hFocusWnd), FALSE);
}

//+---------------------------------------------------------------------------
//
// _AImeAssociateFocus
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_AImeAssociateFocus(HWND hWnd, HIMC hIMC, DWORD dwFlags)
{
    if (hIMC)
    {
        DIMM_IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return E_FAIL;

        lpIMC->hWnd = hWnd;
    }

    return _pActiveIME->AssociateFocus(hWnd, hIMC, dwFlags);
}

//+---------------------------------------------------------------------------
//
// _ResizePrivateIMCC
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_ResizePrivateIMCC(IN HIMC hIMC, IN DWORD dwPrivateSize)
{
    /*
     * Resize private IMCC method.
     *
     * If IsRealIme() was true, should not resize private IMCC to ActiveIME's size.
     * 
     */
    if (!_IsRealIme())
        return _InputContext.ResizePrivateIMCC(hIMC, dwPrivateSize);
    else
        return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetIMEWndClassName
//
//----------------------------------------------------------------------------

DWORD CActiveIMM::_GetIMEWndClassName(HKL hKL, LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate)
{
    return (!_IsRealIme(hKL)) ? _GetIMEWndClassName(lpsz, dwBufLen, pulPrivate)
                                              : 0L;
}

DWORD CActiveIMM::_GetIMEWndClassName(LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate)
{
    DWORD len = wcslen(_IMEInfoEx.achWndClass);

    if (lpsz == NULL || dwBufLen < len) {
        return len;
    }
    else {
        wcscpy(lpsz, _IMEInfoEx.achWndClass);
        *pulPrivate = _IMEInfoEx.dwPrivate;
    }
    return len;
}

//+---------------------------------------------------------------------------
//
// _CallWindowProc
//
//----------------------------------------------------------------------------

LRESULT CActiveIMM::_CallWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _DefaultIMEWindow.CallWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _SendUIMessage
//
//----------------------------------------------------------------------------

LRESULT CActiveIMM::_SendUIMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode)
{
    return (!_IsRealIme()) ? _UIWindow.SendUIMessage(Msg, wParam, lParam, fUnicode)
                                           : 0L;
}

//+---------------------------------------------------------------------------
//
// _SetHookWndList
//
//----------------------------------------------------------------------------

BOOL CActiveIMM::_SetHookWndList(HWND hwnd)
{
    TCHAR achMyClassName[MAX_PATH + 1];
    int lenMyClassName = ::GetClassName(hwnd, achMyClassName, ARRAYSIZE(achMyClassName) - 1);
    achMyClassName[ARRAYSIZE(achMyClassName) -1] = TEXT('\0');
    if (lenMyClassName) {
        CString cls(achMyClassName);
        if (cls.CompareNoCase(TEXT("IME")) == 0) {
            _HookWndList.SetAt(hwnd, TRUE);
            return TRUE;
        }
    }

    DWORD dwStyle = GetClassLong(hwnd, GCL_STYLE);
    if (dwStyle & CS_IME) {
        _HookWndList.SetAt(hwnd, TRUE);
        return TRUE;
    }

    _HookWndList.SetAt(hwnd, FALSE);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// OnPreFocusDIM
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::OnPreFocusDIM(HWND hWnd)
{
    HIMC hIMC;
    if (SUCCEEDED(_InputContext.GetContext(hWnd, &hIMC)))
    {
        if (IsPresent(hWnd, TRUE))
        {
            if (_InputContext._IsDefaultContext(hIMC)) 
            {
                DIMM_IMCLock pIMC(hIMC);
                if (pIMC.Valid()) 
                {
                    // set the hWnd since this is a default context
                    pIMC->hWnd = hWnd;
                }
            }
            _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
            _SetMapWndFocus(hWnd);
        }
        else if (hIMC)
        {
            _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS | AIMMP_AFF_SETNULLDIM);
        }
        else
        {
            _AImeAssociateFocus(hWnd, NULL, AIMMP_AFF_SETFOCUS);
        }
    }
    else
    {
        _AImeAssociateFocus(hWnd, NULL, AIMMP_AFF_SETFOCUS);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSysKeybaordProc
//
//----------------------------------------------------------------------------

STDAPI CActiveIMM::OnSysKeyboardProc(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return hr;

    BOOL bIsRealIme = _IsRealIme();

    BOOL fNoOnTrans;

    if ((wParam != VK_PROCESSKEY) && !bIsRealIme)
    {
        // fNoOnTrans = (pTS->uMsgPumpOwnerRef == 0); // check this once so it doesn't get changed during the op
        fNoOnTrans = TRUE;

        if (HIWORD(lParam) & KF_UP)
        {
            // if this a key up event, clear the KF_REPEAT flag
            lParam &= ~(KF_REPEAT << 16);
        }

        hr = _this->_ProcessKey(&wParam, &lParam, fNoOnTrans);

        // wParam will be set 0 if _ProcessKey wants to eat it without consulting the ime
        // (It might also be converted to VK_HANJA, etc.)
        if (hr == S_OK && fNoOnTrans && wParam)
        {
            // nobody's using OnTranslateMessage to finish off the key now
            hr = _this->_ToAsciiEx(wParam, lParam);
        }
    }
#ifdef CICERO_3564
    else if ((wParam == VK_PROCESSKEY) &&
             ! bIsRealIme)
    {
        /*
         * KOREAN:
         *  Send VK_PROCESSKEY to finalize current composition string (NT4 behavior)
         *  Post private message (WM_IME_SYSTEM::IMS_FINALIZE_COMPSTR) to let IMM finalize the composition string (NT5)
         */
        IMTLS *ptls = IMTLS_GetOrAlloc();
        if (ptls == NULL)
            return hr;

        if (ptls->pAImeProfile == NULL)
            return hr;

        LANGID langid;
        ptls->pAImeProfile->GetLangId(&langid);

        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            hr = _this->_ToAsciiEx(wParam, lParam);
        }
    }
#endif // CICERO_3564

    return hr;
}


//+---------------------------------------------------------------------------
//
// _SendIMENotify
//
// Inform IME and Apps Wnd about the change of composition window.
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_SendIMENotify(
    HIMC hImc,
    HWND hWnd,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (dwAction != 0) {
        _AImeNotifyIME(hImc, dwAction, dwIndex, dwValue);
    }

    if (hWnd != NULL && wParam != 0) {
        SendMessage(hWnd, WM_IME_NOTIFY, wParam, lParam);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetIMEProperty
//
//----------------------------------------------------------------------------

DWORD CActiveIMM::_GetIMEProperty(PROPERTY_TYPE iType)
{
    switch (iType) {
        case PROP_PRIVATE_DATA_SIZE:  return _IMEInfoEx.ImeInfo.dwPrivateDataSize;  break;
        case PROP_IME_PROPERTY:       return _IMEInfoEx.ImeInfo.fdwProperty;        break;
        case PROP_CONVERSION_CAPS:    return _IMEInfoEx.ImeInfo.fdwConversionCaps;  break;
        case PROP_SENTENCE_CAPS:      return _IMEInfoEx.ImeInfo.fdwSentenceCaps;    break;
        case PROP_UI_CAPS:            return _IMEInfoEx.ImeInfo.fdwUICaps;          break;
        case PROP_SCS_CAPS:           return _IMEInfoEx.ImeInfo.fdwSCSCaps;         break;
        case PROP_SELECT_CAPS:        return _IMEInfoEx.ImeInfo.fdwSelectCaps;      break;
        default:                      return 0;
    }
}

//+---------------------------------------------------------------------------
//
// HideOrRestoreToolbarWnd
//
//----------------------------------------------------------------------------

void CActiveIMM::HideOrRestoreToolbarWnd(BOOL fRestore)
{
    ITfLangBarMgr *plbm;
    if (SUCCEEDED(TF_CreateLangBarMgr(&plbm)))
    {
        if (fRestore)
        {
            if (_dwPrevToolbarStatus)
            {
                plbm->ShowFloating(_dwPrevToolbarStatus);
                _dwPrevToolbarStatus = 0;
            }
        } 
        else
        {
            if (SUCCEEDED(plbm->GetShowFloatingStatus(&_dwPrevToolbarStatus)))
            {
                BOOL fHide = TRUE;
                if (_dwPrevToolbarStatus & TF_SFT_DESKBAND)
                    fHide = FALSE;
          
                //
                // mask for show/hide
                //
                _dwPrevToolbarStatus &= (TF_SFT_SHOWNORMAL |
                                         TF_SFT_DOCK |
                                         TF_SFT_MINIMIZED |
                                         TF_SFT_HIDDEN);

                if (fHide)
                    plbm->ShowFloating(TF_SFT_HIDDEN);
            } 
        } 
        plbm->Release();
    }
}

//+---------------------------------------------------------------------------
//
// OnSysShellProc
//
//----------------------------------------------------------------------------

STDAPI CActiveIMM::OnSysShellProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return hr;

    switch (nCode) {
        case HSHELL_LANGUAGE:
            if (IsOn98() || IsOn95()) {
                //
                // Windows 9x platform
                // Alternative of WM_IME_SYSTEM::IMS_ACTIVATETHREADLAYOUT
                //
                _this->_OnImeActivateThreadLayout((HKL)lParam);
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\enum.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    enum.h

Abstract:

    This file defines the IEnumInputContext Class.

Author:

Revision History:

Notes:

--*/

#ifndef _ENUM_H_
#define _ENUM_H_

#include "ctxtlist.h"

class CEnumInputContext : public IEnumInputContext
{
public:
    CEnumInputContext(CContextList& _hIMC_List) : _list(_hIMC_List)
    {
        _cRef = 1;
        Reset();
    };
    ~CEnumInputContext() { };

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IEnumInputContext
    //
    STDMETHODIMP Clone(IEnumInputContext** ppEnum);
    STDMETHODIMP Next(ULONG ulCount, HIMC* rgInputContext, ULONG* pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    LONG            _cRef;

    POSITION        _pos;
    CContextList    _list;
};

#endif // _ENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\enum.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    enum.cpp

Abstract:

    This file implements the IEnumInputContext Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "enum.h"

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::QueryInterface(
    REFIID riid,
    void **ppvObj
    )
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumInputContext))
    {
        *ppvObj = SAFECAST(this, IEnumInputContext *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

ULONG
CEnumInputContext::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

ULONG
CEnumInputContext::Release()
{
    LONG cr = --_cRef;

    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Clone(
    IEnumInputContext** ppEnum
    )
{
    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    CEnumInputContext* pClone;
    if ((pClone = new CEnumInputContext(_list)) == NULL)
        return E_OUTOFMEMORY;

    *ppEnum = pClone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Next(
    ULONG ulCount,
    HIMC* rgInputContext,
    ULONG* pcFetched
    )
{
    if (rgInputContext == NULL)
        return E_INVALIDARG;

    ULONG cFetched;
    if (pcFetched == NULL)
        pcFetched = &cFetched;

    if (_pos == NULL) {
        *pcFetched = 0;
        return S_FALSE;
    }

    for (*pcFetched = 0; *pcFetched < ulCount; *pcFetched++, rgInputContext++) {
        _list.GetNextHimc(_pos, rgInputContext);
        if (_pos == NULL)
            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Reset(
    )
{
    _pos = _list.GetStartPosition();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Skip(
    ULONG ulCount
    )
{
    POSITION backup = _pos;

    while (ulCount--) {
        HIMC imc;
        _list.GetNextHimc(_pos, &imc);
        if (_pos == NULL) {
            _pos = backup;
            return S_FALSE;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\guidmap.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       guidmap.cpp
//
//  Contents:   IActiveIMMAppEx::GetGuidAtom routines
//
//----------------------------------------------------------------------------

#include "private.h"

#include "context.h"
#include "globals.h"
#include "cdimm.h"



//
// IActiveIMMAppEx::GetGuidAtom method
//

STDMETHODIMP CActiveIMM::GetGuidAtom(HIMC hIMC, BYTE bAttr, TfGuidAtom* pGuidAtom)
{
    if (pGuidAtom == NULL) {
        return E_INVALIDARG;
    }

    *pGuidAtom = TF_INVALID_GUIDATOM;

    HRESULT hr;

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        if (pActiveIMM->_IsRealIme(NULL))
            return E_FAIL;
    }
    else
        return E_UNEXPECTED;

    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult())) {
        return hr;
    }

    if (imc->m_pContext != NULL) {
        return imc->m_pContext->GetGuidAtom(hIMC, bAttr, pGuidAtom);
    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "globals.h"
#include "template.h"

TOUNICODEEX g_pfnToUnicodeEx = NULL;

CProcessIMM* g_ProcessIMM;



UINT  WM_MSIME_SERVICE;
UINT  WM_MSIME_UIREADY;
UINT  WM_MSIME_RECONVERTREQUEST;
UINT  WM_MSIME_RECONVERT;
UINT  WM_MSIME_DOCUMENTFEED;
UINT  WM_MSIME_QUERYPOSITION;
UINT  WM_MSIME_MODEBIAS;
UINT  WM_MSIME_SHOWIMEPAD;
UINT  WM_MSIME_MOUSE;
UINT  WM_MSIME_KEYMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "pimm.h"
#include "imtls.h"

extern HINSTANCE g_hInst;

extern CProcessIMM* g_ProcessIMM;

typedef struct tagSELECTCONTEXT_ENUM {
    HKL hSelKL;
    HKL hUnSelKL;
} SCE, *PSCE;


typedef int (*TOUNICODEEX)(UINT, UINT, CONST BYTE *, LPWSTR, int, UINT, HKL);
extern TOUNICODEEX g_pfnToUnicodeEx;



//+---------------------------------------------------------------------------
//
// WM_MSIME_xxxx
//
//----------------------------------------------------------------------------

extern UINT  WM_MSIME_SERVICE;
extern UINT  WM_MSIME_UIREADY;
extern UINT  WM_MSIME_RECONVERTREQUEST;
extern UINT  WM_MSIME_RECONVERT;
extern UINT  WM_MSIME_DOCUMENTFEED;
extern UINT  WM_MSIME_QUERYPOSITION;
extern UINT  WM_MSIME_MODEBIAS;
extern UINT  WM_MSIME_SHOWIMEPAD;
extern UINT  WM_MSIME_MOUSE;
extern UINT  WM_MSIME_KEYMAP;

//+---------------------------------------------------------------------------
//
// GetTLS
//
//----------------------------------------------------------------------------

class CActiveIMM;

inline CActiveIMM *GetTLS()
{
    return IMTLS_GetActiveIMM();
}

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imclock2.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    DIMM_IMCLock.cpp

Abstract:

    This file implements the DIMM_IMCLock / DIMM_IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "imclock2.h"
#include "defs.h"
#include "delay.h"
#include "globals.h"
#include "cdimm.h"

DIMM_IMCLock::DIMM_IMCLock(
    HIMC hImc
    ) : _IMCLock(hImc)
{
    if (hImc) {
        /*
         * Set m_fUnicde and m_uCodePage
         */
        DWORD dwProcessId;
        CActiveIMM *_this = GetTLS();
        if (_this == NULL)
            return;

        if (!_this->_ContextLookup(hImc, &dwProcessId, &m_fUnicode))
            return;

        m_hr = _LockIMC(hImc, &m_inputcontext);
    }
}

HRESULT
DIMM_IMCLock::_LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT_AIMM12 **ppIMC
    )
{
    TraceMsg(TF_API, "_LockIMC");

    if (hIMC == NULL)
        return E_INVALIDARG;

    /*
     * Get Process ID
     */
    DWORD dwProcessId;

    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return E_FAIL;

    if (!_this->_ContextLookup(hIMC, &dwProcessId))
        return E_ACCESSDENIED;

    if (IsOnImm()) {
        return Imm32_LockIMC(hIMC, (INPUTCONTEXT**)ppIMC);
    }
    else {
        /*
         * Cannot access input context from other process.
         */
        if (dwProcessId != GetCurrentProcessId())
            return E_ACCESSDENIED;

        *ppIMC = (INPUTCONTEXT_AIMM12 *)LocalLock(hIMC);
    }

    return *ppIMC == NULL ? E_FAIL : S_OK;
}

HRESULT
DIMM_IMCLock::_UnlockIMC(
    IN HIMC hIMC
    )
{
    TraceMsg(TF_API, "_UnlockIMC");

    if (IsOnImm()) {
        return Imm32_UnlockIMC(hIMC);
    }
    else {
        // for now HIMC are LocalAlloc(LHND) handle
        if (LocalUnlock(hIMC)) {
            // memory object still locked.
            return S_OK;
        }
        else {
            DWORD err = GetLastError();
            if (err == NO_ERROR)
                // memory object is unlocked.
                return S_OK;
            else if (err == ERROR_NOT_LOCKED)
                // memory object is already unlocked.
                return S_OK;
        }
    }
    return E_FAIL;
}



DIMM_InternalIMCCLock::DIMM_InternalIMCCLock(
    HIMCC hImcc
    ) : _IMCCLock(hImcc)
{
    if (hImcc) {
        m_hr = _LockIMCC(m_himcc, (void**)&m_pimcc);
    }
}


HRESULT
DIMM_InternalIMCCLock::_LockIMCC(
    HIMCC hIMCC,
    void** ppv
    )
{
    TraceMsg(TF_API, "_LockIMCC");

    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    if (IsOnImm()) {
        return Imm32_LockIMCC(hIMCC, ppv);
    }
    else {
        *ppv = (void *)LocalLock(hIMCC);
    }

    return *ppv == NULL ? E_FAIL : S_OK;
}

HRESULT
DIMM_InternalIMCCLock::_UnlockIMCC(
    HIMCC hIMCC
    )
{
    TraceMsg(TF_API, "_UnlockIMCC");

    if (IsOnImm()) {
        return Imm32_UnlockIMCC(hIMCC);
    }
    else {
        if (LocalUnlock(hIMCC)) {
            // memory object still locked.
            return S_OK;
        }
        else {
            DWORD err = GetLastError();
            if (err == NO_ERROR)
                // memory object is unlocked.
                return S_OK;
            else if (err == ERROR_NOT_LOCKED)
                // memory object is already unlocked.
                return S_OK;
        }
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imccomp.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imccomp.h

Abstract:

    This file defines the Context of Composition Class.

Author:

Revision History:

Notes:

    This implementation is almost identical to ..\inc\ctxtcmp.h.

--*/

#ifndef IMCCOMP_H
#define IMCCOMP_H

#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// GetCompInfo

template<class T>
HRESULT
GetCompInfo(
    IN T size,
    IN DWORD len,
    IN LONG*& lpCopied
    )
{
    *lpCopied = (LONG)(len * size);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CompData

template<class TYPE, class ARG_TYPE>
class CompData
{
public:
    CompData(HIMC hIMC = NULL, ARG_TYPE* lpsz = NULL, DWORD dwLen = 0)
    {
        DIMM_IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return;

        if (lpsz)
            WriteCompData(lpsz, dwLen);
    }

    CompData(DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr)
    {
    }

    CompData(DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr, DWORD dwIndex);

    DWORD WriteCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();
        if (!psz)
            return 0;

        DWORD index = dwLen;
        while (index--) {
            *psz++ = data;
        }

        return dwLen;
    }

    DWORD WriteCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();
        if (!psz)
            return 0;

        memcpy(psz, lpSrc, dwLen * sizeof(TYPE));
        return dwLen;
    }

    DWORD AddCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData();
        if (!psTemp)
            return 0;

        memcpy(psTemp+dwl, lpSrc, dwLen*sizeof(TYPE));

        return dwLen;
    }

    DWORD AddCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData();
        if (!psTemp)
            return 0;

        psTemp += dwl;

        DWORD index = dwLen;
        while (index--) {
            *psTemp++ = data;
        }

        return dwLen;
    }

    const INT_PTR ReadCompData(IN ARG_TYPE* lpDest = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_array.GetSize();
        }
        else {
            ARG_TYPE* psz = m_array.GetData();
            if ((INT_PTR)dwLen > m_array.GetSize()) {
                dwBufLen = m_array.GetSize();
            }
            else {
                dwBufLen = (INT_PTR)dwLen;
            }
            memcpy(lpDest, psz, dwBufLen * sizeof(TYPE));
        }
        return dwBufLen;
    }

    DWORD GetCompStrIndex(IN DWORD dwIndex) {
        switch(dwIndex) {
            case GCS_COMPATTR:         return GCS_COMPSTR;
            case GCS_COMPREADATTR:     return GCS_COMPREADSTR;
            case GCS_COMPCLAUSE:       return GCS_COMPSTR;
            case GCS_COMPREADCLAUSE:   return GCS_COMPREADSTR;
            case GCS_RESULTCLAUSE:     return GCS_RESULTSTR;
            case GCS_RESULTREADCLAUSE: return GCS_RESULTREADSTR;
            case GCS_CURSORPOS:        return GCS_COMPSTR;
            case GCS_DELTASTART:       return GCS_COMPSTR;
            default:                   break;
        }
        ASSERT(FALSE);
        return 0;
    }

    TYPE GetAt(INT_PTR nIndex) const
    {
        return  m_array.GetAt(nIndex);
    }

    void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
    {
        m_array.SetAtGrow(nIndex, newElement);
    }

    INT_PTR Add(ARG_TYPE newElement)
    {
        return m_array.Add(newElement);
    }

    INT_PTR GetSize() const
    {
        return m_array.GetSize();
    }

    void RemoveAll()
    {
        m_array.RemoveAll();
    }

    operator void* ()
    {
        return m_array.GetData();
    }

    TYPE operator[](INT_PTR nIndex)
    {
        return m_array.GetAt(nIndex);
    }

protected:
    CArray<TYPE, ARG_TYPE>    m_array;
};

template<class TYPE, class ARG_TYPE>
CompData<TYPE, ARG_TYPE>::CompData(
    DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
    DWORD dwIndex
    )
{
    switch (dwIndex) {
        case GCS_COMPSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompStrOffset),
                                                            lpCompStr->CompStr.dwCompStrLen);        // # of chars
            break;
        case GCS_COMPREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadStrOffset),
                                                            lpCompStr->CompStr.dwCompReadStrLen);    // # of chars
            break;
        case GCS_RESULTSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultStrOffset),
                                                            lpCompStr->CompStr.dwResultStrLen);      // # of chars
            break;
        case GCS_RESULTREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadStrOffset),
                                                            lpCompStr->CompStr.dwResultReadStrLen);  // # of chars
            break;

        case GCS_COMPATTR:        // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompAttrOffset),
                                                            lpCompStr->CompStr.dwCompAttrLen);
            break;
        case GCS_COMPREADATTR:    // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadAttrOffset),
                                                            lpCompStr->CompStr.dwCompReadAttrLen);
            break;

        case GCS_COMPREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadClauseOffset),
                                                            lpCompStr->CompStr.dwCompReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultClauseOffset),
                                                            lpCompStr->CompStr.dwResultClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadClauseOffset),
                                                            lpCompStr->CompStr.dwResultReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_COMPCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompClauseOffset),
                                                            lpCompStr->CompStr.dwCompClauseLen / sizeof(TYPE));    // # of bytes
            break;

        case GCS_CURSORPOS:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwCursorPos);
            break;
        case GCS_DELTASTART:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwDeltaStart);
            break;

        default:
            break;
    }
}


class CWCompString;


/////////////////////////////////////////////////////////////////////////////
// CBCompString

class CBCompString : public CompData<CHAR, CHAR>
{
public:
    CBCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<CHAR, CHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<CHAR, CHAR>(lpCompStr),
                                                              m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<CHAR, CHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CBCompString& operator=(CWCompString& wcompstr);

    const DWORD ConvertUnicodeString(IN OUT LPWSTR lpsz = NULL, DWORD cch = 0)
    {
        return _mbstowcs(lpsz, cch);
    }

    CHAR GetAt(IN DWORD dwIndex)
    {
        return CompData<CHAR, CHAR>::GetAt(dwIndex);
    }

    BOOL IsDBCSLeadByteEx(IN DWORD dwIndex)
    {
         CHAR c = GetAt(dwIndex);
         return ::IsDBCSLeadByteEx(m_cp, c);
    }

private:
    UINT      m_cp;            // code page value.

    int _mbstowcs(wchar_t* wcstr, size_t cch);
};

inline
int
CBCompString::_mbstowcs(
    wchar_t* wcstr,
    size_t cch
    )
{
    if (cch == 0 && wcstr != NULL)
        return 0;

    const char* mbstr = m_array.GetData();
    if (!mbstr)
        return 0;

    INT_PTR nSize = m_array.GetSize();

    int result = ::MultiByteToWideChar(m_cp,     // code page
                                       0,        // character-type option
                                       mbstr,    // address of string to map
                                       (int)nSize,    // number of bytes in string
                                       wcstr,    // address of wide-char buffer
                                       (int)cch);   // size of buffer, in wide character

    return result;
}



/////////////////////////////////////////////////////////////////////////////
// CWCompString

class CWCompString : public CompData<WCHAR, WCHAR>
{
public:
    CWCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPWSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<WCHAR, WCHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<WCHAR, WCHAR>(lpCompStr),
                                                              m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<WCHAR, WCHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CWCompString& operator=(CBCompString& bcompstr);

    const DWORD ConvertANSIString(IN OUT LPSTR lpsz = NULL, DWORD dwLen = 0)
    {
        return _wcstombs(lpsz, dwLen);
    }

    WCHAR GetAt(IN DWORD dwIndex)
    {
        return (WCHAR)CompData<WCHAR, WCHAR>::GetAt(dwIndex);
    }

    int UnicodeToMultiByteSize(IN DWORD dwIndex)
    {
        WCHAR wc = GetAt(dwIndex);
        return ::WideCharToMultiByte(m_cp,     // code page
                                     0,        // performance and mapping flags
                                     (const wchar_t*)&wc,     // address of wide-char string
                                     1,        // number of char string
                                     NULL,     // address of buffer for new string
                                     0,        // size of buffer
                                     NULL,     // default for unmappable char
                                     NULL);    // flag set when default char
    }

private:
    UINT      m_cp;            // code page value.

    int _wcstombs(char* mbstr, size_t count);
};

inline
int
CWCompString::_wcstombs(
    char* mbstr,
    size_t count
    )
{
    if (count == 0 && mbstr != NULL)
        return 0;

    const wchar_t* wcstr = m_array.GetData();
    if (!wcstr)
        return 0;

    INT_PTR nSize = m_array.GetSize();

    int result = ::WideCharToMultiByte(m_cp,     // code page
                                       0,        // performance and mapping flags
                                       wcstr,    // address of wide-char string
                                       (int)nSize,    // number of char string
                                       mbstr,    // address of buffer for new string
                                       (int)count,    // size of buffer
                                       NULL,     // default for unmappable char
                                       NULL);    // flag set when default char

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// CBCompStrin/CWCompString::operator=

inline
const CBCompString&
CBCompString::operator=(
    CWCompString& wcompstr
    )

/*+++
 *
 * Get ANSI string from Unicode composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = wcompstr.ConvertANSIString();
    m_array.SetSize(len);

    LPSTR psz = m_array.GetData();
    if (psz)
        len = wcompstr.ConvertANSIString(psz, len * sizeof(CHAR));

    return *this;
}

inline
const CWCompString&
CWCompString::operator=(
    CBCompString& bcompstr
    )

/*+++
 *
 * Get Unicode string from ANSI composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = bcompstr.ConvertUnicodeString();
    m_array.SetSize(len);

    LPWSTR psz = m_array.GetData();
    if (psz)
        len = bcompstr.ConvertUnicodeString(psz, len);

    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckAttribute template

template<class APPS_ATTR, class HIMC_ATTR, class HIMC_CLAUSE>
HRESULT
CheckAttribute(
    APPS_ATTR& apps_attr,                        // the attr from apps
    HIMC_ATTR& himc_attr,                        // the attr from IMC
    HIMC_CLAUSE& himc_clause                     // the clause from IMC
    )
{
    if (himc_clause.ReadCompData() == 0) {
        TraceMsg(TF_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
    }
    else {
        if (himc_attr.ReadCompData() != 0) {
            if (apps_attr.GetSize() != himc_attr.GetSize()) {
                TraceMsg(TF_ERROR, "CheckAttribute: wrong length.");
                return E_FAIL;
            }

            /*
             * The attr. of chars of one clause have to be same.
             */
            DWORD dwAttrIndex = 0;
            DWORD dwClauseIndex;
            for (dwClauseIndex = 0;
                 (INT_PTR)himc_clause.GetAt(dwClauseIndex) < apps_attr.ReadCompData();
                 dwClauseIndex++
                ) {
                DWORD dwBound = himc_clause.GetAt(dwClauseIndex+1) - himc_clause.GetAt(dwClauseIndex);
                DWORD battr = apps_attr.GetAt(dwAttrIndex++);
                DWORD dwCnt;
                for (dwCnt = 1; dwCnt < dwBound; dwCnt++) {
                    if (battr != apps_attr.GetAt(dwAttrIndex++)) {
                        TraceMsg(TF_ERROR, "CheckAttribute: mismatch clause attribute.");
                        return E_FAIL;
                    }
                }
            }
        }
    }

    return S_OK;
}

class CWCompAttribute;

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute

class CBCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CBCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                              m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CBCompAttribute& operator=(CWCompAttribute& wcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompAttribute

class CWCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CWCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                              m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CWCompAttribute& operator=(CBCompAttribute& bcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CWCompString    m_wcompstr;
};

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute/CWCompAttribute::operator=

inline
const CBCompAttribute&
CBCompAttribute::operator=(
    CWCompAttribute& wcompattr
    )

/*+++
 *
 * Get ANSI attribute from Unicode composition attribute.
 *
---*/

{
    m_bcompstr = wcompattr.m_wcompstr;
    INT_PTR dwAttrIndexW = 0;
    INT_PTR dwStrIndex = 0;
    while ( dwStrIndex   < m_bcompstr.ReadCompData() &&
            dwAttrIndexW <  wcompattr.ReadCompData() &&
            m_bcompstr.GetAt((DWORD)dwStrIndex) != '\0'
          ) {
        if (m_bcompstr.IsDBCSLeadByteEx((DWORD)dwStrIndex)) {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex += 2;
        }
        else {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex++;
        }
        dwAttrIndexW++;
    }
    return *this;
}

inline
const CWCompAttribute&
CWCompAttribute::operator=(
    CBCompAttribute& bcompattr
    )

/*+++
 *
 * Get Unicode attribute from ANSI composition attribute.
 *
---*/

{
    m_wcompstr = bcompattr.m_bcompstr;
    INT_PTR dwAttrIndexA = 0;
    INT_PTR dwStrIndex = 0;
    while ( dwStrIndex   < m_wcompstr.ReadCompData() &&
            dwAttrIndexA <  bcompattr.ReadCompData() &&
            m_wcompstr.GetAt((DWORD)dwStrIndex) != '\0' 
          ) {
        if (m_wcompstr.UnicodeToMultiByteSize((DWORD)dwStrIndex) == 2) {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA += 2;
        }
        else {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA++;
        }
        dwStrIndex++;
    }
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckClause template


template<class APPS_CLAUSE, class HIMC_CLAUSE>
HRESULT
CheckClause(
    APPS_CLAUSE& apps_clause,                 // the clause from apps
    HIMC_CLAUSE& himc_clause                  // the clause from IMC
    )
{
    if (apps_clause.ReadCompData() == 0 ||
        himc_clause.ReadCompData() == 0  ) {
        TraceMsg(TF_ERROR, "CheckClause: no Clause.");
        return E_FAIL;
    }

    if (apps_clause.GetAt(0) ||
        himc_clause.GetAt(0)   ) {
        TraceMsg(TF_ERROR, "CheckClause: clause[0] have to be ZERO.");
        return E_FAIL;
    }

    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < himc_clause.ReadCompData();
         dwClauseIndex++
        ) {
        if (apps_clause.GetAt((DWORD)dwClauseIndex) != himc_clause.GetAt((DWORD)dwClauseIndex)) {
            return E_FAIL;
        }
    }

    return S_OK;
}


class CWCompClause;


/////////////////////////////////////////////////////////////////////////////
// CBCompClause

class CBCompClause : public CompData<DWORD, DWORD>
{
public:
    CBCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CBCompClause& operator=(CWCompClause& wcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompClause

class CWCompClause : public CompData<DWORD, DWORD>
{
public:
    CWCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CWCompClause& operator=(CBCompClause& bcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompClause/CWCompClause::operator=

inline
const CBCompClause&
CBCompClause::operator=(
    CWCompClause& wcompclause
    )

/*+++
 *
 * Get ANSI clause from Unicode composition clause.
 *
---*/

{
    m_bcompstr = wcompclause.m_wcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < wcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionWtoA( wcompclause.GetAt((DWORD)dwClauseIndex), &wcompclause.m_wcompstr ) );
    }
    return *this;
}

inline
const CWCompClause&
CWCompClause::operator=(
    CBCompClause& bcompclause
    )

/*+++
 *
 * Get Unicode clause from ANSI composition clause.
 *
---*/

{
    m_wcompstr = bcompclause.m_bcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < bcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionAtoW( bcompclause.GetAt((DWORD)dwClauseIndex), &bcompclause.m_bcompstr ) );
    }
    return *this;
}


class CWCompCursorPos;

/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos

class CBCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CBCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_bcompstr(cp, hIMC)
    {
    };

    CBCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CBCompCursorPos& operator=(CWCompCursorPos& wcompcursor);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompCursorPos

class CWCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CWCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(cp, hIMC)
    {
    };

    CWCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CWCompCursorPos& operator=(CBCompCursorPos& bcompcursorpos);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos/CWCompCursorPos::operator=

inline
const CBCompCursorPos&
CBCompCursorPos::operator=(
    CWCompCursorPos& wcompcursor
    )

/*+++
 *
 * Get ANSI cursor/delta start position from Unicode composition string.
 *
---*/

{
    if (wcompcursor.m_wcompstr.GetSize() > 0)
    {
        m_bcompstr = wcompcursor.m_wcompstr;
    
        m_array.SetAtGrow( 0, CalcCharacterPositionWtoA(wcompcursor.GetAt(0), &wcompcursor.m_wcompstr) );
    }
    return *this;
}

inline
const CWCompCursorPos&
CWCompCursorPos::operator=(
    CBCompCursorPos& bcompcursor
    )

/*+++
 *
 * Get Unicode cursor/delta start position from ANSI composition string.
 *
---*/

{
    if (bcompcursor.m_bcompstr.GetSize() > 0)
    {
        m_wcompstr = bcompcursor.m_bcompstr;
        m_array.SetAtGrow( 0, CalcCharacterPositionAtoW(bcompcursor.GetAt(0), &bcompcursor.m_bcompstr) );
    }
    return *this;
}


class CWReconvertString;

/////////////////////////////////////////////////////////////////////////////
// CBReconvetString

class CBReconvertString
{
public:
    CBReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_bcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;
        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_bcompstr.WriteCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset;
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset;
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_bcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_bcompstr.ReadCompData() * sizeof(CHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)(m_bcompstr.ReadCompData() * sizeof(CHAR));
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(CHAR));
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(CHAR));

            dwBufLen = m_bcompstr.ReadCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CBReconvertString& operator=(CWReconvertString& wReconvStr);

    void SetData(CWReconvertString& wReconvStr);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

public:
    CBCompString    m_bcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CBCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CBCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};


/////////////////////////////////////////////////////////////////////////////
// CWReconvertString

class CWReconvertString
{
public:
    CWReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_wcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;

        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_wcompstr.WriteCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset / sizeof(WCHAR);   // char count
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset / sizeof(WCHAR);  // char count
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_wcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_wcompstr.ReadCompData() * sizeof(WCHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)m_wcompstr.ReadCompData();
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(WCHAR));  // byte count
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(WCHAR));  // byte count

            dwBufLen = m_wcompstr.ReadCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CWReconvertString& operator=(CBReconvertString& bReconvStr);

    void SetData(CBReconvertString& bReconvStr);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

public:
    CWCompString    m_wcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CWCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CWCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};

/////////////////////////////////////////////////////////////////////////////
// CBCompReconvertString/CWCompReconvertString::operator=

inline
const CBReconvertString&
CBReconvertString::operator=(
    CWReconvertString& wReconvStr
    )
{
    m_bcompstr = wReconvStr.m_wcompstr;
    SetData(wReconvStr);
    return *this;
}

inline
const CWReconvertString&
CWReconvertString::operator=(
    CBReconvertString& bReconvStr
    )
{
    m_wcompstr = bReconvStr.m_bcompstr;
    SetData(bReconvStr);
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CBReconvertString/CWReconvertString::SetData

inline
void
CBReconvertString::SetData(
    CWReconvertString& wReconvStr
    )
{
    m_dwVersion = wReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex), &wReconvStr.m_wcompstr);
    m_CompStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen), &wReconvStr.m_wcompstr) - m_CompStrIndex;
    m_TargetStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex), &wReconvStr.m_wcompstr);
    m_TargetStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex + wReconvStr.m_TargetStrLen), &wReconvStr.m_wcompstr) - m_TargetStrIndex;
}

inline
void
CWReconvertString::SetData(
    CBReconvertString& bReconvStr
    )
{
    m_dwVersion = bReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex), &bReconvStr.m_bcompstr);
    m_CompStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex + bReconvStr.m_CompStrLen), &bReconvStr.m_bcompstr) - m_CompStrIndex);
    m_TargetStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex), &bReconvStr.m_bcompstr);
    m_TargetStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex + bReconvStr.m_TargetStrLen), &bReconvStr.m_bcompstr) - m_TargetStrIndex);
}













/////////////////////////////////////////////////////////////////////////////
// CWInterimString

class CWInterimString
{
public:
    CWInterimString(
        UINT cp,
        HIMC hIMC
        ) : m_wresultstr(cp, hIMC)
    {
        m_InterimChar = L'\0';
        m_InterimAttr = 0;
    }

    DWORD WriteResultStr(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        return m_wresultstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadResultStr(IN LPWSTR lpSrc = NULL, DWORD dwLen = 0)
    {
        return (DWORD)m_wresultstr.ReadCompData(lpSrc, dwLen);
    }

    VOID WriteInterimChar(WCHAR ch, BYTE attr)
    {
        m_InterimChar = ch;
        m_InterimAttr = attr;
    }

    void ReadInterimChar(WCHAR* ch, BYTE* attr)
    {
        *ch   = m_InterimChar;
        *attr = m_InterimAttr;
    }

public:
    CWCompString    m_wresultstr;

    WCHAR           m_InterimChar;
    BYTE            m_InterimAttr;
};




/////////////////////////////////////////////////////////////////////////////
// CWCompTfGuidAtom

class CWCompTfGuidAtom : public CompData<TfGuidAtom, TfGuidAtom>
{
public:
};




/////////////////////////////////////////////////////////////////////////////
// friend

inline
DWORD
CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    CBCompString* bcompstr
    )

/*+++

    Calculation Unicode character position to ANSI character position

---*/

{
    DWORD dwCharPosW = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosA != 0) {
        if (bcompstr->IsDBCSLeadByteEx(dwStrIndex)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            dwStrIndex += 2;
        }
        else {
            dwCharPosA--;
            dwStrIndex++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}

inline
DWORD
CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    CWCompString* wcompstr
    )

/*+++

    Calculate ANSI character position to Unicode character position.

---*/

{
    DWORD dwCharPosA = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosW != 0) {
        if (wcompstr->UnicodeToMultiByteSize(dwStrIndex) == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwStrIndex++;
        dwCharPosW--;
    }

    return dwCharPosA;
}

#endif // IMCCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imclock2.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imclock2.h

Abstract:

    This file defines the DIMM_IMCLock / DIMM_IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#ifndef IMCLOCK2_H
#define IMCLOCK2_H

#define  _ENABLE_AIME_CONTEXT_
#include "imclock.h"

class DIMM_IMCLock : public _IMCLock
{
public:
    DIMM_IMCLock(HIMC hImc=NULL);
    virtual ~DIMM_IMCLock() {
        if (m_inputcontext) {
            _UnlockIMC(m_himc);
        }
    }

    // virtual DIMM_InternalIMCCLock
    HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT_AIMM12** ppIMC);
    HRESULT _UnlockIMC(HIMC hIMC);

private:
    // Do not allow to make a copy
    DIMM_IMCLock(DIMM_IMCLock&) { }
};


class DIMM_InternalIMCCLock : public _IMCCLock
{
public:
    DIMM_InternalIMCCLock(HIMCC hImcc=NULL);
    virtual ~DIMM_InternalIMCCLock() {
        if (m_pimcc) {
            _UnlockIMCC(m_himcc);
        }
    }

    // virtual DIMM_InternalIMCCLock
    HRESULT _LockIMCC(HIMCC hIMCC, void** ppv);
    HRESULT _UnlockIMCC(HIMCC hIMCC);

private:
    // Do not allow to make a copy
    DIMM_InternalIMCCLock(DIMM_InternalIMCCLock&) { }
};


template <class T>
class DIMM_IMCCLock : public DIMM_InternalIMCCLock
{
public:
    DIMM_IMCCLock(HIMCC hImcc=NULL) : DIMM_InternalIMCCLock(hImcc) {};

    T* GetBuffer() { return (T*)m_pimcc; }

    operator T*() { return (T*)m_pimcc; }

    T* operator->() {
        ASSERT(m_pimcc);
        return (T*)m_pimcc;
    }

private:
    // Do not allow to make a copy
    DIMM_IMCCLock(DIMM_IMCCLock<T>&) { }
};


#endif // IMCLOCK2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imewnd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewnd.h

Abstract:

    This file defines the Default IME Window Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMEWND_H_
#define _IMEWND_H_

#include "cstring.h"

extern "C" {
    // windows subclass
    LRESULT ImeWndProcA(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ImeWndProcW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
}

class CDefaultIMEWindow
{
public:
    CDefaultIMEWindow() {
        m_hDefaultIMEWnd = NULL;
        m_hDummyDefaultIMEWnd = NULL;
        m_nCntInAIMEProc = 0;

        m_bMyRegisterClass = FALSE;
        m_bMyCreateWindow = FALSE;
        // m_bNeedRecoverIMEWndProc = FALSE;

        m_SubclassWindowProc = 0;
    }

    virtual ~CDefaultIMEWindow() {
        if (IsWindow(m_hDefaultIMEWnd) && m_SubclassWindowProc) {
            //
            // Set the wndproc pointer back to original WndProc.
            //
            // some other subclass window may keep my WndProc pointer.
            // but msctf.dll may be unloaded from memory so we don't want to
            // call him to set the wndproc pointer back to our Wndproc pointer.
            // The pointer will be bogus.
            //
            WNDPROC pfnOrgImeWndProc;
            pfnOrgImeWndProc = (WNDPROC)GetClassLongPtr(m_hDefaultIMEWnd, GCLP_WNDPROC);
            SetWindowLongPtr(m_hDefaultIMEWnd,
                             GWLP_WNDPROC,
                             (LONG_PTR)pfnOrgImeWndProc);
            m_SubclassWindowProc = NULL;
        }
    }

    HRESULT GetDefaultIMEWnd(IN HWND hWnd, OUT HWND *phDefWnd);
    LRESULT CallWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT  SendIMEMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE,
                            BOOL fCheckImm32 = TRUE) {
        if (fCheckImm32 && IsOnImm()) {
            return 0L;
        }

        LRESULT lRet;
        InterlockedIncrement(&m_nCntInAIMEProc);    // Mark to avoid recursion.
        if (fUnicode)
            lRet = SendMessageW(m_hDefaultIMEWnd, Msg, wParam, lParam);
        else
            lRet = SendMessageA(m_hDefaultIMEWnd, Msg, wParam, lParam);
        InterlockedDecrement(&m_nCntInAIMEProc);
        return lRet;
    }

    BOOL IsAIMEHandler()
    {
        return (m_nCntInAIMEProc > 0);
    }

public:
    BOOL _CreateDefaultIMEWindow(HIMC hDefIMC);
    BOOL _DestroyDefaultIMEWindow();

protected:
    HWND _CreateIMEWindow(HIMC hDefIMC);

public:
    BOOL IsNeedRecovIMEWndProc() {
#if 0
        return (m_bNeedRecoverIMEWndProc == TRUE);
#endif
        return FALSE;
    }

private:
#if 0
    BOOL InitDefIMEWndSubclass() {
        if (m_SubclassWindowProc == NULL) {
            m_SubclassWindowProc = SetWindowLongPtr(m_hDefaultIMEWnd,
                                                    GWLP_WNDPROC,
                                                    (LONG_PTR)ImeWndProcA);
            if (IsOnImm()) {
                LONG_PTR _OriginalWindowProc = GetWindowLongPtr(m_hDummyDefaultIMEWnd,
                                                                GWLP_WNDPROC);
                //
                // We assume the m_SubclassWindowProc and _OriginalWindowProc are
                // the same address of USER32!ImeWndProcA/W.
                //
                if (m_SubclassWindowProc != _OriginalWindowProc) {
                    //
                    // Anybody rewrote the default IME window procedure address.
                    // We know the MSIME9x/2K rewrote an address to MSIMEPrivateWindowProc.
                    // We should catch a recovery procedure address by the IME
                    // that using window call hook the _DefImeWnd_CallWndProc.
                    //
                    m_bNeedRecoverIMEWndProc = TRUE;
                }
            }
        }
        return (m_SubclassWindowProc != 0);
    }
#endif
    BOOL Start() {
        Assert(IsWindow(m_hDefaultIMEWnd));
        if (m_SubclassWindowProc == NULL) {
            m_SubclassWindowProc = SetWindowLongPtr(m_hDefaultIMEWnd,
                                                    GWLP_WNDPROC,
                                                    (LONG_PTR)ImeWndProcA);
        }
        return (m_SubclassWindowProc != 0);
    }

#if 0
    VOID UninitDefIMEWndSubclass() {
        if (m_SubclassWindowProc) {
            SetWindowLongPtr(m_hDefaultIMEWnd,
                             GWLP_WNDPROC,
                             m_SubclassWindowProc);
            m_SubclassWindowProc = NULL;
        }
    }
#endif
    WNDPROC Stop() {
        Assert(IsWindow(m_hDefaultIMEWnd));
        WNDPROC pfnBack = (WNDPROC)m_SubclassWindowProc;
        if (m_SubclassWindowProc != NULL) {
            //
            // unfortunately, we can not restore the wndproc pointer always.
            // someone else subclassed it after we did.
            //
            WNDPROC pfnCur = (WNDPROC)GetWindowLongPtr(m_hDefaultIMEWnd, GWLP_WNDPROC);
            if (pfnCur == ImeWndProcA) {
                SetWindowLongPtr(m_hDefaultIMEWnd,
                                 GWLP_WNDPROC,
                                 (LONG_PTR) m_SubclassWindowProc);
                m_SubclassWindowProc = NULL;
            }
        }
        return pfnBack;
    }

public:
    VOID ImeDefWndHook(HWND hWnd) {
#if 0
        LONG_PTR _WindowProc = GetWindowLongPtr(m_hDefaultIMEWnd,
                                                GWLP_WNDPROC);
        ASSERT(m_hDummyDefaultIMEWnd != NULL);
        LONG_PTR _OriginalWindowProc = GetWindowLongPtr(m_hDummyDefaultIMEWnd,
                                                        GWLP_WNDPROC);
        if (_WindowProc == _OriginalWindowProc) {
            //
            // Recovered procedure address.
            //
            m_SubclassWindowProc = SetWindowLongPtr(m_hDefaultIMEWnd,
                                                    GWLP_WNDPROC,
                                                    (LONG_PTR)ImeWndProcA);
        }
#endif
    }

private:
    HWND         m_hDefaultIMEWnd;          // Handle of default IME window.
    HWND         m_hDummyDefaultIMEWnd;     // Handle of Dummy default IME window.

    LONG         m_nCntInAIMEProc;          // Non-zero if hwnd has called into CCiceroIME::ActivateLayout/DeactivateLayout.

    BOOL         m_bMyRegisterClass;        // TRUE: RegisterClass("IME") myself.
    BOOL         m_bMyCreateWindow;         // TRUE: CreateWindow("IME") myself.
    // BOOL         m_bNeedRecoverIMEWndProc;  // TRUE: Need a recovery IME wnd proc addr.

    LONG_PTR     m_SubclassWindowProc;      // Address of subclass window procedure.
};

LRESULT ImeWndDestroyHandler(HWND hwnd);
LRESULT ImeSelectHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
LRESULT ImeControlHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
LRESULT ImeSetContextHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
LRESULT ImeNotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

#endif // _IMEWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imewndhd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewndhd.h

Abstract:

    This file defines the IME window handler Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMEWNDHD_H_
#define _IMEWNDHD_H_

#include "ctxtlist.h"
#include "globals.h"

extern LPCTSTR IMEWndHandlerName;

class CIMEWindowHandler
{
public:
    CIMEWindowHandler(HWND hwnd = NULL, BOOL fDefault = FALSE);
    ~CIMEWindowHandler();

    LRESULT ImeWndCreateHandler(DWORD style, HIMC hDefIMC);
    LRESULT ImeWndCreateHandler(LPCREATESTRUCT lpcs);

    HIMC ImeGetImc()
    {
        return m_imeui.hIMC;
    }

    VOID ImeSetWnd(HWND hwnd)
    {
        m_imeui.hImeWnd = hwnd;
    }

    LRESULT ImeWndProcWorker(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE);

private:
    LRESULT _ImeWndProcWorker(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);

public:
    VOID    ImeWndFinalDestroyHandler();

private:
    VOID    ImeWndDestroyHandler();
    LRESULT ImeSystemHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeSelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeControlHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeSetContextHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeNotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeMsImeHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);

    LRESULT SendMessageToUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);

    LRESULT ImeActivateLayout(HKL hSelKL, CActiveIMM* pActiveIMM);
    VOID ImeSetImc(HIMC hIMC, CActiveIMM* pActiveIMM);

    VOID ImeMarkUsedContext(HWND hImeWnd, HIMC hIMC, CActiveIMM* pActiveIMM);
    BOOL ImeIsUsableContext(HWND hImeWnd, HIMC hIMC, CActiveIMM* pActiveIMM);
    BOOL ImeBroadCastMsg(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

    int IsIMEHandler()
    {
        return (m_imeui.nCntInIMEProc);
    }

    BOOL IsMsImeMessage(UINT uMsg)
    {
        if (uMsg == WM_MSIME_SERVICE ||
            uMsg == WM_MSIME_UIREADY ||
            uMsg == WM_MSIME_RECONVERTREQUEST ||
            uMsg == WM_MSIME_RECONVERT ||
            uMsg == WM_MSIME_DOCUMENTFEED ||
            uMsg == WM_MSIME_QUERYPOSITION ||
            uMsg == WM_MSIME_MODEBIAS ||
            uMsg == WM_MSIME_SHOWIMEPAD ||
            uMsg == WM_MSIME_MOUSE ||
            uMsg == WM_MSIME_KEYMAP)
            return TRUE;
        else
            return FALSE;
    }

    //
    // Enumrate callbacks
    //
    static ENUM_RET EnumInputContextCallback(HIMC hIMC,
                                             CContextList* pList);

private:
    typedef struct tagIMEUI {
        HWND  hImeWnd;
        HIMC  hIMC;
        LONG  nCntInIMEProc;   // Non-zero if hwnd has called into ImeWndProc.
        BOOL  fDefault:1;      // TRUE if this is the default IME.
    } IMEUI;
    IMEUI     m_imeui;

    HKL   m_hKL_UnSelect;      // Use in ImeActivateLayout() for unselect hKL value.
};



CIMEWindowHandler* GetImeWndHandler(HWND hwnd, BOOL fDefault = FALSE);


#endif // _IMEWNDHD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imewndhd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewndhd.cpp

Abstract:

    This file implements the IME window handler Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"


#include "defs.h"
#include "cdimm.h"
#include "imewndhd.h"
#include "globals.h"

LPCTSTR IMEWndHandlerName = TEXT("IMEWindowHandler");


CIMEWindowHandler::CIMEWindowHandler(
    HWND hwnd,
    BOOL fDefault
    )
{
    m_imeui.hImeWnd = hwnd;
    m_imeui.hIMC = NULL;
    m_imeui.nCntInIMEProc = 0;
    m_imeui.fDefault = fDefault;

    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return;

    _pActiveIMM->_GetKeyboardLayout(&m_hKL_UnSelect);
}

CIMEWindowHandler::~CIMEWindowHandler(
    )
{
}

LRESULT
CIMEWindowHandler::ImeWndProcWorker(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    LRESULT lr;

    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return 0L;

    lr = _ImeWndProcWorker(uMsg, wParam, lParam, fUnicode, _pActiveIMM);

    return lr;
}

LRESULT
CIMEWindowHandler::_ImeWndProcWorker(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )

{
    /*
     * This is necessary to avoid recursion call from IME UI.
     */
    
    if (IsIMEHandler() > 1) {
        TraceMsg(TF_API, "ImeWndProcWorker: Recursive for hwnd=%08x, msg=%08x, wp=%08x, lp=%08x", m_imeui.hImeWnd, uMsg, wParam, lParam);
        switch (uMsg) {
            case WM_IME_STARTCOMPOSITION:
            case WM_IME_ENDCOMPOSITION:
            case WM_IME_COMPOSITION:
            case WM_IME_SETCONTEXT:
            case WM_IME_NOTIFY:
            case WM_IME_CONTROL:
            case WM_IME_COMPOSITIONFULL:
            case WM_IME_SELECT:
            case WM_IME_CHAR:
            case WM_IME_REQUEST:
                return 0L;
            default:
                return pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, uMsg, wParam, lParam);
        }
    }

    switch (uMsg) {
        case WM_CREATE:
            ImeWndCreateHandler((LPCREATESTRUCT)lParam);
            break;

        case WM_DESTROY:
            /*
             * We are destroying the IME window,
             * destroy any UI window that it owns.
             */
            ImeWndDestroyHandler();
            break;

        case WM_NCDESTROY:
        /* case WM_FINALDESTROY: */
            pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, uMsg, wParam, lParam);
            ImeWndFinalDestroyHandler();
            return 0L;

        case WM_IME_SYSTEM:
            if (ImeSystemHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM))
                return 0L;
            break;

        case WM_IME_SELECT:
            ImeSelectHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_CONTROL:
            ImeControlHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_SETCONTEXT:
            ImeSetContextHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_NOTIFY:
            ImeNotifyHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_REQUEST:
            break;

        case WM_IME_COMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_IME_STARTCOMPOSITION:
        {
            LRESULT lret;
            lret = SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);

            if (!pActiveIMM->_IsRealIme())
                return lret;

            break;
        }

        default:
            if (IsMsImeMessage(uMsg)) {
                if (! pActiveIMM->_IsRealIme()) {
                    return ImeMsImeHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
                }
            }
            break;
    }

    return pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, uMsg, wParam, lParam);
}

LRESULT
CIMEWindowHandler::ImeWndCreateHandler(
    DWORD style,
    HIMC hDefIMC
    )
{
    if ( !(style & WS_POPUP) || !(style & WS_DISABLED)) {
        TraceMsg(TF_WARNING, "IME should have WS_POPUP and WS_DISABLED!!");
        return -1L;
    }

    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return 0L;

    /*
     */
    if (hDefIMC != NULL) {
        if (ImeIsUsableContext(m_imeui.hImeWnd, hDefIMC, _pActiveIMM)) {
            /*
             * Store it for later use.
             */
            ImeSetImc(hDefIMC, _pActiveIMM);
        }
        else {
            ImeSetImc(NULL, _pActiveIMM);
        }
    }
    else {
        ImeSetImc(NULL, _pActiveIMM);
    }

    return 0L;
}

LRESULT
CIMEWindowHandler::ImeWndCreateHandler(
    LPCREATESTRUCT lpcs
    )
{
    HIMC hIMC;

    if (lpcs->hwndParent != NULL) {
        CActiveIMM *_pActiveIMM = GetTLS();
        if (_pActiveIMM == NULL)
            return 0L;

        _pActiveIMM->GetContextInternal(lpcs->hwndParent, &hIMC, FALSE);
    }
    else if (lpcs->lpCreateParams) {
        hIMC = (HIMC)lpcs->lpCreateParams;
    }
    else
        hIMC = NULL;
    return ImeWndCreateHandler(lpcs->style, hIMC);
}

VOID
CIMEWindowHandler::ImeWndDestroyHandler(
    )
{
}

VOID
CIMEWindowHandler::ImeWndFinalDestroyHandler(
    )
{
    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return;

    _pActiveIMM->_ImeWndFinalDestroyHandler();

    SetProp(m_imeui.hImeWnd, IMEWndHandlerName, NULL);
    delete this;
}

LRESULT
CIMEWindowHandler::ImeSystemHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    LRESULT dwRet = 0L;

    switch (wParam) {
        case IMS_ACTIVATETHREADLAYOUT:
            return ImeActivateLayout((HKL)lParam, pActiveIMM);
#ifdef CICERO_3564
        case IMS_FINALIZE_COMPSTR:
            if (! pActiveIMM->_IsRealIme())
            {
                /*
                 * KOREAN:
                 *  Finalize current composition string
                 */
                HIMC hIMC = ImeGetImc();
                pActiveIMM->NotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
            }
            break;
#endif // CICERO_3564
    }

    return dwRet;
}

LRESULT
CIMEWindowHandler::ImeSelectHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    /*
     * Deliver this message to other IME windows in this thread.
     */
    if (! pActiveIMM->_IsRealIme((HKL)lParam) && m_imeui.fDefault)
        ImeBroadCastMsg(uMsg, wParam, lParam, fUnicode);

    /*
     * We must re-create UI window of newly selected IME.
     */
    return pActiveIMM->_ImeSelectHandler(uMsg, wParam, lParam, fUnicode, ImeGetImc());
}

LRESULT
CIMEWindowHandler::ImeControlHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    /*
     * Do nothing with NULL hIMC.
     */
    HIMC hIMC = ImeGetImc();

    switch (wParam) {
        case IMC_OPENSTATUSWINDOW:
        case IMC_CLOSESTATUSWINDOW:
            pActiveIMM->HideOrRestoreToolbarWnd(IMC_OPENSTATUSWINDOW == wParam);
            break;

        /*
         * ------------------------------------------------
         * IMC_SETCOMPOSITIONFONT,
         * IMC_SETCONVERSIONMODE,
         * IMC_SETOPENSTATUS
         * ------------------------------------------------
         * Don't pass these WM_IME_CONTROLs to UI window.
         * Call Imm in order to process these requests instead.
         * It makes message flows simpler.
         */
        case IMC_SETCOMPOSITIONFONT:
            if (hIMC != NULL)
            {
                LOGFONTAW* lplf = (LOGFONTAW*)lParam;
                if (fUnicode)
                {
                    if (FAILED(pActiveIMM->SetCompositionFontW(hIMC, (LOGFONTW *)lplf)))
                        return 1L;
                }
                else
                {
                    if (FAILED(pActiveIMM->SetCompositionFontA(hIMC, (LOGFONTA *)lplf)))
                        return 1L;
                }
            }
            break;

        case IMC_SETCONVERSIONMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(pActiveIMM->GetConversionStatus(hIMC, &dwConversion, &dwSentence)) ||
                    FAILED(pActiveIMM->SetConversionStatus(hIMC, (DWORD)lParam, dwSentence)))
                    return 1L;
            }
            break;

        case IMC_SETSENTENCEMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(pActiveIMM->GetConversionStatus(hIMC, &dwConversion, &dwSentence)) ||
                    FAILED(pActiveIMM->SetConversionStatus(hIMC, dwConversion, (DWORD)lParam)))
                    return 1L;
            }
            break;

        case IMC_SETOPENSTATUS:
            if (hIMC != NULL)
            {
                if (FAILED(pActiveIMM->SetOpenStatus(hIMC, (int)lParam)))
                    return 1L;
            }
            break;

#if 0   // internal
        case IMC_GETCONVERSIONMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(GetTeb()->GetConversionStatus(hIMC, &dwConversion, &dwSentence)))
                    return 1L;
                return dwConversion;
            }

        case IMC_GETSENTENCEMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(GetTeb()->GetConversionStatus(hIMC, &dwConversion, &dwSentence)))
                    return 1L;
                return dwSentence;
            }

        case IMC_GETOPENSTATUS:
            if (hIMC != NULL)
                return GetTeb()->GetOpenStatus(hIMC);
#endif

        case IMC_GETCOMPOSITIONFONT:
            if (hIMC != NULL)
            {
                LOGFONTAW* lplf = (LOGFONTAW*)lParam;
                if (fUnicode)
                {
                    if (FAILED(pActiveIMM->GetCompositionFontW(hIMC, (LOGFONTW *)lplf)))
                        return 1L;
                }
                else
                {
                    if (FAILED(pActiveIMM->GetCompositionFontA(hIMC, (LOGFONTA *)lplf)))
                        return 1L;
                }
            }
            break;

        case IMC_SETCOMPOSITIONWINDOW:
            if (hIMC != NULL)
            {
                if (FAILED(pActiveIMM->SetCompositionWindow(hIMC, (LPCOMPOSITIONFORM)lParam)))
                    return 1L;
            }
            break;

        case IMC_SETSTATUSWINDOWPOS:
            if (hIMC != NULL)
            {
                POINT ppt;
                ppt.x = (LONG)((LPPOINTS)&lParam)->x;
                ppt.y = (LONG)((LPPOINTS)&lParam)->y;
                if (FAILED(pActiveIMM->SetStatusWindowPos(hIMC, &ppt)))
                    return 1L;
            }
            break;

        case IMC_SETCANDIDATEPOS:
            if (hIMC != NULL)
            {
                if (FAILED(pActiveIMM->SetCandidateWindow(hIMC, (LPCANDIDATEFORM)lParam)))
                    return 1L;
            }
            break;

        /*
         * Followings are the messages to be sent to UI.
         */
        case IMC_GETCANDIDATEPOS:
        case IMC_GETSTATUSWINDOWPOS:
        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_GETSOFTKBDPOS:
        case IMC_SETSOFTKBDPOS:
            if (hIMC != NULL)
                return SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);

        default:
            break;
    }

    return 0L;
}

LRESULT
CIMEWindowHandler::ImeSetContextHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    if (wParam) {
        /*
         * if it's being activated
         */
        if (GetWindowThreadProcessId(m_imeui.hImeWnd, NULL) != GetCurrentThreadId()) {
            TraceMsg(TF_WARNING, "ImeSetContextHandler: Can not access other thread's hIMC");
            return 0L;
        }

        HWND hwndFocus = GetFocus();
        HIMC hFocusImc;

        //
        // hFocusImc always need to set some valid hIMC for SetUIWindowContext().
        // When sets NULL hIMC in SetUIWindowContext(), message deliver to UI window
        // has been stop.
        //
        if (FAILED(pActiveIMM->GetContextInternal(hwndFocus, &hFocusImc, TRUE))) {
            TraceMsg(TF_WARNING, "ImeSetContextHandler: No hFocusImc");
            return 0L;
        }

        /*
         * Cannot share input context with other IME window.
         */
        if (hFocusImc != NULL &&
            ! ImeIsUsableContext(m_imeui.hImeWnd, hFocusImc, pActiveIMM)) {
            ImeSetImc(NULL, pActiveIMM);
            return 0L;
        }

        ImeSetImc(hFocusImc, pActiveIMM);

        /*
         * Store it to the window memory
         */
        pActiveIMM->SetUIWindowContext(hFocusImc);
    }

    return SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);
}

LRESULT
CIMEWindowHandler::ImeNotifyHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    LRESULT lRet = 0L;

    switch (wParam) {
        case IMN_PRIVATE:
            break;

        case IMN_SETCONVERSIONMODE:
        case IMN_SETOPENSTATUS:
            //
            // notify shell and keyboard the conversion mode change
            //

            /*** FALL THROUGH ***/
        default:
            lRet = SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);
    }

    return lRet;
}

LRESULT
CIMEWindowHandler::ImeMsImeHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    return SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);
}

LRESULT
CIMEWindowHandler::SendMessageToUI(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    LRESULT lRet;

    InterlockedIncrement(&m_imeui.nCntInIMEProc);    // Mark to avoid recursion.
    lRet = pActiveIMM->_SendUIMessage(uMsg, wParam, lParam);
    InterlockedDecrement(&m_imeui.nCntInIMEProc);
    return lRet;
}

LRESULT
CIMEWindowHandler::ImeActivateLayout(
    HKL hSelKL,
    CActiveIMM* pActiveIMM
    )
{
    if (hSelKL == m_hKL_UnSelect)
        //
        // Apps startup time, msctf!PostInputLangRequest may calls ActivateKeyboardLayout
        // with Cicero's hKL (04110411 or 08040804).
        // However, CIMEWindowHandle::m_hKL_UnSelect also have Cicero's hKL because
        // this class ask to ITfInputProcessorProfile.
        //
        return TRUE;

    HKL hUnSelKL = m_hKL_UnSelect;

    /*
     * Save IME_CMODE_GUID_NULL and IME_SMODE_GUID_NULL bit in the CContextList
     * When hSelKL is regacy IME, IMM32 SelectInputContext reset this flag.
     */
    CContextList _hIMC_MODE_GUID_NULL;

    Interface<IEnumInputContext> EnumInputContext;
    HRESULT hr = pActiveIMM->EnumInputContext(0,       // 0 = Current Thread
                                              EnumInputContext);
    if (SUCCEEDED(hr)) {
        CEnumrateValue<IEnumInputContext,
                       HIMC,
                       CContextList> Enumrate(EnumInputContext,
                                              EnumInputContextCallback,
                                              &_hIMC_MODE_GUID_NULL);

        Enumrate.DoEnumrate();
    }

    /*
     * Deactivate layout (hUnSelKL).
     */
    pActiveIMM->_DeactivateLayout(hSelKL, hUnSelKL);

    IMTLS *ptls;
    LANGID langid;

    if ((ptls = IMTLS_GetOrAlloc()) != NULL)
    {
        ptls->pAImeProfile->GetLangId(&langid);

        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            //
            // Save open and conversion status for Korean
            //
            if (_hIMC_MODE_GUID_NULL.GetCount() > 0)
            {
                POSITION pos = _hIMC_MODE_GUID_NULL.GetStartPosition();
                int index;
                for (index = 0; index < _hIMC_MODE_GUID_NULL.GetCount(); index++)
                {
                    HIMC hIMC;
                    CContextList::CLIENT_IMC_FLAG client_flag;
                    _hIMC_MODE_GUID_NULL.GetNextHimc(pos, &hIMC, &client_flag);
                    if (client_flag & (CContextList::IMCF_CMODE_GUID_NULL |
                                       CContextList::IMCF_SMODE_GUID_NULL  ))
                    {
                        DIMM_IMCLock imc(hIMC);
                        if (SUCCEEDED(imc.GetResult()))
                            imc->fdwHangul = imc->fdwConversion;
                    }
                }
            }
        }
    }


    // /*
    //  * If either hKL are regacy IME, then should call IMM32's handler.
    //  */
    // if (_pThread->IsRealIme(hSelKL) || _pThread->IsRealIme(hUnSelKL))
        pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, 
                                    WM_IME_SYSTEM, 
                                    IMS_ACTIVATETHREADLAYOUT, 
                                    (LPARAM)hSelKL);

    /*
     * Activate layout (hSelKL).
     */
    pActiveIMM->_ActivateLayout(hSelKL, hUnSelKL);

    /*
     * Restore CContextList's IME_CMODE_GUID_NULL and IME_SMODE_GUID_NULL to each hIMC
     */
    if (_hIMC_MODE_GUID_NULL.GetCount() > 0) {
        POSITION pos = _hIMC_MODE_GUID_NULL.GetStartPosition();
        int index;
        for (index = 0; index < _hIMC_MODE_GUID_NULL.GetCount(); index++) {
            HIMC hIMC;
            CContextList::CLIENT_IMC_FLAG client_flag;
            _hIMC_MODE_GUID_NULL.GetNextHimc(pos, &hIMC, &client_flag);
            if (client_flag & (CContextList::IMCF_CMODE_GUID_NULL |
                               CContextList::IMCF_SMODE_GUID_NULL  )) {
                DIMM_IMCLock imc(hIMC);
                if (SUCCEEDED(imc.GetResult())) {
                    if (PRIMARYLANGID(langid) == LANG_KOREAN) {
                        //
                        // Restore open and conversion status value by changing IMM32
                        //
                            imc->fdwConversion = imc->fdwHangul;
                            if (imc->fdwConversion &
                                (IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE))
                                imc->fOpen = TRUE;
                            else
                                imc->fOpen = FALSE;
                     }
                     if (client_flag & CContextList::IMCF_CMODE_GUID_NULL)
                         imc->fdwConversion |= IME_CMODE_GUID_NULL;
                     if (client_flag & CContextList::IMCF_SMODE_GUID_NULL)
                         imc->fdwSentence   |= IME_SMODE_GUID_NULL;
                }
            }
        }
    }

    /*
     * Set unselect hKL value
     */
    m_hKL_UnSelect = hSelKL;

    return TRUE;
}

VOID
CIMEWindowHandler::ImeSetImc(
    HIMC hIMC,
    CActiveIMM* pActiveIMM
    )
{
    HIMC hOldImc = ImeGetImc();

    /*
     * return if nothing to change.
     */
    if (hIMC == hOldImc)
        return;

    /*
     * Unmark the old input context.
     */
    if (hOldImc != NULL)
        ImeMarkUsedContext(NULL, hOldImc, pActiveIMM);

    /*
     * Update the in use input context for this IME window.
     */
    m_imeui.hIMC = hIMC;

    /*
     * Mark the new input context.
     */
    if (hIMC != NULL)
        ImeMarkUsedContext(m_imeui.hImeWnd, hIMC, pActiveIMM);
}

VOID
CIMEWindowHandler::ImeMarkUsedContext(
    HWND hImeWnd,
    HIMC hIMC,
    CActiveIMM* pActiveIMM
    )

/*+++

    Some IME windows can not share same input context.
    This function marks the specified hIMC to be in used by the specified IME window.

---*/

{
    HWND hImcImeWnd;

    if (! pActiveIMM->_ContextLookup(hIMC, &hImcImeWnd)) {
        TraceMsg(TF_WARNING, "ImeMarkUsedContext: Invalid hImc (=%lx).", hIMC);
        return;
    }

    /*
     * Nothing to change?
     */
    if (hImcImeWnd == hImeWnd)
        return;

    pActiveIMM->_ContextUpdate(hIMC, hImeWnd);
    return;
}

BOOL
CIMEWindowHandler::ImeIsUsableContext(
    HWND hImeWnd,
    HIMC hIMC,
    CActiveIMM* pActiveIMM
    )

/*+++

    Some IME windows can not share the same input context.
    This function checks whether the specified hIMC can be used (means 'Set activated')
    by the specified IME window.

    Return: TRUE - OK to use the hIMC by hImeWnd.
            FALSE - otherwise.

---*/

{
    HWND hImcImeWnd;

    if (! pActiveIMM->_ContextLookup(hIMC, &hImcImeWnd)) {
        TraceMsg(TF_WARNING, "ImeIsUsableContext: Invalid hIMC (=%lx).", hIMC);
        return FALSE;
    }

    if (hImcImeWnd == NULL ||
        hImcImeWnd == hImeWnd ||
        ! IsWindow(hImcImeWnd))
        return TRUE;
    else
        return FALSE;
}

BOOL
CIMEWindowHandler::ImeBroadCastMsg(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    return TRUE;
}


ENUM_RET
CIMEWindowHandler::EnumInputContextCallback(
    HIMC hIMC,
    CContextList* pList
    )
{
    DIMM_IMCLock imc(hIMC);
    if (SUCCEEDED(imc.GetResult())) {
        CContextList::CLIENT_IMC_FLAG client_flag = CContextList::IMCF_NONE;

        if (imc->fdwConversion & IME_CMODE_GUID_NULL)
            client_flag = (CContextList::CLIENT_IMC_FLAG)(client_flag | CContextList::IMCF_CMODE_GUID_NULL);

        if (imc->fdwSentence   & IME_SMODE_GUID_NULL)
            client_flag = (CContextList::CLIENT_IMC_FLAG)(client_flag | CContextList::IMCF_SMODE_GUID_NULL);

        pList->SetAt(hIMC, client_flag);
    }

    return ENUM_CONTINUE;
}


CIMEWindowHandler*
GetImeWndHandler(
    HWND hwnd,
    BOOL fDefault
    )
{
    CIMEWindowHandler* pimeui = static_cast<CIMEWindowHandler*>(GetProp(hwnd, IMEWndHandlerName));
    if (pimeui == NULL) {
        pimeui = new CIMEWindowHandler(hwnd, fDefault);
        if (pimeui == NULL) {
            return NULL;
        }
        SetProp(hwnd, IMEWndHandlerName, pimeui);
    }

    pimeui->ImeSetWnd(hwnd);
    return pimeui;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\imewnd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewnd.cpp

Abstract:

    This file implements the Default IME window Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "defs.h"
#include "imewnd.h"
#include "imewndhd.h"



BOOL
CDefaultIMEWindow::_CreateDefaultIMEWindow(
    HIMC hDefIMC
    )
{
#ifndef CICERO_4678
    //
    // If m_hDefaultIMEWnd's owner is IMM32, then this value always valid hWnd.
    // For CICERO_4678, we should remove this code because subclass window hook
    // never start after Deactivate() and Activate().
    // In Trident and go to another Web page, Trident calls Deactivate() and Activate(),
    // first Deactivate() calls CDefaultIMEWindow::Stop() and
    // next Activate() calls here, however m_hDefaultIMEWnd already exist, then
    // returns immediately. Never calls CDefaultIMEWindow::Start().
    // Note: Cicero bug d/b #4678
    //
    if (m_hDefaultIMEWnd)
        /*
         * already exist IME window.
         */
        return TRUE;
#endif

    if (IsOnImm()) {
        //
        // Create dummy default IME window.
        //
        // When the IsOnImm() is TRUE, this function could get the default IME window handle
        // by using imm32.Imm32_GetDefaultIMEWnd() function.
        // Imm32's GetDefaultIMEWnd might be return no IME window when no any parent window
        // in this thread.
        // However, we can assume that GetDefaultIMEWnd must return a valid IME window.
        // Because, _CreateIMEWindow() function always create a dummy default IME
        // window.
        //
        if (m_hDummyDefaultIMEWnd == NULL) {
            m_hDummyDefaultIMEWnd = _CreateIMEWindow(NULL);
        }

#ifdef CICERO_4678
        if (m_hDefaultIMEWnd == NULL) {
            Imm32_GetDefaultIMEWnd(NULL, &m_hDefaultIMEWnd);
        }
#else
        Imm32_GetDefaultIMEWnd(NULL, &m_hDefaultIMEWnd);
#endif

        if (IsWindow(m_hDefaultIMEWnd) &&
            //
            // Set subclass window procedure.
            //
            Start()
           ) {
            CIMEWindowHandler* pimeui = GetImeWndHandler(m_hDefaultIMEWnd, TRUE);
            if (pimeui == NULL)
                return FALSE;
            pimeui->ImeWndCreateHandler(GetWindowLong(m_hDefaultIMEWnd, GWL_STYLE),
                                        hDefIMC);
        }
    }
    else {
        /*
         * NT5 have a IME class.
         */
        if (! IsOnNT5()) {
            WNDCLASSEX wcWndCls;

            wcWndCls.cbSize        = sizeof(WNDCLASSEX);
            wcWndCls.cbClsExtra    = 0;
            wcWndCls.cbWndExtra    = 0;
            wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
            wcWndCls.hInstance     = g_hInst;
            wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
            wcWndCls.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
            wcWndCls.lpszMenuName  = (LPTSTR)NULL;
            wcWndCls.hIconSm       = NULL;

            wcWndCls.style         = CS_GLOBALCLASS;
            wcWndCls.lpfnWndProc   = ImeWndProcA;
            wcWndCls.lpszClassName = "IME";

            if (! RegisterClassEx(&wcWndCls)) {
                return FALSE;
            }

            m_bMyRegisterClass = TRUE;
        }

        if (m_hDefaultIMEWnd == NULL) {
            m_hDefaultIMEWnd = _CreateIMEWindow(hDefIMC);
            if (m_hDefaultIMEWnd)
                m_bMyCreateWindow = TRUE;
            else
                return FALSE;
        }

        if (IsOnNT5() && IsWindow(m_hDefaultIMEWnd) && ! m_bMyRegisterClass &&
            //
            // Set subclass window procedure.
            //
            Start()
           ) {
            CIMEWindowHandler* pimeui = GetImeWndHandler(m_hDefaultIMEWnd, TRUE);
            if (pimeui == NULL)
                return FALSE;
            pimeui->ImeWndCreateHandler(GetWindowLong(m_hDefaultIMEWnd, GWL_STYLE),
                                        hDefIMC);
        }
    }

    if (m_hDefaultIMEWnd == NULL)
        return FALSE;
    else
        return TRUE;
}

BOOL
CDefaultIMEWindow::_DestroyDefaultIMEWindow(
    )
{
    Stop();

    if (IsWindow(m_hDummyDefaultIMEWnd)) {
        DestroyWindow(m_hDummyDefaultIMEWnd);
    }

    if (m_bMyCreateWindow) {
        DestroyWindow(m_hDefaultIMEWnd);
        m_bMyCreateWindow = FALSE;
        m_hDefaultIMEWnd = NULL;
    }
    else if (IsWindow(m_hDefaultIMEWnd)) {
        //
        // This DefaultIMEWnd is owned by IMM32.
        // If still exist DefaultIMEWnd, then DIMM12 never receive WM_NCDESTROY message
        // in CIMEWindowHandler::ImeWndProcWorker.
        // We need clean up memory of CIMEWindowHandler.
        //
        CIMEWindowHandler* pimeui = GetImeWndHandler(m_hDefaultIMEWnd);
        if (pimeui == NULL)
            return FALSE;
        pimeui->ImeWndFinalDestroyHandler();
    }

    if (m_bMyRegisterClass) {
        UnregisterClass("IME", g_hInst);
        m_bMyRegisterClass = FALSE;
    }

    return TRUE;
};

HWND
CDefaultIMEWindow::_CreateIMEWindow(
    HIMC hDefIMC
    )
{
    return CreateWindow("IME",
                        "",
                        WS_DISABLED | WS_POPUP,
                        0, 0, 0, 0,                    // x, y, width, height
                        NULL,                          // parent
                        NULL,                          // menu
                        g_hInst,
                        hDefIMC);                      // lpParam
}

HRESULT
CDefaultIMEWindow::GetDefaultIMEWnd(
    IN HWND hWnd,
    OUT HWND *phDefWnd
    )
{
    if (IsOnImm()) {
        Imm32_GetDefaultIMEWnd(hWnd, phDefWnd);
    }
    else {
        if (hWnd == NULL) {
            *phDefWnd = m_hDefaultIMEWnd;
        }
        else {
            if (GetWindowThreadProcessId(hWnd, NULL) == GetCurrentThreadId()) {
                *phDefWnd = m_hDefaultIMEWnd;
            }
            else {
                return E_FAIL;
            }
        }
    }

    return S_OK;
}

LRESULT
CDefaultIMEWindow::CallWindowProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (m_SubclassWindowProc != 0) {
        switch (uMsg) {
            case WM_IME_SETCONTEXT:
            case WM_IME_SELECT:
            {
                WNDPROC pfn = Stop();
                LRESULT lRet = ::CallWindowProc(pfn, hWnd, uMsg, wParam, lParam);
                Start();
                return lRet;
            }
        }
        return ::CallWindowProc((WNDPROC)m_SubclassWindowProc, hWnd, uMsg, wParam, lParam);
    }
    else {
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
}

LRESULT
ImeWndProcA(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CIMEWindowHandler* pimeui = GetImeWndHandler(hwnd);
    if (pimeui == NULL)
        return 0L;
    return pimeui->ImeWndProcWorker(uMsg, wParam, lParam, FALSE);
}

LRESULT
ImeWndProcW(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CIMEWindowHandler* pimeui = GetImeWndHandler(hwnd);
    if (pimeui == NULL)
        return 0L;
    return pimeui->ImeWndProcWorker(uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\immapp.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       immapp.cpp
//
//  Contents:   IActiveIMM methods with application win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "globals.h"
#include "cdimm.h"
#include "defs.h"
#include "enum.h"

extern HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

//+---------------------------------------------------------------------------
//
//
//    Input Context Group
//
//
//----------------------------------------------------------------------------

STDAPI
CActiveIMM::CreateContext(
    OUT HIMC *phIMC
    )

/*++

Method:

    IActiveIMMApp::CreateContext
    IActiveIMMIME::CreateContext

Routine Description:

    Creates a new input context, allocating memory for the context and initializing it.

Arguments:

    phIMC - [out] Address of a handle to receive the new input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::CreateContext");

    HRESULT hr;

    if (FAILED(hr = _InputContext.CreateContext(_GetIMEProperty(PROP_PRIVATE_DATA_SIZE),
                                                (_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE) ? TRUE : FALSE,
                                                phIMC, _IsAlreadyActivate())))
    {
        return hr;
    }

    if (_IsAlreadyActivate() && !_IsRealIme())
    {
        _AImeSelect(*phIMC, TRUE);
    }

    return hr;
}


STDAPI
CActiveIMM::DestroyContext(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMApp::DestroyContext
    IActiveIMMIME::DestroyContext

Routine Description:

    Releases the input context and frees any memory associated with it.

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::DestroyContext");

    if (_IsAlreadyActivate() && !_IsRealIme()) {
        _AImeSelect(hIMC, FALSE);
    }

    return _InputContext.DestroyContext(hIMC);
}

STDAPI
CActiveIMM::AssociateContext(
    IN HWND hWnd,
    IN HIMC hIMC,
    OUT HIMC *phPrev
    )

/*++

Method:

    IActiveIMMApp::AssociateContext
    IActiveIMMIME::AssociateContext

Routine Description:

    Associates the specified input context with the specified window.

Arguments:

    hWnd - [in] Handle to the window to be associated with the input context.
    hIMC - [in] Handle to the input context. If hIMC is NULL, the method removed any
                association the window may have had with input context.
    phPrev - [out] Address of the handle to the input context previously associated
                   with the window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::AssociateContext");

    hr = _InputContext.AssociateContext(hWnd, hIMC, phPrev);

    if (FAILED(hr))
        return hr;

    if (!_IsRealIme())
    {
        if (_hFocusWnd == hWnd)
        {
            _AImeAssociateFocus(hWnd, *phPrev, 0);
            _ResetMapWndFocus(hWnd);
            _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
            _SetMapWndFocus(hWnd);
        }
    }

    return IsOnImm() ? Imm32_AssociateContext(hWnd, hIMC, phPrev) : hr;
}

STDAPI
CActiveIMM::AssociateContextEx(
    IN HWND hWnd,
    IN HIMC hIMC,
    IN DWORD dwFlags
    )

/*++

Method:

    IActiveIMMApp::AssociateContextEx
    IActiveIMMIME::AssociateContextEx

Routine Description:

    Changes the association between the input method context and the specified window
    or its children.

Arguments:

    hWnd - [in] Handle to the window to be associated with the input context.
    hIMC - [in] Handle to the input context.
    dwFlags - [in] Unsigned long integer value that contains the type of association
                   between the window and the input method context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    HIMC hImcFocusOld;

    TraceMsg(TF_API, "CActiveIMM::AssociateContextEx");

    hr = _InputContext.AssociateContextEx(hWnd, hIMC, dwFlags);

    if (FAILED(hr))
        return hr;

    if (!_IsRealIme())
    {
        hr = _InputContext.GetContext(hWnd, &hImcFocusOld);
        if (FAILED(hr))
            hImcFocusOld = NULL;

        hr = _InputContext.AssociateContextEx(hWnd, hIMC, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (_hFocusWnd == hWnd)
            {
                _AImeAssociateFocus(hWnd, hImcFocusOld, 0);
                _ResetMapWndFocus(hWnd);
                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
                _SetMapWndFocus(hWnd);
            }
        }
    }

    if (FAILED(hr))
        return hr;

    return IsOnImm() ? Imm32_AssociateContextEx(hWnd, hIMC, dwFlags) : hr;
}

STDAPI
CActiveIMM::GetContext(
    HWND hWnd,
    HIMC *phIMC
    )

/*++

Method:

    IActiveIMMApp::GetContext
    IActiveIMMIME::GetContext

Routine Description:

    Retrieves the input context associated with the specified window. An application must
    release each context retrieved by calling IActiveIMMApp::ReleaseContext.

Arguments:

    hWnd - [in] Handle to the window that is retrieving an input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return GetContextInternal(hWnd, phIMC, TRUE);
}

HRESULT
CActiveIMM::GetContextInternal(
    HWND hWnd,
    HIMC *phIMC,
    BOOL fGetDefIMC
    )
{
    TraceMsg(TF_API, "CActiveIMM::GetContext");

    *phIMC = 0;

    if (!IsWindow(hWnd))
        return E_INVALIDARG;

    if (!fGetDefIMC && !IsPresent(hWnd, FALSE) && !_IsRealIme())
        return S_FALSE;

    return _InputContext.GetContext(hWnd, phIMC);
}


STDAPI
CActiveIMM::ReleaseContext(
    IN HWND hWnd,
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMApp::ReleaseContext
    IActiveIMMIME::ReleaseContext

Routine Description:

    Release the input context and unlocks the memory associated in the context.
    An application must call this method for each call to the IActiveIMMApp::GetContext
    method.

Arguments:

    hWnd - [in] Handle to the window for which the input context was previously retrieved.
    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::ReleaseContext");

    return S_OK;
}

STDAPI
CActiveIMM::GetOpenStatus(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMApp::GetOpenStatus
    IActiveIMMIME::GetOpenStatus

Routine Description:

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns a nonzero value if the IME is open, or zero otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetOpenStatus");

    if (_IsRealIme())
    {
        return Imm32_GetOpenStatus(hIMC);
    }

    return _InputContext.GetOpenStatus(hIMC);
}

STDAPI
CActiveIMM::SetOpenStatus(
    HIMC hIMC,
    BOOL fOpen
    )

/*++

Method:

    IActiveIMMApp::SetOpenStatus
    IActiveIMMIME::SetOpenStatus

Routine Description:

    Open or close the IME.

Arguments:

    hIMC - [in] Handle to the input context.
    fOpen - [in] Boolean value that contains the status. If TRUE, the IMM is opened:
                 otherwize the IMM is closed.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    BOOL fOpenChg;
    HWND hWnd;

    TraceMsg(TF_API, "CActiveIMM::SetOpenStatus");

    if (_IsRealIme())
    {
        return Imm32_SetOpenStatus(hIMC, fOpen);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetOpenStatus(lpIMC, fOpen, &fOpenChg);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the conversion mode changes.
     */
    if (SUCCEEDED(hr) && fOpenChg) {
        _SendIMENotify(hIMC, hWnd,
                       NI_CONTEXTUPDATED, (DWORD)0, IMC_SETOPENSTATUS,
                       IMN_SETOPENSTATUS, 0L);

        /*
         * notify shell and keyboard the conversion mode change
         */
        // NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    return hr;
}

STDAPI
CActiveIMM::GetConversionStatus(
    IN HIMC hIMC,
    OUT DWORD *lpfdwConversion,
    OUT DWORD *lpfdwSentence
    )

/*++

Method:

    IActiveIMMApp::GetConversionStatus
    IActiveIMMIME::GetConversionStatus

Routine Description:

    Retrieves the current conversion status.

Arguments:

    hIMC - [in] Handle to the input context for which to retrieve information.
    lpfdwConversion - [out] Address of an unsigned long integer value that receives a
                            combination of conversion mode.
    lpfwSentence - [out] Address of an unsigned long integer value that receives a sentence
                         mode value.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetConversionStatus");

    if (_IsRealIme())
    {
        return Imm32_GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
    }

    return _InputContext.GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
}

STDAPI
CActiveIMM::SetConversionStatus(
    IN HIMC hIMC,
    IN DWORD fdwConversion,
    IN DWORD fdwSentence
    )

/*++

Method:

    IActiveIMMApp::SetConversionStatus
    IActiveIMMIME::SetConversionStatus

Routine Description:

    Sets the current conversion status.

Arguments:

    hIMC - [in] Handle to the input context.
    fdwConversion - [in] Unsigned long value that contains the conversion mode values.
    fdwSentence - [in] Unsigned long integer value that contains the sentence mode values.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    BOOL fConvModeChg = FALSE;
    BOOL fSentenceChg = FALSE;
    HWND hWnd;
    DWORD fdwOldConversion;
    DWORD fdwOldSentence;
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::SetConversionStatus");

    if (_IsRealIme())
    {
        return Imm32_SetConversionStatus(hIMC, fdwConversion, fdwSentence);
    }

    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    hr = _InputContext.SetConversionStatus(lpIMC, fdwConversion, fdwSentence,
                                           &fConvModeChg, &fSentenceChg, &fdwOldConversion, &fdwOldSentence);

    hWnd = lpIMC->hWnd;

    /*
     * inform IME and Apps Wnd about the conversion mode changes.
     */
    if (fConvModeChg) {
        _SendIMENotify(hIMC, hWnd,
                       NI_CONTEXTUPDATED, fdwOldConversion, IMC_SETCONVERSIONMODE,
                       IMN_SETCONVERSIONMODE, 0L);

        /*
         * notify shell and keyboard the conversion mode change
         */
        // NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    /*
     * inform IME and Apps Wnd about the sentence mode changes.
     */
    if (fSentenceChg) {
        _SendIMENotify(hIMC, hWnd,
                       NI_CONTEXTUPDATED, fdwOldSentence, IMC_SETSENTENCEMODE,
                       IMN_SETSENTENCEMODE, 0L);
    }

    return hr;
}

STDAPI
CActiveIMM::GetStatusWindowPos(
    IN HIMC hIMC,
    OUT POINT *lpptPos
    )

/*++

Method:

    IActiveIMMApp::GetStatusWindowPos
    IActiveIMMIME::GetStatusWindowPos

Routine Description:

    Retrieves the position of the status window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpptPos - [out] Address of the POINT structure that receives the position coordinates.
                    These are screen coordinates, relative to the upper-left corner of the screen.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetStatusWindowPos");

    if (_IsRealIme())
    {
        return Imm32_GetStatusWindowPos(hIMC, lpptPos);
    }

    return _InputContext.GetStatusWindowPos(hIMC, lpptPos);
}

STDAPI
CActiveIMM::SetStatusWindowPos(
    IN HIMC hIMC,
    IN POINT *lpptPos
    )

/*++

Method:

    IActiveIMMApp::SetStatusWindowPos

Routine Description:

    Sets the position of the status window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpptPos - [in] Address of the POINT structure that receives the new position of the status
                   window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/
{
    HRESULT hr;
    HWND hWnd;

    TraceMsg(TF_API, "CActiveIMM::SetStatusWindowPos");

    if (_IsRealIme())
    {
        return Imm32_SetStatusWindowPos(hIMC, lpptPos);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetStatusWindowPos(lpIMC, lpptPos);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of  composition window position.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETSTATUSWINDOWPOS,
                   IMN_SETSTATUSWINDOWPOS, 0L);

    return hr;
}

STDAPI
CActiveIMM::GetCompositionStringA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LONG *plCopied,
    OUT LPVOID lpBuf
    )

/*++

Method:

    IActiveIMMApp::GetCompositionStringA
    IActiveIMMIME::GetCompositionStringA

Routine Description:

    Retrieves information about the composition string. ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the index of the information
                   to retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size of the buffer, in bytes.
    plCopied - [out] Address of long integer value that receives the number of bytes copied to
                     the buffer. If dwBufLen is zero, plCopied receives the number of bytes
                     needed to receive all of the requested information.
    lpBuf - [out] Address of the buffer to receive the information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionStringA");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    // Especially, GetCompositionString() calls from application when changed keyboard layout.
    // In this timing, Cicero's profile already updeted to Cicero's hKL but ImeSelectHandler(FALSE)
    // is not yet received in IMM32.
    // If IMM32 IME were ASCII style IME, then it hIMC is also ASCII and hIMC's A->W conversion
    // occurred by ImeSelectHandler().
    // For below ::GetKeyboardLayout() call, When IMM32 IME has been selected, we retreive
    // composition string from IMM32 even while changing keyboard layout.
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, FALSE);
    }

    return _GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, FALSE);
}

STDAPI
CActiveIMM::GetCompositionStringW(
    IN HIMC hIMC,
    IN  DWORD dwIndex,
    IN  DWORD dwBufLen,
    OUT LONG *plCopied,
    OUT LPVOID lpBuf
    )

/*++

Method:

    IActiveIMMApp::GetCompositionStringW
    IActiveIMMIME::GetCompositionStringW

Routine Description:

    Retrieves information about the composition string. Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the index of the information
                   to retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size of the buffer, in bytes.
    plCopied - [out] Address of long integer value that receives the number of bytes copied to
                     the buffer. If dwBufLen is zero, plCopied receives the number of bytes
                     needed to receive all of the requested information.
    lpBuf - [out] Address of the buffer to receive the information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionStringW");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, TRUE);
    }

    return _GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, TRUE);
}

STDAPI
CActiveIMM::SetCompositionStringA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen
    )

/*++

Method:

    IActiveIMMApp::SetCompositionStringA
    IActiveIMMIME::SetCompositionStringA

Routine Description:

    Sets the characters, attributes, and clauses of the composition and reading strings.
    ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the type of information
                   to set.
    lpComp - [in] Address of the buffer containing the information to set for the composition
                  string. The information is as specified by the dwIndex value.
    dwCompLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the composition string.
    lpRead - [in] Address of the buffer containing the information to set for the reading
                  string. The information is as specified by the dwIndex value.
    dwReadLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the reading string.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_FUNC, TEXT("CActiveIMM::SetCompositionStringA"));

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, FALSE);
    }

    return _SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, FALSE);
}

STDAPI
CActiveIMM::SetCompositionStringW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen
    )

/*++

Method:

    IActiveIMMApp::SetCompositionStringW
    IActiveIMMIME::SetCompositionStringW

Routine Description:

    Sets the characters, attributes, and clauses of the composition and reading strings.
    Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the type of information
                   to set.
    lpComp - [in] Address of the buffer containing the information to set for the composition
                  string. The information is as specified by the dwIndex value.
    dwCompLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the composition string.
    lpRead - [in] Address of the buffer containing the information to set for the reading
                  string. The information is as specified by the dwIndex value.
    dwReadLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the reading string.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, TRUE);
    }

    return _SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, TRUE);
}

STDAPI
CActiveIMM::GetCompositionFontA(
    IN HIMC hIMC,
    OUT LOGFONTA *lplf
    )

/*++

Method:

    IActiveIMMApp::GetCompositeFontA
    IActiveIMMIME::GetCompositeFontA

Routine Description:

    Retrieves information about the logical font currently used to display character
    in the composition window. ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [out] Address of a LOGFONTA structure that receives the fontinformation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionFontA");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
    }

    return _GetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
}

STDAPI
CActiveIMM::GetCompositionFontW(
    IN HIMC hIMC,
    IN LOGFONTW *lplf
    )

/*++

Method:

    IActiveIMMApp::GetCompositeFontW
    IActiveIMMIME::GetCompositeFontW

Routine Description:

    Retrieves information about the logical font currently used to display character
    in the composition window. Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [out] Address of a LOGFONTW structure that receives the fontinformation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionFontW");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
    }

    return _GetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
}

STDAPI
CActiveIMM::SetCompositionFontA(
    IN HIMC hIMC,
    IN LOGFONTA *lplf
    )

/*++

Method:

    IActiveIMMApp::SetCompositionFontA
    IActiveIMMIME::SetCompositionFontA

Routine Description:

    Sets the logocal font used to display characters in the composition window.
    ANSI implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [in] Address of the LOGFONTA structure containing the font information to set.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::SetCompositionFontA");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
    }

    return _SetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
}

STDAPI
CActiveIMM::SetCompositionFontW(
    IN HIMC hIMC,
    IN LOGFONTW *lplf
    )

/*++

Method:

    IActiveIMMApp::SetCompositionFontW
    IActiveIMMIME::SetCompositionFontW

Routine Description:

    Sets the logocal font used to display characters in the composition window.
    Unicode implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [in] Address of the LOGFONTW structure containing the font information to set.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::SetCompositionFontW");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
    }

    return _SetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
}

STDAPI
CActiveIMM::GetCompositionWindow(
    IN HIMC hIMC,
    OUT COMPOSITIONFORM *lpCompForm
    )

/*++

Method:

    IActiveIMMApp::GetCompositionWindow
    IActiveIMMIME::GetCompositionWindow

Routine Description:

    Retrieves information about the composition window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpCompForm - [out] Address of the COMPOSITIONFORM structure that receives information
                       about the composition.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionWindow");

    if (_IsRealIme())
    {
        return Imm32_GetCompositionWindow(hIMC, lpCompForm);
    }

    return _InputContext.GetCompositionWindow(hIMC, lpCompForm);
}

STDAPI
CActiveIMM::SetCompositionWindow(
    IN HIMC hIMC,
    IN COMPOSITIONFORM *lpCompForm
    )

/*++

Method:

    IActiveIMMApp::SetCompositionWindow

Routine Description:

    Sets the position of the composition window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpCompForm - [in] Address of the COMPOSITIONFORM structure that contains the new position
                      and other related information about the composition window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HWND hWnd;
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::SetCompositionWindow");

    if (_IsRealIme())
    {
        return Imm32_SetCompositionWindow(hIMC, lpCompForm);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetCompositionWindow(lpIMC, lpCompForm);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of composition window.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETCOMPOSITIONWINDOW,
                   IMN_SETCOMPOSITIONWINDOW, 0L);

    return hr;
}

STDAPI
CActiveIMM::GetCandidateListA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN UINT uBufLen,
    OUT CANDIDATELIST *lpCandList,
    OUT UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListA
    IActiveIMMIME::GetCandidateListA

Routine Description:

    Retrieves a specified candidate list, copying the list to the specified buffer.
    ANSI implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the zero-based index of
                   the candidate list.
    uBufLen - [in] Unsigned integer value that contains the size of the buffer, in bytes.
                   If this is zero or if the buffer is insufficient to receive the candidate
                   list, the method returns the size in bytes required to receive the complete
                   candidate list to the variable specified by puCopied.
    lpCandList - [out] Address of the CANDIDATELIST structure that receives the candidate list.
    puCopied - [out] Address of an unsigned integer valiable that receives the number of bytes
                     copied to the specified buffer if the buffer is sufficient, otherwise it
                     receives the size in bytes required to receive the complete candidate list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListA");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, FALSE);
    }

    return _InputContext.GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, FALSE);
}

STDAPI
CActiveIMM::GetCandidateListW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN UINT uBufLen,
    OUT CANDIDATELIST *lpCandList,
    OUT UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListW
    IActiveIMMIME::GetCandidateListW

Routine Description:

    Retrieves a specified candidate list, copying the list to the specified buffer.
    Unicode implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the zero-based index of
                   the candidate list.
    uBufLen - [in] Unsigned integer value that contains the size of the buffer, in bytes.
                   If this is zero or if the buffer is insufficient to receive the candidate
                   list, the method returns the size in bytes required to receive the complete
                   candidate list to the variable specified by puCopied.
    lpCandList - [out] Address of the CANDIDATELIST structure that receives the candidate list.
    puCopied - [out] Address of an unsigned integer valiable that receives the number of bytes
                     copied to the specified buffer if the buffer is sufficient, otherwise it
                     receives the size in bytes required to receive the complete candidate list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListW");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, TRUE);
    }

    return _InputContext.GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, TRUE);
}

STDAPI
CActiveIMM::GetCandidateListCountA(
    IN HIMC hIMC,
    OUT DWORD *lpdwListSize,
    OUT DWORD *pdwBufLen
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListCountA
    IActiveIMMIME::GetCandidateListCountA

Routine Description:

    Retrieves the size, in bytes, of the candidate list. ANSI inplementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lpdwListSize - [out] Address of an unsigned long integer value that receives the size of
                         the candidate list.
    pdwBufLen - [out] Address of an unsigned long integer value that contains the number of
                      bytes required to receive all candidate lists.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListCountA");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, FALSE);
    }

    return _InputContext.GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, FALSE);
}

STDAPI
CActiveIMM::GetCandidateListCountW(
    IN HIMC hIMC,
    OUT DWORD *lpdwListSize,
    OUT DWORD *pdwBufLen
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListCountW
    IActiveIMMIME::GetCandidateListCountW

Routine Description:

    Retrieves the size, in bytes, of the candidate list. Unicode inplementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lpdwListSize - [out] Address of an unsigned long integer value that receives the size of
                         the candidate list.
    pdwBufLen - [out] Address of an unsigned long integer value that contains the number of
                      bytes required to receive all candidate lists.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListCountW");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, TRUE);
    }

    return _InputContext.GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, TRUE);
}

STDAPI
CActiveIMM::GetCandidateWindow(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT CANDIDATEFORM *lpCandidate
    )

/*++

Method:

    IActiveIMMApp::GetCandidateWindow
    IActiveIMMIME::GetCandidateWindow

Routine Description:

    Retrieves information about the candidate list window.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the size, in byte, of the buffer.
    lpCandidate - [out] Address of a CANDIDATEFORM structire that receives information about
                        the candidate window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateWindow");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateWindow(hIMC, dwIndex, lpCandidate);
    }

    return _InputContext.GetCandidateWindow(hIMC, dwIndex, lpCandidate);
}

STDAPI
CActiveIMM::SetCandidateWindow(
    IN HIMC hIMC,
    IN CANDIDATEFORM *lpCandForm
    )

/*++

Method:

    IActiveIMMApp::SetCandidateWindow
    IActiveIMMIME::SetCandidateWindow

Routine Description:

    Sets information about the candidate list window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpCandForm - [in] Address of the CANDIDATEFORM structure that contains information about
                      the candidate window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HWND hWnd;
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::SetCandidateWindow");

    if (lpCandForm->dwIndex >= 4)       // over flow candidate index
        return E_INVALIDARG;

    if (_IsRealIme())
    {
        return Imm32_SetCandidateWindow(hIMC, lpCandForm);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetCandidateWindow(lpIMC, lpCandForm);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of composition window.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETCANDIDATEPOS,
                   IMN_SETCANDIDATEPOS, (LPARAM)(0x01 << lpCandForm->dwIndex));

    return hr;
}

STDAPI
CActiveIMM::GetGuideLineA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPSTR pBuf,
    OUT DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetGuideLineA
    IActiveIMMIME::GetGuideLineA

Routine Description:

    Retrieves information about errors. Applications use this information to notify users.
    ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the guideline information to
                   retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                    buffer referenced by pBuf.
    pBuf - [out] Address of a string value that receives the error message string.
    pdwResult - [out] Address of an unsigned long integer value that receives the error level,
                      error index, or size of an error message string, depending on the value
                      of dwIndex. If dwBufLen is set to zero, pdwResult receives the buffer size,
                      in bytes, needed to receive the requested information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetGuideLineA");

    if (_IsRealIme())
    {
        return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, FALSE);
    }

    return _InputContext.GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, FALSE);
}

STDAPI
CActiveIMM::GetGuideLineW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPWSTR pBuf,
    OUT DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetGuideLineW
    IActiveIMMIME::GetGuideLineW

Routine Description:

    Retrieves information about errors. Applications use this information to notify users.
    Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the guideline information to
                   retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                    buffer referenced by pBuf.
    pBuf - [out] Address of a string value that receives the error message string.
    pdwResult - [out] Address of an unsigned long integer value that receives the error level,
                      error index, or size of an error message string, depending on the value
                      of dwIndex. If dwBufLen is set to zero, pdwResult receives the buffer size,
                      in bytes, needed to receive the requested information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetGuideLineW");

    if (_IsRealIme())
    {
        return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, TRUE);
    }

    return _InputContext.GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, TRUE);
}

STDAPI
CActiveIMM::NotifyIME(
    IN HIMC hIMC,
    IN DWORD dwAction,
    IN DWORD dwIndex,
    IN DWORD dwValue
    )

/*++

Method:

    IActiveIMMApp::NotifyIME

Routine Description:

    Notifies the IME about changes to the status of the input context.

Arguments:

    hIMC - [in] Handle to the input context.
    dwAction - [in] Unsigined long integer value that contains the notification code.
    dwIndex - [in] Unsigned long integer value that contains the index of a candidate list or,
                   if dwAction is set to NI_COMPOSITIONSTR, one of the following values:
                   CPS_CANCEL:  Clear the composition string and set the status to no composition
                                string.
                   CPS_COMPLETE: Set the composition string as the result string.
                   CPS_CONVERT: Convert the composition string.
                   CPS_REVERT: Cancel the current composition string and revert to the unconverted
                               string.
    dwValue - [in] Unsigned long integer value that contains the index of a candidate string or
                   is not used, depending on the value of the dwAction parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::NotifyIME");

    return (!_IsRealIme()) ? _AImeNotifyIME(hIMC, dwAction, dwIndex, dwValue) :
                             Imm32_NotifyIME(hIMC, dwAction, dwIndex, dwValue);
}

STDAPI
CActiveIMM::GetImeMenuItemsA(
    IN HIMC hIMC,
    IN DWORD dwFlags,
    IN DWORD dwType,
    IN IMEMENUITEMINFOA *pImeParentMenu,
    OUT IMEMENUITEMINFOA *pImeMenu,
    IN DWORD dwSize,
    OUT DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetImeMenuItemsA
    IActiveIMMIME::GetImeMenuItemsA

Routine Description:

    Retrieves the menu items that are registerd in the IME menu.
    ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwFlags - [in] Unsigned long integer value that contains the menu infomation flags.
    dwType - [in] Unsigned long integer value that contains the type of menu returned by this
                  method.
    pImeParentMenu - [in] Address of an IMEMENUITEMINFOA structure that has the fType member
                          set to MFT_SUBMENU to return informaion about the submenu items
                          of this parent menu, If this parameter is NULL, the function returns
                           only top-level menu items.
    pImeMenu - [out] Address of an array of IMEMENUITEMINFOA structure to reveive the 
                     contents of the memu items.
    dwSize - [in] Unsigned long integer value that contains the size of the buffer to receive
                  the structures.
    pdwResult - [out] Address of an unsigned long integer value that receives the number of
                      menu items copied into pImeMenu. If pImeMenu is null, the function returns
                      the number of registered menu items.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetImeMenuItemsA");

    if (_IsRealIme())
    {
        return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, FALSE);
    }

    return _InputContext.GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, FALSE);
}

STDAPI
CActiveIMM::GetImeMenuItemsW(
    HIMC hIMC,
    DWORD dwFlags,
    DWORD dwType,
    IMEMENUITEMINFOW *pImeParentMenu,
    IMEMENUITEMINFOW *pImeMenu,
    DWORD dwSize,
    DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetImeMenuItemsW
    IActiveIMMIME::GetImeMenuItemsW

Routine Description:

    Retrieves the menu items that are registerd in the IME menu.
    Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwFlags - [in] Unsigned long integer value that contains the menu infomation flags.
    dwType - [in] Unsigned long integer value that contains the type of menu returned by this
                  method.
    pImeParentMenu - [in] Address of an IMEMENUITEMINFOW structure that has the fType member
                          set to MFT_SUBMENU to return informaion about the submenu items
                          of this parent menu, If this parameter is NULL, the function returns
                           only top-level menu items.
    pImeMenu - [out] Address of an array of IMEMENUITEMINFOW structure to reveive the 

                     controls of the memu items.
    dwSize - [in] Unsigned long integer value that contains the size of the buffer to receive
                  the structures.
    pdwResult - [out] Address of an unsigned long integer value that receives the number of
                      menu items copied into pImeMenu. If pImeMenu is null, the function returns
                      the number of registered menu items.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetImeMenuItemsW");

    if (_IsRealIme())
    {
        return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, TRUE);
    }

    return _InputContext.GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, TRUE);
}

STDAPI
CActiveIMM::EnumInputContext(
    DWORD idThread,
    IEnumInputContext **ppEnum
    )

/*++

Method:

    IActiveIMMApp::EnumInputContext
    IActiveIMMIME::EnumInputContext

Routine Description:

    Enumerates the input contexts on a thread.

Arguments:

    idThread - [in] Unsigned long integer value that specifies the thread.
    ppEnum - [out] Address of a pointer to the IEnumInputContext interface of the enumeration
                   object.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EnumInputContext");

    CContextList _hIMC_List;
    CEnumInputContext* pEnumInputContext = NULL;

    _InputContext.EnumInputContext(idThread, _EnumContextProc, (LPARAM)&_hIMC_List);

    if ((pEnumInputContext = new CEnumInputContext(_hIMC_List)) == NULL) {
        return E_OUTOFMEMORY;
    }

    *ppEnum = pEnumInputContext;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//
//    Window Handle Group
//
//
//----------------------------------------------------------------------------


STDAPI
CActiveIMM::GetDefaultIMEWnd(
    IN HWND hWnd,
    OUT HWND *phDefWnd
    )

/*++

Method:

    IActiveIMMApp::GetDefaultIMEWnd
    IActiveIMMIME::GetDefaultIMEWnd

Routine Description:

    Retrieves the default window handle to the IME class.

Arguments:

    hWnd     - [in] Handle to the window for the application.
    phDefWnd - [out] Address of the default window handle to the IME class.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetDefaultIMEWnd");

    if (_IsRealIme())
    {
        return Imm32_GetDefaultIMEWnd(hWnd, phDefWnd);
    }

    return _DefaultIMEWindow.GetDefaultIMEWnd(hWnd, phDefWnd);
}

STDAPI
CActiveIMM::GetVirtualKey(
    HWND hWnd,
    UINT *puVirtualKey
    )

/*++

Method:

    IActiveIMMApp::GetVirtualKey
    IActiveIMMIME::GetVirtualKey

Routine Description:

    Recovers the original virtual-key value associated with a key input message that has already
    been processed by the IME.

Arguments:

    hWnd     - [in] Handle to the window that receives the key message.
    puVirtualKey - [out] Address of an unsigned integer value that receives the original
                         virtual-key value.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetVirtualKey");

    if (_IsRealIme())
    {
        return Imm32_GetVirtualKey(hWnd, puVirtualKey);
    }

    return E_FAIL;
}

STDAPI
CActiveIMM::IsUIMessageA(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Method:

    IActiveIMMApp::IsUIMessageA
    IActiveIMMIME::IsUIMessageA

Routine Description:

    Checks for messages intended for the IME window and sends those messages to the specified
    window. ANSI implementation.

Arguments:

    hWndIME - [in] Handle to a window belonging to the IME window class.
    msg - [in] Unsigned integer value that contains the message to be checked.
    wParam - [in] Message-specific parameter.
    lParam - [in] Message-specific parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::IsUIMessageA");

    if (_IsRealIme())
    {
        return Imm32_IsUIMessageA(hWndIME, msg, wParam, lParam);
    }

    return E_FAIL;
}

STDAPI
CActiveIMM::IsUIMessageW(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Method:

    IActiveIMMApp::IsUIMessageW
    IActiveIMMIME::IsUIMessageW

Routine Description:

    Checks for messages intended for the IME window and sends those messages to the specified
    window. Unicode implementation.

Arguments:

    hWndIME - [in] Handle to a window belonging to the IME window class.
    msg - [in] Unsigned integer value that contains the message to be checked.
    wParam - [in] Message-specific parameter.
    lParam - [in] Message-specific parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::IsUIMessageW");

    if (_IsRealIme())
    {
        return Imm32_IsUIMessageW(hWndIME, msg, wParam, lParam);
    }

    return E_FAIL;
}

STDAPI
CActiveIMM::SimulateHotKey(
    HWND hWnd,
    DWORD dwHotKeyID
    )

/*++

Method:

    IActiveIMMApp::SimulateHotKey
    IActiveIMMIME::SimulateHotKey

Routine Description:

    Simulates the specified IME hot key, causing the same response as if the user had pressed the
    hot key in the specified window.

Arguments:

    hWnd - [in] Handle to the window.
    dwHotKeyID - [in] Unsigned long integer value that contains the identifier for the IME hot key.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::SimulateHotKey");

    if (_IsRealIme())
    {
        return Imm32_SimulateHotKey(hWnd, dwHotKeyID);
    }

    return E_FAIL;
}



//+---------------------------------------------------------------------------
//
//
//    Keyboard Layout Group
//
//
//----------------------------------------------------------------------------


STDAPI
CActiveIMM::EnumRegisterWordA(
    HKL hKL,
    LPSTR szReading,
    DWORD dwStyle,
    LPSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordA **pEnum
    )

/*++

Method:

    IActiveIMMApp::EnumRegisterWordA
    IActiveIMMIME::EnumRegisterWordA

Routine Description:

    Creates an enumeration object that will enumerate the register strings having the specified
    reading string, style, and register string. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    szReading - [in] Address of a string value that contains the reading string to be enumerated.
                     If NULL, this method enumerates all available reading strings that match
                     with the values specified by dwStyle and szRegister.
    dwStyle - [in] Unsigned long integer value that contains the style to be enumerated. If set
                   to zero, this method enumerates all available styles that match with the
                   values specified by szReading and szRegister.
    szRegister - [in] Address of a string value that contains the register string to enumerate.
                      If NULL, this method enumerates all register strings that match with the
                      values specified by szReading and dwStyle.
    lpData - [in] Address of a buffer containing data supplied by the application.
    pEnum - [out] Address of a pointer to the IEnumRegisterWordA interface of the enumeration
                  object.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EnumRegisterWordA");

    if (_IsRealIme())
    {
        return Imm32_EnumRegisterWordA(hKL, szReading, dwStyle, szRegister, lpData, pEnum);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::EnumRegisterWordW(
    HKL hKL,
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordW **pEnum
    )

/*++

Method:

    IActiveIMMApp::EnumRegisterWordW
    IActiveIMMIME::EnumRegisterWordW

Routine Description:

    Creates an enumeration object that will enumerate the register strings having the specified
    reading string, style, and register string. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    szReading - [in] Address of a string value that contains the reading string to be enumerated.
                     If NULL, this method enumerates all available reading strings that match
                     with the values specified by dwStyle and szRegister.
    dwStyle - [in] Unsigned long integer value that contains the style to be enumerated. If set
                   to zero, this method enumerates all available styles that match with the
                   values specified by szReading and szRegister.
    szRegister - [in] Address of a string value that contains the register string to enumerate.
                      If NULL, this method enumerates all register strings that match with the
                      values specified by szReading and dwStyle.
    lpData - [in] Address of a buffer containing data supplied by the application.
    pEnum - [out] Address of a pointer to the IEnumRegisterWordW interface of the enumeration
                  object.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EnumRegisterWordW");

    if (_IsRealIme())
    {
        return Imm32_EnumRegisterWordW(hKL, szReading, dwStyle, szRegister, lpData, pEnum);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetRegisterWordStyleA(
    HKL hKL,
    UINT nItem,
    STYLEBUFA *lpStyleBuf,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetRegisterWordStyleA
    IActiveIMMIME::GetRegisterWordStyleA

Routine Description:

    Retrieves a list of the styles supported by the IME associated with the specified keyboard
    layout. ANSI implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    nItem - [in] Unsigned integer value that contains the maximum number of styles that the buffer
                 can hold.
    lpStyleBuf - [out] Address of a STYLEBUFA structure that receives the style information.
    puCopied - [out] Address of an unsigned integer value that receives the number of layout
                     handles copied to the buffer, or if nItem is zero, receives the buffer size
                     in array elements needed to receive all available style information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetRegisterWordStyleA");

    if (_IsRealIme())
    {
        return Imm32_GetRegisterWordStyleA(hKL, nItem, lpStyleBuf, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetRegisterWordStyleW(
    HKL hKL,
    UINT nItem,
    STYLEBUFW *lpStyleBuf,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetRegisterWordStyleW
    IActiveIMMIME::GetRegisterWordStyleW

Routine Description:

    Retrieves a list of the styles supported by the IME associated with the specified keyboard
    layout. Unicode implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    nItem - [in] Unsigned integer value that contains the maximum number of styles that the buffer
                 can hold.
    lpStyleBuf - [out] Address of a STYLEBUFW structure that receives the style information.
    puCopied - [out] Address of an unsigned integer value that receives the number of layout
                     handles copied to the buffer, or if nItem is zero, receives the buffer size
                     in array elements needed to receive all available style information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetRegisterWordStyleW");

    if (_IsRealIme())
    {
        return Imm32_GetRegisterWordStyleW(hKL, nItem, lpStyleBuf, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::RegisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszRegister
    )

/*++

Method:

    IActiveIMMApp::RegisterWordA
    IActiveIMMIME::RegisterWordA

Routine Description:

    Registers a string into the dictionary of the IME associated with the specified keyboard
    layout. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to register.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszRegister - [in] Address of a string value that contains a null-terminated string specifying
                        the string to register.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::RegisterWordA");

    if (_IsRealIme())
    {
        return Imm32_RegisterWordA(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::RegisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszRegister
    )

/*++

Method:

    IActiveIMMApp::RegisterWordW
    IActiveIMMIME::RegisterWordW

Routine Description:

    Registers a string into the dictionary of the IME associated with the specified keyboard
    layout. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to register.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszRegister - [in] Address of a string value that contains a null-terminated string specifying
                        the string to register.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::RegisterWordW");

    if (_IsRealIme())
    {
        return Imm32_RegisterWordW(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::UnregisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszUnregister
    )

/*++

Method:

    IActiveIMMApp::UnregisterWordA
    IActiveIMMIME::UnregisterWordA

Routine Description:

    Removes a register string from the dictionary of the IME associated with the specified
    keyboard layout. ANSI implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to remove.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszUnregister - [in] Address of a string value that contains a null-terminated string
                          specifying the register string to remove.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::UnregisterWordA");

    if (_IsRealIme())
    {
        return Imm32_UnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::UnregisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszUnregister
    )

/*++

Method:

    IActiveIMMApp::UnregisterWordW
    IActiveIMMIME::UnregisterWordW

Routine Description:

    Removes a register string from the dictionary of the IME associated with the specified
    keyboard layout. Unicode implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to remove.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszUnregister - [in] Address of a string value that contains a null-terminated string
                          specifying the register string to remove.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::UnregisterWordW");

    if (_IsRealIme())
    {
        return Imm32_UnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return E_NOTIMPL;
}



STDAPI
CActiveIMM::ConfigureIMEA(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDA *lpdata
    )

/*++

Method:

    IActiveIMMApp::ConfigureIMEA
    IActiveIMMIME::ConfigureIMEA

Routine Description:

    Displays the configuration dialog box for the IME. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hWnd - [in] Handle to the parent window for the dialog box.
    dwMode - [in] Unsigned long integer value that contains the type of dialog box to display.
                  This can be one of the following values:
                  IME_CONFIG_GENERAL: Displays the general purpose configuration dialog box.
                  IME_CONFIG_REGISTERWORD: Displays the register word dialog box.
                  IME_CONFIG_SELECTDICTIONARY: Displays the dictionary selection dialog box.
    lpdata - [in] Address of a REGISTERWORDA structure. This structure will be used if dwMode is
                  set to IME_CONFIG_REGISTERWORD. Otherwise this parameter is ignored.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::ConfigureIMEA");

    if (_IsRealIme())
    {
        return Imm32_ConfigureIMEA(hKL, hWnd, dwMode, lpdata);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(ConfigureIMEA) failed");
            return hr;
        }

        hr = _ConfigureIMEA(hKL, hWnd, dwMode, lpdata);

        pAImeProfile->Release();
        return hr;
    }
}

STDAPI
CActiveIMM::ConfigureIMEW(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *lpdata
    )

/*++

Method:

    IActiveIMMApp::ConfigureIMEW
    IActiveIMMIME::ConfigureIMEW

Routine Description:

    Displays the configuration dialog box for the IME. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hWnd - [in] Handle to the parent window for the dialog box.
    dwMode - [in] Unsigned long integer value that contains the type of dialog box to display.
                  This can be one of the following values:
                  IME_CONFIG_GENERAL: Displays the general purpose configuration dialog box.
                  IME_CONFIG_REGISTERWORD: Displays the register word dialog box.
                  IME_CONFIG_SELECTDICTIONARY: Displays the dictionary selection dialog box.
    lpdata - [in] Address of a REGISTERWORDW structure. This structure will be used if dwMode is
                  set to IME_CONFIG_REGISTERWORD. Otherwise this parameter is ignored.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::ConfigureIMEW");

    if (_IsRealIme())
    {
        return Imm32_ConfigureIMEW(hKL, hWnd, dwMode, lpdata);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(ConfigureIMEW) failed");
            return hr;
        }

        hr = _ConfigureIMEW(hKL, hWnd, dwMode, lpdata);

        pAImeProfile->Release();
        return hr;
    }
}

STDAPI
CActiveIMM::EscapeA(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult
    )

/*++

Method:

    IActiveIMMApp::EscapeA
    IActiveIMMIME::EscapeA

Routine Description:

    Executes IME-specific subfunctions and is used mainly for country-specific function.
    ANSI implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    uEscape - [in] Unsigned integer that contains the index of the subfunction.
    lpData - [in, out] Address of a buffer containing subfunction-specific data.
    plResult - [out] Address of the LRESULT variable that received the escape-specific value
                     returned by the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EscapeA");

    if (_IsRealIme())
    {
        return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(EscapeA) failed");
            return hr;
        }

        if (SUCCEEDED(hr=pAImeProfile->ChangeCurrentKeyboardLayout(hKL)))
        {
            hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
        }

        pAImeProfile->Release();
        return hr;
    }
}

STDAPI
CActiveIMM::EscapeW(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult
    )

/*++

Method:

    IActiveIMMApp::EscapeW
    IActiveIMMIME::EscapeW

Routine Description:

    Executes IME-specific subfunctions and is used mainly for country-specific function.
    Unicode implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    uEscape - [in] Unsigned integer that contains the index of the subfunction.
    lpData - [in, out] Address of a buffer containing subfunction-specific data.
    plResult - [out] Address of the LRESULT variable that received the escape-specific value
                     returned by the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EscapeW");

    if (_IsRealIme())
    {
        return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(EscapeW) failed");
            return hr;
        }

        if (SUCCEEDED(hr=pAImeProfile->ChangeCurrentKeyboardLayout(hKL)))
        {
            hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
        }

        pAImeProfile->Release();
        return hr;
    }
}


STDAPI
CActiveIMM::GetConversionListA(
    HKL hKL,
    HIMC hIMC,
    LPSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetConversionListA
    IActiveIMMIME::GetConversionListA

Routine Description:

    Retrieves the list of characters or words from one character or word. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    lpSrc - [in] Address of a string value containing a null-terminated character string.
    uBufLen - [in] Unsigned integer value that contains the size of the destination buffer,
                   in bytes.
    uFlag - [in] Unsigned integer value that contains action flags.
    lpDst - [out] Address of the CANDIDATELIST structure that receives the conversion result.
    puCopied - [out] Address of an unsigned integer value that receives the number of bytes
                     copied to the specified buffer. If uBufLen is zero, puCopied receives the
                     number of bytes needed to receive the list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetConversionListA");

    if (_IsRealIme())
    {
        return Imm32_GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetConversionListW(
    HKL hKL,
    HIMC hIMC,
    LPWSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetConversionListW
    IActiveIMMIME::GetConversionListW

Routine Description:

    Retrieves the list of characters or words from one character or word. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    lpSrc - [in] Address of a string value containing a null-terminated character string.
    uBufLen - [in] Unsigned integer value that contains the size of the destination buffer,
                   in bytes.
    uFlag - [in] Unsigned integer value that contains action flags.
    lpDst - [out] Address of the CANDIDATELIST structure that receives the conversion result.
    puCopied - [out] Address of an unsigned integer value that receives the number of bytes
                     copied to the specified buffer. If uBufLen is zero, puCopied receives the
                     number of bytes needed to receive the list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetConversionListW");

    if (_IsRealIme())
    {
        return Imm32_GetConversionListW(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetDescriptionA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszDescription,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetDescriptionA
    IActiveIMMIME::GetDescriptionA

Routine Description:

    Copies the description of the IME to the specified buffer (ANSI implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned long integer value that contains the size of the buffer in characters.
    lpszDescription - [out] Address of a string buffer that receives the null-terminated string
                            describing the IME.
    puCopied - [out] Address of an unsigned long integer that receives the number of characters
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in characters, needed to receive the description.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetDescriptionA");

    if (_IsRealIme())
    {
        return Imm32_GetDescriptionA(hKL, uBufLen, lpszDescription, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetDescriptionW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszDescription,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetDescriptionW
    IActiveIMMIME::GetDescriptionW

Routine Description:

    Copies the description of the IME to the specified buffer (Unicode implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned long integer value that contains the size of the buffer in characters.
    lpszDescription - [out] Address of a string buffer that receives the null-terminated string
                            describing the IME.
    puCopied - [out] Address of an unsigned long integer that receives the number of characters
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in characters, needed to receive the description.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetDescriptionW");

    if (_IsRealIme())
    {
        return Imm32_GetDescriptionW(hKL, uBufLen, lpszDescription, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetIMEFileNameA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszFileName,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetIMEFileNameA
    IActiveIMMIME::GetIMEFileNameA

Routine Description:

    Retrieves the file name of the IME associated with the specified keyboard layout
    (ANSI implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned integer value that contains the size, in bytes, of the buffer.
    lpszFileName - [out] Address of a string buffer that receives the file name.
    puCopied - [out] Address of an unsigned integer that receives the number of bytes
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in bytes, required to receive the file name.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetIMEFileNameA");

    if (_IsRealIme())
    {
        return Imm32_GetIMEFileNameA(hKL, uBufLen, lpszFileName, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetIMEFileNameW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszFileName,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetIMEFileNameW
    IActiveIMMIME::GetIMEFileNameW

Routine Description:

    Retrieves the file name of the IME associated with the specified keyboard layout
    (Unicode implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned integer value that contains the size, in bytes, of the buffer.
    lpszFileName - [out] Address of a string buffer that receives the file name.
    puCopied - [out] Address of an unsigned integer that receives the number of bytes
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in bytes, required to receive the file name.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetIMEFileNameW");

    if (_IsRealIme())
    {
        return Imm32_GetIMEFileNameW(hKL, uBufLen, lpszFileName, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetProperty(
    IN HKL hKL,
    IN DWORD dwIndex,
    OUT DWORD *pdwProperty
    )

/*++

Method:

    IActiveIMMApp::GetProperty
    IActiveIMMIME::GetProperty

Routine Description:

    Retrieves the property and capabilities of the IME associated with specified
    keyboard layout.

Arguments:

    hKL - [in] Handle of the keyboard layout.
    dwIndex - [in] Unsigned long integer value that contains the type of property
                   information to retrieve.
    pdwProperty - [out] Address of an unsigned long integer value that receives the
                        property or capability value, depending on the value of the
                        dwIndex parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetProperty");


    if (_IsRealIme(hKL))
    {
        return Imm32_GetProperty(hKL, dwIndex, pdwProperty);
    }

    if (dwIndex != IGP_GETIMEVERSION &&
        ( (dwIndex & 3) || dwIndex > IGP_LAST))
    {
        // bad fdwIndex
        return E_FAIL;
    }

    if (dwIndex == IGP_GETIMEVERSION) {
        *pdwProperty = IMEVER_0400;
        return S_OK;
    }

    // Inquire IME's information and UI class name.
    if (_pActiveIME)
        _pActiveIME->Inquire(FALSE, &_IMEInfoEx.ImeInfo, _IMEInfoEx.achWndClass, &_IMEInfoEx.dwPrivate);

    *pdwProperty = *(DWORD *)((BYTE *)&_IMEInfoEx.ImeInfo + dwIndex);
    return S_OK;
}

STDAPI
CActiveIMM::InstallIMEA(
    LPSTR lpszIMEFileName,
    LPSTR lpszLayoutText,
    HKL *phKL
    )

/*++

Method:

    IActiveIMMApp::InstallIMEA
    IActiveIMMIME::InstallIMEA

Routine Description:

    Installs an IME into the system. ANSI implementaion.

Arguments:

    lpszIMEFileName - [in] Address of a null-terminated string value that specifies the full path
                           of the IME.
    lpszLayoutText - [in] Address of a null-terminated string value that specifies the name of the
                          IME. This name also specifies the layout text of the IME.
    phKL - [out] Address of the handle to the keyboard layout for the IME.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::InstallIMEA");

    if (_IsRealIme())
    {
        return Imm32_InstallIMEA(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::InstallIMEW(
    LPWSTR lpszIMEFileName,
    LPWSTR lpszLayoutText,
    HKL *phKL
    )

/*++

Method:

    IActiveIMMApp::InstallIMEW
    IActiveIMMIME::InstallIMEW

Routine Description:

    Installs an IME into the system. Unicode implementaion.

Arguments:

    lpszIMEFileName - [in] Address of a null-terminated string value that specifies the full path
                           of the IME.
    lpszLayoutText - [in] Address of a null-terminated string value that specifies the name of the
                          IME. This name also specifies the layout text of the IME.
    phKL - [out] Address of the handle to the keyboard layout for the IME.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::InstallIMEW");

    if (_IsRealIme())
    {
        return Imm32_InstallIMEW(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::IsIME(
    HKL hKL
    )

/*++

Method:

    IActiveIMMApp::IsIME
    IActiveIMMIME::IsIME

Routine Description:

    Checks whether the specified handle identifies an IME.

Arguments:

    hKL - [in] Handle to the keyboard layout to check.

Return Value:

    Returns a S_OK value if the handle identifies an IME, or S_FALSE otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::IsIME");

    if (_IsRealIme(hKL))
    {
        return Imm32_IsIME(hKL);
    }

    HRESULT hr;
    IAImeProfile* pAImeProfile;
    extern HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);

    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CreateInstance(IsIME) failed");
        return hr;
    }

    hr = pAImeProfile->IsIME(hKL);

    pAImeProfile->Release();
    return hr;
}


STDAPI
CActiveIMM::DisableIME(
    DWORD idThread
    )

/*++

Method:

    IActiveIMMApp::DisableIME
    IActiveIMMIME::DisableIME

Routine Description:

    Disables the Input Method Editor (IME) for a thread or all threads in a process.

Arguments:

    idThread - [in] Unsigned long integer value that contains the thread identifier for which
                    the IME will be disabled. If idThread is zero, the IME for the current thread
                    is disabled. If idThread is -1, the IME is disabled for all threads in the
                    current process.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::DisableIME");

    if (_IsRealIme())
    {
        return Imm32_DisableIME(idThread);
    }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\immdevaw.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    immdevaw.h

Abstract:

    This file defines the A/W structure for IMM.

Author:

Revision History:

Notes:

--*/

#ifndef _IMMDEVAW_H_
#define _IMMDEVAW_H_


/////////////////////////////////////////////////////////////////////////////
// LOGFONTA  and  LOGFONTW

typedef union {
    LOGFONTA    A;
    LOGFONTW    W;
} LOGFONTAW;


/////////////////////////////////////////////////////////////////////////////
// CHAR  and  WCHAR

typedef union {
    char       A;
    WCHAR      W;
} CHARAW;


/////////////////////////////////////////////////////////////////////////////
// IMEMENUITEMINFOA  and  IMEMENUITEMINFOW

typedef union {
    IMEMENUITEMINFOA    A;
    IMEMENUITEMINFOW    W;
} IMEMENUITEMINFOAW;

#endif // _IMMDEVAW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\immcom.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       dimmcom.cpp
//
//  Contents:   CActiveIMM COM methods without win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "defs.h"
#include "util.h"

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CActiveIMM::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IActiveIMMIME_Private))
    {
        *ppvObj = SAFECAST(this, IActiveIMMIME_Private *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CActiveIMM::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CActiveIMM::Release()
{
    LONG cr = --_cRef;

    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

HRESULT CActiveIMM::Activate(BOOL fRestoreLayout)

/*++

Method:

    IActiveIMMApp::Activate

Routine Description:

    Starts the Active IMM service and sets the status of Active IMEs for the thread.

Arguments:

    fRestoreLayout - [in] Boolean value that determines wherher Active IMEs are enabled
                          for the thread. If TRUE, the method enables Active IMEs.
                          Otherwise it disables Active IMEs.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HKL hKL;

    TraceMsg(TF_GENERAL, "Activate called for %x", GetCurrentThreadId());

    //
    // If target thread doesn't activate the IActiveIME, then calls _ActivateIME.
    // Otherwise, if already activated then add reference count and returns S_OK.
    //

    //
    // Increment activate reference count.
    //
    if (_AddActivate() > 1)
    {
        return S_OK;
    }


    // init the thread focus wnd
    _hFocusWnd = GetFocus();

    if (_CreateActiveIME()) {

        //
        // setup the hooks
        //
        if (!_InitHooks()) {
            _ReleaseActivate();
            return E_UNEXPECTED;
        }

        /*
         * If hKL were regacy IME, then we should not call WM_IME_SELCT to Default IME window.
         * The wrapapi.h should check hKL.
         * The user32!ImeSelectHandler would like create new pimeui.
         */
        _GetKeyboardLayout(&hKL);
        _ActivateLayout(hKL, NULL);

        /*
         * If hKL were Cicero IME and IsOnImm() is true,
         * then we should call WM_IME_SELECT to Default IME window.
         * SendIMEMessage() doesn't send WM_IME_SELECT message when IsOnImm() is true
         * because imm32 also send it message to Default IME window.
         * However, when start new application, imm32 doesn't send message so in this case
         * win32 layer can not create UI window.
         */
        if ( (! _IsRealIme() && IsOnImm()) || ! IsOnImm()) {
            _OnImeSelect(hKL);
        }
    }

    _OnSetFocus(_hFocusWnd, _IsRealIme());

    // if everything went ok, and this is the first call on this thread
    // need to AddRef this
    AddRef();

    return S_OK;
}


HRESULT
CActiveIMM::Deactivate(
    )

/*++

Method:

    IActiveIMMApp::Deactivate

Routine Description:

    Stops the Activate IMM service.

Arguments:

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    HKL hUnSelKL;

    TraceMsg(TF_GENERAL, "Deactivate called for %x", GetCurrentThreadId());

    if (!_IsAlreadyActivate())
        return E_UNEXPECTED;

    hr = S_OK;

    if (_ReleaseActivate() == 0)
    {
        _OnKillFocus(_hFocusWnd, _IsRealIme());

        //hr = _pCiceroIME->Deactivate(_hFocusWnd, _IsRealIme());
        hr = _GetKeyboardLayout(&hUnSelKL);
        if (FAILED(hr))
            return hr;

        //
        // unload the hooks
        //
        _UninitHooks();

        _DeactivateLayout(NULL, hUnSelKL);

        if ( (! _IsRealIme() && IsOnImm()) || ! IsOnImm()) {
            _OnImeUnselect(hUnSelKL);
        }

        _DestroyActiveIME();
        SafeReleaseClear(_AImeProfile);

        // last call on this thread, delete this
        // NB: no this pointer after the following Release!
        Release();
    }

    return hr;
}







HRESULT
CActiveIMM::FilterClientWindows(
    ATOM *aaWindowClasses,
    UINT uSize,
    BOOL *aaGuidMap
    )

/*++

Method:

    IActiveIMMAppEx::FilterClientWindows

Routine Description:

    Creates a list of registered window class that support Active IMM.

Arguments:

    aaWindowClasses - [in] Address of a list of window classes.
    uSize - [in] Unsigned integer that contains the number of window classes in the list.
    aaGuidMap - [in] Address of a list of GUID map enable/disable flag.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    if (g_ProcessIMM)
    {
        hr = g_ProcessIMM->_FilterList._Update(aaWindowClasses, uSize, aaGuidMap);
    }
    else
    {
        hr = E_FAIL;
    }

    HWND hwndFocus = GetFocus();

    if (hwndFocus)
    {
        ATOM aClass = (ATOM)GetClassLong(hwndFocus, GCW_ATOM);
        UINT u = 0;
        while (u < uSize)
        {
            if (aClass == aaWindowClasses[u])
            {
                _OnSetFocus(hwndFocus, _IsRealIme());
                break;
            }
            u++;
        }
    }

    return hr;
}








HRESULT
CActiveIMM::FilterClientWindowsEx(
    HWND hWnd,
    BOOL fGuidMap
    )

/*++

Method:

    IActiveIMMAppEx::FilterClientWindowsEx

Routine Description:

    Register window handle that support Active IMM.

Arguments:

    hWnd - [in] Handle to the window.
    fGuidMap - [in] Boolean value that contains the GUID map flag.
                    If TRUE, the hIMC's attribute field contains GUID map attribute and application should get GUID atom by IActiveIMMAppEx::GetGuidMap method.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    _mapFilterWndEx.SetAt(hWnd, fGuidMap);

    HWND hwndFocus = GetFocus();

    if (hwndFocus == hWnd)
        _OnSetFocus(hWnd, _IsRealIme());

    return S_OK;
}


HRESULT
CActiveIMM::UnfilterClientWindowsEx(
    HWND hWnd
    )

/*++

Method:

    IActiveIMMAppEx::UnfilterClientWindowsEx

Routine Description:

    Unregister window handle that support Active IMM.

Arguments:

    hWnd - [in] Handle to the window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    _mapFilterWndEx.RemoveKey(hWnd);

    HWND hwndFocus = GetFocus();

    if (hwndFocus == hWnd)
        _OnKillFocus(hWnd, _IsRealIme());

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\list.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.h

Abstract:

    This file defines the CFilterList Class.

Author:

Revision History:

Notes:

--*/


#ifndef LIST_H
#define LIST_H

#include "template.h"
#include "cstring.h"

/////////////////////////////////////////////////////////////////////////////
// CParserTypeOfHwnd

struct CParserTypeOfHwnd {
    typedef enum {
        HWND_UNKNOWN = 0,
        HWND_CURRENT,
        HWND_PARENT
    } TYPE_OF_HWND;

    CParserTypeOfHwnd ()
    {
        m_type = HWND_UNKNOWN;
    }

    BOOL Parser(CString& str)
    {
        if (str.CompareNoCase(TEXT("current")) == 0) {
            m_type = HWND_CURRENT;
            return TRUE;
        }
        else if (str.CompareNoCase(TEXT("parent")) == 0) {
            m_type = HWND_PARENT;
            return TRUE;
        }
        return FALSE;
    }

    TYPE_OF_HWND  m_type;
};

/////////////////////////////////////////////////////////////////////////////
// CParserTypeOfPresent

struct CParserTypeOfPresent {
    typedef enum {
        UNKNOWN_PRESENT = 0,
        NOT_PRESENT_LIST,
        PRESENT_LIST
    } TYPE_OF_PRESENT;

    CParserTypeOfPresent()
    {
        m_type = UNKNOWN_PRESENT;
    }

    BOOL Parser(CString& str)
    {
        if (str.CompareNoCase(TEXT("present")) == 0) {
            m_type = PRESENT_LIST;
            return TRUE;
        }
        else if (str.CompareNoCase(TEXT("notpresent")) == 0) {
            m_type = NOT_PRESENT_LIST;
            return TRUE;
        }
        return FALSE;
    }

    TYPE_OF_PRESENT m_type;
};

/////////////////////////////////////////////////////////////////////////////
// CFilterList

class CFilterList
{
public:
    CFilterList();
    ~CFilterList() { }

    HRESULT _Update(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);
    BOOL _IsPresent(HWND hWnd, CMap<HWND, HWND, ITfDocumentMgr *, ITfDocumentMgr *> &mapWndFocus, BOOL fExcludeAIMM, ITfDocumentMgr *dimAssoc);

    BOOL _IsGuidMapEnable(HWND hWnd, BOOL& fGuidMap);

    BOOL IsExceptionPresent(HWND hWnd);

private:
    typedef struct {
        BOOL fFilter : 1;
        BOOL fGuidMap : 1;
    } FILTER_CLIENT;

    CMap<ATOM,                     // class KEY
         ATOM,                     // class ARG_KEY
         FILTER_CLIENT,            // class VALUE
         FILTER_CLIENT             // class ARG_VALUE
        > m_FilterList;

    CMapStringToOb<
         CParserTypeOfHwnd,        // class VALUE
         CParserTypeOfHwnd         // class ARG_VALUE
        > m_NotPresentList;
    CMapStringToOb<
         CParserTypeOfHwnd,        // class VALUE
         CParserTypeOfHwnd         // class ARG_VALUE
        > m_PresentList;
};

#endif // LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\pimm.h ===
//+---------------------------------------------------------------------------
//
//  File:       pimm.h
//
//  Contents:   CProcessIMM
//
//----------------------------------------------------------------------------

#ifndef PIMM_H
#define PIMM_H

#include "private.h"
#include "list.h"

//+---------------------------------------------------------------------------
//
// CProcessIMM
//
//----------------------------------------------------------------------------

class CProcessIMM : public IActiveIMMAppEx,
                    public IActiveIMMMessagePumpOwner,
                    public IAImmThreadCompartment,
                    public IServiceProvider
{
public:
    CProcessIMM() {}

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IActiveIMMMessagePumpOwner
    //
    STDMETHODIMP Start();
    STDMETHODIMP End();
    STDMETHODIMP OnTranslateMessage(const MSG *pMsg);
    STDMETHODIMP Pause(DWORD *pdwCookie);
    STDMETHODIMP Resume(DWORD dwCookie);

    //
    // IActiveIMMApp/IActiveIMM methods
    //

    /*
     * AIMM Input Context (hIMC) Methods.
     */
    STDMETHODIMP CreateContext(HIMC *phIMC);
    STDMETHODIMP DestroyContext(HIMC hIME);
    STDMETHODIMP AssociateContext(HWND hWnd, HIMC hIME, HIMC *phPrev);
    STDMETHODIMP AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags);
    STDMETHODIMP GetContext(HWND hWnd, HIMC *phIMC);
    STDMETHODIMP ReleaseContext(HWND hWnd, HIMC hIMC);
    STDMETHODIMP GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC);
    STDMETHODIMP UnlockIMC(HIMC hIMC);

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    STDMETHODIMP CreateIMCC(DWORD dwSize, HIMCC *phIMCC);
    STDMETHODIMP DestroyIMCC(HIMCC hIMCC);
    STDMETHODIMP GetIMCCSize(HIMCC hIMCC, DWORD *pdwSize);
    STDMETHODIMP ReSizeIMCC(HIMCC hIMCC, DWORD dwSize, HIMCC *phIMCC);
    STDMETHODIMP GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMCC(HIMCC hIMCC, void **ppv);
    STDMETHODIMP UnlockIMCC(HIMCC hIMCC);

    /*
     * AIMM Open Status API Methods
     */
    STDMETHODIMP GetOpenStatus(HIMC hIMC);
    STDMETHODIMP SetOpenStatus(HIMC hIMC, BOOL fOpen);

    /*
     * AIMM Conversion Status API Methods
     */
    STDMETHODIMP GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion, DWORD *lpfdwSentence);
    STDMETHODIMP SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence);

    /*
     * AIMM Status Window Pos API Methods
     */
    STDMETHODIMP GetStatusWindowPos(HIMC hIMC, POINT *lpptPos);
    STDMETHODIMP SetStatusWindowPos(HIMC hIMC, POINT *lpptPos);

    /*
     * AIMM Composition String API Methods
     */
    STDMETHODIMP GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
    STDMETHODIMP SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);

    /*
     * AIMM Composition Font API Methods
     */
    STDMETHODIMP GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);
    STDMETHODIMP SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);

    /*
     * AIMM Composition Window API Methods
     */
    STDMETHODIMP GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);
    STDMETHODIMP SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);

    /*
     * AIMM Candidate List API Methods
     */
    STDMETHODIMP GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);
    STDMETHODIMP GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);

    /*
     * AIMM Candidate Window API Methods
     */
    STDMETHODIMP GetCandidateWindow(HIMC hIMC, DWORD dwBufLen, CANDIDATEFORM *lpCandidate);
    STDMETHODIMP SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate);

    /*
     * AIMM Guide Line API Methods
     */
    STDMETHODIMP GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult);
    STDMETHODIMP GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult);

    /*
     * AIMM Notify IME API Method
     */
    STDMETHODIMP NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    /*
     * AIMM Menu Items API Methods
     */
    STDMETHODIMP GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult);
    STDMETHODIMP GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult);

    /*
     * AIMM Register Word API Methods
     */
    STDMETHODIMP RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister);
    STDMETHODIMP RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister);
    STDMETHODIMP UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister);
    STDMETHODIMP UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister);
    STDMETHODIMP EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum);
    STDMETHODIMP EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum);
    STDMETHODIMP GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied);
    STDMETHODIMP GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied);

    /*
     * AIMM Configuration API Methods.
     */
    STDMETHODIMP ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
    STDMETHODIMP ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);
    STDMETHODIMP GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty);
    STDMETHODIMP IsIME(HKL hKL);

    // others
    STDMETHODIMP EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd);
    STDMETHODIMP GetVirtualKey(HWND hWnd, UINT *puVirtualKey);
    STDMETHODIMP IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);

    // ime helper methods
    STDMETHODIMP GenerateMessage(HIMC hIMC);

    // hot key manipulation api's
    STDMETHODIMP GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL);
    STDMETHODIMP SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL);
    STDMETHODIMP SimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

    // soft keyboard api's
    STDMETHODIMP CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd);
    STDMETHODIMP DestroySoftKeyboard(HWND hSoftKbdWnd);
    STDMETHODIMP ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    // win98/nt5 apis
    STDMETHODIMP DisableIME(DWORD idThread);
    STDMETHODIMP RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum);

    // methods without corresponding IMM APIs

    //
    // IActiveIMMApp methods
    //

    STDMETHODIMP Activate(BOOL fRestoreLayout);
    STDMETHODIMP Deactivate();

    STDMETHODIMP OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    //
    // FilterClientWindows
    //
    STDMETHODIMP FilterClientWindows(ATOM *aaWindowClasses, UINT uSize);

    //
    //
    //
    STDMETHODIMP GetCodePageA(HKL hKL, UINT *uCodePage);
    STDMETHODIMP GetLangId(HKL hKL, LANGID *plid);

    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IActiveIMMAppEx
    //
    STDMETHODIMP FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap);
    STDMETHODIMP FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);

    STDMETHODIMP GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom);

    STDMETHODIMP UnfilterClientWindowsEx(HWND hWnd);

    //
    // IAImmThreadCompartment,
    //
    STDMETHODIMP SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);
    STDMETHODIMP GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);


public:
    CFilterList                 _FilterList;


private:
    BOOL _IsValidKeyboardLayout(HKL hkl)
    {
        BOOL ret = FALSE;
        UINT uSize = ::GetKeyboardLayoutList(0, NULL);
        if (uSize) {
            HKL* pList = new HKL [uSize];
            if (pList) {
                uSize = ::GetKeyboardLayoutList(uSize, pList);

                for (UINT i = 0; i < uSize; i++) {
                    if (hkl == pList[i]) {
                        ret = TRUE;
                        break;
                    }
                }
                delete [] pList;
            }
        }
        return ret;
    }

private:
    static LONG _cRef;
};

#endif // PIMM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\pimm.cpp ===
//
// pimm.cpp
//

#include "private.h"
#include "defs.h"
#include "pimm.h"
#include "cdimm.h"
#include "globals.h"
#include "util.h"
#include "immxutil.h"

extern void DllAddRef(void);
extern void DllRelease(void);

HRESULT CActiveIMM_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

LONG CProcessIMM::_cRef = -1;

//+---------------------------------------------------------------------------
//
// RunningInExcludedModule
//
// Exclude some processes from using the old aimm IIDs/CLSIDs.
//----------------------------------------------------------------------------

BOOL RunningInExcludedModule()
{
static const TCHAR c_szOutlookModule[] = TEXT("outlook.exe");
static const TCHAR c_szMsoobeModule[] = TEXT("msoobe.exe");

    DWORD dwHandle;
    void *pvData;
    VS_FIXEDFILEINFO *pffi;
    UINT cb;
    TCHAR ch;
    TCHAR *pch;
    TCHAR *pchFileName;
    BOOL fRet;
    TCHAR achModule[MAX_PATH+1];

    if (GetModuleFileName(NULL, achModule, ARRAYSIZE(achModule)-1) == 0)
        return FALSE;

    // null termination.
    achModule[ARRAYSIZE(achModule) - 1] = TEXT('\0');

    pch = pchFileName = achModule;

    while ((ch = *pch) != 0)
    {
        pch = CharNext(pch);

        if (ch == '\\')
        {
            pchFileName = pch;
        }
    }

    fRet = FALSE;

    if (lstrcmpi(pchFileName, c_szOutlookModule) == 0)
    {
        static BOOL s_fCached = FALSE;
        static BOOL s_fOldVersion = TRUE;

        // don't run aimm with versions of outlook before 10.0

        if (s_fCached)
        {
            return s_fOldVersion;
        }

        cb = GetFileVersionInfoSize(achModule, &dwHandle);

        if (cb == 0)
        {
            // can't get ver info...assume the worst
            return TRUE;
        }

        if ((pvData = cicMemAlloc(cb)) == NULL)
            return TRUE; // assume the worst

        if (GetFileVersionInfo(achModule, 0, cb, pvData) &&
            VerQueryValue(pvData, TEXT("\\"), (void **)&pffi, &cb))
        {
            fRet = s_fOldVersion = (HIWORD(pffi->dwProductVersionMS) < 10);
            s_fCached = TRUE; // set this last to be thread safe
        }
        else
        {
            fRet = TRUE; // something went wrong
        }

        cicMemFree(pvData);           
    }
    else if (lstrcmpi(pchFileName, c_szMsoobeModule) == 0)
    {
        //
        // #339234.
        //
        // MSOOBE.EXE starts before the end user logon. However it opens an 
        // interactive windows station ("WinSta0") and open a default 
        // desktop ("Default"). So MSIMTF.DLL thinks it is not winlogon 
        // desktop. But the fact is that the thread is running on 
        // ".Default user". So I think we may not want to start Cicero 
        // there because it could load 3rd vender TIP. 
        //
        // #626606
        // msoobe doesn't allow any creating new process under Windows
        // Product Activation wizard. That's the security reason to prevent 
        // people from replacing msoobe.exe with explorer.exe and running the
        // machine without activating.

        fRet = TRUE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance - CLSID_CActiveIMM12
//
//----------------------------------------------------------------------------

// entry point for msimtf.dll
HRESULT CActiveIMM_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CActiveIMM *pActiveIMM;
    HRESULT hr;
    BOOL fInitedTLS = FALSE;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    //
    // Look up disabling Text Services status from the registry.
    // If it is disabled, return fail not to support Text Services.
    //
    if (IsDisabledTextServices())
        return E_FAIL;

    if (RunningInExcludedModule())
        return E_NOINTERFACE;

    if (!IsInteractiveUserLogon())
        return E_NOINTERFACE;

    if (NoTipsInstalled(NULL))
        return E_NOINTERFACE;

    // init the tls
    // nb: we also try to do this in Activate, but this is to preserve
    // existing behavior on the main thread (HACKHACK)
    if ((pActiveIMM = GetTLS()) == NULL)
    {
        if ((pActiveIMM = new CActiveIMM) == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hr=pActiveIMM->_Init()) ||
            FAILED(hr=IMTLS_SetActiveIMM(pActiveIMM) ? S_OK : E_FAIL))
        {
            delete pActiveIMM;
            return hr;
        }

        fInitedTLS = TRUE;
    }

    // we return a per-process IActiveIMM
    // why?  because trident breaks the apt threaded rules
    // and uses a single per-process obj
    if (g_ProcessIMM)
    {
        hr = g_ProcessIMM->QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = E_FAIL;
    }

    if (fInitedTLS)
    {
        //
        // Tell CActiveIMM which interface created.
        //
        if (SUCCEEDED(hr)) {
            pActiveIMM->_EnableGuidMap( IsEqualIID(riid, IID_IActiveIMMAppEx) );
        }

        // dec the ref on the tls.  Normally it will drop from 2 -> 1
        // if QueryInterface failed, it will be deleted
        pActiveIMM->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance - CLSID_CActiveIMM12_Trident
//
//----------------------------------------------------------------------------

// entry point for msimtf.dll
HRESULT CActiveIMM_CreateInstance_Trident(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    HRESULT hr = CActiveIMM_CreateInstance(pUnkOuter, riid, ppvObj);
    if (SUCCEEDED(hr))
    {
        g_fAIMM12Trident = TRUE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::QueryInterface(REFIID riid, void **ppvObj)
{
    //
    // 4955DD32-B159-11d0-8FCF-00AA006BCC59
    //
    static const IID IID_IActiveIMMAppTrident4x = {
       0x4955DD32,
       0xB159,
       0x11d0,
       { 0x8F, 0xCF, 0x00, 0xaa, 0x00, 0x6b, 0xcc, 0x59 }
    };

    // 
    // c839a84c-8036-11d3-9270-0060b067b86e
    // 
    static const IID IID_IActiveIMMAppPostNT4 = { 
        0xc839a84c,
        0x8036,
        0x11d3,
        {0x92, 0x70, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e}
      };

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IActiveIMMAppTrident4x) ||
        IsEqualIID(riid, IID_IActiveIMMAppPostNT4) ||
        IsEqualIID(riid, IID_IActiveIMMApp))
    {
        *ppvObj = SAFECAST(this, IActiveIMMApp *);
    }
    else if (IsEqualIID(riid, IID_IActiveIMMAppEx))
    {
        *ppvObj = SAFECAST(this, IActiveIMMAppEx*);
    }
    else if (IsEqualIID(riid, IID_IActiveIMMMessagePumpOwner))
    {
        *ppvObj = SAFECAST(this, IActiveIMMMessagePumpOwner *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IAImmThreadCompartment))
    {
        *ppvObj = SAFECAST(this, IAImmThreadCompartment*);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CProcessIMM::AddRef()
{
    CActiveIMM *pActiveIMM;

    // nb: our ref count is special!
    // it is initialized to -1 so we can use InterlockedIncrement
    // correctly on win95
    if (InterlockedIncrement(&_cRef) == 0)
    {
        DllAddRef();
    }

    // inc the thread ref
    if (pActiveIMM = GetTLS())
    {
        pActiveIMM->AddRef();
    }
    else
    {
        Assert(0); // how did we get this far with no tls!?
    }

    return _cRef+1; // "diagnostic" unthread-safe return
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CProcessIMM::Release()
{
    CActiveIMM *pActiveIMM;

    // dec the thread ref
    if (pActiveIMM = GetTLS())
    {
        pActiveIMM->Release();
    }
    else
    {
        Assert(0); // how did we get this far with no tls!?
    }

    // nb: our ref count is special!
    // it is initialized to -1 so we can use InterlockedIncrement
    // correctly on win95
    if (InterlockedDecrement(&_cRef) < 0)
    {
        DllRelease();
    }

    // this obj lives as long as the process does,
    // so no need for a delete
    return _cRef+1; // "diagnostic" unthread safe return
}


//+---------------------------------------------------------------------------
//
// Start
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Start()
{
    Assert(0); // who's calling this?
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// End
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::End()
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnTranslateMessage
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::OnTranslateMessage(const MSG *pMsg)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Pause
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Pause(DWORD *pdwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Resume
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Resume(DWORD dwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// CreateContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::CreateContext(HIMC *phIMC)
{
    CActiveIMM *pActiveIMM;

    if (phIMC == NULL)
        return E_INVALIDARG;

    *phIMC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->CreateContext(phIMC);
    }

    return Imm32_CreateContext(phIMC);
}

//+---------------------------------------------------------------------------
//
// DestroyContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DestroyContext(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->DestroyContext(hIMC);
    }

    return Imm32_DestroyContext(hIMC);
}

//+---------------------------------------------------------------------------
//
// AssociateContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::AssociateContext(HWND hWnd, HIMC hIME, HIMC *phPrev)
{
    CActiveIMM *pActiveIMM;

    if (phPrev == NULL)
        return E_INVALIDARG;

    *phPrev = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->AssociateContext(hWnd, hIME, phPrev);
    }

    return Imm32_AssociateContext(hWnd, hIME, phPrev);
}

//+---------------------------------------------------------------------------
//
// AssociateContextEx
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->AssociateContextEx(hWnd, hIMC, dwFlags);
    }

    return Imm32_AssociateContextEx(hWnd, hIMC, dwFlags);
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetContext(HWND hWnd, HIMC *phIMC)
{
    CActiveIMM *pActiveIMM;

    if (phIMC == NULL)
        return E_INVALIDARG;

    *phIMC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetContext(hWnd, phIMC);
    }

    return Imm32_GetContext(hWnd, phIMC);
}

//+---------------------------------------------------------------------------
//
// ReleaseContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ReleaseContext(HWND hWnd, HIMC hIMC)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetIMCLockCount
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount)
{
    CActiveIMM *pActiveIMM;

    if (pdwLockCount == NULL)
        return E_INVALIDARG;

    *pdwLockCount = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMCLockCount(hIMC, pdwLockCount);
    }

    return Imm32_GetIMCLockCount(hIMC, pdwLockCount);
}

//+---------------------------------------------------------------------------
//
// LockIMC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC)
{
    CActiveIMM *pActiveIMM;

    if (ppIMC == NULL)
        return E_INVALIDARG;

    *ppIMC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->LockIMC(hIMC, ppIMC);
    }

    return Imm32_LockIMC(hIMC, ppIMC);
}

//+---------------------------------------------------------------------------
//
// UnlockIMC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnlockIMC(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnlockIMC(hIMC);
    }

    return Imm32_UnlockIMC(hIMC);
}

//+---------------------------------------------------------------------------
//
// CreateIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::CreateIMCC(DWORD dwSize, HIMCC *phIMCC)
{
    CActiveIMM *pActiveIMM;

    if (phIMCC == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->CreateIMCC(dwSize, phIMCC);
    }

    return Imm32_CreateIMCC(dwSize, phIMCC);
}

//+---------------------------------------------------------------------------
//
// DestroyIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DestroyIMCC(HIMCC hIMCC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->DestroyIMCC(hIMCC);
    }

    return Imm32_DestroyIMCC(hIMCC);
}

//+---------------------------------------------------------------------------
//
// GetIMCCSize
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMCCSize(HIMCC hIMCC, DWORD *pdwSize)
{
    CActiveIMM *pActiveIMM;

    if (pdwSize == NULL)
        return E_INVALIDARG;

    *pdwSize = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMCCSize(hIMCC, pdwSize);
    }

    return Imm32_GetIMCCSize(hIMCC, pdwSize);
}

//+---------------------------------------------------------------------------
//
// ReSizeIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ReSizeIMCC(HIMCC hIMCC, DWORD dwSize,  HIMCC *phIMCC)
{
    CActiveIMM *pActiveIMM;

    if (phIMCC == NULL)
        return E_INVALIDARG;

    *phIMCC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->ReSizeIMCC(hIMCC, dwSize, phIMCC);
    }

    return Imm32_ReSizeIMCC(hIMCC, dwSize,  phIMCC);
}

//+---------------------------------------------------------------------------
//
// GetIMCCLockCount
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount)
{
    CActiveIMM *pActiveIMM;

    if (pdwLockCount == NULL)
        return E_INVALIDARG;

    *pdwLockCount = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMCCLockCount(hIMCC, pdwLockCount);
    }

    return Imm32_GetIMCCLockCount(hIMCC, pdwLockCount);
}

//+---------------------------------------------------------------------------
//
// LockIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::LockIMCC(HIMCC hIMCC, void **ppv)
{
    CActiveIMM *pActiveIMM;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->LockIMCC(hIMCC, ppv);
    }

    return Imm32_LockIMCC(hIMCC, ppv);
}

//+---------------------------------------------------------------------------
//
// UnlockIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnlockIMCC(HIMCC hIMCC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnlockIMCC(hIMCC);
    }

    return Imm32_UnlockIMCC(hIMCC);
}

//+---------------------------------------------------------------------------
//
// GetOpenStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetOpenStatus(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetOpenStatus(hIMC);
    }

    return Imm32_GetOpenStatus(hIMC);
}

//+---------------------------------------------------------------------------
//
// SetOpenStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetOpenStatus(HIMC hIMC, BOOL fOpen)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetOpenStatus(hIMC, fOpen);
    }

    return Imm32_SetOpenStatus(hIMC, fOpen);
}

//+---------------------------------------------------------------------------
//
// GetConversionStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion, DWORD *lpfdwSentence)
{
    CActiveIMM *pActiveIMM;

    if (lpfdwConversion != NULL)
    {
        *lpfdwConversion = 0;
    }
    if (lpfdwSentence != NULL)
    {
        *lpfdwSentence = 0;
    }
    if (lpfdwConversion == NULL || lpfdwSentence == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
    }

    return Imm32_GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
}

//+---------------------------------------------------------------------------
//
// SetConversionStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetConversionStatus(hIMC, fdwConversion, fdwSentence);
    }

    return Imm32_SetConversionStatus(hIMC, fdwConversion, fdwSentence);
}

//+---------------------------------------------------------------------------
//
// GetStatusWindowPos
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
{
    CActiveIMM *pActiveIMM;

    if (lpptPos == NULL)
        return E_INVALIDARG;

    memset(lpptPos, 0, sizeof(POINT));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetStatusWindowPos(hIMC, lpptPos);
    }

    return Imm32_GetStatusWindowPos(hIMC, lpptPos);
}

//+---------------------------------------------------------------------------
//
// SetStatusWindowPos
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
{
    CActiveIMM *pActiveIMM;

    if (lpptPos == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetStatusWindowPos(hIMC, lpptPos);
    }

    return Imm32_SetStatusWindowPos(hIMC, lpptPos);
}

//+---------------------------------------------------------------------------
//
// GetCompositionStringA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
{
    CActiveIMM *pActiveIMM;

    if (plCopied == NULL)
        return E_INVALIDARG;

    *plCopied = 0;

    if (dwBufLen > 0 && lpBuf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionStringA(hIMC, dwIndex, dwBufLen, plCopied, lpBuf);
    }

    return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionStringW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
{
    CActiveIMM *pActiveIMM;

    if (plCopied == NULL)
        return E_INVALIDARG;

    *plCopied = 0;

    if (dwBufLen > 0 && lpBuf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionStringW(hIMC, dwIndex, dwBufLen, plCopied, lpBuf);
    }

    return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, TRUE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionStringA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    CActiveIMM *pActiveIMM;

    if ((dwIndex & (SCS_SETSTR | SCS_CHANGEATTR | SCS_CHANGECLAUSE | SCS_SETRECONVERTSTRING | SCS_QUERYRECONVERTSTRING)) == 0)
        return E_INVALIDARG;

    if (lpComp == NULL && lpRead == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
    }

    return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, FALSE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionStringW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    CActiveIMM *pActiveIMM;

    if ((dwIndex & (SCS_SETSTR | SCS_CHANGEATTR | SCS_CHANGECLAUSE | SCS_SETRECONVERTSTRING | SCS_QUERYRECONVERTSTRING)) == 0)
        return E_INVALIDARG;

    if (lpComp == NULL && lpRead == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionStringW(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
    }

    return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionFontA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    memset(lplf, 0, sizeof(LOGFONTA));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionFontA(hIMC, lplf);
    }

    return Imm32_GetCompositionFont(hIMC, (LOGFONTAW *)lplf, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionFontW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    memset(lplf, 0, sizeof(LOGFONTW));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionFontW(hIMC, lplf);
    }

    return Imm32_GetCompositionFont(hIMC, (LOGFONTAW *)lplf, TRUE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionFontA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionFontA(hIMC, lplf);
    }

    return Imm32_SetCompositionFont(hIMC, (LOGFONTAW *)lplf, FALSE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionFontW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionFontW(hIMC, lplf);
    }

    return Imm32_SetCompositionFont(hIMC, (LOGFONTAW *)lplf, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
{
    CActiveIMM *pActiveIMM;

    if (lpCompForm == NULL)
        return E_INVALIDARG;

    memset(lpCompForm, 0, sizeof(COMPOSITIONFORM));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionWindow(hIMC, lpCompForm);
    }

    return Imm32_GetCompositionWindow(hIMC, lpCompForm);
}

//+---------------------------------------------------------------------------
//
// SetCompositionWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
{
    CActiveIMM *pActiveIMM;

    if (lpCompForm == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionWindow(hIMC, lpCompForm);
    }

    return Imm32_SetCompositionWindow(hIMC, lpCompForm);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }
    if (uBufLen > 0 && lpCandList != NULL)
    {
        memset(lpCandList, 0, uBufLen);
    }

    if (puCopied == NULL)
        return E_INVALIDARG;
    if (uBufLen > 0 && lpCandList == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListA(hIMC, dwIndex, uBufLen, lpCandList, puCopied);
    }

    return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }
    if (uBufLen > 0 && lpCandList != NULL)
    {
        memset(lpCandList, 0, uBufLen);
    }

    if (puCopied == NULL)
        return E_INVALIDARG;
    if (uBufLen > 0 && lpCandList == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListW(hIMC, dwIndex, uBufLen, lpCandList, puCopied);
    }

    return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListCountA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
{
    CActiveIMM *pActiveIMM;

    if (lpdwListSize != NULL)
    {
        *lpdwListSize = 0;
    }
    if (pdwBufLen != NULL)
    {
        *pdwBufLen = 0;
    }
    if (lpdwListSize == NULL || pdwBufLen == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListCountA(hIMC, lpdwListSize, pdwBufLen);
    }

    return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListCountW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
{
    CActiveIMM *pActiveIMM;

    if (lpdwListSize != NULL)
    {
        *lpdwListSize = 0;
    }
    if (pdwBufLen != NULL)
    {
        *pdwBufLen = 0;
    }
    if (lpdwListSize == NULL || pdwBufLen == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListCountW(hIMC, lpdwListSize, pdwBufLen);
    }

    return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateWindow(HIMC hIMC, DWORD dwBufLen, CANDIDATEFORM *lpCandidate)
{
    CActiveIMM *pActiveIMM;

    if (lpCandidate == NULL)
        return E_INVALIDARG;

    memset(lpCandidate, 0, dwBufLen);

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateWindow(hIMC, dwBufLen, lpCandidate);
    }

    return Imm32_GetCandidateWindow(hIMC, dwBufLen, lpCandidate);
}

//+---------------------------------------------------------------------------
//
// SetCandidateWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate)
{
    CActiveIMM *pActiveIMM;

    if (lpCandidate == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCandidateWindow(hIMC, lpCandidate);
    }

    return Imm32_SetCandidateWindow(hIMC, lpCandidate);
}

//+---------------------------------------------------------------------------
//
// GetGuideLineA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetGuideLineA(hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
    }

    return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetGuideLineW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetGuideLineW(hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
    }

    return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, TRUE);
}

//+---------------------------------------------------------------------------
//
// NotifyIME
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue);
    }

    return Imm32_NotifyIME(hIMC, dwAction, dwIndex, dwValue);
}

//+---------------------------------------------------------------------------
//
// GetImeMenuItemsA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetImeMenuItemsA(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
    }

    return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetImeMenuItemsW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetImeMenuItemsW(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
    }

    return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, TRUE);
}

//+---------------------------------------------------------------------------
//
// RegisterWordA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RegisterWordA(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return Imm32_RegisterWordA(hKL, lpszReading, dwStyle, lpszRegister);
}

//+---------------------------------------------------------------------------
//
// RegisterWordW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RegisterWordW(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return Imm32_RegisterWordW(hKL, lpszReading, dwStyle, lpszRegister);
}

//+---------------------------------------------------------------------------
//
// UnregisterWordA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return Imm32_UnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister);
}

//+---------------------------------------------------------------------------
//
// UnregisterWordW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return Imm32_UnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister);
}

//+---------------------------------------------------------------------------
//
// EnumRegisterWordA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **ppEnum)
{
    if (ppEnum != NULL)
    {
        *ppEnum = NULL;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EnumRegisterWordA(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
    }

    return Imm32_EnumRegisterWordA(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
}

//+---------------------------------------------------------------------------
//
// EnumRegisterWordW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **ppEnum)
{
    if (ppEnum != NULL)
    {
        *ppEnum = NULL;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EnumRegisterWordW(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
    }

    return Imm32_EnumRegisterWordW(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
}

//+---------------------------------------------------------------------------
//
// GetRegisterWordStyleA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied)
{
    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetRegisterWordStyleA(hKL, nItem, lpStyleBuf, puCopied);
    }

    return Imm32_GetRegisterWordStyleA(hKL, nItem, lpStyleBuf, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetRegisterWordStyleW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied)
{
    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetRegisterWordStyleW(hKL, nItem, lpStyleBuf, puCopied);
    }

    return Imm32_GetRegisterWordStyleW(hKL, nItem, lpStyleBuf, puCopied);
}

//+---------------------------------------------------------------------------
//
// ConfigureIMEA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->ConfigureIMEA(hKL, hWnd, dwMode, lpdata);
    }

    return Imm32_ConfigureIMEA(hKL, hWnd, dwMode, lpdata);
}

//+---------------------------------------------------------------------------
//
// ConfigureIMEW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->ConfigureIMEW(hKL, hWnd, dwMode, lpdata);
    }

    return Imm32_ConfigureIMEW(hKL, hWnd, dwMode, lpdata);
}

//+---------------------------------------------------------------------------
//
// GetDescriptionA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetDescriptionA(hKL, uBufLen, lpszDescription, puCopied);
    }

    return GetDescriptionA(hKL, uBufLen, lpszDescription, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetDescriptionW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetDescriptionW(hKL, uBufLen, lpszDescription, puCopied);
    }

    return Imm32_GetDescriptionW(hKL, uBufLen, lpszDescription, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetIMEFileNameA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMEFileNameA(hKL, uBufLen, lpszFileName, puCopied);
    }

    return Imm32_GetIMEFileNameA(hKL, uBufLen, lpszFileName, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetIMEFileNameW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMEFileNameW(hKL, uBufLen, lpszFileName, puCopied);
    }

    return Imm32_GetIMEFileNameW(hKL, uBufLen, lpszFileName, puCopied);
}

//+---------------------------------------------------------------------------
//
// InstallIMEA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->InstallIMEA(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return Imm32_InstallIMEA(lpszIMEFileName, lpszLayoutText, phKL);
}

//+---------------------------------------------------------------------------
//
// InstallIMEW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->InstallIMEW(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return Imm32_InstallIMEW(lpszIMEFileName, lpszLayoutText, phKL);
}

//+---------------------------------------------------------------------------
//
// GetProperty
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty)
{
    CActiveIMM *pActiveIMM;

    if (pdwProperty == NULL)
        return E_INVALIDARG;

    *pdwProperty = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetProperty(hKL, fdwIndex, pdwProperty);
    }

    return Imm32_GetProperty(hKL, fdwIndex, pdwProperty);
}

//+---------------------------------------------------------------------------
//
// IsIME
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::IsIME(HKL hKL)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->IsIME(hKL);
    }

    return Imm32_IsIME(hKL);
}

//+---------------------------------------------------------------------------
//
// EscapeA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EscapeA(hKL, hIMC, uEscape, lpData, plResult);
    }

    return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
}

//+---------------------------------------------------------------------------
//
// EscapeW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EscapeW(hKL, hIMC, uEscape, lpData, plResult);
    }

    return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetConversionListA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return Imm32_GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetConversionListW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetConversionListW(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return Imm32_GetConversionListW(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetDefaultIMEWnd
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd)
{
    CActiveIMM *pActiveIMM;

    if (phDefWnd == NULL)
        return E_INVALIDARG;

    *phDefWnd = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetDefaultIMEWnd(hWnd, phDefWnd);
    }

    return Imm32_GetDefaultIMEWnd(hWnd, phDefWnd);
}

//+---------------------------------------------------------------------------
//
// GetVirtualKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetVirtualKey(HWND hWnd, UINT *puVirtualKey)
{
    CActiveIMM *pActiveIMM;

    if (puVirtualKey == NULL)
        return E_INVALIDARG;

    *puVirtualKey = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetVirtualKey(hWnd, puVirtualKey);
    }

    return Imm32_GetVirtualKey(hWnd, puVirtualKey);
}

//+---------------------------------------------------------------------------
//
// IsUIMessageA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->IsUIMessageA(hWndIME, msg, wParam, lParam);
    }

    return Imm32_IsUIMessageA(hWndIME, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// IsUIMessageW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->IsUIMessageW(hWndIME, msg, wParam, lParam);
    }

    return Imm32_IsUIMessageW(hWndIME, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// GenerateMessage
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GenerateMessage(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GenerateMessage(hIMC);
    }

    return Imm32_GenerateMessage(hIMC);
}

//+---------------------------------------------------------------------------
//
// GetHotKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL)
{
    CActiveIMM *pActiveIMM;

    if (puModifiers != NULL)
    {
        *puModifiers = 0;
    }
    if (puVKey != NULL)
    {
        *puVKey = 0;
    }
    if (phKL != NULL)
    {
        *phKL = 0;
    }
    if (puModifiers == NULL || puVKey == NULL || phKL == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL);
    }

    return Imm32_GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL);
}

//+---------------------------------------------------------------------------
//
// SetHotKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetHotKey(dwHotKeyID, uModifiers, uVKey, hKL);
    }

    return Imm32_SetHotKey(dwHotKeyID, uModifiers, uVKey, hKL);
}

//+---------------------------------------------------------------------------
//
// SimulateHotKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SimulateHotKey(HWND hWnd, DWORD dwHotKeyID)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SimulateHotKey(hWnd, dwHotKeyID);
    }

    return Imm32_SimulateHotKey(hWnd, dwHotKeyID);
}

//+---------------------------------------------------------------------------
//
// CreateSoftKeyboard
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd)
{
    if (phSoftKbdWnd != NULL)
    {
        *phSoftKbdWnd = 0;
    }
        
    return Imm32_CreateSoftKeyboard(uType, hOwner, x, y, phSoftKbdWnd);
}

//+---------------------------------------------------------------------------
//
// DestroySoftKeyboard
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DestroySoftKeyboard(HWND hSoftKbdWnd)
{
    return Imm32_DestroySoftKeyboard(hSoftKbdWnd);
}

//+---------------------------------------------------------------------------
//
// ShowSoftKeyboard
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow)
{
    return Imm32_ShowSoftKeyboard(hSoftKbdWnd, nCmdShow);
}

//+---------------------------------------------------------------------------
//
// DisableIME
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DisableIME(DWORD idThread)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->DisableIME(idThread);
    }

    return Imm32_DisableIME(idThread);
}

//+---------------------------------------------------------------------------
//
// RequestMessageA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RequestMessageA(hIMC, wParam, lParam, plResult);
    }

    return Imm32_RequestMessageA(hIMC, wParam, lParam, plResult);
}

//+---------------------------------------------------------------------------
//
// RequestMessageW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RequestMessageW(hIMC, wParam, lParam, plResult);
    }

    return Imm32_RequestMessageW(hIMC, wParam, lParam, plResult);
}

//+---------------------------------------------------------------------------
//
// EnumInputContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum)
{
    CActiveIMM *pActiveIMM;

    if (ppEnum != NULL)
    {
        *ppEnum = NULL;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EnumInputContext(idThread, ppEnum);
    }

    Assert(0);
    return E_NOTIMPL; // consider: need code to wrap up HIMC's into enumerator
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Activate(BOOL fRestoreLayout)
{
    PENDINGFILTER        *pPending;
    PENDINGFILTERGUIDMAP *pPendingGuidMap;
    PENDINGFILTEREX      *pPendingEx;
    IMTLS *ptls;
    CActiveIMM *pActiveIMM;
    HRESULT hr;
    BOOL fInitedTLS = FALSE;

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    // init the tls
    if ((pActiveIMM = ptls->pActiveIMM) == NULL)
    {
        if ((pActiveIMM = new CActiveIMM) == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hr=pActiveIMM->_Init()) ||
            FAILED(hr=IMTLS_SetActiveIMM(pActiveIMM) ? S_OK : E_FAIL))
        {
            delete pActiveIMM;
            return hr;
        }

        fInitedTLS = TRUE;

        // handle any calls to FilterClientWindows that preceded the activate call
        // consider: is it safe to limit filter list to per-thread?  Shouldn't this be per-process
        // to make trident happy?
        while (ptls->pPendingFilterClientWindows != NULL)
        {               
            ptls->pActiveIMM->FilterClientWindows(ptls->pPendingFilterClientWindows->rgAtoms, ptls->pPendingFilterClientWindows->uSize, ptls->pPendingFilterClientWindowsGuidMap->rgGuidMap);

            pPending = ptls->pPendingFilterClientWindows->pNext;
            cicMemFree(ptls->pPendingFilterClientWindows);
            ptls->pPendingFilterClientWindows = pPending;

            pPendingGuidMap = ptls->pPendingFilterClientWindowsGuidMap->pNext;
            cicMemFree(ptls->pPendingFilterClientWindowsGuidMap);
            ptls->pPendingFilterClientWindowsGuidMap = pPendingGuidMap;
        }
        while (ptls->pPendingFilterClientWindowsEx != NULL)
        {
            ptls->pActiveIMM->FilterClientWindowsEx(ptls->pPendingFilterClientWindowsEx->hWnd,
                                                    ptls->pPendingFilterClientWindowsEx->fGuidMap);

            pPendingEx = ptls->pPendingFilterClientWindowsEx->pNext;
            cicMemFree(ptls->pPendingFilterClientWindowsEx);
            ptls->pPendingFilterClientWindowsEx = pPendingEx;
        }
    }

    hr = pActiveIMM->Activate(fRestoreLayout);

    if (fInitedTLS)
    {
        // the first Activate call on this thread will do an internal AddRef
        // on success, so we must release
        pActiveIMM->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Deactivate()
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->Deactivate();
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// OnDefWindowProc
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->OnDefWindowProc(hWnd, Msg, wParam, lParam, plResult);
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// FilterClientWindows
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::FilterClientWindows(ATOM *aaWindowClasses, UINT uSize)
{
    return FilterClientWindowsGUIDMap(aaWindowClasses, uSize, NULL);
}

STDAPI CProcessIMM::FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap)
{
    IMTLS *ptls;
    PENDINGFILTER *pPending;
    PENDINGFILTERGUIDMAP *pPendingGuidMap;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->FilterClientWindows(aaWindowClasses, uSize, aaGuidMap);
    }

    // Activate hasn't been called yet on this thread
    // need to handle the call later
    
    pPending = (PENDINGFILTER *)cicMemAlloc(sizeof(PENDINGFILTER)+uSize*sizeof(ATOM)-sizeof(ATOM));
    if (pPending == NULL)
        return E_OUTOFMEMORY;

    pPendingGuidMap = (PENDINGFILTERGUIDMAP *)cicMemAlloc(sizeof(PENDINGFILTERGUIDMAP)+uSize*sizeof(BOOL)-sizeof(BOOL));
    if (pPendingGuidMap == NULL) {
        cicMemFree(pPending);
        return E_OUTOFMEMORY;
    }

    pPending->uSize = uSize;
    memcpy(pPending->rgAtoms, aaWindowClasses, uSize*sizeof(ATOM));

    pPendingGuidMap->uSize = uSize;
    if (aaGuidMap) {
        memcpy(pPendingGuidMap->rgGuidMap, aaGuidMap, uSize*sizeof(BOOL));
    }
    else {
        memset(pPendingGuidMap->rgGuidMap, FALSE, uSize*sizeof(BOOL));
    }

    pPending->pNext = ptls->pPendingFilterClientWindows;
    ptls->pPendingFilterClientWindows = pPending;

    pPendingGuidMap->pNext = ptls->pPendingFilterClientWindowsGuidMap;
    ptls->pPendingFilterClientWindowsGuidMap = pPendingGuidMap;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap)
{
    IMTLS *ptls;
    PENDINGFILTEREX *pPending;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->FilterClientWindowsEx(hWnd, fGuidMap);
    }

    // Activate hasn't been called yet on this thread
    // need to handle the call later
    
    pPending = (PENDINGFILTEREX *)cicMemAlloc(sizeof(PENDINGFILTEREX));

    if (pPending == NULL)
        return E_OUTOFMEMORY;

    pPending->hWnd = hWnd;
    pPending->fGuidMap = fGuidMap;

    pPending->pNext = ptls->pPendingFilterClientWindowsEx;
    ptls->pPendingFilterClientWindowsEx = pPending;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGuidAtom
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom)
{
    IMTLS *ptls;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->GetGuidAtom(hImc, bAttr, pGuidAtom);
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// UnfilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnfilterClientWindowsEx(HWND hWnd)
{
    IMTLS *ptls;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->UnfilterClientWindowsEx(hWnd);
    }

    // Activate hasn't been called yet on this thread
    // need to remove a handle from the waiting list
    
    PENDINGFILTEREX *current = ptls->pPendingFilterClientWindowsEx;
    PENDINGFILTEREX *previous = NULL;

    while (current != NULL)
    {
        if (current->hWnd == hWnd)
        {
            PENDINGFILTEREX *pv;
            pv = current->pNext;
            cicMemFree(current);

            if (previous == NULL)
                ptls->pPendingFilterClientWindowsEx = pv;
            else
                previous->pNext = pv;

            current  = pv;
        }
        else
        {
            previous = current;
            current  = current->pNext;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCodePageA
//
//----------------------------------------------------------------------------

extern UINT GetCodePageFromLangId(LCID lcid);

STDAPI CProcessIMM::GetCodePageA(HKL hKL, UINT *puCodePage)

/*++

Method:

    IActiveIMMApp::GetCodePageA
    IActiveIMMIME::GetCodePageA

Routine Description:

    Retrieves the code page associated with the given keyboard layout.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    puCodePage - [out] Address of an unsigned integer that receives the code page
                       identifier associated with the keyboard.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    if (puCodePage == NULL)
        return E_INVALIDARG;

    *puCodePage = CP_ACP;

    TraceMsg(TF_API, "CProcessIMM::GetCodePageA");

    if (_IsValidKeyboardLayout(hKL)) {
        *puCodePage = ::GetCodePageFromLangId(LOWORD(hKL));
        return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetLangId
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetLangId(HKL hKL, LANGID *plid)

/*++

Method:

    IActiveIMMApp::GetLangId
    IActiveIMMIME::GetLangId

Routine Description:

    Retrieves the language identifier associated with the given keyboard layout.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    plid - [out] Address of the LANGID associated with the keyboard layout.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    if (plid == NULL)
        return E_INVALIDARG;

    *plid = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    TraceMsg(TF_API, "CProcessIMM::GetLangId");

    if (_IsValidKeyboardLayout(hKL)) {
        *plid = LOWORD(hKL);
        return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    CActiveIMM *pActiveIMM;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->QueryService(guidService, riid, ppv);
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// SetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
{
    CActiveIMM *pActiveIMM;

    if (pvar == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
        return pActiveIMM->SetThreadCompartmentValue(rguid, pvar);

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
{
    CActiveIMM *pActiveIMM;

    if (pvar == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvar);

    if (pActiveIMM = GetTLS())
        return pActiveIMM->GetThreadCompartmentValue(rguid, pvar);

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <ocidl.h>

#include <tchar.h>
#include <limits.h>

// New NT5 header
#include "immdev.h"
#define _IMM_
#define _DDKIMM_H_

#include "dimm.h"

#include "msctf.h"
#include "ctffunc.h"
#include "osver.h"
#include "ccstock.h"
#include "immxutil.h"
#include "xstring.h"
#include "regsvr.h"

#define _DDKIMM_H_
#include "aimm12.h"
#include "aimmex.h"
#include "aimmp.h"
#include "msuimw32.h"
#include "imeutil.h"

#include "immdevaw.h"
#include "helpers.h"

//
// include private header
//
#include "winuserp.h"    // define WM_IME_SYSTEM
#define  NOGDI           // no include tagINPUTCONTEXT
#pragma warning(disable:4200)
#include "immp.h"        // define IMS_ACTIVATETHREADLAYOUT
#pragma warning(default:4200)

#include "mem.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\immime.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       immime.cpp
//
//  Contents:   IActiveIMM methods with ime win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "defs.h"

STDAPI
CActiveIMM::GenerateMessage(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMIME::GenerateMessage

Routine Description:

    Sends a message on the specified input context.

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    TraceMsg(TF_IMEAPI, "CActiveIMM::GenerateMessage");

    if (_IsRealIme())
    {
        return Imm32_GenerateMessage(hIMC);
    }

    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr=lpIMC.GetResult()))
        return hr;

    Assert(IsWindow(lpIMC->hWnd));

    DIMM_IMCCLock<TRANSMSG> pdw(lpIMC->hMsgBuf);
    if (FAILED(hr=pdw.GetResult()))
        return hr;

    _AimmSendMessage(lpIMC->hWnd,
                    lpIMC->dwNumMsgBuf,
                    pdw,
                    lpIMC);

    lpIMC->dwNumMsgBuf = 0;

    return S_OK;
}

STDAPI
CActiveIMM::LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT **ppIMC
    )

/*++

Method:

    IActiveIMMIME::LockIMC

Routine Description:

    Retrieves the INPUTCONTEXT structure and increases the lock count for the input context.

Arguments:

    hIMC - [in] Handle to the input context to lock.
    pphIMCC - [out] Address of a pointer to an INPUTCONTEXT structure containing
                    the locked context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr=lpIMC.GetResult()))
        return hr;

    hr = _InputContext._LockIMC(hIMC, (INPUTCONTEXT_AIMM12 **)ppIMC);
    return hr;
}


STDAPI
CActiveIMM::UnlockIMC(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMIME::UnlockIMC

Routine Description:

    Decreases the lock count for the input context.

Arguments:

    hIMC - [in] Handle to the input context to unlock.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext._UnlockIMC(hIMC);
}


STDAPI
CActiveIMM::GetIMCLockCount(
    IN HIMC hIMC,
    OUT DWORD *pdwLockCount
    )

/*++

Method:

    IActiveIMMIME::GetIMCLockCount

Routine Description:

    Retrieves the lock count of the input context.

Arguments:

    hIMC - [in] Handle to the input context to unlock.
    pdwLockCount - [out] Address of an unsigned long integer value that receives the lock count.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.GetIMCLockCount(hIMC, pdwLockCount);
}

STDAPI
CActiveIMM::CreateIMCC(
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )

/*++

Method:

    IActiveIMMIME::CreateIMCC

Routine Description:

    Creates a new input context component.

Arguments:

    dwSize - [in] Unsigned long interger value that contains the size of the new input
                  context component.
    phIMCC - [out] Address of a handle to the new input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.CreateIMCC(dwSize, phIMCC);
}


STDAPI
CActiveIMM::DestroyIMCC(
    IN HIMCC hIMCC
    )

/*++

Method:

    IActiveIMMIME::DestroyIMCC

Routine Description:

    Destroys an input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.DestroyIMCC(hIMCC);
}


STDAPI
CActiveIMM::LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )

/*++

Method:

    IActiveIMMIME::LockIMCC

Routine Description:

    Retrieves the address of the input context component and increases its lock count.

Arguments:

    hIMCC - [in] Handle to the input context component.
    ppv - [out] Address of a pointer to the buffer that receives the input context
                component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext._LockIMCC(hIMCC, ppv);
}


STDAPI
CActiveIMM::UnlockIMCC(
    IN HIMCC hIMCC
    )

/*++

Method:

    IActiveIMMIME::UnlockIMCC

Routine Description:

    Decreases the lock count for the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext._UnlockIMCC(hIMCC);
}


STDAPI
CActiveIMM::ReSizeIMCC(
    IN HIMCC hIMCC,
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )

/*++

Method:

    IActiveIMMIME::ReSizeIMCC

Routine Description:

    Changes the size of the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.
    dwSize - [in] Unsigned long integer value that contains the new
                  size of the component.
    phIMCC - [out] Address of a handle to the new input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.ReSizeIMCC(hIMCC, dwSize, phIMCC);
}


STDAPI
CActiveIMM::GetIMCCSize(
    IN HIMCC hIMCC,
    OUT DWORD *pdwSize
    )

/*++

Method:

    IActiveIMMIME::GetIMCCSize

Routine Description:

    Retrieves the size of the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.
    pdwSize - [out] Address of an unsigned long integer value that receives the
                    size of the component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.GetIMCCSize(hIMCC, pdwSize);
}


STDAPI
CActiveIMM::GetIMCCLockCount(
    IN HIMCC hIMCC,
    OUT DWORD *pdwLockCount
    )

/*++

Method:

    IActiveIMMIME::GetIMCCLockCount

Routine Description:

    Retrieves the lock count for the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.
    pdwLockCount - [out] Address of an unsigned long integer value that receives the
                         lock count.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.GetIMCCLockCount(hIMCC, pdwLockCount);
}

STDAPI
CActiveIMM::GetHotKey(
    DWORD dwHotKeyID,
    UINT *puModifiers,
    UINT *puVKey,
    HKL *phKL
    )
{
    TraceMsg(TF_API, "CActiveIMM::GetHotKey");

    if (_IsRealIme())
    {
        return Imm32_GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::SetHotKey(
    DWORD dwHotKeyID,
    UINT uModifiers,
    UINT uVKey,
    HKL hKL
    )
{
    TraceMsg(TF_API, "CActiveIMM::SetHotKey");

    if (_IsRealIme())
    {
        return Imm32_SetHotKey(dwHotKeyID, uModifiers, uVKey, hKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::RequestMessageA(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    TraceMsg(TF_API, "CActiveIMM::RequestMessageA");

    if (_IsRealIme())
    {
        return Imm32_RequestMessageA(hIMC, wParam, lParam, plResult);
    }

    return _RequestMessage(hIMC, wParam, lParam, plResult, FALSE);
}

STDAPI
CActiveIMM::RequestMessageW(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    TraceMsg(TF_API, "CActiveIMM::RequestMessageW");

    if (_IsRealIme())
    {
        return Imm32_RequestMessageW(hIMC, wParam, lParam, plResult);
    }

    return _RequestMessage(hIMC, wParam, lParam, plResult, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\list.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.cpp

Abstract:

    This file implements the CFilterList class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "list.h"
#include "defs.h"
#include "atlbase.h"
#include "globals.h"
#include "resource.h"
#include "msctfp.h"


//+---------------------------------------------------------------------------
//
// CFilterList
//
//----------------------------------------------------------------------------

LPCTSTR REG_DIMM12_KEY = TEXT("SOFTWARE\\Microsoft\\CTF\\DIMM12");
LPCTSTR REG_FILTER_LIST_VAL = TEXT("Filter List");

CFilterList::CFilterList(
    )
{
    //
    // Setup system defines filter list from registry value
    //
    CRegKey   Dimm12Reg;
    LONG      lRet;
    lRet = Dimm12Reg.Open(HKEY_LOCAL_MACHINE, REG_DIMM12_KEY, KEY_READ);
    if (lRet == ERROR_SUCCESS) {
        TCHAR  szValue[128];
        DWORD  dwCount = sizeof(szValue);
        lRet = Dimm12Reg.QueryValue(szValue, REG_FILTER_LIST_VAL, &dwCount);
        if (lRet == ERROR_SUCCESS && dwCount > 0) {

            //
            // REG_MULTI_SZ
            //
            // Format of Filter List:
            //    <Present>=<Current>,<Class Name>
            //        where:
            //            Present : Specify "Present" or "NotPresent".
            //                      If "Present" were specified, even apps didn't set class name
            //                      with IActiveIMMApp::FilterClientWindows,
            //                      this function return TRUE that correspond class name.
            //                      If "NotPresent" were specified, even apps do set class name,
            //                      this function return FALSE that correspond class name.
            //            Current : Specify "Current" or "Parent".
            //                      If "Current" were specified, called GetClassName with current hWnd.
            //                      If "Parent" were specified, called GetClassName with GetParent.
            //            Class Name : Specify class name string.
            //

            LPTSTR psz = szValue;
            while ((dwCount = lstrlen(psz)) > 0) {
                CString WholeText(psz);
                int sep1;
                if ((sep1 = WholeText.Find(TEXT('='))) > 0) {
                    CString Present(WholeText, sep1);
                    CParserTypeOfPresent TypeOfPresent;
                    if (TypeOfPresent.Parser(Present)) {

                        int sep2;
                        if ((sep2 = WholeText.Find(TEXT(','))) > 0) {
                            CString Parent(WholeText.Mid(sep1+1, sep2-sep1-1));
                            CParserTypeOfHwnd TypeOfHwnd;
                            if (TypeOfHwnd.Parser(Parent)) {

                                CString ClassName(WholeText.Mid(sep2+1));
                                if (TypeOfPresent.m_type == CParserTypeOfPresent::NOT_PRESENT_LIST)
                                    m_NotPresentList.SetAt(ClassName, TypeOfHwnd);
                                else if (TypeOfPresent.m_type == CParserTypeOfPresent::PRESENT_LIST)
                                    m_PresentList.SetAt(ClassName, TypeOfHwnd);
                            }
                        }
                    }
                }

                psz += dwCount + 1;
            }
        }
    }

    //
    // Setup default filter list from resource data (RCDATA)
    //
    LPTSTR   lpName = (LPTSTR) ID_FILTER_LIST;

    HRSRC hRSrc = FindResourceEx(g_hInst, RT_RCDATA, lpName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    if (hRSrc == NULL)
        return;

    HGLOBAL hMem = LoadResource(g_hInst, hRSrc);
    if (hMem == NULL)
        return;

#pragma pack(push, 1)
    struct _RC_FILTER_LIST {
        WORD    NumberOfList;
        struct  _RC_ITEMS {
            WORD    Present;
            WORD    Current;
            BYTE    String[1];
        }        Item;
    };
#pragma pack(pop)

    struct _RC_FILTER_LIST* pData = (struct _RC_FILTER_LIST*)LockResource(hMem);

    WORD  NumberOfList = pData->NumberOfList;

    struct _RC_FILTER_LIST::_RC_ITEMS* pItem = &pData->Item;
    while (NumberOfList--) {
        //
        // RCDATA
        //
        // Format of Filter List:
        //    <WORD NumberOfList>
        //        where:
        //            NumberOfList : Number of list.
        //                           This is allocated one data in the fist of RCDATA.
        //
        //    <WORD Present>=<WORD Current>,<LPCSTR Class Name>
        //        where:
        //            Present : Specify "WORD:0 (Present)" or "WORD:1 (NotPresent)".
        //                      If "Present" were specified, even apps didn't set class name
        //                      with IActiveIMMApp::FilterClientWindows,
        //                      this function return TRUE that correspond class name.
        //                      If "NotPresent" were specified, even apps do set class name,
        //                      this function return FALSE that correspond class name.
        //            Current : Specify "WORD:0 (Current)" or "WORD:1 (Parent)".
        //                      If "Current" were specified, called GetClassName with current hWnd.
        //                      If "Parent" were specified, called GetClassName with GetParent.
        //            Class Name : Specify class name string with LPCSTR (ASCIIZ).
        //

        CParserTypeOfPresent TypeOfPresent;
        TypeOfPresent.m_type = pItem->Present ? CParserTypeOfPresent::NOT_PRESENT_LIST
                                              : CParserTypeOfPresent::PRESENT_LIST;

        CParserTypeOfHwnd TypeOfHwnd;
        TypeOfHwnd.m_type = pItem->Current ? CParserTypeOfHwnd::HWND_PARENT
                                           : CParserTypeOfHwnd::HWND_CURRENT;

        LPCSTR psz = (LPCSTR)pItem->String;
        CString ClassName(psz);
        if (TypeOfPresent.m_type == CParserTypeOfPresent::NOT_PRESENT_LIST)
            m_NotPresentList.SetAt(ClassName, TypeOfHwnd);
        else if (TypeOfPresent.m_type == CParserTypeOfPresent::PRESENT_LIST)
            m_PresentList.SetAt(ClassName, TypeOfHwnd);

        psz += lstrlen(psz) + 1;

        pItem = (struct _RC_FILTER_LIST::_RC_ITEMS*)(BYTE*)psz;
    }
}

HRESULT
CFilterList::_Update(
    ATOM *aaWindowClasses,
    UINT uSize,
    BOOL *aaGuidMap
    )
{
    if (aaWindowClasses == NULL && uSize > 0)
        return E_INVALIDARG;

    EnterCriticalSection(g_cs);

    while (uSize--) {
        FILTER_CLIENT filter;
        filter.fFilter = TRUE;
        filter.fGuidMap =  aaGuidMap != NULL ? *aaGuidMap++ : FALSE;
        m_FilterList.SetAt(*aaWindowClasses++, filter);
    }

    LeaveCriticalSection(g_cs);

    return S_OK;
}

BOOL
CFilterList::_IsPresent(
    HWND hWnd,
    CMap<HWND, HWND, ITfDocumentMgr *, ITfDocumentMgr *> &mapWndFocus,
    BOOL fExcludeAIMM,
    ITfDocumentMgr *dimAssoc
    )
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    //
    // If this is a native cicero aware window, we don't have to do 
    // anything.
    //
    // when hWnd is associated to NULL-hIMC, GetAssociated may return
    // empty DIM that is made by Win32 part. We want to compare it but
    // mapWndFocus does not know it so we return FALSE then. And it should be
    // ok.
    //
    if (! fExcludeAIMM && dimAssoc)
    {
        ITfDocumentMgr *dim = NULL;
        if (mapWndFocus.Lookup(hWnd, dim) && (dim == dimAssoc))
        {
            fRet = TRUE;
        }
        dimAssoc->Release();
    }
    else
    {
        fRet =  IsExceptionPresent(hWnd);
    }

    LeaveCriticalSection(g_cs);
    return fRet;
}

BOOL
CFilterList::IsExceptionPresent(
    HWND hWnd
    )
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    ATOM aClass = (ATOM)GetClassLong(hWnd, GCW_ATOM);
    FILTER_CLIENT filter = { 0 };
    BOOL ret = m_FilterList.Lookup(aClass, filter);

    TCHAR achMyClassName[MAX_PATH+1];
    TCHAR achParentClassName[MAX_PATH+1];
    int lenMyClassName = ::GetClassName(hWnd, achMyClassName, ARRAYSIZE(achMyClassName) - 1);
    int lenParentClassName = ::GetClassName(GetParent(hWnd), achParentClassName, ARRAYSIZE(achParentClassName) - 1);
    CParserTypeOfHwnd  TypeOfHwnd;

    // null termination
    achMyClassName[ARRAYSIZE(achMyClassName) - 1] = TEXT('\0');
    achParentClassName[ARRAYSIZE(achParentClassName) - 1] = TEXT('\0');

    if (! ret || (! ret && ! filter.fFilter))
        goto Exit;

    if (filter.fFilter) {
        //
        // fFilter = TRUE : Registered window class ATOM
        //
        if (ret) {
            //
            // Found ATOM in the list.
            //
            if (lenMyClassName) {
                if (m_NotPresentList.Lookup(achMyClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_CURRENT)
                    goto Exit;
            }
            if (lenParentClassName) {
                if (m_NotPresentList.Lookup(achParentClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_PARENT)
                    goto Exit;
            }
            fRet = TRUE;
        }
        else
        {
            //
            // Not found ATOM in the list.
            //
            if (lenMyClassName) {
                if (m_PresentList.Lookup(achMyClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_CURRENT)
                {
                    fRet = TRUE;
                    goto Exit;
                }
            }
            if (lenParentClassName) {
                if (m_PresentList.Lookup(achParentClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_PARENT)
                {
                    fRet = TRUE;
                    goto Exit;
                }
            }
        }
    }

Exit:
    LeaveCriticalSection(g_cs);
    return fRet;
}

BOOL
CFilterList::_IsGuidMapEnable(
    HWND hWnd,
    BOOL& fGuidMap
    )
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    ATOM aClass = (ATOM)GetClassLong(hWnd, GCW_ATOM);
    FILTER_CLIENT filter = { 0 };
    BOOL ret = m_FilterList.Lookup(aClass, filter);

    fGuidMap = filter.fGuidMap;

    LeaveCriticalSection(g_cs);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\registry.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    registry.h

Abstract:

    This file defines the Registry Class.

Author:

Revision History:

Notes:

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_


class CRegistry
{
public:
    CRegistry() {
        _hKey = NULL;
        _iEnumKeyIndex = -1;
        _dwMaxSubKeyLen = 0;
        _pMemBlock = NULL;
    }

    ~CRegistry() {
        if (_hKey != NULL) {
            RegCloseKey(_hKey);
            _hKey = NULL;
        }
        Release();
    }

    DWORD CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, LPSECURITY_ATTRIBUTES lpSecAttr = NULL, LPDWORD pDisposition = NULL);
    DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS);

    typedef enum {
        REG_QUERY_NUMBER_OF_SUBKEYS,
        REG_QUERY_MAX_SUBKEY_LEN
    } REG_QUERY;

    DWORD QueryInfoKey(REG_QUERY iType, LPBYTE lpData);

    DWORD GetFirstSubKey(LPTSTR* lppStr, LPDWORD lpdwSize);
    DWORD GetNextSubKey(LPTSTR* lppStr, LPDWORD lpdwSize);

private:
    void* Allocate(DWORD dwSize);
    void Release();

    HKEY    _hKey;           // Handle of registry key.

    int     _iEnumKeyIndex;  // Index of enumration key.
    DWORD   _dwMaxSubKeyLen; // Longest subkey name length

    LPBYTE  _pMemBlock;      // Memory block for enumration.
};

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\registry.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This file implements the Registry Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "registry.h"

DWORD
CRegistry::CreateKey(
    IN HKEY hKey,
    IN LPCTSTR lpSubKey,
    IN REGSAM access,
    IN LPSECURITY_ATTRIBUTES lpSecAttr,
    OUT LPDWORD pDisposition
    )

/*++

Routine Description:

    Create the registry key specified.

Arguments:

Return Value:

--*/

{
    if (_hKey != NULL) {
        RegCloseKey(_hKey);
        _hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(hKey,               // handle of an open key.
                                  lpSubKey,           // address of subkey name.
                                  0,                  // reserved.
                                  NULL,               // address of class string.
                                  REG_OPTION_NON_VOLATILE,  // special options flag.
                                  access,             // desired security access.
                                  lpSecAttr,          // address of key security structure.
                                  &_hKey,             // address of buffer for opened handle.
                                  &dwDisposition);    // address of disposition value buffer
    if (lResult != ERROR_SUCCESS) {
        _hKey = NULL;
    }

    if (pDisposition) {
        *pDisposition = dwDisposition;
    }

    return lResult;
}

DWORD
CRegistry::OpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpSubKey,
    IN REGSAM access
    )

/*++

Routine Description:

    Open the registry key specified.

Arguments:

Return Value:

--*/

{
    if (_hKey != NULL) {
        RegCloseKey(_hKey);
        _hKey = NULL;
    }

    LONG lResult = RegOpenKeyEx(hKey,         // handle of open key.
                                lpSubKey,     // address of name of subkey to open
                                0,            // reserved
                                access,       // security access mask
                                &_hKey);      // address of handle of open key
    if (lResult != ERROR_SUCCESS) {
        _hKey = NULL;
    }

    return lResult;
}

DWORD
CRegistry::QueryInfoKey(
    IN REG_QUERY iType,
    OUT LPBYTE lpData
    )

/*++

Routine Description:

    Retrieves information about a specified registry key.

Arguments:

Return Value:

--*/

{
    DWORD cSubKeys, cbMaxSubKeyLen;

    LONG lResult = RegQueryInfoKey(_hKey,             // handle to key to query
                                   NULL,              // address of buffer for class string
                                   NULL,              // address of size of class string buffer
                                   NULL,              // reserved
                                   &cSubKeys,         // address of buffer for number of subkeys
                                   &cbMaxSubKeyLen,   // address of buffer for longest subkey name length
                                   NULL,              // address of buffer for longest class string length
                                   NULL,              // address of buffer for number of value entries
                                   NULL,              // address of buffer for longest value name length
                                   NULL,              // address of buffer for longest value data length
                                   NULL,              // address of buffer for security descriptor length.
                                   NULL);             // address of buffer for last write time

    switch (iType) {
        case REG_QUERY_NUMBER_OF_SUBKEYS:
            *((LPDWORD)lpData) = cSubKeys;         break;
        case REG_QUERY_MAX_SUBKEY_LEN:
            *((LPDWORD)lpData) = cbMaxSubKeyLen;   break;
    }

    return lResult;
}

DWORD
CRegistry::GetFirstSubKey(
    OUT LPTSTR* lppStr,
    OUT LPDWORD lpdwSize
    )

/*++

Routine Description:

    Reads a first subkey for the key.

Arguments:

Return Value:

--*/

{
    _iEnumKeyIndex = 0;

    DWORD dwRet = QueryInfoKey(REG_QUERY_MAX_SUBKEY_LEN, (LPBYTE)&_dwMaxSubKeyLen);
    if (dwRet != ERROR_SUCCESS) {
        return dwRet;
    }

    return GetNextSubKey(lppStr, lpdwSize);
}

DWORD
CRegistry::GetNextSubKey(
    OUT LPTSTR* lppStr,
    OUT LPDWORD lpdwSize
    )

/*++

Routine Description:

    Reads the next subkey for the key.

Arguments:

Return Value:

--*/

{
    *lpdwSize = 0;

    if (Allocate(*lpdwSize = (_dwMaxSubKeyLen+sizeof(TCHAR)) * sizeof(TCHAR)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD lResult = RegEnumKeyEx(_hKey,                 // handle of key to enumrate
                                 _iEnumKeyIndex,        // index of subkey to enumerate
                                 (LPTSTR)_pMemBlock,    // address of buffer for subkey name
                                 lpdwSize,              // address for size of subkey buffer
                                 0,                     // reserved
                                 NULL,                  // address of buffer for class string
                                 NULL,                  // address for sieze of class buffer
                                 NULL);                 // address for time key last written to

    *lpdwSize += sizeof(TCHAR);    // since null terminate is not included in the size.

    if (lResult == ERROR_SUCCESS) {
        *lppStr = (LPTSTR)_pMemBlock;
        _iEnumKeyIndex++;
    }

    return lResult;
}

void*
CRegistry::Allocate(
    IN DWORD dwSize
    )
{
    ASSERT(dwSize != 0);

    if (_pMemBlock) {
        Release();
    }

    _pMemBlock = new BYTE[dwSize];

    return _pMemBlock;
}

void
CRegistry::Release(
    )
{
    if (_pMemBlock) {
        delete [] _pMemBlock;
    }

    _pMemBlock = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\uiwnd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwnd.cpp

Abstract:

    This file implements the UI Window Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "uiwnd.h"
#include "globals.h"
#include "cdimm.h"

BOOL
CUIWindow::CreateUIWindow(
    HKL hKL
    )
{
    WCHAR achIMEWndClass[16];
    UINT_PTR ulPrivate;

    // consider: BOGUS fix: we are sengin WM_IME_SELECT twice on non-fe
    // so we get here twice and create two windows, which can ultimately
    // crash the process....
    // real fix: stop aimm from sending x2 WM_IME_SELECT
    if (_hUIWnd != 0)
    {
        // Assert(0);
        return TRUE;
    }

    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    if (_this->_GetIMEWndClassName(hKL,
                                      achIMEWndClass,
                                      sizeof(achIMEWndClass)/sizeof(WCHAR),
                                      &ulPrivate) == 0) {
        ASSERT(FALSE);
        return FALSE;
    }


    char achMBCS[32];

    // consider: probably need to stipulate somewhere that ui class name must be in ascii
    // to avoid CP_ACP problems....
    AssertE(WideCharToMultiByte(CP_ACP, 0, achIMEWndClass, -1, achMBCS, sizeof(achMBCS), NULL, NULL) != 0);

    //
    // create the ime's ui window
    // we create an ANSI IME UI window because Win9x platform doesn't have Unicode function.
    //
    _hUIWnd = CreateWindowExA(0,
                              achMBCS,
                              achMBCS,
                              WS_POPUP | WS_DISABLED,
                              0, 0, 0, 0,
                              NULL, 0, g_hInst, (void *)ulPrivate);
    if (_hUIWnd == NULL) {
        GetLastError();
        ASSERT(_hUIWnd);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\util.h ===
//+---------------------------------------------------------------------------
//
//  File:       util.h
//
//  Contents:   Generic helpers.
//
//----------------------------------------------------------------------------

#ifndef UTIL_H
#define UTIL_H

#define AA_INC 0
#define AA_DEC 1
void AIMMAtom(UINT uCmd);

#endif // UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "util.h"
#include "imeapp.h"

BOOL DIMM12_DllProcessAttach()
{
    if (g_ProcessIMM == NULL)
    {
        g_ProcessIMM = new CProcessIMM;
        if (g_ProcessIMM == NULL)
        {
            return FALSE;
        }
    }

    if (IsOnNT())
    {
        HINSTANCE hUser32 = GetSystemModuleHandle(TEXT("user32.dll"));
        if (hUser32)
            g_pfnToUnicodeEx = (TOUNICODEEX)GetProcAddress(hUser32, TEXT("ToUnicodeEx"));
    }

    WM_MSIME_SERVICE          = RegisterWindowMessageA( RWM_SERVICE );
    WM_MSIME_UIREADY          = RegisterWindowMessageA( RWM_UIREADY );
    WM_MSIME_RECONVERTREQUEST = RegisterWindowMessageA( RWM_RECONVERTREQUEST );
    WM_MSIME_RECONVERT        = RegisterWindowMessageA( RWM_RECONVERT );
    WM_MSIME_DOCUMENTFEED     = RegisterWindowMessageA( RWM_DOCUMENTFEED );
    WM_MSIME_QUERYPOSITION    = RegisterWindowMessageA( RWM_QUERYPOSITION );
    WM_MSIME_MODEBIAS         = RegisterWindowMessageA( RWM_MODEBIAS );
    WM_MSIME_SHOWIMEPAD       = RegisterWindowMessageA( RWM_SHOWIMEPAD );
    WM_MSIME_MOUSE            = RegisterWindowMessageA( RWM_MOUSE );
    WM_MSIME_KEYMAP           = RegisterWindowMessageA( RWM_KEYMAP );

    if (!WM_MSIME_SERVICE          ||
        !WM_MSIME_UIREADY          ||
        !WM_MSIME_RECONVERTREQUEST ||
        !WM_MSIME_RECONVERT        ||
        !WM_MSIME_DOCUMENTFEED     ||
        !WM_MSIME_QUERYPOSITION    ||
        !WM_MSIME_MODEBIAS         ||
        !WM_MSIME_SHOWIMEPAD       ||
        !WM_MSIME_MOUSE            ||
        !WM_MSIME_KEYMAP)
        return FALSE;

    return TRUE;
}

void DIMM12_DllProcessDeatch()
{
    if (g_ProcessIMM != NULL)
    {
        delete g_ProcessIMM;
    }
}

HRESULT DIMM12_DllRegisterServer(void)
{
    TCHAR achPath[MAX_PATH+1];
    HRESULT hr = E_FAIL;

    if (GetModuleFileName(g_hInst, achPath, ARRAYSIZE(achPath)) == 0)
        goto Exit;

    if (!RegisterServer(CLSID_CActiveIMM, TEXT("Active IMM"), achPath, TEXT("Apartment"), NULL))
        goto Exit;

    if (!RegisterServer(CLSID_CActiveIMM12, TEXT("Active IMM"), achPath, TEXT("Apartment"), NULL))
        goto Exit;

    if (!RegisterServer(CLSID_CActiveIMM12_Trident, TEXT("Active IMM"), achPath, TEXT("Apartment"), NULL))
        goto Exit;

    hr = S_OK;

Exit:
    return hr;
}

HRESULT DIMM12_DllUnregisterServer(void)
{
    HRESULT hr;

    if (FAILED(hr = RegisterServer(CLSID_CActiveIMM, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

    if (FAILED(hr = RegisterServer(CLSID_CActiveIMM12, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

    if (FAILED(hr = RegisterServer(CLSID_CActiveIMM12_Trident, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\dimm\uiwnd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwnd.h

Abstract:

    This file defines the UI Window Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UIWND_H_
#define _UIWND_H_


class CUIWindow
{
public:
    CUIWindow() {
        _hUIWnd = NULL;
    }

    BOOL     CreateUIWindow(HKL hKL);

    BOOL     DestroyUIWindow() {
        BOOL fRet = DestroyWindow(_hUIWnd);
        _hUIWnd = NULL;
        return fRet;
    }

    LONG     SetUIWindowContext(HIMC hIMC) {
        return (LONG)SetWindowLongPtr(_hUIWnd, IMMGWLP_IMC, (LONG_PTR)hIMC);
    }

    LRESULT  SendUIMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE) {
        LRESULT lRet;
        if (fUnicode && IsOnNT())      // Because Win9x platform doesn't have SendMessageW
            lRet = SendMessageW(_hUIWnd, Msg, wParam, lParam);
        else
            lRet = SendMessageA(_hUIWnd, Msg, wParam, lParam);
        return lRet;
    }

private:
    HWND         _hUIWnd;          // Handle of UI window.
};

#endif // _UIWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\ctxtcomp.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ctxtcomp.h

Abstract:

    This file defines the Context of Composition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CTXTCOMP_H_
#define _CTXTCOMP_H_

#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// GetCompInfo

template<class T>
HRESULT
GetCompInfo(
    IN T size,
    IN DWORD len,
    IN LONG*& lpCopied
    )
{
    *lpCopied = (LONG)(len * size);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CompData

template<class TYPE, class ARG_TYPE>
class CompData
{
public:
    CompData(HIMC hIMC = NULL, ARG_TYPE* lpsz = NULL, DWORD dwLen = 0)
    {
        IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return;

        if (lpsz)
            WriteCompData(lpsz, dwLen);
    }

    CompData(IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr)
    {
    }

    CompData(IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr, DWORD dwIndex);

    DWORD WriteCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();

        DWORD index = dwLen;
        while (index--) {
            *psz++ = data;
        }

        return dwLen;
    }

    DWORD WriteCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();

        memcpy(psz, lpSrc, dwLen * sizeof(TYPE));
        return dwLen;
    }

    DWORD AddCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData();
        memcpy(psTemp+dwl, lpSrc, dwLen*sizeof(TYPE));

        return dwLen;
    }

    DWORD AddCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData()+dwl;

        DWORD index = dwLen;
        while (index--) {
            *psTemp++ = data;
        }

        return dwLen;
    }

    const INT_PTR ReadCompData(IN ARG_TYPE* lpDest = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_array.GetSize();
        }
        else {
            ARG_TYPE* psz = m_array.GetData();
            if ((INT_PTR)dwLen > m_array.GetSize()) {
                dwBufLen = m_array.GetSize();
            }
            else {
                dwBufLen = (INT_PTR)dwLen;
            }
            memcpy(lpDest, psz, dwBufLen * sizeof(TYPE));
        }
        return dwBufLen;
    }

    DWORD GetCompStrIndex(IN DWORD dwIndex) {
        switch(dwIndex) {
            case GCS_COMPATTR:         return GCS_COMPSTR;
            case GCS_COMPREADATTR:     return GCS_COMPREADSTR;
            case GCS_COMPCLAUSE:       return GCS_COMPSTR;
            case GCS_COMPREADCLAUSE:   return GCS_COMPREADSTR;
            case GCS_RESULTCLAUSE:     return GCS_RESULTSTR;
            case GCS_RESULTREADCLAUSE: return GCS_RESULTREADSTR;
            case GCS_CURSORPOS:        return GCS_COMPSTR;
            case GCS_DELTASTART:       return GCS_COMPSTR;
            default:                   break;
        }
        ASSERT(FALSE);
        return 0;
    }

    TYPE GetAt(INT_PTR nIndex) const
    {
        return m_array.GetAt(nIndex);
    }

    void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
    {
        m_array.SetAtGrow(nIndex, newElement);
    }

    INT_PTR Add(ARG_TYPE newElement)
    {
        return m_array.Add(newElement);
    }

    INT_PTR GetSize() const
    {
        return m_array.GetSize();
    }

    void RemoveAll()
    {
        m_array.RemoveAll();
    }

    operator void* ()
    {
        return m_array.GetData();
    }

    TYPE operator[](INT_PTR nIndex)
    {
        return m_array.GetAt(nIndex);
    }

protected:
    CArray<TYPE, ARG_TYPE>    m_array;
};

template<class TYPE, class ARG_TYPE>
CompData<TYPE, ARG_TYPE>::CompData(
    IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
    DWORD dwIndex
    )
{
    switch (dwIndex) {
        case GCS_COMPSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompStrOffset),
                                                            lpCompStr->CompStr.dwCompStrLen);        // # of chars
            break;
        case GCS_COMPREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadStrOffset),
                                                            lpCompStr->CompStr.dwCompReadStrLen);    // # of chars
            break;
        case GCS_RESULTSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultStrOffset),
                                                            lpCompStr->CompStr.dwResultStrLen);      // # of chars
            break;
        case GCS_RESULTREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadStrOffset),
                                                            lpCompStr->CompStr.dwResultReadStrLen);  // # of chars
            break;

        case GCS_COMPATTR:        // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompAttrOffset),
                                                            lpCompStr->CompStr.dwCompAttrLen);
            break;
        case GCS_COMPREADATTR:    // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadAttrOffset),
                                                            lpCompStr->CompStr.dwCompReadAttrLen);
            break;

        case GCS_COMPREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadClauseOffset),
                                                            lpCompStr->CompStr.dwCompReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultClauseOffset),
                                                            lpCompStr->CompStr.dwResultClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadClauseOffset),
                                                            lpCompStr->CompStr.dwResultReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_COMPCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompClauseOffset),
                                                            lpCompStr->CompStr.dwCompClauseLen / sizeof(TYPE));    // # of bytes
            break;

        case GCS_CURSORPOS:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwCursorPos);
            break;
        case GCS_DELTASTART:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwDeltaStart);
            break;

        default:
            break;
    }
}


class CWCompString;


/////////////////////////////////////////////////////////////////////////////
// CBCompString

class CBCompString : public CompData<CHAR, CHAR>
{
public:
    CBCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<CHAR, CHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<CHAR, CHAR>(lpCompStr),
                                                         m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<CHAR, CHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CBCompString& operator=(CWCompString& wcompstr);

    const DWORD ConvertUnicodeString(IN OUT LPWSTR lpsz = NULL, DWORD cch = 0)
    {
        return _mbstowcs(lpsz, cch);
    }

    CHAR GetAt(IN DWORD dwIndex)
    {
        return CompData<CHAR, CHAR>::GetAt(dwIndex);
    }

    BOOL IsDBCSLeadByteEx(IN DWORD dwIndex)
    {
         CHAR c = GetAt(dwIndex);
         return ::IsDBCSLeadByteEx(m_cp, c);
    }

private:
    UINT      m_cp;            // code page value.

    int _mbstowcs(wchar_t* wcstr, size_t cch);
};

inline
int
CBCompString::_mbstowcs(
    wchar_t* wcstr,
    size_t cch
    )
{
    if (cch == 0 && wcstr != NULL)
        return 0;

    const char* mbstr = m_array.GetData();
    INT_PTR nSize = m_array.GetSize();

    int result = ::MultiByteToWideChar(m_cp,     // code page
                                       0,        // character-type option
                                       mbstr,    // address of string to map
                                       (int)nSize,    // number of bytes in string
                                       wcstr,    // address of wide-char buffer
                                       (int)cch);   // size of buffer, in wide character.

    return result;
}



/////////////////////////////////////////////////////////////////////////////
// CWCompString

class CWCompString : public CompData<WCHAR, WCHAR>
{
public:
    CWCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPWSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<WCHAR, WCHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<WCHAR, WCHAR>(lpCompStr),
                                                         m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<WCHAR, WCHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CWCompString& operator=(CBCompString& bcompstr);

    const DWORD ConvertANSIString(IN OUT LPSTR lpsz = NULL, DWORD dwLen = 0)
    {
        return _wcstombs(lpsz, dwLen);
    }

    WCHAR GetAt(IN DWORD dwIndex)
    {
        return (WCHAR)CompData<WCHAR, WCHAR>::GetAt(dwIndex);
    }

    int UnicodeToMultiByteSize(IN DWORD dwIndex)
    {
        WCHAR wc = GetAt(dwIndex);
        return ::WideCharToMultiByte(m_cp,     // code page
                                     0,        // performance and mapping flags
                                     (const wchar_t*)&wc,     // address of wide-char string
                                     1,        // number of char string
                                     NULL,     // address of buffer for new string
                                     0,        // size of buffer
                                     NULL,     // default for unmappable char
                                     NULL);    // flag set when default char
    }

private:
    UINT      m_cp;            // code page value.

    int _wcstombs(char* mbstr, size_t count);
};

inline
int
CWCompString::_wcstombs(
    char* mbstr,
    size_t count
    )
{
    if (count == 0 && mbstr != NULL)
        return 0;

    const wchar_t* wcstr = m_array.GetData();
    INT_PTR nSize = m_array.GetSize();

    int result = ::WideCharToMultiByte(m_cp,     // code page
                                       0,        // performance and mapping flags
                                       wcstr,    // address of wide-char string
                                       (int)nSize,    // number of char string
                                       mbstr,    // address of buffer for new string
                                       (int)count,    // size of buffer
                                       NULL,     // default for unmappable char
                                       NULL);    // flag set when default char

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// CBCompStrin/CWCompString::operator=

inline
const CBCompString&
CBCompString::operator=(
    CWCompString& wcompstr
    )

/*+++
 *
 * Get ANSI string from Unicode composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = wcompstr.ConvertANSIString();
    m_array.SetSize(len);

    LPSTR psz = m_array.GetData();
    len = wcompstr.ConvertANSIString(psz, len * sizeof(CHAR));

    return *this;
}

inline
const CWCompString&
CWCompString::operator=(
    CBCompString& bcompstr
    )

/*+++
 *
 * Get Unicode string from ANSI composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = bcompstr.ConvertUnicodeString();
    m_array.SetSize(len);

    LPWSTR psz = m_array.GetData();
    len = bcompstr.ConvertUnicodeString(psz, len);

    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckAttribute template

template<class APPS_ATTR, class HIMC_ATTR, class HIMC_CLAUSE>
HRESULT
CheckAttribute(
    APPS_ATTR& apps_attr,                        // the attr from apps
    HIMC_ATTR& himc_attr,                        // the attr from IMC
    HIMC_CLAUSE& himc_clause                     // the clause from IMC
    )
{
    if (himc_clause.ReadCompData() == 0) {
        TraceMsg(TF_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
    }
    else {
        if (himc_attr.ReadCompData() != 0) {
            if (apps_attr.GetSize() != himc_attr.GetSize()) {
                TraceMsg(TF_ERROR, "CheckAttribute: wrong length.");
                return E_FAIL;
            }

            /*
             * The attr. of chars of one clause have to be same.
             */
            DWORD dwAttrIndex = 0;
            DWORD dwClauseIndex;
            for (dwClauseIndex = 0;
                 (INT_PTR)himc_clause.GetAt(dwClauseIndex) < apps_attr.ReadCompData();
                 dwClauseIndex++
                ) {
                DWORD dwBound = himc_clause.GetAt(dwClauseIndex+1) - himc_clause.GetAt(dwClauseIndex);
                DWORD battr = apps_attr.GetAt(dwAttrIndex++);
                DWORD dwCnt;
                for (dwCnt = 1; dwCnt < dwBound; dwCnt++) {
                    if (battr != apps_attr.GetAt(dwAttrIndex++)) {
                        TraceMsg(TF_ERROR, "CheckAttribute: mismatch clause attribute.");
                        return E_FAIL;
                    }
                }
            }
        }
    }

    return S_OK;
}

class CWCompAttribute;

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute

class CBCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CBCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CBCompAttribute& operator=(CWCompAttribute& wcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompAttribute

class CWCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CWCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CWCompAttribute& operator=(CBCompAttribute& bcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CWCompString    m_wcompstr;
};

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute/CWCompAttribute::operator=

inline
const CBCompAttribute&
CBCompAttribute::operator=(
    CWCompAttribute& wcompattr
    )

/*+++
 *
 * Get ANSI attribute from Unicode composition attribute.
 *
---*/

{
    m_bcompstr = wcompattr.m_wcompstr;
    INT_PTR dwAttrIndexW = 0;
    INT_PTR dwStrIndex = 0;
    while ( dwStrIndex   < m_bcompstr.ReadCompData() &&
            dwAttrIndexW <  wcompattr.ReadCompData() &&
            m_bcompstr.GetAt((DWORD)dwStrIndex) != '\0' 
          ) {
        if (m_bcompstr.IsDBCSLeadByteEx((DWORD)dwStrIndex)) {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex += 2;
        }
        else {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex++;
        }
        dwAttrIndexW++;
    }
    return *this;
}

inline
const CWCompAttribute&
CWCompAttribute::operator=(
    CBCompAttribute& bcompattr
    )

/*+++
 *
 * Get Unicode attribute from ANSI composition attribute.
 *
---*/

{
    m_wcompstr = bcompattr.m_bcompstr;
    INT_PTR dwAttrIndexA = 0;
    INT_PTR dwStrIndex = 0;

    while ( dwStrIndex   < m_wcompstr.ReadCompData() &&
            dwAttrIndexA <  bcompattr.ReadCompData() &&
            m_wcompstr.GetAt((DWORD)dwStrIndex) != L'\0' 
          ) {
        if (m_wcompstr.UnicodeToMultiByteSize((DWORD)dwStrIndex) == 2) {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA += 2;
        }
        else {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA++;
        }
        dwStrIndex++;
    }
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckClause template


template<class APPS_CLAUSE, class HIMC_CLAUSE>
HRESULT
CheckClause(
    APPS_CLAUSE& apps_clause,                 // the clause from apps
    HIMC_CLAUSE& himc_clause                  // the clause from IMC
    )
{
    if (apps_clause.ReadCompData() == 0 ||
        himc_clause.ReadCompData() == 0  ) {
        TraceMsg(TF_ERROR, "CheckClause: no Clause.");
        return E_FAIL;
    }

    if (apps_clause.GetAt(0) ||
        himc_clause.GetAt(0)   ) {
        TraceMsg(TF_ERROR, "CheckClause: clause[0] have to be ZERO.");
        return E_FAIL;
    }

    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < himc_clause.ReadCompData();
         dwClauseIndex++
        ) {
        if (apps_clause.GetAt(dwClauseIndex) != himc_clause.GetAt(dwClauseIndex)) {
            return E_FAIL;
        }
    }

    return S_OK;
}


class CWCompClause;


/////////////////////////////////////////////////////////////////////////////
// CBCompClause

class CBCompClause : public CompData<DWORD, DWORD>
{
public:
    CBCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CBCompClause& operator=(CWCompClause& wcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompClause

class CWCompClause : public CompData<DWORD, DWORD>
{
public:
    CWCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CWCompClause& operator=(CBCompClause& bcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompClause/CWCompClause::operator=

inline
const CBCompClause&
CBCompClause::operator=(
    CWCompClause& wcompclause
    )

/*+++
 *
 * Get ANSI clause from Unicode composition clause.
 *
---*/

{
    m_bcompstr = wcompclause.m_wcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < wcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionWtoA( wcompclause.GetAt((DWORD)dwClauseIndex), &wcompclause.m_wcompstr ) );
    }
    return *this;
}

inline
const CWCompClause&
CWCompClause::operator=(
    CBCompClause& bcompclause
    )

/*+++
 *
 * Get Unicode clause from ANSI composition clause.
 *
---*/

{
    m_wcompstr = bcompclause.m_bcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < bcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionAtoW( bcompclause.GetAt((DWORD)dwClauseIndex), &bcompclause.m_bcompstr ) );
    }
    return *this;
}


class CWCompCursorPos;

/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos

class CBCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CBCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_bcompstr(cp, hIMC)
    {
    };

    CBCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CBCompCursorPos& operator=(CWCompCursorPos& wcompcursor);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompCursorPos

class CWCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CWCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(cp, hIMC)
    {
    };

    CWCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CWCompCursorPos& operator=(CBCompCursorPos& bcompcursorpos);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos/CWCompCursorPos::operator=

inline
const CBCompCursorPos&
CBCompCursorPos::operator=(
    CWCompCursorPos& wcompcursor
    )

/*+++
 *
 * Get ANSI cursor/delta start position from Unicode composition string.
 *
---*/

{
    m_bcompstr = wcompcursor.m_wcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionWtoA(wcompcursor.GetAt(0), &wcompcursor.m_wcompstr) );
    return *this;
}

inline
const CWCompCursorPos&
CWCompCursorPos::operator=(
    CBCompCursorPos& bcompcursor
    )

/*+++
 *
 * Get Unicode cursor/delta start position from ANSI composition string.
 *
---*/

{
    m_wcompstr = bcompcursor.m_bcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionAtoW(bcompcursor.GetAt(0), &bcompcursor.m_bcompstr) );
    return *this;
}


class CWCompDeltaStart;

/////////////////////////////////////////////////////////////////////////////
// CBCompDeltaStart

class CBCompDeltaStart : public CompData<DWORD, DWORD>
{
public:
    CBCompDeltaStart(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_bcompstr(cp, hIMC)
    {
    };

    CBCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CBCompDeltaStart& operator=(CWCompDeltaStart& wcompdeltastart);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompDeltaStart

class CWCompDeltaStart : public CompData<DWORD, DWORD>
{
public:
    CWCompDeltaStart(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(cp, hIMC)
    {
    };

    CWCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CWCompDeltaStart& operator=(CBCompDeltaStart& bcompdeltastart);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompDeltaStart/CWCompDeltaStart::operator=

inline
const CBCompDeltaStart&
CBCompDeltaStart::operator=(
    CWCompDeltaStart& wcompdeltastart
    )

/*+++
 *
 * Get ANSI cursor/delta start position from Unicode composition string.
 *
---*/

{
    m_bcompstr = wcompdeltastart.m_wcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionWtoA(wcompdeltastart.GetAt(0), &wcompdeltastart.m_wcompstr) );
    return *this;
}

inline
const CWCompDeltaStart&
CWCompDeltaStart::operator=(
    CBCompDeltaStart& bcompdeltastart
    )

/*+++
 *
 * Get Unicode cursor/delta start position from ANSI composition string.
 *
---*/

{
    m_wcompstr = bcompdeltastart.m_bcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionAtoW(bcompdeltastart.GetAt(0), &bcompdeltastart.m_bcompstr) );
    return *this;
}



class CWReconvertString;

/////////////////////////////////////////////////////////////////////////////
// CBReconvetString

class CBReconvertString
{
public:
    CBReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_bcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;
        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_bcompstr.WriteCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset;
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset;
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_bcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_bcompstr.ReadCompData() * sizeof(CHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)(m_bcompstr.ReadCompData() * sizeof(CHAR));
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(CHAR));
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(CHAR));

            dwBufLen = m_bcompstr.ReadCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CBReconvertString& operator=(CWReconvertString& wReconvStr);

    void SetData(CWReconvertString& wReconvStr);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

public:
    CBCompString    m_bcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CBCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CBCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};


/////////////////////////////////////////////////////////////////////////////
// CWReconvertString

class CWReconvertString
{
public:
    CWReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_wcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;

        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_wcompstr.WriteCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset / sizeof(WCHAR);   // char count
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset / sizeof(WCHAR);  // char count
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_wcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_wcompstr.ReadCompData() * sizeof(WCHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)m_wcompstr.ReadCompData();
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(WCHAR));  // byte count
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(WCHAR));  // byte count

            dwBufLen = m_wcompstr.ReadCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CWReconvertString& operator=(CBReconvertString& bReconvStr);

    void SetData(CBReconvertString& bReconvStr);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

public:
    CWCompString    m_wcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CWCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CWCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};

/////////////////////////////////////////////////////////////////////////////
// CBCompReconvertString/CWCompReconvertString::operator=

inline
const CBReconvertString&
CBReconvertString::operator=(
    CWReconvertString& wReconvStr
    )
{
    m_bcompstr = wReconvStr.m_wcompstr;
    SetData(wReconvStr);
    return *this;
}

inline
const CWReconvertString&
CWReconvertString::operator=(
    CBReconvertString& bReconvStr
    )
{
    m_wcompstr = bReconvStr.m_bcompstr;
    SetData(bReconvStr);
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CBReconvertString/CWReconvertString::SetData

inline
void
CBReconvertString::SetData(
    CWReconvertString& wReconvStr
    )
{
    m_dwVersion = wReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex), &wReconvStr.m_wcompstr);
    m_CompStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen), &wReconvStr.m_wcompstr) - m_CompStrIndex;
    m_TargetStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex), &wReconvStr.m_wcompstr);
    m_TargetStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex + wReconvStr.m_TargetStrLen), &wReconvStr.m_wcompstr) - m_TargetStrIndex;
}

inline
void
CWReconvertString::SetData(
    CBReconvertString& bReconvStr
    )
{
    m_dwVersion = bReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex), &bReconvStr.m_bcompstr);
    m_CompStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex + bReconvStr.m_CompStrLen), &bReconvStr.m_bcompstr) - m_CompStrIndex);
    m_TargetStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex), &bReconvStr.m_bcompstr);
    m_TargetStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex + bReconvStr.m_TargetStrLen), &bReconvStr.m_bcompstr) - m_TargetStrIndex);
}













/////////////////////////////////////////////////////////////////////////////
// CWInterimString

class CWInterimString : public CWCompString
{
public:
    CWInterimString(
        UINT cp,
        HIMC hIMC
        ) : CWCompString(cp, hIMC)
    {
        m_InterimChar = L'\0';
        m_InterimAttr = 0;
    }

    VOID WriteInterimChar(WCHAR ch, BYTE attr)
    {
        m_InterimChar = ch;
        m_InterimAttr = attr;
    }

    void ReadInterimChar(WCHAR* ch, BYTE* attr)
    {
        *ch   = m_InterimChar;
        *attr = m_InterimAttr;
    }

    void ReadInterimChar(CWCompString* ch, CWCompAttribute* attr)
    {
        ch->WriteCompData(&m_InterimChar, 1);
        attr->WriteCompData(&m_InterimAttr, 1);
    }

public:
    WCHAR           m_InterimChar;
    BYTE            m_InterimAttr;
};




/////////////////////////////////////////////////////////////////////////////
// CWCompTfGuidAtom

class CWCompTfGuidAtom : public CompData<TfGuidAtom, TfGuidAtom>
{
public:
};




/////////////////////////////////////////////////////////////////////////////
// friend

inline
DWORD
CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    CBCompString* bcompstr
    )

/*+++

    Calculation Unicode character position to ANSI character position

---*/

{
    DWORD dwCharPosW = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosA != 0) {
        if (bcompstr->IsDBCSLeadByteEx(dwStrIndex)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            dwStrIndex += 2;
        }
        else {
            dwCharPosA--;
            dwStrIndex++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}

inline
DWORD
CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    CWCompString* wcompstr
    )

/*+++

    Calculate ANSI character position to Unicode character position.

---*/

{
    DWORD dwCharPosA = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosW != 0) {
        if (wcompstr->UnicodeToMultiByteSize(dwStrIndex) == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwStrIndex++;
        dwCharPosW--;
    }

    return dwCharPosA;
}

#endif // _CTXTCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\imeapp.h ===
//
//	%%Title: IMEAPP
//	%%Unit: COM
//	%%Contact: TakeshiF/SeijiA
//	%%Date: 97/06/20
//	%%File: imeapp.h
//
//	Private API / Message service
//

#ifndef __IMEUP_H__
#define __IMEUP_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#include "actdict.h"

//// START

/***********************************************************************
    IME Version IDs
 ***********************************************************************/
#define VERSION_ID_JAPANESE                 0x01000000
#define VERSION_ID_KOREAN                   0x02000000
#define VERSION_ID_CHINESE_TRADITIONAL      0x04000000
#define VERSION_ID_CHINESE_SIMPLIFIED       0x08000000

#define VERSION_ID_IMEJP98  (VERSION_ID_JAPANESE | 0x980)
#define VERSION_ID_IMEJP98A (VERSION_ID_JAPANESE | 0x98a)

/***********************************************************************
    Msg:    WM_MSIME_SERVICE
    Desc:   service functions
    Dir:    Apps to IME
    wParam: reserved
    lParam: reserved
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_SERVICE     TEXT("MSIMEService")

//getting version number (wParam)
#define FID_MSIME_VERSION       0

/***********************************************************************
    Msg:    WM_MSIME_UIREADY
    Desc:   service functions
    Dir:    IME to Apps
    wParam: Version ID
    lParam: reserved
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_UIREADY     TEXT("MSIMEUIReady")


//getting class id
#define FID_MSIME_GETCLSID		2

typedef struct _IMECLSID
{
	int			cbSize;		//size of this structure
	CLSID		clsid;		//class id
} IMECLSID;


/***********************************************************************
	Msg:	WM_MSIME_AUTOCOMPLETE
	Desc: 	use IImeActiveDict to support auto-complete
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_AUTOCOMPLETE 		TEXT("MSIMEAutoComplete")

// AutoComplete Version
#define VERSION_AUTOCOMPETE		1

// Dictionary Structure
typedef struct _IMEDICT
{
	int				cbSize;			//size of this structure
	HIMC			hIMC;			//IME context
	IImeActiveDict	*pdict;			//program dictionary
} IMEDICT;

//WParam definition
#define FID_AUTO_VERSION		1
#define FID_AUTO_ACTIVATE		2
#define FID_AUTO_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_WORDSTAT
	Desc: 	use IImeActiveDict to get word statistics
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_WORDSTAT 		TEXT("MSIMEWordStatistics")

// WordStat Version
#define VERSION_WORDSTAT		1

// WParam definition
#define FID_STAT_VERSION		1
#define FID_STAT_GIVESTAT		2


/***********************************************************************
	Msg:	WM_MSIME_DOCKDICT
	Desc: 	use IImeActiveDict to dock dictionary
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_DOCKDICT 		TEXT("MSIMEDockActiveDict")

// Dictionary Docking Version
#define VERSION_DOCKDICT		1

// WParam definition
#define FID_DOCK_VERSION		1
#define FID_DOCK_ACTIVATE		2
#define FID_DOCK_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_MOUSE
	Desc: 	mouse operation definition                
	Owner: 	kentu				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE 		TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION		1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED		(-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION	0xff	// mouse supported?

#define IMEMOUSE_NONE		0x00	// no mouse button was pushed
#define IMEMOUSE_LDOWN		0x01
#define IMEMOUSE_RDOWN		0x02
#define IMEMOUSE_MDOWN		0x04
#define IMEMOUSE_WUP		0x10	// wheel up
#define IMEMOUSE_WDOWN		0x20	// wheel down


/***********************************************************************
	Msg:	WM_MSIME_RECONVERT/WM_MSIME_RECONVERTREQUEST
	Desc: 	reconversion
	Owner: 	takeshif				
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION	0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION		1

// Label for RegisterWindowMessage
#define	RWM_RECONVERT			TEXT("MSIMEReconvert")
#define	RWM_RECONVERTREQUEST	TEXT("MSIMEReconvertRequest")

/***********************************************************************
	Msg:	WM_MSIME_DOCUMENTFEED
	Desc: 	reconversion
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
				(RECONVERTSTRING*)pReconv );
	wParam: VERSION_DOCUMENTFEED
	lParam: Pointer of RECONVERTSTRING structure
	return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED		1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define	RWM_DOCUMENTFEED	TEXT("MSIMEDocumentFeed")

/***********************************************************************
	Msg:	WM_MSIME_QUERYHIDECARET
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndDefUI, WM_MSIME_QUERYHIDECARET, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = shows caret. Zero = hide caret.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYHIDECARET
#define VERSION_QUERYHIDECARET		1

// Label for RegisterWindowMessage
#define	RWM_QUERYHIDECARET	TEXT("MSIMEQueryHideCaret")

/***********************************************************************
	Msg:	WM_MSIME_QUERYPOSITION
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, VERSION_QUERYPOSITION, (IMEPOSITION*)pPs );
	wParam: reserved. must be 0.
	lParam: pointer of IMEPOSITION structure
	return: Non-zero = success. Zero = error.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION		1

// Label for RegisterWindowMessage
#define	RWM_QUERYPOSITION	TEXT("MSIMEQueryPosition")


/***********************************************************************
	Msg:	WM_MSIME_MODEBIAS
	Desc: 	input mode bias
	Owner: 	takeshif
	Usage: SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, MODEBIASMODE_xxxx );
	wParam: operation of bias
	lParam: bias mode
	return: If wParam is MODEBIAS_GETVERSION,returns version number of interface.
			If wParam is MODEBIAS_SETVALUE : return non-zero value if succeeded. Returns 0 if fail.
			If wParam is MODEBIAS_GETVALUE : returns current bias mode.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS			TEXT("MSIMEModeBias")

// Current version
#define VERSION_MODEBIAS		1

// Set or Get (wParam)
#define MODEBIAS_GETVERSION		0
#define MODEBIAS_SETVALUE		1
#define MODEBIAS_GETVALUE		2

// Bias (lParam)
#define MODEBIASMODE_DEFAULT				0x00000000	// reset all of bias setting
#define MODEBIASMODE_FILENAME				0x00000001	// filename
#define MODEBIASMODE_READING				0x00000002	// reading recommended
#define MODEBIASMODE_DIGIT					0x00000004	// ANSI-Digit Recommended Mode


/***********************************************************************
	Msg:	WM_MSIME_SHOWIMEPAD
	Desc: 	show ImePad
	Owner: 	toshiaK
	Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SHOWIMEPAD			TEXT("MSIMEShowImePad")


/***********************************************************************
	Msg:	WM_MSIME_KEYMAP
	Desc: 	key map sharing with apps
	Owner: 	HiroakiK
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_KEYMAP				TEXT("MSIMEKeyMap")
#define	RWM_CHGKEYMAP			TEXT("MSIMEChangeKeyMap")
#define	RWM_NTFYKEYMAP			TEXT("MSIMENotifyKeyMap")


#define FID_MSIME_KMS_VERSION		1
#define FID_MSIME_KMS_INIT			2
#define FID_MSIME_KMS_TERM			3
#define FID_MSIME_KMS_DEL_KEYLIST	4
#define FID_MSIME_KMS_NOTIFY		5
#define FID_MSIME_KMS_GETMAP		6
#define FID_MSIME_KMS_INVOKE		7
#define FID_MSIME_KMS_SETMAP		8
#define FID_MSIME_KMS_FUNCDESC		9


#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4
#define IMEKMS_INPTGL               5



typedef struct tagIMEKMSINIT {
	INT			cbSize;
	HWND		hWnd;	// Window which receives notification from IME.
						// If hWnd is NULL, no notification is posted
						// to Input context.
} IMEKMSINIT;


typedef struct tagIMEKMSKEY {
	DWORD dwStatus;		//Shift-Control combination status.
						//Any combination of constants below
						//(defined in IMM.H)
						// 0x0000 (default)
						// MOD_CONTROL     0x0002
						// MOD_SHIFT       0x0004
						// Alt key and Win key is not processed by IME. 
	
	DWORD dwCompStatus;	//Composition string status
						//One of the constants below
						// IMEKMS_NOCOMPOSITION  No composition string      
						// IMEKMS_COMPOSITION    Some composition string
						// IMEKMS_SELECTION      Selection exists in apps
						// IMEKMS_IMEOFF         IME Off state
						// IMEKMS_2NDLEVEL       2nd stage on 2 stroke key operation
						
	
	DWORD dwVKEY;		// VKEY code defined in IMM.H
	union {
		DWORD dwControl;// IME Functionality ID
		DWORD dwNotUsed;
	};
	union {
		WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
		WCHAR pwszNoUse[31];
	};
} IMEKMSKEY;

typedef struct tagIMEKMS {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		cKeyList;
	IMEKMSKEY	*pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
	INT			cbSize;
	HIMC		hIMC;
	BOOL		fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
	INT			cbSize;			//[in] size of this structure
	HIMC		hIMC;			//[in] Input context
	LANGID		idLang;			//[in] Language ID
	WORD		wVKStart;		//[in] VKEY start
	WORD		wVKEnd;			//[in] VKEY end
	INT			cKeyList;		//[out] number of IMEKMSKEY
	IMEKMSKEY	*pKeyList;		//[out] retrieve buffer of IMEKMSKEY
								//      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		dwControl;
} IMEKMSINVK;

typedef struct tagIMEKMSFUNCDESC {
	INT			cbSize;			//[in] size of this structure
	LANGID		idLang;			//[in] Language ID
	DWORD		dwControl;		//[in] IME Functionality ID
	WCHAR		pwszDescription[128]; //[out] Description of the functionality
} IMEKMSFUNCDESC;

/***********************************************************************
    Msg:    WM_MSIME_RECONVERTOPTIONS
    Desc:   Set reconversion options
    Usage: SendMessage( hwndDefUI, WM_MSIME_RECONVERTOPTIONS, dwOpt, (LPARAM)(HIMC)hIMC );
    wParam: options
    lParam: Input context handle
    return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_RECONVERTOPTIONS          TEXT("MSIMEReconvertOptions")

//WParam definition for WM_IME_RECONVERTOPTIONS.
#define RECONVOPT_NONE              0x00000000  // default
#define RECONVOPT_USECANCELNOTIFY   0x00000001  // cancel notify

// parameter of ImmGetCompositionString
#define GCSEX_CANCELRECONVERT       0x10000000

//// END

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif // __IMEUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\actdict.h ===
/*----------------------------------------------------------------------------
	%%File: ACTDICT.H
	%%Unit: ACTDICT
	%%Contact: seijia@microsoft.com

	Header file for the program dictionary interface.
----------------------------------------------------------------------------*/

#ifndef __PRGDIC__
#define  __PRGDIC__

#include "outpos.h"

#define DLLExport				__declspec( dllexport )

//HRESULT values
#define IPRG_S_LONGER_WORD			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)
#define IPRG_S_NO_ENTRY				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7401)

//Dictionary Category
typedef DWORD			IMEDICAT;

#define dicatNone			0x00000000
#define dicatGeneral		0x00000001
#define	dicatNamePlace		0x00000002
#define dicatSpeech			0x00000004
#define dicatReverse		0x00000008
#define	dicatEnglish		0x00000010
#define dicatALL			0x0000001f

//Index Type
typedef DWORD			IMEIDXTP;

#define	idxtpHiraKanji		0x0001
#define	idxtpKanjiHira		0x0002
#define	idxtpMix			(idxtpHiraKanji | idxtpKanjiHira)

//IImeActiveDict Interface Version
#define	verIImeActiveDict			0x0100

//Dictionary Data Disclosure
typedef enum _IMEDDISC
{
	ddiscNone,				//do not disclose data
	ddiscAll,				//show all contents
	ddiscPartial			//show partial data
} IMEDDISC;

// Shared Header dictionary File
typedef struct _IMESHF
{
	WORD 		cbShf;				//size of this struct
	WORD 		verDic;				//dictionary version
	CHAR 		szTitle[48];		//dictionary title
	CHAR 		szDescription[256];	//dictionary description
	CHAR 		szCopyright[128];	//dictionary copyright info
} IMESHF;

//Dictionary Info
typedef struct _IMEDINFO
{
	IMESHF		shf;		//header
	DWORD		ver;		//IImeActiveDict version number
	IMEDDISC	ddisc;		//disclosure permission type
	FILETIME	filestamp;	//file stamp at creation
	IMEDICAT	dicat;		//dictionary category
	IMEIDXTP	idxtp;		//index type
	BOOL		fLearn;		//support word learning
} IMEDINFO;

#define cwchWordMax			64

typedef DWORD		IMESTMP;			//word stamp

//Program Dictionary Tango
typedef struct _IMEPDT
{
	IMEIDXTP	idxtp;					//index type
	int			cwchInput;				//input string length
	int			cwchOutput;				//output string length
	WCHAR		wszInput[cwchWordMax];	//input string
	WCHAR		wszOutput[cwchWordMax];	//output string
	DWORD		nPos;					//part of speech
	IMESTMP		stmp;					//word time stamp
} IMEPDT;

///////////////////////////////
// The IImeActiveDict interface
///////////////////////////////

#undef  INTERFACE
#define INTERFACE   IImeActiveDict

DECLARE_INTERFACE_(IImeActiveDict, IUnknown)
{
	// IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IImeActiveDict members
    STDMETHOD(DicInquire)	(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicOpen)		(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicClose)		(THIS) PURE;
    STDMETHOD(DicSearchWord)(THIS_
							IMEPDT *ppdt, 				//(in/out) tango
							BOOL fFirst, 				//(in) first time flag
							BOOL fWildCard,				//(in) wildcard flag
							BOOL fPartial				//(in) disclosure flag
							) PURE;
    STDMETHOD(DicLearnWord)	(THIS_
							IMEPDT *ppdt,				//(in/out) tango
							BOOL fUserLearn	,			//(in) user learning option
							int nLevel					//(in) learning level
							) PURE;
    STDMETHOD(DicProperty)	(THIS_
							HWND hwnd					//(in) parent window handle
							) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance() since we don't support class ID at this time.
typedef HRESULT (WINAPI *PFNCREATE)(VOID **, int);
DLLExport HRESULT WINAPI CreateIImeActiveDictInstance(VOID **ppvObj, int nid);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__PRGDIC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\imeutil.h ===
//
// imeutil.h
//

#ifndef IMEUTIL_H
#define IMEUTIL_H

#include <windows.h>


#ifdef __cplusplus
extern "C" {
#endif

DWORD HexStrToDWORD(TCHAR *pStr);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // IMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\imclock.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imclock.h

Abstract:

    This file defines the _IMCLock/_IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMCLOCK_H_
#define _IMCLOCK_H_

typedef struct tagINPUTCONTEXT_AIMM12 {
    HWND                hWnd;
    BOOL                fOpen;
    POINT               ptStatusWndPos;
    POINT               ptSoftKbdPos;
    DWORD               fdwConversion;
    DWORD               fdwSentence;
    union   {
        LOGFONTA        A;
        LOGFONTW        W;
    } lfFont;
    COMPOSITIONFORM     cfCompForm;
    CANDIDATEFORM       cfCandForm[4];
    HIMCC               hCompStr;
    HIMCC               hCandInfo;
    HIMCC               hGuideLine;
    HIMCC               hPrivate;
    DWORD               dwNumMsgBuf;
    HIMCC               hMsgBuf;
    DWORD               fdwInit;
    //
    // Use dwReserve[0] area for AIMM12
    //
    union {
        DWORD               m_dwReserve0;
#ifdef  _ENABLE_AIME_CONTEXT_
        IAImeContext*       m_pContext;
#endif
#ifdef  _ENABLE_CAIME_CONTEXT_
        CAImeContext*       m_pAImeContext;
#endif
    };

    //
    // Use dwReserve[1] area for AIMM12(Hangul mode tracking)
    //
    DWORD               fdwHangul;

    DWORD               dwReserve[1];
} INPUTCONTEXT_AIMM12, *PINPUTCONTEXT_AIMM12, NEAR *NPINPUTCONTEXT_AIMM12, FAR *LPINPUTCONTEXT_AIMM12;

// bit field for extended conversion mode
#define IME_CMODE_GUID_NULL    0x80000000
#define IME_SMODE_GUID_NULL    0x00008000


typedef struct tagCOMPOSITIONSTRING_AIMM12 {
    COMPOSITIONSTRING   CompStr;
    //
    // IME share of GUID map attribute.
    //
    DWORD               dwTfGuidAtomLen;
    DWORD               dwTfGuidAtomOffset;
    //
    DWORD               dwGuidMapAttrLen;
    DWORD               dwGuidMapAttrOffset;
} COMPOSITIONSTRING_AIMM12, *PCOMPOSITIONSTRING_AIMM12, NEAR *NPCOMPOSITIONSTRING_AIMM12, FAR *LPCOMPOSITIONSTRING_AIMM12;

// bits of fdwInit of INPUTCONTEXT
#define INIT_GUID_ATOM    0x00000040


//
// AIMM12 Compatibility flag
//
extern LPCTSTR REG_MSIMTF_KEY;

#define AIMM12_COMP_WINWORD 0x00000001




class _IMCLock
{
public:
    _IMCLock(HIMC hImc=NULL);
    virtual ~_IMCLock() {};

    bool    Valid()     { return m_inputcontext != NULL ? m_hr == S_OK : FALSE; }
    bool    Invalid()   { return !Valid(); }
    HRESULT GetResult() { return m_inputcontext ? m_hr : E_FAIL; }

    operator INPUTCONTEXT_AIMM12*() { return m_inputcontext; }

    INPUTCONTEXT_AIMM12* operator->() {
        ASSERT(m_inputcontext);
        return m_inputcontext;
    }

    operator HIMC() { return m_himc; }

    BOOL IsUnicode() { return m_fUnicode; }

protected:
    INPUTCONTEXT_AIMM12* m_inputcontext;
    HIMC                 m_himc;
    HRESULT              m_hr;
    BOOL                 m_fUnicode;

    virtual HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT_AIMM12 **ppIMC) = 0;
    virtual HRESULT _UnlockIMC(HIMC hIMC) = 0;

private:
    // Do not allow to make a copy
    _IMCLock(_IMCLock&) { }
};

inline
_IMCLock::_IMCLock(
    HIMC hImc
    )
{
    m_inputcontext = NULL;
    m_himc         = hImc;
    m_hr           = S_OK;
    m_fUnicode     = FALSE;
}


class _IMCCLock
{
public:
    _IMCCLock(HIMCC himcc = NULL);
    virtual ~_IMCCLock() {};

    bool Valid() { return m_pimcc != NULL; }
    bool Invalid() { return !Valid(); }
    HRESULT GetResult() { return m_pimcc ? m_hr : E_FAIL; }

    void ReleaseBuffer() { }

    void* GetOffsetPointer(DWORD dwOffset) {
        return (void*)( (LPBYTE)m_pimcc + dwOffset );
    }

protected:
    union {
        void*                      m_pimcc;
        COMPOSITIONSTRING_AIMM12*  m_pcomp;
#ifdef  _ENABLE_PRIVCONTEXT_
        PRIVCONTEXT*               m_ppriv;
#endif
    };

    HIMCC         m_himcc;
    HRESULT       m_hr;

    virtual HRESULT _LockIMCC(HIMCC hIMCC, void **ppv) = 0;
    virtual HRESULT _UnlockIMCC(HIMCC hIMCC) = 0;

private:
    void init(HIMCC hImcc);

    // Do not allow to make a copy
    _IMCCLock(_IMCCLock&) { }
};

inline
_IMCCLock::_IMCCLock(
    HIMCC hImcc
    )
{
    init(hImcc);
}

inline
void
_IMCCLock::init(
    HIMCC hImcc
    )
{
    m_pimcc = NULL;
    m_himcc        = hImcc;
    m_hr           = S_OK;
}

#endif // _IMCLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\imtls.h ===
//
// imtls.h
//

#ifndef IMTLS_H
#define IMTLS_H

#include "private.h"
#include "ciccs.h"
#include "imtls.h"

extern DWORD g_dwTLSIndex;

class CActiveIMM;

struct ITfThreadMgr_P;
struct IActiveIMMIME_Private;
struct IAImeProfile;

typedef struct _PENDINGFILTER
{
    struct _PENDINGFILTER *pNext;
    UINT uSize;
    ATOM rgAtoms[1];
} PENDINGFILTER;

typedef struct _PENDINGFILTERGUIDMAP
{
    struct _PENDINGFILTERGUIDMAP *pNext;
    UINT uSize;
    BOOL rgGuidMap[1];
} PENDINGFILTERGUIDMAP;

typedef struct _PENDINGFILTEREX
{
    struct _PENDINGFILTEREX *pNext;
    HWND hWnd;
    BOOL fGuidMap;
} PENDINGFILTEREX;

typedef struct _PrivateUIWndMsg
{
    HWND hWnd;
    UINT uMsgOnLayoutChange;
    UINT uMsgOnClearDocFeedBuffer;
} PrivateUIWndMsg;

typedef struct _IMTLS
{
    // dimm
    CActiveIMM *pActiveIMM;
    PENDINGFILTER        *pPendingFilterClientWindows;          // IActiveIMMApp::FilterClientWindows
    PENDINGFILTERGUIDMAP *pPendingFilterClientWindowsGuidMap;   // IActiveIMMAppEx::FilterClientWindows
    PENDINGFILTEREX      *pPendingFilterClientWindowsEx;        // IActiveIMMAppEx::FilterClientWindowsEx

    // win32
    // consider: perf: this is so lame.  We could put almost all of this directly
    // into ImmIfIme, the per-thread object, rather using TLS everywhere.
    ITfThreadMgr_P *tim;
    HIMC hIMC;
    IActiveIMMIME_Private *pAImm; // consider: this could be merged with pActiveIMM
    IAImeProfile *pAImeProfile;
    PrivateUIWndMsg prvUIWndMsg; // consider: is this constant per-process?

    BOOL   m_fMyPushPop : 1;                  // TRUE: This is AIMM1.2's Push/Pop call.

} IMTLS;

extern CCicCriticalSectionStatic g_cs;
extern BOOL  g_fInLegacyClsid;
extern BOOL  g_fTrident55;
extern BOOL  g_fAIMM12Trident;

#ifdef DEBUG
extern DWORD g_dwCacheThreadId;
#endif

inline IMTLS *IMTLS_GetOrAlloc()
{
    IMTLS *ptls;
 
    ptls = (IMTLS *)TlsGetValue(g_dwTLSIndex);

    if (ptls == NULL)
    {
        if ((ptls = (IMTLS *)cicMemAllocClear(sizeof(IMTLS))) == NULL)
            return NULL;

        if (!TlsSetValue(g_dwTLSIndex, ptls))
        {
            cicMemFree(ptls);
            return NULL;
        }
    }

    return ptls;
}

inline void IMTLS_Free()
{
    PENDINGFILTER *pPending;
    PENDINGFILTEREX *pPendingEx;
    IMTLS *ptls;

    ptls = (IMTLS *)TlsGetValue(g_dwTLSIndex);

    if (ptls == NULL)
        return;

    Assert(ptls->pActiveIMM == NULL);
    Assert(ptls->tim == NULL);
    Assert(ptls->pAImeProfile == NULL);

    while (ptls->pPendingFilterClientWindows != NULL)
    {
        pPending = ptls->pPendingFilterClientWindows->pNext;
        cicMemFree(ptls->pPendingFilterClientWindows);
        ptls->pPendingFilterClientWindows = pPending;
    }
    while (ptls->pPendingFilterClientWindowsEx != NULL)
    {
        pPendingEx = ptls->pPendingFilterClientWindowsEx->pNext;
        cicMemFree(ptls->pPendingFilterClientWindowsEx);
        ptls->pPendingFilterClientWindowsEx = pPendingEx;
    }

    cicMemFree(ptls);
    TlsSetValue(g_dwTLSIndex, NULL);
}

inline CActiveIMM *IMTLS_GetActiveIMM()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
    {
        return NULL;
    }

    return ptls->pActiveIMM;
}

inline BOOL IMTLS_SetActiveIMM(CActiveIMM *pActiveIMM)
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return FALSE;

    ptls->pActiveIMM = pActiveIMM;

    return TRUE;
}

#endif // IMTLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\lib\imeutil.c ===
//
// imeutil.c
//

#include "imeutil.h"
#include "debug.h"

DWORD HexStrToDWORD(TCHAR *pStr)
{
    DWORD dw;
    TCHAR c;

    dw = 0;

    while (c = *pStr++)
    {
        dw *= 16;

        if (c >= '0' && c <= '9')
        {
            dw += c - '0';
        }
        else if (c >= 'a' && c <= 'f')
        {
            dw += c - 'a' + 10;
        }
        else if (c >= 'A' && c <= 'F')
        {
            dw += c - 'A' + 10;
        }
        else
        {
            break;
        }
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\outpos.h ===
/*----------------------------------------------------------------------------
	%%File: OUTPOS.H
	%%Unit: OUTPOS
	%%Contact: seijia

	mapping from public and private pos
----------------------------------------------------------------------------*/

#ifndef __OUTPOS_H__
#define __OUTPOS_H__

#define POS_UNDEFINED			0

#define JPOS_UNDEFINED			POS_UNDEFINED

#define JPOS_MEISHI_FUTSU		100		//
#define JPOS_MEISHI_SAHEN		101		//
#define JPOS_MEISHI_ZAHEN		102		//
#define JPOS_MEISHI_KEIYOUDOUSHI		103		//`
#define JPOS_HUKUSIMEISHI		104		//I
#define JPOS_MEISA_KEIDOU		105		//`
#define JPOS_JINMEI		106		//l
#define JPOS_JINMEI_SEI		107		//
#define JPOS_JINMEI_MEI		108		//
#define JPOS_CHIMEI		109		//n
#define JPOS_CHIMEI_KUNI		110		//
#define JPOS_CHIMEI_KEN		111		//
#define JPOS_CHIMEI_GUN		112		//S
#define JPOS_CHIMEI_KU		113		//
#define JPOS_CHIMEI_SHI		114		//s
#define JPOS_CHIMEI_MACHI		115		//
#define JPOS_CHIMEI_MURA		116		//
#define JPOS_CHIMEI_EKI		117		//w
#define JPOS_SONOTA		118		//L
#define JPOS_SHAMEI		119		//
#define JPOS_SOSHIKI		120		//gD
#define JPOS_KENCHIKU		121		//z
#define JPOS_BUPPIN		122		//i
#define JPOS_DAIMEISHI		123		//
#define JPOS_DAIMEISHI_NINSHOU		124		//l
#define JPOS_DAIMEISHI_SHIJI		125		//w
#define JPOS_KAZU		126		//
#define JPOS_KAZU_SURYOU		127		//
#define JPOS_KAZU_SUSHI		128		//
#define JPOS_5DAN_AWA		200		//s
#define JPOS_5DAN_KA		201		//s
#define JPOS_5DAN_GA		202		//s
#define JPOS_5DAN_SA		203		//s
#define JPOS_5DAN_TA		204		//s
#define JPOS_5DAN_NA		205		//s
#define JPOS_5DAN_BA		206		//s
#define JPOS_5DAN_MA		207		//s
#define JPOS_5DAN_RA		208		//s
#define JPOS_5DAN_AWAUON		209		//s
#define JPOS_5DAN_KASOKUON		210		//s
#define JPOS_5DAN_RAHEN		211		//si
#define JPOS_4DAN_HA		212		//sli
#define JPOS_1DAN		213		//i
#define JPOS_TOKUSHU_KAHEN		214		//
#define JPOS_TOKUSHU_SAHENSURU		215		//
#define JPOS_TOKUSHU_SAHEN		216		//si
#define JPOS_TOKUSHU_ZAHEN		217		//si
#define JPOS_TOKUSHU_NAHEN		218		//si
#define JPOS_KURU_KI		219		//
#define JPOS_KURU_KITA		220		//
#define JPOS_KURU_KITARA		221		//
#define JPOS_KURU_KITARI		222		//
#define JPOS_KURU_KITAROU		223		//
#define JPOS_KURU_KITE		224		//
#define JPOS_KURU_KUREBA		225		//
#define JPOS_KURU_KO		226		//ij
#define JPOS_KURU_KOI		227		//
#define JPOS_KURU_KOYOU		228		//
#define JPOS_SURU_SA		229		//
#define JPOS_SURU_SI		230		//
#define JPOS_SURU_SITA		231		//
#define JPOS_SURU_SITARA		232		//
#define JPOS_SURU_SIATRI		233		//
#define JPOS_SURU_SITAROU		234		//
#define JPOS_SURU_SITE		235		//
#define JPOS_SURU_SIYOU		236		//
#define JPOS_SURU_SUREBA		237		//
#define JPOS_SURU_SE		238		//
#define JPOS_SURU_SEYO		239		//^
#define JPOS_KEIYOU		300		//`e
#define JPOS_KEIYOU_GARU		301		//`e
#define JPOS_KEIYOU_GE		302		//`e
#define JPOS_KEIYOU_ME		303		//`e
#define JPOS_KEIYOU_YUU		304		//`e
#define JPOS_KEIYOU_U		305		//`e
#define JPOS_KEIDOU		400		//`e
#define JPOS_KEIDOU_NO		401		//`e
#define JPOS_KEIDOU_TARU		402		//`e
#define JPOS_KEIDOU_GARU		403		//`e
#define JPOS_FUKUSHI		500		//
#define JPOS_FUKUSHI_SAHEN		501		//
#define JPOS_FUKUSHI_NI		502		//
#define JPOS_FUKUSHI_NANO		503		//
#define JPOS_FUKUSHI_DA		504		//
#define JPOS_FUKUSHI_TO		505		//
#define JPOS_FUKUSHI_TOSURU		506		//
#define JPOS_RENTAISHI		600		//A
#define JPOS_RENTAISHI_SHIJI		601		//wA
#define JPOS_SETSUZOKUSHI		650		//
#define JPOS_KANDOUSHI		670		//
#define JPOS_SETTOU		700		//
#define JPOS_SETTOU_KAKU		701		//P
#define JPOS_SETTOU_SAI		702		//Q
#define JPOS_SETTOU_FUKU		703		//R
#define JPOS_SETTOU_MI		704		//S
#define JPOS_SETTOU_DAISHOU		705		//T
#define JPOS_SETTOU_KOUTEI		706		//U
#define JPOS_SETTOU_CHOUTAN		707		//V
#define JPOS_SETTOU_SHINKYU		708		//W
#define JPOS_SETTOU_JINMEI		709		//l
#define JPOS_SETTOU_CHIMEI		710		//n
#define JPOS_SETTOU_SONOTA		711		//L
#define JPOS_SETTOU_JOSUSHI		712		//Ou
#define JPOS_SETTOU_TEINEI_O		713		//JP
#define JPOS_SETTOU_TEINEI_GO		714		//JQ
#define JPOS_SETTOU_TEINEI_ON		715		//JR
#define JPOS_SETSUBI		800		//
#define JPOS_SETSUBI_TEKI		801		//P
#define JPOS_SETSUBI_SEI		802		//Q
#define JPOS_SETSUBI_KA		803		//R
#define JPOS_SETSUBI_CHU		804		//S
#define JPOS_SETSUBI_FU		805		//T
#define JPOS_SETSUBI_RYU		806		//U
#define JPOS_SETSUBI_YOU		807		//V
#define JPOS_SETSUBI_KATA		808		//W
#define JPOS_SETSUBI_MEISHIRENDAKU		809		//A
#define JPOS_SETSUBI_JINMEI		810		//l
#define JPOS_SETSUBI_CHIMEI		811		//n
#define JPOS_SETSUBI_KUNI		812		//
#define JPOS_SETSUBI_KEN		813		//
#define JPOS_SETSUBI_GUN		814		//S
#define JPOS_SETSUBI_KU		815		//
#define JPOS_SETSUBI_SHI		816		//s
#define JPOS_SETSUBI_MACHI		817		//P
#define JPOS_SETSUBI_CHOU		818		//Q
#define JPOS_SETSUBI_MURA		819		//P
#define JPOS_SETSUBI_SON		820		//Q
#define JPOS_SETSUBI_EKI		821		//w
#define JPOS_SETSUBI_SONOTA		822		//L
#define JPOS_SETSUBI_SHAMEI		823		//
#define JPOS_SETSUBI_SOSHIKI		824		//gD
#define JPOS_SETSUBI_KENCHIKU		825		//z
#define JPOS_RENYOU_SETSUBI		826		//Ap
#define JPOS_SETSUBI_JOSUSHI		827		//u
#define JPOS_SETSUBI_JOSUSHIPLUS		828		//u{
#define JPOS_SETSUBI_JIKAN		829		//
#define JPOS_SETSUBI_JIKANPLUS		830		//{
#define JPOS_SETSUBI_TEINEI		831		//J
#define JPOS_SETSUBI_SAN		832		//JP
#define JPOS_SETSUBI_KUN		833		//JQ
#define JPOS_SETSUBI_SAMA		834		//JR
#define JPOS_SETSUBI_DONO		835		//JS
#define JPOS_SETSUBI_FUKUSU		836		//
#define JPOS_SETSUBI_TACHI		837		//P
#define JPOS_SETSUBI_RA		838		//Q
#define JPOS_TANKANJI		900		//P
#define JPOS_TANKANJI_KAO		901		//
#define JPOS_KANYOUKU		902		//p
#define JPOS_DOKURITSUGO		903		//
#define JPOS_FUTEIGO		904		//s
#define JPOS_KIGOU		905		//L
#define JPOS_EIJI		906		//p
#define JPOS_KUTEN		907		//_
#define JPOS_TOUTEN		908		//_
#define JPOS_KANJI		909		//s\
#define JPOS_OPENBRACE		910		//J
#define JPOS_CLOSEBRACE		911		//


#pragma pack (push, 1)
//POS table data structure
typedef struct _POSTBL
{
	WORD		nPos;					//pos number
	BYTE		*szName;				//name of pos
} POSTBL;
#pragma pack (pop)

#ifdef __cplusplus
extern "C" {
#endif

//function prototypes
extern POSTBL *ObtainPosTable(int *pcPos);
extern WORD WPosExtFromIn(WORD wPos);
extern WORD WPosInFromExt(WORD wPos);
BOOL FRegistExtPos(WORD wPos);
#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__OUTPOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\inc\resource.h ===
//
// resource.h
//

#ifndef RESOURCE_H
#define RESOURCE_H

/////////////////////////////////////////////////////////////////////////////
// Editing VK

#define ID_EDITING 100

#define EDIT_ID_FINALIZE    1
#define EDIT_ID_HANJA       2

/////////////////////////////////////////////////////////////////////////////
// Filter list

#define ID_FILTER_LIST 200

/////////////////////////////////////////////////////////////////////////////
// Known EXE module list for Trident aware applications.

#define ID_KNOWN_EXE   300

/////////////////////////////////////////////////////////////////////////////
// String ID

#define IDS_FUNCPRV_CONVERSION          0x0202

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\lib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define NOIME
#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <ocidl.h>


// New NT5 header
#include "immdev.h"
#define _IMM_
#define _DDKIMM_H_

#include "msctf.h"

//#include <shlwapi.h>
//#include <advpub.h>
#include <ccstock.h>
//#include <inetreg.h>
//#include <comcat.h>
//#include <olectl.h>

#define _DDKIMM_H_
#include "aimm12.h"
#include "aimmp.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\uuid\aimm_g.c ===
#ifdef __cplusplus
extern "C"{
#endif


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#if 0
/* aa80e7f1-2021-11d2-93e0-0060b067b86e */
const CLSID CLSID_CActiveIMM = {
    0x4955DD33,
    0xB159,
    0x11d0,
    {0x8f, 0xcf, 0x00, 0xaa, 0x00, 0x6b, 0xcc, 0x59}
  };
#endif

/* c1ee01f2-b3b6-4a6a-9ddd-e988c088ec82 */
const CLSID CLSID_CActiveIMM12 = { 
    0xc1ee01f2,
    0xb3b6,
    0x4a6a,
    {0x9d, 0xdd, 0xe9, 0x88, 0xc0, 0x88, 0xec, 0x82}
  };

/* 50D5107A-D278-4871-8989-F4CEAAF59CFC */
const CLSID CLSID_CActiveIMM12_Trident = {
    0x50d5107a,
    0xd278,
    0x4871,
    {0x89, 0x89, 0xf4, 0xce, 0xaa, 0xf5, 0x9c, 0xfc}
   };

// {B676DB87-64DC-4651-99EC-91070EA48790}
const CLSID CLSID_CAImmLayer = {
    0xb676db87,
    0x64dc,
    0x4651,
    { 0x99, 0xec, 0x91, 0x7, 0xe, 0xa4, 0x87, 0x90 }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_context.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_context.cpp

Abstract:

    This file implements the CAImeContext Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cime.h"
#include "a_context.h"
#include "editses.h"
#include "immif.h"
#include "idebug.h"
#include "resource.h"
#include "a_wrappers.h"
#include "langct.h"
#include "korimx.h"


//
// Create instance
//

// entry point for msimtf.dll
HRESULT CAImeContext_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return CAImeContext::CreateInstance(pUnkOuter, riid, ppvObj);
}

HRESULT
CAImeContext::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    DebugMsg(TF_FUNC, "CAImeContext::CreateInstance called.");

    *ppvObj = NULL;
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    CAImeContext* pImeContext = new CAImeContext;
    if (pImeContext) {
        HRESULT hr = pImeContext->QueryInterface(riid, ppvObj);

        if (SUCCEEDED(hr)) {
            pImeContext->Release();
        }

        return hr;
    }

    return E_OUTOFMEMORY;
}

//
// Initialization, destruction and standard COM stuff
//

CAImeContext::CAImeContext(
    )
{
    m_ref = 1;

    m_hImc = NULL;

    m_pdim = NULL;           // Document Manager
    m_pic = NULL;            // Input Context
    m_piccb = NULL;          // Context owner service from m_pic

    m_fInReconvertEditSession = FALSE;
#ifdef CICERO_4732
    m_fInCompComplete = FALSE;
#endif

    m_fHanjaReConversion = FALSE;

    m_fQueryPos = IME_QUERY_POS_UNKNOWN;

    _cCompositions = 0;
}

CAImeContext::~CAImeContext()
{
}

HRESULT
CAImeContext::QueryInterface(
    REFIID riid,
    void **ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IAImeContext) ||
        IsEqualIID(riid, IID_IUnknown)) {
        *ppvObj = static_cast<IAImeContext*>(this);
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        *ppvObj = static_cast<ITfCleanupContextSink*>(this);
    }
    else if (IsEqualGUID(riid, IID_ITfContextOwnerCompositionSink))
    {
        *ppvObj = static_cast<ITfContextOwnerCompositionSink*>(this);
    }
    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CAImeContext::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CAImeContext::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

TfClientId CAImeContext::GetClientId()
{ 
    Assert(m_pImmIfIME != NULL);
    return m_pImmIfIME->GetClientId();
}

HRESULT
CAImeContext::CreateAImeContext(
    HIMC hIMC,
    IActiveIME_Private* pActiveIME
    )
{
    TfEditCookie ecTmp;
    ITfSourceSingle *pSourceSingle;
    HRESULT hr;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (hIMC == m_hImc)
        return S_OK;
    else if (m_hImc)
        return E_FAIL;

    m_hImc = hIMC;

    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    m_pImmIfIME = (ImmIfIME*)pActiveIME;
    m_pImmIfIME->AddRef();

    imc->m_pAImeContext = this;

    // do this once for the life time of this context
    m_fStartComposition = FALSE;

    //
    // Create document manager.
    //
    if (m_pdim == NULL) {

        if (FAILED(hr = ptls->tim->CreateDocumentMgr(&m_pdim)))
        {
            m_pImmIfIME->Release();
            return hr;
        }
    }

    // tim should already be activated
    Assert(GetClientId() != TF_CLIENTID_NULL);

    Assert(m_pic == NULL);

    //
    // Create input context
    //
    hr = m_pdim->CreateContext(GetClientId(), 0, (ITfContextOwnerCompositionSink*)this, &m_pic, &ecTmp);
    if (FAILED(hr)) {
        DestroyAImeContext(hIMC);
        return hr;
    }

    //
    // set AppProp mapping
    //
    ITfContext_P *picp;
    if (SUCCEEDED(m_pic->QueryInterface(IID_ITfContext_P, (void **)&picp)))
    {
        picp->MapAppProperty(TSATTRID_Text_ReadOnly, GUID_PROP_MSIMTF_READONLY);
        picp->Release();
    }

    //
    // Create Input Context Owner Callback
    //
    if (m_pICOwnerSink == NULL) {
        m_pICOwnerSink = new CInputContextOwnerCallBack(m_pImmIfIME->_GetLibTLS());
        if (m_pICOwnerSink == NULL) {
            DebugMsg(TF_ERROR, "Couldn't create ICOwnerSink tim!");
            Assert(0); // couldn't activate thread!
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }

        if (!m_pICOwnerSink->Init()) {
            DebugMsg(TF_ERROR, TEXT("Couldn't initialize ICOwnerSink tim!"));
            Assert(0); // couldn't activate thread!
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }

        m_pICOwnerSink->SetCallbackDataPointer(m_pICOwnerSink);
    }

    //
    // Advise IC.
    //
    m_pICOwnerSink->_Advise(m_pic);

    if (m_pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
    {
        // setup a cleanup callback
        // nb: a real tip doesn't need to be this aggressive, for instance
        // kimx probably only needs this sink on the focus ic.
        pSourceSingle->AdviseSingleSink(GetClientId(), IID_ITfCleanupContextSink, (ITfCleanupContextSink *)this);
        pSourceSingle->Release();
    }

    //
    // Push IC.
    //
    ptls->m_fMyPushPop = TRUE;
    hr = m_pdim->Push(m_pic);
    ptls->m_fMyPushPop = FALSE;

    if (m_piccb == NULL) {
        m_pic->QueryInterface(IID_ITfContextOwnerServices,
                              (void **)&m_piccb);
    }

    //
    // Create Text Event Sink Callback
    //
    if (m_pTextEventSink == NULL) {
        m_pTextEventSink = new CTextEventSinkCallBack(m_pImmIfIME, hIMC);
        if (m_pTextEventSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pTextEventSink->SetCallbackDataPointer(m_pTextEventSink);

        Interface_Attach<ITfContext> ic(GetInputContext());
        m_pTextEventSink->_Advise(ic.GetPtr(), ICF_TEXTDELTA);
    }

    //
    // Create Thread Manager Event Sink Callback
    //
    if (m_pThreadMgrEventSink == NULL) {
        m_pThreadMgrEventSink = new CThreadMgrEventSinkCallBack();
        if (m_pThreadMgrEventSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pThreadMgrEventSink->SetCallbackDataPointer(m_pThreadMgrEventSink);
        m_pThreadMgrEventSink->_Advise(ptls->tim);
    }

    //
    // Create Compartment Event Sink Callback
    //
    if (m_pCompartmentEventSink == NULL) {
        m_pCompartmentEventSink = new CCompartmentEventSinkCallBack(m_pImmIfIME);
        if (m_pCompartmentEventSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pCompartmentEventSink->SetCallbackDataPointer(m_pCompartmentEventSink);
        m_pCompartmentEventSink->_Advise(ptls->tim, GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, FALSE);
        m_pCompartmentEventSink->_Advise(ptls->tim, GUID_COMPARTMENT_KORIMX_CONVMODE, FALSE);
    }

    //
    // Create Start reconversion notify Sink
    //
    if (m_pStartReconvSink == NULL) {
        m_pStartReconvSink = new CStartReconversionNotifySink(this);
        if (m_pStartReconvSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pStartReconvSink->_Advise(m_pic);
    }

    //
    // Create Message Buffer
    //
    if (m_pMessageBuffer == NULL) {
        m_pMessageBuffer = new CFirstInFirstOut<TRANSMSG, TRANSMSG>;
        if (m_pMessageBuffer == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
    }

    //
    // Create Editing Key List.
    //
    if (m_pEditingKeyList == NULL) {
        m_pEditingKeyList = new CMap<UINT, UINT, UINT, UINT>;
        if (m_pEditingKeyList == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
    }

    //
    // Set up Editing key list.
    //
    LANGID langid;
    hr = ptls->pAImeProfile->GetLangId(&langid);
    if (FAILED(hr))
        langid = LANG_NEUTRAL;

    SetupEditingKeyList(langid);

    return hr;
}

HRESULT
CAImeContext::DestroyAImeContext(
    HIMC hIMC
    )
{
    ITfSourceSingle *pSourceSingle;

    if (hIMC != m_hImc)
        return E_FAIL;
    else if (m_hImc == NULL)
        return S_OK;

    IMTLS *ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(hIMC);
    HRESULT hr;
    if (FAILED(hr=imc.GetResult()))
        return hr;

    if (m_pic && m_pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
    {
        pSourceSingle->UnadviseSingleSink(GetClientId(), IID_ITfCleanupContextSink);
        pSourceSingle->Release();
    }

    if (m_pImmIfIME)
    {
        m_pImmIfIME->Release();
        m_pImmIfIME = NULL;
    }

    if (m_pMessageBuffer) {
        delete m_pMessageBuffer;
        m_pMessageBuffer = NULL;
    }

    if (m_pEditingKeyList) {
        delete m_pEditingKeyList;
        m_pEditingKeyList = NULL;
    }

    if (m_pTextEventSink) {
        m_pTextEventSink->_Unadvise();
        m_pTextEventSink->Release();
        m_pTextEventSink = NULL;
    }

    if (m_pThreadMgrEventSink) {
        m_pThreadMgrEventSink->_Unadvise();
        m_pThreadMgrEventSink->Release();
        m_pThreadMgrEventSink = NULL;
    }

    if (m_pCompartmentEventSink) {
        m_pCompartmentEventSink->_Unadvise();
        m_pCompartmentEventSink->Release();
        m_pCompartmentEventSink = NULL;
    }

    if (m_pStartReconvSink) {
        m_pStartReconvSink->_Unadvise();
        m_pStartReconvSink->Release();
        m_pStartReconvSink = NULL;
    }


    if (m_pic) {
        m_pic->Release();
        m_pic = NULL;
    }

    if (m_piccb) {
        m_piccb->Release();
        m_piccb = NULL;
    }

    ptls->m_fMyPushPop = TRUE;
    if (m_pdim)
    {
        hr = m_pdim->Pop(TF_POPF_ALL);
    }
    ptls->m_fMyPushPop = FALSE;


    // ic owner is auto unadvised during the Pop by cicero
    // in any case, it must not be unadvised before the pop
    // since it will be used to handle mouse sinks, etc.
    if (m_pICOwnerSink) {
        m_pICOwnerSink->_Unadvise();
        m_pICOwnerSink->Release();
        m_pICOwnerSink = NULL;
    }

    if (m_pdim)
    {
        m_pdim->Release();
        m_pdim = NULL;
    }

    return S_OK;
}


HRESULT
CAImeContext::UpdateAImeContext(
    HIMC hIMC
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    //
    // Update Editing key list.
    //
    LANGID langid;
    HRESULT hr = ptls->pAImeProfile->GetLangId(&langid);
    if (FAILED(hr))
        langid = LANG_NEUTRAL;

    if (m_pEditingKeyList)
    {
       m_pEditingKeyList->RemoveAll();    // Remove old Editing key list.

       SetupEditingKeyList(langid);
    }

    return S_OK;
}

#if 0
HRESULT
CAImeContext::AssociateFocus(
    HIMC hIMC,
    BOOL fActive
    )
{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    if (fActive) {
        AssocFocus(imc->hWnd, m_pdim);
    }
    else {
        AssocFocus(imc->hWnd, NULL);
    }

    return S_OK;
}
#endif

HRESULT
CAImeContext::MapAttributes(
    HIMC hIMC
    )
{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<COMPOSITIONSTRING_AIMM12> comp(imc->hCompStr);
    if (FAILED(hr = comp.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    if (_pAImeContext->usGuidMapSize == 0) {
        //
        // Make transration table.
        //
        _pAImeContext->usGuidMapSize = ATTR_LAYER_GUID_START;

        for (USHORT i = 0; i < comp->dwTfGuidAtomLen; ++i) {
            // Check if this GUID is already registered
            for (USHORT j = ATTR_LAYER_GUID_START; j < _pAImeContext->usGuidMapSize; ++j) {
                if (_pAImeContext->aGuidMap[j] == ((TfGuidAtom*)comp.GetOffsetPointer(comp->dwTfGuidAtomOffset))[i]) {
                    break;
                }
            }

            BYTE bAttr;
            if (j >= _pAImeContext->usGuidMapSize) {
                // Couldn't find the GUID registered.
                if (_pAImeContext->usGuidMapSize < ARRAYSIZE(_pAImeContext->aGuidMap) - 1) {
                    bAttr = static_cast<BYTE>(_pAImeContext->usGuidMapSize);
                    _pAImeContext->aGuidMap[_pAImeContext->usGuidMapSize++] = ((TfGuidAtom*)comp.GetOffsetPointer(comp->dwTfGuidAtomOffset))[i];
                }
                else {
                    // # of GUID exceeds the # of available attribute...
                    // Maybe it should fail, but for now give it a bogus attirbute.
                    bAttr = ATTR_TARGET_CONVERTED;
                }
            }
            else {
                bAttr = static_cast<BYTE>(j);
            }

            ((BYTE*)comp.GetOffsetPointer(comp->dwGuidMapAttrOffset))[i] = bAttr;
        }

        comp->dwGuidMapAttrLen = comp->dwTfGuidAtomLen;
    }

    return S_OK;
}

HRESULT
CAImeContext::GetGuidAtom(HIMC hIMC, BYTE bAttr, TfGuidAtom* pGuidAtom)
{
    if (bAttr < ATTR_LAYER_GUID_START) {
        return E_INVALIDARG;
    }

    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult())) {
        return hr;
    }

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);
    if (_pAImeContext == NULL)
        return E_UNEXPECTED;

    if (bAttr < _pAImeContext->usGuidMapSize) {
        *pGuidAtom = _pAImeContext->aGuidMap[bAttr];
    }
    return S_OK;
}

#if 0
void
CAImeContext::AssocFocus(
    HWND hWnd,
    ITfDocumentMgr* pdim
    )
{
    if (! ::IsWindow(hWnd))
        /*
         * Return invalid hWnd.
         */
        return;

    rTIM _tim;

    ITfDocumentMgr  *pdimPrev; // just to receive prev for now
    _tim->AssociateFocus(hWnd, pdim, &pdimPrev);
    if (pdimPrev)
        pdimPrev->Release();
}
#endif

UINT
CAImeContext::TranslateImeMessage(
    HIMC hIMC,
    TRANSMSGLIST* lpTransMsgList
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    IMCLock imc(hIMC);
    HRESULT hr;
    if (FAILED(hr=imc.GetResult()))
        return hr;

    if (m_pMessageBuffer == NULL)
        return 0;

    INT_PTR NumMsg = m_pMessageBuffer->GetSize();
    if (NumMsg == 0)
        return 0;

    UINT retNumMsg = 0;

    if (lpTransMsgList && NumMsg < (INT_PTR)lpTransMsgList->uMsgCount) {
        LPTRANSMSG lpTransMsg = &lpTransMsgList->TransMsg[0];
        while (NumMsg--) {
            if (! m_pMessageBuffer->GetData(*lpTransMsg++))
                break;
            retNumMsg++;
        }
    }
    else {
        if (imc->hMsgBuf == NULL) {
            imc->hMsgBuf = ImmCreateIMCC(ptls, (DWORD)(NumMsg * sizeof(TRANSMSG)));
        }
        else if (ImmGetIMCCSize(ptls, imc->hMsgBuf) < NumMsg * sizeof(TRANSMSG)) {
            imc->hMsgBuf = ImmReSizeIMCC(ptls, imc->hMsgBuf, (DWORD)(NumMsg * sizeof(TRANSMSG)));
        }

        imc->dwNumMsgBuf = 0;

        IMCCLock<TRANSMSG> pdw(imc->hMsgBuf);
        if (pdw.Valid()) {
            LPTRANSMSG lpTransMsg = pdw;
            while (NumMsg--) {
                if (! m_pMessageBuffer->GetData(*lpTransMsg++))
                    break;
                retNumMsg++;
            }
            imc->dwNumMsgBuf = retNumMsg;
        }
    }

    return retNumMsg;
}


LPCTSTR REG_MSIMTF_KEY = TEXT("SOFTWARE\\Microsoft\\CTF\\MSIMTF\\");
LPCTSTR REG_EDITING_VAL = TEXT("Editing VK");

HRESULT
CAImeContext::SetupEditingKeyList(
    LANGID LangId
    )
{
    //
    // Setup user defines finalize key from registry value
    //
    TCHAR     MsImtfKey[128];
    lstrcpy(MsImtfKey, REG_MSIMTF_KEY);
    _itoa(LangId, MsImtfKey + lstrlen(MsImtfKey), 16);

    CRegKey   MsimtfReg;
    LONG      lRet;
    lRet = MsimtfReg.Open(HKEY_CURRENT_USER, MsImtfKey);
    if (lRet == ERROR_SUCCESS) {
        QueryRegKeyValue(MsimtfReg, REG_EDITING_VAL, EDIT_ID_FINALIZE);
    }

    //
    // Setup default editing key from resource data (RCDATA)
    //
    QueryResourceDataValue(LangId, ID_EDITING, EDIT_ID_FINALIZE);
    QueryResourceDataValue(LangId, ID_EDITING, EDIT_ID_HANJA);

    return S_OK;
}

LRESULT
CAImeContext::MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, HIMC hIMC)
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return IMEMOUSERET_NOTHANDLED;

    LRESULT ret = m_pICOwnerSink->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc,
                                                    m_pImmIfIME);

    if (dwBtnStatus & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) {
        m_pImmIfIME->_UpdateCompositionString();
    }

    return ret;
}

HRESULT CAImeContext::SetupReconvertString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->SetupReconvertString(m_pic, imc);
}

HRESULT CAImeContext::SetupReconvertString(UINT uPrivMsg)
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->SetupReconvertString(m_pic, imc, uPrivMsg);
}

HRESULT CAImeContext::EndReconvertString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->EndReconvertString(imc);
}

HRESULT CAImeContext::SetupUndoCompositionString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->SetupReconvertString(m_pic, imc, 0); /* 0 == Don't need ITfFnReconvert */
}

HRESULT CAImeContext::EndUndoCompositionString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->EndReconvertString(imc);
}

HRESULT
CAImeContext::SetReconvertEditSession(
    BOOL bSet
    )
{
    m_fInReconvertEditSession = (bSet ? TRUE : FALSE);
    return S_OK;
}

HRESULT
CAImeContext::SetClearDocFeedEditSession(
    BOOL bSet
    )
{
    m_fInClearDocFeedEditSession = (bSet ? TRUE : FALSE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnCleanupContext
//
//----------------------------------------------------------------------------

HRESULT CAImeContext::OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic)
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (ptls->pAImeProfile == NULL)
        return E_FAIL;

    LANGID LangId;
    HRESULT hr = ptls->pAImeProfile->GetLangId(&LangId);
    if (FAILED(hr))
        LangId = LANG_NEUTRAL;

    //
    // Check IME_PROP_COMPLETE_ON_UNSELECT property on current language property
    //
    DWORD fdwProperty, fdwConversionCaps, fdwSentenceCaps, fdwSCSCaps, fdwUICaps;
    CLanguageCountry language(LangId);
    hr = language.GetProperty(&fdwProperty,
                              &fdwConversionCaps,
                              &fdwSentenceCaps,
                              &fdwSCSCaps,
                              &fdwUICaps);

    if (fdwProperty & IME_PROP_COMPLETE_ON_UNSELECT)
    {
#if 0
        ImmIfCompositionComplete *pImmIfCallBack = new ImmIfCompositionComplete;
        if (!pImmIfCallBack)
            return E_OUTOFMEMORY;

        pImmIfCallBack->CompComplete(ecWrite, m_hImc, FALSE, pic, m_pImmIfIME);

        delete pImmIfCallBack;
#else
        //
        // Remove GUID_PROP_COMPOSING
        //
        ITfRange *rangeFull = NULL;
        ITfProperty *prop;
        ITfRange *rangeTmp;
        if (SUCCEEDED(pic->GetProperty(GUID_PROP_COMPOSING, &prop)))
        {
            IEnumTfRanges *enumranges;
            if (SUCCEEDED(prop->EnumRanges(ecWrite, &enumranges, rangeFull)))
            {
                while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
                {
                    VARIANT var;
                    QuickVariantInit(&var);
                    prop->GetValue(ecWrite, rangeTmp, &var);
                    if ((var.vt == VT_I4) && (var.lVal != 0))
                    {
                        prop->Clear(ecWrite, rangeTmp);
                    }
                    rangeTmp->Release();
                }
                enumranges->Release();
            }
            prop->Release();
        }
#endif
    }
    return S_OK;
}

HRESULT CAImeContext::OnStartComposition(ITfCompositionView *pComposition, BOOL *pfOk)
{
    if (_cCompositions > 0 && !_fModifyingDoc)
    {
        *pfOk = FALSE;
    }
    else
    {
        *pfOk = TRUE;
        _cCompositions++;
    }

    return S_OK;
}

HRESULT CAImeContext::OnUpdateComposition(ITfCompositionView *pComposition, ITfRange *pRangeNew)
{
    return S_OK;
}

HRESULT CAImeContext::OnEndComposition(ITfCompositionView *pComposition)
{
    _cCompositions--;
    return S_OK;
}

HRESULT
CAImeContext::GetTextAndAttribute(
    HIMC hIMC,
    CWCompString* wCompString,
    CWCompAttribute* wCompAttribute
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetTextAndAttribute(imc, wCompString, wCompAttribute);
}

HRESULT
CAImeContext::GetTextAndAttribute(
    HIMC hIMC,
    CBCompString* bCompString,
    CBCompAttribute* bCompAttribute
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetTextAndAttribute(imc, bCompString, bCompAttribute);
}

HRESULT
CAImeContext::GetCursorPosition(
    HIMC hIMC,
    CWCompCursorPos* wCursorPosition
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetCursorPosition(imc, wCursorPosition);
}

HRESULT
CAImeContext::GetSelection(
    HIMC hIMC,
    CWCompCursorPos& wStartSelection,
    CWCompCursorPos& wEndSelection
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetSelection(imc, wStartSelection, wEndSelection);
}

HRESULT
CAImeContext::InquireIMECharPosition(
    HIMC hIMC,
    IME_QUERY_POS* pfQueryPos
    )
{
    if (m_fQueryPos == IME_QUERY_POS_UNKNOWN) {
        //
        // Is apps support "query positioning" ?
        //
        IMECHARPOSITION ip = {0};
        ip.dwSize = sizeof(IMECHARPOSITION);

        m_fQueryPos = QueryCharPos(hIMC, &ip) ? IME_QUERY_POS_YES : IME_QUERY_POS_NO;
    }

    if (pfQueryPos) {
        *pfQueryPos = m_fQueryPos;
    }

    return S_OK;
}

HRESULT
CAImeContext::RetrieveIMECharPosition(
    HIMC hIMC,
    IMECHARPOSITION* ip
    )
{
    return QueryCharPos(hIMC, ip) ? S_OK : E_FAIL;
}

BOOL
CAImeContext::QueryCharPos(
    HIMC hIMC,
    IMECHARPOSITION* position
    )
{
    IMTLS *ptls;

    ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return FALSE;

    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return FALSE;

    LRESULT lRet;

    //
    // First Step. Query by local method.
    //
    lRet = ::SendMessage(imc->hWnd,
                         WM_MSIME_QUERYPOSITION,
                         VERSION_QUERYPOSITION,
                         (LPARAM)position);
    if (lRet) {
        return TRUE;
    }

    //
    // Second Step. Query by IMM method.
    //
    if (IsOnNT5() || IsOn98()) {
        if (SUCCEEDED(ptls->pAImm->RequestMessageW((HIMC)imc,
                                                   IMR_QUERYCHARPOSITION,
                                                   (LPARAM)position,
                                                   &lRet)) && lRet) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_server.cpp ===
#include "private.h"

#include "globals.h"
#include "immif.h"

const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_PROPSTYLE_STATICCOMPACT, &GUID_PROP_MSIMTF_READONLY},
    {&GUID_TFCAT_PROPSTYLE_STATIC, &GUID_PROP_MSIMTF_TRACKCOMPOSITION},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM, &GUID_PROP_MSIMTF_PREPARE_RECONVERT},
    {NULL, NULL}
};

HRESULT WIN32LR_DllRegisterServer(void)
{
    TRACE0("DllRegisterServer.");

    HRESULT hr;

    hr = RegisterCategories(CLSID_CActiveIMM12, c_rgRegCat);
    if (FAILED(hr)) {
        TRACE0("RegisterCategory: f3");
        goto Exit;
    }

Exit:

    TRACE1("DllRegisterServer: returning with hr=0x%x", hr);
    return hr;
}

HRESULT WIN32LR_DllUnregisterServer(void)
{
    TRACE0("DllUnregisterServer");

    HRESULT hr;

    hr = UnregisterCategories(CLSID_CActiveIMM12, c_rgRegCat);
    if (FAILED(hr)) {
        TRACE0("RegisterCategory: f3");
        goto Exit;
    }

Exit:

    TRACE1("DllUnregisterServer: hr=%x", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_comp.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_comp.cpp

Abstract:

    This file implements the ImmIfIME Class's key handling routine and make an edit session.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "immif.h"
#include "template.h"
#include "editses.h"
#include "resource.h"




inline
BOOL
ImmIfIME::_WantThisKey(
    IMCLock& imc,
    UINT uVKey,
    BOOL* pfNextHook     // default value is NULL
    )

/*+++

Routine Description:

    Check essential virtual key code for the win32 layer's key handling routine.

Arguments:

    uVKey - [in] Unsigned integer value that virtual key code.
    pfNextHool - [out] Address of bool that flag for next hook.
                       Specifies TRUE,  dimm12!CCiceroIME::KeyboardHook calls CallNextHookEx.
                       Specifies FALSE, dimm12!CCiceroIME::KeyboardHook doesn't call CallNextHookEx.
                                        This means this key code eaten by dimm.

Return Value:

    Returns true if essential vkey, or false unessential.

---*/

{
    LANGID langid;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (pfNextHook != NULL)
        *pfNextHook = FALSE;

    if (ptls == NULL)
        return false;

    ptls->pAImeProfile->GetLangId(&langid);
    if (PRIMARYLANGID(langid) == LANG_KOREAN)
        return false;

    //
    // Finalize the composition string
    // Cancel the composition string
    //
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);
    if (_pAImeContext == NULL)
        return false;

    if (!_pAImeContext->IsTopNow())
        return false;

    if (_pAImeContext->IsVKeyInKeyList(uVKey) ||
        BYTE(uVKey) == VK_BACK ||
        BYTE(uVKey) == VK_DELETE ||
        BYTE(uVKey) == VK_LEFT ||
        BYTE(uVKey) == VK_RIGHT)
    {
        /*
         * If we don't have a composition string, then we should calls next hook.
         */
        if (! _pAImeContext->m_fStartComposition) {
            if (pfNextHook != NULL &&
                (_pAImeContext->IsVKeyInKeyList(uVKey, EDIT_ID_HANJA) ||
                 BYTE(uVKey) == VK_LEFT ||
                 BYTE(uVKey) == VK_RIGHT) ) {
                *pfNextHook = TRUE;
            }
            return false;
        }

        return true;
    }

    return false;
}

STDAPI
ImmIfIME::ProcessKey(
    HIMC hIMC,
    UINT uVKey,
    DWORD lKeyData,
    LPBYTE lpbKeyState
    )

/*++

Method:

    IActiveIME::ProcessKey

Routine Description:

    Preprocesses all the keystrokes given through the Active Input Method Manager.

Arguments:

    hIMC - [in] Handle to the input context.
    uVKey - [in] Unsigned integer value that specifies the virtual key to be processed.
    lKeyData - [in] Unsigned long integer value that specifies additional message information.
                    This is the repeat count, scan code, extended-key flag, context code,
                    previous key-state flag, and transition-state flag.
                        0-15 : Specifies the repeat count.
                       16-23 : Specifies the scan code.
                          24 : Specifies whether the key is an extended key.
                       25-28 : Reserved.
                          29 : Specifies the context code.
                          30 : Specifies the previous key state.
                          31 : Specifies the transition state.
    lpbKeyState - [in] Address of a 256-byte array that contains the current keyboard state.
                       The Active Input Method Editor should not modify the content of the key
                       state.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    BOOL fEaten;
    BOOL fKeysEnabled;
    HRESULT hr;

    // has anyone disabled system key feeding?
    if (m_tim->IsKeystrokeFeedEnabled(&fKeysEnabled) == S_OK && !fKeysEnabled)
        return S_FALSE;

    if (HIWORD(lKeyData) & KF_UP)
        hr = m_pkm->TestKeyUp(uVKey, lKeyData, &fEaten);
    else
        hr = m_pkm->TestKeyDown(uVKey, lKeyData, &fEaten);

    if (hr == S_OK && fEaten) {
        return S_OK;
    }

    if (!fEaten)
    {
        IMCLock imc(hIMC);
        if (SUCCEEDED(hr=imc.GetResult()))
        {
           if (imc->m_pAImeContext)
               m_tim->RequestPostponedLock(imc->m_pAImeContext->GetInputContext());
        }
    }


    if ((HIWORD(lKeyData) & KF_UP) ||
        (HIWORD(lKeyData) & KF_ALTDOWN)) {
        return S_FALSE;
    }

    if (! (HIWORD(lKeyData) & KF_UP)) {
        if (_WantThisKey(hIMC, uVKey)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


HRESULT
ImmIfIME::ToAsciiEx(
    UINT uVirKey,
    UINT uScanCode,
    BYTE *pbKeyState,
    UINT fuState,
    HIMC hIMC,
    DWORD* pdwTransBuf,
    UINT *puSize
    )

/*++

Method:

    IActiveIME::ToAsciiEx

Routine Description:

    Generates a conversion result through the Active Input Method Editor (IME) conversion
    engine according to the hIMC parameter.

Arguments:

    uVirKey - [in] Unsigned integer value that specifies the virtual key code to be translated.
                   // HIWORD(uVirKey) : if IME_PROP_KBD_CHAR_FIRST property,
                                        then hiword is translated char code of VKey.
                   // LOWORD(uVirKey) : Virtual Key code.
    uScanCode - [in] Unsigned integer value that specifies the hardware scan code of the key to
                     be translated.
    pbKeyState - [in] Address of a 256-byte array that contains the current keyboard state.
                      The Active IME should not modify the content of the key state.
    fuState - [in] Unsigned integer value that specifies the active menu flag.
    hIMC - [in] Handle to the input context.
    pdwTransBuf - [out] Address of an unsigned long integer value that receives the translated
                        result.
    puSize - [out] Address of an unsigned integer value that receives the number of messages.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return ToAsciiEx(uVirKey,
                     uScanCode,
                     pbKeyState,
                     fuState,
                     hIMC,
                     (TRANSMSGLIST*)pdwTransBuf,
                     puSize);
}

HRESULT
ImmIfIME::ToAsciiEx(
    UINT uVirKey,
    UINT uScanCode,
    BYTE *pbKeyState,
    UINT fuState,
    HIMC hImc,
    TRANSMSGLIST *pdwTransBuf,
    UINT *puSize
    )
{
    *puSize = 0;
    return _ToAsciiEx(hImc, uVirKey, uScanCode,
                      pdwTransBuf, puSize);
}


HRESULT
ImmIfIME::_ToAsciiEx(
    HIMC hImc,
    UINT uVKey,
    UINT uScanCode,
    TRANSMSGLIST *pdwTransBuf,
    UINT *puSize
    )

/*+++

Arguments:

    uVKey - [in] Unsigned integer value that specifies the virtual key code to be translated.
                 // HIWORD(uVirKey) : if IME_PROP_KBD_CHAR_FIRST property,
                                      then hiword is translated char code of VKey.
                 // LOWORD(uVirKey) : Virtual Key code.

Return Value:

    Returns S_FALSE, dimm12!CCiceroIME::KeyboardHook calls CallNextHookEx.
    Returns S_OK,    dimm12!CCiceroIME::KeyboardHook doesn't call CallNextHookEx.
                     This means this key code eaten by dimm.

---*/

{
    BOOL fEaten;
    HRESULT hr;

    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);
    if (! _pAImeContext)
        return S_FALSE;

    //
    // Backup the m_fOpenCandidateWindow flag.
    // If open the candidate list and press "Cancel" key, Kana TIP would want to
    // close candidate UI window in the KeyDown() action.
    // Candidate UI calss maybe call m_pdim->Pop() and this function notify to
    // the ThreadMgrEventSinkCallback.
    // Win32 layer advised this callback and toggled m_fOpenCandidateWindow flag.
    // Win32 layer doesn't know candidate status after KeyDown() call.
    //
    BOOL fOpenCandidateWindow = _pAImeContext->m_fOpenCandidateWindow;

    //
    // If candidate window were open, send IMN_CHANGECANDIDATE message.
    // In the case of PPT's centering composition string, it expect IMN_CHANGECANDIDATE.
    //
    if (fOpenCandidateWindow &&
        *puSize < pdwTransBuf->uMsgCount) {
        TRANSMSG* pTransMsg = &pdwTransBuf->TransMsg[*puSize];
        pTransMsg->message = WM_IME_NOTIFY;
        pTransMsg->wParam  = IMN_CHANGECANDIDATE;
        pTransMsg->lParam  = 1;  // bit 0 to first candidate list.
        (*puSize)++;
    }

    //
    // AIMM put char code in hiword. So we need to bail it out.
    //
    // if we don't need charcode, we may want to 
    // remove IME_PROP_KBD_CHAR_FIRST.
    //
    uVKey = uVKey & 0xffff;

#ifdef CICERO_3564
    if ((uVKey == VK_PROCESSKEY) &&
        _pAImeContext->m_fStartComposition)
    {
        /*
         * KOREAN:
         *  Finalize current composition string
         */
        IMTLS *ptls = IMTLS_GetOrAlloc();
        if (ptls == NULL)
            return S_FALSE;
        if (ptls->pAImeProfile == NULL)
            return S_FALSE;

        LANGID langid;
        ptls->pAImeProfile->GetLangId(&langid);
        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            //
            // Composition complete.
            //
            _CompComplete(imc, FALSE);    // ASYNC
            return S_OK;
        }
    }
#endif // CICERO_3564

    //
    // consider: dimm12 set high bit oflower WORD at keyup.
    //
    if (uScanCode & KF_UP)
        hr = m_pkm->KeyUp(uVKey, (uScanCode << 16), &fEaten);
    else
        hr = m_pkm->KeyDown(uVKey, (uScanCode << 16), &fEaten);

    if (hr == S_OK && fEaten) {
        return S_OK;
#if 0
        // We don't need EDIT_ID_FINALIZE anymore
        // since AIMM1.2 detect composition object by GUID_PROP_COMPOSING 

        //
        // If press the Enter key, AIMM layer finalize composition string.
        // or
        // If press the Escape key, AIMM layer cancel composition string.
        //
        if (! _pAImeContext->IsVKeyInKeyList(uVKey))
            //
            // Neither Finalize nor Cancel this key eaten.
            //
            return S_OK;
        else if (fOpenCandidateWindow)
            //
            // If candidate list opend, we don't want finalize a string.
            //
            return S_OK;
#endif
    }


    //
    // we want to process all events that were requested by pAimeContext
    // during KeyDwon() or KeyUp, if TIP did not eat the key.
    //
    // This can keep WM_IME_COMPOSITION/WM_IME_ENDCOMPOSITION message
    // order.
    //
    if (!fEaten)
        m_tim->RequestPostponedLock(_pAImeContext->GetInputContext());

    if (!(HIWORD(uScanCode) & KF_UP)) {
        BOOL fNextHook;
        if (_WantThisKey(imc, uVKey, &fNextHook)) {
            _HandleThisKey(imc, uVKey);
        }
        hr = fNextHook ? S_FALSE    // Call next hook
                       : S_OK;      // Stop next hook
    }

    return hr;
}



HRESULT
ImmIfIME::_HandleThisKey(
    IMCLock& imc,
    UINT uVKey
    )

/*+++

Routine Description:

    Handle the virtual key in the edit session.

Arguments:

---*/

{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_HANDLETHISKEY,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                        uVKey);
}







HRESULT
ImmIfIME::_CompCancel(
    IMCLock& imc
    )

/*+++

Routine Description:

    Cancel the composition string in the hIMC.

Arguments:

---*/

{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_COMPCANCEL,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC);
}




HRESULT
ImmIfIME::_CompComplete(
    IMCLock& imc,
    BOOL fSync        // defalut value is TRUE
    )

/*+++

Routine Description:

    Complete the composition string in the hIMC.

Arguments:

    fSync - [in] TRUE,  Create synchronized edit session.
                 FALSE, Create ansynchronized edit session.

---*/

{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_COMPCOMPLETE,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0), fSync == TRUE);
}




HRESULT
ImmIfIME::Internal_SetCompositionString(
    CWCompString& wCompStr,
    CWCompString& wCompReadStr
    )
{
    HRESULT hr;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_REPLACEWHOLETEXT,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                      &wCompStr);
    if (FAILED(hr))
        return hr;

    return _UpdateCompositionString();
}


//
// Get all text and attribute from TOM and update the composition
// string.
//
HRESULT
ImmIfIME::_UpdateCompositionString(
    DWORD dwDeltaStart
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();
    HRESULT hr;

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_UPDATECOMPOSITIONSTRING,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)

    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    //
    // This method should not set synchronize mode becuase the edit session call back routine
    // modify a text in the input context.
    //
    return _pEditSession->RequestEditSession(TF_ES_READWRITE,
                                        (UINT)dwDeltaStart);
}





//
// Internal Reconvert String
//
HRESULT
ImmIfIME::Internal_ReconvertString(
    IMCLock& imc,
    CWReconvertString& wReconvStr,
    CWReconvertString& wReconvReadStr
    )
{
    HRESULT hr;
    Interface<ITfRange> Selection;
    Interface<ITfFunctionProvider> FuncProv;
    Interface<ITfFnReconversion> Reconversion;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_RECONVERTSTRING,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    _pAImeContext->SetReconvertEditSession(TRUE);

    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                      &wReconvStr, &Selection, FALSE);
    if (FAILED(hr))
        goto Exit;

    hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
    if (FAILED(hr))
        goto Exit;

    hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
    if (SUCCEEDED(hr)) {
        Interface<ITfRange> RangeNew;
        BOOL fConvertable;
        hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
        if (SUCCEEDED(hr) && fConvertable) {
            hr = Reconversion->Reconvert(RangeNew);
        }
        else {
            DebugMsg(TF_ERROR, "Internal__ReconvertString: QueryRange failed so the compoisiton string will be completed.");
            _CompComplete(imc, TRUE);
            hr = E_FAIL;
        }
    }

Exit:
    _pAImeContext->SetReconvertEditSession(FALSE);
    return hr;
}

// static
HRESULT
ImmIfIME::Internal_QueryReconvertString_ICOwnerSink(
    UINT uCode,
    ICOARGS *pargs,
    VOID *pv
    )
{
    switch (uCode)
    {
        case ICO_STATUS:
            pargs->status.pdcs->dwDynamicFlags = 0;
            pargs->status.pdcs->dwStaticFlags = TF_SS_TRANSITORY;
            break;
    }

    return S_OK;
}

//
// Internal Query Reconvert String
//
HRESULT
ImmIfIME::Internal_QueryReconvertString(
    IMCLock& imc,
    RECONVERTSTRING *pReconv,
    UINT cp,
    BOOL fNeedAW
    )
{
    HRESULT hr;

    CWReconvertString wReconvStr(cp, 
                                 imc, 
                                 !fNeedAW ? pReconv : NULL, 
                                 !fNeedAW ? pReconv->dwSize : 0);
    if (fNeedAW)
    {
        //
        // convert Ansi to Unicode.
        //
        CBReconvertString bReconvStr(cp, imc, pReconv, pReconv->dwSize);
        wReconvStr = bReconvStr;
    }

    IMTLS *ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    //
    // Create document manager.
    //
    Interface<ITfDocumentMgr> pdim;           // Document Manager
    if (FAILED(hr = m_tim->CreateDocumentMgr(pdim)))
        return hr;

    //
    // Create input context
    //
    Interface<ITfContext> pic;                // Input Context
    TfEditCookie ecTmp;
    hr = pdim->CreateContext(m_tfClientId, 0, NULL, pic, &ecTmp);
    if (FAILED(hr))
        return hr;

    //
    // Create Input Context Owner Callback
    //
    CInputContextOwner *_pICOwnerSink;          // IC owner call back

    _pICOwnerSink = new CInputContextOwner(Internal_QueryReconvertString_ICOwnerSink, NULL);
    if (_pICOwnerSink == NULL) {
        DebugMsg(TF_ERROR, "Couldn't create ICOwnerSink tim!");
        Assert(0); // couldn't activate thread!
        return E_FAIL;
    }

    //
    // Advise IC.
    //
    _pICOwnerSink->_Advise(pic);

    //
    // Push IC.
    //
    ptls->m_fMyPushPop = TRUE;
    hr = pdim->Push(pic);
    ptls->m_fMyPushPop = FALSE;
    if (SUCCEEDED(hr)) {

        Interface<ITfDocumentMgr> priv_dim;
        if (SUCCEEDED(hr=m_tim->GetFocus(priv_dim)) &&
            SUCCEEDED(hr=m_tim->SetFocus(pdim)))
        {

            Interface_Attach<ITfContext> _pic(pic);
            Interface_Creator<ImmIfEditSession> _pEditSessionQueryConvertString(
                new ImmIfEditSession(ESCB_QUERYRECONVERTSTRING,
                                     m_tfClientId,
                                     GetCurrentInterface(),
                                     imc,
                                     _pic)
            );
            if (_pEditSessionQueryConvertString.Invalid()) {
                hr = E_FAIL;
            }
            else {

                Interface<ITfRange> Selection;
                hr = _pEditSessionQueryConvertString->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                                  &wReconvStr, &Selection, FALSE);

                if (S_OK == hr)
                {
                    Interface<ITfFunctionProvider> FuncProv;
                    Interface<ITfFnReconversion> Reconversion;
                    hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
                    if (S_OK == hr)
                    {
                        hr = FuncProv->GetFunction(GUID_NULL,
                                       IID_ITfFnReconversion,
                                       (IUnknown**)(ITfFnReconversion**)Reconversion);
                    }
                    if (S_OK == hr) {
                        Interface<ITfRange> RangeNew;
                        BOOL fConvertable;
                        hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                        if (SUCCEEDED(hr) && fConvertable) {
                            //
                            // Calcurate start position of RangeNew on text store
                            //
                            Interface_Creator<ImmIfEditSession> _pEditSession(
                                new ImmIfEditSession(ESCB_CALCRANGEPOS,
                                                     m_tfClientId,
                                                     GetCurrentInterface(),
                                                     imc,
                                                     _pic)
                            );
                            if (_pEditSession.Valid()) {
                                hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                                                  &wReconvStr, &RangeNew, FALSE);
                            }
                            else {
                                hr = E_FAIL;
                            }
                        }
                        else {
                            hr = E_FAIL;
                        }
                    }
                }
            }
        }

        if (S_OK == hr)
        {
            if (fNeedAW) {
                //
                // Back to convert Unicode to Ansi.
                //
                CBReconvertString bReconvStr(cp, imc, NULL, 0);
                bReconvStr = wReconvStr;

                bReconvStr.ReadCompData(pReconv, pReconv->dwSize);
            }
            else {
                wReconvStr.ReadCompData(pReconv, pReconv->dwSize);
            }
        }

        m_tim->SetFocus(priv_dim);

        m_tim->RequestPostponedLock(pic);
        if (imc->m_pAImeContext)
            m_tim->RequestPostponedLock(imc->m_pAImeContext->GetInputContext());

        ptls->m_fMyPushPop = TRUE;
        pdim->Pop(TF_POPF_ALL);
        ptls->m_fMyPushPop = FALSE;
    }

    // ic owner is auto unadvised during the Pop by cicero
    // in any case, it must not be unadvised before the pop
    // since it will be used to handle mouse sinks, etc.
    if (_pICOwnerSink) {
        _pICOwnerSink->_Unadvise();
        _pICOwnerSink->Release();
        _pICOwnerSink = NULL;
    }

    return hr;
}




//
// Setup reconversion string
//
// This function called from
//   1. CFnDocFeed::StartReconvert
//   2. CStartReconversionNotifySink::StartReconversion
//   3. CIMEUIWindowHandler::ImeUIMsImeHandler(WM_MSIME_RECONVERTREQUEST)
//
// If Cicero's text store were not cleared, then compositioning and unessential query
// RECONVERTSTRING to apprication. Also edit session (ImmIfReconvertString::ReconvertString)
// doesn't set RECONVERTSTRING text string to hIMC's text store.
//

HRESULT 
ImmIfIME::SetupReconvertString(
    ITfContext *pic,
    IMCLock& imc,
    UINT  uPrivMsg        // is WM_MSIME_RECONVERTREQUEST or 0
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    _pAImeContext->SetReconvertEditSession(TRUE);

    if (_pAImeContext->m_fStartComposition)
        return _ReconvertStringTextStore(pic, imc, uPrivMsg);
    else
        return _ReconvertStringNegotiation(pic, imc, uPrivMsg);
}

//
// End reconversion string
//
HRESULT 
ImmIfIME::EndReconvertString(
    IMCLock& imc
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    _pAImeContext->SetReconvertEditSession(FALSE);
    return S_OK;
}

HRESULT
ImmIfIME::_ReconvertStringNegotiation(
    ITfContext *pic,
    IMCLock& imc,
    UINT  uPrivMsg
    )
{
    RECONVERTSTRING *pReconv = NULL;
    HRESULT hr = E_FAIL;
    int nSize;

    UINT uReconvMsg = uPrivMsg != 0 ? uPrivMsg : WM_IME_REQUEST;

    Assert(IsWindow(imc->hWnd));

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    nSize = (int)SendMessage(imc->hWnd,  uReconvMsg, IMR_RECONVERTSTRING, NULL);
    if (!nSize)
    {
        return S_OK;
    }

    pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
    if (!pReconv)
    {
        return E_OUTOFMEMORY;
    }

    pReconv->dwSize = nSize;

    if (SendMessage(imc->hWnd, uReconvMsg, IMR_RECONVERTSTRING, (LPARAM)pReconv) || (uPrivMsg != 0 && pReconv->dwCompStrLen > 0))
    {
        UINT cp = CP_ACP;
        GetCodePageA(&cp);

        //
        // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
        // Any string data doesn't convert between ASCII <--> Unicode.
        // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
        // If ASCII wnd proc, then returns ASCII string.
        // Otherwise if Unicode wnd proc, returns Unicode string.
        //
        BOOL fNeedAW = ( !(IsOnNT() && IsWindowUnicode(imc->hWnd)) && uPrivMsg == 0);

        //
        // backup RECOVNERTSTRING in case IMR_CONFIRMCONVERTSTRING fails.
        //
        RECONVERTSTRING rsBackUp;
        memcpy(&rsBackUp, pReconv, sizeof(RECONVERTSTRING));

        // AdjustZeroCompLenReconvertString(pReconv, cp, fNeedAW);
        hr = Internal_QueryReconvertString(imc, pReconv, cp, fNeedAW);
        if (FAILED(hr))
            goto Exit;

        if (!SendMessage(imc->hWnd, uReconvMsg, IMR_CONFIRMRECONVERTSTRING, (LPARAM)pReconv))
        {
            memcpy(pReconv, &rsBackUp, sizeof(RECONVERTSTRING));
        }

        Interface<ITfRange> Selection;


        CWReconvertString wReconvStr(cp, 
                                     imc, 
                                     !fNeedAW ? pReconv : NULL, 
                                     !fNeedAW ? nSize : 0);
        if (fNeedAW)
        {
            //
            // convert Ansi to Unicode.
            //
            CBReconvertString bReconvStr(cp, imc, pReconv, nSize);
            wReconvStr = bReconvStr;
        }

        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_RECONVERTSTRING,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Invalid())
        {
            hr = E_FAIL;
            goto Exit;
        }

        hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                          &wReconvStr, &Selection, FALSE);

        if (S_OK == hr && uPrivMsg != 0)
        {
            Interface<ITfFunctionProvider> FuncProv;
            Interface<ITfFnReconversion> Reconversion;
            hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
            if (S_OK == hr)
            {

                hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
            }
            if (S_OK == hr) {
                Interface<ITfRange> RangeNew;
                BOOL fConvertable;
                hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                if (SUCCEEDED(hr) && fConvertable) {
                    hr = Reconversion->Reconvert(RangeNew);
                }
                else {
                    _CompComplete(imc, TRUE);
                    hr = E_FAIL;
                    goto Exit;
                }
            }
        }
    }

Exit:
    if (pReconv)
        cicMemFree(pReconv);

    return hr;
}

HRESULT
ImmIfIME::_ReconvertStringTextStore(
    ITfContext *pic,
    IMCLock& imc,
    UINT  uPrivMsg
    )
{
    //
    // Clear DocFeed buffer
    //
    ClearDocFeedBuffer(pic, imc);

    if (uPrivMsg != 0) {
        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_GETSELECTION,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Invalid())
            return E_FAIL;

        Interface<ITfRange> Selection;
        HRESULT hr =  _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                                   &Selection);
        if (S_OK == hr)
        {
            Interface<ITfFunctionProvider> FuncProv;
            Interface<ITfFnReconversion> Reconversion;
            hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
            if (S_OK == hr)
            {
                hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
            }
            if (S_OK == hr) {
                Interface<ITfRange> RangeNew;
                BOOL fConvertable;
                hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                if (SUCCEEDED(hr) && fConvertable) {
                    hr = Reconversion->Reconvert(RangeNew);
                }
                else {
                    _CompComplete(imc, TRUE);
                    return E_FAIL;
                }
            }
        }
    }
    return S_OK;
}

//
// Setup docfeed string
//
HRESULT 
ImmIfIME::SetupDocFeedString(
    ITfContext *pic,
    IMCLock& imc)
{
    RECONVERTSTRING *pReconv = NULL;
    HRESULT hr = E_FAIL;
    int nSize;

    Assert(IsWindow(imc->hWnd));

    nSize = (int)SendMessage(imc->hWnd, WM_IME_REQUEST, IMR_DOCUMENTFEED, NULL);
    if (!nSize)
    {
        return S_OK;
    }

    pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
    if (!pReconv)
    {
        return E_OUTOFMEMORY;
    }

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    if (SendMessage(imc->hWnd, WM_IME_REQUEST, IMR_DOCUMENTFEED, (LPARAM)pReconv))
    {
        UINT cp = CP_ACP;
        GetCodePageA(&cp);
        Interface<ITfRange> Selection;

        //
        // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
        // Any string data doesn't convert between ASCII <--> Unicode.
        // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
        // If ASCII wnd proc, then returns ASCII string.
        // Otherwise if Unicode wnd proc, returns Unicode string.
        //
        BOOL fNeedAW = !(IsOnNT() && IsWindowUnicode(imc->hWnd));

        CWReconvertString wReconvStr(cp, 
                                     imc, 
                                     !fNeedAW ? pReconv : NULL, 
                                     !fNeedAW ? nSize : 0);
        if (fNeedAW)
        {
            //
            // convert Ansi to Unicode.
            //
            CBReconvertString bReconvStr(cp, imc, pReconv, nSize);
            wReconvStr = bReconvStr;
        }

        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_RECONVERTSTRING,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Invalid())
        {
            hr = E_FAIL;
            goto Exit;
        }

        hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                          &wReconvStr, &Selection, TRUE);

    }

Exit:
    if (pReconv)
        cicMemFree(pReconv);

    return S_OK;
}

//
// Setup docfeed string
//
HRESULT 
ImmIfIME::ClearDocFeedBuffer(
    ITfContext *pic,
    IMCLock& imc,
    BOOL fSync        // defalut value is TRUE
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_CLEARDOCFEEDBUFFER,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
    {
        goto Exit;
    }

    _pAImeContext->SetClearDocFeedEditSession(TRUE);
    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0));
    _pAImeContext->SetClearDocFeedEditSession(FALSE);

Exit:
    return hr;
}

//
// GetTextAndString Edit Session
//
HRESULT
ImmIfIME::GetTextAndAttribute(
    IMCLock& imc,
    CWCompString* wCompString,
    CWCompAttribute* wCompAttribute
    )
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETTEXTANDATTRIBUTE,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                      wCompString, wCompAttribute);
    return hr;
}

HRESULT
ImmIfIME::GetTextAndAttribute(
    IMCLock& imc,
    CBCompString* bCompString,
    CBCompAttribute* bCompAttribute
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    UINT cp;
    ptls->pAImeProfile->GetCodePageA(&cp);

    CWCompString wCompString(cp);
    CWCompAttribute wCompAttribute(cp);

    HRESULT hr = GetTextAndAttribute(imc,
                                     &wCompString, &wCompAttribute);
    if (SUCCEEDED(hr)) {
        //
        // Convert Unicode to ASCII.
        //
        LONG num_of_written = (LONG)wCompString.ReadCompData();
        WCHAR* buffer = new WCHAR[ num_of_written ];
        if (buffer != NULL) {
            wCompString.ReadCompData(buffer, num_of_written);

            wCompAttribute.m_wcompstr.WriteCompData(buffer, num_of_written);

            *bCompString = wCompString;
            *bCompAttribute = wCompAttribute;

            delete [] buffer;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//
// GetCursorPosition Edit Session
//
HRESULT
ImmIfIME::GetCursorPosition(
    IMCLock& imc,
    CWCompCursorPos* wCursorPosition
    )
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GET_CURSOR_POSITION,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                      wCursorPosition);
    return hr;
}


//
// GetSelection Edit Session
//
HRESULT
ImmIfIME::GetSelection(
    IMCLock& imc,
    CWCompCursorPos& wStartSelection,
    CWCompCursorPos& wEndSelection
    )
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETSELECTION,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    Interface<ITfRange> Selection;
    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                      &Selection);
    if (S_OK == hr) {
        //
        // Calcurate start position of RangeNew on text store
        //
        Interface_Creator<ImmIfEditSession> _pEditSession2(
            new ImmIfEditSession(ESCB_CALCRANGEPOS,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession2.Valid()) {
            UINT cp = CP_ACP;
            GetCodePageA(&cp);
            CWReconvertString wReconvStr(cp, imc);
            hr = _pEditSession2->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                               &wReconvStr, &Selection, FALSE);
            if (S_OK == hr) {
                wStartSelection.Set((DWORD) wReconvStr.m_CompStrIndex);
                wEndSelection.Set((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen));
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_context.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_context.h

Abstract:

    This file defines the CAImeContext Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#include "cime.h"
#include "icocb.h"
#include "txtevcb.h"
#include "tmgrevcb.h"
#include "cmpevcb.h"
#include "reconvcb.h"
#include "globals.h"
#include "template.h"
#include "atlbase.h"
#include "imeapp.h"

class ImmIfIME;
class CBReconvertString;
class CWCompString; class CBCompString;
class CWCompAttribute; class CBCompAttribute;
class CWCompCursorPos;

//
// The smallest value for bAttr to map to guidatom.
// We reserve the lower values for IMM32's IME. So there is no confilict.
//
const BYTE ATTR_LAYER_GUID_START  =  (ATTR_FIXEDCONVERTED + 1);

class CAImeContext : public IAImeContext,
                     public ITfCleanupContextSink,
                     public ITfContextOwnerCompositionSink
{
public:
    CAImeContext();
    virtual ~CAImeContext();

public:
    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IAImeContext methods
    //
    STDMETHODIMP CreateAImeContext(HIMC hIMC, IActiveIME_Private* pActiveIME);
    STDMETHODIMP DestroyAImeContext(HIMC hIMC);
    STDMETHODIMP UpdateAImeContext(HIMC hIMC);
    STDMETHODIMP MapAttributes(HIMC hIMC);
    STDMETHODIMP GetGuidAtom(HIMC hIMC, BYTE bAttr, TfGuidAtom* pGuidAtom);


    //
    // ITfCleanupContextSink methods
    //
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    //
    // ITfContextOwnerCompositionSink
    //
    STDMETHODIMP OnStartComposition(ITfCompositionView *pComposition, BOOL *pfOk);
    STDMETHODIMP OnUpdateComposition(ITfCompositionView *pComposition, ITfRange *pRangeNew);
    STDMETHODIMP OnEndComposition(ITfCompositionView *pComposition);

public:
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

protected:
    long m_ref;

public:
    // HRESULT AssociateFocus(HIMC hIMC, BOOL fActive);

    ITfDocumentMgr* GetDocumentManager()
    {
        return m_pdim;
    }

    ITfContext* GetInputContext()
    {
        return m_pic;
    }

    ITfContextOwnerServices* GetInputContextOwnerSink()
    {
        return m_piccb;
    }

    //
    // Reconvert Edit Session
    //
public:
    HRESULT SetupReconvertString();
    HRESULT SetupReconvertString(UINT uPrivMsg);
    HRESULT EndReconvertString();

    HRESULT SetupUndoCompositionString();
    HRESULT EndUndoCompositionString();

    HRESULT SetReconvertEditSession(BOOL bSet);
    BOOL    IsInReconvertEditSession() {return m_fInReconvertEditSession;}
    HRESULT SetClearDocFeedEditSession(BOOL bSet);
    BOOL    IsInClearDocFeedEditSession() {return m_fInClearDocFeedEditSession;}

    //
    // GetTextAndAttribute Edit Session
    //
public:
    HRESULT GetTextAndAttribute(HIMC hIMC, CWCompString* wCompString, CWCompAttribute* wCompAttribute);
    HRESULT GetTextAndAttribute(HIMC hIMC, CBCompString* bCompString, CBCompAttribute* bCompAttribute);

    //
    // GetCursorPosition Edit Session
    //
public:
    HRESULT GetCursorPosition(HIMC hIMC, CWCompCursorPos* wCursorPosition);

    //
    // GetSelection Edit Session
    //
public:
    HRESULT GetSelection(HIMC hIMC, CWCompCursorPos& wStartSelection, CWCompCursorPos& wEndSelection);

public:
    BOOL IsTopNow()
    {
        BOOL bRet = FALSE;
        ITfContext *pic;
        if (SUCCEEDED(m_pdim->GetTop(&pic)))
        {
            bRet = (pic == m_pic) ? TRUE : FALSE;
            pic->Release();
        }
        return bRet;
    }

    //
    // Get ImmIfIME interface pointer.
    //
public:
    ImmIfIME* const GetImmIfIME()
    {
        return m_pImmIfIME;
    }

    //
    // QueryCharPos
    //
public:
    typedef enum {
        IME_QUERY_POS_UNKNOWN = 0,
        IME_QUERY_POS_NO      = 1,
        IME_QUERY_POS_YES     = 2
    } IME_QUERY_POS;

    HRESULT InquireIMECharPosition(HIMC hIMC, IME_QUERY_POS* pfQueryPos);
    HRESULT RetrieveIMECharPosition(HIMC hIMC, IMECHARPOSITION* ip);
    HRESULT ResetIMECharPosition(HIMC hIMC)
    {
        m_fQueryPos = IME_QUERY_POS_UNKNOWN;
        return S_OK;
    }

private:
    BOOL QueryCharPos(HIMC hIMC, IMECHARPOSITION* position);


private:
    HIMC                      m_hImc;

    //
    // IActiveIME context
    //
    ImmIfIME                  *m_pImmIfIME;

    //
    // Cicero's context
    //
    ITfDocumentMgr            *m_pdim;           // Document Manager
    ITfContext                *m_pic;            // Input Context
    ITfContextOwnerServices   *m_piccb;          // Context owner service from m_pic

    //
    // Cicero's event sink callback
    //
    CInputContextOwnerCallBack      *m_pICOwnerSink;          // IC owner call back

    CTextEventSinkCallBack          *m_pTextEventSink;        // Text event sink callback

    CThreadMgrEventSinkCallBack     *m_pThreadMgrEventSink;   // Thread manager event sink callback

    CCompartmentEventSinkCallBack   *m_pCompartmentEventSink; // Compartment event sink callback

    CStartReconversionNotifySink    *m_pStartReconvSink;

    //
    // Generate message
    //
public:
    UINT TranslateImeMessage(HIMC hIMC, LPTRANSMSGLIST lpTransMsgList = NULL);

    CFirstInFirstOut<TRANSMSG, TRANSMSG>    *m_pMessageBuffer;

    //
    // Mouse sink
    //
    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, HIMC hIMC);

    //
    // Editing VK list.
    //
public:
    BOOL IsVKeyInKeyList(UINT uVKey, UINT uEditingId = 0)
    {
        UINT uRetEditingId;

        if (uRetEditingId = _IsVKeyInKeyList(uVKey, m_pEditingKeyList)) {
            if (uEditingId == 0 ||
                uEditingId == uRetEditingId)
                return TRUE;
        }

        return FALSE;
    }

private:
    HRESULT SetupEditingKeyList(LANGID LangId);

    VOID QueryRegKeyValue(CRegKey& reg, LPCTSTR lpszRegVal, UINT uEditingId)
    {
        TCHAR  szValue[128];
        DWORD  dwCount = sizeof(szValue);
        LONG   lRet;
        lRet = reg.QueryValue(szValue, lpszRegVal, &dwCount);
        if (lRet == ERROR_SUCCESS && dwCount > 0) {

            LPTSTR psz = szValue;
            while ((dwCount = lstrlen(psz)) > 0) {
                UINT uVKey = atoi(psz);
                if (uVKey != 0) {
                    m_pEditingKeyList->SetAt(uVKey, uEditingId);
                }
                psz += dwCount + 1;
            }
        }
    }

    VOID QueryResourceDataValue(LANGID LangId, DWORD dwID, UINT uEditingId)
    {
        HINSTANCE hInstance = GetInstance();
        LPTSTR    lpName = (LPTSTR) (ULONG_PTR)dwID;

        HRSRC hRSrc = FindResourceEx(hInstance, RT_RCDATA, lpName, LangId);
        if (hRSrc == NULL) {
            return;
        }

        HGLOBAL hMem = LoadResource(hInstance, hRSrc);
        if (hMem == NULL)
            return;

        WORD* pwData = (WORD*)LockResource(hMem);

        while (*pwData) {
            if (*(pwData+1) == uEditingId) {
                m_pEditingKeyList->SetAt(*pwData, uEditingId);
            }
            pwData += 2;
        }
    }

    UINT _IsVKeyInKeyList(UINT uVKey, CMap<UINT, UINT, UINT, UINT>* map)
    {
        UINT flag;
        if (map && map->Lookup(uVKey, flag))
            return flag;
        else
            return 0;
    }

    TfClientId GetClientId();

private:
    CMap<UINT,                     // class KEY       <Virtual Key>
         UINT,                     // class ARG_KEY
         UINT,                     // class VALUE     <Editing Identification>
         UINT                      // class ARG_VALUE
        >* m_pEditingKeyList;

private:
    // void AssocFocus(HWND hWnd, ITfDocumentMgr* pdim);

    //
    // Mode bias
    //
public:
    LPARAM lModeBias;

    //
    // Flags
    //
public:
    BOOL   m_fStartComposition : 1;        // TRUE: already sent WM_IME_STARTCOMPOSITION.
    BOOL   m_fOpenCandidateWindow : 1;     // TRUE: opening candidate list window.
    BOOL   m_fInReconvertEditSession : 1;  // TRUE: In reconvert edit session.
    BOOL   m_fInClearDocFeedEditSession : 1;  // TRUE: In ClearDocFeed edit session.
#ifdef CICERO_4732
    BOOL   m_fInCompComplete : 1;             // TRUE: In CompComplete running.
#endif

    BOOL   m_fHanjaReConversion;
#ifdef UNSELECTCHECK
    BOOL   m_fSelected : 1;   // TRUE: if this context is selected.
#endif UNSELECTCHECK

    IME_QUERY_POS   m_fQueryPos;           // Apps support QueryCharPos().

    int _cCompositions;
    BOOL _fModifyingDoc;

    //
    // IME share.
    //
    USHORT      usGuidMapSize;
    TfGuidAtom  aGuidMap[256];    // GUIDATOM map to IME Attribute

};

#endif // _CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_cime.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_cimc.cpp

Abstract:

    This file implements the ImmIfIME Class's public method.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "immif.h"
#include "ico.h"
#include "langct.h"
#include "template.h"
#include "imeapp.h"
#include "profile.h"
#include "funcprv.h"
#include "a_wrappers.h"
#include "computil.h"
#include "korimx.h"


extern HRESULT CAImeContext_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);


//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance
//
//----------------------------------------------------------------------------

HRESULT
CIME_CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    DebugMsg(TF_FUNC, "CIME_CreateInstance called. TID=%x", GetCurrentThreadId());

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    ImmIfIME *pIME = new ImmIfIME;
    if (pIME == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pIME->QueryInterface(riid, ppvObj);
    pIME->Release();

    if (SUCCEEDED(hr)) {
        hr = pIME->InitIMMX();
        if (FAILED(hr)) {
            pIME->Release();
            *ppvObj = NULL;
        }
    }

    return hr;
}

ImmIfIME::ImmIfIME()
{
    Dbg_MemSetThisName(TEXT("ImmIfIME"));

    m_fCicInit    = FALSE;
    m_fOnSetFocus = FALSE;

    m_tim = NULL;
    m_tfClientId = TF_CLIENTID_NULL;
    m_pkm = NULL;
    m_AImeProfile = NULL;
    m_dimEmpty = NULL;

    m_fAddedProcessAtom = FALSE;
}

ImmIfIME::~ImmIfIME()
{
    UnInitIMMX();
}


STDAPI
ImmIfIME::ConnectIMM(IActiveIMMIME_Private *pActiveIMM)

/*++

Method:

    IActiveIME::ConnectIMM

Routine Description:

    Accepts an IActiveIMMIME pointer from the dimm layer.

Arguments:

    pActiveIMM - [in] the imm layer

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    IMTLS *ptls;

    Assert(m_pIActiveIMMIME == NULL);

    // DON'T AddRef, this would create a circular ref.
    // We can get away with this because this is an internal
    // only object.
    // (This hack is necessary so that we can hook up dimm HIMCs
    // with cicero dim's before anyone calls Activate, which
    // we want to support.  We could avoid the cicular ref
    // problem by doing the hookup in IActiveIMMApp::Activate,
    // but then the ime layer is useless before the Activate
    // call.)
    m_pIActiveIMMIME = pActiveIMM;

    // Set IActiveIMMIME instance in the TLS data.
    if (ptls = IMTLS_GetOrAlloc())
    {
        Assert(ptls->pAImm == NULL);
        ptls->pAImm = pActiveIMM;
    }

    return S_OK;
}

STDAPI
ImmIfIME::UnconnectIMM()

/*++

Method:

    IActiveIME::UnconnectIMM

Routine Description:

    Releases the IActiveIMMIME pointer from the dimm layer.

Arguments:

    pActiveIMM - [in] the imm layer

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    IMTLS *ptls;

    Assert(m_pIActiveIMMIME != NULL);

    // nb: non-standard, won't Release pointer
    // we didn't AddRef in ConnectIMM
    m_pIActiveIMMIME = NULL;

    // Set IActiveIMMIME instance in the TLS data.
    if (ptls = IMTLS_GetOrAlloc())
    {
        ptls->pAImm = NULL;
    }

    return S_OK;
}

HRESULT
ImmIfIME::GetCodePageA(
    UINT *puCodePage
    )

/*++

Method:

    IActiveIME::GetCodePageA

Routine Description:

    Retrieves the code page associated with this Active IME.

Arguments:

    uCodePage - [out] Address of an unsigned integer that receives the code page identifier
                      associated with the keyboard layout.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::GetCodePageA");

    if (puCodePage == NULL) {
        return E_INVALIDARG;
    }

    return m_AImeProfile->GetCodePageA(puCodePage);
}

HRESULT
ImmIfIME::GetLangId(
    LANGID *plid
    )

/*++

Method:

    IActiveIME::GetLangId

Routine Description:

    Retrieves the language identifier associated with this Active IME.

Arguments:

    plid - [out] Address of the LANGID associated with the keyboard layout.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::GetLangId");

    if (plid == NULL) {
        return E_INVALIDARG;
    }

    return m_AImeProfile->GetLangId(plid);
}


STDAPI
ImmIfIME::Inquire(
    DWORD dwSystemInfoFlags,
    IMEINFO *pIMEInfo,
    LPWSTR szWndClass,
    DWORD *pdwPrivate
    )

/*++

Method:

    IActiveIME::Inquire

Routine Description:

    Handles the initialization of the Active IME.

Arguments:

    dwSystemInfoFlags - [in] Unsigned long integer value that specifies the system info flags.
                            FALSE : Inquire IME property and class name
                            TRUE  : Also Activate thread manager and input processor profile.
    pIMEInfo - [out] Address of the IMEINFO structure that receives information about the Active
                     IME.
    szWndClass - [out] Address of a string value that receives the window class name.
    pdwPrivate - [out] Reserved. Must be set to NULL.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    HWND hWndDummy = NULL;

    DebugMsg(TF_FUNC, "ImmIfIME::Inquire :: TID=%x", GetCurrentThreadId());

    if (pIMEInfo == NULL || pdwPrivate == NULL)
        return E_POINTER;

    *pdwPrivate = 0;

    if (!_ImeInquire(pIMEInfo, szWndClass, dwSystemInfoFlags))
        return E_FAIL;

    //
    // Inquire IME property and class name
    //
    if (dwSystemInfoFlags == FALSE)
        return S_OK;

    //
    // Activate thread manager and input processor profile.
    //
    Assert(m_tfClientId == TF_CLIENTID_NULL);
    
    // Set Activate flag in the CAImeProfile.
    m_AImeProfile->Activate();

    if (IsOn98() || IsOn95()) {
        /*
         * The ITfThreadMgr->Activate method calls win32 ActivateKeyboardLayout() function.
         * However if Windows9x platforms, this function require hWnd for succeed function call.
         * In this code, we prevent fail return from ActivateKeyboardLayout() by create dummy hWnd.
         */
        hWndDummy = CreateWindowA(TEXT("STATIC"),
                                  TEXT(""),
                                  WS_POPUP,                // Do not set WS_DISABLED flag
                                                           // due to ActivateKeyboardLayout fail
                                  0, 0, 0, 0,              // x, y, width, height
                                  NULL,                    // parent
                                  NULL,                    // menu
                                  GetInstance(),
                                  NULL);                   // lpParam

        if (hWndDummy == NULL)
            return E_FAIL;
    }

    hr = m_tim->Activate(&m_tfClientId);

    ITfSourceSingle *pSourceSingle;

    if (m_tim->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
    {
        CFunctionProvider *pFunc = new CFunctionProvider(this, m_tfClientId);
        if (pFunc)
        {
            pSourceSingle->AdviseSingleSink(m_tfClientId, IID_ITfFunctionProvider, (ITfFunctionProvider *)pFunc);
            pFunc->Release();
        }
        pSourceSingle->Release();
    }


    if (hWndDummy != NULL)
    {
        DestroyWindow(hWndDummy);
    }

    if (hr != S_OK)
    {
        Assert(0); // couldn't activate thread!
        m_tfClientId = TF_CLIENTID_NULL;
        return E_FAIL;
    }

    if (!m_dimEmpty && FAILED(hr = m_tim->CreateDocumentMgr(&m_dimEmpty)))
        return E_FAIL;

    return S_OK;
}


const char ImmIfIME::s_szUIClassName[16] = "IMMIF UI";

BOOL
ImmIfIME::_ImeInquire(
    LPIMEINFO lpImeInfo,
    LPWSTR pwszWndClass,
    DWORD dwSystemInfoFlags
    )
{
    DebugMsg(TF_FUNC, "ImmIfIME::ImeInquire");

    if (lpImeInfo == NULL) {
        DebugMsg(TF_ERROR, "ImeInquire: lpImeInfo is NULL.");
        return FALSE;
    }

    lpImeInfo->dwPrivateDataSize = 0;

    lpImeInfo->fdwProperty = 0;
    lpImeInfo->fdwConversionCaps = 0;
    lpImeInfo->fdwSentenceCaps = 0;
    lpImeInfo->fdwSCSCaps = 0;
    lpImeInfo->fdwUICaps = 0;

    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = (DWORD)NULL;

#ifdef UNICODE
    lstrcpy(pwszWndClass, s_szUIClassName);
#else
    MultiByteToWideChar(CP_ACP, 0, s_szUIClassName, -1, pwszWndClass,  16);
#endif

    //
    // Per language property
    //
    LANGID LangId;
    HRESULT hr = GetLangId(&LangId);
    if (SUCCEEDED(hr)) {
        CLanguageCountry language(LangId);
        hr = language.GetProperty(&lpImeInfo->fdwProperty,
                                  &lpImeInfo->fdwConversionCaps,
                                  &lpImeInfo->fdwSentenceCaps,
                                  &lpImeInfo->fdwSCSCaps,
                                  &lpImeInfo->fdwUICaps);
    }
    return TRUE;
}




STDAPI
ImmIfIME::SelectEx(
    HIMC hIMC,
    DWORD dwFlags,
    BOOL bIsRealIme_SelKL,
    BOOL bIsRealIme_UnSelKL
    )

/*++

Method:

    IActiveIME::Select

Routine Description:

    Initializes and frees the Active Input Method Editor private context.

Arguments:

    hIMC - [in] Handle to the input context.
    dwFlags - [in] dword value that specifies the action. 

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::Select(%x, %x)", hIMC, dwFlags);

    HRESULT hr;
    IMTLS *ptls;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    if (_pAImeContext == NULL && (dwFlags & AIMMP_SE_SELECT))
    {
        // this happens if the context is created before Activate was called
        // we need to create the CAImeContext now
        if (CAImeContext_CreateInstance(NULL, IID_IAImeContext, (void**)&_pAImeContext) != S_OK)
            return E_FAIL;

        if (_pAImeContext->CreateAImeContext(hIMC, this) != S_OK)
        {
            _pAImeContext->Release();
            return E_FAIL;
        }
    }

    ptls = IMTLS_GetOrAlloc();

    HKL          _hkl;
    _hkl = ::GetKeyboardLayout(0);
    LANGID langid = LANGIDFROMLCID(PtrToUlong(_hkl));

    //
    // Chinese Legacy IME hack code for near caret IME.
    //
    if (PRIMARYLANGID(langid) == LANG_CHINESE)
    {
        imc->cfCandForm[0].dwStyle = CFS_DEFAULT;
        imc->cfCandForm[0].dwIndex = (DWORD)-1;
    }

#ifdef UNSELECTCHECK
    if (_pAImeContext)
        _pAImeContext->m_fSelected = (dwFlags & AIMMP_SE_SELECT) ? TRUE : FALSE;
#endif UNSELECTCHECK

    if (dwFlags & AIMMP_SE_SELECT) {

        Assert(_pAImeContext->lModeBias == MODEBIASMODE_DEFAULT /* => 0 */); // make sure lModeBias is init'd correctly

        if (hIMC == ImmGetContext(ptls, GetFocus())) {
            /*
             * Current focus window and hIMC matched.
             * Set current active hIMC in the *this->m_hImc
             */
            if (ptls != NULL)
            {
                ptls->hIMC = hIMC;
            }
        }

        if (! imc.ClearCand()) {
            return E_FAIL;
        }

        if ((imc->fdwInit & INIT_CONVERSION) == 0) {

            DWORD fdwConvForLang = (imc->fdwConversion & IME_CMODE_SOFTKBD); // = IME_CMODE_ALPHANUMERIC
            if (langid)
            {
                switch(PRIMARYLANGID(langid))
                {
                    case LANG_JAPANESE:
                        //
                        // Roman-FullShape-Native is a major convmode to 
                        // initialize.
                        //
                        fdwConvForLang |= IME_CMODE_ROMAN | 
                                          IME_CMODE_FULLSHAPE | 
                                          IME_CMODE_NATIVE;
                        break;

                    case LANG_KOREAN:
                        // IME_CMODE_ALPHANUMERIC
                        break;

#ifdef CICERO_4428
                    case LANG_CHINESE:
                        switch(SUBLANGID(langid))
                        {
                            case SUBLANG_CHINESE_TRADITIONAL:
                                // IME_CMODE_ALPHANUMERIC
                                break;
                            default:
                                fdwConvForLang |= IME_CMODE_NATIVE;
                                break;
                        }
                        break;
#endif

                    default:
                        fdwConvForLang |= IME_CMODE_NATIVE;
                        break;
                }
            }
            imc->fdwConversion |= fdwConvForLang;

            imc->fdwInit |= INIT_CONVERSION;
        }

        // Initialize extended fdwConversion flag.
        // While set IME_CMODE_GUID_NULL bit in fdwConversion, ICO_ATTR returns GUID_NULL.
        imc->fdwConversion |= IME_CMODE_GUID_NULL;

        //
        // Also, initialize extended fdwSentence flag.
        // While set IME_SMODE_GUID_NULL bit in fdwSentence, ICO_ATTR returns GUID_NULL.
        //
        imc->fdwSentence |= IME_SMODE_PHRASEPREDICT | IME_SMODE_GUID_NULL;

        if ((imc->fdwInit & INIT_LOGFONT) == 0) {
            HDC hDC;
            HGDIOBJ hSysFont;

            hDC = ::GetDC(imc->hWnd);
            hSysFont = ::GetCurrentObject(hDC, OBJ_FONT);
            LOGFONTA font;
            ::GetObjectA(hSysFont, sizeof(LOGFONTA), &font);
            ::ReleaseDC(NULL, hDC);

            if (ptls != NULL &&
                SUCCEEDED(ptls->pAImm->SetCompositionFontA(hIMC, &font)))
            {
                imc->fdwInit |= INIT_LOGFONT;
            }
        }

        imc.InitContext();

        // if this IME is run under Chicago Simplified Chinese version
        imc->lfFont.W.lfCharSet = GetCharsetFromLangId(LOWORD(HandleToUlong(_hkl)));


        //
        // Retrieve imc->fOpen status.
        //
        Interface_Attach<ITfContext> ic(GetInputContext(imc));

        if (ptls != NULL && ptls->hIMC == hIMC) {
            /*
             * Selecting hIMC has been current active hIMC,
             * then associate this DIM with the TIM.
             */
            if (dwFlags & AIMMP_SE_ISPRESENT) {
                Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc));
                SetFocus(imc->hWnd, dim.GetPtr(), TRUE);
            }
            else {
                SetFocus(imc->hWnd, NULL, TRUE);
            }
        }

        hr = GetCompartmentDWORD(m_tim,
                                 GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                 (DWORD*)&imc->fOpen, FALSE);

    }
    else {  // being unselected
        DebugMsg(TF_FUNC, "ImmIf is being unselected.");

        if (IsOnNT())
        {
            //
            // Switch hKL from Cicero KL to Legacy KL in Unselect handler.
            // We needs to call postponed lock so release all queueing request for edit session here.
            // Especially, ESCB_UPDATECOMPOSITIONSTRING should handle before switch to Legacy IME,
            // because this edit session possible to rewrite hIMC->hCompStr buffer.
            // Some Legacy IME have dependency of size and each offset with hCompStr.
            //
            // IsOn98 is CIMEUIWindowHandler::ImeUISelectHandler()
            //
            if ((! bIsRealIme_UnSelKL) && bIsRealIme_SelKL)
            {
                Interface_Attach<ITfContext> ic(GetInputContext(imc));
                if (ic.Valid())
                    m_tim->RequestPostponedLock(ic.GetPtr());
            }
        }

        Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc));

        //
        // Reset INIT_GUID_ATOM flag here.
        //
#ifdef CICERO_4428
        imc->fdwInit &= ~(INIT_GUID_ATOM);
#else
        imc->fdwInit &= ~(INIT_CONVERSION | INIT_GUID_ATOM);
#endif

        if (dim.GetPtr()) {
            if (ptls != NULL && ptls->hIMC == hIMC) {
                /*
                 * Selecting hIMC has been current active hIMC,
                 * then associate this DIM with the TIM.
                 */

                //
                // This call made Cicero to think the window was no Cicero aware
                // any more when hKL was changed to a real IME.
                //
                // SetFocus(imc->hWnd, NULL);
                //
                ptls->hIMC = (HIMC)NULL;
            }
        }
    }

    return hr;
}

STDAPI
ImmIfIME::UnSelectCheck(
    HIMC hIMC
    )

/*++

Method:

    IActiveIME::UnSelectCheck

Routine Description:

    Initializes and frees the Active Input Method Editor private context.

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::UnSelectCheck(%x)", hIMC);

#ifdef UNSELECTCHECK
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    if (_pAImeContext)
    {
        _pAImeContext->m_fSelected = FALSE;
    }

#else
    //
    // none should call this without UNSELECTCHECK.
    //
    Assert(0);
#endif UNSELECTCHECK
    return S_OK;
}

void
ImmIfIME::SetFocus(
    HWND hWnd,
    ITfDocumentMgr* pdim,
    BOOL fSetFocus
    )
{
    if (m_fOnSetFocus) {
        /*
         * Prevent reentrance call from m_tim->AssociateFocus.
         */
        return;
    }

    m_fOnSetFocus = TRUE;

    if (::IsWindow(hWnd) && m_fCicInit != FALSE) {
        ITfDocumentMgr  *pdimPrev; // just to receive prev for now
        m_tim->AssociateFocus(hWnd, pdim, &pdimPrev);
        if (fSetFocus) {
            m_tim->SetFocus(pdim);
        }
        if (pdimPrev)
            pdimPrev->Release();

    }

    m_fOnSetFocus = FALSE;
}


STDAPI
ImmIfIME::AssociateFocus(
    HWND hWnd,
    HIMC hIMC,
    DWORD dwFlags
    )

/*++

Method:

    IActiveIME::AssociateFocus

Routine Description:

    Notifies the current Active Input Method Editor of the active input context.

Arguments:

    hIMC - [in] Handle to the input context.
    fActive - [in] Boolean value that specifies the status of the input context. TRUE indicates
                   the input context is activated, and FALSE indicates the input contest is
                   deactivated.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::AssociateFocus(%x, %x, %x)", hWnd, hIMC, dwFlags);

    HRESULT hr;
    IMTLS *ptls;
    BOOL fFocus = (dwFlags & AIMMP_AFF_SETFOCUS) ? TRUE : FALSE;
    HIMC hOldIMC = NULL;

    if (fFocus)
    {
        if (ptls = IMTLS_GetOrAlloc())
        {
            hOldIMC = ptls->hIMC;
            ptls->hIMC = hIMC;
        }
    }

    if (dwFlags & AIMMP_AFF_SETNULLDIM) {
        //
        // set  null dim so legacy IME start running.
        //
        SetFocus(hWnd, NULL, fFocus);

    }
    else if (hIMC) {
        IMCLock imc(hIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc));
        SetFocus(imc->hWnd, dim.GetPtr(), fFocus);

    }
    else {
        //
        // this new focus change performance improvement breaks some
        // assumption of IsRealIME() in AssociateContext in dimm\immapp.cpp.
        // Associate NULL dim under IsPresent() window has not been the case
        // AIMM1.2 handles. In fact, this breaks IE that calls
        // AssociateContext on the focus window that is IsPresent().
        //
#ifdef FOCUSCHANGE_PERFORMANCE
        //
        // set empty dim so no text store to simulate NULL-HIMC.
        //
        BOOL fUseEmptyDIM = FALSE;
        ITfDocumentMgr  *pdimPrev; // just to receive prev for now
        if (SUCCEEDED(m_tim->GetFocus(&pdimPrev)) && pdimPrev)
        {
            fUseEmptyDIM = TRUE;
            pdimPrev->Release();
                
        }
        
        SetFocus(hWnd, fUseEmptyDIM ? m_dimEmpty : NULL, fFocus);
#else
        SetFocus(hWnd, m_dimEmpty, fFocus);
#endif
    }

    //
    // we want to finish ActivateAssemblyItem when we move between
    // Cicero aware and Non Cicero aware control.
    //
    // Async Edit Session may cause the hKL activate order problem.
    //
    if (fFocus && hOldIMC)
    {
        IMCLock imc(hOldIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        Interface_Attach<ITfContext> ic(GetInputContext(imc));

        if (ic.Valid())
            m_tim->RequestPostponedLock(ic.GetPtr());
    }

    return S_OK;
}



HRESULT
ImmIfIME::Notify(
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue
    )

/*++

Method:

    IActiveIME::Notify

Routine Description:

    Notifies the Active IME about changes to the status of the input context.

Arguments:

    hIMC - [in] Handle to the input context.
    dwAction - [in] Unsigined long integer value that specifies the notification code.
    dwIndex - [in] Unsigned long integer value that specifies the index of a candidate list or,
                   if dwAction is set to NI_COMPOSITIONSTR, one of the following values:
                   CPS_CANCEL:  Clear the composition string and set the status to no composition
                                string.
                   CPS_COMPLETE: Set the composition string as the result string.
                   CPS_CONVERT: Convert the composition string.
                   CPS_REVERT: Cancel the current composition string and revert to the unconverted
                               string.
    dwValue - [in] Unsigned long integer value that specifies the index of a candidate string or
                   is not used, depending on the value of the dwAction parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    IMCLock imc(hIMC);
    if (imc.Invalid())
        return E_FAIL;

    DebugMsg(TF_FUNC, "ImmIfIME::Notify(hIMC=%x, dwAction=%x, dwIndex=%x, dwValue=%x)", hIMC, dwAction, dwIndex, dwValue);

    switch (dwAction) {

        case NI_CONTEXTUPDATED:
            switch (dwValue) {
                case IMC_SETOPENSTATUS:
                    return OnSetOpenStatus(imc);

                case IMC_SETCONVERSIONMODE:
                case IMC_SETSENTENCEMODE:
                    return OnSetConversionSentenceMode(imc);

                case IMC_SETCOMPOSITIONWINDOW:
                case IMC_SETCOMPOSITIONFONT:
                    return E_NOTIMPL;

                case IMC_SETCANDIDATEPOS:
                    return OnSetCandidatePos(imc);

                default:
                    return E_FAIL;
            }
            break;

        case NI_COMPOSITIONSTR:
            switch (dwIndex) {
                case CPS_COMPLETE:
                    _CompComplete(imc);
                    return S_OK;

                case CPS_CONVERT:
                case CPS_REVERT:
                    return E_NOTIMPL;

                case CPS_CANCEL:
                    _CompCancel(imc);
                    return S_OK;

                default:
                    return E_FAIL;
            }
            break;

        case NI_OPENCANDIDATE:
        case NI_CLOSECANDIDATE:
        case NI_SELECTCANDIDATESTR:
        case NI_CHANGECANDIDATELIST:
        case NI_SETCANDIDATE_PAGESIZE:
        case NI_SETCANDIDATE_PAGESTART:
        case NI_IMEMENUSELECTED:
            return E_NOTIMPL;

        default:
            break;
    }
    return E_FAIL;
}

HRESULT
ImmIfIME::SetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    void *pComp,
    DWORD dwCompLen,
    void *pRead,
    DWORD dwReadLen
    )

/*++

Method:

    IActiveIME::SetCompositionString

Routine Description:

    Sets the characters, attributes, and clauses of the composition and reading strings.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long interger value that specifies the type of information to set.
    pComp - [in] Address of the buffer that contains the information to set for composition string.
                 The information is as specified by the dwIndex value.
    dwCompLen - [in] Unsigned long interger value that specifies the size, in bytes, of the
                     information buffer for the composition string.
    pRead - [in] Address of the buffer that contains the information to set for the reading string.
                 The information is as specified by the dwIndex value.
    dwReadLen - [in] Unsigned long interger value that specifies the size, in bytes, of the
                     information buffer for the reading string.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    UINT cp = CP_ACP;
    GetCodePageA(&cp);

    switch (dwIndex) {
        case SCS_SETSTR:
            {
                CWCompString wCompStr(cp, hIMC, (LPWSTR)pComp, dwCompLen);
                CWCompString wCompReadStr(cp, hIMC, (LPWSTR)pRead, dwReadLen);
                hr = Internal_SetCompositionString(wCompStr, wCompReadStr);
            }
            break;
        case SCS_CHANGEATTR:
        case SCS_CHANGECLAUSE:
            hr = E_NOTIMPL;
            break;
        case SCS_SETRECONVERTSTRING:
            {
                CWReconvertString wReconvStr(cp, hIMC, (LPRECONVERTSTRING)pComp, dwCompLen);
                CWReconvertString wReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)pRead, dwReadLen);
                hr = Internal_ReconvertString(imc, wReconvStr, wReconvReadStr);
            }
            break;
        case SCS_QUERYRECONVERTSTRING:
            // AdjustZeroCompLenReconvertString((LPRECONVERTSTRING)pComp, cp, FALSE);
            // hr = S_OK;

            hr = Internal_QueryReconvertString(imc, (LPRECONVERTSTRING)pComp, cp, FALSE);
            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

HRESULT
ImmIfIME::Destroy(
    UINT uReserved
    )

/*++

Method:

    IActiveIME::Destroy

Routine Description:

    Terminates the Active Input Method Editor (IME).

Arguments:

    uReserved - [in] Reserved. Must be set to zero.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    //
    // clear empty dim
    //
    SafeReleaseClear(m_dimEmpty);

    // Deactivate thread manager.
    if (m_tfClientId != TF_CLIENTID_NULL)
    {
        ITfSourceSingle *pSourceSingle;

        if (m_tim->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
        {
            pSourceSingle->UnadviseSingleSink(m_tfClientId, IID_ITfFunctionProvider);
            pSourceSingle->Release();
        }

        m_tfClientId = TF_CLIENTID_NULL;
        m_tim->Deactivate();

    }

    return S_OK;
}


HRESULT
ImmIfIME::Escape(
    HIMC hIMC,
    UINT uEscape,
    void *pData,
    LRESULT *plResult
    )

/*++

Method:

    IActiveIME::Escape

Routine Description:

    Allows an application to access capabilities of a particular Active Input Method Editor (IME)
    not directly available through other methods.

Arguments:

    hIMC - [in] Handle to the input context.
    uEscape - [in] Unsigned integer value that specifies the escape function to be performed.
    pData - [in, out] Address of a buffer that contains the data required by the specified
                      escape function.
    plResult - [out] Address of a buffer that receives the result of the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    LANGID LangId;
    HRESULT hr = GetLangId(&LangId);
    if (SUCCEEDED(hr)) {
        CLanguageCountry language(LangId);

        UINT cp = CP_ACP;
        GetCodePageA(&cp);

        hr = language.Escape(cp, hIMC, uEscape, pData, plResult);
    }
    return hr;
}

STDAPI
ImmIfIME::ConversionList(
    HIMC hIMC,
    LPWSTR szSource,
    UINT uFlag,
    UINT uBufLen,
    CANDIDATELIST *pDest,
    UINT *puCopied
    )
{
    if (puCopied == NULL)
        return E_POINTER;

    *puCopied = 0;

    // really not implemented
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::Configure(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *pRegisterWord
    )
{
    IMTLS *ptls;
    TF_LANGUAGEPROFILE LanguageProfile;

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    HRESULT hr = ptls->pAImeProfile->GetActiveLanguageProfile(hKL,
                                                        GUID_TFCAT_TIP_KEYBOARD,
                                                        &LanguageProfile);
    if (FAILED(hr))
        return hr;

    Interface<ITfFunctionProvider> pFuncProv;
    hr = ptls->tim->GetFunctionProvider(LanguageProfile.clsid,    // CLSID of tip
                                   pFuncProv);
    if (FAILED(hr))
        return hr;

    if (dwMode & IME_CONFIG_GENERAL) {
        Interface<ITfFnConfigure> pFnConfigure;
        hr = pFuncProv->GetFunction(GUID_NULL,
                                    IID_ITfFnConfigure,
                                    (IUnknown**)(ITfFnConfigure**)pFnConfigure);
        if (FAILED(hr))
            return hr;

        hr = pFnConfigure->Show(hWnd,
                                LanguageProfile.langid,
                                LanguageProfile.guidProfile);
        return hr;
    }
    else if (dwMode & IME_CONFIG_REGISTERWORD) {
        Interface<ITfFnConfigureRegisterWord> pFnRegisterWord;
        hr = pFuncProv->GetFunction(GUID_NULL,
                                    IID_ITfFnConfigureRegisterWord,
                                    (IUnknown**)(ITfFnConfigureRegisterWord**)pFnRegisterWord);
        if (FAILED(hr))
            return hr;

        if (!pRegisterWord)
        {
            hr = pFnRegisterWord->Show(hWnd,
                                       LanguageProfile.langid,
                                       LanguageProfile.guidProfile,
                                       NULL);
        }
        else
        {
            BSTR bstrWord = SysAllocString(pRegisterWord->lpWord);
            if (!bstrWord)
                return E_OUTOFMEMORY;
    
            hr = pFnRegisterWord->Show(hWnd,
                                       LanguageProfile.langid,
                                       LanguageProfile.guidProfile,
                                       bstrWord);

            SysFreeString(bstrWord);
        }
        return hr;
    }
    else {
        return E_NOTIMPL;
    }
}

STDAPI
ImmIfIME::RegisterWord(
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szString
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::UnregisterWord(
    LPWSTR szReading,
    DWORD  dwStyle,
    LPWSTR szString
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::GetRegisterWordStyle(
    UINT nItem,
    STYLEBUFW *pStyleBuf,
    UINT *puBufSize
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::EnumRegisterWord(
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szRegister,
    LPVOID pData,
    IEnumRegisterWordW **ppEnum
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

//
// Notification
//
HRESULT
ImmIfIME::OnSetOpenStatus(
    IMCLock& imc
    )
{
    if (! imc->fOpen && imc.ValidCompositionString())
        _CompCancel(imc);

    Interface_Attach<ITfContext> ic(GetInputContext(imc));
    m_ulOpenStatusChanging++;
    HRESULT hr =  SetCompartmentDWORD(m_tfClientId,
                                      m_tim,
                                      GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                      imc->fOpen,
                                      FALSE);
    m_ulOpenStatusChanging--;
    return hr;
}

HRESULT
ImmIfIME::OnSetKorImxConversionMode(
    IMCLock& imc
    )
{
    DWORD fdwConvMode = 0;

    Interface_Attach<ITfContext> ic(GetInputContext(imc));

    m_ulKorImxModeChanging++;

    if (imc->fdwConversion & IME_CMODE_HANGUL)
    {
        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
            fdwConvMode = KORIMX_HANGULJUNJA_MODE;
        else
            fdwConvMode = KORIMX_HANGUL_MODE;
    }
    else
    {
        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
            fdwConvMode = KORIMX_JUNJA_MODE;
        else
            fdwConvMode = KORIMX_ALPHANUMERIC_MODE;
    }

    HRESULT hr =  SetCompartmentDWORD(m_tfClientId,
                                      m_tim,
                                      GUID_COMPARTMENT_KORIMX_CONVMODE,
                                      fdwConvMode,
                                      FALSE);
    m_ulKorImxModeChanging--;

    return hr;
}

HRESULT
ImmIfIME::OnSetConversionSentenceMode(
    IMCLock& imc
    )
{
    IMTLS *ptls;

    Interface_Attach<ITfContextOwnerServices> iccb(GetInputContextOwnerSink(imc));

    // let cicero know the mode bias has changed
    // consider: perf: we could try to filter out false-positives here
    // (sometimes a bit that cicero ignores changes, we could check and avoid the call,
    // but it would complicate the code)
    iccb->OnAttributeChange(GUID_PROP_MODEBIAS);

    //
    // let Korean Tip sync up the current mode status changing...
    //
    if ((ptls = IMTLS_GetOrAlloc()) != NULL)
    {
        LANGID langid;

        ptls->pAImeProfile->GetLangId(&langid);

        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            OnSetKorImxConversionMode(imc);
        }
    }

    return S_OK;
}

HRESULT
ImmIfIME::OnSetCandidatePos(
    IMCLock& imc
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    //
    // When this is in the reconvert session, candidate window position is
    // not caret position of cfCandForm->ptCurrentPos.
    //
    if (! _pAImeContext->IsInReconvertEditSession()) {
        IMTLS *ptls;
        if (ptls = IMTLS_GetOrAlloc())
        {
            /*
             * A-Synchronize call ITfContextOwnerServices::OnLayoutChange
             * because this method had a protected.
             */
            PostMessage(ptls->prvUIWndMsg.hWnd,
                        ptls->prvUIWndMsg.uMsgOnLayoutChange, (WPARAM)(HIMC)imc, 0);
        }
    }
    return S_OK;
}


STDAPI 
ImmIfIME::SetThreadCompartmentValue(
    REFGUID rguid, 
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;


    HRESULT hr = E_FAIL;
    if (m_tim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)m_tim, rguid, &pComp, FALSE)))
        {
            hr = pComp->SetValue(m_tfClientId, pvar);
            pComp->Release();
        }
    }

    return hr;
}

STDAPI 
ImmIfIME::GetThreadCompartmentValue(
    REFGUID rguid, 
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    QuickVariantInit(pvar);

    if (m_tim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)m_tim, rguid, &pComp, FALSE)))
        {
            hr = pComp->GetValue(pvar);
            pComp->Release();
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_wrappers.cpp ===
//
// a_wrapper.cpp
//

#include "private.h"

#include "globals.h"
#include "cime.h"
#include "imtls.h"

#define IsAIMM() (ptls && ptls->pAImm)

HINSTANCE hIMM = NULL;   // temporary: do not call IMM32 for now

#define _GETPROC(name) \
        static t ## name lpProc = NULL; \
        if (lpProc == NULL) { \
            lpProc = (t ## name)GetProcAddress(hIMM, #name); \
        } \
        ASSERT(lpProc); \
        if (lpProc)

#define CALLPROCRET(name) \
    _GETPROC(name) \
        return lpProc

#define GETPROC(name, val, param) \
    {   \
        _GETPROC(name) { \
            (val) = lpProc param; \
        } \
    }



typedef HKL   (WINAPI * tImmInstallIMEA)(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
typedef HWND  (WINAPI * tImmGetDefaultIMEWnd)(HWND);
typedef UINT  (WINAPI * tImmGetDescriptionA)(HKL, LPSTR, UINT uBufLen);
typedef UINT  (WINAPI * tImmGetDescriptionW)(HKL, LPWSTR, UINT uBufLen);
typedef UINT  (WINAPI * tImmGetIMEFileNameA)(HKL, LPSTR, UINT uBufLen);
typedef UINT  (WINAPI * tImmGetIMEFileNameW)(HKL, LPWSTR, UINT uBufLen);
typedef DWORD  (WINAPI * tImmGetProperty)(HKL, DWORD);
typedef BOOL  (WINAPI * tImmIsIME)(HKL);
typedef BOOL  (WINAPI * tImmSimulateHotKey)(HWND, DWORD);
typedef HIMC  (WINAPI * tImmCreateContext)(void);
typedef BOOL  (WINAPI * tImmDestroyContext)(HIMC);
typedef HIMC  (WINAPI * tImmGetContext)(HWND);
typedef BOOL  (WINAPI * tImmReleaseContext)(HWND, HIMC);
typedef HIMC  (WINAPI * tImmAssociateContext)(HWND, HIMC);
typedef LONG   (WINAPI * tImmGetCompositionStringA)(HIMC, DWORD, LPVOID, DWORD);
typedef LONG   (WINAPI * tImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD);
typedef BOOL   (WINAPI * tImmSetCompositionStringA)(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
typedef BOOL   (WINAPI * tImmSetCompositionStringW)(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
typedef DWORD  (WINAPI * tImmGetCandidateListCountA)(HIMC, LPDWORD lpdwListCount);
typedef DWORD  (WINAPI * tImmGetCandidateListA)(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
typedef DWORD  (WINAPI * tImmGetGuideLineA)(HIMC, DWORD dwIndex, LPSTR, DWORD dwBufLen);
typedef DWORD  (WINAPI * tImmGetGuideLineW)(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);
typedef BOOL  (WINAPI * tImmGetConversionStatus)(HIMC, LPDWORD, LPDWORD);
typedef BOOL  (WINAPI * tImmSetConversionStatus)(HIMC, DWORD, DWORD);
typedef BOOL  (WINAPI * tImmGetOpenStatus)(HIMC);
typedef BOOL  (WINAPI * tImmSetOpenStatus)(HIMC, BOOL);
typedef BOOL  (WINAPI * tImmGetCompositionFontA)(HIMC, LPLOGFONTA);
typedef BOOL  (WINAPI * tImmSetCompositionFontA)(HIMC, LPLOGFONTA);
typedef BOOL  (WINAPI * tImmConfigureIMEA)(HKL, HWND, DWORD, LPVOID);
typedef LRESULT  (WINAPI * tImmEscapeA)(HKL, HIMC, UINT, LPVOID);
typedef DWORD    (WINAPI * tImmGetConversionListA)(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
typedef DWORD    (WINAPI * tImmGetConversionListW)(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
typedef BOOL  (WINAPI * tImmNotifyIME) (HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
typedef BOOL  (WINAPI * tImmGetStatusWindowPos)(HIMC, LPPOINT);
typedef BOOL  (WINAPI * tImmSetStatusWindowPos)(HIMC, LPPOINT);
typedef BOOL  (WINAPI * tImmGetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
typedef BOOL  (WINAPI * tImmSetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
typedef BOOL  (WINAPI * tImmGetCandidateWindow)(HIMC, DWORD, LPCANDIDATEFORM);
typedef BOOL  (WINAPI * tImmSetCandidateWindow)(HIMC, LPCANDIDATEFORM);
typedef BOOL  (WINAPI * tImmIsUIMessageA)(HWND, UINT, WPARAM, LPARAM);
typedef UINT  (WINAPI * tImmGetVirtualKey)(HWND);
typedef BOOL  (WINAPI * tImmRegisterWordA)(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
typedef BOOL  (WINAPI * tImmRegisterWordW)(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
typedef BOOL  (WINAPI * tImmUnregisterWordA)(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
typedef BOOL  (WINAPI * tImmUnregisterWordW)(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
typedef UINT  (WINAPI * tImmGetRegisterWordStyleA)(HKL, UINT nItem, LPSTYLEBUFA);
typedef UINT (WINAPI * tImmEnumRegisterWordA)(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
typedef UINT (WINAPI * tImmEnumRegisterWordW)(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);

typedef LPINPUTCONTEXT (WINAPI* tImmLockIMC)(HIMC);
typedef BOOL (WINAPI* tImmUnlockIMC)(HIMC);

typedef HIMCC (WINAPI* tImmCreateIMCC)(DWORD);
typedef HIMCC (WINAPI* tImmDestroyIMCC)(HIMCC);
typedef LPVOID (WINAPI* tImmLockIMCC)(HIMCC);
typedef BOOL (WINAPI* tImmUnlockIMCC)(HIMCC);
typedef HIMCC (WINAPI* tImmReSizeIMCC)(HIMCC, DWORD);
typedef DWORD (WINAPI* tImmGetIMCCSize)(HIMCC);
typedef DWORD (WINAPI* tImmGetIMCCLockCount)(HIMCC);

typedef BOOL (WINAPI* tImmGenerateMessage)(HIMC);

typedef LRESULT (WINAPI* tImmEscapeA)(HKL hKL, HIMC hIMC, UINT uFunc, LPVOID lpData);
typedef LRESULT (WINAPI* tImmEscapeW)(HKL hKL, HIMC hIMC, UINT uFunc, LPVOID lpData);

typedef BOOL (WINAPI* tImmEnumInputContext)(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

UINT WINAPI RawImmGetDescriptionA(HKL hkl, LPSTR lpstr, UINT uBufLen)
{
    UINT rUINT = 0;
    GETPROC(ImmGetDescriptionA, rUINT, (hkl, lpstr, uBufLen));
    return rUINT;
}

BOOL WINAPI RawImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
{
    BOOL ret = FALSE;
    GETPROC(ImmEnumInputContext, ret, (idThread, lpfn, lParam));
    return ret;
}

HIMC ImmGetContext(IMTLS *ptls, HWND hwnd)
{
    HIMC rHIMC = NULL;

    if (IsAIMM()) {
        ptls->pAImm->GetContext(hwnd, &rHIMC);
    }
    else if (hIMM) {
        GETPROC(ImmGetContext, rHIMC, (hwnd));
    }
    else {
        ASSERT(FALSE);
    }

    return rHIMC;

}

BOOL ImmSetCompositionStringW(IMTLS *ptls, HIMC himc, DWORD dwIndex, LPVOID lpComp, DWORD dword, LPVOID lpRead, DWORD dword2)
{
    if (IsAIMM()) {
        return ptls->pAImm->SetCompositionStringW( himc, dwIndex, (LPVOID)lpComp, dword, (LPVOID)lpRead, dword2) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionStringW)(himc, dwIndex, lpComp, dword, lpRead, dword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL ImmSetConversionStatus(IMTLS *ptls, HIMC himc, DWORD dword, DWORD dword2)
{
    if (IsAIMM()) {
        return ptls->pAImm->SetConversionStatus(himc,dword, dword2) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetConversionStatus)(himc, dword, dword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

LPINPUTCONTEXT ImmLockIMC(IMTLS *ptls, HIMC himc)
{
    if (IsAIMM()) {
        LPINPUTCONTEXT lpimc;
        if (ptls->pAImm->LockIMC(himc, &lpimc) == S_OK) {
            return lpimc;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmLockIMC)(himc);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

BOOL ImmUnlockIMC(IMTLS *ptls, HIMC himc)
{
    if (IsAIMM()) {
        return ptls->pAImm->UnlockIMC(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnlockIMC)(himc);
    }
    ASSERT(FALSE);

    return FALSE;
}

HIMCC ImmCreateIMCC(IMTLS *ptls, DWORD dwSize)
{
    if (IsAIMM()) {
        HIMCC himcc;
        if (ptls->pAImm->CreateIMCC(dwSize, &himcc) == S_OK) {
            return himcc;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmCreateIMCC)(dwSize);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

HIMCC ImmDestroyIMCC(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        return ptls->pAImm->DestroyIMCC(himcc) == S_OK ? NULL : himcc;
    }

    if (hIMM) {
        CALLPROCRET(ImmDestroyIMCC)(himcc);
    }
    ASSERT(FALSE);

    return himcc;
}

LPVOID ImmLockIMCC(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        LPVOID lpv;
        if (ptls->pAImm->LockIMCC(himcc, &lpv) == S_OK) {
            return lpv;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmLockIMCC)(himcc);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

BOOL ImmUnlockIMCC(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        return ptls->pAImm->UnlockIMCC(himcc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnlockIMCC)(himcc);
    }
    ASSERT(FALSE);

    return FALSE;
}

HIMCC ImmReSizeIMCC(IMTLS *ptls, HIMCC himcc, DWORD dwSize)
{
    if (IsAIMM()) {
        HIMCC himccr;
        if (ptls->pAImm->ReSizeIMCC(himcc, dwSize, &himccr) == S_OK) {
            return himccr;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmReSizeIMCC)(himcc, dwSize);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

DWORD ImmGetIMCCSize(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        DWORD dwSize;
        if (ptls->pAImm->GetIMCCSize(himcc, &dwSize) == S_OK) {
            return dwSize;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmGetIMCCSize)(himcc);
    }
    else {
        ASSERT(FALSE);
    }

    return 0;
}

#ifdef DEBUG
namespace debug {
void DumpMessages(HIMC himc)
{
    IMCLock imc(himc);
    ASSERT(imc.Valid());

    IMCCLock<TRANSMSG> msgbuf(imc->hMsgBuf);

    for (DWORD i = 0; i < imc->dwNumMsgBuf; ++i) {
        TRANSMSG* msg = &msgbuf[i];
    }
}
}
#endif

BOOL ImmGenerateMessage(IMTLS *ptls, HIMC himc)
{
#ifdef DEBUG
    debug::DumpMessages(himc);
#endif

    if (IsAIMM()) {
        return ptls->pAImm->GenerateMessage(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGenerateMessage)(himc);
    }
    else {
        ASSERT(FALSE);
    }

    return FALSE;
}

#ifdef UNUSED

HWND WINAPI ImmGetDefaultIMEWnd(HWND hwnd)
{
    HWND rHwnd = NULL;

    if (IsAIMM()) {
        ActiveIMM->GetDefaultIMEWnd(hwnd, &rHwnd);
    }
    else if (hIMM) {
        GETPROC(ImmGetDefaultIMEWnd, rHwnd, (hwnd));
    }

    return rHwnd;
}

HIMC WINAPI ImmCreateContext(void)
{
    HIMC rHIMC = NULL;

    if (IsAIMM()) {
        ActiveIMM->CreateContext(&rHIMC);
    }
    else if (hIMM) {
        GETPROC(ImmCreateContext, rHIMC, ());
    }

    return rHIMC;
}


HKL  WINAPI ImmInstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText)
{
    HKL rHKL = 0;

    if (IsAIMM()) {
        ActiveIMM->InstallIMEA(lpszIMEFileName, lpszLayoutText, &rHKL);
    }
    else if (hIMM) {
        GETPROC(ImmInstallIMEA, rHKL, (lpszIMEFileName, lpszLayoutText));
    }
    else {
        ASSERT(FALSE);
    }

    return rHKL;
}


UINT WINAPI ImmGetDescriptionA(HKL hkl, LPSTR lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetDescriptionA(hkl, uBufLen, lpstr, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetDescriptionA, rUINT, (hkl, lpstr, uBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmGetDescriptionW(HKL hkl, WCHAR* lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetDescriptionW(hkl, uBufLen, lpstr, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetDescriptionW, rUINT, (hkl, lpstr, uBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmGetIMEFileNameA(HKL hkl, LPSTR lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        HRESULT hres = ActiveIMM->GetIMEFileNameA(hkl, uBufLen, lpstr, &rUINT);
        if (hres == E_NOTIMPL) {
            return -1L;
        }
    }
    else if (hIMM) {
        GETPROC(ImmGetIMEFileNameA, rUINT, (hkl, lpstr, uBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmGetIMEFileNameW(HKL hkl, WCHAR* lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        HRESULT hres = ActiveIMM->GetIMEFileNameW(hkl, uBufLen, lpstr, &rUINT);
        if (hres == E_NOTIMPL) {
            return -1L;
        }
    }
    else if (hIMM) {
        GETPROC(ImmGetIMEFileNameW, rUINT, (hkl, lpstr, uBufLen));
    } else {
        ASSERT(FALSE);
    }

    return rUINT;
}

DWORD WINAPI ImmGetProperty(HKL hkl, DWORD dword)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        ActiveIMM->GetProperty(hkl, dword, &rDWORD);
    }
    else if (hIMM) {
        GETPROC(ImmGetProperty, rDWORD, (hkl, dword));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}

BOOL WINAPI ImmIsIME(HKL hkl)
{
    if (IsAIMM()) {
        return ActiveIMM->IsIME(hkl) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmIsIME)(hkl);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSimulateHotKey(HWND hwnd, DWORD dword)
{

    if (IsAIMM()) {
        return ActiveIMM->SimulateHotKey(hwnd, dword) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSimulateHotKey)(hwnd, dword);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmDestroyContext(HIMC himc)
{

    if (IsAIMM()) {
        return ActiveIMM->DestroyContext(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmDestroyContext)(himc);
    }
    ASSERT(FALSE);


    return FALSE;
}

BOOL WINAPI ImmReleaseContext(HWND hwnd, HIMC himc)
{
    if (IsAIMM()) {
        return(ActiveIMM->ReleaseContext(hwnd, himc)==S_OK);
    }

    if (hIMM) {
        CALLPROCRET(ImmReleaseContext)(hwnd, himc);
    }
    ASSERT(FALSE);

    return FALSE;
}


HIMC WINAPI ImmAssociateContext(HWND hwnd, HIMC himc)
{
    HIMC rHIMC = NULL;

    if (IsAIMM()) {
        ActiveIMM->AssociateContext(hwnd, himc, &rHIMC);
    }
    else if (hIMM) {
        GETPROC(ImmAssociateContext, rHIMC, (hwnd, himc));
    }
    else {
        ASSERT(FALSE);
    }

    return rHIMC;
}


LONG WINAPI ImmGetCompositionStringA(HIMC himc, DWORD dword, LPVOID lpvoid, DWORD dword2)
{
    LONG rLONG = 0;

    if (IsAIMM()) {
        ActiveIMM->GetCompositionStringA(himc, dword, dword2,  &rLONG, lpvoid);
    }
    else if (hIMM) {
        GETPROC(ImmGetCompositionStringA, rLONG, (himc, dword, lpvoid, dword2));
    }

    return rLONG;
}

LONG  WINAPI ImmGetCompositionStringW(HIMC himc, DWORD dword, LPVOID lpvoid, DWORD dword2)
{
    LONG rLONG = 0;

    if (IsAIMM()) {
        ActiveIMM->GetCompositionStringW(himc, dword, dword2,  &rLONG, lpvoid);
    }
    else if (hIMM) {
        GETPROC(ImmGetCompositionStringW, rLONG, (himc, dword, lpvoid, dword2));
    }

    return rLONG;
}

BOOL  WINAPI ImmSetCompositionStringA(HIMC himc, DWORD dwIndex, LPVOID lpComp, DWORD dword, LPVOID lpRead, DWORD dword2)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCompositionStringA( himc, dwIndex, (LPVOID)lpComp, dword, (LPVOID)lpRead, dword2) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionStringA)(himc, dwIndex, lpComp, dword, lpRead, dword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

DWORD WINAPI ImmGetCandidateListCountA(HIMC himc, LPDWORD lpdwListCount)
{
    DWORD rDWORD = 0;
    HRESULT hres = 0;

    if (IsAIMM()) {
        hres = ActiveIMM->GetCandidateListCountA(himc, lpdwListCount, &rDWORD);
        if (hres == E_NOTIMPL)
            return -1L;
    }
    else if (hIMM) {
        GETPROC(ImmGetCandidateListCountA, rDWORD, (himc, lpdwListCount));
    }
    else {
        ASSERT(FALSE);
    }


    return rDWORD;
}

DWORD WINAPI ImmGetCandidateListA(HIMC himc, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        UINT rUINT = 0;
        HRESULT hres = ActiveIMM->GetCandidateListA(himc, dwIndex,  dwBufLen, lpCandList, &rUINT);
        rDWORD = rUINT;

        if (hres == E_NOTIMPL) {
            return -1L;
        }
    }
    else if (hIMM) {
        GETPROC(ImmGetCandidateListA, rDWORD, (himc, dwIndex, lpCandList, dwBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}


DWORD WINAPI ImmGetGuideLineA(HIMC himc, DWORD dwIndex, LPSTR lpstr, DWORD dwBufLen)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        ActiveIMM->GetGuideLineA(himc, dwIndex, dwBufLen, lpstr,  &rDWORD);
    }
    else if (hIMM) {
        GETPROC(ImmGetGuideLineA, rDWORD, (himc, dwIndex, lpstr, dwBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}

DWORD WINAPI ImmGetGuideLineW(HIMC himc, DWORD dwIndex, LPWSTR lpstr, DWORD dwBufLen)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        ActiveIMM->GetGuideLineW(himc, dwIndex, dwBufLen, lpstr,  &rDWORD);
    }
    else if (hIMM) {
        GETPROC(ImmGetGuideLineW, rDWORD, (himc, dwIndex, lpstr, dwBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}


BOOL WINAPI ImmGetConversionStatus(HIMC himc, LPDWORD lpdword, LPDWORD lpdword2)
{
    if (IsAIMM()) {
        return ActiveIMM->GetConversionStatus(himc, lpdword, lpdword2);
    }

    if (hIMM) {
        CALLPROCRET(ImmGetConversionStatus)(himc, lpdword, lpdword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmGetOpenStatus(HIMC himc)
{
    if (IsAIMM()) {
        return ActiveIMM->GetOpenStatus(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetOpenStatus)(himc);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSetOpenStatus(HIMC himc, BOOL bvalue)
{
    if (IsAIMM()) {
        return ActiveIMM->SetOpenStatus(himc, bvalue) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetOpenStatus)(himc, bvalue);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmGetCompositionFontA(HIMC himc, LPLOGFONTA lplogfonta)
{
    if (IsAIMM()) {
        HRESULT hres = ActiveIMM->GetCompositionFontA(himc, lplogfonta);

        return (hres == S_OK) ? TRUE : FALSE;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetCompositionFontA)(himc, lplogfonta);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmSetCompositionFontA(HIMC himc, LPLOGFONTA lplogfonta)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCompositionFontA(himc, lplogfonta) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionFontA)(himc, lplogfonta);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmConfigureIMEA(HKL hkl, HWND hwnd, DWORD dword, LPVOID lpvoid)
{
    if (IsAIMM()) {
        return ActiveIMM->ConfigureIMEA(hkl,  hwnd, dword, (REGISTERWORDA*) lpvoid) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmConfigureIMEA)(hkl, hwnd, dword, lpvoid);
    }
    ASSERT(FALSE);

    return FALSE;
}

LRESULT WINAPI ImmEscapeA(HKL hkl, HIMC himc, UINT uFunc, LPVOID lpData)
{
    LRESULT rLRESULT = 0;

    if (IsAIMM()) {
        ActiveIMM->EscapeA(hkl, himc, uFunc, lpData,  &rLRESULT);
    }
    else if (hIMM) {
        GETPROC(ImmEscapeA, rLRESULT, (hkl, himc, uFunc, lpData));
    }
    else {
        ASSERT(FALSE);
    }

    return rLRESULT;
}


LRESULT WINAPI ImmEscapeW(HKL hkl, HIMC himc, UINT uFunc, LPVOID lpData)
{
    LRESULT lr = 0;

    if (IsAIMM()) {
        ActiveIMM->EscapeW(hkl, himc, uFunc, lpData, &lr);
    }
    else if (hIMM) {
        GETPROC(ImmEscapeW, lr, (hkl, himc, uFunc, lpData));
    }
    else {
        ASSERT(FALSE);
    }

    return lr;
}

DWORD WINAPI ImmGetConversionListA(HKL hkl, HIMC himc, LPCSTR lpcstr, LPCANDIDATELIST lpcandlist, DWORD dwBufLen, UINT uFlag)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        UINT    rUINT = 0;
        ActiveIMM->GetConversionListA( hkl, himc, (LPSTR)lpcstr, dwBufLen, uFlag, lpcandlist, &rUINT);
        rDWORD = rUINT;
    }
    else if (hIMM) {
        GETPROC(ImmGetConversionListA, rDWORD, (hkl, himc, lpcstr, lpcandlist, dwBufLen, uFlag));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}

DWORD WINAPI ImmGetConversionListW(HKL hkl, HIMC himc, LPCWSTR lpcstr, LPCANDIDATELIST lpcandlist, DWORD dwBufLen, UINT uFlag)
{
    DWORD rDWORD = 0;

    if (IsAIMM())
    {
        UINT rUINT = 0;
        ActiveIMM->GetConversionListW( hkl, himc, (LPWSTR)lpcstr, dwBufLen, uFlag, lpcandlist, &rUINT);
        rDWORD = rUINT;
    }
    else if (hIMM) {
        GETPROC(ImmGetConversionListW, rDWORD, (hkl, himc, lpcstr, lpcandlist, dwBufLen, uFlag));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}


BOOL WINAPI ImmNotifyIME(HIMC himc, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    if (IsAIMM()) {
        return ActiveIMM->NotifyIME(himc,  dwAction,  dwIndex,  dwValue) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmNotifyIME)(himc,  dwAction,  dwIndex,  dwValue);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmGetStatusWindowPos(HIMC himc, LPPOINT lppoint)
{
    if (IsAIMM()) {
        return ActiveIMM->GetStatusWindowPos(himc,  lppoint) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetStatusWindowPos)(himc, lppoint);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmSetStatusWindowPos(HIMC himc, LPPOINT lppoint)
{
    if (IsAIMM()) {
        return ActiveIMM->SetStatusWindowPos( himc,  lppoint) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetStatusWindowPos)(himc, lppoint);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmGetCompositionWindow(HIMC himc, LPCOMPOSITIONFORM lpcompositionform)
{
    HRESULT hres=0;

    if (IsAIMM()) {
        return ActiveIMM->GetCompositionWindow( himc,  lpcompositionform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetCompositionWindow)(himc, lpcompositionform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSetCompositionWindow(HIMC himc, LPCOMPOSITIONFORM lpcompositionform)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCompositionWindow( himc,  lpcompositionform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionWindow)(himc, lpcompositionform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmGetCandidateWindow(HIMC himc, DWORD dword, LPCANDIDATEFORM lpcandidateform)
{
    if (IsAIMM()) {
        return ActiveIMM->GetCandidateWindow( himc,  dword, lpcandidateform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetCandidateWindow)(himc, dword, lpcandidateform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSetCandidateWindow(HIMC himc, LPCANDIDATEFORM lpcandidateform)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCandidateWindow( himc,  lpcandidateform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCandidateWindow)(himc, lpcandidateform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmIsUIMessageA(HWND hwnd, UINT uint, WPARAM wparam, LPARAM lparam)
{
    if (IsAIMM()) {
        return ActiveIMM->IsUIMessageA( hwnd,  uint,  wparam,  lparam) == S_OK;
    }
    else if (hIMM) {
        CALLPROCRET(ImmIsUIMessageA)(hwnd,  uint,  wparam,  lparam);
    }
    ASSERT(FALSE);

    return FALSE;
}

UINT WINAPI ImmGetVirtualKey(HWND hwnd)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetVirtualKey(hwnd, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetVirtualKey, rUINT, (hwnd));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmEnumRegisterWordA(HKL hkl, REGISTERWORDENUMPROCA registerwordenumproca, LPCSTR lpszReading, DWORD dword, LPCSTR lpszRegister, LPVOID lpvoid)
{
    //
    // HY: ???
    //
    UINT rUINT = 0;
    IEnumRegisterWordA *pEnum = NULL;

    if (IsAIMM()) {
        ActiveIMM->EnumRegisterWordA(hkl, (LPSTR)lpszReading, dword, (LPSTR)lpszRegister, lpvoid, &pEnum);
    }
    else if (hIMM) {
        GETPROC(ImmEnumRegisterWordA, rUINT, (hkl, registerwordenumproca, lpszReading, dword, lpszRegister, lpvoid));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}


UINT WINAPI ImmGetRegisterWordStyleA(HKL hkl, UINT nItem, LPSTYLEBUFA lpstylebufa)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetRegisterWordStyleA( hkl,  nItem,  lpstylebufa, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetRegisterWordStyleA, rUINT, (hkl,  nItem,  lpstylebufa));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}


BOOL WINAPI ImmRegisterWordA(HKL hkl, LPCSTR lpszReading, DWORD dword, LPCSTR lpszRegister)
{
    if (IsAIMM()) {
        return ActiveIMM->RegisterWordA( hkl, (LPSTR) lpszReading, dword, (LPSTR) lpszRegister) == S_OK;
    }
    else if (hIMM) {
        CALLPROCRET(ImmRegisterWordA)(hkl, lpszReading, dword, lpszRegister);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmRegisterWordW(HKL hkl, LPCWSTR lpszReading, DWORD dword, LPCWSTR lpszRegister)
{
    if (IsAIMM()) {
        return ActiveIMM->RegisterWordW( hkl, (LPWSTR) lpszReading, dword, (LPWSTR) lpszRegister) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmRegisterWordW)(hkl, lpszReading, dword, lpszRegister);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmUnregisterWordA(HKL hkl, LPCSTR lpszReading, DWORD dword, LPCSTR lpszUnregister)
{
    if (IsAIMM()) {
        return ActiveIMM->UnregisterWordA( hkl, (LPSTR) lpszReading, dword, (LPSTR) lpszUnregister) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnregisterWordA)(hkl, lpszReading, dword, lpszUnregister);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmUnregisterWordW(HKL hkl, LPCWSTR lpszReading, DWORD dword, LPCWSTR lpszUnregister)
{
    if (IsAIMM()) {
        return ActiveIMM->UnregisterWordW( hkl, (LPWSTR) lpszReading, dword, (LPWSTR) lpszUnregister) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnregisterWordW)(hkl, lpszReading, dword, lpszUnregister);
    }
    ASSERT(FALSE);

    return FALSE;
}

DWORD WINAPI ImmGetIMCCLockCount(HIMCC himcc)
{
    if (IsAIMM()) {
        DWORD dw;
        if (ActiveIMM->GetIMCCLockCount(himcc, &dw) == S_OK) {
            return dw;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmGetIMCCLockCount)(himcc);
    }
    else {
        ASSERT(FALSE);
    }

    return 0;
}
#endif // UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\a_wrappers.h ===
//
// a_wrappers.h
//

#ifndef A_WRAPPERS_H
#define A_WRAPPERS_H

#include "private.h"
#include "imtls.h"

HIMC ImmGetContext(IMTLS *ptls, HWND hwnd);
BOOL ImmSetCompositionStringW(IMTLS *ptls, HIMC himc, DWORD dwIndex, LPVOID lpComp, DWORD dword, LPVOID lpRead, DWORD dword2);
BOOL ImmSetConversionStatus(IMTLS *ptls, HIMC himc, DWORD dword, DWORD dword2);
LPINPUTCONTEXT ImmLockIMC(IMTLS *ptls, HIMC himc);
BOOL ImmUnlockIMC(IMTLS *ptls, HIMC himc);
HIMCC ImmCreateIMCC(IMTLS *ptls, DWORD dwSize);
HIMCC ImmDestroyIMCC(IMTLS *ptls, HIMCC himcc);
LPVOID ImmLockIMCC(IMTLS *ptls, HIMCC himcc);
BOOL ImmUnlockIMCC(IMTLS *ptls, HIMCC himcc);
HIMCC ImmReSizeIMCC(IMTLS *ptls, HIMCC himcc, DWORD dwSize);
DWORD ImmGetIMCCSize(IMTLS *ptls, HIMCC himcc);
BOOL ImmGenerateMessage(IMTLS *ptls, HIMC himc);

#endif // A_WRAPPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\caime.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       caime.cpp
//
//  Contents:   CAIME
//
//----------------------------------------------------------------------------

#include "private.h"

#include "globals.h"
#include "idebug.h"
#include "globals.h"
#include "caime.h"


CAIME::CAIME()
{
    m_pIActiveIMMIME = NULL;
    _pPauseCookie = NULL;

    DllAddRef();
    _cRef = 1;
}

CAIME::~CAIME()
{
    Assert(_pPauseCookie == NULL);
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CAIME::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IActiveIME_Private))
    {
        *ppvObj = SAFECAST(this, IActiveIME_Private *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider)) {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
#if 0
    else if (IsEqualIID(ridd, IID_IAImmLayer)) {
        *ppvObj = SAFECAST(this, IAImmLayer*);
    }
#endif

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CAIME::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CAIME::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\candpos.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    candpos.h

Abstract:

    This file defines the CCandidatePosition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CANDPOS_H_
#define _CANDPOS_H_

#include "cime.h"
#include "imtls.h"
#include "ctxtcomp.h"

class CCandidatePosition
{
public:
    HRESULT GetCandidatePosition(OUT RECT* out_rcArea);

private:
    HRESULT GetRectFromApp(IN IMTLS* ptls,
                           IN IMCLock& imc,
                           IN LANGID langid,
                           OUT RECT* out_rcArea);

    HRESULT GetRectFromHIMC(IN IMCLock& imc,
                            IN DWORD dwStyle,
                            IN POINT* ptCurrentPos,
                            IN RECT* rcArea,
                            OUT RECT* out_rcArea);

    HRESULT GetCandidateArea(IN IMCLock& imc,
                             IN DWORD dwStyle,
                             IN POINT* ptCurrentPos,
                             IN RECT* rcArea,
                             OUT RECT* out_rcArea);

    HRESULT GetRectFromCompFont(IN IMTLS* ptls,
                                IN IMCLock& imc,
                                IN POINT* ptCurrentPos,
                                OUT RECT* out_rcArea);

    HRESULT FindAttributeInCompositionString(IN IMCLock& imc,
                                             IN BYTE target_attribute,
                                             OUT CWCompCursorPos& wCursorPosition);

    HRESULT GetCursorPosition(IN IMCLock& imc,
                              OUT CWCompCursorPos& wCursorPosition);

    HRESULT GetSelection(IN IMCLock& imc,
                         OUT CWCompCursorPos& wStartSelection,
                         OUT CWCompCursorPos& wEndSelection);

    typedef enum {
        DIR_LEFT_RIGHT = 0,        // normal
        DIR_TOP_BOTTOM = 1,        // vertical
        DIR_RIGHT_LEFT = 2,        // right to left
        DIR_BOTTOM_TOP = 3         // vertical
    } DOC_DIR;

    DOC_DIR DocumentDirection(IN IMCLock& imc)
    {
        if (imc->lfFont.A.lfEscapement == 2700 ||
            imc->lfFont.A.lfEscapement == 900) {
            //
            // Vertical writting.
            //
            if (imc->lfFont.A.lfEscapement == 900 ||
                imc->lfFont.A.lfEscapement == 1800) {
                return DIR_BOTTOM_TOP;
            }
            else {
                return DIR_TOP_BOTTOM;
            }
        }
        else {
            //
            // Horizontal writting.
            //
            if (imc->lfFont.A.lfEscapement == 1800) {
                return DIR_RIGHT_LEFT;
            }
            else {
                return DIR_LEFT_RIGHT;
            }
        }
    }
};

#endif // _CANDPOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\cime.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cime.cpp

Abstract:

    This file implements the IMCLock / IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cime.h"
#include "template.h"
#include "imedefs.h"
#include "a_wrappers.h"
#include "a_context.h"

/////////////////////////////////////////////////////////////////////////////
// IMCLock

IMCLock::IMCLock(
    HIMC hImc
    ) : _IMCLock(hImc)
{
    if (hImc) {
        m_hr = _LockIMC(hImc, &m_inputcontext);
    }
}

HRESULT
IMCLock::_LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT_AIMM12 **ppIMC
    )
{
    if (hIMC == NULL) {
        return E_INVALIDARG;
    }

    *ppIMC = (INPUTCONTEXT_AIMM12*)ImmLockIMC(IMTLS_GetOrAlloc(), hIMC);
    return *ppIMC == NULL ? E_FAIL : S_OK;
}

HRESULT
IMCLock::_UnlockIMC(
    IN HIMC hIMC
    )
{
    return ImmUnlockIMC(IMTLS_GetOrAlloc(), hIMC) ? S_OK : E_FAIL;
}

BOOL
IMCLock::ValidCompositionString(
    )
{
    if (ImmGetIMCCSize(IMTLS_GetOrAlloc(), m_inputcontext->hCompStr) < sizeof(COMPOSITIONSTRING))
        return FALSE;

    IMCCLock<COMPOSITIONSTRING> lpCompStr(m_inputcontext->hCompStr);
    if (lpCompStr.Invalid())
        return FALSE;

    return (lpCompStr->dwCompStrLen > 0);
}

//
// Initialize the context
//
void
IMCLock::InitContext(
    )
{
    CAImeContext* _pAImeContext = m_inputcontext->m_pAImeContext;
    if (_pAImeContext)
        _pAImeContext->m_fOpenCandidateWindow = FALSE;     // TRUE: opening candidate list window.


    if (!(m_inputcontext->fdwInit & INIT_COMPFORM)) {
        m_inputcontext->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    for (UINT i = 0; i < 4; i++) {
        m_inputcontext->cfCandForm[i].dwStyle = CFS_DEFAULT;
    }

    return;
}

//
// clear candidate list
//
BOOL
IMCLock::ClearCand(
    )
{
    HIMCC           hMem;
    LPCANDIDATELIST lpCandList;
    IMTLS *ptls = IMTLS_GetOrAlloc();
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;

    if (! m_inputcontext->hCandInfo) {
        // it maybe free by other IME, init it
        m_inputcontext->hCandInfo = ImmCreateIMCC(ptls, dwSize);
    } else if (hMem = ImmReSizeIMCC(ptls, m_inputcontext->hCandInfo, dwSize)) {
        m_inputcontext->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(ptls, m_inputcontext->hCandInfo);
        m_inputcontext->hCandInfo = ImmCreateIMCC(ptls, dwSize);
        return (FALSE);
    }

    if (! m_inputcontext->hCandInfo) {
        return (FALSE);
    }


    IMCCLock<CANDIDATEINFO> lpCandInfo(m_inputcontext->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(IMTLS_GetOrAlloc(), m_inputcontext->hCandInfo);
        m_inputcontext->hCandInfo = ImmCreateIMCC(ptls, dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)lpCandInfo.GetOffsetPointer( lpCandInfo->dwOffset[0] );
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    return (TRUE);
}

//
// generate message
//
void
IMCLock::GenerateMessage(
    )
{
    CAImeContext* _pAImeContext = m_inputcontext->m_pAImeContext;

    if (_pAImeContext &&
        _pAImeContext->TranslateImeMessage((HIMC)*this))
        ImmGenerateMessage(IMTLS_GetOrAlloc(), (HIMC)*this);
}

/////////////////////////////////////////////////////////////////////////////
// InternalIMCCLock

InternalIMCCLock::InternalIMCCLock(
    HIMCC hImcc
    ) : _IMCCLock(hImcc)
{
    if (hImcc) {
        m_hr = _LockIMCC(m_himcc, (void**)&m_pimcc);
    }
}


HRESULT
InternalIMCCLock::_LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )
{
    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    *ppv = ImmLockIMCC(IMTLS_GetOrAlloc(), hIMCC);
#if defined(DEBUG)
    if (*ppv) {
        HeapValidate( GetProcessHeap(), 0, *ppv);
    }
#endif
    return *ppv == NULL ? E_FAIL : S_OK;
}

HRESULT
InternalIMCCLock::_UnlockIMCC(
    IN HIMCC hIMCC
    )
{
    return ImmUnlockIMCC(IMTLS_GetOrAlloc(), hIMCC) ? S_OK :
        GetLastError() == NO_ERROR ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\cmpevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmpevcb.cpp

Abstract:

    This file implements the CCompartmentEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cmpevcb.h"
#include "cime.h"
#include "immif.h"
#include "korimx.h"


// static
HRESULT
CCompartmentEventSinkCallBack::CompartmentEventSinkCallback(
    void* pv,
    REFGUID rguid
    )
{
    DebugMsg(TF_FUNC, "CompartmentEventSinkCallback");

    IMTLS *ptls;
    HRESULT hr = S_OK;
    LANGID langid;
    BOOL fOpenChanged;

    CCompartmentEventSinkCallBack* _this = (CCompartmentEventSinkCallBack*)pv;
    ASSERT(_this);

    ImmIfIME* _ImmIfIME = _this->m_pImmIfIME;
    ASSERT(_ImmIfIME);

    fOpenChanged = _ImmIfIME->IsOpenStatusChanging();

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    ptls->pAImeProfile->GetLangId(&langid);

    if ((PRIMARYLANGID(langid) != LANG_KOREAN) && fOpenChanged)
        return S_OK;

    IMCLock imc(ptls->hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    if (!fOpenChanged)
    {
        DWORD fOnOff;
        hr = GetCompartmentDWORD(ptls->tim,
                                 GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                 &fOnOff, FALSE);
        if (SUCCEEDED(hr)) {


            if (!_ImmIfIME->IsRealIme())
            {
                imc->fOpen = (BOOL) ! ! fOnOff;

                SendMessage(imc->hWnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0L);
            }

            //
            // Direct input mode support for Satori.
            // When user switch to direct input mode with composition string,
            // we want finalize composition string.
            //
            if (! imc->fOpen) {
                CAImeContext* _pAImeContext = imc->m_pAImeContext;
                ASSERT(_pAImeContext != NULL);
                if (_pAImeContext == NULL)
                    return E_FAIL;

                if (_pAImeContext->m_fStartComposition) {
                    //
                    // finalize the composition before letting the world see this keystroke
                    //
                    _ImmIfIME->_CompComplete(imc);
                }
            }
        }
    }

    if ((PRIMARYLANGID(langid) == LANG_KOREAN))
    {
        DWORD fdwConvMode;

        hr = GetCompartmentDWORD(ptls->tim,
                                 GUID_COMPARTMENT_KORIMX_CONVMODE,
                                 &fdwConvMode,
                                 FALSE);
        if (SUCCEEDED(hr))
        {
            switch (fdwConvMode)
            {
                // Korean TIP ALPHANUMERIC Mode
                case KORIMX_ALPHANUMERIC_MODE:
                    imc->fdwConversion = IME_CMODE_ALPHANUMERIC;
                    break;

                // Korean TIP HANGUL Mode
                case KORIMX_HANGUL_MODE:
                    imc->fdwConversion = IME_CMODE_HANGUL;
                    break;

                // Korean TIP JUNJA Mode
                case KORIMX_JUNJA_MODE:
                    imc->fdwConversion = IME_CMODE_FULLSHAPE;
                    break;

                // Korean TIP HANGUL/JUNJA Mode
                case KORIMX_HANGULJUNJA_MODE:
                    imc->fdwConversion = IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE;
                    break;
            }
        }
    }

    return hr;
}

CCompartmentEventSinkCallBack::CCompartmentEventSinkCallBack(
    ImmIfIME* pImmIfIME) : m_pImmIfIME(pImmIfIME),
                           CCompartmentEventSink(CompartmentEventSinkCallback, NULL)
{
    m_pImmIfIME->AddRef();
};

CCompartmentEventSinkCallBack::~CCompartmentEventSinkCallBack(
    )
{
    m_pImmIfIME->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\cime.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cime.h

Abstract:

    This file defines the IMCLock / IMCCLock Class.

Author:

Revision History:

Notes:

--*/


#ifndef CIME_H
#define CIME_H

#include "idebug.h"
#include "template.h"

class CAImeContext;

#define  _ENABLE_CAIME_CONTEXT_
#include "imclock.h"


const int MAXCAND = 256;
const int CANDPERPAGE = 9;


class IMCLock : public _IMCLock
{
public:
    IMCLock(HIMC hImc=NULL);
    virtual ~IMCLock() {
        if (m_inputcontext) {
            _UnlockIMC(m_himc);
        }
    }

    // virtual InternalIMCCLock
    HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT_AIMM12** ppIMC);
    HRESULT _UnlockIMC(HIMC hIMC);

    void InitContext();
    BOOL ClearCand();

    void GenerateMessage();

    BOOL ValidCompositionString();

private:
    // Do not allow to make a copy
    IMCLock(IMCLock&) { }
};


class InternalIMCCLock : public _IMCCLock
{
public:
    InternalIMCCLock(HIMCC hImcc = NULL);
    virtual ~InternalIMCCLock() {
        if (m_pimcc) {
            _UnlockIMCC(m_himcc);
        }
    }

    // virtual InternalIMCCLock
    HRESULT _LockIMCC(HIMCC hIMCC, void** ppv);
    HRESULT _UnlockIMCC(HIMCC hIMCC);

private:
    // Do not allow to make a copy
    InternalIMCCLock(InternalIMCCLock&) { }
};


template <class T>
class IMCCLock : public InternalIMCCLock
{
public:
    IMCCLock(HIMCC hImcc) : InternalIMCCLock(hImcc) {};

    T* GetBuffer() { return (T*)m_pimcc; }

    operator T*() { return (T*)m_pimcc; }

    T* operator->() {
        ASSERT(m_pimcc);
        return (T*)m_pimcc;
    }

private:
    // Do not allow to make a copy
    IMCCLock(IMCCLock<T>&) { }
};


#endif // CIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\candpos.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    candpos.cpp

Abstract:

    This file implements the CCandidatePosition Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "candpos.h"
#include "a_context.h"
#include "ctxtcomp.h"

HRESULT
CCandidatePosition::GetCandidatePosition(
    OUT RECT* out_rcArea
    )
{
    IMTLS *ptls;

    ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    HRESULT hr;
    IMCLock imc(ptls->hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    ::SetRect(out_rcArea, 0, 0, 0, 0);

    LANGID langid;
    ptls->pAImeProfile->GetLangId(&langid);
#if 0
    //
    // Simplified Chinese TIP's Candidate window create ic and Push it.
    // AIMM can know candidate window status.
    // If it opened, we returns position of imc->cfCandForm.
    // Not use QueryCharPos() because it returns position of Reading window.
    //
    if (langid == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        if (_pAImeContext->m_fOpenCandidateWindow) {
            if (imc->cfCandForm[0].dwStyle != CFS_DEFAULT && imc->cfCandForm[0].dwStyle != CFS_EXCLUDE) {

#if 0
                //
                // Chinese TIP needs rectangle
                //
                IMECHARPOSITION ip = {0};
                ip.dwSize = sizeof(IMECHARPOSITION);

                if (QueryCharPos(ptls, imc, &ip)) {
                    //
                    // Sure. Support "query positioning".
                    //
                    RECT rect;
                    hr = GetRectFromApp(ptls,
                                        imc,
                                        &rect);    // rect = screen coordinate.
                    if (SUCCEEDED(hr)) {
                        MapWindowPoints(HWND_DESKTOP, imc->hWnd, (LPPOINT)&rect, sizeof(RECT)/sizeof(POINT));
                        hr = GetRectFromHIMC(imc,
                                             CFS_EXCLUDE,
                                             &imc->cfCandForm[0].ptCurrentPos,
                                             &rect,
                                             out_rcArea);
                        if (SUCCEEDED(hr))
                            return hr;
                    }
                }
#endif
                //
                // Chinese TIP needs rectangle
                //
                hr = GetRectFromCompFont(ptls,
                                         imc,
                                         &imc->cfCandForm[0].ptCurrentPos,
                                         out_rcArea);
                if (SUCCEEDED(hr))
                    return hr;

            }

            hr = GetRectFromHIMC(imc,
                                 imc->cfCandForm[0].dwStyle,
                                 &imc->cfCandForm[0].ptCurrentPos,
                                 &imc->cfCandForm[0].rcArea,
                                 out_rcArea);

            return hr;
        }
    }
#endif

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    //
    // Is apps support "query positioning" ?
    //
    CAImeContext::IME_QUERY_POS qpos;
    if (SUCCEEDED(_pAImeContext->InquireIMECharPosition(imc, &qpos)) &&
        qpos == CAImeContext::IME_QUERY_POS_YES) {
        //
        // Sure. Support "query positioning".
        //
        hr = GetRectFromApp(ptls,
                            imc,
                            langid,
                            out_rcArea);
        if (SUCCEEDED(hr))
            return hr;
        else
            _pAImeContext->ResetIMECharPosition(imc);
    }

    if ( (PRIMARYLANGID(langid) == LANG_CHINESE) &&
         (imc->cfCandForm[0].dwIndex == -1))
    {
        //
        // Assume CHT/CHS's Reading Window Position.
        //
        hr = GetRectFromHIMC(imc,
                             imc->cfCompForm.dwStyle,
                             &imc->cfCompForm.ptCurrentPos,
                             &imc->cfCompForm.rcArea,
                             out_rcArea);
        return hr;
    }

    hr = GetRectFromHIMC(imc,
                         imc->cfCandForm[0].dwStyle,
                         &imc->cfCandForm[0].ptCurrentPos,
                         &imc->cfCandForm[0].rcArea,
                         out_rcArea);

    return hr;
}

HRESULT
CCandidatePosition::GetRectFromApp(
    IN IMTLS* ptls,
    IN IMCLock& imc,
    IN LANGID langid,
    OUT RECT* out_rcArea
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    IMECHARPOSITION ip = {0};
    ip.dwSize = sizeof(IMECHARPOSITION);

    CWCompCursorPos wCursorPosition;
    HRESULT hr;

    if (PRIMARYLANGID(langid) == LANG_JAPANESE &&
        (hr = FindAttributeInCompositionString(imc,
                                               ATTR_TARGET_CONVERTED,
                                               wCursorPosition)) == S_OK) {
        ip.dwCharPos = wCursorPosition.GetAt(0);
    }
    else {
        if (SUCCEEDED(hr = GetCursorPosition(imc,
                                             wCursorPosition))) {
            CWCompCursorPos wStartSelection;
            CWCompCursorPos wEndSelection;
            if (SUCCEEDED(hr = GetSelection(imc,
                                            wStartSelection, wEndSelection))) {
                ip.dwCharPos = min(wCursorPosition.GetAt(0),
                                   wStartSelection.GetAt(0));
            }
            else {
                ip.dwCharPos = wCursorPosition.GetAt(0);
            }
        }
        else {
            ip.dwCharPos = 0;
        }
    }

    if (SUCCEEDED(hr = _pAImeContext->RetrieveIMECharPosition(imc, &ip))) {
        switch (DocumentDirection(imc)) {
            case DIR_TOP_BOTTOM:
                ::SetRect(out_rcArea,
                          ip.pt.x - ip.cLineHeight,               // left
                          ip.pt.y,                                // top
                          ip.pt.x,                                // right
                          max(ip.pt.y, ip.rcDocument.bottom));    // bottom
                break;
            case DIR_BOTTOM_TOP:
                ::SetRect(out_rcArea,
                          ip.pt.x - ip.cLineHeight,               // left
                          min(ip.pt.y, ip.rcDocument.top),        // top
                          ip.pt.x,                                // right
                          ip.pt.y);                               // bottom
                break;
            case DIR_RIGHT_LEFT:
                ::SetRect(out_rcArea,
                          min(ip.pt.x, ip.rcDocument.left),       // left
                          ip.pt.y,                                // top
                          ip.pt.x,                                // right
                          ip.pt.y + ip.cLineHeight);              // bottom
                break;
            case DIR_LEFT_RIGHT:
                ::SetRect(out_rcArea,
                          ip.pt.x,                                // left
                          ip.pt.y,                                // top
                          max(ip.pt.x, ip.rcDocument.right),      // right
                          ip.pt.y + ip.cLineHeight);              // bottom
                break;
        }
    }

    return hr;
}

HRESULT
CCandidatePosition::GetRectFromHIMC(
    IN IMCLock& imc,
    IN DWORD  dwStyle,
    IN POINT* ptCurrentPos,
    IN RECT*  rcArea,
    OUT RECT*  out_rcArea
    )
{
    HWND hWnd = imc->hWnd;

    POINT pt;

    if (dwStyle == CFS_DEFAULT)
    {
        ::SystemParametersInfo(SPI_GETWORKAREA,
                               0,
                               out_rcArea,
                               0);
        out_rcArea->left   = out_rcArea->right;
        out_rcArea->top    = out_rcArea->bottom;
    }
    else if (dwStyle == CFS_RECT)
    {
        out_rcArea->left   = ptCurrentPos->x;
        out_rcArea->right  = ptCurrentPos->x;
        out_rcArea->top    = ptCurrentPos->y;
        out_rcArea->bottom = ptCurrentPos->y;
    }
    else if (dwStyle == CFS_CANDIDATEPOS)
    {
        IMTLS *ptls;

        ptls = IMTLS_GetOrAlloc();
        if (ptls == NULL)
            return E_FAIL;

        //
        // We needs rectangle
        //
        return GetRectFromCompFont(ptls,
                                   imc,
                                   ptCurrentPos,
                                   out_rcArea);
    }
    else if (dwStyle == CFS_EXCLUDE)
    {
        GetCandidateArea(imc, dwStyle, ptCurrentPos, rcArea, out_rcArea);
    }

    pt.x = pt.y = 0;
    ClientToScreen(hWnd, &pt);
    out_rcArea->left   += pt.x;
    out_rcArea->right  += pt.x;
    out_rcArea->top    += pt.y;
    out_rcArea->bottom += pt.y;

    return S_OK;
}

HRESULT
CCandidatePosition::GetRectFromCompFont(
    IN IMTLS* ptls,
    IN IMCLock& imc,
    IN POINT* ptCurrentPos,
    OUT RECT* out_rcArea
    )
{
    HRESULT hr = E_FAIL;

    HDC dc = ::GetDC(imc->hWnd);
    if (dc != NULL) {

        LOGFONTA logfont;
        if (SUCCEEDED(ptls->pAImm->GetCompositionFontA((HIMC)imc, &logfont))) {

            HFONT font = ::CreateFontIndirectA( &logfont );
            if (font != NULL) {

                HFONT prev_font;
                prev_font = (HFONT)::SelectObject(dc, font);

                TEXTMETRIC metric;
                if (::GetTextMetrics(dc, &metric)) {

                    int font_cx = metric.tmMaxCharWidth;
                    int font_cy = metric.tmHeight;

                    switch (DocumentDirection(imc)) {
                        case DIR_TOP_BOTTOM:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x - font_cx,              // left
                                      ptCurrentPos->y,                        // top
                                      ptCurrentPos->x,                        // right
                                      ptCurrentPos->y + font_cy);             // bottom
                            break;
                        case DIR_BOTTOM_TOP:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x,                        // left
                                      ptCurrentPos->y - font_cy,              // top
                                      ptCurrentPos->x + font_cx,              // right
                                      ptCurrentPos->y);                       // bottom
                            break;
                        case DIR_RIGHT_LEFT:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x - font_cx,              // left
                                      ptCurrentPos->y - font_cy,              // top
                                      ptCurrentPos->x,                        // right
                                      ptCurrentPos->y);                       // bottom
                            break;
                        case DIR_LEFT_RIGHT:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x,                        // left
                                      ptCurrentPos->y,                        // top
                                      ptCurrentPos->x + font_cx,              // right
                                      ptCurrentPos->y + font_cy);             // bottom
                            break;
                    }

                    POINT pt;
                    pt.x = pt.y = 0;
                    ClientToScreen(imc->hWnd, &pt);
                    out_rcArea->left   += pt.x;
                    out_rcArea->right  += pt.x;
                    out_rcArea->top    += pt.y;
                    out_rcArea->bottom += pt.y;

                    hr = S_OK;
                }

                ::SelectObject(dc, prev_font);
                ::DeleteObject(font);
            }
        }

        ::ReleaseDC(imc->hWnd, dc);
    }

    return hr;
}


/*
 *
 *  dwStyle == CFS_EXCLUDE
 *
 */

HRESULT
CCandidatePosition::GetCandidateArea(
    IN IMCLock& imc,
    IN DWORD dwStyle,
    IN POINT* ptCurrentPos,
    IN RECT* rcArea,
    OUT RECT* out_rcArea
    )
{
    POINT pt = *ptCurrentPos;
    RECT rc = *rcArea;

    switch (DocumentDirection(imc)) {
        case DIR_TOP_BOTTOM:
            ::SetRect(out_rcArea,
                      min(pt.x, rcArea->left),     // left
                      max(pt.y, rcArea->top),      // top
                      max(pt.x, rcArea->right),    // right
                      rcArea->bottom);             // bottom
            break;
        case DIR_BOTTOM_TOP:
            ::SetRect(out_rcArea,
                      min(pt.x, rcArea->left),     // left
                      rcArea->top,                 // top
                      max(pt.x, rcArea->right),    // right
                      min(pt.y, rcArea->bottom));  // bottom
            break;
        case DIR_RIGHT_LEFT:
            ::SetRect(out_rcArea,
                      rcArea->left,                // left
                      min(pt.y, rcArea->top),      // top
                      min(pt.x, rcArea->right),    // right
                      max(pt.y, rcArea->bottom));  // bottom
            break;
        case DIR_LEFT_RIGHT:
            ::SetRect(out_rcArea,
                      max(pt.x, rcArea->left),     // left
                      min(pt.y, rcArea->top),      // top
                      rcArea->right,               // right
                      max(pt.y, rcArea->bottom));  // bottom
            break;
    }

    return S_OK;
}

HRESULT
CCandidatePosition::FindAttributeInCompositionString(
    IN IMCLock& imc,
    IN BYTE target_attribute,
    OUT CWCompCursorPos& wCursorPosition
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext != NULL) {

        CWCompString    wCompString;
        CWCompAttribute wCompAttribute;

        if (SUCCEEDED(hr = _pAImeContext->GetTextAndAttribute((HIMC)imc,
                                                              &wCompString, &wCompAttribute))) {

            LONG num_of_written = (LONG)wCompAttribute.ReadCompData();
            if (num_of_written == 0)
                return E_FAIL;

            BYTE* attribute = new BYTE[ num_of_written ];
            if (attribute != NULL) {
                //
                // Get attribute data.
                //
                wCompAttribute.ReadCompData(attribute, num_of_written);

                LONG start_position = 0;

                LONG ich = 0;
                LONG attr_size = num_of_written;
                while (ich < attr_size && attribute[ich] != target_attribute)
                    ich++;

                if (ich < attr_size) {
                    start_position = ich;
                }
                else {
                    //
                    // If not hit with target_attribute, then returns S_FALSE.
                    // 
                    hr = S_FALSE;
                }

                wCursorPosition.Set(start_position);

                delete [] attribute;
            }
        }
    }

    return hr;
}

HRESULT
CCandidatePosition::GetCursorPosition(
    IN IMCLock& imc,
    OUT CWCompCursorPos& wCursorPosition
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext != NULL) {
        hr = _pAImeContext->GetCursorPosition((HIMC)imc, &wCursorPosition);
    }

    return hr;
}

HRESULT
CCandidatePosition::GetSelection(
    IN IMCLock& imc,
    OUT CWCompCursorPos& wStartSelection,
    OUT CWCompCursorPos& wEndSelection
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext != NULL) {
        hr = _pAImeContext->GetSelection((HIMC)imc, wStartSelection, wEndSelection);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\caime.h ===
//+---------------------------------------------------------------------------
//
//  File:       caime.h
//
//  Contents:   CAIME
//
//----------------------------------------------------------------------------

#ifndef CAIME_H
#define CAIME_H

#include "imtls.h"

typedef struct _PauseCookie
{
    DWORD dwCookie;
    struct _PauseCookie *next;
} PauseCookie;

//+---------------------------------------------------------------------------
//
// CAIME
//
//----------------------------------------------------------------------------

class __declspec(novtable) CAIME : public IActiveIME_Private,
                                   public IServiceProvider
{
public:
    CAIME();
    virtual ~CAIME();

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

#if 0
    //
    // Wrappers
    //

    HIMC GetContext(HWND hWnd)
    {
        HIMC hIMC;

        _pActiveIMM->GetContext(hWnd, &hIMC);

        return hIMC;
    }

    HIMC CreateContext()
    {
        HIMC hIMC;

        _pActiveIMM->CreateContext(&hIMC);

        return hIMC;
    }

    BOOL DestroyContext(HIMC hIMC)
    {
        return SUCCEEDED(_pActiveIMM->DestroyContext(hIMC));
    }

    HIMC AssociateContext(HWND hWnd, HIMC hIMC)
    {
        HIMC hOrgIMC;

        _pActiveIMM->AssociateContext(hWnd, hIMC, &hOrgIMC);

        return hOrgIMC;
    }

    LPINPUTCONTEXT LockIMC(HIMC hIMC)
    {
        LPINPUTCONTEXT pic;

        _pActiveIMM->LockIMC(hIMC, &pic);

        return pic;
    }

    BOOL UnlockIMC(HIMC hIMC)
    {
        return (_pActiveIMM->UnlockIMC(hIMC) == S_OK);
    }

    LPVOID LockIMCC(HIMCC hIMCC)
    {
        void *pv;

        _pActiveIMM->LockIMCC(hIMCC, &pv);

        return pv;
    }

    BOOL UnlockIMCC(HIMCC hIMCC)
    {
        return (_pActiveIMM->UnlockIMCC(hIMCC) == S_OK);
    }

    HIMCC CreateIMCC(DWORD dwSize)
    {
        HIMCC hIMCC;

        _pActiveIMM->CreateIMCC(dwSize, &hIMCC);

        return hIMCC;
    }

    HIMCC DestroyIMCC(HIMCC hIMCC)
    {
        return SUCCEEDED(_pActiveIMM->DestroyIMCC(hIMCC)) ? NULL : hIMCC;
    }

    DWORD GetIMCCSize(HIMCC hIMCC)
    {
        DWORD dwSize;

        _pActiveIMM->GetIMCCSize(hIMCC, &dwSize);

        return dwSize;
    }

    HIMCC ReSizeIMCC(HIMCC hIMCC, DWORD dwSize)
    {
        HIMCC hIMCC2;

        _pActiveIMM->ReSizeIMCC(hIMCC, dwSize, &hIMCC2);

        return hIMCC2;
    }

    BOOL GenerateMessage(HIMC hIMC)
    {
        return (_pActiveIMM->GenerateMessage(hIMC) == S_OK);
    }

    DWORD GetGuideLineA(HIMC hIMC, DWORD dwIndex, LPSTR szBuffer, DWORD dwBufLen)
    {
        DWORD dwResult;

        _pActiveIMM->GetGuideLineA(hIMC, dwIndex, dwBufLen, szBuffer, &dwResult);

        return dwResult;
    }

    BOOL SetCandidateWindow(HIMC hIMC, LPCANDIDATEFORM lpCandidateForm)
    {
        return (_pActiveIMM->SetCandidateWindow(hIMC, lpCandidateForm) == S_OK);
    }

    BOOL GetOpenStatus(HIMC hIMC)
    {
        return (_pActiveIMM->GetOpenStatus(hIMC) == S_OK);
    }

    BOOL SetOpenStatus(HIMC hIMC, BOOL fOpen)
    {
        return (_pActiveIMM->SetOpenStatus(hIMC, fOpen) == S_OK);
    }

    BOOL GetConversionStatus(HIMC hIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
    {
        return (_pActiveIMM->GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence) == S_OK);
    }

    BOOL SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence)
    {
        return (_pActiveIMM->SetConversionStatus(hIMC, fdwConversion, fdwSentence) == S_OK);
    }

    HWND GetDefaultIMEWnd(HWND hWnd)
    {
        HWND hDefWnd;

        _pActiveIMM->GetDefaultIMEWnd(hWnd, &hDefWnd);

        return hDefWnd;
    }

    BOOL GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL)
    {
        return SUCCEEDED(_pActiveIMM->GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL));
    }

    HWND CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y)
    {
        HWND hWnd;

        _pActiveIMM->CreateSoftKeyboard(uType, hOwner, x, y, &hWnd);

        return hWnd;
    }

    BOOL DestroySoftKeyboard(HWND hSoftKbdWnd)
    {
        return SUCCEEDED(_pActiveIMM->DestroySoftKeyboard(hSoftKbdWnd));
    }

    BOOL ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow)
    {
        return SUCCEEDED(_pActiveIMM->ShowSoftKeyboard(hSoftKbdWnd, nCmdShow));
    }

    UINT GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, CANDIDATELIST *lpDst, UINT uBufLen, UINT uFlag)
    {
        UINT uCopied;

        _pActiveIMM->GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, &uCopied);

        return uCopied;
    }

    LRESULT EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData)
    {
        LRESULT lResult;

        _pActiveIMM->EscapeA(hKL, hIMC, uEscape, lpData, &lResult);

        return lResult;
    }

    BOOL SetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
    {
        return SUCCEEDED(_pActiveIMM->SetStatusWindowPos(hIMC, lpptPos));
    }
#endif

protected:

    IActiveIMMIME_Private* m_pIActiveIMMIME;

    PauseCookie *_pPauseCookie;
    int _cRef;

public:
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv) = 0;
};

#endif // CAIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\cmpevcb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmpevcb.h

Abstract:

    This file defines the CCompartmentEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CMPEVCB_H_
#define _CMPEVCB_H_

class ImmIfIME;

class CCompartmentEventSinkCallBack : public CCompartmentEventSink
{
public:
    CCompartmentEventSinkCallBack(ImmIfIME* pImmIfIME);
    virtual ~CCompartmentEventSinkCallBack();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // Callbacks
    //
private:
    static HRESULT CompartmentEventSinkCallback(void* pv, REFGUID rguid);

    ImmIfIME     *m_pImmIfIME;
};

#endif // _CMPEVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\cic.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cic.cpp

Abstract:

    This file implements the ImmIfIME Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "globals.h"
#include "imeapp.h"
#include "immif.h"
#include "profile.h"


HRESULT
ImmIfIME::QueryService(
    REFGUID guidService,
    REFIID riid,
    void **ppv
    )
{
    if (ppv == NULL) {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF))
        return E_INVALIDARG /*SVC_E_UNKNOWNSERVICE*/; // SVC_E_UNKNOWNSERVICE is in msdn, but not any nt source/headers

    if (IsEqualIID(riid, IID_ITfThreadMgr)) {
        if (m_tim) {
            *ppv = SAFECAST(m_tim, ITfThreadMgr*);
            m_tim->AddRef();
            return S_OK;
        }
    }
    else {
        IMTLS *ptls = IMTLS_GetOrAlloc();

        if (ptls == NULL)
            return E_FAIL;

        IMCLock imc(ptls->hIMC);
        HRESULT hr;
        if (FAILED(hr=imc.GetResult()))
            return hr;

        if (IsEqualIID(riid, IID_ITfDocumentMgr)) {
            ITfDocumentMgr *pdim = GetDocumentManager(imc).GetPtr();
            if (pdim) {
                *ppv = SAFECAST(pdim, ITfDocumentMgr*);
                pdim->AddRef();
                return S_OK;
            }
        }
        else if (IsEqualIID(riid, IID_ITfContext)) {
            ITfContext *pic = GetInputContext(imc).GetPtr();

            if (pic) {
                *ppv = SAFECAST(pic, ITfContext*);
                pic->AddRef();
                return S_OK;
            }
        }
    }

    DebugMsg(TF_ERROR, "QueryService: cannot find the interface. riid=%p", riid);

    return E_NOINTERFACE;
}


HRESULT
ImmIfIME::InitIMMX(
    )
{
    ITfThreadMgr *tim;
    IMTLS *ptls;

    DebugMsg(TF_FUNC, "InitIMMX: entered. :: TID=%x", GetCurrentThreadId());

    HRESULT hr;

    if (m_fCicInit)
        return S_OK;

    Assert(m_tim == NULL);
    Assert(m_AImeProfile == NULL);
    Assert(m_pkm == NULL);
    Assert(m_tfClientId == TF_CLIENTID_NULL);

    ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    //
    // Create ITfThreadMgr instance.
    //
    if (ptls->tim == NULL)
    {
        if (FindAtom(TF_ENABLE_PROCESS_ATOM) && ! FindAtom(AIMM12_PROCESS_ATOM))
        {
            //
            // This is CTF aware application.
            //
            return E_NOINTERFACE;
        }

        //
        // This is AIMM1.2 aware application.
        //
        AddAtom(AIMM12_PROCESS_ATOM);
        m_fAddedProcessAtom = TRUE;

        //
        // ITfThreadMgr is per thread instance.
        //
        hr = TF_CreateThreadMgr(&tim);

        if (hr != S_OK)
        {
            Assert(0); // couldn't create tim!
            goto ExitError;
        }

        hr = tim->QueryInterface(IID_ITfThreadMgr_P, (void **)&m_tim);
        tim->Release();

        if (hr != S_OK || m_tim == NULL)
        {
            Assert(0); // couldn't find ITfThreadMgr_P
            m_tim = NULL;
            goto ExitError;
        }
        Assert(ptls->tim == NULL);
        ptls->tim = m_tim;                    // Set ITfThreadMgr instance in the TLS data.
        ptls->tim->AddRef();
    }
    else
    {
        m_tim = ptls->tim;
        m_tim->AddRef();
    }

    //
    // Create CAImeProfile instance.
    //
    if (ptls->pAImeProfile == NULL)
    {
        //
        // IAImeProfile is per thread instance.
        //
        hr = CAImeProfile::CreateInstance(NULL,
                                          IID_IAImeProfile,
                                          (void**) &m_AImeProfile);
        if (FAILED(hr))
        {
            Assert(0); // couldn't create profile
            m_AImeProfile = NULL;
            goto ExitError;
        }
        Assert(ptls->pAImeProfile == m_AImeProfile); // CreateInst will set tls
    }
    else
    {
        m_AImeProfile = ptls->pAImeProfile;
        m_AImeProfile->AddRef();
    }

    //
    // get the keystroke manager ready
    //
    if (FAILED(::GetService(m_tim, IID_ITfKeystrokeMgr, (IUnknown **)&m_pkm))) {
        Assert(0); // couldn't get ksm!
        goto ExitError;
    }

    // cleanup/error code assumes this is the last thing we do, doesn't call
    // UninitDAL on error
    if (FAILED(InitDisplayAttrbuteLib(&_libTLS)))
    {
        Assert(0); // couldn't init lib!
        goto ExitError;
    }

    m_fCicInit = TRUE;

    return S_OK;

ExitError:
    UnInitIMMX();
    return E_FAIL;
}


void
ImmIfIME::UnInitIMMX(
    )
{
    IMTLS *ptls;

    DebugMsg(TF_FUNC, TEXT("ImmIfIME::UnInitIMMX :: TID=%x"), GetCurrentThreadId());

    // clear the display lib
    UninitDisplayAttrbuteLib(&_libTLS);

    TFUninitLib_Thread(&_libTLS);

    // clear the keystroke mgr
    SafeReleaseClear(m_pkm);

    ptls = IMTLS_GetOrAlloc();

    // clear the profile
    if (m_AImeProfile != NULL)
    {
        SafeReleaseClear(m_AImeProfile);
        if (ptls != NULL)
        {
            SafeReleaseClear(ptls->pAImeProfile);
        }
    }

    // clear empty dim.
    SafeReleaseClear(m_dimEmpty);

    // clear the thread mgr
    if (m_tim != NULL)
    {
        SafeReleaseClear(m_tim);
        if (ptls != NULL)
        {
            SafeReleaseClear(ptls->tim);
        }

        //
        // Remove AIMM1.2 aware application ATOM.
        //
        ATOM atom;
        if (m_fAddedProcessAtom &&
            (atom = FindAtom(AIMM12_PROCESS_ATOM)))
        {
            DeleteAtom(atom);
            m_fAddedProcessAtom = FALSE;
        }
    }

    m_fCicInit = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSIMTF"
#define SZ_MODULE       "MSIMTF"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\editcomp.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editcomp.h

Abstract:

    This file defines the EditCompositionString Class.

Author:

Revision History:

Notes:

--*/

#ifndef _EDITCOMP_H_
#define _EDITCOMP_H_

/////////////////////////////////////////////////////////////////////////////
// EditCompositionString

class EditCompositionString
{
public:
    HRESULT SetString(IMCLock& imc,
                      CWCompString* CompStr,
                      CWCompAttribute* CompAttr,
                      CWCompClause* CompClause,
                      CWCompCursorPos* CompCursorPos,
                      CWCompDeltaStart* CompDeltaStart,
                      CWCompTfGuidAtom* CompGuid,
                      OUT BOOL* lpbBufferOverflow,
                      CWCompString* CompReadStr = NULL,
                      CWCompAttribute* CompReadAttr = NULL,
                      CWCompClause* CompReadClause = NULL,
                      CWCompString* ResultStr = NULL,
                      CWCompClause* ResultClause = NULL,
                      CWCompString* ResultReadStr = NULL,
                      CWCompClause* ResultReadClause = NULL,
                      CWInterimString* InterimStr = NULL,
                      // n.b. ResultRead is not supported for now...
                      BOOL fGenerateMessage = TRUE);

private:

    HRESULT _MakeCompositionData(IMCLock& imc,
                                 CWCompString* CompStr,
                                 CWCompAttribute* CompAttr,
                                 CWCompClause* CompClause,
                                 CWCompCursorPos* CompCursorPos,
                                 CWCompDeltaStart* CompDeltaStart,
                                 CWCompTfGuidAtom* CompGuid,
                                 CWCompString* CompReadStr,
                                 CWCompAttribute* CompReadAttr,
                                 CWCompClause* CompReadClause,
                                 CWCompString* ResultStr,
                                 CWCompClause* ResultClause,
                                 CWCompString* ResultReadStr,
                                 CWCompClause* ResultReadClause,
                                 OUT LPARAM* lpdwFlag,
                                 OUT BOOL* lpbBufferOverflow);

    HRESULT _MakeInterimData(IMCLock& imc,
                             CWInterimString* InterimStr,
                             LPARAM* lpdwFlag);

    HRESULT _GenerateHanja(IMCLock& imc,
                           CWCompString*,
                           BOOL fGenerateMessage);

};

#endif // _EDITCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\editses.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editses.h

Abstract:

    This file defines the EditSession Class.

Author:

Revision History:

Notes:

--*/

#ifndef _EDITSES_H_
#define _EDITSES_H_

#include "immif.h"
#include "editcomp.h"


typedef enum {
    ESCB_HANDLETHISKEY = 1,
    ESCB_COMPCOMPLETE,
    ESCB_COMPCANCEL,
    ESCB_UPDATECOMPOSITIONSTRING,
    ESCB_REPLACEWHOLETEXT,
    ESCB_RECONVERTSTRING,
    ESCB_CLEARDOCFEEDBUFFER,
    ESCB_GETTEXTANDATTRIBUTE,
    ESCB_QUERYRECONVERTSTRING,
    ESCB_CALCRANGEPOS,
    ESCB_GETSELECTION,
    ESCB_GET_READONLY_PROP_MARGIN,
    ESCB_GET_CURSOR_POSITION,
    ESCB_GET_ALL_TEXT_RANGE
} ESCB;


/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSessionCallBack

class ImmIfEditSession;

class ImmIfEditSessionCallBack
{
public:
    ImmIfEditSessionCallBack() { };
    virtual ~ImmIfEditSessionCallBack() { };

    virtual HRESULT CallBackRoutine(TfEditCookie ec,
                                    ImmIfEditSession* pes,
                                    Interface_Attach<ImmIfIME> ImmIfIme) = 0;
protected:
    HRESULT GetAllTextRange(TfEditCookie ec,
                            Interface_Attach<ITfContext>& ic,
                            Interface<ITfRange>* range,
                            LONG* lpTextLength,
                            TF_HALTCOND* lpHaltCond=NULL);

    HRESULT SetTextInRange(TfEditCookie ec,
                           ITfRange* range,
                           LPWSTR psz,
                           DWORD len,
                           CAImeContext* pAImeContext);

    HRESULT ClearTextInRange(TfEditCookie ec,
                             ITfRange* range,
                             CAImeContext* pAImeContext);

    HRESULT GetReadingString(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             CWCompString& reading_string,
                             CWCompClause& reading_clause);

    HRESULT GetReadingString(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             ITfRange* range,
                             CWCompString& reading_string,
                             CWCompClause& reading_clause);

    HRESULT CompClauseToResultClause(IMCLock& imc,
                                     CWCompClause& result_clause, UINT cch);

    HRESULT _GetTextAndAttribute(LIBTHREAD *pLibTLS,
                                 TfEditCookie ec,
                                 IMCLock& imc,
                                 Interface_Attach<ITfContext>& ic,
                                 Interface<ITfRange>& range,
                                 CWCompString& CompStr,
                                 CWCompAttribute& CompAttr,
                                 BOOL bInWriteSession)
    {
        CWCompClause CompClause;
        CWCompTfGuidAtom CompGuid;
        CWCompString CompReadStr;
        CWCompClause CompReadClause;
        CWCompString ResultStr;
        CWCompClause ResultClause;
        CWCompString ResultReadStr;
        CWCompClause ResultReadClause;
        return _GetTextAndAttribute(pLibTLS, ec, imc, ic, range,
                                    CompStr, CompAttr, CompClause,
                                    CompGuid,
                                    CompReadStr, CompReadClause,
                                    ResultStr, ResultClause,
                                    ResultReadStr, ResultReadClause,
                                    bInWriteSession);
    }

    HRESULT _GetTextAndAttribute(LIBTHREAD *pLibTLS,
                                 TfEditCookie ec,
                                 IMCLock& imc,
                                 Interface_Attach<ITfContext>& ic,
                                 Interface<ITfRange>& range,
                                 CWCompString& CompStr,
                                 CWCompAttribute& CompAttr,
                                 CWCompClause& CompClause,
                                 CWCompTfGuidAtom& CompGuid,
                                 CWCompString& CompReadStr,
                                 CWCompClause& CompReadCls,
                                 CWCompString& ResultStr,
                                 CWCompClause& ResultClause,
                                 CWCompString& ResultReadStr,
                                 CWCompClause& ResultReadClause,
                                 BOOL bInWriteSession);

    HRESULT _GetTextAndAttributeGapRange(LIBTHREAD *pLibTLS,
                                         TfEditCookie ec,
                                         IMCLock& imc,
                                         Interface<ITfRange>& gap_range,
                                         LONG result_comp,
                                         CWCompString& CompStr,
                                         CWCompAttribute& CompAttr,
                                         CWCompClause& CompClause,
                                         CWCompTfGuidAtom& CompGuid,
                                         CWCompString& ResultStr,
                                         CWCompClause& ResultClause);

    HRESULT _GetTextAndAttributePropertyRange(LIBTHREAD *pLibTLS,
                                              TfEditCookie ec,
                                              IMCLock& imc,
                                              ITfRange* pPropRange,
                                              BOOL fDispAttribute,
                                              LONG result_comp,
                                              BOOL bInWriteSession,
                                              TF_DISPLAYATTRIBUTE da,
                                              TfGuidAtom guidatom,
                                              CWCompString& CompStr,
                                              CWCompAttribute& CompAttr,
                                              CWCompClause& CompClause,
                                              CWCompTfGuidAtom& CompGuid,
                                              CWCompString& ResultStr,
                                              CWCompClause& ResultClause);

    HRESULT _GetNoDisplayAttributeRange(LIBTHREAD *pLibTLS,
                                        TfEditCookie ec,
                                        Interface_Attach<ITfContext>& ic,
                                        Interface<ITfRange>& range,
                                        Interface<ITfRange>& no_display_attribute_range);

    HRESULT _GetCursorPosition(TfEditCookie ec,
                               IMCLock& imc,
                               Interface_Attach<ITfContext>& ic,
                               CWCompCursorPos& CompCursorPos,
                               CWCompAttribute& CompAttr);

private:
    typedef struct _EnumReadingPropertyArgs
    {
        Interface<ITfProperty> Property;
        TfEditCookie ec;
        CWCompString*          reading_string;
        CWCompClause*          reading_clause;
        LONG ulClausePos;
    } EnumReadingPropertyArgs;

    //
    // Enumrate callbacks
    //
    static ENUM_RET EnumReadingPropertyCallback(ITfRange* pRange, EnumReadingPropertyArgs *pargs);

    BYTE _ConvertAttributeToImm32(TF_DA_ATTR_INFO attribute)
    {
        if (attribute == TF_ATTR_OTHER || attribute > TF_ATTR_FIXEDCONVERTED) {
            return ATTR_TARGET_CONVERTED;
        }
        else {
            return (BYTE)attribute;
        }
    }
};




/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSession

class ImmIfEditSession : public ITfEditSession
{
public:
    ImmIfEditSession(ESCB escb,
                     TfClientId tid,
                     Interface_Attach<ImmIfIME> ImmIfIme,
                     IMCLock& imc);
    ImmIfEditSession(ESCB escb,
                     TfClientId tid,
                     Interface_Attach<ImmIfIME> ImmIfIme,
                     IMCLock& imc,
                     Interface_Attach<ITfContext> pic);
private:
    void _Init(ESCB escb);

public:
    virtual ~ImmIfEditSession();

    bool Valid();
    bool Invalid() { return ! Valid(); }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback method
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

    //
    // ImmIfEditSession methods
    //
    static HRESULT EditSessionCallBack(TfEditCookie ec, ImmIfEditSession* pes)
    {
        if (pes->m_ImmIfCallBack)
            return pes->m_ImmIfCallBack->CallBackRoutine(ec, pes, pes->m_ImmIfIme);
        else
            return E_FAIL;
    }

    //
    // EditSession methods.
    //
    HRESULT RequestEditSession(DWORD dwFlags,
                               UINT uVKey=0)
    {
        HRESULT hr;
        m_state.uVKey = uVKey;
        m_ic->RequestEditSession(m_tid, this, dwFlags, &hr);
        return hr;
    }

    HRESULT RequestEditSession(DWORD dwFlags, CWCompString* pwCompStr,
                          CWCompString* pwReadCompStr=NULL, Interface<ITfRange>* pRange=NULL)
    {
        m_state.lpwCompStr     = pwCompStr;
        m_state.lpwReadCompStr = pwReadCompStr;
        m_pRange               = pRange;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags, Interface<ITfRange>* pSelection)
    {
        m_pRange             = pSelection;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWReconvertString* pwReconvStr, Interface<ITfRange>* pSelection, BOOL fDocFeedOnly)
    {
        m_state.lpwReconvStr = pwReconvStr;
        m_pRange             = pSelection;
        m_fDocFeedOnly       = fDocFeedOnly;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          Interface<ITfRangeACP>* pMouseRangeACP, LPMOUSE_RANGE_RECT pv)
    {
        m_pRangeACP          = pMouseRangeACP;
        m_state.pv           = (INT_PTR)pv;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWCompString* pwCompStr, CWCompAttribute* pwCompAttr)
    {
        m_state.lpwCompStr  = pwCompStr;
        m_state.lpwCompAttr = pwCompAttr;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags, BOOL fTerminateComp)
    {
        m_state.fTerminateComp             = fTerminateComp;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          Interface<ITfRangeACP>* pRange, LONG* cch)
    {
        m_pRangeACP = pRange;
        m_state.pv  = (INT_PTR)cch;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWCompCursorPos* pwCursorPosition)
    {
        m_state.lpwCursorPosition = pwCursorPosition;
        return RequestEditSession(dwFlags);
    }

public:
    ImmIfEditSessionCallBack*     m_ImmIfCallBack;

    Interface_Attach<ImmIfIME>    m_ImmIfIme;
    Interface_Attach<ITfContext>  m_ic;
    Interface<ITfRange>*          m_pRange;
    Interface<ITfRangeACP>*       m_pRangeACP;
    BOOL                          m_fDocFeedOnly;

    struct state {
        state(HIMC hd) : hIMC(hd) { };

        UINT                uVKey;
        HIMC                hIMC;
        CWCompString*       lpwCompStr;
        CWCompString*       lpwReadCompStr;
        CWCompAttribute*    lpwCompAttr;
        CWReconvertString*  lpwReconvStr;
        CWCompCursorPos*    lpwCursorPosition;
        INT_PTR             pv;
        BOOL                fTerminateComp;
    } m_state;

    TfClientId              m_tid;
    HRESULT                 (*m_pfnCallback)(TfEditCookie ec, ImmIfEditSession*);
    int                     m_cRef;
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfHandleThisKey

class ImmIfHandleThisKey : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return HandleThisKey(ec,
                             pes->m_state.uVKey,
                             pes->m_state.hIMC,
                             pes->m_ic,
                             ImmIfIme);
    }

    HRESULT HandleThisKey(TfEditCookie ec,
                          UINT uVKey,
                          HIMC hIMC,
                          Interface_Attach<ITfContext> ic,
                          Interface_Attach<ImmIfIME> ImmIfIme);

private:
    HRESULT ShiftSelectionToLeft(TfEditCookie rc, ITfRange *range, bool fShiftEnd = true);
    HRESULT ShiftSelectionToRight(TfEditCookie rc, ITfRange *range, bool fShiftStart = true);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionComplete

class ImmIfCompositionComplete : public ImmIfEditSessionCallBack,
                                 private EditCompositionString
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return CompComplete(ec,
                            pes->m_state.hIMC,
                            pes->m_state.fTerminateComp,
                            pes->m_ic,
                            ImmIfIme);
    }

    HRESULT CompComplete(TfEditCookie ec,
                         HIMC hIMC,
                         BOOL fTerminateComp,
                         Interface_Attach<ITfContext> ic,
                         Interface_Attach<ImmIfIME> ImmIfIme);

private:
    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWCompString* ResultStr,
                                  CWCompClause* ResultClause,
                                  CWCompString* ResultReadStr,
                                  CWCompClause* ResultReadClause)
    {
        return SetString(imc,
                         NULL, NULL, NULL,    // CompStr, CompAttr, CompCls
                         NULL, NULL,          // CompCursor, CompDeltaStart
                         NULL,                // CompGuid
                         NULL,                // lpbBufferOverflow
                         NULL, NULL, NULL,    // CompReadStr, CompReadAttr, CompReadCls
                         ResultStr, ResultClause,           // ResultStr, ResultCls
                         ResultReadStr, ResultReadClause);  // ResultReadStr, ResultReadCls
    }

};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionCancel

class ImmIfCompositionCancel : public ImmIfEditSessionCallBack,
                               private EditCompositionString
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return CompCancel(ec,
                          pes->m_state.hIMC,
                          pes->m_ic);
    }

    HRESULT CompCancel(TfEditCookie ec,
                       HIMC hIMC,
                       Interface_Attach<ITfContext> ic);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfUpdateCompositionString

class ImmIfUpdateCompositionString : public ImmIfEditSessionCallBack,
                                     private EditCompositionString
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return UpdateCompositionString(ec,
                                       pes->m_state.hIMC,
                                       pes->m_ic,
                                       pes->m_state.uVKey,
                                       ImmIfIme);
    }

    HRESULT UpdateCompositionString(TfEditCookie ec,
                                    HIMC hIMC,
                                    Interface_Attach<ITfContext> ic,
                                    DWORD dwDeltaStart,
                                    Interface_Attach<ImmIfIME> ImmIfIme);

private:
    HRESULT _IsInterimSelection(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             Interface<ITfRange>* pInterimRange,
                             BOOL *pfInterim);

    HRESULT _MakeCompositionString(LIBTHREAD *pLibTLS,
                                   TfEditCookie ec,
                                   IMCLock& imc,
                                   Interface_Attach<ITfContext>& ic,
                                   Interface<ITfRange>& FullTextRange,
                                   DWORD dwDeltaStart,
                                   BOOL bInWriteSession);

    HRESULT _MakeInterimString(LIBTHREAD *pLibTLS,
                               TfEditCookie ec,
                               IMCLock& imc,
                               Interface_Attach<ITfContext>& ic,
                               Interface<ITfRange>& FullTextRange,
                               Interface<ITfRange>& InterimRange,
                               LONG lTextLength,
                               UINT cp,
                               BOOL bInWriteSession);

    HRESULT _GetDeltaStart(CWCompDeltaStart& CompDeltaStart,
                           CWCompString& CompStr,
                           DWORD dwDeltaStart);

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWCompString* CompStr,
                                  CWCompAttribute* CompAttr,
                                  CWCompClause* CompClause,
                                  CWCompCursorPos* CompCursorPos,
                                  CWCompDeltaStart* CompDeltaStart,
                                  CWCompTfGuidAtom* CompGuid,
                                  OUT BOOL* lpbBufferOverflow,
                                  CWCompString* CompReadStr)
    {
        return SetString(imc,
                         CompStr, CompAttr, CompClause,
                         CompCursorPos, CompDeltaStart,
                         CompGuid,
                         lpbBufferOverflow,
                         CompReadStr);
    }

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWCompString* CompStr,
                                  CWCompAttribute* CompAttr,
                                  CWCompClause* CompClause,
                                  CWCompCursorPos* CompCursorPos,
                                  CWCompDeltaStart* CompDeltaStart,
                                  CWCompTfGuidAtom* CompGuid,
                                  OUT BOOL* lpbBufferOverflow,
                                  CWCompString* CompReadStr,
                                  CWCompString* ResultStr,
                                  CWCompClause* ResultClause,
                                  CWCompString* ResultReadStr,
                                  CWCompClause* ResultReadClause)
    {
        return SetString(imc,
                         CompStr, CompAttr, CompClause,
                         CompCursorPos, CompDeltaStart,
                         CompGuid,
                         lpbBufferOverflow,
                         CompReadStr, NULL, NULL,     // CompReadStr, CompReadAttr, CompReadCls
                         ResultStr, ResultClause,
                         ResultReadStr, ResultReadClause);
    }

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWInterimString* InterimStr)
    {
        return SetString(imc,
                         NULL, NULL, NULL,    // CompStr, CompAttr, CompCls
                         NULL, NULL,          // CompCursor, CompDeltaStart
                         NULL,                // CompGuid
                         NULL,                // lpbBufferOverflow
                         NULL, NULL, NULL,    // CompReadStr, CompReadAttr, CompReadCls
                         NULL, NULL,          // ResultStr, ResultCls
                         NULL, NULL,          // ResultReadStr, ResultReadCls
                         InterimStr);
    }
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfReplaceWholeText

class ImmIfReplaceWholeText : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return ReplaceWholeText(ec,
                                pes->m_state.hIMC,
                                pes->m_ic,
                                pes->m_state.lpwCompStr);
    }

    HRESULT ReplaceWholeText(TfEditCookie ec,
                             HIMC hIMC,
                             Interface_Attach<ITfContext> ic,
                             CWCompString* lpwCompStr);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfReconvertString

class ImmIfReconvertString : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return ReconvertString(ec,
                               pes->m_state.hIMC,
                               pes->m_ic,
                               pes->m_pRange,
                               pes->m_fDocFeedOnly,
                               pes->m_state.lpwReconvStr,
                               ImmIfIme);
    }

    HRESULT ReconvertString(TfEditCookie ec,
                            HIMC hIMC,
                            Interface_Attach<ITfContext> ic,
                            Interface<ITfRange>* rangeSrc,
                            BOOL fDocFeedOnly,
                            CWReconvertString* lpwReconvStr,
                            Interface_Attach<ImmIfIME> ImmIfIme);
};

/////////////////////////////////////////////////////////////////////////////
// ImmIfClearDocFeedBuffer

class ImmIfClearDocFeedBuffer : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return ClearDocFeedBuffer(ec,
                                  pes->m_state.hIMC,
                                  pes->m_ic,
                                  ImmIfIme);
    }

    HRESULT ClearDocFeedBuffer(TfEditCookie ec,
                            HIMC hIMC,
                            Interface_Attach<ITfContext> ic,
                            Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetTextAndAttribute

class ImmIfGetTextAndAttribute : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetTextAndAttribute(ec,
                                   pes->m_state.hIMC,
                                   pes->m_ic,
                                   pes->m_state.lpwCompStr,
                                   pes->m_state.lpwCompAttr,
                                   ImmIfIme);
    }

    HRESULT GetTextAndAttribute(TfEditCookie ec,
                                HIMC hIMC,
                                Interface_Attach<ITfContext> ic,
                                CWCompString* lpwCompString,
                                CWCompAttribute* lpwCompAttribute,
                                Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfQueryReconvertString

class ImmIfQueryReconvertString : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return QueryReconvertString(ec,
                                    pes->m_state.hIMC,
                                    pes->m_ic,
                                    pes->m_pRange,
                                    pes->m_state.lpwReconvStr,
                                    ImmIfIme);
    }

    HRESULT QueryReconvertString(TfEditCookie ec,
                                 HIMC hIMC,
                                 Interface_Attach<ITfContext> ic,
                                 Interface<ITfRange>* rangeQuery,
                                 CWReconvertString* lpwReconvStr,
                                 Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCalcRangePos

class ImmIfCalcRangePos : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return CalcRangePos(ec,
                            pes->m_ic,
                            pes->m_pRange,
                            pes->m_state.lpwReconvStr,
                            ImmIfIme);
    }

    HRESULT CalcRangePos(TfEditCookie ec,
                         Interface_Attach<ITfContext> ic,
                         Interface<ITfRange>* rangeSrc,
                         CWReconvertString* lpwReconvStr,
                         Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetSelection

class ImmIfGetSelection : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetSelection(ec,
                            pes->m_ic,
                            pes->m_pRange,
                            ImmIfIme);
    }

    HRESULT GetSelection(TfEditCookie ec,
                         Interface_Attach<ITfContext> ic,
                         Interface<ITfRange>* rangeSrc,
                         Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetReadOnlyPropMargin

class ImmIfGetReadOnlyPropMargin : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetReadOnlyPropMargin(ec,
                                     pes->m_ic,
                                     pes->m_pRangeACP,
                                     (INT_PTR*)pes->m_state.pv,
                                     ImmIfIme);
    }

    HRESULT GetReadOnlyPropMargin(TfEditCookie ec,
                                  Interface_Attach<ITfContext> ic,
                                  Interface<ITfRangeACP>* rangeSrc,
                                  INT_PTR* cch,
                                  Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

class ImmIfGetCursorPosition : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetCursorPosition(ec,
                                 pes->m_state.hIMC,
                                 pes->m_ic,
                                 pes->m_state.lpwCursorPosition,
                                 ImmIfIme);
    }

    HRESULT GetCursorPosition(TfEditCookie ec,
                              HIMC hIMC,
                              Interface_Attach<ITfContext> ic,
                              CWCompCursorPos* lpwCursorPosition,
                              Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

class ImmIfGetAllTextRange : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        LONG cch;

        return GetAllTextRange(ec,
                               pes->m_ic,
                               pes->m_pRange,
                               &cch);
    }
};


#endif // _EDITSES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\editses.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editses.cpp

Abstract:

    This file implements the EditSession Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "ctffunc.h"

#include "editses.h"
#include "globals.h"
#include "resource.h"
#include "candpos.h"

#include "proputil.h"

/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSessionCallBack

HRESULT
ImmIfEditSessionCallBack::GetAllTextRange(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>* range,
    LONG* lpTextLength,
    TF_HALTCOND* lpHaltCond
    )
{
    ITfRange *rangeFull = NULL;
    HRESULT hr;
    BOOL fFound = FALSE;
    BOOL fIsReadOnlyRange = FALSE;
    ITfProperty *prop;
    ITfRange *rangeTmp;
    LONG cch;

    //
    // init lpTextLength first.
    //
    *lpTextLength = 0;

    //
    // Create the range that covers all the text.
    //
    if (FAILED(hr=ic->GetStart(ec, &rangeFull)))
        return hr;

    if (FAILED(hr=rangeFull->ShiftEnd(ec, LONG_MAX, &cch, lpHaltCond)))
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, rangeFull)))
        {
            while(!fFound && (enumranges->Next(1, &rangeTmp, NULL) == S_OK))
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_EMPTY) || (var.lVal == 0))
                {
                    fFound = TRUE;
                    hr = rangeTmp->Clone(*range);
                    rangeTmp->Release();
                    break;
                }

                fIsReadOnlyRange = TRUE;
                rangeTmp->Release();
            }
            enumranges->Release();
        }
        prop->Release();
    }

    if (FAILED(hr))
        return hr;

    if (!fFound)
    {
        if (fIsReadOnlyRange)
        {
            //
            // all text store is readonly. So we just return an empty range.
            //
            if (FAILED(hr = GetSelectionSimple(ec, ic.GetPtr(), *range)))
                return hr;

            if (FAILED(hr = (*range)->Collapse(ec, TF_ANCHOR_START)))
                return hr;

        }
        else 
        {
            if (FAILED(hr = rangeFull->Clone(*range)))
                return hr;

            *lpTextLength = cch;
        }
    }
    else
    {
        *lpTextLength = 0;

        if (SUCCEEDED((*range)->Clone(&rangeTmp)))
        {
            BOOL fEmpty;
            WCHAR wstr[256 + 1];
            ULONG ul = 0;

            while (rangeTmp->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
            {
                ULONG ulcch;
                rangeTmp->GetText(ec, 
                                  TF_TF_MOVESTART, 
                                  wstr, 
                                  ARRAYSIZE(wstr) - 1, 
                                  &ulcch);
                ul += ulcch;
            }

            rangeTmp->Release();

            *lpTextLength = (LONG)ul;
        }
    }

    SafeRelease(rangeFull);

    return S_OK;
}


HRESULT
ImmIfEditSessionCallBack::SetTextInRange(
    TfEditCookie ec,
    ITfRange* range,
    LPWSTR psz,
    DWORD len,
    CAImeContext* pAImeContext
    )
{
    pAImeContext->_fModifyingDoc = TRUE;

    //
    // Set the text in Cicero TOM
    //
    HRESULT hr = range->SetText(ec, 0, psz, len);

    pAImeContext->_fModifyingDoc = FALSE;

    return hr;
}


HRESULT
ImmIfEditSessionCallBack::ClearTextInRange(
    TfEditCookie ec,
    ITfRange* range,
    CAImeContext* pAImeContext
    )
{
    //
    // Clear the text in Cicero TOM
    //
    return SetTextInRange(ec, range, NULL, 0, pAImeContext);
}


HRESULT
ImmIfEditSessionCallBack::GetReadingString(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    CWCompString& reading_string,
    CWCompClause& reading_clause
    )
{
    HRESULT hr;

    Interface<ITfRange> range;
    LONG l;
    if (FAILED(hr=GetAllTextRange(ec, ic, &range, &l)))
        return hr;

    return GetReadingString(ec, ic, range, reading_string, reading_clause);
}

HRESULT
ImmIfEditSessionCallBack::GetReadingString(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    ITfRange* range,
    CWCompString& reading_string,
    CWCompClause& reading_clause
    )
{
    HRESULT hr;

    EnumReadingPropertyArgs args;
    if (FAILED(hr=ic->GetProperty(GUID_PROP_READING, args.Property)))
        return hr;

    Interface<IEnumTfRanges> EnumReadingProperty;
    hr = args.Property->EnumRanges(ec, EnumReadingProperty, range);
    if (FAILED(hr))
        return hr;

    args.ec = ec;
    args.reading_string = &reading_string;
    args.reading_clause = &reading_clause;
    args.ulClausePos = (reading_clause.GetSize() > 0 ? reading_clause[ reading_clause.GetSize() - 1]
                                                     : 0);

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumReadingPropertyArgs>  Enumrate(EnumReadingProperty,
                                                          EnumReadingPropertyCallback,
                                                          &args);      // Argument of callback func.
    Enumrate.DoEnumrate();

    return S_OK;
}

//
// Enumrate callbacks
//

/* static */
ENUM_RET
ImmIfEditSessionCallBack::EnumReadingPropertyCallback(
    ITfRange* pRange,
    EnumReadingPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        if (V_VT(&var) == VT_BSTR) {
            BSTR bstr = V_BSTR(&var);
            LONG cch = SysStringLen(bstr);
            pargs->reading_string->AddCompData(bstr, cch);

            if (pargs->reading_clause->GetSize() == 0)
                pargs->reading_clause->Add(0);

            pargs->reading_clause->Add( pargs->ulClausePos += cch );
        }
        VariantClear(&var);
    }

    return ret;
}


HRESULT
ImmIfEditSessionCallBack::CompClauseToResultClause(
    IMCLock& imc,
    CWCompClause& result_clause,
    UINT          cch
    )
{
    LONG num_of_written;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls && ptls->pAImm) {

        // Check GCS_COMPCLAUSE office set
        IMCCLock<COMPOSITIONSTRING> lpCompStr(imc->hCompStr);
        if (lpCompStr.Invalid())
            return E_FAIL;

        if (lpCompStr->dwCompClauseOffset > lpCompStr->dwSize)
            return E_FAIL;

        if (lpCompStr->dwCompClauseOffset + lpCompStr->dwCompClauseLen > lpCompStr->dwSize)
            return E_FAIL;

        if (SUCCEEDED(ptls->pAImm->GetCompositionStringW((HIMC)imc,
                                               GCS_COMPCLAUSE,
                                               0, &num_of_written, NULL))) {
            DWORD* buffer = new DWORD[ num_of_written / sizeof(DWORD) ];
            if (buffer != NULL) {
                ptls->pAImm->GetCompositionStringW((HIMC)imc,
                                             GCS_COMPCLAUSE,
                                             num_of_written, &num_of_written, buffer);
 
                int idx = num_of_written / sizeof(DWORD);
                if (idx > 1)
                {
                    idx -= 1;
                    if (buffer[idx] == cch)
                    {
                        result_clause.WriteCompData(buffer, num_of_written / sizeof(DWORD));
                    }
                    else
                    {
                        // this is the case comp clause is corrupted
                        // it is the least we can do for the failure case
                        buffer[0] = 0;
                        buffer[1] = cch;
                        result_clause.WriteCompData(buffer, 2);
                    }
                }

                delete [] buffer;
            }
        }
    }
    return S_OK;
}


//
// Get cursor position
//
HRESULT
ImmIfEditSessionCallBack::_GetCursorPosition(
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    CWCompCursorPos& CompCursorPos,
    CWCompAttribute& CompAttr
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    CAImeContext::IME_QUERY_POS qpos = CAImeContext::IME_QUERY_POS_UNKNOWN;

    if (_pAImeContext->m_fStartComposition) {
        //
        // This method should not call before sending WM_IME_STARTCOMPOSITION
        // because some apps confusing to receive QUERYCHARPOSITION due to
        // no composing.
        //
        _pAImeContext->InquireIMECharPosition(imc, &qpos);
    }

    //
    // Is apps support "query positioning" ?
    //
    if ((g_fInLegacyClsid || g_fAIMM12Trident) &&
        qpos != CAImeContext::IME_QUERY_POS_YES) {

        //
        // IE5.0 candidate window positioning code.
        // They except of it position from COMPOSITIONSTRING.dwCursorPos.
        //
        INT_PTR ich = 0;
        INT_PTR attr_size;

        if (attr_size = CompAttr.GetSize()) {
            while (ich < attr_size && CompAttr[ich] != ATTR_TARGET_CONVERTED)
                ich++;
            if (ich < attr_size) {
                CompCursorPos.Set((DWORD)ich);
                return S_OK;
            }
        }
    }

    HRESULT hr;
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (SUCCEEDED(hr = ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched))) {
        Interface<ITfRange> start;
        LONG ich;
        TF_HALTCOND hc;

        hc.pHaltRange = sel->range;
        hc.aHaltPos = (sel->style.ase == TF_AE_START) ? TF_ANCHOR_START : TF_ANCHOR_END;
        hc.dwFlags = 0;

        if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &ich, &hc))) {
            CompCursorPos.Set(ich);
        }
    }

    return hr;
}




//
// Get text and attribute in given range
//
//                                ITfRange::range
//   TF_ANCHOR_START
//    |======================================================================|
//                        +--------------------+          #+----------+
//                        |ITfRange::pPropRange|          #|pPropRange|
//                        +--------------------+          #+----------+
//                        |     GUID_ATOM      |          #
//                        +--------------------+          #
//    ^^^^^^^^^^^^^^^^^^^^                      ^^^^^^^^^^#
//    ITfRange::gap_range                       gap_range #
//                                                        #
//                                                        V
//                                                        ITfRange::no_display_attribute_range
//                                                   result_comp
//                                          +1   <-       0    ->     -1
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttribute(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& rangeIn,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& CompReadStr,
    CWCompClause& CompReadClause,
    CWCompString& ResultStr,
    CWCompClause& ResultClause,
    CWCompString& ResultReadStr,
    CWCompClause& ResultReadClause,
    BOOL bInWriteSession
    )
{
    //
    // Get no display attribute range if there exist.
    // Otherwise, result range is the same to input range.
    //
    LONG result_comp;
    Interface<ITfRange> no_display_attribute_range;
    if (FAILED(rangeIn->Clone(no_display_attribute_range)))
        return E_FAIL;

    if (FAILED(_GetNoDisplayAttributeRange(pLibTLS,
                                           ec,
                                           ic,
                                           rangeIn,
                                           no_display_attribute_range)))
        return E_FAIL;

     
    Interface<ITfProperty> propComp;
    Interface<IEnumTfRanges> enumComp;
    VARIANT var;

    HRESULT hr;
    if (FAILED(hr = ic->GetProperty(GUID_PROP_COMPOSING, propComp)))
        return hr;

    if (FAILED(hr = propComp->EnumRanges(ec, enumComp, rangeIn)))
        return hr;

    CompClause.Add(0);         // setup composition clause at 0
    ResultClause.Add(0);       // setup result clause at 0

    Interface<ITfRange>  range;
    while(enumComp->Next(1, range, NULL) == S_OK)
    {

        BOOL fCompExist = FALSE;

        hr = propComp->GetValue(ec, range, &var);
        if (S_OK == hr)
        {
            if (var.vt == VT_I4 && var.lVal != 0)
                fCompExist = TRUE;
        }

        ULONG ulNumProp;

        //
        // Get display attribute track property range
        //
        Interface<IEnumTfRanges> enumProp;
        Interface<ITfReadOnlyProperty> prop;
        if (FAILED(GetDisplayAttributeTrackPropertyRange(ec, ic.GetPtr(), range, prop, enumProp, &ulNumProp))) {
            return E_FAIL;
        }
    
        // use text range for get text
        Interface<ITfRange> textRange;
        if (FAILED(range->Clone(textRange)))
            return E_FAIL;

        // use text range for gap text (no property range).
        Interface<ITfRange> gap_range;
        if (FAILED(range->Clone(gap_range)))
            return E_FAIL;


        ITfRange* pPropRange = NULL;
        while (enumProp->Next(1, &pPropRange, NULL) == S_OK) {

            // pick up the gap up to the next property
            gap_range->ShiftEndToRange(ec, pPropRange, TF_ANCHOR_START);

            //
            // GAP range
            //
            no_display_attribute_range->CompareStart(ec,
                                                     gap_range,
                                                     TF_ANCHOR_START,
                                                     &result_comp);
            _GetTextAndAttributeGapRange(pLibTLS,
                                         ec,
                                         imc,
                                         gap_range,
                                         result_comp,
                                         CompStr, CompAttr, CompClause, CompGuid,
                                         ResultStr, ResultClause);

            //
            // Get display attribute data if some GUID_ATOM exist.
            //
            TF_DISPLAYATTRIBUTE da;
            TfGuidAtom guidatom = TF_INVALID_GUIDATOM;

            GetDisplayAttributeData(pLibTLS, ec, prop, pPropRange, &da, &guidatom, ulNumProp);

            
            //
            // Property range
            //
            no_display_attribute_range->CompareStart(ec,
                                                     pPropRange,
                                                     TF_ANCHOR_START,
                                                     &result_comp);

            // Adjust GAP range's start anchor to the end of proprty range.
            gap_range->ShiftStartToRange(ec, pPropRange, TF_ANCHOR_END);
    
            //
            // Get reading string from property.
            //
            if (fCompExist == TRUE && result_comp <= 0)
                GetReadingString(ec, ic, pPropRange, CompReadStr, CompReadClause);
            else
                GetReadingString(ec, ic, pPropRange, ResultReadStr, ResultReadClause);
    
            //
            // Get property text
            //
            _GetTextAndAttributePropertyRange(pLibTLS,
                                              ec,
                                              imc,
                                              pPropRange,
                                              fCompExist,
                                              result_comp,
                                              bInWriteSession,
                                              da,
                                              guidatom,
                                              CompStr, CompAttr, CompClause, CompGuid,
                                              ResultStr, ResultClause);

            SafeReleaseClear(pPropRange);

        } // while

        // the last non-attr
        textRange->ShiftStartToRange(ec, gap_range, TF_ANCHOR_START);
        textRange->ShiftEndToRange(ec, range, TF_ANCHOR_END);

        LONG ulClausePos = 0;
        BOOL fEmpty;
        while (textRange->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
        {
            WCHAR wstr0[256 + 1];
            ULONG ulcch0 = ARRAYSIZE(wstr0) - 1;
            textRange->GetText(ec, TF_TF_MOVESTART, wstr0, ulcch0, &ulcch0);

            TfGuidAtom guidatom;
            guidatom = TF_INVALID_GUIDATOM;

            TF_DISPLAYATTRIBUTE da;
            da.bAttr = TF_ATTR_INPUT;

            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
            ulClausePos += ulcch0;
        }

        if (ulClausePos) {
            DWORD last_clause;
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        textRange->Collapse(ec, TF_ANCHOR_END);

        range->Release();
        *(ITfRange **)(range) = NULL;

    } // out-most while for GUID_PROP_COMPOSING

    //
    // Fix up empty clause
    //
    if (CompClause.GetSize() <= 1)
        CompClause.RemoveAll();
    if (ResultClause.GetSize() <= 1)
        ResultClause.RemoveAll();


    return S_OK;
}

//
// Retrieve text from gap range
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttributeGapRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface<ITfRange>& gap_range,
    LONG result_comp,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& ResultStr,
    CWCompClause& ResultClause
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    TfGuidAtom guidatom;
    guidatom = TF_INVALID_GUIDATOM;

    TF_DISPLAYATTRIBUTE da;
    da.bAttr = TF_ATTR_INPUT;

    ULONG ulClausePos = 0;
    BOOL fEmpty;
    WCHAR wstr0[256 + 1];
    ULONG ulcch0;


    while (gap_range->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        Interface<ITfRange> backup_range;
        if (FAILED(gap_range->Clone(backup_range)))
            return E_FAIL;

        //
        // Retrieve gap text if there exist.
        //
        ulcch0 = ARRAYSIZE(wstr0) - 1;
        if (FAILED(gap_range->GetText(ec,
                           TF_TF_MOVESTART,    // Move range to next after get text.
                           wstr0,
                           ulcch0, &ulcch0)))
            return E_FAIL;

        ulClausePos += ulcch0;

        if (result_comp <= 0) {
            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
        }
        else {
            ResultStr.AddCompData(wstr0, ulcch0);
            if (_pAImeContext)
                ClearTextInRange(ec, backup_range, _pAImeContext);
        }
    }

    if (ulClausePos) {
        DWORD last_clause;
        if (result_comp <= 0) {
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        else {
            if (ResultClause.GetSize() > 0) {
                last_clause = ResultClause[ ResultClause.GetSize() - 1 ];
                ResultClause.Add( last_clause + ulClausePos );
            }
        }
    }

    return S_OK;
}

//
// Retrieve text from property range
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttributePropertyRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    ITfRange* pPropRange,
    BOOL fCompExist,
    LONG result_comp,
    BOOL bInWriteSession,
    TF_DISPLAYATTRIBUTE da,
    TfGuidAtom guidatom,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& ResultStr,
    CWCompClause& ResultClause
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    ULONG ulClausePos = 0;
    BOOL fEmpty;
    WCHAR wstr0[256 + 1];
    ULONG ulcch0;

    while (pPropRange->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        Interface<ITfRange> backup_range;
        if (FAILED(pPropRange->Clone(backup_range)))
            return E_FAIL;

        //
        // Retrieve property text if there exist.
        //
        ulcch0 = ARRAYSIZE(wstr0) - 1;
        if (FAILED(pPropRange->GetText(ec,
                            TF_TF_MOVESTART,    // Move range to next after get text.
                            wstr0,
                            ulcch0, &ulcch0)))
            return E_FAIL;

        ulClausePos += ulcch0;  // we only need to addup the char position for clause info

        // see if there is a valid disp attribute
        if (fCompExist == TRUE && result_comp <= 0)
        {
            if (guidatom == TF_INVALID_GUIDATOM) {
                da.bAttr = TF_ATTR_INPUT;
            }
            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
        }
        else if (bInWriteSession)
        {
            // if there's no disp attribute attached, it probably means 
            // the part of string is finalized.
            //
            ResultStr.AddCompData(wstr0, ulcch0);
            
            // it was a 'determined' string
            // so the doc has to shrink
            //
            if (_pAImeContext)
                ClearTextInRange(ec, backup_range, _pAImeContext);
        }
        else
        {
            //
            // Prevent infinite loop
            //
            break;
        }
    }

    if (ulClausePos) {
        DWORD last_clause;
        if (fCompExist == TRUE && result_comp <= 0) {
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        else if (result_comp == 0) {
            //
            // Copy CompClause data to ResultClause
            //
            CompClauseToResultClause(imc, ResultClause, ulcch0);
        }
        else {
            if (ResultClause.GetSize() > 0) {
                last_clause = ResultClause[ ResultClause.GetSize() - 1 ];
                ResultClause.Add( last_clause + ulClausePos );
            }
        }
    }

    return S_OK;
}

HRESULT
ImmIfEditSessionCallBack::_GetNoDisplayAttributeRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& rangeIn,
    Interface<ITfRange>& no_display_attribute_range
    )
{
    Interface<ITfProperty> propComp;
    Interface<IEnumTfRanges> enumComp;
    VARIANT var;

    HRESULT hr = ic->GetProperty(GUID_PROP_COMPOSING, propComp);
    if (S_OK == hr)
    {
        hr = propComp->EnumRanges(ec, enumComp, rangeIn);
    }
    else
        return hr;

    ITfRange *pRange;

    while(enumComp->Next(1, &pRange, NULL) == S_OK)
    {

        BOOL fCompExist = FALSE;

        hr = propComp->GetValue(ec, pRange, &var);
        if (S_OK == hr)
        {
            if (var.vt == VT_I4 && var.lVal != 0)
                fCompExist = TRUE;
        }

        if (!fCompExist) {

            // Adjust GAP range's start anchor to the end of proprty range.
            no_display_attribute_range->ShiftStartToRange(ec, pRange, TF_ANCHOR_START);
        }
        pRange->Release();
    }


    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSession

ImmIfEditSession::ImmIfEditSession(
    ESCB escb,
    TfClientId tid,
    Interface_Attach<ImmIfIME> ImmIfIme,
    IMCLock& imc
    ) : m_ImmIfIme(ImmIfIme), m_ic(ImmIfIme->GetInputContext(imc)), m_tid(tid),
        m_state((HIMC)imc)
{
    _Init(escb);
}

ImmIfEditSession::ImmIfEditSession(
    ESCB escb,
    TfClientId tid,
    Interface_Attach<ImmIfIME> ImmIfIme,
    IMCLock& imc,
    Interface_Attach<ITfContext> pic
    ) : m_ImmIfIme(ImmIfIme), m_ic(pic), m_tid(tid),
        m_state((HIMC)imc)
{
    _Init(escb);
}

void 
ImmIfEditSession::_Init(
    ESCB escb
    )
{
    m_pfnCallback = EditSessionCallBack;
    m_cRef        = 1;

    m_ImmIfCallBack  = NULL;

    switch(escb) {
        case ESCB_HANDLETHISKEY:
            m_ImmIfCallBack = new ImmIfHandleThisKey;
            break;
        case ESCB_COMPCOMPLETE:
            m_ImmIfCallBack = new ImmIfCompositionComplete;
            break;
        case ESCB_COMPCANCEL:
            m_ImmIfCallBack = new ImmIfCompositionCancel;
            break;
        case ESCB_UPDATECOMPOSITIONSTRING:
            m_ImmIfCallBack = new ImmIfUpdateCompositionString;
            break;
        case ESCB_REPLACEWHOLETEXT:
            m_ImmIfCallBack = new ImmIfReplaceWholeText;
            break;
        case ESCB_RECONVERTSTRING:
            m_ImmIfCallBack = new ImmIfReconvertString;
            break;
        case ESCB_CLEARDOCFEEDBUFFER:
            m_ImmIfCallBack = new ImmIfClearDocFeedBuffer;
            break;
        case ESCB_GETTEXTANDATTRIBUTE:
            m_ImmIfCallBack = new ImmIfGetTextAndAttribute;
            break;
        case ESCB_QUERYRECONVERTSTRING:
            m_ImmIfCallBack = new ImmIfQueryReconvertString;
            break;
        case ESCB_CALCRANGEPOS:
            m_ImmIfCallBack = new ImmIfCalcRangePos;
            break;
        case ESCB_GETSELECTION:
            m_ImmIfCallBack = new ImmIfGetSelection;
            break;
        case ESCB_GET_READONLY_PROP_MARGIN:
            m_ImmIfCallBack = new ImmIfGetReadOnlyPropMargin;
            break;
        case ESCB_GET_CURSOR_POSITION:
            m_ImmIfCallBack = new ImmIfGetCursorPosition;
            break;
        case ESCB_GET_ALL_TEXT_RANGE:
            m_ImmIfCallBack = new ImmIfGetAllTextRange;
            break;
    }
}

ImmIfEditSession::~ImmIfEditSession(
    )
{
    if (m_ImmIfCallBack)
        delete m_ImmIfCallBack;
}

bool
ImmIfEditSession::Valid(
    )
{
    return (m_ImmIfIme.Valid() && m_ic.Valid()) ? true : false;
}


// ImmIfEditSession::ITfEditCallback method

STDAPI
ImmIfEditSession::DoEditSession(
    TfEditCookie ec
    )
{
    return m_pfnCallback(ec, this);
}


// ImmIfEditSession::IUnknown

STDAPI
ImmIfEditSession::QueryInterface(
    REFIID riid,
    void** ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession)) {
        *ppvObj = SAFECAST(this, ImmIfEditSession*);
    }

    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG)
ImmIfEditSession::AddRef(
    )
{
    return ++m_cRef;
}

STDAPI_(ULONG)
ImmIfEditSession::Release(
    )
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0) {
        delete this;
    }

    return cr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfHandleThisKey

HRESULT
ImmIfHandleThisKey::HandleThisKey(
    TfEditCookie ec,
    UINT uVKey,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    Interface_TFSELECTION sel;
    BOOL fEmpty;
    ULONG cFetched;

    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    //
    // Finalize the composition string
    //
    if (_pAImeContext &&
        _pAImeContext->IsVKeyInKeyList(uVKey, EDIT_ID_FINALIZE)) {
        return ImmIfIme->_CompComplete(imc);
    }

    //
    // Keys that change its behavior on selection
    //

    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return E_FAIL;

    sel->range->IsEmpty(ec, &fEmpty);

    if (!fEmpty) {
        //
        // Selection is not empty.
        //

        switch (uVKey) {
        case VK_BACK:
        case VK_DELETE:
            //
            // Delete the selection
            //
            ClearTextInRange(ec, sel->range, _pAImeContext);
            return ImmIfIme->_UpdateCompositionString();
        }
    }

    switch (uVKey) {
    case VK_BACK:
        // Make selection
        if (SUCCEEDED(ShiftSelectionToLeft(ec, sel->range, false))) {
            // Clear the current selection
            if (SUCCEEDED(ClearTextInRange(ec, sel->range, _pAImeContext))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;

    case VK_DELETE:
        if (SUCCEEDED(ShiftSelectionToRight(ec, sel->range, false))) {
            if (SUCCEEDED(ClearTextInRange(ec, sel->range, _pAImeContext))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;

    case VK_LEFT:
        sel->style.ase = TF_AE_START;

        if (::GetKeyState(VK_SHIFT) >= 0 &&
            ::GetKeyState(VK_CONTROL) >= 0) {
            if (SUCCEEDED(ShiftSelectionToLeft(ec, sel->range)) &&
                SUCCEEDED(ic->SetSelection(ec, 1, sel))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;

    case VK_RIGHT:
        sel->style.ase = TF_AE_END;

        if (::GetKeyState(VK_SHIFT) >= 0 &&
            ::GetKeyState(VK_CONTROL) >= 0) {
            if (SUCCEEDED(ShiftSelectionToRight(ec, sel->range)) &&
                SUCCEEDED(ic->SetSelection(ec, 1, sel))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;
    }

    return E_FAIL;
}

HRESULT
ImmIfHandleThisKey::ShiftSelectionToLeft(
    TfEditCookie ec,
    ITfRange *range,
    bool fShiftEnd
    )
{
    LONG cch;

    if (SUCCEEDED(range->ShiftStart(ec, -1, &cch, NULL))) {
        HRESULT hr = S_OK;
        if (fShiftEnd) {
            hr = range->Collapse(ec, TF_ANCHOR_START);
        }
        return hr;
    }

    return E_FAIL;
}

HRESULT
ImmIfHandleThisKey::ShiftSelectionToRight(
    TfEditCookie ec,
    ITfRange *range,
    bool fShiftStart
    )
{
    LONG cch;

    if (SUCCEEDED(range->ShiftEnd(ec, 1, &cch, NULL))) {
        HRESULT hr = S_OK;
        if (fShiftStart) {
            hr = range->Collapse(ec, TF_ANCHOR_END);
        }
        return hr;
    }

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionComplete

HRESULT
ImmIfCompositionComplete::CompComplete(
    TfEditCookie ec,
    HIMC hIMC,
    BOOL fTerminateComp,
    Interface_Attach<ITfContext> ic,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;

    if (fTerminateComp == TRUE)
    {
        Interface<ITfContextOwnerCompositionServices> icocs;

        hr = ic->QueryInterface(IID_ITfContextOwnerCompositionServices, (void **)icocs);

        if (S_OK == hr)
        {
            icocs->TerminateComposition(NULL);
        }
    }

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    //
    // Get the whole text, finalize it, and set empty string in TOM
    //
    Interface<ITfRange> start;
    LONG cch;

    if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &cch))) {

        //
        // If there is no string in TextStore and we havenot sent 
        // WM_IME_STARTCOMPOSITION, we don't have to do anything.
        //
        if (!cch) {
            if (_pAImeContext && !(_pAImeContext->m_fStartComposition))
                return S_OK;
        }

        LPWSTR wstr = new WCHAR[ cch + 1 ];
        Interface<ITfProperty> prop;
        //
        // Get the whole text, finalize it, and erase the whole text.
        //
        if (SUCCEEDED(start->GetText(ec, TF_TF_IGNOREEND, wstr, (ULONG)cch, (ULONG*)&cch))) {
            //
            // Make Result String.
            //
            UINT cp = CP_ACP;
            ImmIfIme->GetCodePageA(&cp);

            CWCompString ResultStr(cp, hIMC, wstr, cch);

            CWCompString ResultReadStr;
            CWCompClause ResultReadClause;
            CWCompClause ResultClause;

            if (cch) {

                //
                // Get reading string from property.
                //
                GetReadingString(ec, ic, ResultReadStr, ResultReadClause);


                //
                // Copy CompClause data to ResultClause
                //
                CompClauseToResultClause(imc, ResultClause, cch);
            }

#ifdef CICERO_4732
            if (_pAImeContext && ! _pAImeContext->m_fInCompComplete)
            {
                //
                // Prevent reentrance call of CPS_COMPLETE.
                //
                _pAImeContext->m_fInCompComplete = TRUE;
#endif

                //
                // set composition string
                //
                hr = _SetCompositionString(imc,
                                           &ResultStr, &ResultClause,
                                           &ResultReadStr, &ResultReadClause);

#ifdef CICERO_4732
                _pAImeContext->m_fInCompComplete = FALSE;
            }
#endif

            //
            // Clear the TOM
            //
            if (SUCCEEDED(hr))
            {
                if (_pAImeContext)
                    hr = ClearTextInRange(ec, start, _pAImeContext);
            }

        }
        delete [] wstr;
    }
    else {
        ImmIfIme->_CompCancel(imc);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionCancel


HRESULT
ImmIfCompositionCancel::CompCancel(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    if (_pAImeContext &&
        _pAImeContext->m_fStartComposition) {
        IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);

        if (SUCCEEDED(hr = comp.GetResult())) {
            TRANSMSG msg;
            msg.message = WM_IME_COMPOSITION;
            msg.wParam = (WPARAM)VK_ESCAPE;
            msg.lParam = (LPARAM)(GCS_COMPREAD | GCS_COMP | GCS_CURSORPOS | GCS_DELTASTART);
            if (_pAImeContext->m_pMessageBuffer)
                _pAImeContext->m_pMessageBuffer->SetData(msg);

            _pAImeContext->m_fStartComposition = FALSE;

            msg.message = WM_IME_ENDCOMPOSITION;
            msg.wParam = (WPARAM) 0;
            msg.lParam = (LPARAM) 0;
            if (_pAImeContext->m_pMessageBuffer)
                _pAImeContext->m_pMessageBuffer->SetData(msg);

            //
            // Clear the text in Cicero TOM
            //
            Interface<ITfRange> range;
            LONG l;
            if (SUCCEEDED(GetAllTextRange(ec, ic, &range, &l))) {
                hr = ClearTextInRange(ec, range, _pAImeContext);
            }
        }

        imc.GenerateMessage();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfUpdateCompositionString

HRESULT
ImmIfUpdateCompositionString::UpdateCompositionString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    DWORD dwDeltaStart,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ImmIfIme->GetClientId(), &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    Interface<ITfRange> InterimRange;
    BOOL fInterim = FALSE;
    if (FAILED(hr = _IsInterimSelection(ec, ic, &InterimRange, &fInterim)))
        return hr;

    if (fInterim) {
        UINT cp = CP_ACP;
        ImmIfIme->GetCodePageA(&cp);

        return _MakeInterimString(ImmIfIme->_GetLibTLS(),
                                  ec, imc, ic, FullTextRange,
                                  InterimRange, lTextLength, cp,
                                  bInWriteSession);
    }
    else {
        return _MakeCompositionString(ImmIfIme->_GetLibTLS(),
                                      ec, imc, ic, FullTextRange,
                                      dwDeltaStart,
                                      bInWriteSession);
    }

}


HRESULT
ImmIfUpdateCompositionString::_IsInterimSelection(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>* pInterimRange,
    BOOL *pfInterim
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    *pfInterim = FALSE;
    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
    {
        // no selection. we can return S_OK.
        return S_OK;
    }

    if (sel->style.fInterimChar) {
        HRESULT hr;
        if (FAILED(hr = sel->range->Clone(*pInterimRange)))
            return hr;

        *pfInterim = TRUE;
    }

    return S_OK;
}


HRESULT
ImmIfUpdateCompositionString::_MakeCompositionString(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& FullTextRange,
    DWORD dwDeltaStart,
    BOOL bInWriteSession
    )
{
    HRESULT hr;
    CWCompString CompStr;
    CWCompAttribute CompAttr;
    CWCompClause CompClause;
    CWCompTfGuidAtom CompGuid;
    CWCompCursorPos CompCursorPos;
    CWCompDeltaStart CompDeltaStart;
    CWCompString CompReadStr;
    CWCompClause CompReadClause;
    CWCompString ResultStr;
    CWCompClause ResultClause;
    CWCompString ResultReadStr;
    CWCompClause ResultReadClause;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic, FullTextRange,
                                         CompStr, CompAttr, CompClause,
                                         CompGuid,
                                         CompReadStr, CompReadClause,
                                         ResultStr, ResultClause,
                                         ResultReadStr, ResultReadClause,
                                         bInWriteSession
                                        ))) {
        return hr;
    }

    if (FAILED(hr = _GetCursorPosition(ec, imc, ic, CompCursorPos, CompAttr))) {
        return hr;
    }

    if (FAILED(hr = _GetDeltaStart(CompDeltaStart, CompStr, dwDeltaStart))) {
        return hr;
    }

    //
    // Clear the GUID attribute map array
    //
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    _pAImeContext->usGuidMapSize = 0;
    memset(&_pAImeContext->aGuidMap, 0, sizeof _pAImeContext->aGuidMap);

    BOOL bBufferOverflow = FALSE;
    
    // handle result string
    hr = _SetCompositionString(imc,
                               &CompStr, &CompAttr, &CompClause,
                               &CompCursorPos, &CompDeltaStart,
                               &CompGuid,
                               &bBufferOverflow,
                               &CompReadStr,
                               &ResultStr, &ResultClause,
                               &ResultReadStr, &ResultReadClause);
                                   
    if (SUCCEEDED(hr) && bBufferOverflow) {
        //
        // Buffer overflow in COMPOSITIONSTRING.compstr[NMAXKEY],
        // Then, Clear the TOM
        //
        //
        // Get the whole text, finalize it, and set empty string in TOM
        //
        Interface<ITfRange> start;
        LONG cch;
        if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &cch))) {
            hr = ClearTextInRange(ec, start, _pAImeContext);
        }
    }

    return hr;
}


HRESULT
ImmIfUpdateCompositionString::_MakeInterimString(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& FullTextRange,
    Interface<ITfRange>& InterimRange,
    LONG lTextLength,
    UINT cp,
    BOOL bInWriteSession
    )
{
    LONG lStartResult;
    LONG lEndResult;

    FullTextRange->CompareStart(ec, InterimRange, TF_ANCHOR_START, &lStartResult);
    if (lStartResult > 0) {
        return E_FAIL;
    }

    FullTextRange->CompareEnd(ec, InterimRange, TF_ANCHOR_END, &lEndResult);
    if (lEndResult < 0) {
        return E_FAIL;
    }
    if (lEndResult > 1) {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    CWInterimString InterimStr(cp, (HIMC)imc);

    if (lStartResult < 0) {
        //
        // Make result string.
        //
#if 0
        BOOL fEqual;
        do {
            LONG cch;
            FullTextRange->ShiftEnd(ec, -1, &cch, NULL);
            if (cch == 0) {
                return E_FAIL;
            }
            lTextLength -= abs(cch);
            FullTextRange->IsEqualEnd(ec, InterimRange, TF_ANCHOR_START, &fEqual);
        } while(! fEqual);
#endif
        if (FAILED(hr=FullTextRange->ShiftEndToRange(ec, InterimRange, TF_ANCHOR_START)))
            return hr;

        //
        // Interim char assume 1 char length.
        // Full text length - 1 means result string length.
        //
        lTextLength --;
        ASSERT(lTextLength > 0);

        if (lTextLength > 0) {

            LPWSTR wstr = new WCHAR[ lTextLength + 1 ];

            //
            // Get the result text, finalize it, and erase the result text.
            //
            if (SUCCEEDED(FullTextRange->GetText(ec, TF_TF_IGNOREEND, wstr, (ULONG)lTextLength, (ULONG*)&lTextLength))) {
                //
                // Clear the TOM
                //
                CAImeContext* _pAImeContext = imc->m_pAImeContext;
                ASSERT(_pAImeContext != NULL);

                if (_pAImeContext) {
                    if (SUCCEEDED(hr = ClearTextInRange(ec, FullTextRange, _pAImeContext))) {
                        InterimStr.WriteCompData(wstr, lTextLength);
                    }
                }
            }
            delete [] wstr;
        }
    }

    //
    // Make interim character
    //
    CWCompString CompStr;
    CWCompAttribute CompAttr;
    CWCompClause CompClause;
    CWCompTfGuidAtom CompGuid;
    CWCompString CompReadStr;
    CWCompClause CompReadClause;
    CWCompString ResultStr;
    CWCompClause ResultClause;
    CWCompString ResultReadStr;
    CWCompClause ResultReadClause;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic, InterimRange,
                                         CompStr, CompAttr, CompClause,
                                         CompGuid,
                                         CompReadStr, CompReadClause,
                                         ResultStr, ResultClause,
                                         ResultReadStr, ResultReadClause,
                                         bInWriteSession
                                        ))) {
        return hr;
    }

    WCHAR ch = L'\0';
    BYTE  attr = 0;
    if (CompStr.GetSize() > 0) {
        CompStr.ReadCompData(&ch, 1);
    }
    if (CompAttr.GetSize() > 0) {
        CompAttr.ReadCompData(&attr, 1);
    }

    InterimStr.WriteInterimChar(ch, attr);
    hr = _SetCompositionString(imc, &InterimStr);

    return hr;
}


//
// Get delta start
//
HRESULT
ImmIfUpdateCompositionString::_GetDeltaStart(
    CWCompDeltaStart& CompDeltaStart,
    CWCompString& CompStr,
    DWORD dwDeltaStart
    )
{
    if (dwDeltaStart < (DWORD)CompStr.GetSize())
        CompDeltaStart.Set(dwDeltaStart);    // Set COMPOSITIONSTRING.dwDeltaStart.
    else
        CompDeltaStart.Set(0);

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfReplaceWholeText

HRESULT
ImmIfReplaceWholeText::ReplaceWholeText(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompString* lpwCompStr
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    DWORD dwSize = (DWORD)lpwCompStr->GetSize();
    LPWSTR lpszComp = new WCHAR[dwSize + 1];

    if (!lpszComp)
        return hr;

    lpwCompStr->ReadCompData(lpszComp, dwSize + 1);
    lpszComp[dwSize] = L'\0';

    Interface<ITfRange> whole;
    LONG cch;
    if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &whole, &cch))) {
        if (_pAImeContext)
            hr = SetTextInRange(ec, whole, lpszComp, 0, _pAImeContext);
    }
    delete [] lpszComp;

    return hr;
}


void SetReadOnlyRange(TfEditCookie ec,
                      Interface_Attach<ITfContext> ic,
                      ITfRange *range,
                      BOOL fSet)
{
    ITfProperty *prop;
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        if (fSet)
        {
            VARIANT var;
            var.vt = VT_I4;
            var.lVal = 1;
            prop->SetValue(ec, range, &var);
        }
        else
        {
            prop->Clear(ec, range);
        }
        prop->Release();
    }
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfReconvertString

HRESULT
ImmIfReconvertString::ReconvertString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    BOOL fDocFeedOnly,
    CWReconvertString* lpwReconvStr,
    Interface_Attach<ImmIfIME> ImmIfIme
    )

/*+++

    LPRECONVERTSTRING structure:
      +00  DWORD dwSize               // Sizeof data (include this structure size) with byte count.
      +04  DWORD dwVersion
      +08  DWORD dwStrLen             // String length with character count.
      +0C  DWORD dwStrOffset          // Offset from start of this structure with byte count.
      +10  DWORD dwCompStrLen         // Comp Str length with character count.
      +14  DWORD dwCompStrOffset      // Offset from this->dwStrOffset with byte count.
      +18  DWORD dwTargetStrLen       // Target Str length with character count.
      +1C  DWORD dwTargetStrOffset    // Offset from this->dwStrOffset with byte count.
      +20

---*/

{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    DWORD dwLen;
    dwLen = lpwReconvStr->ReadCompData();
    if (dwLen) {
        LPRECONVERTSTRING lpReconvertString;
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];

        if (lpReconvertString == NULL)
            return hr;

        lpwReconvStr->ReadCompData(lpReconvertString, dwLen);


        if (lpReconvertString->dwStrLen) {
            hr = ic->GetStart(ec, *rangeSrc);
            if (SUCCEEDED(hr)) {
                LONG cch;
                hr = (*rangeSrc)->ShiftEnd(ec, LONG_MAX, &cch, NULL);
                SetReadOnlyRange(ec, ic, *rangeSrc, FALSE);
                BOOL fSkipSetText = FALSE;

                if (SUCCEEDED(hr)) {

                    Interface<ITfRange> rangeOrgSelection;

                    if (lpReconvertString->dwCompStrLen)
                    {
                        WCHAR *pwstr = NULL;
                        ULONG ul = 0;
                        Interface<ITfRange> rangeTmp;
    
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeTmp)))
                        {
                            UINT uSize = lpReconvertString->dwCompStrLen + 2;
                            pwstr = new WCHAR[uSize + 1];
                            if (pwstr)
                            {
                                ULONG ulcch;
                                rangeTmp->GetText(ec, 0, pwstr, uSize, &ulcch);

                                if ((lpReconvertString->dwCompStrLen == ulcch) &&
                                     !memcmp(((LPBYTE)lpReconvertString +
                                                lpReconvertString->dwStrOffset +
                                                lpReconvertString->dwCompStrOffset),
                                            pwstr,
                                            lpReconvertString->dwCompStrLen * sizeof(WCHAR)))
                                    fSkipSetText = TRUE;
                
                                delete [] pwstr;
                            }
                        }

                        if (!fSkipSetText && fDocFeedOnly)
                        {
                            TraceMsg(TF_WARNING, "ImmIfReconvertString::ReconvertString   the current text store does not match with the string from App.");
                            goto Exit;
                        }
    
                        if (!fSkipSetText)
                            hr = SetTextInRange(ec,
                                                *rangeSrc,
                                                (LPWSTR)((LPBYTE)lpReconvertString +
                                                                 lpReconvertString->dwStrOffset +
                                                                 lpReconvertString->dwCompStrOffset),
                                                lpReconvertString->dwCompStrLen,
                                                _pAImeContext);
                        else
                        {
                            GetSelectionSimple(ec, ic.GetPtr(), rangeOrgSelection);
                            hr = S_OK;
                        }

#if 0
                        //
                        // set disp attribute for the reconvert
                        //
                        if (S_OK == hr)
                        {
    
                            ITfProperty *pProp = NULL;
    
                            hr = ic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);
                            if (S_OK == hr)
                            {
                               SetAttrPropertyData(ImmIfIme->_GetLibTLS(),
                                                   ec, 
                                                   pProp, 
                                                   *rangeSrc, 
                                                   GUID_ATTR_MSIMTF_INPUT);
                            }
                            pProp->Release();
                        } 
#endif
                    } 
                    else
                    {
                        BOOL fEmpty;
 
                        if (SUCCEEDED((*rangeSrc)->IsEmpty(ec, &fEmpty)) && !fEmpty)
                        {
                            if (fDocFeedOnly)
                            {
                                TraceMsg(TF_WARNING, "ImmIfReconvertString::ReconvertString   the current text store does not match with the string from App.");
                                goto Exit;
                            }

                            hr = ClearTextInRange(ec, *rangeSrc, _pAImeContext);
                        }
                    } 


                    //
                    // set read only string
                    //
                    if (lpReconvertString->dwCompStrOffset)
                    {
                        //
                        // keep rangeSrc and rangeOrgSelection
                        //
                        (*rangeSrc)->SetGravity(ec, 
                                                  TF_GRAVITY_FORWARD,
                                                  TF_GRAVITY_FORWARD);

                        if (rangeOrgSelection.Valid())
                            rangeOrgSelection->SetGravity(ec, 
                                                        TF_GRAVITY_FORWARD,
                                                        TF_GRAVITY_FORWARD);
                        Interface<ITfRange> rangeStart;
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeStart)))
                        {
                            if (SUCCEEDED(rangeStart->Collapse(ec, TF_ANCHOR_START)))
                            {
                                rangeStart->SetGravity(ec, 
                                                       TF_GRAVITY_BACKWARD,
                                                       TF_GRAVITY_FORWARD);
                                hr = SetTextInRange(ec,
                                                    rangeStart,
                                                    (LPWSTR)((LPBYTE)lpReconvertString +
                                                                     lpReconvertString->dwStrOffset),
                                                    lpReconvertString->dwCompStrOffset / sizeof(WCHAR),
                                                    _pAImeContext);

                                if (SUCCEEDED(hr))
                                    SetReadOnlyRange(ec, ic, rangeStart, TRUE);
                            }
                        }
                    }


                    if ((lpReconvertString->dwCompStrOffset + lpReconvertString->dwCompStrLen * sizeof(WCHAR)) < lpReconvertString->dwStrLen * sizeof(WCHAR))
                    {
                        //
                        // keep rangeSrc and rangeOrgSelection
                        //
                        (*rangeSrc)->SetGravity(ec, 
                                                  TF_GRAVITY_BACKWARD,
                                                  TF_GRAVITY_BACKWARD);

                        if (rangeOrgSelection.Valid())
                            rangeOrgSelection->SetGravity(ec, 
                                                        TF_GRAVITY_BACKWARD,
                                                        TF_GRAVITY_BACKWARD);

                        Interface<ITfRange> rangeEnd;
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeEnd)))
                        {
                            if (SUCCEEDED(rangeEnd->Collapse(ec, TF_ANCHOR_END)))
                            {
                                rangeEnd->SetGravity(ec, 
                                                     TF_GRAVITY_BACKWARD,
                                                     TF_GRAVITY_FORWARD);

                                hr = SetTextInRange(ec,
                                                    rangeEnd,
                                                    (LPWSTR)((LPBYTE)lpReconvertString +
                                                                     lpReconvertString->dwStrOffset +
                                                                     lpReconvertString->dwCompStrOffset +
                                                                    (lpReconvertString->dwCompStrLen * sizeof(WCHAR))),
                                                    ((lpReconvertString->dwStrLen  * sizeof(WCHAR)) -
                                                     (lpReconvertString->dwCompStrOffset +
                                                     (lpReconvertString->dwCompStrLen * sizeof(WCHAR)))) / sizeof(WCHAR),
                                                    _pAImeContext);
                                if (SUCCEEDED(hr))
                                    SetReadOnlyRange(ec, ic, rangeEnd, TRUE);
                            }
                        }
                    }

                    (*rangeSrc)->SetGravity(ec, 
                                              TF_GRAVITY_FORWARD,
                                              TF_GRAVITY_BACKWARD);


                    //
                    // we just set a selection to the target string.
                    //
                    Interface<ITfRange> range;
                    if (fSkipSetText)
                    {
                        if (rangeOrgSelection.Valid())
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = rangeOrgSelection;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);
                        }
                    }
                    else if (SUCCEEDED((*rangeSrc)->Clone(range)))
                    {
                        LONG cchStart;
                        LONG cchEnd;

                        if (lpReconvertString->dwTargetStrOffset == 0 &&
                            lpReconvertString->dwTargetStrLen == 0      ) {
                            cchStart = lpReconvertString->dwCompStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwCompStrOffset / sizeof(WCHAR) + lpReconvertString->dwCompStrLen;
                        }
                        else {
                            cchStart = (lpReconvertString->dwTargetStrOffset - lpReconvertString->dwCompStrOffset) / sizeof(WCHAR);
                            cchEnd = (lpReconvertString->dwTargetStrOffset - lpReconvertString->dwCompStrOffset) / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                            // cchStart = (lpReconvertString->dwTargetStrOffset) / sizeof(WCHAR);
                            // cchEnd = (lpReconvertString->dwTargetStrOffset) / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                        }

                        range->Collapse(ec, TF_ANCHOR_START);

                        //
                        // shift end first then shift start.
                        //
                        if ((SUCCEEDED(range->ShiftEnd(ec, 
                                                      cchEnd,
                                                      &cch, 
                                                      NULL))) &&
                            (SUCCEEDED(range->ShiftStart(ec,
                                                         cchStart,
                                                         &cch, 
                                                         NULL))))
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = range;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);
                        }
                    }

                    //
                    // it's time to generate WM_IME_COMPOSITION.
                    //
                    ImmIfIme->_UpdateCompositionString();
                }
            }
        }
Exit:
        delete [] lpReconvertString;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfClearDocFeedBuffer

HRESULT
ImmIfClearDocFeedBuffer::ClearDocFeedBuffer(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ITfRange *rangeFull = NULL;
    ITfProperty *prop;
    ITfRange *rangeTmp;
    LONG cch;

    //
    // Create the range that covers all the text.
    //
    if (FAILED(hr=ic->GetStart(ec, &rangeFull)))
        return hr;

    if (FAILED(hr=rangeFull->ShiftEnd(ec, LONG_MAX, &cch, NULL)))
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, rangeFull)))
        {
            while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_I4) && (var.lVal != 0))
                {
                    prop->Clear(ec, rangeTmp);
                    ClearTextInRange(ec, rangeTmp, _pAImeContext);
                }
                rangeTmp->Release();
            }
            enumranges->Release();
        }
        prop->Release();
    }


    rangeFull->Release();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfGetTextAndAttribute

HRESULT
ImmIfGetTextAndAttribute::GetTextAndAttribute(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompString* lpwCompString,
    CWCompAttribute* lpwCompAttribute,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    LIBTHREAD *pLibTLS = ImmIfIme->_GetLibTLS();

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ImmIfIme->GetClientId(), &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic,
                                         FullTextRange,
                                         *lpwCompString,
                                         *lpwCompAttribute,
                                         bInWriteSession))) {
        return hr;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfQueryReconvertString

HRESULT
ImmIfQueryReconvertString::QueryReconvertString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeQuery,
    CWReconvertString* lpwReconvStr,
    Interface_Attach<ImmIfIME> ImmIfIme
    )

/*+++

    LPRECONVERTSTRING structure:
      +00  DWORD dwSize               // Sizeof data (include this structure size) with byte count.
      +04  DWORD dwVersion
      +08  DWORD dwStrLen             // String length with character count.
      +0C  DWORD dwStrOffset          // Offset from start of this structure with byte count.
      +10  DWORD dwCompStrLen         // Comp Str length with character count.
      +14  DWORD dwCompStrOffset      // Offset from this->dwStrOffset with byte count.
      +18  DWORD dwTargetStrLen       // Target Str length with character count.
      +1C  DWORD dwTargetStrOffset    // Offset from this->dwStrOffset with byte count.
      +20

---*/

{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    DWORD dwLen;
    dwLen = lpwReconvStr->ReadCompData();
    if (dwLen) {
        LPRECONVERTSTRING lpReconvertString;
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];

        if (lpReconvertString == NULL)
            return hr;

        lpwReconvStr->ReadCompData(lpReconvertString, dwLen);

        if (lpReconvertString->dwStrLen) {
            Interface<ITfRange> rangeSrc;
            hr = ic->GetStart(ec, rangeSrc);
            if (SUCCEEDED(hr)) {
                LONG cch;
                hr = rangeSrc->ShiftEnd(ec, LONG_MAX, &cch, NULL);
                if (SUCCEEDED(hr)) {

                    hr = SetTextInRange(ec,
                                        rangeSrc,
                                        (LPWSTR)((LPBYTE)lpReconvertString +
                                                         lpReconvertString->dwStrOffset),
                                        lpReconvertString->dwStrLen,
                                        _pAImeContext);

#if 0
                    //
                    // set disp attribute for the query reconvert
                    //
                    if (S_OK == hr)
                    {

                        ITfProperty *pProp = NULL;

                        hr = ic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);
                        if (S_OK == hr)
                        {
                           SetAttrPropertyData(ImmIfIme->_GetLibTLS(),
                                               ec, 
                                               pProp, 
                                               rangeSrc, 
                                               GUID_ATTR_MSIMTF_INPUT);
                        }
                        pProp->Release();
                    } 
                    else
                    {
                        BOOL fEmpty;
 
                        if (SUCCEEDED(rangeSrc->IsEmpty(ec, &fEmpty)) && !fEmpty)
                        {
                            hr = ClearTextInRange(ec, rangeSrc, _pAImeContext);
                        }
                    } 
#endif


                    //
                    // we just set a selection to the target string.
                    //
                    Interface<ITfRange> range;
                    if (SUCCEEDED(rangeSrc->Clone(range)))
                    {
                        LONG cchStart;
                        LONG cchEnd;

                        if (lpReconvertString->dwTargetStrOffset == 0 &&
                            lpReconvertString->dwTargetStrLen == 0      ) {
                            cchStart = lpReconvertString->dwCompStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwCompStrOffset / sizeof(WCHAR) + lpReconvertString->dwCompStrLen;
                        }
                        else {
                            cchStart = lpReconvertString->dwTargetStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwTargetStrOffset / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                        }

                        range->Collapse(ec, TF_ANCHOR_START);

                        //
                        // shift end first then shift start.
                        //
                        if ((SUCCEEDED(range->ShiftEnd(ec, 
                                                      cchEnd,
                                                      &cch, 
                                                      NULL))) &&
                            (SUCCEEDED(range->ShiftStart(ec,
                                                         cchStart,
                                                         &cch, 
                                                         NULL))))
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = range;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);

                            hr = range->Clone(*rangeQuery);
                        }
                    }
                }
            }
        }
        delete [] lpReconvertString;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfCalcRangePos

HRESULT
ImmIfCalcRangePos::CalcRangePos(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    CWReconvertString* lpwReconvStr,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    Interface<ITfRange> pFullRange;

    hr = ic->GetStart(ec, pFullRange);
    if (SUCCEEDED(hr)) {
        lpwReconvStr->m_CompStrIndex = 0;
        lpwReconvStr->m_TargetStrIndex = 0;

        BOOL equal = FALSE;
        while (SUCCEEDED(hr=(*rangeSrc)->IsEqualStart(ec, pFullRange, TF_ANCHOR_START, &equal)) &&
               ! equal) {
            LONG cch;
            hr = pFullRange->ShiftStart(ec, 1, &cch, NULL);
            if (FAILED(hr))
                break;

            lpwReconvStr->m_CompStrIndex++;
            lpwReconvStr->m_TargetStrIndex++;
        }

        if (S_OK == hr) {
            lpwReconvStr->m_CompStrLen = 0;
            lpwReconvStr->m_TargetStrLen = 0;

            Interface<ITfRange> rangeTmp;

            if (SUCCEEDED(hr=(*rangeSrc)->Clone(rangeTmp)))
            {
                BOOL fEmpty;
                WCHAR wstr[256 + 1];
                ULONG ul = 0;

                while (rangeTmp->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
                {
                    ULONG ulcch;
                    rangeTmp->GetText(ec, 
                                      TF_TF_MOVESTART, 
                                      wstr, 
                                      ARRAYSIZE(wstr) - 1, 
                                      &ulcch);
                    ul += ulcch;
                }

                //
                // Hack for Satori
                // Satori receives empty range with Reconversion->QueryRange().
                // Apps couldn't call reconversion.
                //
                if (ul == 0) {
                    ul++;
                }

                lpwReconvStr->m_CompStrLen = (LONG)ul;
                lpwReconvStr->m_TargetStrLen = (LONG)ul;
            }
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetSelection

HRESULT
ImmIfGetSelection::GetSelection(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return E_FAIL;

    return sel->range->Clone(*rangeSrc);
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetReadOnlyPropMargin

HRESULT
ImmIfGetReadOnlyPropMargin::GetReadOnlyPropMargin(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRangeACP>* rangeSrc,
    INT_PTR* cch,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    Interface<ITfRange> range_readonly_prop;

    *cch = 0;

    //
    // Create the range that covers start of text to rangeSrc.
    //
    if (FAILED(hr=ic->GetStart(ec, range_readonly_prop)))
        return hr;

    if (FAILED(hr=range_readonly_prop->ShiftEndToRange(ec, *rangeSrc, TF_ANCHOR_START)))
        return hr;

    //
    // same ?
    //
    BOOL empty;
    if (FAILED(hr=range_readonly_prop->IsEmpty(ec, &empty)))
        return hr;

    if (empty)
        return S_OK;

    //
    // find the first non readonly range in the text store.
    //
    ITfProperty *prop;
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, range_readonly_prop)))
        {
            ITfRange *rangeTmp;
            while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_I4) && (var.lVal != 0))
                {
                    while (rangeTmp->IsEmpty(ec, &empty) == S_OK && !empty)
                    {
                        WCHAR wstr[256 + 1];
                        ULONG ulcch;
                        rangeTmp->GetText(ec, 
                                          TF_TF_MOVESTART, 
                                          wstr, 
                                          ARRAYSIZE(wstr) - 1, 
                                          &ulcch);
                        *cch += ulcch;
                    }
                }
                rangeTmp->Release();
            }
            enumranges->Release();
        }
        prop->Release();
    }

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

HRESULT
ImmIfGetCursorPosition::GetCursorPosition(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompCursorPos* lpwCursorPosition,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    LIBTHREAD *pLibTLS = ImmIfIme->_GetLibTLS();

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ImmIfIme->GetClientId(), &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    CWCompString CompStr;
    CWCompAttribute CompAttr;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic,
                                         FullTextRange,
                                         CompStr,
                                         CompAttr,
                                         bInWriteSession))) {
        return hr;
    }

    if (FAILED(hr = _GetCursorPosition(ec, imc, ic, *lpwCursorPosition, CompAttr))) {
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\compstr.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    compstr.h

Abstract:

    This file defines the CCompStrFactory Class.

Author:

Revision History:

Notes:

--*/


#ifndef _COMPSTR_H_
#define _COMPSTR_H_

#include "cime.h"
#include "template.h"
#include "ctxtcomp.h"

class CCompStrFactory : public IMCCLock<COMPOSITIONSTRING_AIMM12>
{
public:
    CCompStrFactory(HIMCC hCompStr) : IMCCLock<COMPOSITIONSTRING_AIMM12>(hCompStr)
    {
        m_pEndOfData = NULL;
    }

    HIMCC GetHandle()
    {
        return m_himcc;
    }

    HRESULT CreateCompositionString(CWCompString* CompStr,
                                    CWCompAttribute* CompAttr,
                                    CWCompClause* CompClause,
                                    CWCompTfGuidAtom* CompGuid,
                                    CWCompString* CompReadStr,
                                    CWCompAttribute* CompReadAttr,
                                    CWCompClause* CompReadClause,
                                    CWCompString* ResultStr,
                                    CWCompClause* ResultClause,
                                    CWCompString* ResultReadStr,
                                    CWCompClause* ResultReadClause
                                   );

    HRESULT CreateCompositionString(CWInterimString* InterimStr);

    template<class CONTEXT_SRC, class ARG_TYPE>
    HRESULT WriteData(CONTEXT_SRC& context_src,
                      DWORD* context_dest_len,
                      DWORD* context_dest_off
                     )
    {
        DWORD dwLen = (DWORD)context_src.GetSize();
        DWORD dwRemainBufferSize = GetRemainBufferSize();

        if (dwLen > dwRemainBufferSize)
            return E_OUTOFMEMORY;

        *context_dest_len = dwLen;
        *context_dest_off = (DWORD)(m_pEndOfData - (BYTE*)m_pcomp);

        context_src.ReadCompData((ARG_TYPE*)m_pEndOfData, dwRemainBufferSize);
        m_pEndOfData += Align(dwLen * sizeof(ARG_TYPE));

        return S_OK;
    }

private:
    HRESULT _CreateCompositionString(DWORD dwCompSize);

    DWORD GetRemainBufferSize()
    {
        if (m_pEndOfData == NULL)
            return 0;

        return (DWORD)(m_pcomp->CompStr.dwSize > (DWORD)(m_pEndOfData - (BYTE*)m_pcomp) ? m_pcomp->CompStr.dwSize - (m_pEndOfData - (BYTE*)m_pcomp) : 0);
    }

    size_t Align(size_t a)
    {
        return (size_t) ((a + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
    }

    BYTE*    m_pEndOfData;
};

#endif // _COMPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\compstr.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    compstr.cpp

Abstract:

    This file implements the CCompStrFactory Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "compstr.h"
#include "a_wrappers.h"

HRESULT
CCompStrFactory::CreateCompositionString(
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompTfGuidAtom* CompGuid,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause
    )
{
    DWORD dwCompSize = (CompStr          ? Align(CompStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (CompAttr         ? Align(CompAttr->GetSize()   * sizeof(BYTE))  : 0) +
                       (CompClause       ? Align(CompClause->GetSize() * sizeof(DWORD)) : 0) +
                       (CompReadStr      ? Align(CompReadStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (CompReadAttr     ? Align(CompReadAttr->GetSize()   * sizeof(BYTE))  : 0) +
                       (CompReadClause   ? Align(CompReadClause->GetSize() * sizeof(DWORD)) : 0) +
                       (ResultStr        ? Align(ResultStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (ResultClause     ? Align(ResultClause->GetSize() * sizeof(DWORD)) : 0) +
                       (ResultReadStr    ? Align(ResultReadStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (ResultReadClause ? Align(ResultReadClause->GetSize() * sizeof(DWORD)) : 0) +
                       (CompGuid         ? Align(CompGuid->GetSize() * sizeof(TfGuidAtom)) : 0) +      // COMPSTRING_AIMM12->dwTfGuidAtom
                       (CompGuid && CompAttr
                                         ? Align(CompAttr->GetSize() * sizeof(BYTE)) : 0);             // COMPSTRING_AIMM12->dwGuidMapAttr

#ifdef CICERO_4678
    //
    // This is another workaround instead of dimm\imewnd.cpp.
    // Even subclass window hook off, AIMM won't resize hCompStr if dwCompSize is zero.
    //
    return (dwCompSize ? _CreateCompositionString(dwCompSize) : S_OK);
#else
    return _CreateCompositionString(dwCompSize);
#endif
}

HRESULT
CCompStrFactory::CreateCompositionString(
    CWInterimString* InterimStr
    )
{
    DWORD dwCompSize = (InterimStr ? Align(InterimStr->GetSize() * sizeof(WCHAR))      : 0) +
                       Align(sizeof(WCHAR)) +    // Interim char
                       Align(sizeof(BYTE));      // Interim attr
    return _CreateCompositionString(dwCompSize);
}

HRESULT
CCompStrFactory::_CreateCompositionString(
    DWORD dwCompSize
    )

/*+++

Return Value:

    Returns S_FALSE, dwCompSize is zero.
    Returns S_OK,    dwCompSize is valid size.

---*/

{
    IMTLS *ptls = IMTLS_GetOrAlloc();
    HRESULT hr = (dwCompSize != 0 ? S_OK : S_FALSE);

    dwCompSize += sizeof(COMPOSITIONSTRING_AIMM12);

    if (m_himcc == NULL) {
        //
        // First creation. Let's initialize it now
        //
        m_himcc = ImmCreateIMCC(ptls, dwCompSize);
        if (m_himcc != NULL) {
            m_hr = _LockIMCC(m_himcc, (void**)&m_pcomp);
        }
    }
    else if (ImmGetIMCCSize(ptls, m_himcc) != dwCompSize) {
        //
        // If already have m_himcc, then recreate it.
        //
        if (m_pcomp) {
            _UnlockIMCC(m_himcc);
        }

        HIMCC hMem;

        if ((hMem = ImmReSizeIMCC(ptls, m_himcc, dwCompSize)) != NULL) {
            m_himcc = hMem;
        }
        else {
            ImmDestroyIMCC(ptls, m_himcc);
            m_himcc = ImmCreateIMCC(ptls, dwCompSize);
        }

        if (m_himcc != NULL) {
            m_hr = _LockIMCC(m_himcc, (void**)&m_pcomp);
        }
    }

    if (FAILED(m_hr))
        return m_hr;

    if (m_himcc == NULL)
        return E_OUTOFMEMORY;

    memset(m_pcomp, 0, dwCompSize);                 // clear buffer with zero.

    m_pcomp->CompStr.dwSize = dwCompSize;           // set buffer size.

    m_pEndOfData = (BYTE*)m_pcomp + sizeof(COMPOSITIONSTRING_AIMM12); // set end of the data pointer.

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\funcprv.cpp ===
//
// funcprv.cpp
//

#include "private.h"
#include "helpers.h"
#include "immxutil.h"
#include "funcprv.h"
#include "cresstr.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProvider::CFunctionProvider(ImmIfIME *pImmIfIME, TfClientId tid) : CFunctionProviderBase(tid)
{
    Init(CLSID_CAImmLayer, L"AIMM12 Function Provider");
    _ImmIfIME = pImmIfIME;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IAImmFnDocFeed))
    {
        *ppunk = new CFnDocFeed(this);
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnDocFeed
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IAImmFnDocFeed))
    {
        *ppvObj = SAFECAST(this, CFnDocFeed *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnDocFeed::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnDocFeed::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnDocFeed::CFnDocFeed(CFunctionProvider *pFuncPrv)
{
    _cRef = 1;
    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnDocFeed::~CFnDocFeed()
{
    _pFuncPrv->Release();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::GetDisplayName(BSTR *pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = SysAllocString(CRStr2(IDS_FUNCPRV_CONVERSION));
    if (!*pbstrName)
        return E_OUTOFMEMORY;

    return S_OK;
}
//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::IsEnabled(BOOL *pfEnable)
{
    if (!pfEnable)
        return E_INVALIDARG;

    *pfEnable = TRUE;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// CFnDocFeed::DocFeed
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::DocFeed()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    _pFuncPrv->_ImmIfIME->SetupDocFeedString(pAImeContext->GetInputContext(), imc);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::ClearDocFeedBuffer
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::ClearDocFeedBuffer()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    _pFuncPrv->_ImmIfIME->ClearDocFeedBuffer(pAImeContext->GetInputContext(), imc);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::StartReconvert
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::StartReconvert()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    pAImeContext->SetupReconvertString();
    pAImeContext->EndReconvertString();
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::StartUndoCompositionString
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::StartUndoCompositionString()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    pAImeContext->SetupUndoCompositionString();
    pAImeContext->EndUndoCompositionString();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\funcprv.h ===
//
// funcprv.h
//

#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"
#include "immif.h"
#include "fnprbase.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

class CFunctionProvider :  public CFunctionProviderBase
{
public:
    CFunctionProvider(ImmIfIME *pImmIfIME, TfClientId tid);

    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    ImmIfIME* _ImmIfIME;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnDocFeed
//
//////////////////////////////////////////////////////////////////////////////

class CFnDocFeed : public IAImmFnDocFeed
{
public:
    CFnDocFeed(CFunctionProvider *pFuncPrv);
    ~CFnDocFeed();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnDocFeed
    //
    STDMETHODIMP DocFeed();
    STDMETHODIMP ClearDocFeedBuffer();
    STDMETHODIMP StartReconvert();

    STDMETHODIMP StartUndoCompositionString();

private:
    CFunctionProvider *_pFuncPrv;
    long _cRef;
};


#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\editcomp.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editcomp.cpp

Abstract:

    This file implements the EditCompositionString Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "immif.h"
#include "editcomp.h"
#include "template.h"
#include "compstr.h"

static BOOL fHanjaRequested = FALSE; // consider: this is not thread safe

/////////////////////////////////////////////////////////////////////////////
// EditCompositionString

//
// Set (almost) all in composition string
//

HRESULT
EditCompositionString::SetString(
    IMCLock& imc,
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompCursorPos* CompCursorPos,
    CWCompDeltaStart* CompDeltaStart,
    CWCompTfGuidAtom* CompGuid,
    OUT BOOL* lpbBufferOverflow,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause,
    CWInterimString* InterimStr,
    // n.b. ResultRead is not supported for now...
    BOOL fGenerateMessage
    )
{
    HRESULT hr;
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

#ifdef UNSELECTCHECK
    if (!_pAImeContext->m_fSelected)
        return S_OK;
#endif UNSELECTCHECK

    if (_pAImeContext->m_fHanjaReConversion ||
        _pAImeContext->IsInClearDocFeedEditSession())
    {
        if (g_fTrident55 && _pAImeContext->m_fHanjaReConversion)
            fHanjaRequested = TRUE;

        return S_OK;
    }

    //
    // Clear the contents of candidate list
    //
    imc.ClearCand();

    TRANSMSG msg;
    if (InterimStr) {
        hr = _MakeInterimData(imc,
                              InterimStr,
                              &msg.lParam);
    }
    else {
        hr = _MakeCompositionData(imc,
                                  CompStr, CompAttr, CompClause,
                                  CompCursorPos, CompDeltaStart,
                                  CompGuid,
                                  CompReadStr, CompReadAttr, CompReadClause,
                                  ResultStr, ResultClause,
                                  ResultReadStr, ResultReadClause,
                                  &msg.lParam,
                                  lpbBufferOverflow);
    }
    if ( hr == S_OK ||     // In case of valid dwCompSize in the CCompStrFactory::CreateCompositionString
        (hr == S_FALSE && _pAImeContext->m_fStartComposition)
                           // In case of empty dwCompSize but still m_fStartComposition
       ) {
        //
        // Is available compstr/attr/clause, compread, result or resultread ?
        //
        bool fNoCompResultData = false;
        if (! (msg.lParam & (GCS_COMP | GCS_COMPREAD | GCS_RESULT | GCS_RESULTREAD))) {
            DebugMsg(TF_GENERAL, "EditCompositionString::SetString: No data in compstr, compread, result or resultread.");
            fNoCompResultData = true;
            if (  _pAImeContext &&
                ! _pAImeContext->m_fStartComposition) {
                DebugMsg(TF_ERROR, "EditCompositionString::SetString: No send WM_IME_STARTCOMPOSITION yet.");
                return S_FALSE;
            }
        }

        //
        // New Trident(5.5 & 6.0) had a bug to convert Hanja.
        // So _GenerateHanja() funtion try to generate message like as Korean
        // legacy IME behavior.
        //
        // Send WM_IME_ENDCOMPOSITION and then WM_IME_COMPOSITION GCS_RESULT msg.
        //
        if (g_fTrident55 && fHanjaRequested &&
            !fNoCompResultData && (msg.lParam & GCS_RESULT))
        {
            LANGID langid;
            IMTLS *ptls = IMTLS_GetOrAlloc();

            fHanjaRequested = FALSE;

            if (ptls != NULL)
                ptls->pAImeProfile->GetLangId(&langid);

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
            {
                return _GenerateHanja(imc, ResultStr,  fGenerateMessage);
            }
        }

        fHanjaRequested = FALSE;

        //
        // set private input context
        //
        bool fSetStartComp = false;

        if (  _pAImeContext &&
            ! _pAImeContext->m_fStartComposition) {
            _pAImeContext->m_fStartComposition = TRUE;
            TRANSMSG start_msg;
            start_msg.message = WM_IME_STARTCOMPOSITION;
            start_msg.wParam  = (WPARAM) 0;
            start_msg.lParam  = (LPARAM) 0;
            if (_pAImeContext->m_pMessageBuffer) {
                _pAImeContext->m_pMessageBuffer->SetData(start_msg);
                fSetStartComp = true;
            }
        }

        if (! fNoCompResultData) {
            msg.message = WM_IME_COMPOSITION;

            IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

            if (msg.lParam & GCS_RESULT)
                msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));
            else
                msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwCompStrOffset));

            if (_pAImeContext &&
                _pAImeContext->m_pMessageBuffer) {
                _pAImeContext->m_pMessageBuffer->SetData(msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then calls QueryCharPos().
                //
                if (fSetStartComp) {
                    TRANSMSG notify_msg;
                    notify_msg.message = WM_IME_NOTIFY;
                    notify_msg.wParam = (WPARAM)WM_IME_STARTCOMPOSITION;
                    notify_msg.lParam = 0;
                    _pAImeContext->m_pMessageBuffer->SetData(notify_msg);
                }
            }
        }
        else {
            msg.message = WM_IME_COMPOSITION;
            msg.wParam = (WPARAM)VK_ESCAPE;
            msg.lParam = (LPARAM)(GCS_COMPREAD | GCS_COMP | GCS_CURSORPOS | GCS_DELTASTART);
            if (_pAImeContext &&
                _pAImeContext->m_pMessageBuffer)
                _pAImeContext->m_pMessageBuffer->SetData(msg);
        }

        if ((ResultStr && ResultStr->GetSize() && !(msg.lParam & GCS_COMP)) 
           || fNoCompResultData) {
            //
            // We're ending the composition
            //
            if (_pAImeContext)
                _pAImeContext->m_fStartComposition = FALSE;
            TRANSMSG end_msg;
            end_msg.message = WM_IME_ENDCOMPOSITION;
            end_msg.wParam  = (WPARAM) 0;
            end_msg.lParam  = (LPARAM) 0;
            if (_pAImeContext &&
                _pAImeContext->m_pMessageBuffer) {
                _pAImeContext->m_pMessageBuffer->SetData(end_msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then clear QueryCharPos's flag.
                //
                TRANSMSG notify_msg;
                notify_msg.message = WM_IME_NOTIFY;
                notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
                notify_msg.lParam = 0;
                _pAImeContext->m_pMessageBuffer->SetData(notify_msg);
            }
        }

#ifdef DEBUG
        IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
#endif

        if (fGenerateMessage) {
            imc.GenerateMessage();
        }
    }

    return hr;
}


//
// Make composition string data in the IMCCLock<_COMPOSITIONSTRING> comp.
//

HRESULT
EditCompositionString::_MakeCompositionData(
    IMCLock& imc,
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompCursorPos* CompCursorPos,
    CWCompDeltaStart* CompDeltaStart,
    CWCompTfGuidAtom* CompGuid,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause,
    OUT LPARAM* lpdwFlag,
    OUT BOOL* lpbBufferOverflow
    )
{
    DebugMsg(TF_FUNC, "EditCompositionString::MakeCompositionData");

    *lpdwFlag = (LPARAM) 0;

    HRESULT hr;

    CCompStrFactory compstrfactory(imc->hCompStr);
    if (FAILED(hr=compstrfactory.GetResult()))
        return hr;

    hr = compstrfactory.CreateCompositionString(CompStr,
                                                CompAttr,
                                                CompClause,
                                                CompGuid,
                                                CompReadStr,
                                                CompReadAttr,
                                                CompReadClause,
                                                ResultStr,
                                                ResultClause,
                                                ResultReadStr,
                                                ResultReadClause
                                              );
    if (FAILED(hr))
        return hr;

    //
    // Composition string
    //
    if (lpbBufferOverflow != NULL)
        *lpbBufferOverflow = FALSE;

    if (CompStr && CompStr->GetSize()) {
#if 0
        /*
         * If composition string length over the buffer of COMPOSITIONSTRING.compstr[NMAXKEY],
         * then we want to finalize this composition string.
         */
        if ((*comp)->dwCompStrLen >= NMAXKEY) {
            if (lpbBufferOverflow != NULL)
                *lpbBufferOverflow = TRUE;
            //
            // Clear compsition string length.
            //
            (*comp)->dwCompStrLen = 0;
            //
            // Make result string.
            //
            (*comp)->dwResultStrLen = NMAXKEY;
            CompStr->ReadCompData((*comp)->W.resultstr, ARRAYSIZE((*comp)->W.resultstr));
            *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
        }
        else
#endif
        {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*CompStr,
                                                               &compstrfactory->CompStr.dwCompStrLen,
                                                               &compstrfactory->CompStr.dwCompStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_COMPSTR;
        }
    }

    if ((lpbBufferOverflow == NULL) ||
        (lpbBufferOverflow != NULL && (! *lpbBufferOverflow))) {

        //
        // Compoition attribute
        //
        if (CompAttr && CompAttr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompAttr,
                                                                 &compstrfactory->CompStr.dwCompAttrLen,
                                                                 &compstrfactory->CompStr.dwCompAttrOffset
                                                                );
            *lpdwFlag |= (LPARAM) GCS_COMPATTR;
        }

        //
        // Compoition clause
        //
        if (CompClause && CompClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*CompClause,
                                                               &compstrfactory->CompStr.dwCompClauseLen,
                                                               &compstrfactory->CompStr.dwCompClauseOffset
                                                              );
            compstrfactory->CompStr.dwCompClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_COMPCLAUSE;
        }

        //
        // Composition Reading string
        //
        if (CompReadStr && CompReadStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*CompReadStr,
                                                               &compstrfactory->CompStr.dwCompReadStrLen,
                                                               &compstrfactory->CompStr.dwCompReadStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_COMPREADSTR;
        }

        //
        // Compoition Reading attribute
        //
        if (CompReadAttr && CompReadAttr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompReadAttr,
                                                                 &compstrfactory->CompStr.dwCompReadAttrLen,
                                                                 &compstrfactory->CompStr.dwCompReadAttrOffset
                                                                );
            *lpdwFlag |= (LPARAM) GCS_COMPREADATTR;
        }

        //
        // Composition Reading clause
        //
        if (CompReadClause && CompReadClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*CompReadClause,
                                                               &compstrfactory->CompStr.dwCompReadClauseLen,
                                                               &compstrfactory->CompStr.dwCompReadClauseOffset
                                                              );
            compstrfactory->CompStr.dwCompReadClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_COMPREADCLAUSE;
        }

        //
        // Result String
        //
        if (ResultStr && ResultStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*ResultStr,
                                                               &compstrfactory->CompStr.dwResultStrLen,
                                                               &compstrfactory->CompStr.dwResultStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
        }

        //
        // Result clause
        //
        if (ResultClause && ResultClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*ResultClause,
                                                               &compstrfactory->CompStr.dwResultClauseLen,
                                                               &compstrfactory->CompStr.dwResultClauseOffset
                                                              );
            compstrfactory->CompStr.dwResultClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_RESULTCLAUSE;
        }

        //
        // Result Reading string
        //
        if (ResultReadStr && ResultReadStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*ResultReadStr,
                                                               &compstrfactory->CompStr.dwResultReadStrLen,
                                                               &compstrfactory->CompStr.dwResultReadStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_RESULTREADSTR;
        }

        //
        // Result Reading clause
        //
        if (ResultReadClause && ResultReadClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*ResultReadClause,
                                                               &compstrfactory->CompStr.dwResultReadClauseLen,
                                                               &compstrfactory->CompStr.dwResultReadClauseOffset
                                                              );
            compstrfactory->CompStr.dwResultReadClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_RESULTREADCLAUSE;
        }

        //
        // TfGuidAtom
        //
        if (CompGuid && CompGuid->GetSize()) {

            // set INIT_GUID_ATOM flag in the fdwInit.
            imc->fdwInit |= INIT_GUID_ATOM;

            hr = compstrfactory.WriteData<CWCompTfGuidAtom, TfGuidAtom>(*CompGuid,
                                                                        &compstrfactory->dwTfGuidAtomLen,
                                                                        &compstrfactory->dwTfGuidAtomOffset
                                                                       );
            // temporary make a buffer of dwGuidMapAttr
            if (CompAttr && CompAttr->GetSize()) {
                hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompAttr,
                                                                     &compstrfactory->dwGuidMapAttrLen,
                                                                     &compstrfactory->dwGuidMapAttrOffset
                                                                    );
            }
        }
    }

    //
    // Composition Cursor Position
    //
    if (CompCursorPos && CompCursorPos->GetSize()) {
        CompCursorPos->ReadCompData(&compstrfactory->CompStr.dwCursorPos, 1);
        *lpdwFlag |= (LPARAM) GCS_CURSORPOS;
    }

    //
    // Delta Start
    //
    if (CompDeltaStart && CompDeltaStart->GetSize()) {
        CompDeltaStart->ReadCompData(&compstrfactory->CompStr.dwDeltaStart, 1);
        *lpdwFlag |= (LPARAM) GCS_DELTASTART;
    }

    //
    // Copy back hCompStr to the Input Context
    //
    imc->hCompStr = compstrfactory.GetHandle();

    return hr;
}

//
// Make interim string data in the IMCCLock<_COMPOSITIONSTRING> comp.
//

HRESULT
EditCompositionString::_MakeInterimData(
    IMCLock& imc,
    CWInterimString* InterimStr,
    LPARAM* lpdwFlag
    )
{
    DebugMsg(TF_FUNC, "EditCompositionString::MakeInterimData");

    *lpdwFlag = (LPARAM) 0;

    //
    // Interim character and result string
    //

    HRESULT hr;

    CCompStrFactory compstrfactory(imc->hCompStr);
    if (FAILED(hr=compstrfactory.GetResult()))
        return hr;

    hr = compstrfactory.CreateCompositionString(InterimStr);
    if (FAILED(hr))
        return hr;

    //
    // Result string
    //
    if (InterimStr && InterimStr->GetSize()) {
        hr = compstrfactory.WriteData<CWInterimString, WCHAR>(*InterimStr,
                                                              &compstrfactory->CompStr.dwResultStrLen,
                                                              &compstrfactory->CompStr.dwResultStrOffset
                                                             );
        *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
    }

    //
    // Composition string (Interim character)
    // Compoition attribute
    //
    CWCompString ch;
    CWCompAttribute attr;
    InterimStr->ReadInterimChar(&ch, &attr);
    if (ch.GetSize() && ch.GetAt(0)) {
        hr = compstrfactory.WriteData<CWCompString, WCHAR>(ch,
                                                           &compstrfactory->CompStr.dwCompStrLen,
                                                           &compstrfactory->CompStr.dwCompStrOffset
                                                          );
        *lpdwFlag |= (LPARAM) GCS_COMPSTR;

        hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(attr,
                                                             &compstrfactory->CompStr.dwCompAttrLen,
                                                             &compstrfactory->CompStr.dwCompAttrOffset
                                                            );
        *lpdwFlag |= (LPARAM) GCS_COMPATTR;

        *lpdwFlag |= (LPARAM) CS_INSERTCHAR | CS_NOMOVECARET;
    }

    //
    // Copy back hCompStr to the Input Context
    //
    imc->hCompStr = compstrfactory.GetHandle();

    return hr;
}

//
// Generate WM_IME_ENDCOMPOSITION and WM_IME_COMPOSITION message for
// Trident 5.5 version. Since Trident 5.5 always expect WM_IME_ENDCOMPOSITION
// first in case of Hanja conversion.
//

HRESULT
EditCompositionString::_GenerateHanja(IMCLock& imc,
    CWCompString* ResultStr,
    BOOL fGenerateMessage)
{
    HRESULT hr = S_OK;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    if (_pAImeContext == NULL)
        return E_FAIL;

    if (ResultStr && ResultStr->GetSize())
    {
        //
        // We're ending the composition
        //
        if (_pAImeContext)
            _pAImeContext->m_fStartComposition = FALSE;

        TRANSMSG end_msg;
        end_msg.message = WM_IME_ENDCOMPOSITION;
        end_msg.wParam  = (WPARAM) 0;
        end_msg.lParam  = (LPARAM) 0;

        if (_pAImeContext &&
            _pAImeContext->m_pMessageBuffer)
        {
            _pAImeContext->m_pMessageBuffer->SetData(end_msg);

            //
            // Internal notification to UI window
            // When receive this msg in UI wnd, then clear QueryCharPos's flag.
            //
            TRANSMSG notify_msg;

            notify_msg.message = WM_IME_NOTIFY;
            notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
            notify_msg.lParam = 0;
            _pAImeContext->m_pMessageBuffer->SetData(notify_msg);
        }

        TRANSMSG result_msg;
        result_msg.message = WM_IME_COMPOSITION;
        result_msg.lParam = GCS_RESULT;

        IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

        result_msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));

        if (_pAImeContext &&
            _pAImeContext->m_pMessageBuffer)
        {
            _pAImeContext->m_pMessageBuffer->SetData(result_msg);
        }
    }


#ifdef DEBUG
    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
#endif

    if (fGenerateMessage)
    {
        imc.GenerateMessage();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\idebug.cpp ===
//
// debug.cpp
//

#include "private.h"

#include <stdio.h>
#include "debug.h"

namespace immif_debug {

	void debug_printf(const char* fmt, ...)
	{
		char buff[512];
		va_list arglist;

		va_start(arglist, fmt);
		_vsnprintf(buff, ARRAYSIZE(buff) - 1, fmt, arglist);
		va_end(arglist);
		buff[ARRAYSIZE(buff) - 1] = 0;
		OutputDebugStringA("[ImmIf] ");
		OutputDebugStringA(buff);
		OutputDebugStringA("\n");
	}

} // end of debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\globals.cpp ===
//
// globals.cpp
//

#include "private.h"

#include "idebug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\icocb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    icocb.h

Abstract:

    This file defines the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _ICOCB_H_
#define _ICOCB_H_

#include "cime.h"

class CMouseSink;
class ImmIfIME;

class CInputContextOwnerCallBack : public CInputContextOwner
{
public:
    CInputContextOwnerCallBack(LIBTHREAD *pLibTLS);
    virtual ~CInputContextOwnerCallBack();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    BOOL Init();

    //
    // Mouse sink
    //
    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc,
                              ImmIfIME* ImmIfIme);

    //
    // Callbacks
    //
private:
    static HRESULT ICOwnerSinkCallback(UINT uCode, ICOARGS *pargs, void *pv);

    HRESULT GetAttribute(const GUID *pguid, VARIANT *pvarValue);

    //
    // Mouse sink
    //
    CMouseSink                      *m_pMouseSink;

    LIBTHREAD                       *m_pLibTLS;
};

#endif // _ICOCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\globals.h ===
//
// globals.h
//


#ifndef IMMIF_GLOBALS_H
#define IMMIF_GLOBALS_H

#include "template.h"

void WINAPI DllAddRef(void);
void WINAPI DllRelease(void);

BYTE GetCharsetFromLangId(LCID lcid);
UINT GetCodePageFromLangId(LCID lcid);

/////////////////////////////////////////////////////////////////////////////
// Module instance

__inline HINSTANCE GetInstance()
{
    extern HINSTANCE g_hInst;
    return g_hInst;
}

/////////////////////////////////////////////////////////////////////////////
// Mouse sink

typedef struct tagPRIVATE_MOUSESINK {
    Interface<ITfRangeACP> range;
    HIMC         hImc;
} PRIVATE_MOUSESINK, *LPPRIVATE_MOUSESINK;


typedef struct tagMOUSE_RANGE_RECT {
    ULONG uStartRangeEdge;
    ULONG uStartRangeQuadrant;
    ULONG uEndRangeEdge;
    ULONG uEndRangeQuadrant;
} MOUSE_RANGE_RECT, *LPMOUSE_RANGE_RECT;


/////////////////////////////////////////////////////////////////////////////
// WM_MSIME_xxxx

extern    UINT  WM_MSIME_SERVICE;
extern    UINT  WM_MSIME_UIREADY;
extern    UINT  WM_MSIME_RECONVERTREQUEST;
extern    UINT  WM_MSIME_RECONVERT;
extern    UINT  WM_MSIME_DOCUMENTFEED;
extern    UINT  WM_MSIME_QUERYPOSITION;
extern    UINT  WM_MSIME_MODEBIAS;
extern    UINT  WM_MSIME_SHOWIMEPAD;
extern    UINT  WM_MSIME_MOUSE;
extern    UINT  WM_MSIME_KEYMAP;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\icocb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    icocb.cpp

Abstract:

    This file implements the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "icocb.h"
#include "cime.h"
#include "imeapp.h"
#include "mouse.h"
#include "tsattrs.h"
#include "imtls.h"
#include "a_context.h"
#include "candpos.h"


CInputContextOwnerCallBack::CInputContextOwnerCallBack(LIBTHREAD *pLibTLS
    ) : CInputContextOwner(ICOwnerSinkCallback, NULL)
{
    m_pMouseSink = NULL;

    m_pLibTLS = pLibTLS;
}

CInputContextOwnerCallBack::~CInputContextOwnerCallBack(
    )
{
    if (m_pMouseSink) {
        m_pMouseSink->InternalRelease();
        m_pMouseSink = NULL;
    }
}

BOOL CInputContextOwnerCallBack::Init()
{
    //
    // Create Mouse Sink
    //
    Assert(!m_pMouseSink);

    m_pMouseSink = new CMouseSink;
    if (m_pMouseSink == NULL)
        return FALSE;

    if (!m_pMouseSink->Init())
    {
        delete m_pMouseSink;
        m_pMouseSink = NULL;
        return FALSE;
    }

    return TRUE;
}


// static
HRESULT
CInputContextOwnerCallBack::ICOwnerSinkCallback(
    UINT uCode,
    ICOARGS *pargs,
    void *pv
    )
{
    DebugMsg(TF_FUNC, "ICOwnerSinkCallback");

    POINT pt;
    IMTLS *ptls;

    CInputContextOwnerCallBack* _this = (CInputContextOwnerCallBack*)pv;

    switch (uCode)
    {
        case ICO_POINT_TO_ACP:
            Assert(0);
            return E_NOTIMPL;

        case ICO_KEYDOWN:
        case ICO_KEYUP:
            *pargs->key.pfEaten = FALSE;
            break;

        case ICO_SCREENEXT:
            {
            ptls = IMTLS_GetOrAlloc();
            if (ptls == NULL)
                break;
            IMCLock imc(ptls->hIMC);
            if (imc.Invalid())
                break;

            GetClientRect(imc->hWnd, pargs->scr_ext.prc);
            pt.x = pt.y = 0;
            ClientToScreen(imc->hWnd, &pt);

            pargs->scr_ext.prc->left += pt.x;
            pargs->scr_ext.prc->right += pt.x;
            pargs->scr_ext.prc->top += pt.y;
            pargs->scr_ext.prc->bottom += pt.y;
            }

            break;

        case ICO_TEXTEXT:
            //
            // consider.
            //
            // hack TextExtent from CANDIDATEFORM of HIMC.
            //
            // more hacks
            //   - may want to send WM_OPENCANDIDATEPOS to let apps
            //     call ImmSetCandidateWindow().
            //   - may need to calculate the actual point from rcArea.
            //
            {
                CCandidatePosition cand_pos;
                cand_pos.GetCandidatePosition(pargs->text_ext.prc);
            }
            break;

        case ICO_STATUS:
            pargs->status.pdcs->dwDynamicFlags = 0;
            pargs->status.pdcs->dwStaticFlags = TF_SS_TRANSITORY;
            break;

        case ICO_WND:
            {
                ptls = IMTLS_GetOrAlloc();
                if (ptls == NULL)
                    break;
                IMCLock imc(ptls->hIMC);
                *(pargs->hwnd.phwnd) = NULL;
                if (imc.Invalid())
                    break;

                *(pargs->hwnd.phwnd) = imc->hWnd;
            }
            break;

        case ICO_ATTR:
            return _this->GetAttribute(pargs->sys_attr.pguid, pargs->sys_attr.pvar);

        case ICO_ADVISEMOUSE:
            {
                ptls = IMTLS_GetOrAlloc();
                if (ptls == NULL)
                    break;
                _this->m_pMouseSink->InternalAddRef();
                return _this->m_pMouseSink->AdviseMouseSink(ptls->hIMC,
                                                            pargs->advise_mouse.rangeACP,
                                                            pargs->advise_mouse.pSink,
                                                            pargs->advise_mouse.pdwCookie);
            }
            break;

        case ICO_UNADVISEMOUSE:
            {
                HRESULT hr = _this->m_pMouseSink->UnadviseMouseSink(pargs->unadvise_mouse.dwCookie);
                _this->m_pMouseSink->InternalRelease();
                return hr;
            }
            break;

        default:
            Assert(0); // shouldn't ever get here
            break;
    }

    return S_OK;
}

/*++

Method:

    CInputContextOwnerCallBack::GetAttribute

Routine Description:

    Implementation of ITfContextOwner::GetAttribute.  Returns the value of a cicero
    app property attribute.

Arguments:


    pguid - [in] GUID of the attrib in question.
    pvarValue - [out] VARIANT, receives the value.  VT_EMPTY if we don't support it.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

HRESULT
CInputContextOwnerCallBack::GetAttribute(
    const GUID *pguid,
    VARIANT *pvarValue
    )
{
    TfGuidAtom ga;
    const GUID *pguidValue;
    IMTLS *ptls;

    QuickVariantInit(pvarValue);

    ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    if (IsEqualGUID(*pguid, GUID_PROP_MODEBIAS))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IMCLock imc(ptls->hIMC);
        if (imc.Invalid())
            return E_FAIL;

        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        ASSERT(_pAImeContext != NULL);
        if (_pAImeContext == NULL)
            return E_FAIL;

        if (_pAImeContext->lModeBias == MODEBIASMODE_FILENAME)
        {
            pguidValue = &GUID_MODEBIAS_FILENAME;
        }
        else if (_pAImeContext->lModeBias == MODEBIASMODE_DIGIT)
        {
            pguidValue = &GUID_MODEBIAS_NUMERIC;
        }
        else
        {
            if (imc->fdwConversion & IME_CMODE_GUID_NULL) {
                //
                // If extended conversion mode were set on,
                // returns GUID_NULL.
                // No returns any MODEBIAS.
                //
                pguidValue = &GUID_NULL;
            }
            else

            //
            // existing logic:
            //
            // if imcp->lModeBias == MODEBIASMODE_DEFAULT
            //      IME_SMODE_CONVERSATION -> GUID_MODEBIAS_CONVERSATION
            //      otherwise -> GUID_MODEBIAS_NONE
            // otherwise
            //      -> MODEBIASMODE_FILENAME -> GUID_MODEBIAS_FILENAME
            //

            if (_pAImeContext->lModeBias == MODEBIASMODE_DEFAULT)
            {
                pguidValue = &GUID_MODEBIAS_NONE;

                if (imc->fdwConversion & IME_CMODE_KATAKANA)
                {
                    if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                        pguidValue = &GUID_MODEBIAS_KATAKANA;
                    else
                        pguidValue = &GUID_MODEBIAS_HALFWIDTHKATAKANA;
                }
                else if (imc->fdwConversion & IME_CMODE_NATIVE)
                {
                    pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                    LANGID langid;
                    ptls->pAImeProfile->GetLangId(&langid);
                    if (langid == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
                    {
                        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                            pguidValue = &GUID_MODEBIAS_HIRAGANA;
                        else
                            pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                    }
                    else if (langid == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT))
                    {
                        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                            pguidValue = &GUID_MODEBIAS_FULLWIDTHHANGUL;
                        else
                            pguidValue = &GUID_MODEBIAS_HANGUL;
                    }
                    else if (PRIMARYLANGID(langid) == LANG_CHINESE)
                    {
                        pguidValue = &GUID_MODEBIAS_CHINESE;
                    }
                }
                else
                {
                    if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                        pguidValue = &GUID_MODEBIAS_FULLWIDTHALPHANUMERIC;
                    else
                        pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                }
            }

            //
            // We overwrite modebias here....
            //
            if (imc->fdwSentence & IME_SMODE_GUID_NULL) {
                //
                // If extended sentence mode were set on,
                // returns GUID_NULL.
                // No returns any MODEBIAS.
                //
                // Nothing to do. pguidValue might be changed with CMODE
                // pguidValue = &GUID_NULL;
            }
            else if (imc->fdwSentence & IME_SMODE_CONVERSATION)
                pguidValue = &GUID_MODEBIAS_CONVERSATION;
            else if (imc->fdwSentence & IME_SMODE_PLAURALCLAUSE)
                pguidValue = &GUID_MODEBIAS_NAME;
        }

        if (!GetGUIDATOMFromGUID(m_pLibTLS, *pguidValue, &ga))
            return E_FAIL;

        pvarValue->vt = VT_I4; // for TfGuidAtom
        pvarValue->lVal = ga;
    }
    if (IsEqualGUID(*pguid, TSATTRID_Text_Orientation))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IMCLock imc(ptls->hIMC);
        if (imc.Invalid())
            return E_FAIL;

        pvarValue->vt = VT_I4; 
        pvarValue->lVal = imc->lfFont.A.lfEscapement;
    }
    if (IsEqualGUID(*pguid, TSATTRID_Text_VerticalWriting))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IMCLock imc(ptls->hIMC);
        if (imc.Invalid())
            return E_FAIL;

        LOGFONTW font;
        if (SUCCEEDED(ptls->pAImm->GetCompositionFontW(ptls->hIMC, &font))) {
            pvarValue->vt = VT_BOOL; 
            pvarValue->lVal = (imc->lfFont.W.lfFaceName[0] == L'@' ? TRUE : FALSE);
        }
    }


    return S_OK;
}

LRESULT
CInputContextOwnerCallBack::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc,
    ImmIfIME* ImmIfIme
    )
{
    return m_pMouseSink->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc, ImmIfIme);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\idebug.h ===
//
// debug.h
//

#ifndef IMMIF_DEBUG_H
#define IMMIF_DEBUG_H

#include "debug.h"

#if DBG

    #define D(x)    x

//    namespace immif_debug {
//        extern void debug_printf(const char* fmt, ...);
//    };

#else

    #define D(x)

#endif


#if DBG
#define VERIFY(x)   D(ASSERT(x))
#else
#define VERIFY(x)   (x)
#endif

#define TRACE0(s)               D(DebugMsg(TF_ALWAYS, "%s", s))
#define TRACE1(fmt, a)          D(DebugMsg(TF_ALWAYS, fmt, a))
#define TRACE2(fmt, a, b)       D(DebugMsg(TF_ALWAYS, fmt, a, b))
#define TRACE3(fmt, a, b, c)    D(DebugMsg(TF_ALWAYS, fmt, a, b, c))
#define TRACE4(fmt, a, b, c, d) D(DebugMsg(TF_ALWAYS, fmt, a, b, c, d))
#define TRACE5(fmt, a, b, c, d, e) \
                                D(DebugMsg(TF_ALWAYS, fmt, a, b, c, d, e))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\imedefs.h ===
#ifndef IMMIF_IMEDEFS_H
#define IMMIF_IMEDEFS_H




// debug flag
#define DEB_FATAL               0
#define DEB_ERR                 1
#define DEB_WARNING             2
#define DEB_TRACE               3

#ifdef _WIN32
void FAR cdecl _DebugOut(UINT, LPCSTR, ...);
#endif

#define NATIVE_CHARSET          ANSI_CHARSET




// state of composition
#define CST_INIT                0
#define CST_INPUT               1



// IME specific constants






void    PASCAL CreateCompWindow(HWND);                          // compui.c

LRESULT CALLBACK UIWndProcA(HWND, UINT, WPARAM, LPARAM);        // ui.c

LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\immif.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    immif.h

Abstract:

    This file defines the IMM Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMMIF_H_
#define _IMMIF_H_

#include "imedefs.h"
#include "cime.h"
#include "ctxtcomp.h"
#include "caime.h"
#include "ico.h"
#include "globals.h"
#include "immxutil.h"
#include "a_context.h"

class ImmIfIME : public CAIME
{
public:
    ImmIfIME();
    ~ImmIfIME();

    //
    // IActiveIME methods
    //

    STDMETHODIMP ConnectIMM(IActiveIMMIME_Private *pActiveIMM);
    STDMETHODIMP UnconnectIMM();
    STDMETHODIMP Inquire(DWORD dwSystemInfoFlags, IMEINFO *pIMEInfo, LPWSTR szWndClass, DWORD *pdwPrivate);
    STDMETHODIMP ConversionList(HIMC hIMC, LPWSTR szSource, UINT uFlag, UINT uBufLen, CANDIDATELIST *pDest, UINT *puCopied);
    STDMETHODIMP Configure(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *pRegisterWord);
    STDMETHODIMP Destroy(UINT uReserved);
    STDMETHODIMP Escape(HIMC hIMC, UINT uEscape, void *pData, LRESULT *plResult);
    STDMETHODIMP ProcessKey(HIMC hIMC, UINT uVirKey, DWORD lParam, BYTE *pbKeyState);
    STDMETHODIMP Notify(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
    STDMETHODIMP SelectEx(HIMC hIMC, DWORD dwFlags, BOOL bIsRealIme_SelKL, BOOL bIsRealIme_UnSelKL);
    STDMETHODIMP UnSelectCheck(HIMC hIMC);
    STDMETHODIMP SetCompositionString(HIMC hIMC, DWORD dwIndex, void *pComp, DWORD dwCompLen, void *pRead, DWORD dwReadLen);
    STDMETHODIMP ToAsciiEx(UINT uVirKey, UINT uScanCode, BYTE *pbKeyState, UINT fuState, HIMC hIMC, DWORD *pdwTransBuf, UINT *puSize);
    STDMETHODIMP RegisterWord(LPWSTR szReading, DWORD dwStyle, LPWSTR szString);
    STDMETHODIMP UnregisterWord(LPWSTR szReading, DWORD  dwStyle, LPWSTR szString);
    STDMETHODIMP GetRegisterWordStyle(UINT nItem, STYLEBUFW *pStyleBuf, UINT *puBufSize);
    STDMETHODIMP EnumRegisterWord(LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID pData, IEnumRegisterWordW **ppEnum);
    STDMETHODIMP GetCodePageA(UINT *uCodePage);
    STDMETHODIMP GetLangId(LANGID *plid);
    STDMETHODIMP AssociateFocus(HWND hWnd, HIMC hIMC, DWORD dwFlags);
    STDMETHODIMP SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);
    STDMETHODIMP GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);

    HRESULT ToAsciiEx(UINT uVirKey, UINT uScanCode, BYTE* pbKeyState, UINT fuState, HIMC hIMC, TRANSMSGLIST* pTransBuf, UINT* puSize);

    //
    // AIMM1.2 interface
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

public:
    BOOL _ImeInquire(LPIMEINFO, LPWSTR, DWORD);

    //
    // Helpers
    //
    static BOOL WINAPI _RegisterImeClass(WNDPROC lpfnUIWndProc);
    static void WINAPI _UnRegisterImeClass();

    LIBTHREAD *_GetLibTLS()
    {
        return &_libTLS;
    }

    BOOL IsRealIme()
    {
        BOOL fReal = FALSE;
        if (m_pIActiveIMMIME)
        {
            m_pIActiveIMMIME->IsRealImePublic(&fReal);
        }

        return fReal;
    }

private:
    BOOL WINAPI _NotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    HRESULT WINAPI _ToAsciiEx(HIMC hImc, UINT uVKey, UINT uScanCode, TRANSMSGLIST* pTransBuf, UINT* puSize);

    BOOL WINAPI _WantThisKey(HIMC hImc, UINT uVKey, BOOL* pfNextHook = NULL)
    {
        IMCLock imc(hImc);
        if (imc.Invalid())
            return false;

        return _WantThisKey(imc, uVKey, pfNextHook);
    }
    BOOL WINAPI _WantThisKey(IMCLock& imc, UINT uVKey, BOOL* pfNextHook = NULL);

    HRESULT _HandleThisKey(IMCLock& imc, UINT uVKey);

public:
    HRESULT _UpdateCompositionString(DWORD dwDeltaStart = 0);

    HRESULT _CompCancel(IMCLock& imc);
    HRESULT _CompComplete(IMCLock& imc, BOOL fSync = TRUE);


public:
    //
    // Cicero stuff
    //
    HRESULT InitIMMX();
    void UnInitIMMX();

private:
    BOOL IsCheckAtom();

public:
    Interface_Attach<ITfContext> GetInputContext(IMCLock& imc) const
    {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (!_pAImeContext)
            return NULL;
        Interface_Attach<ITfContext> ic(_pAImeContext->GetInputContext());
        return ic;
    }

    Interface_Attach<ITfDocumentMgr> GetDocumentManager(IMCLock& imc) const
    {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (!_pAImeContext)
            return NULL;
        Interface_Attach<ITfDocumentMgr> dim(_pAImeContext->GetDocumentManager());
        return dim;
    }

    Interface_Attach<ITfContextOwnerServices> GetInputContextOwnerSink(IMCLock& imc) const
    {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (!_pAImeContext)
            return NULL;
        Interface_Attach<ITfContextOwnerServices> iccb(_pAImeContext->GetInputContextOwnerSink());
        return iccb;
    }

    Interface_Attach<ITfThreadMgr_P> GetThreadManagerInternal() const
    {
        Interface_Attach<ITfThreadMgr_P> tim(m_tim);
        return tim;
    }

    Interface_Attach<ImmIfIME> GetCurrentInterface()
    {
        Interface_Attach<ImmIfIME> ImmIfIme(this);
        return ImmIfIme;
    }

    TfClientId GetClientId() {return m_tfClientId;}
    bool   IsOpenStatusChanging() {return m_ulOpenStatusChanging > 0;}

protected:
    static const char s_szUIClassName[16];

protected:
    bool             m_fCicInit : 1;
    bool             m_fOnSetFocus : 1;
    ULONG            m_ulOpenStatusChanging;
    ULONG            m_ulKorImxModeChanging;

    ITfThreadMgr_P  *m_tim;
    ITfDocumentMgr  *m_dimEmpty;   // empty dim for NULL hIMC.
    TfClientId       m_tfClientId;

    ITfKeystrokeMgr *m_pkm;

    IAImeProfile    *m_AImeProfile;

    LIBTHREAD       _libTLS; // tls for the helper library. Since this object is apt threaded,
                             // all members are accessed in a single thread
                             // also, cicero will only create a single instance of this obj per thread
    
    BOOL            m_fAddedProcessAtom : 1;

private:

    HRESULT Internal_SetCompositionString(CWCompString& wCompStr, CWCompString& wCompReadStr);
    HRESULT Internal_ReconvertString(IMCLock& imc, CWReconvertString& wReconvStr, CWReconvertString& wReconvReadStr);

    static HRESULT Internal_QueryReconvertString_ICOwnerSink(UINT uCode, ICOARGS *pargs, VOID *pv);
    HRESULT Internal_QueryReconvertString(IMCLock& imc, RECONVERTSTRING* pReconv, UINT cp, BOOL fNeedAW);

    void SetFocus(HWND hWnd, ITfDocumentMgr* pdim, BOOL fSetFocus);

public:
    // void  AdjustZeroCompLenReconvertString(RECONVERTSTRING *pReconv, UINT cp, BOOL fAnsi);
    HRESULT SetupReconvertString(ITfContext *pic, IMCLock& imc, UINT uPrivMsg = 0);
    HRESULT EndReconvertString(IMCLock& imc);

    HRESULT SetupDocFeedString(ITfContext *pic, IMCLock& imc);
    HRESULT ClearDocFeedBuffer(ITfContext *pic, IMCLock& imc, BOOL fSync = TRUE);

private:
    HRESULT _ReconvertStringNegotiation(ITfContext *pic, IMCLock& imc, UINT uPrivMsg);
    HRESULT _ReconvertStringTextStore(ITfContext *pic, IMCLock& imc, UINT uPrivMsg);

public:
    HRESULT GetTextAndAttribute(IMCLock& imc,
                                CWCompString* wCompString, CWCompAttribute* wCompAttribute);
    HRESULT GetTextAndAttribute(IMCLock& imc,
                                CBCompString* bCompString, CBCompAttribute* bCompAttribute);
public:
    HRESULT GetCursorPosition(IMCLock& imc, CWCompCursorPos* wCursorPosition);
public:
    HRESULT GetSelection(IMCLock& imc, CWCompCursorPos& wStartSelection, CWCompCursorPos& wEndSelection);

    //
    // Notification
    //
public:
    HRESULT OnSetOpenStatus(IMCLock& imc);
    HRESULT OnSetConversionSentenceMode(IMCLock& imc);
    HRESULT OnSetCandidatePos(IMCLock& imc);
    HRESULT OnSetKorImxConversionMode(IMCLock& imc);

};

inline void SetThis(HWND hWnd, LPARAM lParam)
{
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
}

inline ImmIfIME *GetThis(HWND hWnd)
{
    ImmIfIME *pIME = (ImmIfIME *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    ASSERT(pIME != NULL);

    return pIME;
}

#endif // _IMMIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\korimx.h ===
#ifndef _KORIMX_H_
#define _KORIMX_H_


const GUID GUID_COMPARTMENT_KORIMX_CONVMODE =
	{ 
	0x91656349, 
	0x4ba9, 
	0x4143, 
	{ 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
	};

//
//  Korean TIP Conversion modes
//
#define KORIMX_ALPHANUMERIC_MODE           0
#define KORIMX_HANGUL_MODE                 1
#define KORIMX_JUNJA_MODE                  2
#define KORIMX_HANGULJUNJA_MODE            3

#endif // _KORIMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\langct.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langct.cpp

Abstract:

    This file implements the LanguageCountry Class for each country.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "langct.h"
#include "langchx.h"
#include "langjpn.h"
#include "langkor.h"


CLanguageCountry::CLanguageCountry(
    LANGID LangId
    )
{
    language = NULL;

    switch(PRIMARYLANGID(LangId)) {
        case LANG_CHINESE:
            language = new CLanguageChinese;
            break;
        case LANG_JAPANESE:
            language = new CLanguageJapanese;
            break;
        case LANG_KOREAN:
            language = new CLanguageKorean;
            break;
    }
}

CLanguageCountry::~CLanguageCountry(
    )
{
    if (language)
        delete language;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\langchx.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langchx.h

Abstract:

    This file defines the Language for Chinese Class.

Author:

Revision History:

Notes:

--*/

#ifndef _LANG_CHX_H_
#define _LANG_CHX_H_

#include "language.h"
#include "idebug.h"

class CLanguageChinese : public CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        TRACE0("CLanguageChinese::Escape");
        return E_NOTIMPL;
    }

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        *property =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY;        // This IME needs the ALT key to be passed to ImmProcessKey.

        *conversion_caps =
        IME_CMODE_CHINESE |          // This bit on indicates IME is in CHINESE(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_FULLSHAPE;

        *sentence_caps =
        IME_SMODE_PLAURALCLAUSE;

        *SCSCaps =
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        *UICaps = UI_CAP_ROT90;

        return S_OK;
    }

private:

};

#endif // _LANG_CHX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\makefile.inc ===
imm.h : $(OAK_INC_PATH)\immdev.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\langjpn.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langjpn.h

Abstract:

    This file defines the Language for Japanese Class.

Author:

Revision History:

Notes:

--*/

#ifndef _LANG_JPN_H_
#define _LANG_JPN_H_

#include "language.h"
#include "idebug.h"

class CLanguageJapanese : public CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        TRACE0("CLanguageJapanese::Escape");
        return E_NOTIMPL;
    }

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        *property =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY |              // This IME needs the ALT key to be passed to ImmProcessKey.
        IME_PROP_COMPLETE_ON_UNSELECT;      // Windows 98 and Windows 2000:
                                            // If set, the IME will complete the composition
                                            // string when the IME is deactivated.
                                            // If clear, the IME will cancel the composition
                                            // string when the IME is deactivated.
                                            // (for example, from a keyboard layout change).

        *conversion_caps =
        IME_CMODE_JAPANESE |         // This bit on indicates IME is in JAPANESE(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_KATAKANA |         // 
        IME_CMODE_FULLSHAPE;

        *sentence_caps =
        IME_SMODE_PLAURALCLAUSE |
        IME_SMODE_CONVERSATION;

        *SCSCaps =
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        *UICaps = UI_CAP_ROT90;

        return S_OK;
    }

private:

};

#endif // _LANG_JPN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\init.cpp ===
/**********************************************************************/
/* Copyright (C) 1993-1995 Microsoft Corporation                      */
/**********************************************************************/

#include "private.h"

#include "immif.h"
// #include "commctrl.h"
// #include "cuilib.h"

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
// class static
BOOL WINAPI ImmIfIME::_RegisterImeClass(
    WNDPROC     lpfnUIWndProc
    )
{
    WNDCLASSEXA wcWndCls;

    // IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(LONG_PTR) * 2;
    wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wcWndCls.hInstance     = GetInstance();
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPTSTR)NULL;
    wcWndCls.hIconSm       = NULL;

    // IME UI class
    if (!GetClassInfoExA(GetInstance(), s_szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME | CS_GLOBALCLASS;
        wcWndCls.lpfnWndProc   = lpfnUIWndProc;
        wcWndCls.lpszClassName = s_szUIClassName;

        ATOM atom = RegisterClassExA(&wcWndCls);
        if (!atom)
            return FALSE;
    }

    return TRUE;
}

void WINAPI ImmIfIME::_UnRegisterImeClass()
{
    WNDCLASSEX wcWndCls;

    GetClassInfoEx(GetInstance(), s_szUIClassName, &wcWndCls);
    UnregisterClass(s_szUIClassName, GetInstance());

    DestroyIcon(wcWndCls.hIcon);
    DestroyIcon(wcWndCls.hIconSm);
}

/**********************************************************************/
/* AttachIME() / UniAttachMiniIME()                                   */
/**********************************************************************/
BOOL PASCAL AttachIME(
    WNDPROC     lpfnUIWndProc
    )
{
    BOOL bRet;

    bRet = ImmIfIME::_RegisterImeClass(lpfnUIWndProc);

    return bRet;
}


/**********************************************************************/
/* DetachIME() / UniDetachMiniIME()                                   */
/**********************************************************************/
void PASCAL DetachIME()
{
    ImmIfIME::_UnRegisterImeClass();
}

BOOL WIN32LR_DllProcessAttach()
{
#if !defined( OLD_AIMM_ENABLED )
    //
    // Might be required by some library function, so let's initialize
    // it as the first thing.
    //
    TFInitLib();
#endif // OLD_AIMM_ENABLED

    if (!AttachIME(UIWndProcA)) {
        return FALSE;
    }

    return TRUE;
}

void WIN32LR_DllThreadAttach()
{
}

void WIN32LR_DllThreadDetach()
{
}

void WIN32LR_DllProcessDetach()
{
    DetachIME();
#if !defined( OLD_AIMM_ENABLED )
    TFUninitLib();
#endif // OLD_AIMM_ENABLED
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\langct.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langct.h

Abstract:

    This file defines the LanguageCountry Class for each country.

Author:

Revision History:

Notes:

--*/

#ifndef _LANGCT_H_
#define _LANGCT_H_

#include "language.h"

class CLanguageCountry
{
public:
    CLanguageCountry(LANGID LangId);
    ~CLanguageCountry();

    CLanguage* language;

    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        if (language)
            return language->Escape(cp, hIMC, uEscape, lpData, plResult);
        else
            return E_NOTIMPL;
    }

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        if (language)
            return language->GetProperty(property, conversion_caps, sentence_caps, SCSCaps, UICaps);
        else {
            *property =
            IME_PROP_UNICODE |       // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
            IME_PROP_AT_CARET;       // If set, conversion window is at the caret position.
            *conversion_caps = 0;
            *sentence_caps = 0;
            *SCSCaps = 0;
            *UICaps = 0;

            return S_OK;
        }
    }
};

#endif // _LANGCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\langkor.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langkor.h

Abstract:

    This file defines the Language for Korean Class.

Author:

Revision History:

Notes:

--*/

#ifndef _LANG_KOR_H_
#define _LANG_KOR_H_

#include "language.h"

class CLanguageKorean : public CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        *property =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY |              // This IME needs the ALT key to be passed to ImmProcessKey.
        IME_PROP_COMPLETE_ON_UNSELECT;      // Windows 98 and Windows 2000:
                                            // If set, the IME will complete the composition
                                            // string when the IME is deactivated.
                                            // If clear, the IME will cancel the composition
                                            // string when the IME is deactivated.
                                            // (for example, from a keyboard layout change).

        *conversion_caps =
        IME_CMODE_HANGUL |           // This bit on indicates IME is in HANGUL(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_FULLSHAPE;

        *sentence_caps = 0;

        *SCSCaps =
        SCS_CAP_COMPSTR;     // This IME can generate the composition string by SCS_SETSTR.
#if 0
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.
#endif

        *UICaps = UI_CAP_ROT90;

        return S_OK;
    }

private:
    HRESULT EscHanjaMode(UINT cp, HIMC hIMC, LPWSTR lpwStr, LRESULT* plResult);

};

#endif // _LANG_KOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\language.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    language.h

Abstract:

    This file defines the Language Class for pure virtual function.

Author:

Revision History:

Notes:

--*/

#ifndef _LANGUAGE_H_
#define _LANGUAGE_H_

class CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    virtual HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult) = 0;

    /*
     * Local
     */
    virtual HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps) = 0;
};

#endif // _LANGUAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\langkor.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langkor.cpp

Abstract:

    This file implements the Language for Korean Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cime.h"
#include "ctxtcomp.h"
#include "langkor.h"
#include "a_wrappers.h"
#include "a_context.h"

HRESULT
CLanguageKorean::Escape(
    UINT cp,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult
    )
{
    TRACE0("CLanguageKorean::Escape");

    HRESULT hr;

    if (!lpData)
        return E_FAIL;

    switch (uEscape) {
        case IME_ESC_QUERY_SUPPORT:
            switch (*(LPUINT)lpData) {
                case IME_ESC_HANJA_MODE: hr = S_OK; *plResult = TRUE; break;
                default:                 hr = E_NOTIMPL; break;
            }
            break;

        case IME_ESC_HANJA_MODE:
            hr = EscHanjaMode(cp, hIMC, (LPWSTR)lpData, plResult);
#if 0
            if (SUCCEEDED(hr)) {
                IMCLock lpIMC(hIMC);
                if (SUCCEEDED(hr=lpIMC.GetResult())) {
                    SendMessage(lpIMC->hWnd, WM_IME_NOTIFY, IMN_OPENCANDIDATE, 1L);
                }
            }
#endif
            break;

        default:
            hr = E_NOTIMPL;
            break;
    }
    return hr;
}

HRESULT
CLanguageKorean::EscHanjaMode(
    UINT cp,
    HIMC hIMC,
    LPWSTR lpwStr,
    LRESULT* plResult
    )
{
    HRESULT hr;
    IMCLock lpIMC(hIMC);

    if (FAILED(hr=lpIMC.GetResult()))
        return hr;

    CAImeContext* pAImeContext = lpIMC->m_pAImeContext;
    if (pAImeContext)
    {
        //
        // This is for only Excel since Excel calling Hanja escape function two
        // times. we going to just ignore the second request not to close Hanja
        // candidate window.
        //
        if (pAImeContext->m_fOpenCandidateWindow)
        {
            //
            // Need to set the result value since some apps(Trident) also call
            // Escape() twice and expect the right result value.
            //
            *plResult = TRUE;
            return S_OK;
        }

        pAImeContext->m_fHanjaReConversion = TRUE;
    }

    CWReconvertString wReconvStr(cp, hIMC);
    wReconvStr.WriteCompData(lpwStr, wcslen(lpwStr));

    BOOL fCompMem = FALSE;
    LPRECONVERTSTRING lpReconvertString = NULL;
    DWORD dwLen = wReconvStr.ReadCompData();
    if (dwLen) {
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];
        if (lpReconvertString) {
            fCompMem = TRUE;
            wReconvStr.ReadCompData(lpReconvertString, dwLen);
        }
    }

    IMTLS *ptls = IMTLS_GetOrAlloc();

    *plResult = ImmSetCompositionStringW(ptls, hIMC, SCS_QUERYRECONVERTSTRING, lpReconvertString, dwLen, NULL, 0);
    if (*plResult) {
        *plResult = ImmSetCompositionStringW(ptls, hIMC, SCS_SETRECONVERTSTRING, lpReconvertString, dwLen, NULL, 0);
        if (*plResult) {
            *plResult = ImmSetConversionStatus(ptls, hIMC, lpIMC->fdwConversion | IME_CMODE_HANJACONVERT,
                                                     lpIMC->fdwSentence);
        }
    }

    if (pAImeContext)
        pAImeContext->m_fHanjaReConversion = FALSE;


    if (fCompMem)
        delete [] lpReconvertString;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\misc.cpp ===
//
// misc.c
//

#include "private.h"
#include "immif.h"
#pragma warning(disable: 4005)
#include <wingdip.h>

BYTE GetCharsetFromLangId(LCID lcid)
{
    CHARSETINFO csInfo;

    if (!TranslateCharsetInfo((DWORD *)(ULONG_PTR)lcid, &csInfo, TCI_SRCLOCALE))
        return DEFAULT_CHARSET;
    return (BYTE) csInfo.ciCharset;
}

UINT GetCodePageFromLangId(LCID lcid)
{
    TCHAR buf[8];   // maxmum may be six

    if (GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, buf, ARRAYSIZE(buf))) {
        return _ttoi(buf);
    }

    return CP_ACP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\mouse.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    mouse.h

Abstract:

    This file defines the CMouseSink Class.

Author:

Revision History:

Notes:

--*/

#ifndef _MOUSE_H_
#define _MOUSE_H_

#include "cime.h"

class ImmIfIME;

class CMouseSink
{
public:
    CMouseSink()
    {
        m_ref = 1;

        m_prgMouseSinks = NULL;
    }
    virtual ~CMouseSink()
    {
        if (m_prgMouseSinks)
        {
            delete m_prgMouseSinks;
            m_prgMouseSinks = NULL;
        }
    }

    BOOL Init()
    {
        Assert(!m_prgMouseSinks);
        m_prgMouseSinks = new CStructArray<GENERICSINK>;
        if (!m_prgMouseSinks)
            return FALSE;

        return TRUE;
    }
public:
    ULONG InternalAddRef(void);
    ULONG InternalRelease(void);

public:
    //
    // Mouse sink
    //
public:
    HRESULT AdviseMouseSink(HIMC hImc, ITfRangeACP* range, ITfMouseSink* pSink, DWORD* pdwCookie);
    HRESULT UnadviseMouseSink(DWORD dwCookie);

    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc,
                              ImmIfIME* ImmIfIme);

public:
    CStructArray<GENERICSINK> *m_prgMouseSinks;

protected:
    long        m_ref;

};

#endif // _MOUSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for AIMM1.2 project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <ocidl.h>
#include <olectl.h>

#include <stdio.h>
#include <tchar.h>
#include <limits.h>
#include <initguid.h>

// New NT5 header
#include "immdev.h"
#define _IMM_
#define _DDKIMM_H_

#include "msctf.h"
#include "msctfp.h"
#include "osver.h"
#include "ico.h"
#include "tes.h"
#include "computil.h"
#include "timsink.h"
#include "sink.h"
#include "dispattr.h"
#include "ccstock.h"
#include "helpers.h"
#include "immxutil.h"
#include "xstring.h"
#include "regsvr.h"
#include "tsattrs.h"

#define _DDKIMM_H_
#include "aimm12.h"
#include "aimmp.h"
#include "aimmex.h"
#include "msuimw32.h"


#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof(x)/sizeof(x)[0])
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    ARRAY_SIZE(x)
#endif

#if defined(_DEBUG) || defined(DEBUG)
#define DBG 1
#endif

#include "mem.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\mouse.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    mouse.cpp

Abstract:

    This file implements the mouse sink in the ImmIfIME Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "mouse.h"
#include "template.h"
#include "immif.h"
#include "editses.h"
#include "sink.h"
#include "imeapp.h"

ULONG
CMouseSink::InternalAddRef(
    )
{
    return ++m_ref;
}

ULONG
CMouseSink::InternalRelease(
    )
{
    ULONG cr = --m_ref;

    if (cr == 0) {
        delete this;
    }

    return cr;
}


HRESULT
CMouseSink::AdviseMouseSink(
    HIMC hImc,
    ITfRangeACP* range,
    ITfMouseSink* pSink,
    DWORD* pdwCookie
    )
{
    if (m_prgMouseSinks == NULL)
        return E_FAIL;

    const IID *rgiid = &IID_ITfMouseSink;
    GENERICSINK *pgs;
    HRESULT hr;

    hr = GenericAdviseSink(IID_ITfMouseSink, pSink, &rgiid, m_prgMouseSinks, 1, pdwCookie, &pgs);
    if (hr == S_OK) {
        pgs->uPrivate = (UINT_PTR) new tagPRIVATE_MOUSESINK;
        if (pgs->uPrivate) {
            ((LPPRIVATE_MOUSESINK)pgs->uPrivate)->range.Attach(range);
            range->AddRef();
            ((LPPRIVATE_MOUSESINK)pgs->uPrivate)->hImc  = hImc;
        }
    }

    return hr;
}

HRESULT
CMouseSink::UnadviseMouseSink(
    DWORD dwCookie
    )
{
    if (m_prgMouseSinks == NULL)
        return E_FAIL;

    HRESULT hr;
    LPPRIVATE_MOUSESINK pPrivMouseSink = NULL;

    hr = GenericUnadviseSink(m_prgMouseSinks, 1, dwCookie, (UINT_PTR *)&pPrivMouseSink);
    if (hr == S_OK) {
        if (pPrivMouseSink) {
            delete pPrivMouseSink;
        }
    }

    return hr;
}

LRESULT
CMouseSink::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc,
    ImmIfIME* ImmIfIme
    )
{
    LONG acpStart;
    LONG cch;
    ULONG uRangeEdgeMin;
    ULONG uRangeEdgeMax;
    HRESULT hr;

    /*
     * Find out specified range in whole text's range
     */
    BOOL fEaten = FALSE;

    for (int i = 0; i < m_prgMouseSinks->Count(); i++) {
        GENERICSINK* pgs;
        LPPRIVATE_MOUSESINK pPrivMouseSink;

        pgs = m_prgMouseSinks->GetPtr(i);
        pPrivMouseSink = (LPPRIVATE_MOUSESINK)pgs->uPrivate;

        if ((HIMC)imc != pPrivMouseSink->hImc)
            continue;

        // test: does this sink cover the specified edge?

        pPrivMouseSink->range->GetExtent(&acpStart, &cch);

        uRangeEdgeMin = acpStart;
        uRangeEdgeMax = acpStart + cch;

        //
        // Get GUID_PROP_MSIMTF_READONLY margin.
        //
        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_GET_READONLY_PROP_MARGIN,
                                 ImmIfIme->GetClientId(),
                                 ImmIfIme->GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Valid())
        {
            if (SUCCEEDED(_pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                                       &pPrivMouseSink->range, &cch)))
            {
                uEdge += cch;
            }
        }

        if (uEdge < uRangeEdgeMin)
            continue;
        if (uEdge == uRangeEdgeMin && uQuadrant < 2)
            continue;

        if (uEdge > uRangeEdgeMax)
            continue;
        if (uEdge == uRangeEdgeMax && uQuadrant > 1)
            continue;

        //
        // Call OnMouseEvent
        //
        hr = ((ITfMouseSink*)pgs->pSink)->OnMouseEvent(uEdge - uRangeEdgeMin /* adjust uEdge for this range's frame of reference */,
                                                       uQuadrant, dwBtnStatus, &fEaten);

        if (hr == S_OK && fEaten)
            return 1L;

        break; // we already found a covered range, don't bother querying any others
    }

    return IMEMOUSERET_NOTHANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\reconvcb.cpp ===
//
// pkes.cpp
//

#include "private.h"
#include "reconvcb.h"
#include "a_context.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CStartReconversionNotifySink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfStartReconversionNotifySink))
    {
        *ppvObj = SAFECAST(this, CStartReconversionNotifySink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CStartReconversionNotifySink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CStartReconversionNotifySink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CStartReconversionNotifySink::CStartReconversionNotifySink(CAImeContext *pAImeContext)
{
    Dbg_MemSetThisName(TEXT("CStartReconversionNotifySink"));

    _cRef = 1;
    _pAImeContext = pAImeContext;
}

//+---------------------------------------------------------------------------
//
// CStartReconversionNotifySink::Advise
//
//----------------------------------------------------------------------------

HRESULT CStartReconversionNotifySink::_Advise(ITfContext *pic)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfStartReconversionNotifySink, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CStartReconversionNotifySink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CStartReconversionNotifySink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// StartReconversionNotifySink::StartReconversion
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::StartReconversion()
{
    _pAImeContext->SetupReconvertString();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// StartReconversionNotifySink::EndReconversion
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::EndReconversion()
{
    _pAImeContext->EndReconvertString();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\profile.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    profile.h

Abstract:

    This file defines the CActiveIMMProfiles Class.

Author:

Revision History:

Notes:

--*/

#ifndef _PROFILE_H
#define _PROFILE_H

#include "ats.h"
#include "template.h"
#include "imtls.h"

class CAImeProfile : public IAImeProfile
{
public:
    CAImeProfile();
    virtual ~CAImeProfile();

public:
    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IAImeProfile methods
    //
    STDMETHODIMP Activate(void);

    STDMETHODIMP Deactivate(void);

    STDMETHODIMP ChangeCurrentKeyboardLayout(HKL hKL);

    STDMETHODIMP GetLangId(LANGID *plid);

    STDMETHODIMP GetCodePageA(UINT* puCodePage);

    STDMETHODIMP GetKeyboardLayout(HKL* phkl);

    STDMETHODIMP IsIME(HKL hKL);

    STDMETHODIMP GetActiveLanguageProfile(IN HKL hKL,
                                          IN GUID catid,
                                          OUT TF_LANGUAGEPROFILE* pLanguageProfile);

public:
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

protected:
    long m_ref;

    ITfInputProcessorProfiles*         m_profile;
    CActiveLanguageProfileNotifySink*   m_pActiveLanguageProfileNotifySink;

    //
    // Callbacks
    //
    static HRESULT ActiveLanguageProfileNotifySinkCallback(REFGUID rguid, REFGUID rguidProfile, BOOL fActivated, void *pv);

    //
    // Enumrate callbacks
    //
    struct LANG_PROF_ENUM_ARG {
        IN GUID catid;
        OUT TF_LANGUAGEPROFILE LanguageProfile;
    };
    static ENUM_RET LanguageProfilesCallback(TF_LANGUAGEPROFILE  LanguageProfile,
                                             LANG_PROF_ENUM_ARG* pLangProfEnumArg);

private:
    LANGID LangIdFromKL(HKL hKL)
    {
        return LOWORD(hKL);
    }

    HRESULT InitProfileInstance();

    void ResetCache(void)
    {
        m_fInitCP     = FALSE;
        m_fInitLangID = FALSE;
        m_fInitHKL    = FALSE;
    }

private:
    LANGID  m_SavedLangId;

    BOOL    m_fActivateThread : 1;    // TRUE: Activate this thread.
    BOOL    m_fInitCP         : 1;    // TRUE: initialized CodePage value.
    BOOL    m_fInitLangID     : 1;    // TRUE: initialized LangID value.
    BOOL    m_fInitHKL        : 1;    // TRUE: initialized hKL value.

    UINT    m_cp;
    LANGID  m_LangID;
    HKL     m_hKL;

};

#endif // _PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\profile.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    profile.cpp

Abstract:

    This file implements the CActiveIMMProfiles Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "globals.h"
#include "profile.h"
#include "idebug.h"

UINT WINAPI RawImmGetDescriptionA(HKL hkl, LPSTR lpstr, UINT uBufLen);

//
// Callbacks
//
HRESULT
CAImeProfile::ActiveLanguageProfileNotifySinkCallback(
    REFGUID rguid,
    REFGUID rguidProfile,
    BOOL fActivated,
    void *pv
    )
{
    DebugMsg(TF_FUNC, "ActiveLanguageProfileNotifySinkCallback");

    CAImeProfile* _this = (CAImeProfile*)pv;

    _this->ResetCache();

    return S_OK;
}

//
// Create instance
//

// entry point for msimtf.dll
HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return CAImeProfile::CreateInstance(pUnkOuter, riid, ppvObj);
}

/* static */
HRESULT
CAImeProfile::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    IMTLS *ptls;

    DebugMsg(TF_FUNC, "CAImeProfile::CreateInstance called.");

    *ppvObj = NULL;
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (ptls->pAImeProfile != NULL) {
        /*
         * CAImeProfile instance already have in a thread.
         */
        return ptls->pAImeProfile->QueryInterface(riid, ppvObj);
    }
    else {
        /*
         * Create an new CAImeProfile instance.
         */
        CAImeProfile* pImeProfile = new CAImeProfile;
        if (pImeProfile) {
            HRESULT hr = pImeProfile->QueryInterface(riid, ppvObj);

            if (SUCCEEDED(hr)) {
                hr = pImeProfile->InitProfileInstance();
                if (hr != S_OK) {
                    DebugMsg(TF_ERROR, "CAImeProfile::CreateInstance: Couldn't create tim!");
                    Assert(0); // couldn't create tim!
                }

                pImeProfile->Release();
            }

            Assert(ptls->pAImeProfile == NULL);
            ptls->pAImeProfile = pImeProfile;    // Set CAImeProfile instance in the TLS data.
            ptls->pAImeProfile->AddRef();

            return hr;
        }
    }

    return E_OUTOFMEMORY;
}

//
// Initialization, destruction and standard COM stuff
//

CAImeProfile::CAImeProfile(
    )
{
    DllAddRef();
    m_ref = 1;

    m_profile = NULL;
    m_pActiveLanguageProfileNotifySink = NULL;

    m_SavedLangId       = LANG_NEUTRAL;

    m_fActivateThread   = FALSE;
    ResetCache();

    m_cp     = CP_ACP;
    m_LangID = LANG_NEUTRAL;
    m_hKL    = 0;
}

CAImeProfile::~CAImeProfile()
{
    if (m_profile) {
        if (m_SavedLangId != LANG_NEUTRAL) {
            HRESULT hr = m_profile->ChangeCurrentLanguage(m_SavedLangId);
            if (FAILED(hr)) {
                TraceMsg(TF_ERROR, "CAImeProfile::~CAImeProfile: failed for ChangeCurrentLanguage");
            }
        }
        m_profile->Release();
        m_profile = NULL;
    }

    if (m_pActiveLanguageProfileNotifySink) {
        m_pActiveLanguageProfileNotifySink->_Unadvise();
        m_pActiveLanguageProfileNotifySink->Release();
        m_pActiveLanguageProfileNotifySink = NULL;
    }

    DllRelease();
}

HRESULT
CAImeProfile::QueryInterface(
    REFIID riid,
    void **ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IAImeProfile) ||
        IsEqualIID(riid, IID_IUnknown)) {
        *ppvObj = static_cast<IAImeProfile*>(this);
    }

    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CAImeProfile::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CAImeProfile::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

HRESULT
CAImeProfile::InitProfileInstance(
    )
{
    HRESULT hr;
    IMTLS *ptls;

    hr = TF_CreateInputProcessorProfiles(&m_profile);

    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CAImeProfile::InitProfileInstance: failed for CoCreate");
    }
    else if (m_pActiveLanguageProfileNotifySink == NULL) {
        m_pActiveLanguageProfileNotifySink = new CActiveLanguageProfileNotifySink(CAImeProfile::ActiveLanguageProfileNotifySinkCallback, this);
        if (m_pActiveLanguageProfileNotifySink == NULL) {
            DebugMsg(TF_ERROR, "Couldn't create ActiveLanguageProfileNotifySink!");

            m_profile->Release();
            m_profile = NULL;
            return E_FAIL;
        }

        if ((ptls = IMTLS_GetOrAlloc()) && ptls->tim != NULL)
        {
            m_pActiveLanguageProfileNotifySink->_Advise(ptls->tim);
        }
    }

    return hr;
}

HRESULT
CAImeProfile::Activate(
    void
    )
{
    m_fActivateThread   = TRUE;
    ResetCache();
    return S_OK;
}

HRESULT
CAImeProfile::Deactivate(
    void
    )
{
    m_fActivateThread   = FALSE;
    return S_OK;
}


HRESULT
CAImeProfile::ChangeCurrentKeyboardLayout(
    HKL hKL
    )
{
    HRESULT hr;

    LANGID CurrentLangId;
    hr = m_profile->GetCurrentLanguage(&CurrentLangId);
    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CAImeProfile::ChangeCurrentKeyboardLayout: failed for GetCurrentLanguage");
    }
    else if (hKL != NULL) {
        LANGID LangId = LangIdFromKL(hKL);
        if (LangId != CurrentLangId) {
            hr = m_profile->ChangeCurrentLanguage(LangId);
            if (FAILED(hr)) {
                m_SavedLangId = LANG_NEUTRAL;
                TraceMsg(TF_ERROR, "CAImeProfile::ChangeCurrentKeyboardLayout: failed for ChangeCurrentLanguage");
            }
            m_SavedLangId = LangId;
        }
    }
    return hr;
}

HRESULT 
CAImeProfile::GetLangId(
    LANGID *plid
    )
{
    if (!m_profile)
        return E_FAIL;

    if (!plid)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if (m_fInitLangID) {
        *plid = m_LangID;
    }
    else {
        *plid = LANG_NEUTRAL;

        hr = m_profile->GetCurrentLanguage(plid);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CAImeProfile::GetLangId: failed for GetCurrentLanguage");
        }
        else {
            m_LangID = *plid;
            m_fInitLangID = TRUE;
        }
    }

    return hr;
}

HRESULT 
CAImeProfile::GetCodePageA(
    UINT *puCodePage
    )
{
    if (!puCodePage)
        return E_INVALIDARG;

    if (m_fInitCP) {
        *puCodePage = m_cp;
    }
    else {
        *puCodePage = CP_ACP;

        LANGID langid;
        if (FAILED(GetLangId(&langid)))
            return E_FAIL;

        CHAR szCodePage[12];
        int ret = GetLocaleInfo(MAKELCID(langid, SORT_DEFAULT),
                                LOCALE_IDEFAULTANSICODEPAGE,
                                szCodePage,
                                sizeof(szCodePage));
        if (ret) {
            szCodePage[ARRAYSIZE(szCodePage)-1] = '\0';
            *puCodePage = strtoul(szCodePage, NULL, 10);
            m_cp = *puCodePage;
            m_fInitCP = TRUE;
        }
    }
    return S_OK;
}

#if 1
//
// TEST CODE
//
    #include "osver.h"

    extern HINSTANCE hIMM;   // temporary: do not call IMM32 for now

    BOOL IsIMEHKL(HKL hkl) {
       return ((((DWORD)(UINT_PTR)hkl) & 0xf0000000) == 0xe0000000) ? TRUE : FALSE;
    }
#endif

HRESULT 
CAImeProfile::GetKeyboardLayout(
    HKL* phkl
    )
{
    if (! phkl)
        return E_INVALIDARG;

    *phkl = NULL;

    if (m_fInitHKL) {
        *phkl = m_hKL;
    }
    else if (! m_fActivateThread) {
        return E_FAIL;
    }
    else {
        LANGID langid;
        GUID guidProfile;
        HRESULT hr = m_profile->GetActiveLanguageProfile(GUID_TFCAT_TIP_KEYBOARD,
                                                         &langid,
                                                         &guidProfile);
        if (FAILED(hr))
            return hr;

        //
        // Instead of (!IsEqualGUID(guidProfil, GUID_NULL)), we check
        // 2nd, 3r and 4th DWORD of guidProfile. Because
        // GetActivelanguageProfile(category guid) may return hKL in 
        // guidProfile
        //
        if ((((unsigned long *) &guidProfile)[1] != 0) ||
            (((unsigned long *) &guidProfile)[2] != 0) ||
            (((unsigned long *) &guidProfile)[3] != 0)) {
            /*
             * Current keyboard layout is Cicero.
             */
            m_hKL = (HKL)LongToHandle(langid);          // Don't use ::GetKeyboardLayout(0);
                                                        // Cicero awre doesn't case hKL.

#if 1
            //
            // check the dummy hkl
            //
            HKL fake_hKL = ::GetKeyboardLayout(0);
            if (IsIMEHKL(fake_hKL)) {
                //
                // fake hKL is IME hKL.
                //
                hIMM = GetSystemModuleHandle("imm32.dll");
                if (hIMM != NULL) {
                    char szDesc[256];
                    char szDumbDesc[256];

                    DWORD ret = RawImmGetDescriptionA(fake_hKL, szDesc, sizeof(szDesc));
                    if (ret != 0) {
                        wsprintf(szDumbDesc, "hkl%04x", LOWORD((UINT_PTR)fake_hKL));
                        if (lstrcmp(szDumbDesc, szDesc) != 0) {
                            //
                            // fake hKL is regacy IME hKL.
                            //
                            if (IsOnNT()) {
                                char szKLID[256];

                                wsprintf(szKLID, "%08x", LOWORD((UINT_PTR) m_hKL));
                                HKL win32_hKL = LoadKeyboardLayout(szKLID, KLF_NOTELLSHELL);
                            }
                            else {
                            }
                        }
                        else {
                            //
                            // Dummy Cicero hKL for Win9x.
                            //
                            UINT n = GetKeyboardLayoutList(0, NULL);
                            if (n) {
                                HKL* phKL = new HKL [n];
                                if (phKL) {
                                    HKL* p = phKL;

                                    GetKeyboardLayoutList(n, phKL);

                                    while (n--) {
                                        if (IsIMEHKL(*p)) {
                                            ret = RawImmGetDescriptionA(*p, szDesc, sizeof(szDesc));
                                            if (ret != 0) {
                                                wsprintf(szDumbDesc, "hkl%04x", LOWORD((UINT_PTR)*p));
                                                if (lstrcmp(szDumbDesc, szDesc) == 0) {
                                                    //
                                                    // Dummy Cicero hKL for Win9x.
                                                    //
                                                    char szKLID[256];

                                                    wsprintf(szKLID, "%08x", LOWORD((UINT_PTR) *p));
                                                    HKL win32_hKL = LoadKeyboardLayout(szKLID, KLF_NOTELLSHELL);
                                                    break;
                                                }
                                            }
                                        }

                                        p++;
                                    }

                                    delete [] phKL;
                                }
                            }
                        }
                    }

                    FreeLibrary(hIMM);
                    hIMM = NULL;
                }
            }
#endif
        }
        else if (!IsEqualGUID(guidProfile, GUID_NULL)) {
            /*
             * Current keyboard layout is regacy IME.
             */
            m_hKL = (HKL)LongToHandle(*(DWORD *)&guidProfile);
        }
        else {
            m_hKL = 0;
        }

        *phkl = m_hKL;
        m_fInitHKL = TRUE;
    }
    return S_OK;
}

HRESULT 
CAImeProfile::IsIME(
    HKL hKL
    )
{
    LANGID LangId = LangIdFromKL(hKL);

    Interface<IEnumTfLanguageProfiles> LanguageProfiles;
    HRESULT hr = m_profile->EnumLanguageProfiles(LangId, 
                                                 LanguageProfiles);
    if (FAILED(hr))
        return S_FALSE;

    CEnumrateValue<IEnumTfLanguageProfiles,
                   TF_LANGUAGEPROFILE,
                   LANG_PROF_ENUM_ARG> Enumrate(LanguageProfiles,
                                                LanguageProfilesCallback);

    ENUM_RET ret = Enumrate.DoEnumrate();
    if (ret != ENUM_FIND)
        return S_FALSE;
    else
        return S_OK;
}

HRESULT
CAImeProfile::GetActiveLanguageProfile(
    IN HKL hKL,
    IN GUID catid,
    OUT TF_LANGUAGEPROFILE* pLanguageProfile
    )
{
    LANGID LangId = LangIdFromKL(hKL);

    Interface<IEnumTfLanguageProfiles> LanguageProfiles;
    HRESULT hr = m_profile->EnumLanguageProfiles(LangId, 
                                                 LanguageProfiles);
    if (FAILED(hr))
        return S_FALSE;

    LANG_PROF_ENUM_ARG LangProfEnumArg;
    LangProfEnumArg.catid = catid;

    CEnumrateValue<IEnumTfLanguageProfiles,
                   TF_LANGUAGEPROFILE,
                   LANG_PROF_ENUM_ARG> Enumrate(LanguageProfiles,
                                                LanguageProfilesCallback,
                                                &LangProfEnumArg);

    ENUM_RET ret = Enumrate.DoEnumrate();
    if (ret != ENUM_FIND || pLanguageProfile == NULL)
        return S_FALSE;
    else {
        *pLanguageProfile = LangProfEnumArg.LanguageProfile;
        return S_OK;
    }
}

ENUM_RET
CAImeProfile::LanguageProfilesCallback(
    TF_LANGUAGEPROFILE   LanguageProfile,
    LANG_PROF_ENUM_ARG* pLangProfEnumArg
    )
{
    if (LanguageProfile.fActive &&
        ! IsEqualGUID(LanguageProfile.clsid, GUID_NULL)) {
        if (pLangProfEnumArg) {
            if (! IsEqualGUID(LanguageProfile.catid, pLangProfEnumArg->catid)) {
                return ENUM_CONTINUE;
            }
            pLangProfEnumArg->LanguageProfile = LanguageProfile;
        }
        return ENUM_FIND;
    }

    return ENUM_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\reconvcb.h ===
//
// pkes.h
//
// Generic ITfPreservedKeyNotifySink object
//

#ifndef RECONVCB_H
#define RECONVCB_H

#include "private.h"

class CAImeContext;

class CStartReconversionNotifySink : public ITfStartReconversionNotifySink
{
public:
    CStartReconversionNotifySink(CAImeContext *pAImeContext);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfStartReconversionNotifySink
    //
    STDMETHODIMP StartReconversion();
    STDMETHODIMP EndReconversion();

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:
    long _cRef;
    ITfContext *_pic;
    CAImeContext *_pAImeContext;
    DWORD _dwCookie;
};

#endif // RECONVCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\tmgrevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tmgrevcb.cpp

Abstract:

    This file implements the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "tmgrevcb.h"
#include "cime.h"
#include "imtls.h"

// static
HRESULT
CThreadMgrEventSinkCallBack::ThreadMgrEventSinkCallback(
    UINT uCode,
    ITfContext* pic,
    void* pv
    )
{
    DebugMsg(TF_FUNC, "ThreadMgrEventSinkCallback");

    IMTLS *ptls;
    HRESULT hr = S_OK;

    switch (uCode) {
        case TIM_CODE_INITIC:
        case TIM_CODE_UNINITIC:
            {
                if ((ptls = IMTLS_GetOrAlloc()) == NULL)
                    break;

                IMCLock imc(ptls->hIMC);
                if (SUCCEEDED(hr=imc.GetResult())) {
                    if (! ptls->m_fMyPushPop) {
                        SendMessage(imc->hWnd, WM_IME_NOTIFY,
                                    (uCode == TIM_CODE_INITIC) ? IMN_OPENCANDIDATE : IMN_CLOSECANDIDATE, 1L);
                    }
                }
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\tmgrevcb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tmgrevcb.h

Abstract:

    This file defines the CThreadMgrEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TMGREVCB_H_
#define _TMGREVCB_H_


class CThreadMgrEventSinkCallBack : public CThreadMgrEventSink
{
public:
    CThreadMgrEventSinkCallBack() : CThreadMgrEventSink(NULL, ThreadMgrEventSinkCallback, NULL) {};

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // Callbacks
    //
private:
    static HRESULT ThreadMgrEventSinkCallback(UINT uCode, ITfContext* pic, void* pv);

};

#endif // _TMGREVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\uiwndhd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwndhd.h

Abstract:

    This file defines the IME UI window handler Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UIWNDHD_H_
#define _UIWNDHD_H_

#include "globals.h"
#include "imtls.h"

extern LPCTSTR IMEUIWndHandlerName;

class CIMEUIWindowHandler
{
public:
    CIMEUIWindowHandler(HWND hwnd = NULL);

    LRESULT ImeUIWndProcWorker(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE);

private:
    LRESULT UIWndCreateHandler(LPCREATESTRUCT lpcs);
    VOID    UIWndDestroyHandler();
    VOID    UIWndFinalDestroyHandler();

    LRESULT ImeUINotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
    LRESULT ImeUISelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

    LRESULT ImeUIMsImeHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
    LRESULT ImeUIMsImeMouseHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
    LRESULT ImeUIMsImeModeBiasHandler(WPARAM wParam, LPARAM lParam);

    BOOL IsMsImeMessage(UINT uMsg)
    {
        if (uMsg == WM_MSIME_SERVICE ||
            uMsg == WM_MSIME_UIREADY ||
            uMsg == WM_MSIME_RECONVERTREQUEST ||
            uMsg == WM_MSIME_RECONVERT ||
            uMsg == WM_MSIME_DOCUMENTFEED ||
            uMsg == WM_MSIME_QUERYPOSITION ||
            uMsg == WM_MSIME_MODEBIAS ||
            uMsg == WM_MSIME_SHOWIMEPAD ||
            uMsg == WM_MSIME_MOUSE ||
            uMsg == WM_MSIME_KEYMAP)
            return TRUE;
        else
            return FALSE;
    }

    LRESULT ImeUIPrivateHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

    BOOL IsPrivateMessage(UINT uMsg)
    {
        IMTLS *ptls = IMTLS_GetOrAlloc();

        if (ptls == NULL)
            return FALSE;

        if (uMsg == ptls->prvUIWndMsg.uMsgOnLayoutChange ||
            uMsg == ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer)
            return TRUE;
        else
            return FALSE;
    }

private:
    static BOOL EnumUnSelectCallback(HIMC hIMC, LPARAM lParam);

private:
    typedef struct tagUIEXTRA {
        HWND  hImeUIWnd;
    } UIEXTRA;
    UIEXTRA      m_imeuiextra;

};


CIMEUIWindowHandler* GetImeUIWndHandler(HWND hwnd);


#endif // _UIWNDHD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\ui.cpp ===
#include "private.h"

#include "imedefs.h"
#include "uiwndhd.h"


/**********************************************************************/
/*                                                                    */
/* UIWndProc()                                                        */
/*                                                                    */
/* IME UI window procedure                                            */
/*                                                                    */
/**********************************************************************/

LRESULT CALLBACK
UIWndProcA(
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CIMEUIWindowHandler* pimeui = GetImeUIWndHandler(hUIWnd);
    return pimeui->ImeUIWndProcWorker(uMsg, wParam, lParam, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\cicload.h ===
//
// aimmlaod.h
//


#define ID_ICON_INDICATOR   1000


// Indicator Menu Item IDs
#define IDM_INDIC_CANCEL      2000
#define IDM_INDIC_UNLOADAIMM  2001
#define IDM_INDIC_IMXSTART    2100
#define IDM_INDIC_IMXEND      2199
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\uiwndhd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwndhd.cpp

Abstract:

    This file implements the IME UI window handler Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cime.h"
#include "template.h"
#include "uiwndhd.h"
#include "editses.h"
#include "imeapp.h"


LPCTSTR IMEUIWndHandlerName = TEXT("IMEUIWindowHandler");


CIMEUIWindowHandler::CIMEUIWindowHandler(
    HWND hwnd
    )
{
    IMTLS *ptls;

    m_imeuiextra.hImeUIWnd = hwnd;

    if (ptls = IMTLS_GetOrAlloc())
    {
        ptls->prvUIWndMsg.hWnd = hwnd;
        ptls->prvUIWndMsg.uMsgOnLayoutChange = RegisterWindowMessageA( TEXT("PrivateUIWndMsg OnLayoutChange") );
        ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer = RegisterWindowMessageA( TEXT("PrivateUIWndMsg OnClearDocFeedBuffer") );
    }
}



LRESULT
CIMEUIWindowHandler::ImeUIWndProcWorker(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    LONG lRet = 0L;

    switch (uMsg) {
        case WM_CREATE:
            return UIWndCreateHandler((LPCREATESTRUCT)lParam);

        case WM_DESTROY:
            /*
             * We are destroying the IME UI window,
             * destroy any related window that it owns.
             */
            UIWndDestroyHandler();
            return 0L;

        case WM_NCDESTROY:
            UIWndFinalDestroyHandler();
            return 0L;

        case WM_IME_NOTIFY:
            return ImeUINotifyHandler(uMsg, wParam, lParam, fUnicode);

        case WM_IME_SELECT:
            return ImeUISelectHandler(uMsg, wParam, lParam, fUnicode);

        default:
            if (IsMsImeMessage(uMsg))
                return ImeUIMsImeHandler(uMsg, wParam, lParam, fUnicode);
            else if (IsPrivateMessage(uMsg))
                return ImeUIPrivateHandler(uMsg, wParam, lParam, fUnicode);
            else
                return fUnicode ? DefWindowProcW(m_imeuiextra.hImeUIWnd, uMsg, wParam, lParam)
                                : DefWindowProcA(m_imeuiextra.hImeUIWnd, uMsg, wParam, lParam);
    }

    return lRet;
}


LRESULT
CIMEUIWindowHandler::UIWndCreateHandler(
    LPCREATESTRUCT lpcs
    )
{
    return 0L;
}


VOID
CIMEUIWindowHandler::UIWndDestroyHandler(
    )
{
}


VOID
CIMEUIWindowHandler::UIWndFinalDestroyHandler(
    )
{
    SetProp(m_imeuiextra.hImeUIWnd, IMEUIWndHandlerName, NULL);
    delete this;
}

LRESULT
CIMEUIWindowHandler::ImeUINotifyHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    IMCLock imc((HIMC)GetWindowLongPtr(m_imeuiextra.hImeUIWnd, IMMGWLP_IMC));
    if (imc.Invalid())
        return 0L;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return 0L;

    ImmIfIME* const _pImmIfIME = _pAImeContext->GetImmIfIME();
    if (_pImmIfIME == NULL)
        return 0L;

    switch (wParam) {
        case IMN_SETOPENSTATUS:
            //
            // we can track this in SetOpenStatus().
            // Don't have to sync when IMM32 is called.
            //
            // _pImmIfIME->OnSetOpenStatus(imc);
            break;
        case IMN_SETSTATUSWINDOWPOS:
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
            break;
        case IMN_SETCONVERSIONMODE:
        case IMN_SETSENTENCEMODE:
            //
            // we can track this in SetConversionMode().
            // Don't have to sync when IMM32 is called.
            //
            // _pImmIfIME->OnSetConversionSentenceMode(imc);
            break;
        case IMN_SETCANDIDATEPOS:
        case IMN_CHANGECANDIDATE:
            _pImmIfIME->OnSetCandidatePos(imc);
            break;
        case IMN_OPENCANDIDATE:
            _pAImeContext->m_fOpenCandidateWindow = TRUE;
            break;
        case IMN_CLOSECANDIDATE:
            _pAImeContext->m_fOpenCandidateWindow = FALSE;
            {
                /*
                 * A-Synchronize call ImmIfIME::ClearDocFeedBuffer
                 * because this method had a protected.
                 */
                IMTLS *ptls;
                if (ptls = IMTLS_GetOrAlloc())
                {
                    PostMessage(ptls->prvUIWndMsg.hWnd,
                                ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer, (WPARAM)(HIMC)imc, 0);
                }
            }
            break;
        case IMN_SETCOMPOSITIONFONT:
        case IMN_SETCOMPOSITIONWINDOW:
        case IMN_GUIDELINE:
            break;
        case WM_IME_STARTCOMPOSITION:
            _pAImeContext->InquireIMECharPosition(imc, NULL);
            break;
        case WM_IME_ENDCOMPOSITION:
            _pAImeContext->ResetIMECharPosition(imc);
            break;
    }

    return 0L;
}

LRESULT
CIMEUIWindowHandler::ImeUIMsImeHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    IMTLS *ptls;

    if (uMsg == WM_MSIME_MOUSE) {
        return ImeUIMsImeMouseHandler(uMsg, wParam, lParam, fUnicode);
    }
    else if (uMsg == WM_MSIME_MODEBIAS)
    {
        return ImeUIMsImeModeBiasHandler(wParam, lParam);
    }
    else if (uMsg == WM_MSIME_RECONVERTREQUEST)
    {

        if (wParam == FID_RECONVERT_VERSION)
        {
            // they're asking for version # so return something
            return 1L;
        }

        ptls = IMTLS_GetOrAlloc();

        if (ptls && ptls->pAImm)
        {
            HIMC himc;
            HWND hwnd = (HWND)lParam;

            if (S_OK == ptls->pAImm->GetContext(hwnd, &himc))
            {
                IMCLock imc((HIMC)himc);
                if (!imc.Invalid())
                {
                    CAImeContext* _pAImeContext = imc->m_pAImeContext;
                    if (_pAImeContext == NULL)
                        return 0L;

                    _pAImeContext->SetupReconvertString(WM_MSIME_RECONVERT);
                    _pAImeContext->EndReconvertString();
                    return 1L;
                }
            }
        }
    }
    else if (uMsg ==  WM_MSIME_SERVICE)
    {
        ptls = IMTLS_GetOrAlloc();

        if (ptls != NULL)
        {
            LANGID langid;

            ptls->pAImeProfile->GetLangId(&langid);

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
                return 0L;
        }

        return 1L;    // Win32 Layer support WM_MSIME_xxxx message.
    }

    return 0L;
}

LRESULT
CIMEUIWindowHandler::ImeUIMsImeMouseHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )

/*++

Method:

    WM_MSIME_MOUSE

Routine Description:

    Mouse Operation on Composition String

Arguments:

    wParam - Mouse operation code.
                 LOBYTE(LOWORD(wParam))
                     IMEMOUSE_VERSION
                     IMEMOUSE_NONE
                     IMEMOUSE_LDOWN
                     IMEMOUSE_RDOWN
                     IMEMOUSE_MDOWN
                     IMEMOUSE_WUP
                     IMEMOUSE_WDOWN
                 HIBYTE(LOWORD(wParam))
                     Mouse Position
                 HIWORD(wParam)
                     Clicked position
    lParam - Input Context handle (HIMC).

Return Value:

    Returns 1 if IME handled this message.
    IMEMOUSERET_NOTHANDLED if IME did not handled this message.

--*/

{
    ULONG dwBtnStatus;

    // special case: version check
    if (LOBYTE(LOWORD(wParam)) == IMEMOUSE_VERSION)
        return 1; // we support version 1.0

    IMCLock imc((HIMC)lParam);
    if (imc.Invalid())
        return IMEMOUSERET_NOTHANDLED;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return IMEMOUSERET_NOTHANDLED;

    ULONG uEdge       = HIWORD(wParam);
    ULONG uQuadrant   = HIBYTE(LOWORD(wParam));
    ULONG dwBtnStatusIme = LOBYTE(LOWORD(wParam));

    //
    // need to xlate dwBtnStatus from WM_MSIME_MOUSE flags to WM_MOUSE flags
    //
    dwBtnStatus = 0;

    if (dwBtnStatusIme & IMEMOUSE_LDOWN)
    {
        dwBtnStatus |= MK_LBUTTON;
    }
    if (dwBtnStatusIme & IMEMOUSE_MDOWN)
    {
        dwBtnStatus |= MK_MBUTTON;
    }
    if (dwBtnStatusIme & IMEMOUSE_RDOWN)
    {
        dwBtnStatus |= MK_RBUTTON;
    }

    // mouse wheel needs to be xlated from IMEMOUSE_WUP/IMEMOUSE_WDOWN to WHEEL_DELTA units 
    if (dwBtnStatusIme & IMEMOUSE_WUP)
    {
        dwBtnStatus |= (WHEEL_DELTA << 16);
    }
    else if (dwBtnStatusIme & IMEMOUSE_WDOWN)
    {
        dwBtnStatus |= (((unsigned long)(-WHEEL_DELTA)) << 16);
    }

    return _pAImeContext->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, (HIMC)lParam);
}

/*++

Method:

    CIMEUIWindowHandler::ImeUIMsImeModeBiasHandler

Routine Description:

    Handles WM_MSIME_MODEBIAS messages sent to the ui window.

Arguments:

    wParam - [in] operation: get version, get mode, set mode
    lParam - [in] for set mode, the new bias
                  otherwise ignored

Return Value:

    If wParam is MODEBIAS_GETVERSION, returns version number of interface.
    If wParam is MODEBIAS_SETVALUE, returns non-zero value if succeeded. Returns 0 if fail.
    If wParam is MODEBIAS_GETVALUE, returns current bias mode.
    
--*/

LRESULT CIMEUIWindowHandler::ImeUIMsImeModeBiasHandler(WPARAM wParam, LPARAM lParam)
{
    if (wParam == MODEBIAS_GETVERSION)
        return 1; // version 1
       
    IMCLock imc((HIMC)GetWindowLongPtr(m_imeuiextra.hImeUIWnd, IMMGWLP_IMC));
    if (imc.Invalid())
        return 0;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    switch (wParam)
    {
        case MODEBIAS_GETVALUE:
            return _pAImeContext ? _pAImeContext->lModeBias : 0L;

        case MODEBIAS_SETVALUE:
            // check lParam
            if (lParam != MODEBIASMODE_DEFAULT &&
                lParam != MODEBIASMODE_FILENAME &&
                lParam != MODEBIASMODE_DIGIT)
            {
                Assert(0); // bogus mode bias!
                return 0;  // failure
            }

            // set the new value
            if (_pAImeContext)
            {
                _pAImeContext->lModeBias = lParam;

                // let cicero know the mode bias has changed
                Interface_Attach<ITfContextOwnerServices> iccb = _pAImeContext->GetInputContextOwnerSink();
                iccb->OnAttributeChange(GUID_PROP_MODEBIAS);
            }

            return 1; // success
    }

    Assert(0); // should never get here; bogus wParam
    return 0;
}

LRESULT
CIMEUIWindowHandler::ImeUIPrivateHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )

/*++

Method:

    CIMEUIWindowHandler::ImeUIPrivateHandler

Routine Description:

    Handles WM_PRIVATE_xxx messages sent to the ui window.

Arguments:

    wParam - [in] HIMC : input context handle
    lParam - [in] N/A

Return Value:

--*/

{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (uMsg == ptls->prvUIWndMsg.uMsgOnLayoutChange) {
        IMCLock imc((HIMC)wParam);
        if (imc.Invalid())
            return E_FAIL;

        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        Interface_Attach<ITfContextOwnerServices> iccb = _pAImeContext->GetInputContextOwnerSink();

        iccb->AddRef();

        /*
         * Repositioning candidate window
         */
        iccb->OnLayoutChange();
        iccb->Release();
    }
    else if (uMsg == ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer) {
        IMCLock imc((HIMC)wParam);
        if (imc.Invalid())
            return E_FAIL;

        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        ImmIfIME* const _pImmIfIME = _pAImeContext->GetImmIfIME();
        if (_pImmIfIME == NULL)
            return E_FAIL;

        //
        // Clear DocFeed buffer
        // Find GUID_PROP_MSIMTF_READONLY property and SetText(NULL).
        //
        _pImmIfIME->ClearDocFeedBuffer(_pAImeContext->GetInputContext(), imc);  // TF_ES_SYNC
    }

    return S_OK;
}

extern HINSTANCE hIMM;   // temporary: do not call IMM32 for now
BOOL WINAPI RawImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

LRESULT
CIMEUIWindowHandler::ImeUISelectHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    if ((! wParam) && (! IsOnNT()) )
    {
        //
        // Unselect Cicero keyboard layout.
        //
        // We needs to call postponed lock so release all queueing request for edit session here.
        // Especially, ESCB_UPDATECOMPOSITIONSTRING should handle before switch to Legacy IME,
        // because this edit session possible to rewrite hIMC->hCompStr buffer.
        // Some Legacy IME have dependency of size and each offset with hCompStr.
        //
        // IsOnNT is ImmIfIME::SelectEx()
        //
        hIMM = GetSystemModuleHandle("imm32.dll");
        if (hIMM != NULL) {
            RawImmEnumInputContext(0,                        // Current thread
                                   EnumUnSelectCallback,     // enumerate callback function
                                   NULL);                    // lParam
        }
    }
    return 0L;
}

/* static */
BOOL
CIMEUIWindowHandler::EnumUnSelectCallback(
    HIMC hIMC,
    LPARAM lParam
    )
{
    IMCLock imc(hIMC);
    if (imc.Invalid())
        return TRUE;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return TRUE;

    ImmIfIME* const _pImmIfIME = _pAImeContext->GetImmIfIME();
    if (_pImmIfIME == NULL)
        return TRUE;

    Interface_Attach<ITfThreadMgr_P> tim(_pImmIfIME->GetThreadManagerInternal());
    if (tim.Valid())
    {
        Interface_Attach<ITfContext> ic(_pAImeContext->GetInputContext());
        if (ic.Valid())
        {
            tim->RequestPostponedLock(ic.GetPtr());
        }
    }

    return TRUE;
}

CIMEUIWindowHandler*
GetImeUIWndHandler(
    HWND hwnd
    )
{
    CIMEUIWindowHandler* pimeui = static_cast<CIMEUIWindowHandler*>(GetProp(hwnd, IMEUIWndHandlerName));
    if (pimeui == NULL) {
        pimeui = new CIMEUIWindowHandler(hwnd);
        SetProp(hwnd, IMEUIWndHandlerName, pimeui);
    }

    return pimeui;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\txtevcb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    txtevcb.h

Abstract:

    This file defines the CTextEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TXTEVCB_H_
#define _TXTEVCB_H_

class ImmIfIME;

class CTextEventSinkCallBack : public CTextEventSink
{
public:
    CTextEventSinkCallBack(ImmIfIME* pImmIfIME, HIMC hIMC);
    virtual ~CTextEventSinkCallBack();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    BOOL _IsSapiFeedbackUIPresent(Interface_Attach<ITfContext>& ic, TESENDEDIT *ee);

    //
    // Callbacks
    //
private:
    static HRESULT TextEventSinkCallback(UINT uCode, void *pv, void *pvData);

    typedef struct _EnumROPropertyArgs
    {
        Interface<ITfProperty> Property;
        TfEditCookie ec;
        GUID         comp_guid;
        LIBTHREAD    *pLibTLS;
    } EnumROPropertyArgs;

    //
    // Enumrate callbacks
    //
    typedef struct _EnumPropertyUpdateArgs
    {
        _EnumPropertyUpdateArgs(ITfContext* pv, ImmIfIME* p1, IMCLock& p2) : ic(pv), immif(p1), imc(p2) { }

        Interface<ITfProperty> Property;
        TfEditCookie           ec;
        Interface_Attach<ITfContext> ic;
        ImmIfIME*              immif;
        IMCLock&               imc;
        DWORD                  dwDeltaStart;
    } EnumPropertyUpdateArgs;
    static ENUM_RET EnumReadOnlyRangeCallback(ITfRange* pRange, EnumROPropertyArgs *pargs);

    //
    // Enumrate property update
    //
    static ENUM_RET EnumPropertyUpdateCallback(ITfRange* update_range, EnumPropertyUpdateArgs *pargs);

    ImmIfIME     *m_pImmIfIME;
    HIMC         m_hIMC;
};

#endif // _TXTEVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\aimm1.2\win32\txtevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    txtevcb.cpp

Abstract:

    This file implements the CTextEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cime.h"
#include "txtevcb.h"
#include "immif.h"
#include "editses.h"


// from ctf\sapilayr\globals.cpp
const GUID GUID_ATTR_SAPI_GREENBAR =
{
    0xc3a9e2e8,
    0x738c,
    0x48e0,
    {0xac, 0xc8, 0x43, 0xee, 0xfa, 0xbf, 0x83, 0xc8}
};

BOOL CTextEventSinkCallBack::_IsSapiFeedbackUIPresent(
    Interface_Attach<ITfContext>& ic,
    TESENDEDIT *ee
    )
{
    EnumROPropertyArgs args;

    args.comp_guid = GUID_ATTR_SAPI_GREENBAR;
    if (FAILED(ic->GetProperty(GUID_PROP_ATTRIBUTE, args.Property)))
        return FALSE;

    Interface<IEnumTfRanges> EnumReadOnlyProperty;
    if (FAILED(args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL)))
        return FALSE;

    args.ec = ee->ecReadOnly;
    args.pLibTLS = m_pImmIfIME->_GetLibTLS();

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumROPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                     EnumReadOnlyRangeCallback,
                                                     &args);        // Argument of callback func.
    ENUM_RET ret_prop_attribute = Enumrate.DoEnumrate();
    if (ret_prop_attribute == ENUM_FIND)
        return TRUE;

    return FALSE;
}

// static
HRESULT
CTextEventSinkCallBack::TextEventSinkCallback(
    UINT uCode,
    void *pv,
    void *pvData
    )
{
    IMTLS *ptls;

    DebugMsg(TF_FUNC, "TextEventSinkCallback");

    ASSERT(uCode == ICF_TEXTDELTA); // the pvData cast only works in this case
    if (uCode != ICF_TEXTDELTA)
        return S_OK;

    CTextEventSinkCallBack* _this = (CTextEventSinkCallBack*)pv;
    ASSERT(_this);

    ImmIfIME* _ImmIfIME = _this->m_pImmIfIME;
    ASSERT(_ImmIfIME);

    TESENDEDIT* ee = (TESENDEDIT*)pvData;
    ASSERT(ee);

    HRESULT hr;

    IMCLock imc(_this->m_hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

#ifdef UNSELECTCHECK
    if (!_pAImeContext->m_fSelected)
        return S_OK;
#endif UNSELECTCHECK

    Interface_Attach<ITfContext> ic(_pAImeContext->GetInputContext());

#if 0
    //
    // What we want to do here is a check of reentrancy of this event sink.
    //
    BOOL fInWrite;
    if (FAILED(hr = ic->InWriteSession(_ImmIfIME->GetClientId(), &fInWrite)))
         return hr;

    Assert(!fInWrite);
#endif

    BOOL     fLangEA       = TRUE;
    BOOL     fComp         = TRUE;
    BOOL     fSapiFeedback = TRUE;

    /*
     * if EA language, then we have composition text.
     */

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;
    
    LANGID langid;
    ptls->pAImeProfile->GetLangId(&langid);
    if (PRIMARYLANGID(langid) == LANG_JAPANESE ||
        PRIMARYLANGID(langid) == LANG_KOREAN   ||
        PRIMARYLANGID(langid) == LANG_CHINESE    ) {

        // need to check speech feedback UI for these lang too
        BOOL fFeedback = _this->_IsSapiFeedbackUIPresent(ic, ee);

        /*
         * This is automatic detection code of the Hangul + alphanumeric input
         * If detected a Hangul + alphanumeric, then we finalized all text.
         */
        EnumROPropertyArgs args;
        args.comp_guid = GUID_NULL;
        if (FAILED(hr=ic->GetProperty(GUID_PROP_COMPOSING, args.Property)))
            return hr;

        Interface<IEnumTfRanges> EnumReadOnlyProperty;
        hr = args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL);
        if (FAILED(hr))
            return hr;

        args.ec = ee->ecReadOnly;
        args.pLibTLS = _ImmIfIME->_GetLibTLS();

        CEnumrateInterface<IEnumTfRanges,
                           ITfRange,
                           EnumROPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                         EnumReadOnlyRangeCallback,
                                                         &args);        // Argument of callback func.
        ENUM_RET ret_prop_composing = Enumrate.DoEnumrate();
        if (!fFeedback && ret_prop_composing != ENUM_FIND)
            fComp = FALSE;
    }
    else {
        /*
         * if not EA language and not SAPI, then we immediately finalize the text.
         */

        fLangEA = FALSE;

        EnumROPropertyArgs args;
        args.comp_guid = GUID_ATTR_SAPI_GREENBAR;
        if (FAILED(hr=ic->GetProperty(GUID_PROP_ATTRIBUTE, args.Property)))
            return hr;

        Interface<IEnumTfRanges> EnumReadOnlyProperty;
        hr = args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL);
        if (FAILED(hr))
            return hr;

        args.ec = ee->ecReadOnly;
        args.pLibTLS = _ImmIfIME->_GetLibTLS();

        CEnumrateInterface<IEnumTfRanges,
                           ITfRange,
                           EnumROPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                         EnumReadOnlyRangeCallback,
                                                         &args);        // Argument of callback func.
        ENUM_RET ret_prop_attribute = Enumrate.DoEnumrate();
        if (ret_prop_attribute != ENUM_FIND)
            fSapiFeedback = FALSE;
    }

    //
    // Update composition and generate WM_IME_COMPOSITION
    //
    //    if EA lang and there is composition property range.
    //        - EA has a hIMC composition by default.
    //
    //    if non EA lang and there is SAPI green bar.
    //        - there is only hIMC composition if there is Speech Green bar.
    //
    //    if Reconversion just started.
    //        - because some tip may not change the text yet.
    //          then there is no composition range yet.
    //
    //    if now clearing DocFeed buffer.
    //        - because the change happens in read-only text
    //          nothing in hIMC changes.
    //
    if ((fLangEA && fComp) || 
        (!fLangEA && fSapiFeedback) ||
        _pAImeContext->IsInReconvertEditSession() ||
        _pAImeContext->IsInClearDocFeedEditSession())
    {
        //
        // Retreive text delta
        //
        const GUID guid = GUID_PROP_COMPOSING;
        const GUID *pguid = &guid;

        Interface<IEnumTfRanges> EnumPropertyUpdate;
        hr = ee->pEditRecord->GetTextAndPropertyUpdates(0,          // dwFlags
                                                        &pguid, 1,
                                                        EnumPropertyUpdate);
        if (SUCCEEDED(hr)) {
            EnumPropertyUpdateArgs args(ic.GetPtr(), _ImmIfIME, imc);

            if (FAILED(hr=ic->GetProperty(GUID_PROP_COMPOSING, args.Property)))
                return hr;

            args.ec = ee->ecReadOnly;
            args.dwDeltaStart = 0;

            CEnumrateInterface<IEnumTfRanges,
                               ITfRange,
                               EnumPropertyUpdateArgs> Enumrate(EnumPropertyUpdate,
                                                                EnumPropertyUpdateCallback,
                                                                &args);        // Argument of callback func.
            ENUM_RET ret_prop_update = Enumrate.DoEnumrate();
            if (ret_prop_update == ENUM_FIND) {
                //
                // Update composition string with delta start position
                //
                return _ImmIfIME->_UpdateCompositionString(args.dwDeltaStart);
            }
        }

        //
        // Update composition string
        //
        return _ImmIfIME->_UpdateCompositionString();
    }
    else {
#if 0
        //
        // Review: 
        //  
        //   need to be reviewed by Matsubara-san.
        //   Why we need this? We can not assume tip always set the new 
        //   selection.
        //
        BOOL fChanged;
        hr = ee->pEditRecord->GetSelectionStatus(&fChanged);
        if (FAILED(hr))
            return hr;

        if (! fChanged)
            /*
             * If no change selection status, then return it.
             */
            return S_FALSE;

#endif
        //
        // Clear DocFeed range's text store.
        // Find GUID_PROP_MSIMTF_READONLY property and SetText(NULL).
        //
        // ImmIfIME::ClearDocFeedBuffer() essential function for all ESCB_RECONVERTSTRING's edit
        // session except only ImmIfIME::SetupDocFeedString() since this is provided for keyboard
        // TIP's DocFeeding.
        //
        _ImmIfIME->ClearDocFeedBuffer(_pAImeContext->GetInputContext(), imc, FALSE);  // No TF_ES_SYNC
        //
        // Composition complete.
        //
        return _ImmIfIME->_CompComplete(imc, FALSE);    //  No TF_ES_SYNC
    }
}

// static
ENUM_RET
CTextEventSinkCallBack::EnumReadOnlyRangeCallback(
    ITfRange* pRange,
    EnumROPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        if (IsEqualIID(pargs->comp_guid, GUID_NULL)) {
            if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0))
                ret = ENUM_FIND;
        }
        else if (V_VT(&var) == VT_I4) {
            TfGuidAtom guid = V_I4(&var);
            if (IsEqualTFGUIDATOM(pargs->pLibTLS, guid, pargs->comp_guid))
                ret = ENUM_FIND;
        }
    }

    VariantClear(&var);
    return ret;
}


// static
ENUM_RET
CTextEventSinkCallBack::EnumPropertyUpdateCallback(
    ITfRange* update_range,
    EnumPropertyUpdateArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, update_range, &var);
    if (SUCCEEDED(hr)) {
        if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0)) {

            Interface_Creator<ImmIfEditSession> _pEditSession(
                new ImmIfEditSession(ESCB_GET_ALL_TEXT_RANGE,
                                     pargs->immif->GetClientId(),
                                     pargs->immif->GetCurrentInterface(),
                                     pargs->imc)
            );
            if (_pEditSession.Valid()) {

                Interface<ITfRange> full_range;

                if (SUCCEEDED(_pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                                           &full_range))) {

                    if (SUCCEEDED(full_range->ShiftEndToRange(pargs->ec, update_range, TF_ANCHOR_START))) {
                        Interface<ITfRangeACP> unupdate_range;
                        if (SUCCEEDED(full_range->QueryInterface(IID_ITfRangeACP, unupdate_range))) {
                            LONG acpStart;
                            LONG cch;
                            if (SUCCEEDED(unupdate_range->GetExtent(&acpStart, &cch))) {
                                pargs->dwDeltaStart = cch;
                                ret = ENUM_FIND;
                            }
                        }
                    }
                }
            }
        }
    }

    VariantClear(&var);
    return ret;
}


CTextEventSinkCallBack::CTextEventSinkCallBack(
    ImmIfIME* pImmIfIME,
    HIMC hIMC
    ) : m_pImmIfIME(pImmIfIME),
        CTextEventSink(TextEventSinkCallback, NULL)
{
    m_pImmIfIME->AddRef();
    m_hIMC = hIMC;
}

CTextEventSinkCallBack::~CTextEventSinkCallBack(
    )
{
    m_pImmIfIME->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "CTFMON"
#define SZ_MODULE       "CTFMON"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\cicload.cpp ===
//
// cicload.cpp
//

#include "private.h"
#include "cicload.h"
#include "loader.h"
#include "immxutil.h"
#include "osver.h"
#include "regwatch.h"
#include "mem.h"
#include "msutbapi.h"
#include "ciccs.h"

DECLARE_OSVER();

typedef BOOL (WINAPI *PFNSETPROCESSSHUTDOWNPARAMETERS)( DWORD dwLevel, DWORD dwFlags);

LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

CLoaderWnd *g_pLoaderWnd;

HINSTANCE g_hInst;

HANDLE g_hInstanceMutex;

BOOL g_fWinLogon = FALSE;
BOOL g_fRunOnceMode = FALSE;
BOOL g_bOnWow64 = FALSE;
BOOL g_fNoRunKey = FALSE;

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

CCicCriticalSectionStatic g_cs;

extern "C" HANDLE WINAPI TF_CreateCicLoadMutex(BOOL *pfWinLogon);

extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

HRESULT GetGlobalCompartment(REFGUID rguidComp, ITfCompartment **ppComp)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;

    *ppComp = NULL;

    if (FAILED(hr = TF_GetGlobalCompartment(&pCompMgr)))
    {
         Assert(0);
         goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    return hr;
}

HRESULT SetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD dw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetGlobalCompartment(rguidComp, &pComp)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(0, &var);
        pComp->Release();
    }
    return hr;
}


HRESULT STDAPICALLTYPE StubCoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
    // we should never get here!  This function is a stub to keep the library happy, so it won't actually
    // load ole32.dll.  ctfmon.exe should never be loading ole32.dll!
    Assert(0);
    if (ppv != NULL)
    {
        *ppv = NULL;
    }
    return E_UNEXPECTED;
}

void AddRunRegkey()
{
    HKEY hkeyRun;
    const static TCHAR c_szCTFMon[] = TEXT("ctfmon.exe");

    if (g_fNoRunKey)
        return;

    if (RegCreateKey( HKEY_CURRENT_USER,
                      REGSTR_PATH_RUN,
                      &hkeyRun ) == ERROR_SUCCESS)
    {
        CicSystemModulePath pathCTFMon;

        if (pathCTFMon.Init(c_szCTFMon))
        {
            RegSetValueEx(hkeyRun,
                          c_szCTFMon,
                          0,
                          REG_SZ,
                          (LPBYTE)pathCTFMon.GetPath(),
                          pathCTFMon.GetLength() * sizeof(TCHAR));

            RegCloseKey(hkeyRun);
        }
    }
}

BOOL InitApp(HINSTANCE hInstance)
{

    g_hInstanceMutex = TF_CreateCicLoadMutex(&g_fWinLogon);

    if (!g_hInstanceMutex)
        return FALSE;

    AddRunRegkey();

    g_hInst = hInstance;
    if (!g_cs.Init())
        return FALSE;

    TFInitLib_PrivateForCiceroOnly(StubCoCreateInstance);
    InitOSVer();

    //
    // Specify the shutdown order of the progman process.
    //
    // Progman (level = 2)
    // taskman (level = 1)
    // ntsd or windbg (level = 0)
    //
    // Ctfmon is enough to have 0xf0 after any programs..
    //
    if (IsOnNT())
    {
        static PFNSETPROCESSSHUTDOWNPARAMETERS pfnSetShutdownParam;
        static HINSTANCE hLibKernel32 = NULL;
        hLibKernel32 = GetSystemModuleHandle( TEXT("kernel32.dll") );
        if (hLibKernel32)
        {
            pfnSetShutdownParam = (PFNSETPROCESSSHUTDOWNPARAMETERS)GetProcAddress(hLibKernel32, TEXT("SetProcessShutdownParameters"));
            if (pfnSetShutdownParam)
                pfnSetShutdownParam(0xf0, SHUTDOWN_NORETRY);
        }
        
    }

    // rev up default Cicero support for the system
    TF_InitSystem();

    if (! g_bOnWow64)
    {
        CRegWatcher::Init();
    }

    g_pLoaderWnd = new CLoaderWnd();
    if (!g_pLoaderWnd)
    {
       return FALSE;
    }

    if (!g_pLoaderWnd->Init())
    {
       return FALSE;
    }

    g_pLoaderWnd->CreateWnd();

    //
    // locate this window at the bottom of z-order list.
    // so we can delay WM_QUERYENDSESSION under Win9x platform.
    //
    if (g_pLoaderWnd->GetWnd())
        SetWindowPos(g_pLoaderWnd->GetWnd(), HWND_BOTTOM, 0, 0, 0, 0,
                     SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

    return TRUE;
}

void UninitApp(void)
{
    ClosePopupTipbar();
    TFUninitLib();
    CloseHandle(g_hInstanceMutex);
    if (! g_bOnWow64)
    {
        CRegWatcher::Uninit();
    }
}

void CheckCmdLine(PSTR pszCmdLine)
{
    PSTR psz = pszCmdLine;

    while (*psz)
    {
        if (*psz == ' ')
        {
            psz++;
            if (!*psz)
                return;

            if ((*psz == '-') || (*psz == '/'))
            {
                psz++;
                if (!*psz)
                    return;
 

                switch (*psz)
                {
                    case 'r':
                    case 'R':
                        g_fRunOnceMode = TRUE;
                        break;

                    case 'n':
                    case 'N':
                        g_fNoRunKey = TRUE;
                        break;

                    default:
                        break;
                }
            }
        }
        psz++;
    }

}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pszCmdLine, int iCmdShow)
{
    MSG msg;
    DWORD dwWaitObj;

    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("CTFMON"), NULL);

    //
    // Retrive WOW64
    //
    g_bOnWow64 = RunningOnWow64();


    CheckCmdLine(pszCmdLine);
    

    if (g_fRunOnceMode)
    {
        AddRunRegkey();
        Dbg_MemUninit();
        return 1;
    }

    if (!InitApp(hInstance))
    {
        Dbg_MemUninit();
        return 0;
    }

    if (! g_bOnWow64)
    {
        //
        // Load MSUTB.DLL
        //
        GetPopupTipbar(g_pLoaderWnd->GetWnd(), g_fWinLogon ? UTB_GTI_WINLOGON : 0);
    }

    //
    // For 64bit only.
    // Launch ctfmon(32).
    //
    {
        SYSTEM_INFO sys;
        GetSystemInfo(&sys);
        if (sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
        {
            HMODULE h = GetSystemModuleHandle("kernel32.dll");
            if (h)
            {
                const char c_szCtfMonExe[] = "\\ctfmon.exe";
                PGET_SYSTEM_WOW64_DIRECTORY_A lpfn;
                lpfn = (PGET_SYSTEM_WOW64_DIRECTORY_A)GetProcAddress(h, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A);
                if (lpfn)
                {
                    char buf[MAX_PATH];
                    UINT len;
                    len = (lpfn)(buf, sizeof(buf)/sizeof(char));
                    if (len && 
                        (ARRAYSIZE(buf) > len + ARRAYSIZE(c_szCtfMonExe)))
                    {
                        PROCESS_INFORMATION process;
                        STARTUPINFO si;
                        memset(&si, 0, sizeof(si));
                        si.cb = sizeof(si);
                        si.wShowWindow = SW_SHOWMINNOACTIVE;

                        lstrcat(buf, c_szCtfMonExe);

                        if (CreateProcess(buf,            // application name
                                          pszCmdLine,     // command line
                                          NULL,           // process SD
                                          NULL,           // thread SD
                                          FALSE,          // inherit handle
                                          0,              // creation flags
                                          NULL,           // environment
                                          NULL,           // current directory
                                          &si,            // startup info
                                          &process))      // process information
                        {
                            CloseHandle(process.hProcess);
                            CloseHandle(process.hThread);
                        }
                    }
                }
            }
        }
    }

    HANDLE hEventWS0 = 0;
    if (! g_bOnWow64)
        hEventWS0 = OpenEvent(SYNCHRONIZE, FALSE, _T("WinSta0_DesktopSwitch"));

    while (TRUE)
    {
        if (! g_bOnWow64)
        {
            HANDLE rgAllEvents[NUM_REG_WATCH+1];
            const HANDLE *prgRegEvents = CRegWatcher::GetEvents();
            memcpy(rgAllEvents, prgRegEvents, NUM_REG_WATCH*sizeof(HANDLE));

            #define IDX_EVENT_WS  NUM_REG_WATCH

            #define NUM_ALL_EVENTS (NUM_REG_WATCH+1)

            rgAllEvents[IDX_EVENT_WS] = hEventWS0;

            dwWaitObj = MsgWaitForMultipleObjects(NUM_ALL_EVENTS, rgAllEvents, FALSE, INFINITE, QS_ALLINPUT);

            if (dwWaitObj == WAIT_OBJECT_0 + NUM_ALL_EVENTS)
            {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                        goto Exit;
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else if (dwWaitObj == WAIT_OBJECT_0 + IDX_EVENT_WS)
            {
                // win station switching event

                // set mic off
                SetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, 0);

                // reset the event (needed? not sure if this is auto-reset)
                ::ResetEvent(rgAllEvents[IDX_EVENT_WS]);
            }
            else if (dwWaitObj < WAIT_OBJECT_0 + NUM_REG_WATCH)
            {
                CRegWatcher::OnEvent(dwWaitObj - WAIT_OBJECT_0);
            }
            else
            {
                Assert(0); // error
                msg.wParam = 0;
                break;
            }
        }
        else
        {
            while (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            break;
        }
    }

Exit:
    delete g_pLoaderWnd;


    if (!CLoaderWnd::_bUninitedSystem)
    {
        UninitApp();

        // it is over!
        TF_UninitSystem();
    }

    g_cs.Delete();

    Dbg_MemUninit();

    return (int)(msg.wParam);
}


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, GetCommandLine(), si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for aimmload project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_
#define WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY

#include <windows.h>
#include <regstr.h>
#include <ccstock.h>
#include <debug.h>
#include "msctf.h"
#include "mem.h" // must be last
#include "tchar.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\loader.h ===
//
// loader.h
//

#ifndef LOADER_H
#define LOADER_H

#include "private.h"

// from msuim.dll
extern "C" BOOL WINAPI TF_InitSystem(void);
extern "C" BOOL WINAPI TF_UninitSystem(void);



class CLoaderWnd
{
public:
    CLoaderWnd();
    ~CLoaderWnd();

    BOOL Init();
    HWND CreateWnd();
    HWND GetWnd() {return _hWnd;}
    void DestroyWnd() {DestroyWindow(_hWnd);}

    static BOOL _bUninitedSystem;
private:
    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static BOOL _bWndClassRegistered;
    HWND _hWnd;
};

#endif // LOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicmem\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#include <windows.h>
#include <ccstock.h>
#include <debug.h>
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicmem\mem.cpp ===
//
// mem.cpp
//

#include "private.h"
#include "ciccs.h"
#include "mem.h"
#ifdef USECRT
#include <malloc.h>
#endif

#ifndef DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// RETAIL memory functions.
//
///////////////////////////////////////////////////////////////////////////////

extern "C" void *cicMemAlloc(UINT uCount)
{
#ifdef USECRT
    return malloc(uCount);
#else
    return LocalAlloc(LMEM_FIXED, uCount);
#endif
}

extern "C" void *cicMemAllocClear(UINT uCount)
{
#ifdef USECRT
    return calloc(uCount, 1);
#else
    return LocalAlloc(LPTR, uCount);
#endif
}

extern "C" void cicMemFree(void *pv)
{
    if (pv == NULL)
        return;

#ifdef USECRT
    free(pv);
#else
    HLOCAL hLocal;

    hLocal = LocalFree(pv);

    Assert(hLocal == NULL);
#endif
}

extern "C" void *cicMemReAlloc(void *pv, UINT uCount)
{
#ifdef USECRT
    return realloc(pv, uCount);
#else
    return LocalReAlloc((HLOCAL)pv, uCount, LMEM_MOVEABLE | LMEM_ZEROINIT);
#endif
}

extern "C" UINT cicMemSize(void *pv)
{
#ifdef USECRT
    return _msize(pv);
#else
    return (UINT)LocalSize((HLOCAL)pv);
#endif
}

#else // DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// DEBUG memory functions.
//
///////////////////////////////////////////////////////////////////////////////

#define MEM_SUSPICIOUSLY_LARGE_ALLOC    0x1000000 // 16MB

// All the debug state goes here.
// Be thread safe: make sure you hold s_Dbg_cs before touching/reading anything!

DBG_MEMSTATS s_Dbg_MemStats = { 0 };

DBG_MEM_COUNTER *s_rgCounters = NULL;

static CCicCriticalSectionStatic s_Dbg_cs;

static void *s_Dbg_pvBreak = (void *)-1; // set this to something to break on at runtime in MemAlloc/MemAllocClear/MemReAlloc

extern "C" TCHAR *Dbg_CopyString(const TCHAR *pszSrc)
{
    TCHAR *pszCpy;
    int c;

    c = lstrlen(pszSrc)+1;
    pszCpy = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c*sizeof(TCHAR));

    if (pszCpy != NULL)
    {
        memcpy(pszCpy, pszSrc, c*sizeof(TCHAR));
    }

    return pszCpy;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemInit
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemInit(const TCHAR *pszName, DBG_MEM_COUNTER *rgCounters)
{
    if (!s_Dbg_cs.Init())
        return FALSE;

    s_Dbg_MemStats.pszName = Dbg_CopyString(pszName);
    s_rgCounters = rgCounters;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemUninit
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemUninit()
{
    DBG_MEMALLOC *pdma;
    DBG_MEMALLOC *pdmaTmp;
    TCHAR achID[64];
    BOOL bMemLeak = FALSE;

    // dump stats
    Dbg_MemDumpStats();

    // everything free?
    pdma = s_Dbg_MemStats.pMemAllocList;

    if (pdma != NULL ||
        s_Dbg_MemStats.uTotalAlloc != s_Dbg_MemStats.uTotalFree) // second test necessary to catch size 0 objects
    {
        TraceMsg(TF_MEMORY_LEAK, "%s: Memory leak detected! %x total bytes leaked!",
            s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc - s_Dbg_MemStats.uTotalFree);
        bMemLeak = TRUE;
    }

    while (pdma != NULL)
    {
        if (pdma->dwID == DWORD(-1))
        {
            achID[0] = '\0';
        }
        else
        {
            wsprintf(achID, " (ID = 0x%x)", pdma->dwID);
        }

        TraceMsg(TF_MEMORY_LEAK, "       Address: %8.8lx     Size: %8.8lx    TID: %8.8lx    %s%s%s line %i %s",
            pdma->pvAlloc, pdma->uCount, pdma->dwThreadID, pdma->pszName ? pdma->pszName : "", pdma->pszName ? " -- " : "", pdma->pszFile, pdma->iLine, achID);

        // free the DBG_MEMALLOC
        pdmaTmp = pdma->next;
        LocalFree(pdma->pszName);
        LocalFree(pdma);
        pdma = pdmaTmp;
    }

    // Assert after tracing.
    if (bMemLeak)
        AssertPrivate(0);

    s_Dbg_MemStats.pMemAllocList = NULL; // in case someone wants to call Dbg_MemInit again

    s_Dbg_cs.Delete();

    LocalFree(s_Dbg_MemStats.pszName);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemDumpStats
//
//----------------------------------------------------------------------------

extern "C" void Dbg_MemDumpStats()
{
    EnterCriticalSection(s_Dbg_cs);

    TraceMsg(TF_MEMORY_LEAK, "Memory: %s allocated %x bytes, freed %x bytes.",
        s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc, s_Dbg_MemStats.uTotalFree);

    if (s_Dbg_MemStats.uTotalAlloc != s_Dbg_MemStats.uTotalFree)
    {
        TraceMsg(TF_MEMORY_LEAK, "Memory: %s %x bytes currently allocated.",
            s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc - s_Dbg_MemStats.uTotalFree);
    }

    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemAlloc", s_Dbg_MemStats.uTotalMemAllocCalls);
    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemAllocClear", s_Dbg_MemStats.uTotalMemAllocClearCalls);
    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemReAlloc", s_Dbg_MemStats.uTotalMemReAllocCalls);
    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemFree", s_Dbg_MemStats.uTotalMemFreeCalls);

    LeaveCriticalSection(s_Dbg_cs);
}


//+---------------------------------------------------------------------------
//
// Dbg_MemAlloc
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemAlloc(UINT uCount, const TCHAR *pszFile, int iLine)
{
    void *pv;
    DBG_MEMALLOC *pdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemAllocCalls);

    if (uCount == 0)
    {
        // TraceMsg(TF_MEMORY_LEAK, "Zero size memory allocation! %s line %i", pszFile, iLine);
        //Assert(0);
    }
    if (uCount >= MEM_SUSPICIOUSLY_LARGE_ALLOC)
    {
        TraceMsg(TF_MEMORY_LEAK, "Suspiciously large memory allocation (0x%x bytes)! %s line %i", uCount, pszFile, iLine);
        Assert(0);
    }

    pv = LocalAlloc(LMEM_FIXED, uCount);

    if (pv == NULL)
        return NULL;

    //
    // record this allocation
    //

    if ((pdma = (DBG_MEMALLOC *)LocalAlloc(LPTR, sizeof(DBG_MEMALLOC))) == NULL)
    {
        // this is a transaction -- fail if we can't allocate the debug info
        LocalFree(pv);
        return NULL;
    }

    pdma->pvAlloc = pv;
    pdma->uCount = uCount;
    pdma->pszFile = pszFile;
    pdma->iLine = iLine;
    pdma->dwThreadID = GetCurrentThreadId();
    pdma->dwID = (DWORD)-1;

    EnterCriticalSection(s_Dbg_cs);

    pdma->next = s_Dbg_MemStats.pMemAllocList;
    s_Dbg_MemStats.pMemAllocList = pdma;

    //
    // update global stats
    //

    s_Dbg_MemStats.uTotalAlloc += uCount;

    LeaveCriticalSection(s_Dbg_cs);

    if (pv == s_Dbg_pvBreak)
        Assert(0);

    return pv;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemAllocClear
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemAllocClear(UINT uCount, const TCHAR *pszFile, int iLine)
{
    void *pv;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemAllocClearCalls);
    InterlockedDecrement(&s_Dbg_MemStats.uTotalMemAllocCalls); // compensate for wrapping

    pv = Dbg_MemAlloc(uCount, pszFile, iLine);

    if (pv != NULL)
    {
        // clear out the mem
        memset(pv, 0, uCount);
    }
    
    return pv;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemFree
//
//----------------------------------------------------------------------------

extern "C" void Dbg_MemFree(void *pv)
{
    HLOCAL hLocal;
    DBG_MEMALLOC *pdma;
    DBG_MEMALLOC **ppdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemFreeCalls);

    if (pv != NULL) // MemFree(NULL) is legal
    {
        EnterCriticalSection(s_Dbg_cs);

        // was this guy allocated?
        ppdma = &s_Dbg_MemStats.pMemAllocList;

        if (ppdma)
        {
            while ((pdma = *ppdma) && pdma->pvAlloc != pv)
            {
                ppdma = &pdma->next;
            }

            if (pdma != NULL)
            {
                // found it, update and delete
                s_Dbg_MemStats.uTotalFree += pdma->uCount;
                *ppdma = pdma->next;
                LocalFree(pdma->pszName);
                LocalFree(pdma);
            }
            else
            {
                TraceMsg(TF_MEMORY_LEAK, "%s: MemFree'ing a bogus pointer %x!", s_Dbg_MemStats.pszName, pv);
                // Assert(0); // freeing bogus pointer
            }
        }
        else
        {
            Assert(0); // freeing bogus pointer
        }

        LeaveCriticalSection(s_Dbg_cs);

        hLocal = LocalFree(pv); // to match retail behavior, we don't call LocalFree for pv == NULL
        Assert(hLocal == NULL);
    }
}

//+---------------------------------------------------------------------------
//
// Dbg_MemReAlloc
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemReAlloc(void *pv, UINT uCount, const TCHAR *pszFile, int iLine)
{
    DBG_MEMALLOC *pdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemReAllocCalls);

    EnterCriticalSection(s_Dbg_cs);

    // was this guy allocated?
    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma == NULL)
    {
        // can't find this guy!
        TraceMsg(TF_MEMORY_LEAK, "%s: MemReAlloc'ing a bogus pointer %x!", s_Dbg_MemStats.pszName, pv);
        Assert(0); // bogus pointer

        pv = NULL;
    }
    else
    {
        // we blow away the original pv here, but we're not free'ing it so that's ok
        pv = LocalReAlloc((HLOCAL)pv, uCount, LMEM_MOVEABLE | LMEM_ZEROINIT);
    }

    if (pv != NULL)
    {
        // update the stats
        pdma->pvAlloc = pv;
        s_Dbg_MemStats.uTotalAlloc += (uCount - pdma->uCount);
        pdma->uCount = uCount;
        pdma->pszFile = pszFile;
        pdma->iLine = iLine;
    }

    LeaveCriticalSection(s_Dbg_cs);

    if (pv == s_Dbg_pvBreak)
        Assert(0);

    return pv;
}


//+---------------------------------------------------------------------------
//
// Dbg_MemSize
//
//----------------------------------------------------------------------------

extern "C" UINT Dbg_MemSize(void *pv)
{
    UINT uiSize;

    EnterCriticalSection(s_Dbg_cs);

    uiSize = (UINT)LocalSize((HLOCAL)pv);

    LeaveCriticalSection(s_Dbg_cs);

    return uiSize;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetName
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetName(void *pv, const TCHAR *pszName)
{
    return Dbg_MemSetNameIDCounter(pv, pszName, (DWORD)-1, (ULONG)-1);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetNameID
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID)
{
    return Dbg_MemSetNameIDCounter(pv, pszName, dwID, (ULONG)-1);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetNameID
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetNameIDCounter(void *pv, const TCHAR *pszName, DWORD dwID, ULONG iCounter)
{
    DBG_MEMALLOC *pdma;
    BOOL f = FALSE;

    EnterCriticalSection(s_Dbg_cs);

    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma != NULL)
    {
        if (s_rgCounters != NULL && iCounter != (ULONG)-1)
        {
            s_rgCounters[iCounter].uCount++;
        }
        LocalFree(pdma->pszName);
        pdma->pszName = Dbg_CopyString(pszName);
        pdma->dwID = dwID;
        f = TRUE;
    }

    LeaveCriticalSection(s_Dbg_cs);

    return f;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemGetName
//
// Pass in ccBuffer == 0 to get size of string only.
//
//----------------------------------------------------------------------------

extern "C" int Dbg_MemGetName(void *pv, TCHAR *pch, int ccBuffer)
{
    DBG_MEMALLOC *pdma;
    int cc;

    if (ccBuffer <= 0)
        return 0;

    EnterCriticalSection(s_Dbg_cs);

    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma != NULL)
    {
        cc = lstrlen(pdma->pszName);
        cc = min(cc, ccBuffer-1);
        memcpy(pch, pdma->pszName, cc*sizeof(TCHAR));
    }
    else
    {
        cc = 0;
    }
    pch[cc] = '\0';

    LeaveCriticalSection(s_Dbg_cs);

    return cc;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\regwatch.cpp ===
//
// regwatch.cpp
//

#include "private.h"
#include "regwatch.h"
#include "indicml.h"
#include "tfpriv.h"
#include "ctffunc.h"
#include "tlapi.h"
#include "immxutil.h"

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCache();
extern "C" HRESULT WINAPI TF_PostAllThreadMsg(WPARAM wParam, DWORD dwFlags);

static const char c_szKbdLayout[]  = "keyboard layout";
static const char c_szKbdToggleKey[]  = "Keyboard Layout\\Toggle";
static const char c_szKbdPreload[]  = "keyboard layout\\Preload";
static const char c_szRun[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
static const char c_szSpeechKey[] = "Software\\Microsoft\\Speech";
static const char c_szCPLAppearance[] = "Control Panel\\Appearance";
static const char c_szCPLColors[] = "Control Panel\\Colors";
static const char c_szCPLMetrics[] = "Control Panel\\Desktop\\WindowMetrics";
static const TCHAR c_szCTFTIPKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
static const TCHAR c_szCTFAssemblies[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Assemblies\\");

REGWATCH CRegWatcher::_rgRegWatch[NUM_REG_WATCH] =
{
    { HKEY_CURRENT_USER,   c_szKbdToggleKey,    0 },
    { HKEY_LOCAL_MACHINE,  c_szCTFTIPKey,       0 },
    { HKEY_CURRENT_USER,   c_szKbdPreload,      0 },
    { HKEY_CURRENT_USER,   c_szRun,             0 },
    { HKEY_CURRENT_USER,   c_szCTFTIPKey,       0 },
    { HKEY_CURRENT_USER,   c_szSpeechKey,       0 },
    { HKEY_CURRENT_USER,   c_szCPLAppearance,   0 },
    { HKEY_CURRENT_USER,   c_szCPLColors,       0 },
    { HKEY_CURRENT_USER,   c_szCPLMetrics,      0 },
    { HKEY_LOCAL_MACHINE,  c_szSpeechKey,       0 },
    { HKEY_CURRENT_USER,   c_szKbdLayout,       0 },
    { HKEY_CURRENT_USER,   c_szCTFAssemblies,   0 },
};

HANDLE CRegWatcher::_rgEvent[NUM_REG_WATCH] = { 0 };

typedef LONG (STDAPICALLTYPE* PFNREGNOTIFYCHANGEKEYVALUE) ( HKEY,
                                                             BOOL,
                                                             DWORD,
                                                             HANDLE,
                                                             BOOL);

typedef HRESULT (STDAPICALLTYPE* PFNCREATELANGPROFILEUTIL) (ITfFnLangProfileUtil **);

PFNREGNOTIFYCHANGEKEYVALUE g_pfnRegNotifyChangeKeyValue = NULL;


//////////////////////////////////////////////////////////////////////////////
//
// CRegWatcher
//
//////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

BOOL CRegWatcher::Init()
{
    int i;
    BOOL bRet = FALSE;

    if (!IsOnNT())
    {
        _rgRegWatch[REG_WATCH_RUN].hKeyRoot = HKEY_LOCAL_MACHINE;
    }

    HMODULE hMod = LoadSystemLibrary("advapi32.dll"); // Issue: why no release?
    g_pfnRegNotifyChangeKeyValue = (PFNREGNOTIFYCHANGEKEYVALUE)GetProcAddress(hMod, "RegNotifyChangeKeyValue");

    if (!g_pfnRegNotifyChangeKeyValue)
    {
        Assert(0);
        goto Exit;
    }

    for (i = 0; i < NUM_REG_WATCH; i++)
    {
        if ((_rgEvent[i] = CreateEvent(NULL, TRUE, FALSE, NULL)) != 0)
        {
            InitEvent(i);
        }
    }

    KillInternat();

    UpdateSpTip();

    bRet = TRUE;

Exit:
    return bRet;
}

//--------------------------------------------------------------------------
//
//  Uninit
//
//--------------------------------------------------------------------------

void CRegWatcher::Uninit()
{
    int i;

    for (i = 0; i < NUM_REG_WATCH; i++)
    {
        RegCloseKey(_rgRegWatch[i].hKey);
        if (_rgEvent[i])
        {
            CloseHandle(_rgEvent[i]);
        }
    }
}

//--------------------------------------------------------------------------
//
//  RegImxTimerProc
//
//--------------------------------------------------------------------------
UINT_PTR CRegWatcher::nRegImxTimerId = 0;

void CRegWatcher::RegImxTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
     KillTimer(NULL, nRegImxTimerId);
     nRegImxTimerId = 0;

     TF_InvalidAssemblyListCache();
     TF_PostAllThreadMsg(TFPRIV_UPDATE_REG_IMX, TLF_LBIMGR);
}

//--------------------------------------------------------------------------
//
//  SysColorTimerProc
//
//--------------------------------------------------------------------------
UINT_PTR CRegWatcher::nSysColorTimerId = 0;

void CRegWatcher::SysColorTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
     KillTimer(NULL, nSysColorTimerId);
     nSysColorTimerId = 0;

     TF_PostAllThreadMsg(TFPRIV_SYSCOLORCHANGED, TLF_LBIMGR);
}

//--------------------------------------------------------------------------
//
//  KbdToggleTimerProc
//
//--------------------------------------------------------------------------
UINT_PTR CRegWatcher::nKbdToggleTimerId = 0;

void CRegWatcher::KbdToggleTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
     KillTimer(NULL, nKbdToggleTimerId);
     nKbdToggleTimerId = 0;

     TF_PostAllThreadMsg(TFPRIV_UPDATE_REG_KBDTOGGLE, TLF_LBIMGR);
}

//--------------------------------------------------------------------------
//
//  OnEvent
//
//--------------------------------------------------------------------------

void CRegWatcher::OnEvent(DWORD dwEventId)
{
    Assert(dwEventId < NUM_REG_WATCH); // bogus event?

    InitEvent(dwEventId, TRUE);

    switch (dwEventId)
    {
          case REG_WATCH_KBDTOGGLE:
              if (nKbdToggleTimerId)
              {
                  KillTimer(NULL, nKbdToggleTimerId);
                  nKbdToggleTimerId = 0;
              }

              nKbdToggleTimerId = SetTimer(NULL, 0, 500, KbdToggleTimerProc);
              break;

          case REG_WATCH_KBDLAYOUT:
          case REG_WATCH_KBDPRELOAD:
          case REG_WATCH_HKLM_IMX:
          case REG_WATCH_HKCU_IMX:
          case REG_WATCH_HKCU_ASSEMBLIES:
              if (nRegImxTimerId)
              {
                  KillTimer(NULL, nRegImxTimerId);
                  nRegImxTimerId = 0;
              }

              nRegImxTimerId = SetTimer(NULL, 0, 200, RegImxTimerProc);
              break;

          case REG_WATCH_RUN:
              KillInternat();
              break;

          case REG_WATCH_HKCU_SPEECH:
          case REG_WATCH_HKLM_SPEECH:
              UpdateSpTip();

              // Forcelly update assembly list
              // fix bug 4871
              if (nRegImxTimerId)
              {
                  KillTimer(NULL, nRegImxTimerId);
                  nRegImxTimerId = 0;
              }

              nRegImxTimerId = SetTimer(NULL, 0, 200, RegImxTimerProc);

              break;

          case REG_WATCH_HKCU_CPL_APPEARANCE:
          case REG_WATCH_HKCU_CPL_COLORS:
          case REG_WATCH_HKCU_CPL_METRICS:
              StartSysColorChangeTimer();
              break;

     }
}

//--------------------------------------------------------------------------
//
//  StartSysColorChangeTimer
//
//--------------------------------------------------------------------------

void CRegWatcher::StartSysColorChangeTimer()
{
    if (nSysColorTimerId)
    {
        KillTimer(NULL, nSysColorTimerId);
        nSysColorTimerId = 0;
    }

    nSysColorTimerId = SetTimer(NULL, 0, 500, SysColorTimerProc);
}


//--------------------------------------------------------------------------
//
//  InitEvent
//
//--------------------------------------------------------------------------

BOOL CRegWatcher::InitEvent(int nId, BOOL fReset)
{
    LONG lErrorCode;

    if (fReset)
        ::ResetEvent(_rgEvent[nId]);

    RegCloseKey(_rgRegWatch[nId].hKey);

    if (RegOpenKeyEx(_rgRegWatch[nId].hKeyRoot, _rgRegWatch[nId].pszKey, 0, KEY_READ, &_rgRegWatch[nId].hKey) == S_OK ||
        RegCreateKeyEx(_rgRegWatch[nId].hKeyRoot, _rgRegWatch[nId].pszKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &_rgRegWatch[nId].hKey, NULL) == S_OK)
    {
        Assert(g_pfnRegNotifyChangeKeyValue);
        lErrorCode = g_pfnRegNotifyChangeKeyValue(_rgRegWatch[nId].hKey,
                                             TRUE,
                                             REG_NOTIFY_CHANGE_NAME |
                                                REG_NOTIFY_CHANGE_LAST_SET,
                                             _rgEvent[nId],
                                             TRUE);

        if (lErrorCode != ERROR_SUCCESS)
        {
            Assert(0);
            return FALSE; 
        }

        return TRUE;
    }

    return FALSE;
}

//--------------------------------------------------------------------------
//
//  KillInternat
//
//--------------------------------------------------------------------------

void CRegWatcher::KillInternat()
{
    HKEY hKey;

    if (RegOpenKeyEx(_rgRegWatch[REG_WATCH_RUN].hKeyRoot, _rgRegWatch[REG_WATCH_RUN].pszKey, 0, KEY_ALL_ACCESS, &hKey) == S_OK)
    {
        RegDeleteValue(hKey, "internat.exe");
        RegCloseKey(hKey);
    }

    HWND hwndIndic = FindWindow(INDICATOR_CLASS, NULL);
    if (hwndIndic)
    {
        PostMessage(hwndIndic, WM_CLOSE, 0, 0);
    }
}


//--------------------------------------------------------------------------
//
//  UpdateSpTip
//
//--------------------------------------------------------------------------

#define WM_PRIV_SPEECHOPTION    WM_APP+2
const char c_szWorkerWndClass[] = "SapiTipWorkerClass";
const TCHAR c_szSapilayrKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Sapilayr\\");
const TCHAR c_szProfileInit[] = TEXT("ProfileInitialized");
const TCHAR c_szSpTipFile[]   = TEXT("\\IME\\sptip.dll");
const TCHAR c_szTFCreateLangPropUtil[] = TEXT("TF_CreateLangProfileUtil");

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCacheIfExist();

void CRegWatcher::UpdateSpTip()
{
    EnumWindows( EnumWndProc, NULL);

    // clear the key that states "we've init'ed profiles"
    //
    // 03/27/01 - for bug#4818, we re-enabled this piece of code for HKCU value
    //            instead of HKLM
    //
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szSapilayrKey, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
    {
        DWORD dw = 0;
        RegSetValueEx(hKey, c_szProfileInit, NULL, REG_DWORD, (const BYTE *)&dw, sizeof(dw));
        RegCloseKey(hKey);
    }

    //
    // ..then call into sptip's ITfFnLangProfileUtil to update sptip's profile
    // we probably don't need to do this at the moment app starts
    // if we don't need to register profiles at app boot, we also don't need
    // the code above to reset 'ProfileInit' - actually we need to remove this
    // code to fix bug 2801 or 3479 (not to access HKLM)
    //
    PFNCREATELANGPROFILEUTIL   pfnCreateLangProfUtil = NULL;
    ITfFnLangProfileUtil *pFnLangUtil = NULL;
    TCHAR szPathSpTip[MAX_PATH];
    HMODULE hSpTip = NULL;

    UINT uLength = GetSystemWindowsDirectory(szPathSpTip, ARRAYSIZE(szPathSpTip));
    if (uLength && 
        (ARRAYSIZE(szPathSpTip) > (uLength + ARRAYSIZE(c_szSpTipFile))))
    {
        _tcscat(szPathSpTip, c_szSpTipFile);
        hSpTip = LoadLibrary(szPathSpTip); // Issue: why no release?
    }
    if (hSpTip != NULL)
    {
        pfnCreateLangProfUtil = (PFNCREATELANGPROFILEUTIL)GetProcAddress(hSpTip, c_szTFCreateLangPropUtil);
    }

    HRESULT hr = E_FAIL;
    if (pfnCreateLangProfUtil != NULL)
    {
        hr = pfnCreateLangProfUtil(&pFnLangUtil);
    }

    if (S_OK == hr)
    { 
        if (S_OK == pFnLangUtil->RegisterActiveProfiles())
            TF_InvalidAssemblyListCacheIfExist();
    }

    if (pFnLangUtil)
        pFnLangUtil->Release();

    if (hSpTip != NULL)
    {
        FreeLibrary(hSpTip);
    }
}

BOOL CALLBACK CRegWatcher::EnumWndProc(HWND hwnd, LPARAM lparam)
{
    char szCls[MAX_PATH];
    if (GetClassNameA(hwnd, szCls, ARRAYSIZE(szCls)) > 0)
    {
        if ( 0 == lstrcmpiA(szCls, c_szWorkerWndClass) )
        {
            PostMessage(hwnd, WM_PRIV_SPEECHOPTION, 0, 0);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\loader.cpp ===
//
// loader.cpp
//

#include "private.h"
#include "loader.h"
#include "regwatch.h"
#include "msutbapi.h"

extern HINSTANCE g_hInst;
extern BOOL g_fWinLogon;
extern BOOL g_bOnWow64;

const TCHAR c_szLoaderWndClass[] = TEXT("CicLoaderWndClass");

extern void UninitApp(void);

BOOL CLoaderWnd::_bWndClassRegistered = FALSE;
BOOL CLoaderWnd::_bUninitedSystem = FALSE;

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLoaderWnd::CLoaderWnd()
{
    _hWnd = NULL;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLoaderWnd::~CLoaderWnd()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CLoaderWnd::Init()
{
    if (!_bWndClassRegistered)
    {
        WNDCLASSEX wc;
        memset(&wc, 0, sizeof(wc));
        wc.cbSize = sizeof(wc);
        wc.style = CS_HREDRAW | CS_VREDRAW ;
        wc.hInstance = g_hInst;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.lpfnWndProc = _WndProc;
        wc.lpszClassName = c_szLoaderWndClass;
        if (RegisterClassEx(&wc))
            _bWndClassRegistered = TRUE;
    }

    return _bWndClassRegistered ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// CreateWnd
//
//----------------------------------------------------------------------------

HWND CLoaderWnd::CreateWnd()
{
    _hWnd = CreateWindowEx(0, c_szLoaderWndClass, TEXT(""), 
                           WS_DISABLED, 
                           0, 0, 0, 0, 
                           NULL, 0, g_hInst, 0);

    return _hWnd;
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK CLoaderWnd::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            break;

        case WM_DESTROY :
            PostQuitMessage(0);
            break;

        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            if (! g_bOnWow64)
            {
                CRegWatcher::StartSysColorChangeTimer();
            }
            break;

        case WM_QUERYENDSESSION:
            if (g_fWinLogon && (lParam & ENDSESSION_LOGOFF))
                return 1;

            if (!IsOnNT())
            {
                //
                // uninit system.
                //

                ClosePopupTipbar();
                TF_UninitSystem();
                _bUninitedSystem = TRUE;
            }

            return 1;

        case WM_ENDSESSION:
            if (!wParam)
            {
                //
                // need to restore Cicero and Toolbar.
                //
                if (_bUninitedSystem)
                {
                   TF_InitSystem();
                   if (! g_bOnWow64)
                   {
                       GetPopupTipbar(hWnd, g_fWinLogon ? UTB_GTI_WINLOGON : 0);
                   }
                   _bUninitedSystem = FALSE;
                }
            }
            else // Do cleanup always no matter if this is from Winlogon session or not.
            {
                if (!_bUninitedSystem)
                {
                    UninitApp();
                    TF_UninitSystem();
                    _bUninitedSystem = TRUE;
                }
            }
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicload\regwatch.h ===
//
// regwatch.h
//


#ifndef REGdWATCH_H
#define REGdWATCH_H

#include "private.h"
//#include "smblock.h"
#include "cregkey.h"

#define REG_WATCH_KBDTOGGLE           0
#define REG_WATCH_HKLM_IMX            1
#define REG_WATCH_KBDPRELOAD          2
#define REG_WATCH_RUN                 3
#define REG_WATCH_HKCU_IMX            4
#define REG_WATCH_HKCU_SPEECH         5
#define REG_WATCH_HKCU_CPL_APPEARANCE 6
#define REG_WATCH_HKCU_CPL_COLORS     7
#define REG_WATCH_HKCU_CPL_METRICS    8
#define REG_WATCH_HKLM_SPEECH         9
#define REG_WATCH_KBDLAYOUT          10
#define REG_WATCH_HKCU_ASSEMBLIES    11
#define NUM_REG_WATCH                12

typedef struct _REGWATCH
{
    HKEY hKeyRoot;
    const char *pszKey;
    HKEY hKey;
} REGWATCH;

class CRegWatcher
{
public:
    CRegWatcher() {}

    static BOOL Init();
    static void Uninit();

    static const HANDLE *GetEvents()
    {
        return _rgEvent;
    }

    static void OnEvent(DWORD dwEventId);
    static void StartSysColorChangeTimer();

private:
    static BOOL InitEvent(int nId, BOOL fReset = FALSE);
    static BOOL PostAllThreadMsg(WPARAM wParam);

    static UINT_PTR nRegImxTimerId;
    static void RegImxTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static UINT_PTR nSysColorTimerId;
    static void SysColorTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static UINT_PTR nKbdToggleTimerId;
    static void KbdToggleTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static UINT_PTR nKbdLayoutTimerId;
    static void KbdLayoutTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static void KillInternat();
    static void UpdateSpTip();
    static BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lparam);

    static REGWATCH _rgRegWatch[NUM_REG_WATCH];
    static HANDLE _rgEvent[NUM_REG_WATCH];
};

#endif // REGdWATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicsthkl\lib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <nt.h>    // for NtQuery
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <debug.h>
#include <inetreg.h>
#include <ocidl.h>
#include <comcat.h>
#include <olectl.h>
#include <limits.h>
#include "msctf.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicsthkl\inc\cicsthkl.h ===
//
// cicsthkl.h
//
// Cicero Library to retreive the substitute keyboard layout of the 
// current active keyboard TIP.
//

//
// CicSubstGetKeyboardLayout
//
// If the current focus is on Cicero aware (including AIMM1.2
// or CUAS), This function returns the substitute HKL of
// the current active keyboard TIP. And the keyboard layout
// name of the hKL that is returned in pszKLID.
// If the current focus is not on Cicero aware, it just returns
// the current keyboard layout and keyboard layout name in 
// pszKLID.
// pszKLID can be NULL.
//
extern "C" HKL WINAPI CicSubstGetKeyboardLayout(char *pszKLID);

//
// CicSubstGetDefaultKeyboardLayout
//
// This function returns the substitute hKL of the default item
// of the given langage.
//
extern "C" HKL WINAPI CicSubstGetDefaultKeyboardLayout(LANGID langid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cicsthkl\lib\substhkl.cpp ===
#include "private.h"
#include "cicsthkl.h"

#define LANGIDFROMHKL(x) LANGID(LOWORD(HandleToLong(x)))

const CHAR c_szCTFTIPKey[] = "SOFTWARE\\Microsoft\\CTF\\TIP\\";
const CHAR c_szLanguageProfileKey[] = "LanguageProfile\\";
const CHAR c_szSubstitutehKL[] =      "SubstituteLayout";

//+------------------------------------------------------------------------
//
//  Function:   cicsthkl_CLSIDToString
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const char szDigits[] = "0123456789ABCDEF";


BOOL cicsthkl_CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// cicsthkl_AsciiToNum
//
//----------------------------------------------------------------------------

DWORD cicsthkl_AsciiToNum( char *pszAscii)
{
   DWORD dwNum = 0;

   for (; *pszAscii; pszAscii++) {
       if (*pszAscii >= '0' && *pszAscii <= '9') {
           dwNum = (dwNum << 4) | (*pszAscii - '0');
       } else if (*pszAscii >= 'A' && *pszAscii <= 'F') {
           dwNum = (dwNum << 4) | (*pszAscii - 'A' + 0x000A);
       } else if (*pszAscii >= 'a' && *pszAscii <= 'f') {
           dwNum = (dwNum << 4) | (*pszAscii - 'a' + 0x000A);
       } else {
           return (0);
       }
   }

   return (dwNum);
}

//+---------------------------------------------------------------------------
//
// cicsthkl_NumToA
//
//----------------------------------------------------------------------------

void cicsthkl_NumToAscii(DWORD dw, char *psz)
{
    int n = 7;
    while (n >= 0)
    {
        BYTE b = (BYTE)(dw >> (n * 4)) & 0x0F;
        if (b < 0x0A)
           *psz = (char)('0' + b);
        else
           *psz = (char)('A' + b - 0x0A);
        psz++;
        n--;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// GetSubstituteHKLFromReg
//
//----------------------------------------------------------------------------

HKL GetSubstituteHKLFromReg(REFCLSID rclsid, LANGID langid, REFGUID rguid)
{
    HKL hKL = NULL;
    CHAR szKey[MAX_PATH];
    CHAR szTempStr[64];

    StringCchCopyA(szKey, ARRAYSIZE(szKey), c_szCTFTIPKey);
    cicsthkl_CLSIDToStringA(rclsid, szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), "\\");
    StringCchCatA(szKey, ARRAYSIZE(szKey), c_szLanguageProfileKey);
    StringCchPrintfA(szTempStr, ARRAYSIZE(szTempStr), "0x%08x", langid);
    StringCchCatA(szKey, ARRAYSIZE(szKey), szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), "\\");
    cicsthkl_CLSIDToStringA(rguid, szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), szTempStr);

    HKEY hKey = NULL;
    LONG lRes = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);
    if (lRes == ERROR_SUCCESS)
    {
        DWORD dwType = NULL;
        char szValue[32];
        DWORD dwCount = sizeof(szValue);
        lRes = RegQueryValueExA(hKey, 
                               (LPTSTR)c_szSubstitutehKL,
                               NULL, 
                               &dwType,
                               (LPBYTE)szValue,
                               &dwCount);

        if (lRes == ERROR_SUCCESS)
        {
            if ((szValue[0] == '0') && 
                ((szValue[1] == 'X') || (szValue[1] == 'x')))
                hKL = (HKL)IntToPtr(cicsthkl_AsciiToNum(&szValue[2]));
        }

        RegCloseKey(hKey);
    }
    return hKL;

}

//----------------------------------------------------------------------------
// 
// [in] langid
//     langid may be LOWORD of the return value of GetKeyboardLayout(0).
//
// The return value
//     It returns NULL hKL 
//         - if Cicero does not have a focus
//         - it there is no keyboard TIP running now
//         - it the current keyboard TIP does not have a substitute layout.
//
//----------------------------------------------------------------------------
HRESULT CicGetSubstitueHKL(LANGID langid, HKL *phkl, BOOL fCheckFocus)
{
    HRESULT hr;
    ITfThreadMgr *ptim;

    *phkl = NULL;

    if (fCheckFocus)
    {
        BOOL fFocusInCicero = FALSE;
        if (SUCCEEDED(CoCreateInstance( CLSID_TF_ThreadMgr,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_ITfThreadMgr,
                                        (void **)&ptim))) {
 
            ITfDocumentMgr *pdim;
            if (SUCCEEDED(ptim->GetFocus(&pdim)) && pdim)
            {
                 fFocusInCicero = TRUE;
                 pdim->Release();
            }
            ptim->Release();
        }
 
        if (!fFocusInCicero)
        {
            //
            // Cicero does not have a focus. Try GetKeyboardLayout(0).
            //
            return S_FALSE;
        }
    }
 
    HKL hKL = NULL;
    ITfInputProcessorProfiles *pPro;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_ITfInputProcessorProfiles,
                                        (void **)&pPro ))) {
        CLSID clsid;
        GUID guid;
 
        ITfInputProcessorProfileSubstituteLayout *pProSubLayout;

        if (SUCCEEDED(hr = pPro->GetDefaultLanguageProfile(langid, 
                                                           GUID_TFCAT_TIP_KEYBOARD, 
                                                           &clsid, 
                                                           &guid)))
        {
            if (!IsEqualGUID(clsid, CLSID_NULL))
            {
                if (SUCCEEDED(hr = pPro->QueryInterface(IID_ITfInputProcessorProfileSubstituteLayout,
                                                        (void **)&pProSubLayout)))
                {
                    hr = pProSubLayout->GetSubstituteKeyboardLayout(clsid, 
                                                                    langid, 
                                                                    guid, 
                                                                    &hKL);
                    pProSubLayout->Release();
                }
                else
                {
                    hKL = GetSubstituteHKLFromReg(clsid, langid, guid);
                    hr = S_OK;
                }
            }
        }
        pPro->Release();
    }
 
    //
    // if hKL is NULL, please get hKL from GetKeybaordLayout(0).
    //
    *phkl = hKL;
    return hr;
}


//----------------------------------------------------------------------------
//
// CicSubstGetKeyboardLayout
//
//----------------------------------------------------------------------------

extern "C" HKL WINAPI CicSubstGetKeyboardLayout(char *pszKLID)
{
    HKL hkl = NULL;
    HKL hklReal = GetKeyboardLayout(0);

    if (SUCCEEDED(CicGetSubstitueHKL(LANGIDFROMHKL(hklReal), &hkl, TRUE)))
    {
        if (!hkl)
        {
            hkl = hklReal;
            if (pszKLID)
                GetKeyboardLayoutName(pszKLID);
        }
        else
        {
            if (pszKLID)
                cicsthkl_NumToAscii((DWORD)HandleToLong(hkl), pszKLID);
        }
    }
    return hkl;
}

//----------------------------------------------------------------------------
//
// CicSubstGetDefaultKeyboardLayout
//
//----------------------------------------------------------------------------

extern "C" HKL WINAPI CicSubstGetDefaultKeyboardLayout(LANGID langid)
{
    HKL hkl = NULL;

    CicGetSubstitueHKL(langid, &hkl, FALSE);

    return hkl;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiarray.cpp ===
//
// cuiarray.cpp
//  = array object in CUILib =
//

#include "private.h"
#include "cuiarray.h"

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  O B J E C T  A R R A Y                                          */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  O B J E C T  A R R A Y   */
/*------------------------------------------------------------------------------

    constructor of CUIFObjectArrayBase

------------------------------------------------------------------------------*/
CUIFObjectArrayBase::CUIFObjectArrayBase( void )
{
    m_pBuffer = NULL;
    m_nBuffer = 0;
    m_nObject = 0;
}


/*   ~  C  U I F  O B J E C T  A R R A Y   */
/*------------------------------------------------------------------------------

    destructor of CUIFObjectArrayBase

------------------------------------------------------------------------------*/
CUIFObjectArrayBase::~CUIFObjectArrayBase( void )
{
    if (m_pBuffer) {
        MemFree( m_pBuffer );
    }
}


/*   A D D   */
/*------------------------------------------------------------------------------

    Add object to the list

------------------------------------------------------------------------------*/
BOOL CUIFObjectArrayBase::Add( void *pv )
{
    // sanity check

    if (pv == NULL) {
        Assert( FALSE );
        return FALSE;
    }

    // check if the object is alrady in the list

    if (0 <= Find( pv )) {
        return FALSE;
    }

    // ensure buffer size

    if (!EnsureBuffer( m_nObject + 1 )) {
        return FALSE;
    }

    // add to list

    Assert( m_nObject < m_nBuffer );
    m_pBuffer[ m_nObject ] = pv;

    m_nObject++;
    return TRUE;
}


/*   R E M O V E   */
/*------------------------------------------------------------------------------

    Remove object from the list

------------------------------------------------------------------------------*/
BOOL CUIFObjectArrayBase::Remove( void *pv )
{
    int i;

    // sanity check

    if (pv == NULL) {
        Assert( FALSE );
        return FALSE;
    }

    // check if the object is in the list

    i = Find( pv );
    if (i < 0) {
        return FALSE;
    }

    // remove from the list

    if (i < m_nObject - 1) {
        MemMove( &m_pBuffer[ i ], &m_pBuffer[ i+1 ], (m_nObject-i-1) * sizeof(void*) );
    }

    m_nObject--;
    return TRUE;
}


/*   G E T  C O U N T   */
/*------------------------------------------------------------------------------

    Get count of objects in the list

------------------------------------------------------------------------------*/
int CUIFObjectArrayBase::GetCount( void )
{
    return m_nObject;
}


/*   G E T   */
/*------------------------------------------------------------------------------

    Get object in the list

------------------------------------------------------------------------------*/
void *CUIFObjectArrayBase::Get( int i )
{
    if (i < 0 || m_nObject <= i) {
        return NULL;
    }

    return m_pBuffer[ i ];
}


/*   G E T  F I R S T   */
/*------------------------------------------------------------------------------

    Get fist object in the list

------------------------------------------------------------------------------*/
void *CUIFObjectArrayBase::GetFirst( void )
{
    return Get( 0 );
}


/*   G E T  L A S T   */
/*------------------------------------------------------------------------------

    Get last object in the list

------------------------------------------------------------------------------*/
void *CUIFObjectArrayBase::GetLast( void )
{
    return Get( m_nObject - 1 );
}


/*   F I N D   */
/*------------------------------------------------------------------------------

    Find object 
    Returns index of object in list when found, -1 when not found.

------------------------------------------------------------------------------*/
int CUIFObjectArrayBase::Find( void *pv )
{
    int i;

    for (i = 0; i < m_nObject; i++) {
        if (m_pBuffer[i] == pv) {
            return i;
        }
    }

    return -1;
}


/*   E N S U R E  B U F F E R   */
/*------------------------------------------------------------------------------

    Ensure buffer size (create/enlarge buffer when no more room)
    Returns TRUE when buffer size is enough, FALSE when error occured

------------------------------------------------------------------------------*/
BOOL CUIFObjectArrayBase::EnsureBuffer( int iSize )
{
    void **pBufferNew;
    int        nBufferNew;

    Assert( 0 < iSize );

    // check if there is room

    if (iSize <= m_nBuffer) {
        Assert( m_pBuffer != NULL );
        return TRUE;
    }

    // calc new buffer size

    nBufferNew = ((iSize - 1) / 16 + 1) * 16;

    // create new buffer

    if (m_pBuffer == NULL) {
        Assert( m_nBuffer == 0 );
        pBufferNew = (void**)MemAlloc( nBufferNew * sizeof(void*) );
    }
    else {
        Assert( 0 < m_nBuffer );
        pBufferNew = (void**)MemReAlloc( m_pBuffer, nBufferNew * sizeof(void*) );
    }

    // check if buffer has been created

    if (pBufferNew == NULL) {
        Assert( FALSE );
        return FALSE;
    }

    // update buffer info

    m_pBuffer = pBufferNew;
    m_nBuffer = nBufferNew;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuibln.h ===
//
// cuibln.h
//


#ifndef CUIBLN_H
#define CUIBLN_H

#include "cuiobj.h"
#include "cuiwnd.h"

#define WNDCLASS_BALLOONWND     "MSIME_PopupMessage"
#define WNDTITLE_BALLOONWND     "MSIME_PopupMessage"


//
// CUIFBallloonButton
//

class CUIFBalloonButton : public CUIFButton
{
public:
    CUIFBalloonButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFBalloonButton( void );

    //
    // CUIFObject methods
    //
    virtual void OnPaint( HDC hDC );

    int  GetButtonID( void );
    v