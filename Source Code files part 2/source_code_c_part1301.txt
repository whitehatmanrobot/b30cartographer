 /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//      The DRIVE_MAPPING structure contains the drive letter (without        /
//      the colon) and a unicode string containing the name of the            /
//      corresponding device.  The buffer in the unicode string is            /
//      allocated from the LSA heap and is never freed.                       /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


typedef struct _DRIVE_MAPPING {
    WCHAR DriveLetter;
    UNICODE_STRING DeviceName;
} DRIVE_MAPPING, PDRIVE_MAPPING;


////////////////////////////////////////////////////////////////////////////////
//                                                                             /
//      We assume a maximum of 26 drive letters.  Though no auditing           /
//      will occur due to references to files on floppy (drives A and          /
//      B), perform their name lookup anyway.  This will then just             /
//      work if somehow we start auditing files on floppies.                   /
//                                                                             /
////////////////////////////////////////////////////////////////////////////////

#define MAX_DRIVE_MAPPING  26

extern DRIVE_MAPPING DriveMappingArray[];

//
// Special privilege values which are not normally audited,
// but generate audits when assigned to a user.  See
// LsapAdtAuditSpecialPrivileges.
//

extern LUID ChangeNotifyPrivilege;
extern LUID AuditPrivilege;
extern LUID CreateTokenPrivilege;
extern LUID AssignPrimaryTokenPrivilege;
extern LUID BackupPrivilege;
extern LUID RestorePrivilege;
extern LUID DebugPrivilege;

//
// Global variable to indicate whether or not we're
// supposed to crash when an audit fails.
//

extern BOOLEAN LsapCrashOnAuditFail;
extern BOOLEAN LsapAllowAdminLogonsOnly;




////////////////////////////////////////////////////////////////////////////////
//                                                                             /
//                                                                             /
////////////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtWriteLog(
    IN OPTIONAL PSE_ADT_PARAMETER_ARRAY AuditRecord,
    IN ULONG Options
    );

NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

VOID
LsapAdtNormalizeAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

NTSTATUS
LsapAdtOpenLog(
    OUT PHANDLE AuditLogHandle
    );

VOID
LsapAdtAuditLogon(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING Source,
    IN PUNICODE_STRING PackageName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN PUNICODE_STRING WorkstationName,
    IN NTSTATUS LogonStatus,
    IN NTSTATUS SubStatus,
    IN LPGUID LogonGuid                         OPTIONAL
    );

VOID
LsapAuditLogonHelper(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid                         OPTIONAL
    );

#define LSAP_ADT_LOG_QUEUE_DISCARD  ((ULONG) 0x00000001L)
#define LSAP_ADT_LOG_QUEUE_WRITEOUT ((ULONG) 0x00000002L)


VOID
LsapAdtSystemRestart(
    PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo
    );

VOID
LsapAdtAuditLogonProcessRegistration(
    IN PLSAP_AU_REGISTER_CONNECT_INFO_EX ConnectInfo
    );


NTSTATUS
LsapAdtInitializeLogQueue(
    VOID
    );

NTSTATUS
LsapAdtQueueRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditRecord,
    IN ULONG Options
    );


#define LsapAdtAcquireLogFullLock()  RtlEnterCriticalSection(&LsapAdtLogFullLock)
#define LsapAdtReleaseLogFullLock()  RtlLeaveCriticalSection(&LsapAdtLogFullLock)


NTSTATUS
LsapAdtObjsInitialize(
    );



NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    );

NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    );

NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildTimeString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildDateString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildGuidString(
    IN  LPGUID pGuid,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtMarshallAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    OUT PSE_ADT_PARAMETER_ARRAY *MarshalledAuditParameters
    );


NTSTATUS
LsapAdtInitializeDriveLetters(
    VOID
    );


BOOLEAN
LsapAdtLookupDriveLetter(
    IN PUNICODE_STRING FileName,
    OUT PUSHORT DeviceNameLength,
    OUT PWCHAR DriveLetter
    );

VOID
LsapAdtSubstituteDriveLetter(
    IN PUNICODE_STRING FileName
    );

VOID
LsapAdtUserRightAssigned(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID UserSid,
    IN LUID CallerAuthenticationId,
    IN PSID ClientSid,
    IN PPRIVILEGE_SET Privileges
    );

VOID
LsapAdtTrustedDomain(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PUNICODE_STRING DomainName
    );

VOID
LsapAdtAuditLogoff(
    PLSAP_LOGON_SESSION Session
    );

VOID
LsapAdtPolicyChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO LsapAdtEventsInformation
    );

VOID
LsapAdtAuditSpecialPrivileges(
    PPRIVILEGE_SET Privileges,
    LUID LogonId,
    PSID UserSid
    );

VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    );

VOID
LsapAdtInitParametersArray(
    IN SE_ADT_PARAMETER_ARRAY* AuditParameters,
    IN ULONG AuditCategoryId,
    IN ULONG AuditId,
    IN USHORT AuditEventType,
    IN USHORT ParameterCount,
    ...);

NTSTATUS
LsapAdtInitGenericAudits( VOID );

#endif // _LSAP_ADTP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\bndcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.cxx
//
// Contents:    Binding cache for Kerberos Package
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------
#include <lsapch.hxx>

#define BNDCACHE_ALLOCATE
#include <bndcache.h>


//+-------------------------------------------------------------------------
//
//  Function:   LsapInitializeList
//
//  Synopsis:   Initializes a lsap list by initializing the lock
//              and the list entry.
//
//  Effects:
//
//  Arguments:  List - List to initialize
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success or errors from
//              RtlInitializeResources
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapInitializeList(
    IN PLSAP_LIST List
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead(&List->List);

    Status = RtlInitializeCriticalSection(
                &List->Lock
                );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeList
//
//  Synopsis:   Frees a lsap list by deleting the associated
//              critical section.
//
//  Effects:    List - the list to free.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      The list must be empty before freeing it.
//
//
//--------------------------------------------------------------------------



VOID
LsapFreeList(
    IN PLSAP_LIST List
    )
{
    //
    // Make sure the list is empty first
    //

    DsysAssert(List->List.Flink == List->List.Blink);
    RtlDeleteCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapInitializeListEntry
//
//  Synopsis:   Initializes a newly created list entry for later
//              insertion onto the list.
//
//  Effects:    The reference count is set to one and the links are set
//              to NULL.
//
//  Arguments:  ListEntry - the list entry to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
LsapInitializeListEntry(
    IN OUT PLSAP_LIST_ENTRY ListEntry
    )
{
    ListEntry->ReferenceCount = 1;
    ListEntry->Next.Flink = ListEntry->Next.Blink = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapInsertListEntry
//
//  Synopsis:   Inserts an entry into a lsap list
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapInsertListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    )
{
    ListEntry->ReferenceCount++;

    RtlEnterCriticalSection(&List->Lock);


    InsertHeadList(
        &List->List,
        &ListEntry->Next
        );


    RtlLeaveCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapReferenceListEntry
//
//  Synopsis:   References a list entry. If the flag RemoveFromList
//              has been specified, the entry is unlinked from the
//              list.
//
//  Effects:    bumps the reference count on the entry (unless it is
//              being removed from the list)
//
//  Arguments:
//
//  Requires:   The list must be locked when calling this routine
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapReferenceListEntry(
    IN PLSAP_LIST List,
    IN PLSAP_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    )
{

    //
    // If it has already been removed from the list
    // don't do it again.
    //

    if (RemoveFromList && ((ListEntry->Next.Flink != NULL) &&
                           (ListEntry->Next.Blink != NULL)))
    {
        RemoveEntryList(&ListEntry->Next);
        ListEntry->Next.Flink = NULL;
        ListEntry->Next.Blink = NULL;
    }
    else
    {
        ListEntry->ReferenceCount++;
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDereferenceListEntry
//
//  Synopsis:   Dereferences a list entry and returns a flag indicating
//              whether the entry should be freed.
//
//  Effects:    decrements reference count on list entry
//
//  Arguments:  ListEntry - the list entry to dereference
//              List - the list containing the list entry
//
//  Requires:
//
//  Returns:    TRUE - the list entry should be freed
//              FALSE - the list entry is still referenced
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
LsapDereferenceListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    )
{
    BOOLEAN DeleteEntry = FALSE;

    RtlEnterCriticalSection(&List->Lock);

    ListEntry->ReferenceCount -= 1;
    if (ListEntry->ReferenceCount == 0)
    {
        DeleteEntry = TRUE;
    }

    RtlLeaveCriticalSection(&List->Lock);
    return(DeleteEntry);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapInitBindingCache
//
//  Synopsis:   Initializes the binding cache
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LsapInitBindingCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = LsapInitializeList( &LsapBindingCache );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    LsapBindingCacheInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        LsapFreeList( &LsapBindingCache );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCleanupBindingCache
//
//  Synopsis:   Frees the binding cache
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
LsapCleanupBindingCache(
    VOID
    )
{
    PLSAP_BINDING_CACHE_ENTRY CacheEntry;

    if (LsapBindingCacheInitialized)
    {
        LsapLockList(&LsapBindingCache);

        //
        // Go through the list of bindings and dereference them all
        //

        while (!IsListEmpty(&LsapBindingCache.List))
        {
            CacheEntry = CONTAINING_RECORD(
                            LsapBindingCache.List.Flink,
                            LSAP_BINDING_CACHE_ENTRY,
                            ListEntry.Next
                            );

            LsapReferenceListEntry(
                &LsapBindingCache,
                &CacheEntry->ListEntry,
                TRUE
                );

            LsapDereferenceBindingCacheEntry(CacheEntry);

        }

        LsapFreeList(&LsapBindingCache);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDereferenceBindingCacheEntry
//
//  Synopsis:   Dereferences a binding cache entry
//
//  Effects:    Dereferences the binding cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   BindingCacheEntry - The binding cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapDereferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    if (LsapDereferenceListEntry(
            &BindingCacheEntry->ListEntry,
            &LsapBindingCache
            ) )
    {
        LsapFreeBindingCacheEntry(BindingCacheEntry);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapReferenceBindingCacheEntry
//
//  Synopsis:   References a binding cache entry
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  BindingCacheEntry - binding cache entry  to reference
//
//  Requires:   The binding cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapReferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    )
{
    LsapLockList(&LsapBindingCache);

    LsapReferenceListEntry(
        &LsapBindingCache,
        &BindingCacheEntry->ListEntry,
        RemoveFromList
        );

    LsapUnlockList(&LsapBindingCache);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapLocateBindingCacheEntry
//
//  Synopsis:   References a binding cache entry by name
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  RealmName - Contains the name of the realm for which to
//                      obtain a binding handle.
//              RemoveFromList - Remove cache entry from cache when found.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------


PLSAP_BINDING_CACHE_ENTRY
LsapLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PLSAP_BINDING_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;

    LsapLockList(&LsapBindingCache);


    //
    // Go through the binding cache looking for the correct entry
    //

    for (ListEntry = LsapBindingCache.List.Flink ;
         ListEntry !=  &LsapBindingCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, LSAP_BINDING_CACHE_ENTRY, ListEntry.Next);
        if (RtlEqualUnicodeString(
                &CacheEntry->RealmName,
                RealmName,
                TRUE
                ))
        {
            LsapReferenceBindingCacheEntry(
                CacheEntry,
                RemoveFromList
                );


            Found = TRUE;
            NtQuerySystemTime(
                &CacheEntry->LastUsed
                );
            break;
        }

    }
    if (!Found)
    {
        CacheEntry = NULL;
    }

    LsapUnlockList(&LsapBindingCache);
    return(CacheEntry);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeBindingCacheEntry
//
//  Synopsis:   Frees memory associated with a binding cache entry
//
//  Effects:
//
//  Arguments:  BindingCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapFreeBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    if ( !BindingCacheEntry )
    {
        return;
    }
    LsapFreeString(&BindingCacheEntry->RealmName);
    if (BindingCacheEntry->PolicyHandle != NULL)
    {
        LsaClose(BindingCacheEntry->PolicyHandle);
    }
    if (BindingCacheEntry->ServerName != NULL) {
        //
        // Note -- because I_NetLogonAuthData is not supported for NT4 and
        // below, ServerName won't always be allocated from NetLogon's MM.
        // So, the ServerName allocation is normalized to LocalAlloc/LocalFree
        //
        LocalFree(BindingCacheEntry->ServerName);
    }
    if (BindingCacheEntry->ServerPrincipalName != NULL) {
        I_NetLogonFree(BindingCacheEntry->ServerPrincipalName);
    }
    if (BindingCacheEntry->ClientContext != NULL) {
        I_NetLogonFree(BindingCacheEntry->ClientContext);
    }

    LsapFreeLsaHeap(BindingCacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapInsertBinding
//
//  Synopsis:   Inserts a binding into the binding cache
//
//  Effects:    bumps reference count on binding
//
//  Arguments:  CacheEntry - Cache entry to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapInsertBinding(
    IN PLSAP_BINDING_CACHE_ENTRY CacheEntry
    )
{
    LsapInsertListEntry(
        &CacheEntry->ListEntry,
        &LsapBindingCache
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCacheBinding
//
//  Synopsis:   Caches a binding in the binding cache
//
//  Effects:    creates a cache entry.
//
//  Arguments:  RealmName - The realm name of the LSA the binding is to.
//              Handle - LSA policy handle to the target machine.
//              ServerName,ServerPrincipalName, ClientContext - authenticated
//                      rpc parameters needed to be cached for the duration
//                      of the binding.
//              CacheEntry - Receives the new binding cache entry,
//                      referenced.
//
//  Requires:
//
//  Returns:
//
//  Notes:      Locks the binding cache for write access while adding
//              the cache entry.
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PLSA_HANDLE Handle,
    IN OUT LPWSTR * ServerName,
    IN OUT LPWSTR * ServerPrincipalName,
    IN OUT PVOID * ClientContext,
    OUT PLSAP_BINDING_CACHE_ENTRY * NewCacheEntry
    )
{
    PLSAP_BINDING_CACHE_ENTRY CacheEntry = NULL;
    PLSAP_BINDING_CACHE_ENTRY OldCacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *NewCacheEntry = NULL;

    CacheEntry = (PLSAP_BINDING_CACHE_ENTRY)
        LsapAllocateLsaHeap(sizeof(LSAP_BINDING_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        CacheEntry,
        sizeof(LSAP_BINDING_CACHE_ENTRY)
        );


    LsapInitializeListEntry(
        &CacheEntry->ListEntry
        );

    NtQuerySystemTime(
        &CacheEntry->LastUsed
        );

    Status = LsapDuplicateString(
                &CacheEntry->RealmName,
                RealmName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    CacheEntry->PolicyHandle = *Handle;
    *Handle = NULL;
    CacheEntry->ServerName = *ServerName;
    *ServerName = NULL;
    CacheEntry->ServerPrincipalName = *ServerPrincipalName;
    *ServerPrincipalName = NULL;
    CacheEntry->ClientContext = *ClientContext;
    *ClientContext = NULL;

    //
    // Before we insert this binding we want to remove any
    // previous instances of bindings to the same realm.
    //

    OldCacheEntry = LsapLocateBindingCacheEntry(
                        RealmName,
                        TRUE    // remove from cache
                        );

    if (OldCacheEntry != NULL)
    {
        LsapDereferenceBindingCacheEntry( OldCacheEntry );
    }

    //
    // Insert the cache entry into the cache
    //

    Status = LsapInsertBinding(
                CacheEntry
                );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewCacheEntry = CacheEntry;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if ( CacheEntry )
        {
            LsapFreeBindingCacheEntry(CacheEntry);
        }
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapRemoveBindingCacheEntry
//
//  Synopsis:   removes an entry from the binding cache
//
//  Effects:
//
//  Arguments:  CacheEntry - entry to remove
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapRemoveBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY CacheEntry
    )
{

    LsapLockList(&LsapBindingCache);

    LsapReferenceBindingCacheEntry(
        CacheEntry,
        TRUE
        );

    LsapDereferenceBindingCacheEntry(
        CacheEntry
        );


    LsapUnlockList(&LsapBindingCache);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\ausrvp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ausrvp.h

Abstract:

    This module contains AUTHENTICATION related data structures and
    API definitions that are private to the Local Security Authority
    (LSA) server.


Author:

    Jim Kelly (JimK) 21-February-1991

Revision History:

--*/

#ifndef _AUSRVP_
#define _AUSRVP_



//#define LSAP_AU_TRACK_CONTEXT
//#define LSAP_AU_TRACK_THREADS
//#define LSAP_AU_TRACK_LOGONS

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <stdlib.h>
#include "lsasrvp.h"
#include <aup.h>
#include <samrpc.h>
#include <ntdsapi.h>
#include "spmgr.h"
#include <secur32p.h>
#include "logons.h"
#include <credp.hxx>


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// AU specific constants                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The filter/augmentor routines use the following bits in a mask
// to track properties of IDs during logon.  These bits have the following
// meaning:
//
// LSAP_AU_SID_PROP_ALLOCATED - Indicates the SID was allocated within
//     the filter routine.  If an error occurs, this allows allocated
//     IDs to be deallocated.  Otherwise, the caller must deallocate
//     them.
//
// LSAP_AU_SID_COPY - Indicates the SID must be copied before returning.
//     This typically indicates that the pointed-to SID is a global
//     variable for use throughout LSA or that the SID is being referenced
//     from another structure (such as an existing TokenInformation structure).
//
// LSAP_AU_SID_PROP_HIGH_RATE - Indicates it is expected that the SID
//     will typically be used in ACLs to grant access.  This is useful
//     to know when arranging SIDs.  Placing the IDs that will have a
//     high chance of granting access at the front of the list of SIDs
//     will reduce the amount of time spent in access validation routines
//     after logon.
//

#define LSAP_AU_SID_PROP_ALLOCATED      (0x00000001L)
#define LSAP_AU_SID_PROP_COPY           (0x00000002L)
#define LSAP_AU_SID_PROP_HIGH_RATE      (0x00000004L)





/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Macro definitions                                                   //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Macros to gain exclusive access to protected global authentication
// data structures
//

#define LsapAuLock()    (RtlEnterCriticalSection(&LsapAuLock))
#define LsapAuUnlock()  (RtlLeaveCriticalSection(&LsapAuLock))



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Type definitions                                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// This data structure is used to house logon process information.
//

typedef struct _LSAP_LOGON_PROCESS {

    //
    //     Links - Used to link contexts together.  This must be the
    //        first field of the context block.
    //

    LIST_ENTRY Links;


    //
    //     ReferenceCount - Used to prevent this context from being
    //       deleted prematurely.
    //

    ULONG References;


    //
    //     ClientProcess - A handle to the client process.  This handle is
    //        used to perform virtual memory operations within the client
    //        process (allocate, deallocate, read, write).
    //

    HANDLE ClientProcess;


    //
    //    CommPort - A handle to the LPC communication port created to
    //       communicate with this client.  this port must be closed
    //       when the client deregisters.
    //

    HANDLE CommPort;

    //
    //    TrustedClient - If TRUE, the caller has TCB privilege and may
    //      call any API. If FALSE, the caller may only call
    //      LookupAuthenticatePackage and CallPackage, which is converted
    //      to LsaApCallPackageUntrusted.
    //

    BOOLEAN TrustedClient;

    //
    // Name of the logon process.
    //

    WCHAR LogonProcessName[1];

} LSAP_LOGON_PROCESS, *PLSAP_LOGON_PROCESS;




//
// This structure should be treated as opaque by non-LSA code.
// It is used to maintain client information related to individual
// requests.  A public data structure (LSA_CLIENT_REQUEST) is
// typecast to this type by LSA code.
//

typedef struct _LSAP_CLIENT_REQUEST {

    //
    //   Request - Points to the request message received from the
    //       client.
    //

    PLSAP_AU_API_MESSAGE Request;


} LSAP_CLIENT_REQUEST, *PLSAP_CLIENT_REQUEST;





//
// The dispatch table of services which are provided by
// authentication packages.
//
typedef struct _LSAP_PACKAGE_TABLE {
    PLSA_AP_INITIALIZE_PACKAGE LsapApInitializePackage;
    PLSA_AP_LOGON_USER LsapApLogonUser;
    PLSA_AP_CALL_PACKAGE LsapApCallPackage;
    PLSA_AP_LOGON_TERMINATED LsapApLogonTerminated;
    PLSA_AP_CALL_PACKAGE_UNTRUSTED LsapApCallPackageUntrusted;
    PLSA_AP_LOGON_USER_EX LsapApLogonUserEx;
} LSAP_PACKAGE_TABLE, *PLSA_PACKAGE_TABLE;


//
// Used to house information about each loaded authentication package
//

typedef struct _LSAP_PACKAGE_CONTEXT {
    PSTRING Name;
    LSAP_PACKAGE_TABLE PackageApi;
} LSAP_PACKAGE_CONTEXT, *PLSAP_PACKAGE_CONTEXT;


//
// Rather than keep authentication package contexts in a linked list,
// they are pointed to via an array of pointers.  This is practical
// because there will never be more than a handful of authentication
// packages in any particular system, and because authentication packages
// are never unloaded.
//

typedef struct _LSAP_PACKAGE_ARRAY {
    PLSAP_PACKAGE_CONTEXT Package[ANYSIZE_ARRAY];
} LSAP_PACKAGE_ARRAY, *PLSAP_PACKAGE_ARRAY;




//
// Logon Session & Credential management data structures.
//
// Credentials are kept in a structure that looks like:
//
//                    +------+     +------+
// LsapLogonSessions->| Logon|---->| Logon|------> o o o
//                    | Id   |     | Id   |
//                    |   *  |     |   *  |
//                    +---|--+     +---|--+
//                        |
//                        |   +-----+       +-----+
//                        +-->| Auth|------>| Auth|
//                            | Cred|       | Cred|
//                            |- - -|       |- - -|
//                            | Cred|       |  .  |
//                            | List|       |  .  |
//                            |  *  |       |  .  |
//                            +--|--+       +-----+
//                               |
//                               +------> +------------+
//                                        | NextCred   | -----> o o o
//                                        |- - - - - - |
//                                        | Primary Key|--->(PrimaryKeyvalue)
//                                        |- - - - - - |
//                                        | Credential |
//                                        | Value      |--->(CredentialValue)
//                                        +------------+
//
//
//

typedef struct _LSAP_CREDENTIALS {

    struct _LSAP_CREDENTIALS *NextCredentials;
    STRING PrimaryKey;
    STRING Credentials;

} LSAP_CREDENTIALS, *PLSAP_CREDENTIALS;



typedef struct _LSAP_PACKAGE_CREDENTIALS {

    struct _LSAP_PACKAGE_CREDENTIALS *NextPackage;

    //
    // Package that created (and owns) these credentials
    //

    ULONG PackageId;

    //
    // List of credentials associated with this package
    //

    PLSAP_CREDENTIALS Credentials;

} LSAP_PACKAGE_CREDENTIALS, *PLSAP_PACKAGE_CREDENTIALS;


#define LSAP_MAX_DS_NAMES   (DS_DNS_DOMAIN_NAME + 1)

typedef struct _LSAP_DS_NAME_MAP {
    LARGE_INTEGER   ExpirationTime ;
    ULONG           RefCount ;
    UNICODE_STRING  Name ;
} LSAP_DS_NAME_MAP, * PLSAP_DS_NAME_MAP ;

typedef struct _LSAP_LOGON_SESSION {

    //
    // List maintained for enumeration
    //

    LIST_ENTRY List ;

    //
    // Each record represents just one logon session
    //

    LUID LogonId;


    //
    // For audit purposes, we keep an account name, authenticating
    // authority name, and User SID for each logon session.
    //

    UNICODE_STRING AccountName;
    UNICODE_STRING AuthorityName;
    UNICODE_STRING ProfilePath;
    PSID UserSid;
    SECURITY_LOGON_TYPE LogonType;

    //
    // Session ID
    //

    ULONG Session ;

    //
    // Logon Time
    //

    LARGE_INTEGER LogonTime ;

    //
    // purported logon server.
    //

    UNICODE_STRING LogonServer;

    //
    // The authentication packages that have credentials associated
    // with this logon session each have their own record in the following
    // linked list.
    //
    // Access serialized by AuCredLock
    //

    PLSAP_PACKAGE_CREDENTIALS Packages;

    //
    // License Server Handle.
    //
    // Null if the license server need not be notified upon logoff.
    //

    HANDLE LicenseHandle;

    //
    // Handle to the token associated with this session.
    //
    // Access serialized by LogonSessionListLock
    //

    HANDLE TokenHandle;

    //
    // Creating Package
    //

    ULONG_PTR CreatingPackage;

    //
    // Create trace info:
    //

    ULONG Process ;
    ULONG ContextAttr ;

    //
    // Credential Sets for this logon session.
    //

    CREDENTIAL_SETS CredentialSets;


    //
    // Access serialized by LogonSessionListLock
    //
    PLSAP_DS_NAME_MAP DsNames[ LSAP_MAX_DS_NAMES ];

    //
    // Logon GUID
    // 
    // This is used by Kerberos package for auditing.
    // (please see function header for LsaIGetLogonGuid for more info)
    //
    GUID LogonGuid;

} LSAP_LOGON_SESSION, *PLSAP_LOGON_SESSION;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Internal API definitions                                            //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



//
// Logon process context management services
//

NTSTATUS
LsapAuInitializeContextMgr(
    VOID
    );

VOID
LsapAuAddClientContext(
    PLSAP_LOGON_PROCESS Context
    );

BOOLEAN
LsapAuReferenceClientContext(
    PLSAP_CLIENT_REQUEST ClientRequest,
    BOOLEAN RemoveContext,
    PBOOLEAN TrustedClient
    );

VOID
LsapAuDereferenceClientContext(
    PLSAP_LOGON_PROCESS Context
    );

//
// Authentication client loop and dispatch routines
//


NTSTATUS
LsapAuListenLoop(          // Listen for connections from logon processes
    IN PVOID ThreadParameter
    );

NTSTATUS
LsapAuServerLoop(          // Wait for logon process calls & dispatch them
    IN PVOID ThreadParameter
    );


BOOLEAN
LsapAuLoopInitialize(
    VOID
    );



typedef
NTSTATUS                   // Template dispatch routine
(* PLSAP_AU_API_DISPATCH)(
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    );


NTSTATUS
LsapAuApiDispatchLogonUser(         // LsaLogonUser() dispatch routine
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    );

NTSTATUS
LsapAuApiDispatchCallPackage(       // LsaCallAuthenticationPackage() dispatch routine
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    );




//
// Client process virtual memory routines
//


NTSTATUS
LsapAllocateClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    );

NTSTATUS
LsapFreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress OPTIONAL
    );

NTSTATUS
LsapCopyToClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    );

NTSTATUS
LsapCopyFromClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    );


//
// Logon session routines
//

BOOLEAN
LsapLogonSessionInitialize();

NTSTATUS
LsapCreateLogonSession(
    IN PLUID LogonId
    );

NTSTATUS
LsapDeleteLogonSession (
    IN PLUID LogonId
    );

PLSAP_LOGON_SESSION
LsapLocateLogonSession(
    PLUID LogonId
    );

VOID
LsapReleaseLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    );

NTSTATUS
LsapSetLogonSessionAccountInfo(
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN OPTIONAL PUNICODE_STRING ProfilePath,
    IN PSID * UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials OPTIONAL
    );

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );

VOID
LsapDerefDsNameMap(
    PLSAP_DS_NAME_MAP Map
    );

NTSTATUS
LsapGetNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession,
    ULONG NameType,
    PLSAP_DS_NAME_MAP * Map,
    BOOL  LocalOnly
    );

NTSTATUS
LsapSetSessionToken(
    IN HANDLE InputTokenHandle,
    IN PLUID LogonId
    );

NTSTATUS
LsapOpenTokenByLogonId(
    IN PLUID LogonId,
    OUT HANDLE *RetTokenHandle
    );

PLSAP_DS_NAME_MAP
LsapGetNameForLocalSystem(
    VOID
    );

//
// Credentials routines
//


NTSTATUS
LsapAddCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue,
    IN PSTRING Credentials
    );


NTSTATUS
LsapGetCredentials(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN OUT PULONG QueryContext,
    IN BOOLEAN RetrieveAllCredentials,
    IN PSTRING PrimaryKeyValue,
    OUT PULONG PrimaryKeyLength,
    IN PSTRING Credentials
    );

NTSTATUS
LsapDeleteCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue
    );


PLSAP_PACKAGE_CREDENTIALS
LsapGetPackageCredentials(
    IN PLSAP_LOGON_SESSION LogonSession,
    IN ULONG PackageId,
    IN BOOLEAN CreateIfNecessary
    );



VOID
LsapFreePackageCredentialList(
    IN PLSAP_PACKAGE_CREDENTIALS PackageCredentialList
    );



VOID
LsapFreeCredentialList(
    IN PLSAP_CREDENTIALS CredentialList
    );


NTSTATUS
LsapReturnCredential(
    IN PLSAP_CREDENTIALS SourceCredentials,
    IN PSTRING TargetCredentials,
    IN BOOLEAN ReturnPrimaryKey,
    IN PSTRING PrimaryKeyValue OPTIONAL,
    OUT PULONG PrimaryKeyLength OPTIONAL
    );



//
// Logon process related services
//


NTSTATUS
LsapValidLogonProcess(
    IN PVOID ConnectionRequest,
    IN ULONG RequestLength,
    IN PCLIENT_ID ClientId,
    OUT PLUID LogonId,
    OUT PULONG Flags
    );




//
// Authentication package routines
//



VOID
LsapAuLogonTerminatedPackages(
    IN PLUID LogonId
    );

NTSTATUS
LsaCallLicenseServer(
    IN PWCHAR LogonProcessName,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    IN BOOLEAN IsAdmin,
    OUT HANDLE *LicenseHandle
    );

VOID
LsaFreeLicenseHandle(
    IN HANDLE LicenseHandle
    );


//
//  Miscellaneous other routines
// (LsapAuInit() is the link to the rest of LSA and resides in lsap.h)
//





BOOLEAN
LsapWellKnownValueInit(
    VOID
    );

BOOLEAN
LsapEnableCreateTokenPrivilege(
    VOID
    );




NTSTATUS
LsapCreateNullToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull,
    OUT PHANDLE Token
    );

NTSTATUS
LsapCreateV2Token(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE Token
    );


NTSTATUS
LsapCaptureClientTokenGroups(
    IN PLSAP_CLIENT_REQUEST ClientRequest,
    IN ULONG GroupCount,
    IN PTOKEN_GROUPS ClientTokenGroups,
    IN PTOKEN_GROUPS *CapturedTokenGroups
    );


NTSTATUS
LsapBuildDefaultTokenGroups(
    PLSAP_LOGON_USER_ARGS Arguments
    );

VOID
LsapFreeTokenGroups(
    IN PTOKEN_GROUPS TokenGroups
    );

VOID
LsapFreeTokenPrivileges(
    IN PTOKEN_PRIVILEGES TokenPrivileges OPTIONAL
    );

VOID
LsapFreeTokenInformationNull(
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull
    );



VOID
LsapFreeTokenInformationV1(
    IN PLSA_TOKEN_INFORMATION_V1 TokenInformationV1
    );

VOID
LsapFreeTokenInformationV2(
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2
    );


NTSTATUS
LsapAuUserLogonPolicyFilter(
    IN SECURITY_LOGON_TYPE          LogonType,
    IN PLSA_TOKEN_INFORMATION_TYPE  TokenInformationType,
    IN PVOID                       *TokenInformation,
    IN PTOKEN_GROUPS                LocalGroups,
    OUT PQUOTA_LIMITS               QuotaLimits,
    OUT PPRIVILEGE_SET             *PrivilegesAssigned
    );




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Global variables of the LSA server                                  //
//                                                                     //
/////////////////////////////////////////////////////////////////////////





//
// Well known LUIDs
//

extern LUID LsapSystemLogonId;
extern LUID LsapAnonymousLogonId;


//
//  Well known privilege values
//


extern LUID LsapCreateTokenPrivilege;
extern LUID LsapAssignPrimaryTokenPrivilege;
extern LUID LsapLockMemoryPrivilege;
extern LUID LsapIncreaseQuotaPrivilege;
extern LUID LsapUnsolicitedInputPrivilege;
extern LUID LsapTcbPrivilege;
extern LUID LsapSecurityPrivilege;
extern LUID LsapTakeOwnershipPrivilege;

//
// Strings needed for auditing.
//

extern UNICODE_STRING LsapLsaAuName;
extern UNICODE_STRING LsapRegisterLogonServiceName;



//
//  The following information pertains to the use of the local SAM
//  for authentication.
//


// Length of typical Sids of members of the Account or Built-In Domains

extern ULONG LsapAccountDomainMemberSidLength,
             LsapBuiltinDomainMemberSidLength;

// Sub-Authority Counts for members of the Account or Built-In Domains

extern UCHAR LsapAccountDomainSubCount,
             LsapBuiltinDomainSubCount;

// Typical Sids for members of Account or Built-in Domains

extern PSID  LsapAccountDomainMemberSid,
             LsapBuiltinDomainMemberSid;





#endif // _AUSRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\bndcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.h
//
// Contents:    Prototypes and types for binding handle  cache
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __BNDCACHE_H__
#define __BNDCACHE_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines TKTCACHE_ALLOCATE
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef BNDCACHE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

typedef struct _LSAP_LIST {
    LIST_ENTRY List;
    RTL_CRITICAL_SECTION Lock;
} LSAP_LIST, *PLSAP_LIST;

EXTERN BOOLEAN LsapBindingCacheInitialized;
EXTERN LSAP_LIST LsapBindingCache;
#define LsapLockList(_List_) RtlEnterCriticalSection(&(_List_)->Lock)
#define LsapUnlockList(_List_) RtlLeaveCriticalSection(&(_List_)->Lock)

typedef struct _LSAP_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} LSAP_LIST_ENTRY, *PLSAP_LIST_ENTRY;


typedef struct _LSAP_BINDING_CACHE_ENTRY {
    LSAP_LIST_ENTRY ListEntry;
    TimeStamp LastUsed;
    UNICODE_STRING RealmName;
    LPWSTR ServerName;
    LPWSTR ServerPrincipalName;
    PVOID ClientContext;
    LSA_HANDLE PolicyHandle;
} LSAP_BINDING_CACHE_ENTRY, *PLSAP_BINDING_CACHE_ENTRY;


VOID
LsapDereferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
LsapReferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    );

NTSTATUS
LsapInitBindingCache(
    VOID
    );

VOID
LsapCleanupBindingCache(
    VOID
    );



PLSAP_BINDING_CACHE_ENTRY
LsapLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN BOOLEAN RemoveFromCache
    );


VOID
LsapFreeBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
LsapRemoveBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY CacheEntry
    );

NTSTATUS
LsapCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PLSA_HANDLE Handle,
    IN OUT LPWSTR * ServerName,
    IN OUT LPWSTR * ServerPrincipalName,
    IN OUT PVOID * ClientContext,
    OUT PLSAP_BINDING_CACHE_ENTRY * NewCacheEntry
    );

NTSTATUS
LsapRefreshBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY CacheEntry
    );


//
// Functions for manipulating lsap lists
//


NTSTATUS
LsapInitializeList(
    IN PLSAP_LIST List
    );

VOID
LsapFreeList(
    IN PLSAP_LIST List
    );

VOID
LsapInsertListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    );

VOID
LsapReferenceListEntry(
    IN PLSAP_LIST List,
    IN PLSAP_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    );

BOOLEAN
LsapDereferenceListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    );


VOID
LsapInitializeListEntry(
    IN OUT PLSAP_LIST_ENTRY ListEntry
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        credapi.c
//
// Contents:    Credential related APIs to the SPMgr
//              - LsaEstablishCreds
//              - LsaLogonUser
//              - LsaAcquireCredHandle
//              - LsaFreeCredHandle
//
//
// History:     20 May 92   RichardW    Commented existing code
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "adtp.h"
#include "msaudite.h"   // LsaAuditLogon
#include "suppcred.h"
}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaEstablishCreds
//
//  Synopsis:   Establishes credentials for a process.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaEstablishCreds( PSECURITY_STRING    pName,
                    PSECURITY_STRING    pSecPackage,
                    DWORD               cbKey,
                    PBYTE               pbKey,
                    PCredHandle         pcredHandle,
                    PTimeStamp          ptsExpiry)
{

    return(SEC_E_UNSUPPORTED_FUNCTION);

}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaAcquireCredHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaAcquireCredHandle(  PSECURITY_STRING    pPrincipal,
                        PSECURITY_STRING    pSecPackage,
                        DWORD               fCredentialUse,
                        PLUID               pLogonID,
                        PVOID               pvAuthData,
                        PVOID               pvGetKeyFn,
                        PVOID               pvGetKeyArgument,
                        PCredHandle         phCredential,
                        PTimeStamp          ptsExpiry)
{
    PLSAP_SECURITY_PACKAGE     pspPackage;
    NTSTATUS           scRet;
    LUID            CallerLogonID;
    PSession        pSession = GetCurrentSession();
    SECPKG_CLIENT_INFO ClientInfo;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // Check if the caller is restricted
    //
    scRet = LsapGetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get client info: 0x%x\n",scRet));
        return(scRet);
    }

    //
    // If the caller is restricted, fail the call for now. This should change
    // if packages are able to support restrictions. In that case, the call
    // should check the package capabilities for handling restrictions and
    // if it supports restrictions, allow the call to continue.
    //

    if (ClientInfo.Restricted)
    {
        DebugLog((DEB_WARN,"Trying to acquire credentials with a restrictred token\n"));
        scRet = SEC_E_NO_CREDENTIALS;
        return(scRet);
    }

#if DBG
    if (pPrincipal->Length)
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AcquireCredentialHandle(%ws, %ws)\n",
            pSession->dwProcessID, pPrincipal->Buffer, pSecPackage->Buffer));
    }
    else
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AcquireCredHandle(%x:%x, %ws)\n",
            pSession->dwProcessID, pLogonID->HighPart, pLogonID->LowPart,
            pSecPackage->Buffer));
    }
#endif // DBG

    phCredential->dwUpper = 0;
    phCredential->dwLower = 0xFFFFFFFF;
    ptsExpiry->LowPart = 0;
    ptsExpiry->HighPart = 0;

    pspPackage = SpmpLookupPackageAndRequest(pSecPackage,
                                            SP_ORDINAL_ACQUIRECREDHANDLE);
    if (!pspPackage)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    SetCurrentPackageId(pspPackage->dwPackageID);

    CallerLogonID = *pLogonID;

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.AcquireCredentialsHandle(pPrincipal,
                                                            fCredentialUse,
                                                            &CallerLogonID,
                                                            pvAuthData,
                                                            pvGetKeyFn,
                                                            pvGetKeyArgument,
                                                            &phCredential->dwUpper,
                                                            ptsExpiry);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    if (FAILED(scRet))
    {
        DebugLog((DEB_WARN, "Failed to acquire cred handle for %ws with %ws\n",
                            pPrincipal->Buffer, pSecPackage->Buffer));
        return(scRet);
    }

    phCredential->dwLower = pspPackage->dwPackageID;

    if(!AddCredHandle(pSession, phCredential, 0))
    {
        DebugLog(( DEB_ERROR, "Failed adding credential handle %p:%p to session %p\n",
                    phCredential->dwUpper, phCredential->dwLower,
                    pSession ));

        pspPackage = SpmpLookupPackageAndRequest(pSecPackage,
                                                SP_ORDINAL_FREECREDHANDLE);

        if( pspPackage )
        {
            ULONG OldCallCount = CallInfo->CallInfo.CallCount;

            CallInfo->CallInfo.CallCount = 1 ;


            //
            // remove the handle from the underlying package.
            //

            StartCallToPackage( pspPackage );

            __try
            {
                pspPackage->FunctionTable.FreeCredentialsHandle(
                                                        phCredential->dwUpper
                                                        );
            }
            __except (SP_EXCEPTION)
            {
                NOTHING;
            }

            EndCallToPackage( pspPackage );

            CallInfo->CallInfo.CallCount = OldCallCount;

        }

        phCredential->dwLower = 0;
        phCredential->dwUpper = 0;

        return SEC_E_INSUFFICIENT_MEMORY;
    }

    LsapLogCallInfo( CallInfo, pSession, *phCredential );

    return(scRet);
}


NTSTATUS
WLsaAddCredentials(
    PCredHandle     phCredential,
    PSECURITY_STRING    pPrincipal,
    PSECURITY_STRING    pSecPackage,
    DWORD               fCredentialUse,
    PVOID               pvAuthData,
    PVOID               pvGetKeyFn,
    PVOID               pvGetKeyArgument,
    PTimeStamp          ptsExpiry)
{
    PLSAP_SECURITY_PACKAGE     pspPackage;
    NTSTATUS           scRet;
    LUID            CallerLogonID;
    PSession        pSession = GetCurrentSession();
    SECPKG_CLIENT_INFO ClientInfo;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID CredKey ;

    //
    // Check if the caller is restricted
    //
    scRet = LsapGetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get client info: 0x%x\n",scRet));
        return(scRet);
    }

    //
    // If the caller is restricted, fail the call for now. This should change
    // if packages are able to support restrictions. In that case, the call
    // should check the package capabilities for handling restrictions and
    // if it supports restrictions, allow the call to continue.
    //

    if (ClientInfo.Restricted)
    {
        DebugLog((DEB_WARN,"Trying to acquire credentials with a restrictred token\n"));
        scRet = SEC_E_NO_CREDENTIALS;
        return(scRet);
    }

#if DBG
    if (pPrincipal->Length)
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AddCredentials(%ws, %ws)\n",
            pSession->dwProcessID, pPrincipal->Buffer, pSecPackage->Buffer));
    }
    else
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AddCredentials(%ws)\n",
            pSession->dwProcessID,
            pSecPackage->Buffer));
    }
#endif // DBG

    ptsExpiry->LowPart = 0;
    ptsExpiry->HighPart = 0;

    LsapLogCallInfo( CallInfo, pSession, *phCredential );

    scRet = ValidateCredHandle(
                    pSession,
                    phCredential,
                    &CredKey );

    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest( phCredential->dwLower,
                                       SP_ORDINAL_ADDCREDENTIALS );
    }
    else
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return( SEC_E_INVALID_HANDLE );
    }

    if (!pspPackage)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    SetCurrentPackageId(pspPackage->dwPackageID);

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.AddCredentials(
                                            phCredential->dwUpper,
                                            pPrincipal,
                                            pSecPackage,
                                            fCredentialUse,
                                            pvAuthData,
                                            pvGetKeyFn,
                                            pvGetKeyArgument,
                                            ptsExpiry);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    if (FAILED(scRet))
    {
        DebugLog((DEB_WARN, "Failed to add credentials for %ws with %ws\n",
                            pPrincipal->Buffer, pSecPackage->Buffer));
        return(scRet);
    }

    LsapLogCallInfo( CallInfo, pSession, *phCredential );

    return(scRet);
}





//+-------------------------------------------------------------------------
//
//  Function:   WLsaFreeCredHandle
//
//  Synopsis:   Worker function to free a cred handle,
//
//  Effects:    calls into a package to free the handle
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaFreeCredHandle( PCredHandle     phCreds)
{
    NTSTATUS       scRet;
    PSession    pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PLSAP_SECURITY_PACKAGE pPackage;


    IsOkayToExec(0);

    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaFreeCredHandle(%p : %p)\n",
                pSession->dwProcessID, phCreds->dwUpper, phCreds->dwLower));

    scRet = ValidateAndDerefCredHandle( pSession, phCreds );

    if ( !NT_SUCCESS( scRet ) )
    {
        if ( ( CallInfo->Flags & CALL_FLAG_NO_HANDLE_CHK ) == 0 )
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );
        }
    }

    LsapLogCallInfo( CallInfo, pSession, *phCreds );

    if (SUCCEEDED(scRet))
    {
        phCreds->dwUpper = phCreds->dwLower = 0xFFFFFFFF;
    }

    return(scRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   SpmpFreePrimaryCredentials
//
//  Synopsis:   Frees primary credentials allocated with LsapAllocateLsaHeap
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
SpmpFreePrimaryCredentials(
    IN PSECPKG_PRIMARY_CRED PrimaryCred
    )
{

    if (PrimaryCred->DownlevelName.Buffer != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->DownlevelName.Buffer);
        PrimaryCred->DownlevelName.Buffer = NULL;
    }
    if (PrimaryCred->DomainName.Buffer != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->DomainName.Buffer);
        PrimaryCred->DomainName.Buffer = NULL;
    }
    if (PrimaryCred->DnsDomainName.Buffer != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->DnsDomainName.Buffer);
        PrimaryCred->DnsDomainName.Buffer = NULL;
    }
    if (PrimaryCred->Upn.Buffer != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->Upn.Buffer);
        PrimaryCred->Upn.Buffer = NULL;
    }
    if (PrimaryCred->Password.Buffer != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->Password.Buffer);
        PrimaryCred->Password.Buffer = NULL;
    }
    if (PrimaryCred->LogonServer.Buffer != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->LogonServer.Buffer);
        PrimaryCred->LogonServer.Buffer = NULL;
    }
    if (PrimaryCred->UserSid != NULL)
    {
        LsapFreeLsaHeap(PrimaryCred->UserSid);
        PrimaryCred->UserSid = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaQueryCredAttributes
//
//  Synopsis:   SPMgr worker to query credential attributes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaQueryCredAttributes(
    PCredHandle phCredentials,
    ULONG ulAttribute,
    PVOID pBuffer
    )
{
    NTSTATUS       scRet;
    PSession    pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PLSAP_SECURITY_PACKAGE pPackage;
    PVOID       CredKey = NULL ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaQueryCredAttributes(%p : %p)\n",
                pSession->dwProcessID, phCredentials->dwUpper, phCredentials->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phCredentials );

    scRet = ValidateCredHandle(
                    pSession,
                    phCredentials,
                    &CredKey );

    if ( !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return( scRet );
    }


    pPackage = SpmpValidRequest(phCredentials->dwLower,
                                SP_ORDINAL_QUERYCREDATTR );

    if (pPackage)
    {

        SetCurrentPackageId(phCredentials->dwLower);

        StartCallToPackage( pPackage );

        __try
        {
            scRet = pPackage->FunctionTable.QueryCredentialsAttributes(
                        phCredentials->dwUpper,
                        ulAttribute,
                        pBuffer
                        );

        }
        __except (SP_EXCEPTION)
        {
            scRet = GetExceptionCode();
            scRet = SPException(scRet, phCredentials->dwLower);
        }

        EndCallToPackage( pPackage );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    DerefCredHandle( pSession, NULL, CredKey );

    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\crserver.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    crserver.c

Abstract:

    Local Security Authority - Server Cipher Routines

    These routines interface the LSA server side with the Cipher
    Routines.  They perform RPC-style memory allocation.

Author:

    Scott Birrell       (ScottBi)       December 13, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>


NTSTATUS
LsapCrServerGetSessionKey(
    IN LSAPR_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    )

/*++

Routine Description:

    This function obtains the Session Key, allocates an Cipher Key
    structure and returns the key.

Arguments:

    ObjectHandle - Handle from an LsaOpen<ObjectType> call.

    SessionKey - Receives a pointer to a structure containing the
       Session Key in which the memory has been allocated via
       MIDL_user_allocate().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            (e.g memory) to complete the call.
--*/


{
    NTSTATUS Status;
    PLSAP_CR_CIPHER_KEY OutputSessionKey = NULL;
    ULONG OutputSessionKeyBufferLength;

    //
    // Allocate memory for the Session Key buffer and LSAP_CR_CIPHER_KEY
    // structure.
    //

    OutputSessionKeyBufferLength = sizeof (USER_SESSION_KEY);

    OutputSessionKey = MIDL_user_allocate(
                           OutputSessionKeyBufferLength +
                           sizeof (LSAP_CR_CIPHER_KEY)
                           );

    if (OutputSessionKey == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ServerGetSessionKeyError;
    }

    //
    // Fill in the Cipher key structure, making the buffer point to
    // just beyond the header.
    //

    OutputSessionKey->Length = OutputSessionKeyBufferLength;
    OutputSessionKey->MaximumLength = OutputSessionKeyBufferLength;
    OutputSessionKey->Buffer = (PUCHAR) (OutputSessionKey + 1);

    Status = RtlGetUserSessionKeyServer(
                 ObjectHandle,
                 (PUSER_SESSION_KEY) OutputSessionKey->Buffer
                 );

    if (!NT_SUCCESS(Status)) {

        goto ServerGetSessionKeyError;
    }

    OutputSessionKey->Length = OutputSessionKey->MaximumLength =
        OutputSessionKeyBufferLength;

ServerGetSessionKeyFinish:

    *SessionKey = OutputSessionKey;
    return(Status);

ServerGetSessionKeyError:

    goto ServerGetSessionKeyFinish;
}


NTSTATUS
LsapCrServerGetSessionKeySafe(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    )

/*++

Routine Description:

    This function obtains the Session Key, allocates an Cipher Key
    structure and returns the key.

    Same a LsapCrServerGetSessionKey except the ObjectHandle is verified

        the LsapCrServerGetSessionKey version of this routine shouldn't exist.
        That routine calls down into the kernel.  Such a call can call back up to the
        LSA and lock locks.  Since LsapCrServerGetSessionKey doesn't validate the
        handle, the caller must have done that.  All such callers lock LSA locks.
        That's bound to be a deadlock.


Arguments:

    ObjectHandle - Handle from an LsaOpen<ObjectType> call.

    ObjectTypeId - Type of ObjectHandle.

    SessionKey - Receives a pointer to a structure containing the
       Session Key in which the memory has been allocated via
       MIDL_user_allocate().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            (e.g memory) to complete the call.
--*/


{
    NTSTATUS Status;


    //
    // Verify that the handle is valid.
    //

    Status =  LsapDbVerifyHandle( ObjectHandle, 0, ObjectTypeId, TRUE );

    if (NT_SUCCESS(Status)) {

        //
        // Get the session key.
        //

        Status = LsapCrServerGetSessionKey( ObjectHandle,
                                            SessionKey );

        //
        // Dereference the handle
        //

        (VOID) LsapDbDereferenceHandle( ObjectHandle );

    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        ctxtapi.c
//
// Contents:    Context APIs to the SPMgr.
//              - LsaInitContext
//              - LsaAcceptContext
//              - LsaFinalizeContext
//              - LsaMapContext
//
//              And WLsa functions
//
// History:     20 May 92   RichardW    Commented existing code
//
//------------------------------------------------------------------------


#include <lsapch.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   WLsaInitContext
//
//  Synopsis:   Worker that maps the call to the appropriate package
//
//  Effects:
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pTarget]       --
//              [fContextReq]   --
//              [dwReserved1]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [dwReserved2]   --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [MappedContext] --
//              [ContextData]   --
//
//  Requires:
//
//  Returns:
//
//  History:    9-24-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WLsaInitContext(    PCredHandle         phCredential,
                    PCtxtHandle         phContext,
                    PSECURITY_STRING    pTarget,
                    DWORD               fContextReq,
                    DWORD               dwReserved1,
                    DWORD               TargetDataRep,
                    PSecBufferDesc      pInput,
                    DWORD               dwReserved2,
                    PCtxtHandle         phNewContext,
                    PSecBufferDesc      pOutput,
                    DWORD *             pfContextAttr,
                    PTimeStamp          ptsExpiry,
                    PBOOLEAN            MappedContext,
                    PSecBuffer          ContextData )
{
    NTSTATUS       scRet;
    PLSAP_SECURITY_PACKAGE pspPackage;
    PSession    pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID ContextKey = NULL ;
    PVOID CredKey = NULL ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaInitContext(%p : %p, %p : %p, %ws)\n",
                pSession->dwProcessID,
                phCredential->dwUpper,
                phCredential->dwLower,
                phContext->dwUpper,
                phContext->dwLower,
                pTarget->Buffer));

#if DBG
    if ( pInput && pInput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pInput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );
    }
    if ( pOutput && pOutput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pOutput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );

    }
#endif

    //
    // Reset the new handle to a known, invalid state
    //

    phNewContext->dwLower = SPMGR_ID;
    phNewContext->dwUpper = 0;


    //
    // Check handles against the session to make sure they're valid.  If the
    // context handle is valid, we use that, otherwise the credential.
    //

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );

    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest( phContext->dwLower,
                                        SP_ORDINAL_INITLSAMODECTXT );

        //
        // Tricky stuff:  if the context handle is valid, but does not
        // come from the same package as the credential, null out the cred
        // handle:
        //

        if ( phCredential->dwLower != phContext->dwLower )
        {
            phCredential->dwLower = 0;
            phCredential->dwUpper = 0;
        }

        LsapLogCallInfo( CallInfo, pSession, *phContext );

    }
    else
    {

        LsapLogCallInfo( CallInfo, pSession, *phCredential );

        scRet = ValidateCredHandle(
                        pSession,
                        phCredential,
                        &CredKey );

        if ( NT_SUCCESS( scRet ) )
        {
            pspPackage = SpmpValidRequest( phCredential->dwLower,
                                           SP_ORDINAL_INITLSAMODECTXT );
        }
        else
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

            return( SEC_E_INVALID_HANDLE );
        }
    }

    if ( !pspPackage )
    {
        if ( ContextKey )
        {
            DerefContextHandle( pSession, NULL, ContextKey );
        }

        if ( CredKey )
        {
            DerefCredHandle( pSession, NULL, CredKey );
        }

        return( SEC_E_INVALID_HANDLE );
    }


    SetCurrentPackageId( pspPackage->dwPackageID );

    StartCallToPackage( pspPackage );

    DebugLog((DEB_TRACE_VERB, "\tContext Req = 0x%08x\n", fContextReq));

    DebugLog((DEB_TRACE_VERB, "\tPackage = %ws\n", pspPackage->Name.Buffer));

    __try
    {

        scRet = pspPackage->FunctionTable.InitLsaModeContext(
                                                phCredential->dwUpper,
                                                phContext->dwUpper,
                                                pTarget,
                                                fContextReq,
                                                TargetDataRep,
                                                pInput,
                                                &phNewContext->dwUpper,
                                                pOutput,
                                                pfContextAttr,
                                                ptsExpiry,
                                                MappedContext,
                                                ContextData );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    DebugLog((DEB_TRACE_WAPI, "InitResult = %x\n", scRet));
    DebugLog((DEB_TRACE_VERB, "\tFlags = %08x\n", *pfContextAttr));


    //
    // Only add a new context if the old one didn't exist.
    // Otherwise copy the old context over the new context.
    //

    if ( NT_SUCCESS( scRet ) )
    {
        if ( (phNewContext->dwUpper != 0) &&
             (phNewContext->dwUpper != phContext->dwUpper) )
        {
            //
            // If the package ID is unchanged, set it to the current package
            // id.  This is so that if package changes the ID through
            // LsapChangeHandle, we can catch it.
            //

            if ( phNewContext->dwLower == SPMGR_ID )
            {
                phNewContext->dwLower = pspPackage->dwPackageID ;

                if(!AddContextHandle( pSession, phNewContext, 0 ))
                {
                    DebugLog(( DEB_ERROR, "Failed adding context handle %p:%p to session %p\n",
                                phNewContext->dwUpper, phNewContext->dwLower,
                                pSession ));

                    pspPackage = SpmpValidRequest(
                                                phNewContext->dwLower,
                                                SP_ORDINAL_DELETECTXT
                                                );

                    if( pspPackage )
                    {
                        //
                        // remove the handle from the underlying package.
                        //

                        StartCallToPackage( pspPackage );

                        __try
                        {
                            pspPackage->FunctionTable.DeleteContext(
                                                            phNewContext->dwUpper
                                                            );
                        }
                        __except (SP_EXCEPTION)
                        {
                            NOTHING;
                        }

                        EndCallToPackage( pspPackage );
                    }

                    phNewContext->dwLower = 0;
                    phNewContext->dwUpper = 0;

                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                }
            }

        }
        else
        {
            *phNewContext = *phContext;
        }
    }
    else
    {
        *phNewContext = *phContext ;
    }

    DebugLog(( DEB_TRACE_WAPI, "Init New Context = %p : %p to session %p\n",
                phNewContext->dwUpper , phNewContext->dwLower, pSession ));

    SetCurrentPackageId( SPMGR_ID );

    if ( ContextKey )
    {
        DerefContextHandle( pSession, NULL, ContextKey );
    }

    if ( CredKey )
    {
        DerefCredHandle( pSession, NULL, CredKey );
    }

    return(scRet);



}






//+-------------------------------------------------------------------------
//
//  Function:   WLsaAcceptContext()
//
//  Synopsis:   Worker function for AcceptSecurityContext()
//
//  Effects:    Creates a server-side security context
//
//  Arguments:  See LsaAcceptContext()
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaAcceptContext(  PCredHandle     phCredential,
                    PCtxtHandle     phContext,
                    PSecBufferDesc  pInput,
                    DWORD           fContextReq,
                    DWORD           TargetDataRep,
                    PCtxtHandle     phNewContext,
                    PSecBufferDesc  pOutput,
                    DWORD *         pfContextAttr,
                    PTimeStamp      ptsExpiry,
                    PBOOLEAN        MappedContext,
                    PSecBuffer      ContextData)
{
    NTSTATUS       scRet;
    PLSAP_SECURITY_PACKAGE pspPackage;
    PSession    pSession;
    PVOID       ContextKey = NULL ;
    PVOID       CredKey = NULL ;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // Clear out the handle
    //

    phNewContext->dwLower = SPMGR_ID;
    phNewContext->dwUpper = 0;

#if DBG
    if ( pInput && pInput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pInput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );
    }
    if ( pOutput && pOutput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pOutput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );

    }
#endif
    //
    // Get our session
    //

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaAcceptContext(%p : %p)\n",
                pSession->dwProcessID,
                phCredential->dwUpper, phCredential->dwLower));

    //
    // Check handles against the session to make sure they're valid.  If the
    // context handle is valid, we use that, otherwise the credential.
    //

    scRet = ValidateContextHandle(
                    pSession,
                    phContext,
                    &ContextKey );

    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest( phContext->dwLower,
                                        SP_ORDINAL_ACCEPTLSAMODECTXT );

        //
        // Tricky stuff:  if the context handle is valid, but does not
        // come from the same package as the credential, null out the cred
        // handle:
        //

        if ( phCredential->dwLower != phContext->dwLower )
        {
            phCredential->dwLower = 0;
            phCredential->dwUpper = 0;
        }

        LsapLogCallInfo( CallInfo, pSession, *phContext );

    }
    else
    {

        LsapLogCallInfo( CallInfo, pSession, *phCredential );

        scRet = ValidateCredHandle(
                        pSession,
                        phCredential,
                        &CredKey );

        if ( NT_SUCCESS( scRet ) )
        {
            pspPackage = SpmpValidRequest( phCredential->dwLower,
                                           SP_ORDINAL_ACCEPTLSAMODECTXT );
        }
        else
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

            return( SEC_E_INVALID_HANDLE );
        }
    }

    if ( !pspPackage )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        if ( ContextKey )
        {
            DerefContextHandle( pSession, NULL, ContextKey );
        }

        if ( CredKey )
        {
            DerefCredHandle( pSession, NULL, CredKey );
        }

        return( SEC_E_INVALID_HANDLE );
    }


    SetCurrentPackageId( pspPackage->dwPackageID );

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.AcceptLsaModeContext(
                                phCredential->dwUpper,
                                phContext->dwUpper,
                                pInput,
                                fContextReq,
                                TargetDataRep,
                                &phNewContext->dwUpper,
                                pOutput,
                                pfContextAttr,
                                ptsExpiry,
                                MappedContext,
                                ContextData );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    DebugLog((DEB_TRACE_WAPI, "[%x]  Result = %x\n", pSession->dwProcessID, scRet));

    //
    // Only add a new context if the old one didn't exist.
    // Otherwise copy the old context over the new context.
    //

    if ( NT_SUCCESS( scRet ) || ( scRet == SEC_E_INCOMPLETE_MESSAGE ) )
    {
        if ( (phNewContext->dwUpper != 0) &&
             (phNewContext->dwUpper != phContext->dwUpper) )
        {
            //
            // If the package ID is unchanged, set it to the current package
            // id.  This is so that if package changes the ID through
            //

            if ( phNewContext->dwLower == SPMGR_ID )
            {
                phNewContext->dwLower = pspPackage->dwPackageID ;

                if(!AddContextHandle( pSession, phNewContext, 0 ))
                {
                    DebugLog(( DEB_ERROR, "Failed adding context handle %p:%p to session %p\n",
                                phNewContext->dwUpper, phNewContext->dwLower,
                                pSession ));

                    pspPackage = SpmpValidRequest(
                                                phNewContext->dwLower,
                                                SP_ORDINAL_DELETECTXT
                                                );

                    if( pspPackage )
                    {
                        //
                        // remove the handle from the underlying package.
                        //

                        StartCallToPackage( pspPackage );

                        __try
                        {
                            pspPackage->FunctionTable.DeleteContext(
                                                            phNewContext->dwUpper
                                                            );
                        }
                        __except (SP_EXCEPTION)
                        {
                            NOTHING;
                        }

                        EndCallToPackage( pspPackage );
                    }

                    phNewContext->dwLower = 0;
                    phNewContext->dwUpper = 0;

                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                }
            }

        }
        else
        {
            *phNewContext = *phContext;
        }
    }
    else
    {
        *phNewContext = *phContext ;
    }

    DebugLog(( DEB_TRACE_WAPI, "Accept new context = %p : %p \n",
                    phNewContext->dwUpper, phNewContext->dwLower ));

    SetCurrentPackageId( SPMGR_ID );

    if ( ContextKey )
    {
        DerefContextHandle( pSession, NULL, ContextKey );
    }

    if ( CredKey )
    {
        DerefCredHandle( pSession, NULL, CredKey );
    }

    return(scRet);

}





//+-------------------------------------------------------------------------
//
//  Function:   WLsaDeleteContext
//
//  Synopsis:   Worker function for deleting a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaDeleteContext(  PCtxtHandle     phContext)
{
    NTSTATUS scRet;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();


    DebugLog((DEB_TRACE_WAPI, "[%x] WDeleteContext(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));


    scRet = ValidateAndDerefContextHandle(
                    pSession,
                    phContext );

    if ( (CallInfo->Flags & CALL_FLAG_NO_HANDLE_CHK) == 0 )
    {
        if ( !NT_SUCCESS( scRet ) )
        {
            DebugLog((DEB_ERROR,"[%x] Invalid handle passed to DeleteContext: %p:%p\n",
                pSession->dwProcessID,
                phContext->dwUpper,phContext->dwLower));

///            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        }
    }

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    if (SUCCEEDED(scRet))
    {
        phContext->dwUpper = phContext->dwLower = 0xFFFFFFFF;
    }


    return(scRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   WLsaApplyControlToken
//
//  Synopsis:   Worker function for applying a control token
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaApplyControlToken(  PCtxtHandle     phContext,
                        PSecBufferDesc  pInput)
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();
    PVOID           ContextKey ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WApplyControlToken(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );

    if ( !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return( scRet );

    }

    pspPackage = SpmpValidRequest(  phContext->dwLower,
                                    SP_ORDINAL_APPLYCONTROLTOKEN);

    if ( !pspPackage )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    SetCurrentPackageId(phContext->dwLower);

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.ApplyControlToken(
                                                phContext->dwUpper,
                                                pInput);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    SetCurrentPackageId( SPMGR_ID );

    DerefContextHandle( pSession, NULL, ContextKey );

    return(scRet);

}



NTSTATUS
WLsaQueryContextAttributes(
    PCtxtHandle phContext,
    ULONG       ulAttribute,
    PVOID       pvBuffer
    )
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage = NULL ;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID           ContextKey ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaQueryContextAttributes(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );


    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest(  phContext->dwLower,
                                        SP_ORDINAL_QUERYCONTEXTATTRIBUTES);
    }
    if (( !pspPackage ) ||
        !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return(SEC_E_INVALID_HANDLE);
    }

    StartCallToPackage( pspPackage );

    SetCurrentPackageId(phContext->dwLower);

    __try
    {
        scRet = pspPackage->FunctionTable.QueryContextAttributes(
                                                phContext->dwUpper,
                                                ulAttribute,
                                                pvBuffer );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    SetCurrentPackageId( SPMGR_ID );

    DerefContextHandle( pSession, NULL, ContextKey );

    return(scRet);

}



NTSTATUS
WLsaSetContextAttributes(
    PCtxtHandle phContext,
    ULONG       ulAttribute,
    PVOID       pvBuffer,
    ULONG       cbBuffer
    )
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage = NULL ;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID           ContextKey ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaSetContextAttributes(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );


    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest(  phContext->dwLower,
                                        SP_ORDINAL_SETCONTEXTATTRIBUTES);
    }
    if (( !pspPackage ) ||
        !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return(SEC_E_INVALID_HANDLE);
    }

    StartCallToPackage( pspPackage );

    SetCurrentPackageId(phContext->dwLower);

    __try
    {
        scRet = pspPackage->FunctionTable.SetContextAttributes(
                                                phContext->dwUpper,
                                                ulAttribute,
                                                pvBuffer,
                                                cbBuffer );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    SetCurrentPackageId( SPMGR_ID );

    DerefContextHandle( pSession, NULL, ContextKey );

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\db.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    db.h

Abstract:

    LSA Database Exported Function Definitions, Datatypes and Defines

    This module contains the LSA Database Routines that may be called
    by parts of the LSA outside the Database sub-component.

Author:

    Scott Birrell       (ScottBi)       August 26, 1991

Environment:

Revision History:

--*/

#ifndef _LSA_DB_
#define _LSA_DB_

//
// Maximum Number of attributes in the various object types
//

#define LSAP_DB_ATTRS_POLICY             ((ULONG) 0x00000010L)
#define LSAP_DB_ATTRS_ACCOUNT            ((ULONG) 0x00000010L)
#define LSAP_DB_ATTRS_DOMAIN             ((ULONG) 0x00000012L)
#define LSAP_DB_ATTRS_SECRET             ((ULONG) 0x00000010L)

//
// Constants for matching options on Sid/Name lookup operations
//

#define LSAP_DB_MATCH_ON_SID             ((ULONG) 0x00000001L)
#define LSAP_DB_MATCH_ON_NAME            ((ULONG) 0x00000002L)

//
// Options for LsapDbLookupSidsInLocalDomains()
//

#define LSAP_DB_SEARCH_BUILT_IN_DOMAIN   ((ULONG) 0x00000001L)
#define LSAP_DB_SEARCH_ACCOUNT_DOMAIN    ((ULONG) 0x00000002L)

//
// Options for LsapDbMergeDisjointReferencedDomains
//

#define LSAP_DB_USE_FIRST_MERGAND_GRAPH  ((ULONG) 0x00000001L)
#define LSAP_DB_USE_SECOND_MERGAND_GRAPH ((ULONG) 0x00000002L)

//
// Option for updating Policy Database
//

#define LSAP_DB_UPDATE_POLICY_DATABASE   ((ULONG) 0x00000001L)
//
// Option for updating Policy Database
//

#define LSAP_DB_UPDATE_POLICY_DATABASE   ((ULONG) 0x00000001L)
//
// Maximum number of attributes corresponding to a Policy Object
// Information Class
//

#define LSAP_DB_ATTRS_INFO_CLASS_POLICY  ((ULONG) 0x00000007L)

//
// Maximum number of attributes corresponding to a Trusted Domain Object
// Information Class
//

#define LSAP_DB_ATTRS_INFO_CLASS_DOMAIN  ((ULONG) 0x00000010L)

//
// Global variables
//

extern BOOLEAN LsapDbRequiresSidInfo[];
extern BOOLEAN LsapDbRequiresNameInfo[];
extern LSAPR_HANDLE LsapDbHandle;
extern BOOLEAN LsapSetupWasRun;
extern BOOLEAN LsapDatabaseSetupPerformed;
extern NT_PRODUCT_TYPE LsapProductType;
extern WORD LsapProductSuiteMask;
extern BOOLEAN LsapDsIsRunning;
extern BOOLEAN LsapDsWReplEnabled;


//
// Table of accesses required to query Policy Information.  This table
// is indexed by Policy Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessQueryPolicy[];
extern ACCESS_MASK LsapDbRequiredAccessQueryDomainPolicy[];

//
// Table of accesses required to set Policy Information.  This table
// is indexed by Policy Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessSetPolicy[];
extern ACCESS_MASK LsapDbRequiredAccessSetDomainPolicy[];

//
// Table of accesses required to query TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessQueryTrustedDomain[];

//
// Table of accesses required to set TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessSetTrustedDomain[];

//
// Maximum Handle Reference Count
//

#define LSAP_DB_MAXIMUM_REFERENCE_COUNT  ((ULONG) 0x00001000L)

//
// Maximum handles per user logon id
//   This was determined by taking the "interesting" access bits and generating possible
//   permutations and using that.  The interesting bits were determined to be:
//      POLICY_VIEW_LOCAL_INFORMATION
//      POLICY_VIEW_AUDIT_INFORMATION
//      POLICY_TRUST_ADMIN
//      POLICY_CREATE_ACCOUNT
//      POLICY_CREATE_SECRET
//      POLICY_LOOKUP_NAMES
//   The possible combinations add up to 720 entries
#define LSAP_DB_MAXIMUM_HANDLES_PER_USER    0x000002D0

//
// Default Computer Name used for Policy Account Domain Info
//

#define LSAP_DB_DEFAULT_COMPUTER_NAME    (L"MACHINENAME")

//
// Options for the LsaDbReferenceObject and LsaDbDereferenceObject
//

#define LSAP_DB_LOCK                                  ((ULONG) 0x00000001L)
#define LSAP_DB_NO_LOCK                               ((ULONG) 0x00000004L)
#define LSAP_DB_START_TRANSACTION                     ((ULONG) 0x00000008L)
#define LSAP_DB_FINISH_TRANSACTION                    ((ULONG) 0x00000010L)
#define LSAP_DB_VALIDATE_HANDLE                       ((ULONG) 0x00000020L)
#define LSAP_DB_TRUSTED                               ((ULONG) 0x00000040L)
#define LSAP_DB_STANDALONE_REFERENCE                  ((ULONG) 0x00000080L)
#define LSAP_DB_DEREFERENCE_CONTR                     ((ULONG) 0x00000100L)
#define LSAP_DB_LOG_QUEUE_LOCK                        ((ULONG) 0x00001000L)
#define LSAP_DB_OMIT_REPLICATOR_NOTIFICATION          ((ULONG) 0x00004000L)
#define LSAP_DB_USE_LPC_IMPERSONATE                   ((ULONG) 0x00008000L)
#define LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES          ((ULONG) 0x00010000L)
#define LSAP_DB_DS_NO_PARENT_OBJECT                   ((ULONG) 0x00080000L)
#define LSAP_DB_OBJECT_SCOPE_DS                       ((ULONG) 0x00100000L)
#define LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET           ((ULONG) 0x00400000L)
#define LSAP_DB_READ_ONLY_TRANSACTION                 ((ULONG) 0x01000000L)
#define LSAP_DB_DS_OP_TRANSACTION                     ((ULONG) 0x02000000L)
#define LSAP_DB_NO_DS_OP_TRANSACTION                  ((ULONG) 0x04000000L)
#define LSAP_DB_HANDLE_UPGRADE                        ((ULONG) 0x10000000L)
#define LSAP_DB_HANDLE_CREATED_SECRET                 ((ULONG) 0x20000000L)
#define LSAP_DB_SCE_POLICY_HANDLE                     ((ULONG) 0x40000000L)

#define LSAP_DB_STATE_MASK                                           \
    (LSAP_DB_LOCK | LSAP_DB_NO_LOCK | \
     LSAP_DB_START_TRANSACTION | LSAP_DB_FINISH_TRANSACTION |        \
     LSAP_DB_LOG_QUEUE_LOCK | \
     LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_DS_OP_TRANSACTION | \
     LSAP_DB_NO_DS_OP_TRANSACTION)


//
// Configuration Registry Root Key for Lsa Database.  All Physical Object
// and Attribute Names are relative to this Key.
//

#define LSAP_DB_ROOT_REG_KEY_NAME L"\\Registry\\Machine\\Security"

//
// LSA Database Object Defines
//

#define LSAP_DB_OBJECT_OPEN                FILE_OPEN
#define LSAP_DB_OBJECT_OPEN_IF             FILE_OPEN_IF
#define LSAP_DB_OBJECT_CREATE              FILE_CREATE
#define LSAP_DB_KEY_VALUE_MAX_LENGTH       (0x00000040L)
#define LSAP_DB_LOGICAL_NAME_MAX_LENGTH    (0x00000100L)
#define LSAP_DB_CREATE_OBJECT_IN_DS        (0x00000200L)

#define LSAP_DB_CREATE_VALID_EXTENDED_FLAGS     0x00000600

//
// LSA Database Object SubKey Defines
//

#define LSAP_DB_SUBKEY_OPEN                FILE_OPEN
#define LSAP_DB_SUBKEY_OPEN_IF             FILE_OPEN_IF
#define LSAP_DB_SUBKEY_CREATE              FILE_CREATE


//
// Growth Delta for Referenced Domain Lists
//

#define LSAP_DB_REF_DOMAIN_DELTA     ((ULONG)  0x00000020L )

//
// Object options values for the object handles
//
#define LSAP_DB_OBJECT_SECRET_INTERNAL      0x00000001  // M$
#define LSAP_DB_OBJECT_SECRET_LOCAL         0x00000002  // L$


//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//
// WARNING! This is an internal version of LSA_REFERENCED_DOMAIN_LIST
// in ntlsa.h.  It has an additional field, MaxEntries.
//

typedef struct _LSAP_DB_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;
    ULONG MaxEntries;

} LSAP_DB_REFERENCED_DOMAIN_LIST, *PLSAP_DB_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//
//     MaxEntries - Is the maximum number of entries that can be stored
//         in the current array


/////////////////////////////////////////////////////////////////////////////
//
// LSA Database Object Types
//
/////////////////////////////////////////////////////////////////////////////

//
// Lsa Database Object Type
//

typedef enum _LSAP_DB_OBJECT_TYPE_ID {

    NullObject = 0,
    PolicyObject,
    TrustedDomainObject,
    AccountObject,
    SecretObject,
    AllObject,
    NewTrustedDomainObject,
    DummyLastObject

} LSAP_DB_OBJECT_TYPE_ID, *PLSAP_DB_OBJECT_TYPE_ID;

//
// LSA Database Object Handle structure (Internal definition of LSAPR_HANDLE)
//
// Note that the Handle structure is public to clients of the Lsa Database
// exported functions, e.g server API workers) so that they can get at things
// like GrantedAccess.
//
// Access to all fields serialized by LsapDbHandleTableEx.TableLock
//

typedef struct _LSAP_DB_HANDLE {

    struct _LSAP_DB_HANDLE *Next;
    struct _LSAP_DB_HANDLE *Previous;
    LIST_ENTRY UserHandleList;
    BOOLEAN Allocated;
    BOOLEAN SceHandle;          // Sce Open Policy handle (opened with LsaOpenPolicySce)
    BOOLEAN SceHandleChild;     // Child handle of an Sce Open Policy Handle
    ULONG ReferenceCount;
    UNICODE_STRING LogicalNameU;
    UNICODE_STRING PhysicalNameU;
    PSID Sid;
    HANDLE KeyHandle;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;
    struct _LSAP_DB_HANDLE *ContainerHandle;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK GrantedAccess;
    ACCESS_MASK RequestedAccess;
    BOOLEAN GenerateOnClose;
    BOOLEAN Trusted;
    BOOLEAN DeletedObject;
    BOOLEAN NetworkClient;
    ULONG Options;
    // New for the Ds
    UNICODE_STRING PhysicalNameDs;
    BOOLEAN fWriteDs;
    ULONG ObjectOptions;
    PVOID   UserEntry;
#if DBG == 1
    LARGE_INTEGER HandleCreateTime;
    LARGE_INTEGER HandleLastAccessTime;
#endif

} *LSAP_DB_HANDLE, **PLSAP_DB_HANDLE;

//
// LSA Database Object Sid Enumeration Buffer
//

typedef struct _LSAP_DB_SID_ENUMERATION_BUFFER {

    ULONG EntriesRead;
    PSID *Sids;

} LSAP_DB_SID_ENUMERATION_BUFFER, *PLSAP_DB_SID_ENUMERATION_BUFFER;

//
// LSA Database Object Name Enumeration Buffer
//

typedef struct _LSAP_DB_NAME_ENUMERATION_BUFFER {

    ULONG EntriesRead;
    PUNICODE_STRING Names;

} LSAP_DB_NAME_ENUMERATION_BUFFER, *PLSAP_DB_NAME_ENUMERATION_BUFFER;

#define LSAP_DB_OBJECT_TYPE_COUNT 0x00000005L

//
// Default System Access assigned to Account objects
//

#define LSAP_DB_ACCOUNT_DEFAULT_SYS_ACCESS      ((ULONG) 0L);

//
// LSA Database Account Object Information
//

typedef struct _LSAP_DB_ACCOUNT_INFORMATION {

    QUOTA_LIMITS QuotaLimits;
    PRIVILEGE_SET Privileges;

} LSAP_DB_ACCOUNT_INFORMATION, *PLSAP_DB_ACCOUNT_INFORMATION;

//
// LSA Database Change Account Privilege Mode
//

typedef enum _LSAP_DB_CHANGE_PRIVILEGE_MODE {
    AddPrivileges = 1,
    RemovePrivileges,
    SetPrivileges

} LSAP_DB_CHANGE_PRIVILEGE_MODE;

//
// Self-Relative Unicode String Structure.
//
//
// UNICODE_STRING_SR is used to store self-relative unicode strings in
// the database.  Prior to Sundown, the UNICODE_STRING structure was used,
// overloading the "Buffer" field with a byte offset.
//

typedef struct _UNICODE_STRING_SR {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Offset;

} UNICODE_STRING_SR, *PUNICODE_STRING_SR;

typedef struct _LSAP_DB_MULTI_UNICODE_STRING {

    ULONG Entries;
    UNICODE_STRING_SR UnicodeStrings[1];

} LSAP_DB_MULTI_UNICODE_STRING, *PLSAP_DB_MULTI_UNICODE_STRING;

//
// LSA Database Object SubKey names in Unicode Form
//

typedef enum _LSAP_DB_NAMES {

    SecDesc = 0,
    Privilgs,
    Sid,
    Name,
    AdminMod,
    OperMode,
    QuotaLim,
    DefQuota,
    QuAbsMin,
    QuAbsMax,
    AdtLog,
    AdtEvent,
    PrDomain,
    EnPasswd,
    Policy,
    Accounts,
    Domains,
    Secrets,
    CurrVal,
    OldVal,
    CupdTime,
    OupdTime,
    WkstaMgr,
    PolAdtLg,
    PolAdtEv,
    PolAcDmN,
    PolAcDmS,
    PolDnDDN,
    PolDnTrN,
    PolDnDmG,
    PolEfDat,
    PolPrDmN,
    PolPrDmS,
    PolPdAcN,
    PolRepSc,
    PolRepAc,
    PolRevision,
    PolDefQu,
    PolMod,
    PolAdtFL,
    PolState,
    PolNxPxF,
    ActSysAc,
    TrDmName,
    TrDmTrPN,   // Netbios name of trust partner
    TrDmSid,
    TrDmAcN,
    TrDmCtN,
    TrDmPxOf,
    TrDmCtEn,
    TrDmTrTy,   // Type of trust
    TrDmTrDi,   // Trust direction
    TrDmTrLA,   // Trust attributes
    TrDmTrPr,   // Trust partner
    TrDmTrRt,   // Trust root partner
    TrDmSAI,    // Auth inbound
    TrDmSAO,    // Auth outbound
    TrDmForT,   // Forest trust info
    AcMaPCF,    // Machine account password change frequency
    PolIPSec,   // IPSec object reference
    PolDIPSec,  // Domain wide IPSec object reference
    PolLoc,     // Policy location,
    PolPubK,    // Public key policy
    KerOpts,    // Kerberos authentication options
    KerMinT,    // Kerberos Minimum ticket age
    KerMaxT,    // Kerberos maximum ticket age
    KerMaxR,    // Kerberos maximum renewal age
    KerProxy,   // Kerberos proxy lifetime
    KerLogoff,  // Kerberos force logoff duration
    DmLDur,     // Lockout duration
    DmLObWin,   // Lockout observation window
    DmLThrs,    // Lockout threshold
    DmPMinL,    // Minimum password length
    DmPHisL,    // Password history length
    DmPProp,    // Password properties
    DmPMinA,    // Minimum password age
    DmPMaxA,    // Maximum password age
    BhvrVers,   // Behavior-Version
    AuditLog,
    AuditLogMaxSize,
    AuditRecordRetentionPeriod,     // Entries beyond this point don't correspond to real policy
                                    // entries, but are pseudo entries only
    PseudoSystemCritical,
    PolSecretEncryptionKey,
    XRefDnsRoot,      // DNS name of cross-ref object
    XRefNetbiosName,  // NETBIOS name of cross-ref object
    DummyLastName

} LSAP_DB_NAMES;

typedef struct _LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO {

    ULONG SystemAccess;
    QUOTA_LIMITS QuotaLimits;
    PPRIVILEGE_SET PrivilegeSet;

} LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO, *PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern UNICODE_STRING LsapDbNames[DummyLastName];
extern UNICODE_STRING LsapDbObjectTypeNames[DummyLastObject];

//
// LSA Database Object Type-specific attribute names and values.  If
// supplied on a call to LsapDbCreateObject, they will be stored with
// the object.
//

typedef enum _LSAP_DB_ATTRIB_TYPE {

    LsapDbAttribUnknown = 0,
    LsapDbAttribUnicode,
    LsapDbAttribMultiUnicode,
    LsapDbAttribSid,
    LsapDbAttribGuid,
    LsapDbAttribULong,
    LsapDbAttribUShortAsULong,
    LsapDbAttribSecDesc,
    LsapDbAttribDsName,
    LsapDbAttribPByte,
    LsapDbAttribTime,
    LsapDbAttribDsNameAsUnicode,
    LsapDbAttribDsNameAsSid,
    LsapDbAttribIntervalAsULong

} LSAP_DB_ATTRIB_TYPE, *PLSAP_DB_ATTRIB_TYPE;


typedef struct _LSAP_DB_ATTRIBUTE {

    PUNICODE_STRING AttributeName;
    PVOID AttributeValue;
    ULONG AttributeValueLength;
    BOOLEAN MemoryAllocated;
    BOOLEAN CanDefaultToZero;
    BOOLEAN PseudoAttribute;
    ULONG DsAttId;
    LSAP_DB_ATTRIB_TYPE AttribType;
    LSAP_DB_NAMES DbNameIndex;

} LSAP_DB_ATTRIBUTE, *PLSAP_DB_ATTRIBUTE;

typedef enum _LSAP_DB_DS_LOCATION {

    LsapDsLocUnknown = 0,
    LsapDsLocRegistry,
    LsapDsLocDs,
    LsapDsLocDsLocalPolObj,
    LsapDsLocDsDomainPolObj,
    LsapDsLocLocalAndReg
} LSAP_DB_DS_LOCATION, *PLSAP_DB_DS_LOCATION;

typedef struct _LSAP_DB_DS_INFO {

    ULONG AttributeId;
    LSAP_DB_ATTRIB_TYPE AttributeType;
    LSAP_DB_DS_LOCATION AttributeLocation;

} LSAP_DB_DS_INFO, *PLSAP_DB_DS_INFO;

//
// LSA Database Object General Information.
//

typedef struct _LSAP_DB_OBJECT_INFORMATION {

    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;
    LSAP_DB_OBJECT_TYPE_ID ContainerTypeId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PLSAP_DB_ATTRIBUTE TypeSpecificAttributes;
    PSID Sid;
    BOOLEAN ObjectAttributeNameOnly;
    ULONG DesiredObjectAccess;

} LSAP_DB_OBJECT_INFORMATION, *PLSAP_DB_OBJECT_INFORMATION;

//
// New for the Ds integration
//
extern PLSAP_DB_DS_INFO LsapDbDsAttInfo;

//
// Installed, absolute minimum and absolute maximum Quota Limits.
//

extern QUOTA_LIMITS LsapDbInstalledQuotaLimits;
extern QUOTA_LIMITS LsapDbAbsMinQuotaLimits;
extern QUOTA_LIMITS LsapDbAbsMaxQuotaLimits;

//
// Required Ds data types
//
//
// This is the state of the machine with respect to the Ds.  It will control
// some of the basic functionality of the Lsa APIs by determing who can write
// what where, etc...
//
typedef enum _LSADS_INIT_STATE {

    LsapDsUnknown = 0,
    LsapDsNoDs,
    LsapDsDs,
    LsapDsDsMaintenance,
    LsapDsDsSetup

} LSADS_INIT_STATE, *PLSADS_INIT_STATE;


//
// LSA Database Exported Function Prototypes
//
// NOTE: These are callable only from the LSA
//

BOOLEAN
LsapDbIsServerInitialized(
    );

NTSTATUS
LsapDbOpenPolicy(
    IN PLSAPR_SERVER_NAME SystemName OPTIONAL,
    IN OPTIONAL PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE PolicyHandle,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
LsapDbOpenTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG Options
    );

NTSTATUS
LsapDbOpenTrustedDomainByName(
    IN LSAPR_HANDLE PolicyHandle OPTIONAL,
    IN PUNICODE_STRING TrustedDomainName,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG AccessMask,
    IN ULONG Options,
    IN BOOLEAN Trusted
    );

NTSTATUS
LsapDbOpenObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE LsaHandle
    );

NTSTATUS
LsapDbCreateObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG Options,
    IN OPTIONAL PLSAP_DB_ATTRIBUTE TypeSpecificAttributes,
    IN ULONG TypeSpecificAttributeCount,
    OUT PLSAPR_HANDLE LsaHandle
    );

NTSTATUS
LsapCloseHandle(
    IN OUT LSAPR_HANDLE *ObjectHandle,
    IN NTSTATUS PreliminaryStatus
    );

NTSTATUS
LsapDbCloseObject(
    IN PLSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN NTSTATUS PreliminaryStatus
    );

NTSTATUS
LsapDbDeleteObject(
    IN LSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapDbReferenceObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LSAP_DB_OBJECT_TYPE_ID HandleTypeId,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    );

NTSTATUS
LsapDbDereferenceObject(
    IN OUT PLSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID HandleTypeId,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN NTSTATUS PreliminaryStatus
    );

NTSTATUS
LsapDbReadAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength
    );

NTSTATUS
LsapDbReadAttributeObjectEx(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_NAMES AttributeIndex,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength,
    IN BOOLEAN CanDefaultToZero
    );

NTSTATUS
LsapDbWriteAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN PVOID AttributeValue,
    IN ULONG AttributeValueLength
    );

NTSTATUS
LsapDbWriteAttributeObjectEx(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_NAMES AttributeIndex,
    IN PVOID AttributeValue,
    IN ULONG AttributeValueLength
    );

NTSTATUS
LsapDbWriteAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDbReadAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDbDeleteAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN BOOLEAN DeleteSecurely
    );

NTSTATUS
LsapDbDeleteAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDbQueryInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PULONG PrivilegeCount,
    OUT PLUID_AND_ATTRIBUTES *Privileges,
    OUT PQUOTA_LIMITS QuotaLimits,
    OUT PULONG SystemAccess
    );

NTSTATUS
LsapDbOpenTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDbApplyTransaction(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType
    );

NTSTATUS
LsapDbAbortTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDbSidToLogicalNameObject(
    IN PSID Sid,
    OUT PUNICODE_STRING LogicalNameU
    );

NTSTATUS
LsapDbMakeTemporaryObject(
    IN LSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapDbChangePrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN LSAP_DB_CHANGE_PRIVILEGE_MODE ChangeMode,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOL LockSce
    );


NTSTATUS
LsapDbEnumerateSids(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbFindNextSid(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_SID *NextSid
    );

NTSTATUS
LsapDbEnumeratePrivileges(
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbEnumerateNames(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbFindNextName(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_UNICODE_STRING Name
    );

VOID
LsapDbFreeEnumerationBuffer(
    IN PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer
    );

NTSTATUS
LsapDbInitializeServer(
    IN ULONG Pass
    );

NTSTATUS
LsapDbInstallRegistry(
    );

//
// These routines may someday migrate to Rtl runtime library.  Their
// names have Lsap Prefixes only temporarily, so that they can be located
// easily.
//

// Options for LsapRtlAddPrivileges

#define  RTL_COMBINE_PRIVILEGE_ATTRIBUTES   ((ULONG) 0x00000001L)
#define  RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES ((ULONG) 0x00000002L)

NTSTATUS
LsapRtlAddPrivileges(
    IN OUT PPRIVILEGE_SET * RunningPrivileges,
    IN OUT PULONG           MaxRunningPrivileges,
    IN PPRIVILEGE_SET       PrivilegesToAdd,
    IN ULONG                Options,
    OUT OPTIONAL BOOLEAN *  Changed
    );

NTSTATUS
LsapRtlRemovePrivileges(
    IN OUT PPRIVILEGE_SET ExistingPrivileges,
    IN PPRIVILEGE_SET PrivilegesToRemove
    );

PLUID_AND_ATTRIBUTES
LsapRtlGetPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege,
    IN PPRIVILEGE_SET Privileges
    );

BOOLEAN
LsapRtlPrefixSid(
    IN PSID PrefixSid,
    IN PSID Sid
    );

ULONG
LsapDbGetSizeTextSid(
    IN PSID Sid
    );

NTSTATUS
LsapDbSidToTextSid(
    IN PSID Sid,
    OUT PSZ TextSid
    );

NTSTATUS
LsapDbSidToUnicodeSid(
    IN PSID Sid,
    OUT PUNICODE_STRING SidU,
    IN BOOLEAN AllocateDestinationString
    );


NTSTATUS
LsapDbInitializeWellKnownValues();

#if defined(REMOTE_BOOT)
VOID
LsapDbInitializeRemoteBootState();
#endif // defined(REMOTE_BOOT)

NTSTATUS
LsapDbVerifyInformationObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation
    );

/*++

BOOLEAN
LsapDbIsValidTypeObject(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    )

Routine Description:

    This macro function determines if a given Object Type Id is valid.

Arguments:

    ObjectTypeId - Object Type Id.

Return Values:

    BOOLEAN - TRUE if object type id is valid, else FALSE.

--*/

#define LsapDbIsValidTypeObject(ObjectTypeId)                            \
            (((ObjectTypeId) > NullObject) &&                            \
             ((ObjectTypeId) < DummyLastObject))


NTSTATUS
LsapDbGetRequiredAccessQueryPolicy(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PACCESS_MASK RequiredAccess
    );


NTSTATUS
LsapDbVerifyInfoQueryPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PACCESS_MASK RequiredAccess
    );

NTSTATUS
LsapDbVerifyInfoSetPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation,
    OUT PACCESS_MASK RequiredAccess
    );

BOOLEAN
LsapDbValidInfoPolicy(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_POLICY_INFORMATION PolicyInformation
    );

NTSTATUS
LsapDbVerifyInfoQueryTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    );

NTSTATUS
LsapDbVerifyInfoSetTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    );

BOOLEAN
LsapDbValidInfoTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    );

NTSTATUS
LsapDbMakeUnicodeAttribute(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeMultiUnicodeAttribute(
    OUT PLSAP_DB_ATTRIBUTE Attribute,
    IN PUNICODE_STRING AttributeName,
    IN PUNICODE_STRING UnicodeNames,
    IN ULONG Entries
    );

VOID
LsapDbCopyUnicodeAttributeNoAlloc(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    );

NTSTATUS
LsapDbCopyUnicodeAttribute(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    );

NTSTATUS
LsapDbMakeSidAttribute(
    IN PSID Sid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeGuidAttribute(
    IN GUID *Guid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeBlobAttribute(
    IN  ULONG   BlobLength,
    IN  PBYTE   pBlob,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeUnicodeAttributeDs(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeMultiUnicodeAttributeDs(
    OUT PLSAP_DB_ATTRIBUTE Attribute,
    IN LSAP_DB_NAMES Name,
    IN PUNICODE_STRING UnicodeNames,
    IN ULONG Entries
    );

NTSTATUS
LsapDbMakeSidAttributeDs(
    IN PSID Sid,
    IN IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeGuidAttributeDs(
    IN GUID *Guid,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeBlobAttributeDs(
    IN  ULONG   BlobLength,
    IN  PBYTE   pBlob,
    IN  LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakePByteAttributeDs(
    IN OPTIONAL PBYTE Buffer,
    IN ULONG BufferLength,
    IN LSAP_DB_ATTRIB_TYPE AttribType,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );


NTSTATUS
LsapDbReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbFreeAttributes(
    IN ULONG Count,
    IN PLSAP_DB_ATTRIBUTE Attributes
    );

/*++

VOID
LsapDbInitializeAttribute(
    IN PLSAP_DB_ATTRIBUTE AttributeP,
    IN PUNICODE_STRING AttributeNameP,
    IN OPTIONAL PVOID AttributeValueP,
    IN ULONG AttributeValueLengthP,
    IN BOOLEAN MemoryAllocatedP
    )

Routine Description:

    This macro function initialize an Lsa Database Object Attribute
    structure.  No validation is done.

Arguments:

    AttributeP - Pointer to Lsa Database Attribute structure to be
        initialized.

    AttributeNameP - Pointer to Unicode String containing the attribute's
        name.

    AttributeValueP - Pointer to the attribute's value.  NULL may be
        specified.

    AttributeValueLengthP - Length of the attribute's value in bytes.

    MemoryAllocatedP - TRUE if memory is allocated by MIDL_user_allocate
        within the LSA Server code (not by RPC server stubs), else FALSE.

Return Values:

    None.

--*/

#define LsapDbInitializeAttribute(                                         \
            AttributeP,                                                    \
            AttributeNameP,                                                \
            AttributeValueP,                                               \
            AttributeValueLengthP,                                         \
            MemoryAllocatedP                                               \
            )                                                              \
                                                                           \
{                                                                          \
    (AttributeP)->AttributeName = AttributeNameP;                          \
    (AttributeP)->AttributeValue = AttributeValueP;                        \
    (AttributeP)->AttributeValueLength = AttributeValueLengthP;            \
    (AttributeP)->MemoryAllocated = MemoryAllocatedP;                      \
    (AttributeP)->DsAttId =   0;                                           \
    (AttributeP)->AttribType = LsapDbAttribUnknown;                        \
    (AttributeP)->CanDefaultToZero = FALSE;                                \
    (AttributeP)->PseudoAttribute = FALSE;                                 \
}

/*++

VOID
LsapDbInitializeAttributeDs(
    IN PLSAP_DB_ATTRIBUTE AttributeP,
    IN LSAP_DB_NAMES Name,
    IN OPTIONAL PVOID AttributeValueP,
    IN ULONG AttributeValueLengthP,
    IN BOOLEAN MemoryAllocatedP
    )

Routine Description:

    This macro function initialize an Lsa Database Object Attribute
    structure.  No validation is done.

Arguments:

    AttributeP - Pointer to Lsa Database Attribute structure to be
        initialized.

    Name - Name index to create

    AttributeValueP - Pointer to the attribute's value.  NULL may be
        specified.

    AttributeValueLengthP - Length of the attribute's value in bytes.

    MemoryAllocatedP - TRUE if memory is allocated by MIDL_user_allocate
        within the LSA Server code (not by RPC server stubs), else FALSE.

Return Values:

    None.

--*/
#define LsapDbInitializeAttributeDs(                                       \
            AttributeP,                                                    \
            Name,                                                          \
            AttributeValueP,                                               \
            AttributeValueLengthP,                                         \
            MemoryAllocatedP                                               \
            )                                                              \
                                                                           \
{                                                                          \
    LsapDbInitializeAttribute( (AttributeP), &LsapDbNames[Name],           \
                                AttributeValueP, AttributeValueLengthP,    \
                                MemoryAllocatedP );                        \
    (AttributeP)->DsAttId =   LsapDbDsAttInfo[Name].AttributeId;           \
    (AttributeP)->AttribType = LsapDbDsAttInfo[Name].AttributeType;        \
    (AttributeP)->CanDefaultToZero = FALSE;                                \
    (AttributeP)->DbNameIndex = Name;                                      \
}

#define LsapDbAttributeCanNotExist(                                        \
            AttributeP                                                     \
            )                                                              \
{                                                                          \
    (AttributeP)->CanDefaultToZero = TRUE;                                 \
}


NTSTATUS
LsapDbGetPrivilegesAndQuotas(
    IN LSAPR_HANDLE PolicyHandle,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PULONG PrivilegeCount,
    OUT PLUID_AND_ATTRIBUTES *Privileges,
    OUT PQUOTA_LIMITS QuotaLimits
    );


NTSTATUS
LsapInitializeNotifiyList(
    VOID
    );

NTSTATUS
LsapCrServerGetSessionKeySafe(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    );

NTSTATUS
LsapDbVerifyHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ExpectedObjectTypeId,
    IN BOOLEAN ReferenceHandle
    );

BOOLEAN
LsapDbDereferenceHandle(
    IN LSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapDbQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    );

NTSTATUS
LsapCreateTrustedDomain2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    );

NTSTATUS
LsapDsInitializeDsStateInfo(
    IN  LSADS_INIT_STATE    DsInitState
    );

NTSTATUS
LsapDsUnitializeDsStateInfo(
    );

/*++

BOOLEAN
LsapValidateLsaUnicodeString(
    IN PLSAPR_UNICODE_STRING UnicodeString
    );

Returns TRUE if the LSAPR_UNICODE_STRING is valid.  FALSE otherwise
--*/

#define LsapValidateLsaUnicodeString( _us_ ) \
(( (_us_) == NULL  || \
    ( \
        (_us_)->MaximumLength >= ( _us_ )->Length && \
        (_us_)->Length % 2 == 0  && \
        (_us_)->MaximumLength % 2 == 0 && \
        ((_us_)->Length == 0  || (_us_)->Buffer != NULL ) \
    ) \
) ? TRUE : FALSE )

/*++

BOOLEAN
LsapValidateLsaCipherValue(
    IN PLSAPR_UNICODE_STRING UnicodeString
    );

Returns TRUE if the LSAPR_CR_CIPHER_KEY is valid.  FALSE otherwise
--*/

#define LsapValidateLsaCipherValue( _us_ ) \
    ( \
        (_us_)->MaximumLength >= ( _us_ )->Length && \
        ((_us_)->Length == 0  || (_us_)->Buffer != NULL ) \
    ) \
? TRUE : FALSE


NTSTATUS
LsapDbIsImpersonatedClientNetworkClient(
    IN OUT PBOOLEAN IsNetworkClient
    );

BOOLEAN
LsapSidPresentInGroups(
    IN PTOKEN_GROUPS TokenGroups,
    IN SID * Sid
    );

NTSTATUS
LsapDomainRenameHandlerForLogonSessions(
    IN PUNICODE_STRING OldNetbiosName,
    IN PUNICODE_STRING OldDnsName,
    IN PUNICODE_STRING NewNetbiosName,
    IN PUNICODE_STRING NewDnsName
    );

NTSTATUS
LsapRetrieveDnsDomainNameFromHive(
    IN HKEY Hkey,
    IN OUT DWORD * Length,
    OUT WCHAR * Buffer
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _LSA_DB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#define ANSI
#include <stdarg.h>
}
//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [SPM]
//      DebugFlags=<Flag>[<,Flag>]*
//      BreakFlags=<BreakFlag>[<,BreakFlags>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace, Verbose, BreakOnError, Helpers,
//          RefMon, Locator, WAPI, Init, Audit, Db, Lsa
//
//      BreakFlags will cause SPMgr to break, if BreakOnError is set in
//      DebugFlags:
//          InitBegin, InitEnd, Connect, Exception, Problem, Load
//
//

#if DBG         // NOTE:  This file not compiled for retail builds


extern "C"
{
WINBASEAPI
BOOL
WINAPI
IsDebuggerPresent(
    VOID
    );
}



DEFINE_DEBUG2(SPM);
DEBUG_KEY   SpmgrDebugKeys[] = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_VERB,       "Verbose"},
                                 {DEB_TRACE_WAPI,       "WAPI"},
                                 {DEB_TRACE_HELPERS,    "Helpers"},
                                 {DEB_TRACE_RM,         "RefMon"},
                                 {DEB_TRACE_INIT,       "Init"},
                                 {DEB_TRACE_SCAV,       "Scav"},
                                 {DEB_TRACE_CRED,       "Cred"},
                                 {DEB_TRACE_NEG,        "Neg"},
                                 {DEB_TRACE_LPC,        "LPC"},
                                 {DEB_TRACE_SAM,        "SAM"},
                                 {DEB_TRACE_LSA,        "LSA"},
                                 {DEB_TRACE_SPECIAL,    "Special"},
                                 {DEB_TRACE_QUEUE,      "Queue"},
                                 {DEB_TRACE_HANDLES,    "Handles"},
                                 {DEB_TRACE_NEG_LOCKS,  "NegLock"},
                                 {DEB_TRACE_AUDIT,      "Audit"},
                                 {DEB_TRACE_EFS,        "EFS"},
                                 {DEB_BREAK_ON_ERROR,   "BreakOnError"},
                                 {0, NULL},
                                 };

DWORD   BreakFlags = 0;

DEFINE_DEBUG2(Neg);
DEBUG_KEY   NegDebugKeys[]   = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_LOCKS,      "Locks"},
                                 {0, NULL},
                                 };

extern  DWORD   NoUnload;

CHAR    DbgPackageName[] = "LSA Debug Package";

LSA_AP_INITIALIZE_PACKAGE       DbgInitialize;
LSA_AP_CALL_PACKAGE             DbgCallPackage;
LSA_AP_CALL_PACKAGE_UNTRUSTED   DbgCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH DbgCallPackagePassthrough;

SECPKG_FUNCTION_TABLE   DbgTable = {
            DbgInitialize,
            NULL,
            DbgCallPackage,
            NULL,
            DbgCallPackage,         
            DbgCallPackage,
            NULL,
            NULL,
            NULL
            };



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char   szSection[] = "SPMgr";

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   BreakKeyNames[] = {
                {"InitBegin",   BREAK_ON_BEGIN_INIT},
                {"InitEnd",     BREAK_ON_BEGIN_END},
                {"Connect",     BREAK_ON_P_CONNECT},
                {"Exception",   BREAK_ON_SP_EXCEPT},
                {"Problem",     BREAK_ON_PROBLEM},
                {"Shutdown",    BREAK_ON_SHUTDOWN},
                {"Load",        BREAK_ON_LOAD}
                };

#define NUM_BREAK_KEYS  (sizeof(BreakKeyNames) / sizeof(DebugKeys))

DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_strcmpi(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
LoadDebugParameters(void)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;


    if (SPMInfoLevel & DEB_BREAK_ON_ERROR)
    {
        SPMSetOption( DEBUG_BREAK_ON_ERROR, TRUE, TRUE );

        cbVal = GetProfileStringA(szSection, "BreakFlags", "", szVal, sizeof(szVal));
        if (cbVal)
        {
            pszDebug = strtok(szVal, ", \t");
            while (pszDebug)
            {
                BreakFlags |= GetDebugKeyValue(BreakKeyNames, NUM_BREAK_KEYS,
                                                pszDebug);

                pszDebug = strtok(NULL, ", \t");
            }
        } // If break flags exists
    }


}


//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the SPMgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
InitDebugSupport(void)
{
    SPMInitDebug(SpmgrDebugKeys);

    LoadDebugParameters();

}




SECURITY_STATUS
SEC_ENTRY
DbgInitialize(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    )
{
    PSTRING Name ;

    Name = (PSTRING) LsapAllocateLsaHeap( sizeof( STRING ) );
    
    if ( Name )
    {
        Name->Buffer = (PSTR) LsapAllocateLsaHeap( sizeof( DbgPackageName ) );
        Name->Length = sizeof( DbgPackageName ) - 1;
        Name->MaximumLength = sizeof( DbgPackageName );
        if ( Name->Buffer )
        {
            strcpy( Name->Buffer, DbgPackageName );
            *AuthenticationPackageName = Name ;
            return TRUE ;
        }
        else 
        {
            LsapFreeLsaHeap( Name );

        }
    }
    return FALSE ;
}


NTSTATUS
DbgCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return STATUS_INVALID_PARAMETER ;

}
    








#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\credmgr.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credmgr.cxx

Abstract:

    Credential Manager Interfaces

Author:

    Cliff Van Dyke      (CliffV)

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <wincrypt.h>
#include <windns.h>
#include <align.h>
#include <rc4.h>
#include <des.h>
#include <modes.h>
#include <cryptdll.h>
#include <names.h>
#include <smbgtpt.h>
#include <shfolder.h>
#include <netlibnt.h>
#include <stddef.h>
}

//
// Include routines common with netapi32.dll
//

#include <credp.h>
#include <..\netclient\credapi.c>

extern "C"
{
BOOLEAN
LsapIsRunningOnPersonal(
    VOID
    );
}

//
// Local structures
//

//
// Structure describing a canonical credential
//
// This is the structure of a single credential as stored in memory in the LSA process.
//

typedef struct _CANONICAL_CREDENTIAL {

    //
    // The Credential itself
    //

    CREDENTIALW Cred;

    //
    // The size in bytes of the clear text credential blob
    //

    ULONG ClearCredentialBlobSize;

    //
    // Link to next entry in the list of credentials in the credential set.
    //  Access serialized by UserCredentialSets->CritSect
    //

    LIST_ENTRY Next;

    //
    // UNICODE_STRING form of Cred.TargetName
    //

    UNICODE_STRING TargetName;

    //
    // UNICODE_STRING form of Cred.TargetAlias
    //

    UNICODE_STRING TargetAlias;

    //
    // UNICODE_STRING form of Cred.UserName
    //

    UNICODE_STRING UserName;

    //
    // Describe the wildcard nature of this credential
    //
    WILDCARD_TYPE WildcardType;

    //
    // TargetName with the wildcard characters removed.
    //
    // The exact value is a function on WildcardType:
    //  WcDfsShareName: this is the 'server name' portion of the string
    //  WcServerWildcard: this is the 'server name' portion of the string preceeded by a .
    //  WcDomainWildcard: this is the 'domain name' portion of the string
    //  All Others: This is a copy of TargetName
    //
    // ??? I don't think we use it for WcDfsShare name any more.

    UNICODE_STRING NonWildcardedTargetName;

    //
    // Size (in bytes) of this structure and all of the pointed to strings.
    //

    ULONG AllocatedSize;

    //
    // True if credential is to be returned to the caller.
    //  Access serialized by UserCredentialSets->CritSect
    //

    BOOLEAN ReturnMe;


} CANONICAL_CREDENTIAL, *PCANONICAL_CREDENTIAL;


//
// Structure describing when a credential should be prompted for.
//
//  In general, this structure exists on a per-session basis for each credential that needs prompt
//  data to be stored.
//  In the future, this structure might contain other per-session/per-credential data.
//
typedef struct _PROMPT_DATA {

    //
    // Link to next entry in the list of PROMPT_DATA for this session.
    //  Access serialized by UserCredentialSets->CritSect
    //

    LIST_ENTRY Next;

    //
    // Target Name of the credential this prompt data is for.
    //

    UNICODE_STRING TargetName;

    //
    // Type of the credential this prompt data is for.
    //

    DWORD Type;

    //
    // Persistence of the credential this prompt data is for.
    //

    DWORD Persist;

    //
    // Boolean indicating if this credential was been written yet in this session.
    //

    BOOLEAN Written;

} PROMPT_DATA, *PPROMPT_DATA;

//
// Structure describing a canonical target info
//

typedef struct _CANONICAL_TARGET_INFO {

    UNICODE_STRING TargetName;
    UNICODE_STRING NetbiosServerName;
    UNICODE_STRING DnsServerName;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;
    UNICODE_STRING DnsTreeName;
    UNICODE_STRING PackageName;
    DWORD Flags;
    DWORD CredTypeCount;
    LPDWORD CredTypes;


//
// Define how a credential matches a target info.
//
// This list is ordered from most specific to least specific
//
#define CRED_DFS_SHARE_NAME         0
#define CRED_DNS_SERVER_NAME        1
#define CRED_NETBIOS_SERVER_NAME    2
#define CRED_TARGET_NAME            3
#define CRED_WILDCARD_SERVER_NAME   4
#define CRED_DNS_DOMAIN_NAME        5
#define CRED_NETBIOS_DOMAIN_NAME    6
#define CRED_UNIVERSAL_SESSION_NAME 7
#define CRED_UNIVERSAL_NAME         8
#define CRED_MAX_ALIASES            9


    //
    // Link into SessionCredSets->TargetInfoHashTable
    //

    LIST_ENTRY HashNext;

    //
    // Link into SessionCredSets->TargetInfoLruList
    //

    LIST_ENTRY LruNext;

} CANONICAL_TARGET_INFO, *PCANONICAL_TARGET_INFO;


//
// Structure describing an encryptable credential set
//
// This is the structure of a credential set as it appears on disk.
// It appears as a MARSHALED_CREDENTIAL_SET structure followed by a series of
// MARSHALED_CREDENTIAL structures.
//

typedef struct _MARSHALED_CREDENTIAL_SET {

    // Version of this structure
    ULONG Version;
#define MARSHALED_CREDENTIAL_SET_VERSION 1

    // Size in bytes of the entire credential set.
    ULONG Size;

} MARSHALED_CREDENTIAL_SET, *PMARSHALED_CREDENTIAL_SET;

typedef struct _MARSHALED_CREDENTIAL {

    //
    // Size in bytes of the entire credential (including variable length fields)
    //
    ULONG EntrySize;

    //
    // Fields from the CREDENTIALW structure
    //
    DWORD Flags;
    DWORD Type;
    FILETIME LastWritten;
    DWORD CredentialBlobSize;
    DWORD Persist;
    DWORD AttributeCount;
    DWORD Expansion1;       // This field is reserved for expansion
    DWORD Expansion2;       // This field is reserved for expansion

} MARSHALED_CREDENTIAL, *PMARSHALED_CREDENTIAL;



//
// Macro to pick a credential set for a particular peristance.
//

#define CREDENTIAL_FILE_NAME L"Credentials";
#define CRED_PERSIST_MIN CRED_PERSIST_SESSION
#define CRED_PERSIST_MAX CRED_PERSIST_ENTERPRISE

#define PersistToCredentialSet( _CredentialSets, _Persist ) \
    (((_Persist) == CRED_PERSIST_SESSION) ? \
        (_CredentialSets)->SessionCredSets->SessionCredSet : \
        (((_Persist) == CRED_PERSIST_LOCAL_MACHINE) ? \
            (_CredentialSets)->UserCredentialSets->LocalMachineCredSet : \
            (_CredentialSets)->UserCredentialSets->EnterpriseCredSet ) )

//
// Macro returns TRUE if the CredentialBlob is to be persisted
//
// Don't persist PINS passwords.  We entrust the PIN to the CSP.
//
#define PersistCredBlob( _Credential ) \
    ( (_Credential)->Type != CRED_TYPE_DOMAIN_CERTIFICATE )

//
// Macro returns TRUE if the credential is to be prompted for
//
// If there is no prompt data,
//      we've never prompted for this credential since logon.
// If there is prompt data,
//      we can rely on the boolean
//

#define ShouldPromptNow( _PromptData ) \
    ((_PromptData) == NULL || !(_PromptData)->Written )



//
// Globals
//
// List of USER_CREDENTIAL_SETS for each logged on user.

RTL_CRITICAL_SECTION CredentialSetListLock;
LIST_ENTRY CredentialSetList;

//
// Configurable values
//
#define CRED_TARGET_INFO_MAX_COUNT 1000;
ULONG CredTargetInfoMaxCount;
ULONG CredDisableDomainCreds;
ULONG CredIsPersonal;

//
// Define the default order for returning credentials from CredReadDomainCredentials
//

ULONG CredTypeDefaultOrder[] =
{
    CRED_TYPE_DOMAIN_CERTIFICATE,
    CRED_TYPE_DOMAIN_PASSWORD,
    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD
};

//
// Memory containing key for LSA protected memory.
//

PVOID CredLockedMemory = NULL;
ULONG CredLockedMemorySize = 0;

//
// DES-X keystate
//

DESXTable *g_pDESXKey = NULL;
unsigned __int64 g_Feedback;

//
// RC4 keystate
//

PBYTE g_pRandomKey = NULL;
ULONG g_cbRandomKey = 0;

//
// Forwards
//

NTSTATUS
CredpWriteCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN OUT PCANONICAL_CREDENTIAL *NewCredential,
    IN BOOLEAN FromPersistedFile,
    IN BOOLEAN WritePinToCsp,
    IN BOOLEAN PromptedFor,
    IN DWORD Flags,
    OUT PCANONICAL_CREDENTIAL *OldCredential OPTIONAL,
    OUT PPROMPT_DATA *OldPromptData OPTIONAL,
    OUT PPROMPT_DATA *NewPromptData OPTIONAL
    );


extern DWORD
DPAPINotifyPasswordChange(
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    );


VOID
LsaINotifyPasswordChanged(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING OldPassword OPTIONAL,
    IN PUNICODE_STRING NewPassword,
    IN BOOLEAN Impersonating
    )

/*++

Routine Description:

    This routine is a callback from the MSV authentication package following a password
    change.  This routine will update any password caches maintained in the LSA.


Arguments:

    NetbiosDomainName - Netbios domain name of the user whose password was changed
                        OPTIONAL if we're caching MIT realm credentials

    UserName - User name of the user whose password was changed

    DnsDomainName - If known, Dns Domain Name of the user whose password was changed

    Upn - If known, the Upn of the user whose password was changed

    OldPassword - If known, the previous password for the user.

    NewPassword - The new password for the user.

    Impersonating - If TRUE, this routine is called while impersonating the user changing
        the password.  That user isn't necessarily UserName.

Return Values:

    None

--*/
{

    //
    // Notify the credential manager of the change.
    //

    if ( Impersonating ) {
        CredpNotifyPasswordChange( NetbiosDomainName,
                                   UserName,
                                   DnsDomainName,
                                   Upn,
                                   NewPassword );
    }

    //
    // Notify DPAPI of the change.
    //

    if (ARGUMENT_PRESENT(NetbiosDomainName))  {

        DPAPINotifyPasswordChange( NetbiosDomainName,
                                   UserName,
                                   OldPassword,
                                   NewPassword);
    }
}


VOID
LsaEncryptMemory(
    PBYTE       pData,
    ULONG       cbData,
    int         Operation
    )
/*++

Routine Description:

    This routine encrypts the specified buffer in place with a key that exists until
    the next reboot.

    The purpose of the routine is to protect sensitive data that will be swapped
    to the page file.

Arguments:

    pData - Pointer to the data to encrypt

    cbData - Length (in bytes) of the data to encrypt

    Operation - ENCRYPT or DECRYPT

Return Values:

    None

--*/
{

    if( pData == NULL || cbData == 0 ) {
        return;
    }

    DsysAssert( ((DESX_BLOCKLEN % 8) == 0) );

    if( (cbData & (DESX_BLOCKLEN-1)) == 0 )
    {
        unsigned __int64 feedback;
        ULONG BlockCount;

        BlockCount = cbData / DESX_BLOCKLEN;
        feedback = g_Feedback;

        while( BlockCount-- )
        {
            CBC(
                desx,                       // desx is the cipher routine
                DESX_BLOCKLEN,
                pData,                      // result buffer.
                pData,                      // input buffer.
                g_pDESXKey,
                Operation,
                (unsigned char*)&feedback
                );

            pData += DESX_BLOCKLEN;
        }


    } else {
        RC4_KEYSTRUCT rc4key;

        rc4_key( &rc4key, g_cbRandomKey, g_pRandomKey );
        rc4( &rc4key, cbData, pData );

        RtlZeroMemory( &rc4key, sizeof(rc4key) );
    }

    return;
}



VOID
LsaProtectMemory(
    VOID        *pData,
    ULONG       cbData
    )
/*++

Routine Description:

    This routine encrypts the specified buffer in place with a key that exists until
    the next reboot.

    The purpose of the routine is to protect sensitive data that will be swapped
    to the page file.

Arguments:

    pData - Pointer to the data to encrypt

    cbData - Length (in bytes) of the data to encrypt

Return Values:

    None

--*/
{
    LsaEncryptMemory( (PBYTE)pData, cbData, ENCRYPT );
}


VOID
LsaUnprotectMemory(
    VOID        *pData,
    ULONG       cbData
    )
/*++

Routine Description:

    This routine decrypts the specified buffer in place with a key that exists until
    the next reboot.

    The purpose of the routine is to un protect sensitive data that was encrypted via
    LsaProtectMemory.

Arguments:

    pData - Pointer to the data to decrypt

    cbData - Length (in bytes) of the data to decrypt

Return Values:

    None

--*/
{
    LsaEncryptMemory( (PBYTE)pData, cbData, DECRYPT );
}

extern "C"
VOID
LsaCleanupProtectedMemory(
    VOID
    )
/*++

Routine Description:

    This routine cleans up the LsaProtectMemory subsystem

Arguments:

    None

Return Values:

    None

--*/
{
    if( CredLockedMemory ) {
        ZeroMemory( CredLockedMemory, CredLockedMemorySize );
        VirtualFree( CredLockedMemory, 0, MEM_RELEASE );
        CredLockedMemory = NULL;
    }
}

extern "C"
NTSTATUS
LsaInitializeProtectedMemory(
    VOID
    )
/*++

Routine Description:

    This routine initializes the LsaProtectMemory subsystem

Arguments:

    None

Return Values:

    Status of the operation

--*/
{
    NTSTATUS Status;
    //
    // Lock enough memory to contain the maximum size key the algorithm supports.
    //

    g_cbRandomKey = 256;

    CredLockedMemorySize = sizeof(DESXTable) + g_cbRandomKey;

    CredLockedMemory = VirtualAlloc(
                                    NULL,
                                    CredLockedMemorySize,
                                    MEM_COMMIT,
                                    PAGE_READWRITE );

    if ( CredLockedMemory == NULL ) {
        return I_RpcMapWin32Status( GetLastError() );
    }

    //
    // lock memory.
    //

    if (!VirtualLock( CredLockedMemory, CredLockedMemorySize )) {
        Status = I_RpcMapWin32Status( GetLastError() );
        goto Cleanup;
    }

    //
    // setup DESX key.
    //

    g_pDESXKey = (DESXTable*)CredLockedMemory;
    g_pRandomKey = (PBYTE)( (PBYTE)g_pDESXKey + sizeof(DESXTable) );

    if ( !RtlGenRandom( g_pRandomKey, DESX_KEYSIZE )) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    if ( !RtlGenRandom( (PUCHAR)&g_Feedback, sizeof(g_Feedback) )) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    desxkey( g_pDESXKey, g_pRandomKey );

    //
    // generate random key in page locked memory.
    //

    if ( !RtlGenRandom( g_pRandomKey, g_cbRandomKey )) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if(!NT_SUCCESS(Status))
    {
        LsaCleanupProtectedMemory();
    }

    return Status;
}



NTSTATUS
CredpInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the credential manager.  It is called once during LSA
    initialization.

Arguments:

    None.

Return Values:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    DWORD WinStatus;
    ULONG i;
    HKEY LsaKey;



    //
    // Initialize LSA memory protection subsystem
    //  (This initialization could have happened earlier, but the cred manager
    //  is its first client.)
    //
    Status = LsaInitializeProtectedMemory();

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // Initialize credential set globals.
    //
    Status = RtlInitializeCriticalSection( &CredentialSetListLock );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    InitializeListHead( &CredentialSetList );

    //
    // Domain creds are always disabled on personal
    //

    if ( LsapIsRunningOnPersonal() ) {

        CredIsPersonal = TRUE;

    }

    //
    // Initialize default values of configurable values.
    //
    CredTargetInfoMaxCount = CRED_TARGET_INFO_MAX_COUNT;
    CredDisableDomainCreds = FALSE;


    //
    // Grab registry settings.
    //


    WinStatus = RegOpenKeyExA(
                            HKEY_LOCAL_MACHINE,
                            "System\\CurrentControlSet\\Control\\Lsa",
                            0,
                            KEY_READ,
                            &LsaKey );

    if ( WinStatus == NO_ERROR ) {
        ULONG Value;
        ULONG Type;
        ULONG Size = sizeof(DWORD);

        //
        // Get the cache size
        //
        WinStatus = RegQueryValueExA(
                            LsaKey,
                            "TargetInfoCacheSize",
                            0,
                            &Type,
                            (PUCHAR) &Value,
                            &Size );

        if ( WinStatus == NO_ERROR ) {
            //
            // Don't allow ridiculously small values.
            //

            if ( Value == 0 ) {
                Value = 1;
            }
            CredTargetInfoMaxCount = Value;
        }

        //
        // Get whether domain creds are disabled
        //

        Size = sizeof(DWORD);

        WinStatus = RegQueryValueExA(
                            LsaKey,
                            "DisableDomainCreds",
                            0,
                            &Type,
                            (PUCHAR) &Value,
                            &Size );

        if ( WinStatus == NO_ERROR ) {
            CredDisableDomainCreds = Value;
        }

        RegCloseKey( LsaKey );
    }


    // ???: Don't check this in
    // SPMInfoLevel |= DEB_TRACE_CRED;

    return STATUS_SUCCESS;
}

DWORD
CredpHashIndexTargetInfo(
    IN LPWSTR TargetName
    )

/*++

Routine Description:

    This routine computes the hash index for a particular server.

Arguments:

    TargetName - Name of the server to compute the index for

Return Values:

    Hash index

--*/

{
    NTSTATUS Status;
    OEM_STRING UpcasedString;
    UNICODE_STRING NetbiosServerNameString;
    CHAR StringBuffer[CNLEN+1];
    ULONG i;
    DWORD Value = 0;

    WCHAR NetbiosServerNameBuffer[CNLEN+1];
    DWORD Size;

    //
    // Convert the name to a netbios name.
    //  (It might already be one.)
    //
    //  We want to make sure the queried name falls into the same hash bucket.
    //  So, no matter what form the input name is in, make the hash real generic.
    //

    Size = CNLEN+1;
    if ( DnsHostnameToComputerNameW( TargetName,
                                     NetbiosServerNameBuffer,
                                     &Size ) ) {

        TargetName = NetbiosServerNameBuffer;
    }

    //
    // Convert the server name to a canonical form
    //

    RtlInitUnicodeString( &NetbiosServerNameString, TargetName );
    UpcasedString.Buffer = StringBuffer;
    UpcasedString.MaximumLength = sizeof(StringBuffer);

    Status = RtlUpcaseUnicodeStringToOemString(
                        &UpcasedString,
                        &NetbiosServerNameString,
                        FALSE );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }

    for ( i=0; i<UpcasedString.Length; i++ ) {
        Value += UpcasedString.Buffer[i];
    }

    return (Value & (CRED_TARGET_INFO_HASH_TABLE_SIZE-1));

}


BOOLEAN
CredpCacheTargetInfo(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_TARGET_INFO TargetInfo
    )

/*++

Routine Description:

    This routine inserts the specified TargetInfo into the target info cache.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential sets.

    TargetInfo - Specifies the target info to insert.
        If this routine returns TRUE, the caller may no longer reference or free
        the passed in TargetInfo.

Return Values:

    TRUE: TargetInfo was inserted.
    FALSE: TargetInfo was not inserted.

--*/

{
    DWORD Index;
    PLIST_ENTRY ListEntry;
    PCANONICAL_TARGET_INFO ExistingTargetInfo;

    //
    // Require a target name name
    //

    if ( TargetInfo->TargetName.Length == 0 ) {
        return FALSE;
    }

    //
    // Compute the hash index
    //
    Index = CredpHashIndexTargetInfo( TargetInfo->TargetName.Buffer );

    //
    // Loop through the existing entries deleting any conflicting entry
    //

    for ( ListEntry = CredentialSets->SessionCredSets->TargetInfoHashTable[Index].Flink ;
          ListEntry != &CredentialSets->SessionCredSets->TargetInfoHashTable[Index];
          ListEntry = ListEntry->Flink) {

        ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, HashNext );


        //
        // If the target names don't match,
        //   neither do the entries.
        //
        if ( !RtlEqualUnicodeString( &TargetInfo->TargetName,
                                     &ExistingTargetInfo->TargetName,
                                     TRUE ) ) {
            continue;
        }


        //
        // Remove the existing entry
        //

        RemoveEntryList( &ExistingTargetInfo->HashNext );
        RemoveEntryList( &ExistingTargetInfo->LruNext );
        LsapFreeLsaHeap( ExistingTargetInfo );
        CredentialSets->SessionCredSets->TargetInfoCount --;
        break;

    }

    //
    // Link the new entry into the list
    //

    InsertHeadList( &CredentialSets->SessionCredSets->TargetInfoHashTable[Index], &TargetInfo->HashNext );
    InsertHeadList( &CredentialSets->SessionCredSets->TargetInfoLruList, &TargetInfo->LruNext );
    CredentialSets->SessionCredSets->TargetInfoCount ++;

    //
    // If we now have too many cache entries,
    //  ditch the oldest.
    //

    while ( CredentialSets->SessionCredSets->TargetInfoCount > CredTargetInfoMaxCount ) {

        ListEntry = RemoveTailList( &CredentialSets->SessionCredSets->TargetInfoLruList );

        ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, LruNext );

        RemoveEntryList( &ExistingTargetInfo->HashNext );
        LsapFreeLsaHeap( ExistingTargetInfo );
        CredentialSets->SessionCredSets->TargetInfoCount --;
    }

    return TRUE;
}


PCANONICAL_TARGET_INFO
CredpFindTargetInfo(
    IN PCREDENTIAL_SETS CredentialSets,
    IN LPWSTR TargetName
    )

/*++

Routine Description:

    This routine finds a cached TargetInfo for the named server.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential sets.

    TargetName - Specifies the server name to find the TargetInfo for

Return Values:

    Returns the requested TargetInfo.
    The returned structure can only be referenced while UserCredentialSets->CritSect remains locked.

    NULL - No such target info exists

--*/

{
    DWORD Index;
    PLIST_ENTRY ListEntry;
    PCANONICAL_TARGET_INFO ExistingTargetInfo = NULL;
    UNICODE_STRING TargetNameString;


    //
    // Compute the hash index
    //

    RtlInitUnicodeString( &TargetNameString, TargetName );
    Index = CredpHashIndexTargetInfo( TargetName );

    //
    // Loop through the entries finding this one.
    //

    for ( ListEntry = CredentialSets->SessionCredSets->TargetInfoHashTable[Index].Flink ;
          ListEntry != &CredentialSets->SessionCredSets->TargetInfoHashTable[Index];
          ListEntry = ListEntry->Flink) {

        ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, HashNext );

        if ( RtlEqualUnicodeString( &TargetNameString,
                                    &ExistingTargetInfo->TargetName,
                                    TRUE ) ) {

            break;
        }

        ExistingTargetInfo = NULL;
    }

    return ExistingTargetInfo;

}

PCREDENTIAL_SET
CredpAllocateCredSet(
    VOID
    )

/*++

Routine Description:

    Allocates and initializes a CREDENTIAL set

Arguments:

    None

Return Values:

    Returns the allocated credential set.
    The caller must dereference this credential set using CredpDereferenceCredSet.

    Return NULL if the memory cannot be allocated.

--*/

{
    PCREDENTIAL_SET TempCredentialSet;

    //
    // Allocate the credential set.
    //

    TempCredentialSet = (PCREDENTIAL_SET) LsapAllocateLsaHeap( sizeof(CREDENTIAL_SET) );

    if ( TempCredentialSet == NULL ) {
        return NULL;
    }

    //
    // Fill it in
    //

    TempCredentialSet->ReferenceCount = 1;
    InitializeListHead( &TempCredentialSet->Credentials );

    TempCredentialSet->Dirty = FALSE;
    TempCredentialSet->BeingWritten = FALSE;
    TempCredentialSet->WriteCount = 0;

    return TempCredentialSet;

}

NTSTATUS
CredpCreateCredSets(
    IN PSID UserSid,
    IN PUNICODE_STRING NetbiosDomainName,
    OUT PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    Create the credential sets for a user with the specified SID.

    If a credential set already exists for the specified user, the existing cred set is used.

Arguments:

    UserSid - User sid of the user to create a credential set for.

    NetbiosDomainName - Specifies the netbios domain name of the user to create the
        credential set for.

    CredentialSets - Returns a pointer the various credential sets.
        The caller must dereference this credential set using CredpDereferenceCredSets.

Return Values:

    The following status codes may be returned:

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    ULONG i;

    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD ComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    UNICODE_STRING ComputerNameString;

    //
    // Initialization
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    RtlZeroMemory( CredentialSets, sizeof(*CredentialSets) );

    //
    // Allocate a session specific credential structure
    //

    CredentialSets->SessionCredSets = (PSESSION_CREDENTIAL_SETS) LsapAllocateLsaHeap( sizeof(SESSION_CREDENTIAL_SETS) );

    if ( CredentialSets->SessionCredSets == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize it
    //

    CredentialSets->SessionCredSets->ReferenceCount = 1;
    for ( i=0; i<CRED_TARGET_INFO_HASH_TABLE_SIZE; i++ ) {
        InitializeListHead( &CredentialSets->SessionCredSets->TargetInfoHashTable[i] );
    }
    CredentialSets->SessionCredSets->TargetInfoCount = 0;
    InitializeListHead( &CredentialSets->SessionCredSets->TargetInfoLruList );
    InitializeListHead( &CredentialSets->SessionCredSets->PromptData );
    CredentialSets->SessionCredSets->ProfileLoaded = FALSE;

    //
    // Allocate a session credential set
    //

    CredentialSets->SessionCredSets->SessionCredSet = CredpAllocateCredSet();

    if ( CredentialSets->SessionCredSets->SessionCredSet == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Loop through the list of loaded user credential sets trying to find this one
    //

    for ( ListEntry = CredentialSetList.Flink ;
          ListEntry != &CredentialSetList;
          ListEntry = ListEntry->Flink) {

        CredentialSets->UserCredentialSets = CONTAINING_RECORD( ListEntry, USER_CREDENTIAL_SETS, Next );

        if ( RtlEqualSid( UserSid,
                          CredentialSets->UserCredentialSets->UserSid ) ) {
            CredentialSets->UserCredentialSets->ReferenceCount ++;
            break;
        }

        CredentialSets->UserCredentialSets = NULL;
    }

    //
    // If we didn't find one,
    //  allocate a new one.
    //

    if ( CredentialSets->UserCredentialSets == NULL ) {
        ULONG UserSidSize;
        LPBYTE Where;
        PUSER_CREDENTIAL_SETS TempUserCredentialSets;


        //
        // Allocate a user credential set
        //

        UserSidSize = RtlLengthSid( UserSid );

        TempUserCredentialSets = (PUSER_CREDENTIAL_SETS) LsapAllocateLsaHeap(
                    sizeof(USER_CREDENTIAL_SETS) + UserSidSize );

        if ( TempUserCredentialSets == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize constant fields
        //

        TempUserCredentialSets->ReferenceCount = 1;
        InitializeListHead( &TempUserCredentialSets->Next );
        TempUserCredentialSets->EnterpriseCredSet = NULL;
        TempUserCredentialSets->LocalMachineCredSet = NULL;

        Where = (LPBYTE)(TempUserCredentialSets+1);
        TempUserCredentialSets->UserSid = Where;
        RtlCopyMemory( Where, UserSid, UserSidSize );

        //
        // Initialize the crit sect
        //

        Status = RtlInitializeCriticalSection( &TempUserCredentialSets->CritSect );

        if ( !NT_SUCCESS(Status) ) {
            LsapFreeLsaHeap( TempUserCredentialSets );
            goto Cleanup;
        }

        //
        // We've initialized to the point that common cleanup can work.
        //

        CredentialSets->UserCredentialSets = TempUserCredentialSets;

        //
        // Allocate the credential sets that hang off this structure
        //

        TempUserCredentialSets->EnterpriseCredSet = CredpAllocateCredSet();

        if ( TempUserCredentialSets->EnterpriseCredSet == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        TempUserCredentialSets->LocalMachineCredSet = CredpAllocateCredSet();

        if ( TempUserCredentialSets->LocalMachineCredSet == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Insert the credential set into the global list.
        //
        // Being in the global list doesn't constitute a reference.
        //

        InsertHeadList( &CredentialSetList, &TempUserCredentialSets->Next );
    }

    //
    // Determine if the user is logging onto a local account
    //

    if ( !GetComputerName( ComputerName, &ComputerNameSize ) ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlInitUnicodeString( &ComputerNameString, ComputerName );

    if ( RtlEqualUnicodeString( NetbiosDomainName,
                                &ComputerNameString,
                                TRUE ) ) {

        CredentialSets->Flags |= CREDSETS_FLAGS_LOCAL_ACCOUNT;
    }


    Status = STATUS_SUCCESS;


Cleanup:
    if ( !NT_SUCCESS(Status) ) {
        CredpDereferenceCredSets( CredentialSets );
    }
    RtlLeaveCriticalSection( &CredentialSetListLock );

    return Status;

}


NTSTATUS
CredpReferenceCredSets(
    IN PLUID LogonId,
    OUT PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine references a credential sets for the specified LogonId.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredentialSet - Returns a pointer to the referenced credential set.
        The caller must dereference this credential set using CredpDereferenceCredSets.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;

    PLSAP_LOGON_SESSION LogonSession = NULL;

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    if ( LogonSession->CredentialSets.UserCredentialSets == NULL ) {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Grab a copy of the cred set pointers and reference them
    //

    RtlEnterCriticalSection( &CredentialSetListLock );
    *CredentialSets = LogonSession->CredentialSets;
    CredentialSets->UserCredentialSets->ReferenceCount ++;
    CredentialSets->SessionCredSets->ReferenceCount ++;
    RtlLeaveCriticalSection( &CredentialSetListLock );

    Status = STATUS_SUCCESS;


Cleanup:
    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return Status;

}

VOID
CredpDereferenceCredSet(
    IN PCREDENTIAL_SET CredentialSet
    )

/*++

Routine Description:

    This routine dereferences a credential set.

Arguments:

    CredentialSet - A pointer to the referenced credential set.

Return Values:

    None

--*/

{

    //
    // Dereference the credential set.
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    CredentialSet->ReferenceCount --;

    if ( CredentialSet->ReferenceCount == 0 ) {

        //
        // Uninitialize it
        //

        while ( !IsListEmpty( &CredentialSet->Credentials) ) {
            PLIST_ENTRY ListEntry;
            PCANONICAL_CREDENTIAL TempCredential;

            ListEntry = RemoveHeadList( &CredentialSet->Credentials );

            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            LsapFreeLsaHeap( TempCredential );
        }

        //
        // Free the entry.
        //

        LsapFreeLsaHeap( CredentialSet );

    }

    RtlLeaveCriticalSection( &CredentialSetListLock );

    return;
}

VOID
CredpDereferenceUserCredSets(
    IN PUSER_CREDENTIAL_SETS UserCredentialSets
    )

/*++

Routine Description:

    This routine dereferences a user credential set.

Arguments:

    UserCredentialSets - A pointer to the referenced user credential set.

Return Values:

    None

--*/

{

    //
    // Dereference the credential set.
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    UserCredentialSets->ReferenceCount --;

    if ( UserCredentialSets->ReferenceCount == 0 ) {

        //
        // Remove the entry from the global list.
        //

        RemoveEntryList( &UserCredentialSets->Next );


        //
        // Uninitialize it
        //

        if ( UserCredentialSets->EnterpriseCredSet != NULL ) {
            CredpDereferenceCredSet( UserCredentialSets->EnterpriseCredSet );
        }
        if ( UserCredentialSets->LocalMachineCredSet != NULL ) {
            CredpDereferenceCredSet( UserCredentialSets->LocalMachineCredSet );
        }

        (VOID) RtlDeleteCriticalSection( &UserCredentialSets->CritSect );


        //
        // Free the entry.
        //

        LsapFreeLsaHeap( UserCredentialSets );

    }

    RtlLeaveCriticalSection( &CredentialSetListLock );

    return;
}

VOID
CredpDereferenceSessionCredSets(
    IN PSESSION_CREDENTIAL_SETS SessionCredentialSets
    )

/*++

Routine Description:

    This routine dereferences a session credential set.

Arguments:

    SessionCredentialSets - A pointer to the referenced session credential set.

Return Values:

    None

--*/

{
    PLIST_ENTRY ListEntry;

    //
    // Dereference the credential set.
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    SessionCredentialSets->ReferenceCount --;

    if ( SessionCredentialSets->ReferenceCount == 0 ) {

        //
        // Uninitialize it
        //

        if ( SessionCredentialSets->SessionCredSet != NULL ) {
            CredpDereferenceCredSet( SessionCredentialSets->SessionCredSet );
        }

        //
        // Free Target Info Cache
        //

        while ( SessionCredentialSets->TargetInfoCount > 0 ) {
            PCANONICAL_TARGET_INFO ExistingTargetInfo;

            ListEntry = RemoveTailList( &SessionCredentialSets->TargetInfoLruList );

            ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, LruNext );

            RemoveEntryList( &ExistingTargetInfo->HashNext );
            LsapFreeLsaHeap( ExistingTargetInfo );
            SessionCredentialSets->TargetInfoCount --;
        }

        //
        // Free the prompt data
        //

        while ( !IsListEmpty( &SessionCredentialSets->PromptData ) ) {
            PPROMPT_DATA PromptData;

            ListEntry = RemoveHeadList( &SessionCredentialSets->PromptData );

            PromptData = CONTAINING_RECORD( ListEntry, PROMPT_DATA, Next );
            LsapFreeLsaHeap( PromptData );
        }


        //
        // Free the entry.
        //

        LsapFreeLsaHeap( SessionCredentialSets );

    }

    RtlLeaveCriticalSection( &CredentialSetListLock );

    return;
}

VOID
CredpDereferenceCredSets(
    IN PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine dereferences a set of credential sets.

Arguments:

    CredentialSets - A pointer to the referenced credential sets.

Return Values:

    None

--*/

{
    //
    // Dereference the User wide credential sets
    //

    if ( CredentialSets->UserCredentialSets != NULL ) {
        CredpDereferenceUserCredSets( CredentialSets->UserCredentialSets );
        CredentialSets->UserCredentialSets = NULL;
    }

    //
    // Dereference the session specific credential sets
    //

    if ( CredentialSets->SessionCredSets != NULL ) {
        CredpDereferenceSessionCredSets( CredentialSets->SessionCredSets );
        CredentialSets->SessionCredSets = NULL;
    }

}

BOOLEAN
CredpValidateBuffer(
    IN LPBYTE Buffer OPTIONAL,
    IN ULONG BufferSize,
    IN ULONG MaximumSize,
    IN BOOLEAN NullOk,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This routine validates a passed in Buffer

Arguments:

    Buffer - Buffer to validate

    BufferSize - Size of the buffer in bytes

    MaximumSize - Maximum size of the buffer (in bytes).

    NullOk - if TRUE, a NULL Buffer is OK.

    Alignment - Specifies the alignment requirements of the buffer size.

Return Values:

    TRUE - Buffer is valid.

    FALSE - Buffer is not valid.

--*/

{
    if ( Buffer == NULL ) {
        if ( BufferSize != 0 ) {
            return FALSE;
        }
        if ( !NullOk ) {
            return FALSE;
        }

        return TRUE;
    }

    if ( BufferSize == 0 ) {
        return FALSE;
    }

    if ( BufferSize > MaximumSize ) {
        return FALSE;
    }

    if ( BufferSize != ROUND_UP_COUNT(BufferSize, Alignment) ) {
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
CredpCompareCredToTargetInfo(
    IN PCANONICAL_TARGET_INFO TargetInfo,
    IN PCANONICAL_CREDENTIAL Credential,
    OUT PULONG AliasIndex
    )

/*++

Routine Description:

    This routine determines if the specified credential matches the
    specified target info.

Arguments:

    TargetInfo - A description of the various aliases for a target.

    Credential - Pointer to the credential to match.

    AliasIndex - On success, this parameter returns an index
        indicating which target alias matched the credential.

Return Values:

    TRUE if the credential matches the target info.

--*/

{
    ULONG Index;
    BOOLEAN DnsCompareFailed = FALSE;

    //
    // If the credential isn't a domain credential,
    //  it doesn't match;
    //

    if ( !CredpIsDomainCredential(Credential->Cred.Type) ) {
        return FALSE;
    }

    //
    // Make sure that UserNameTarget credentials only match
    //  UserNameTarget requests (and vice versa)
    //

    if ( Credential->WildcardType == WcUserName ) {
        if ( (TargetInfo->Flags & CRED_TI_USERNAME_TARGET) == 0 ) {
            return FALSE;
        }
    } else {
        if ( (TargetInfo->Flags & CRED_TI_USERNAME_TARGET) != 0 ) {
            return FALSE;
        }
    }

    //
    // If the target info specifies a list of valid cred types,
    //  only return a credential that matches the list.
    //

    if ( TargetInfo->CredTypeCount ) {
        ULONG i;

        for ( i=0; i<TargetInfo->CredTypeCount; i++ ) {

            if ( TargetInfo->CredTypes[i] == Credential->Cred.Type ) {
                break;
            }

        }

        //
        // If the cred doesn't match any of the valid cred types,
        //  ignore it.
        //
        if ( i == TargetInfo->CredTypeCount ) {
            return FALSE;
        }
    }


    //
    // Handle credentials that specify DFS share names
    //

    switch (Credential->WildcardType ) {
    case WcDfsShareName:

        //
        // Determine if the target info is for the named dfs share
        //

        if ( TargetInfo->TargetName.Length != 0 &&
             RtlEqualUnicodeString( &TargetInfo->TargetName,
                                    &Credential->TargetName,
                                    TRUE ) ) {

            *AliasIndex = CRED_DFS_SHARE_NAME;
            return TRUE;

        }

        break;

    //
    // Handle credentials that are for a specific server
    //
    case WcServerName:

        //
        // Compare the DNS server name
        //

        if ( TargetInfo->DnsServerName.Length != 0 ) {

            //
            // Do an exact comparison.
            //
            //  ??? NonWildcardedTargetName should probably be TargetName
            if ( RtlEqualUnicodeString( &TargetInfo->DnsServerName,
                                        &Credential->NonWildcardedTargetName,
                                        TRUE ) ) {

                *AliasIndex = CRED_DNS_SERVER_NAME;
                return TRUE;
            }

            DnsCompareFailed = TRUE;

            //
            // If a netbios alias is specified,
            //  and we don't know the format of the target info name,
            //  compare it.
            //

            if ( Credential->TargetAlias.Length != 0 &&
                 (TargetInfo->Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) != 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->DnsServerName,
                                            &Credential->TargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_SERVER_NAME;
                    return TRUE;
                }
            }
        }

        //
        // Compare the netbios server name
        //

        if ( TargetInfo->NetbiosServerName.Length != 0 ) {

            //
            // If no alias is specified,
            //  the TargetName might be the netbios name.
            //

            if ( Credential->TargetAlias.Length == 0 ) {

            //  ??? NonWildcardedTargetName should probably be TargetName
                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosServerName,
                                            &Credential->NonWildcardedTargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_SERVER_NAME;
                    return TRUE;
                }

            //
            // If an alias is specified,
            //  it is always the netbios name.
            //
            // (Don't compare the alias if the more specific comparision failed.)
            //

            } else if ( !DnsCompareFailed ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosServerName,
                                            &Credential->TargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_SERVER_NAME;
                    return TRUE;
                }
            }

        }

        //
        // Compare the target name if it is different than the Netbios or DNS name already compared
        //
        if ( Credential->WildcardType == WcServerName ) {

            if ( TargetInfo->TargetName.Length != 0 &&
                 !RtlEqualUnicodeString( &TargetInfo->TargetName,
                                         &TargetInfo->DnsServerName,
                                         TRUE ) &&
                 !RtlEqualUnicodeString( &TargetInfo->TargetName,
                                         &TargetInfo->NetbiosServerName,
                                         TRUE ) ) {

                //
                // The TargetName might be the netbios name or DNS name
                //

                if ( RtlEqualUnicodeString( &TargetInfo->TargetName,
                                            &Credential->TargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_TARGET_NAME;
                    return TRUE;
                }

                if ( RtlEqualUnicodeString( &TargetInfo->TargetName,
                                            &Credential->TargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_TARGET_NAME;
                    return TRUE;
                }

            }

        }
        break;

    //
    // Handle the server wildcard case
    //
    // If the TargetName is of the form *.xxx.yyy,
    //  compare equal if the DnsServerName ends in .xxx.yyy.
    //
    // The comparision includes the . to ensure *.xxx.yyy doesn't match
    //  fredxxx.yyy
    //

    case WcServerWildcard:

        //
        // Compare the DNS server name
        //

        if ( TargetInfo->DnsServerName.Length != 0 ) {

            UNICODE_STRING LocalTargetName = Credential->NonWildcardedTargetName;
            UNICODE_STRING LocalServerName = TargetInfo->DnsServerName;

            //
            // Build a server name without the leading characters
            //

            if ( LocalTargetName.Length < LocalServerName.Length ) {
                DWORD TrimAmount = LocalServerName.Length - LocalTargetName.Length;

                LocalServerName.Length = LocalTargetName.Length;
                LocalServerName.MaximumLength = LocalTargetName.Length;
                LocalServerName.Buffer += TrimAmount/sizeof(WCHAR);

                //
                // Compare the names
                //

                if ( RtlEqualUnicodeString( &LocalServerName,
                                            &LocalTargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_WILDCARD_SERVER_NAME;
                    return TRUE;
                }
            }
        }

        break;

    //
    // Handle the domain wildcard case.
    //
    // If the target names is of the form <Domain>\*,
    //  compare equal if Netbios or Dns domain name is <Domain>
    //

    case WcDomainWildcard: {
        UNICODE_STRING LocalTargetName;
        UNICODE_STRING LocalTargetAlias;

        //
        // Build a target name without the \*
        //

        LocalTargetName = Credential->NonWildcardedTargetName;

        LocalTargetAlias = Credential->TargetAlias;
        if ( LocalTargetAlias.Length > 2 * sizeof(WCHAR) &&
             LocalTargetAlias.Buffer[(LocalTargetAlias.Length/sizeof(WCHAR))-1] == L'*' &&
             LocalTargetAlias.Buffer[(LocalTargetAlias.Length/sizeof(WCHAR))-2] == L'\\' ) {

            LocalTargetAlias.Length -= 2 * sizeof(WCHAR);
        }


        //
        // Compare the DNS domain name
        //

        if ( TargetInfo->DnsDomainName.Length != 0 ) {


            if ( RtlEqualUnicodeString( &TargetInfo->DnsDomainName,
                                        &LocalTargetName,
                                        TRUE ) ) {

                *AliasIndex = CRED_DNS_DOMAIN_NAME;
                return TRUE;

            }

            DnsCompareFailed = TRUE;

            //
            // If a netbios alias is specified,
            //  and we don't know the format of the target info name,
            //  compare it.
            //

            if ( LocalTargetAlias.Length != 0 &&
                 (TargetInfo->Flags & CRED_TI_DOMAIN_FORMAT_UNKNOWN) != 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->DnsDomainName,
                                            &LocalTargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_DOMAIN_NAME;
                    return TRUE;
                }
            }

        }

        //
        // Compare the netbios domain name
        //

        if ( TargetInfo->NetbiosDomainName.Length != 0 ) {

            //
            // If no alias is specified,
            //  the TargetName might be the netbios name.
            //

            if ( LocalTargetAlias.Length == 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosDomainName,
                                            &LocalTargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_DOMAIN_NAME;
                    return TRUE;
                }

            //
            // If an alias is specified,
            //  it is always the netbios name.
            //
            // (Don't compare the alias if the more specific comparision failed.)
            //

            } else if ( !DnsCompareFailed ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosDomainName,
                                            &LocalTargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_DOMAIN_NAME;
                    return TRUE;
                }
            }
        }

        break;
    }

    //
    // Handle the * wildcard case.
    //

    case WcUniversalWildcard:

        *AliasIndex = CRED_UNIVERSAL_NAME;
        return TRUE;

    //
    // Handle the * wildcard case.
    //

    case WcUniversalSessionWildcard:

        *AliasIndex = CRED_UNIVERSAL_SESSION_NAME;
        return TRUE;

    //
    // Handles creds that have a user name as the target name
    //

    case WcUserName:

        //
        // Determine if the target info is for this username
        //

        if ( TargetInfo->TargetName.Length != 0 &&
             RtlEqualUnicodeString( &TargetInfo->TargetName,
                                    &Credential->TargetName,
                                    TRUE ) ) {

            *AliasIndex = CRED_TARGET_NAME;
            return TRUE;

        }

        break;

    //
    // Catch coding errors
    //
    default:
        ASSERT( FALSE );
        break;
    }


    return FALSE;
}


NTSTATUS
CredpLogonCredsMatchTargetInfo(
    IN PLUID LogonId,
    IN PCANONICAL_TARGET_INFO TargetInfo
    )

/*++

Routine Description:

    This routine determines if the specified credential matches the
    specified target info.

Arguments:

    LogonId - LogonId of the session to check

    TargetInfo - A description of the various aliases for a target.

Return Values:

    STATUS_SUCCESS - Logon creds match target info
    STATUS_NO_MATCH - Logon creds don't match target info
    Otherwise, fatal error

--*/

{
    NTSTATUS Status;
    PLSAP_LOGON_SESSION LogonSession = NULL;
    ULONG AliasIndex;
    CANONICAL_CREDENTIAL CanonicalCredential;
    LPWSTR DottedDnsDomainName = NULL;
    PLSAP_DS_NAME_MAP DnsDomainMap = NULL;

    //
    // If the target machine is a member of a workgroup,
    //  never use the *Session cred.

    if ( TargetInfo->Flags & CRED_TI_WORKGROUP_MEMBER ) {
        DebugLog((DEB_TRACE_CRED,
                 "*Session: %wZ: not used on workgroup member.\n",
                 &TargetInfo->TargetName ));
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Get the DnsDomainName for the logon session.  Do not go
    // off-machine if it's not in the cache.
    //

    Status = LsapGetNameForLogonSession(
                        LogonSession,
                        NameDnsDomain,
                        &DnsDomainMap,
                        TRUE );

    if ( !NT_SUCCESS(Status) ) {
        DnsDomainMap = NULL;
    } else {
        if ( DnsDomainMap->Name.Length == 0 ) {
            LsapDerefDsNameMap( DnsDomainMap );
            DnsDomainMap = NULL;
        }
    }


    //
    // Check if a *.<DnsDomainName> credential matches the target info
    //

    if ( DnsDomainMap != NULL ) {

        //
        // Clear the cred
        //

        RtlZeroMemory( &CanonicalCredential, sizeof(CanonicalCredential) );
        CanonicalCredential.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
        CanonicalCredential.WildcardType = WcServerWildcard;

        //
        // Allocate space on the stack
        //

        SafeAllocaAllocate( DottedDnsDomainName,
                            DnsDomainMap->Name.Length + (3*sizeof(WCHAR)) );

        if ( DottedDnsDomainName == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Build *.<DnsDomainName>
        //

        RtlCopyMemory( DottedDnsDomainName,
                       L"*.",
                       2*sizeof(WCHAR) );

        RtlCopyMemory( DottedDnsDomainName+2,
                       DnsDomainMap->Name.Buffer,
                       DnsDomainMap->Name.Length );

        DottedDnsDomainName[(DnsDomainMap->Name.Length/sizeof(WCHAR))+2] = L'\0';

        //
        // Fill in the Canonical cred
        //

        RtlInitUnicodeString( &CanonicalCredential.TargetName, DottedDnsDomainName );

        CanonicalCredential.NonWildcardedTargetName.Buffer =
            CanonicalCredential.TargetName.Buffer + 1;
        CanonicalCredential.NonWildcardedTargetName.Length =
            CanonicalCredential.TargetName.Length - sizeof(WCHAR);
        CanonicalCredential.NonWildcardedTargetName.MaximumLength =
            CanonicalCredential.TargetName.MaximumLength - sizeof(WCHAR);


        //
        // See if the cred matches the target info
        //

        if ( CredpCompareCredToTargetInfo(
                    TargetInfo,
                    &CanonicalCredential,
                    &AliasIndex ) ) {

            DebugLog((DEB_TRACE_CRED,
                     "*Session: %wZ: %ws: not used on wildcard server match.\n",
                     &TargetInfo->TargetName,
                     DottedDnsDomainName ));

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

    }

    //
    // Check if a <DomainName>\* credential matches the target info
    //

    if ( LogonSession->AuthorityName.Length != 0 ) {

        //
        // Clear the cred
        //

        RtlZeroMemory( &CanonicalCredential, sizeof(CanonicalCredential) );
        CanonicalCredential.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
        CanonicalCredential.WildcardType = WcDomainWildcard;

        //
        // If there is a DNS domain name too,
        //  build a cred with an alias
        //

        if ( DnsDomainMap != NULL ) {

            //
            // The primary target name is the DNS domain name
            //

            CanonicalCredential.NonWildcardedTargetName = DnsDomainMap->Name;

            //
            // The alias is the netbios domain name
            //

            CanonicalCredential.TargetAlias = LogonSession->AuthorityName;


        //
        // If there is no DNS domain name,
        //  just use the netbios domain name.
        //

        } else {
            CanonicalCredential.NonWildcardedTargetName = LogonSession->AuthorityName;

        }


        //
        // See if the cred matches the target info
        //

        if ( CredpCompareCredToTargetInfo(
                    TargetInfo,
                    &CanonicalCredential,
                    &AliasIndex ) ) {

            DebugLog((DEB_TRACE_CRED,
                     "*Session: %wZ: %wZ: not used on wildcard domain match.\n",
                     &TargetInfo->TargetName,
                     &CanonicalCredential.NonWildcardedTargetName ));

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

    }


    Status = STATUS_NO_MATCH;


Cleanup:
    if ( DnsDomainMap != NULL ) {
        LsapDerefDsNameMap( DnsDomainMap );
    }

    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    if ( DottedDnsDomainName != NULL ) {
        SafeAllocaFree( DottedDnsDomainName );
    }

    return Status;
}


NTSTATUS
CredpValidateCredential(
    IN ULONG CredFlags,
    IN PCANONICAL_TARGET_INFO TargetInfo OPTIONAL,
    IN PENCRYPTED_CREDENTIALW EncryptedInputCredential,
    OUT PCANONICAL_CREDENTIAL *ValidatedCredential
    )

/*++

Routine Description:

    This routine validates a passed in credential structure.  It returns
    a canonicalized version of the credential.

Arguments:

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.
            If set, CredentialBlob data is passed in protected via LsapProtectMemory.
        CREDP_FLAGS_CLEAR_PASSWORD - CredentialBlob data is passed in in the clear.
            If neither set, CredentialBlob data is passed in protected via CredpEncodeCredential.

    TargetInfo - Validated Target information that further describes the
        target of the credential.

    EncryptedInputCredential - Specifies the credential to validate.

    ValidatedCredential - Returns a pointer to the canonicalized credential.
        The caller should free this structure by calling LsapFreeLsaHeap.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARMETER - The input credential is not valid.

--*/

{
    NTSTATUS Status;
    DWORD WinStatus;
    PCREDENTIALW InputCredential;
    PCANONICAL_CREDENTIAL ReturnCredential = NULL;
    ULONG TempSize;

    ULONG TargetNameSize;
    ULONG TempTargetNameSize;
    UNICODE_STRING NonWildcardedTargetName;
    ULONG CommentSize;

    ULONG TargetAliasSize;
    LPWSTR TargetAlias;
    LPWSTR AllocatedTargetAlias = NULL;

    ULONG UserNameSize;
    LPWSTR UserName;
    LPWSTR AllocatedUserName = NULL;

    ULONG CredBlobSizeToAlloc;

    ULONG VariableAttributeSize;
    ULONG AllocatedSize;
    WILDCARD_TYPE WildcardType;
    TARGET_NAME_TYPE TargetNameType;

    LPBYTE Where;
    LPBYTE OldWhere;

    ULONG i;

    //
    // Initialization
    //

    RtlInitUnicodeString( &NonWildcardedTargetName, NULL );

    //
    // Validate the pointer itself.
    //

    if ( EncryptedInputCredential == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: credential NULL\n" ));
        goto Cleanup;
    }
    InputCredential = &EncryptedInputCredential->Cred;

    //
    // Validate flags
    //  (Flags may indicate presence of other fields.)
    //

    if ( (InputCredential->Flags & ~CRED_FLAGS_VALID_FLAGS) != 0 ) {
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid flags: 0x%lx\n", InputCredential->TargetName, InputCredential->Flags ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    InputCredential->Flags &= ~CRED_FLAGS_PROMPT_NOW;   // Ignore "prompt now" bit on input


    //
    // Ensure flags are consistent with type.
    //
    if ( InputCredential->Flags & CRED_FLAGS_USERNAME_TARGET ) {

        if ( !CredpIsDomainCredential(InputCredential->Type ) ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: UsernameTarget flag for non domain credentrial: 0x%ld\n", InputCredential->TargetName, InputCredential->Type ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TargetNameType = IsUsernameTarget;
    } else {
        TargetNameType = IsNotUsernameTarget;
    }

    //
    // Validate the Target Name
    //

    Status = CredpValidateTargetName( InputCredential->TargetName,
                                      InputCredential->Type,
                                      TargetNameType,
                                      &InputCredential->UserName,
                                      &InputCredential->Persist,
                                      &TargetNameSize,
                                      &WildcardType,
                                      &NonWildcardedTargetName );

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }


    //
    // Validate the contained strings.
    //

    if ( !CredpValidateString( InputCredential->Comment, CRED_MAX_STRING_LENGTH, TRUE, &CommentSize ) ||
         !CredpValidateString( InputCredential->TargetAlias, CRED_MAX_STRING_LENGTH, TRUE, &TargetAliasSize ) ||
         !CredpValidateString( InputCredential->UserName, CRED_MAX_USERNAME_LENGTH, TRUE, &UserNameSize ) ) {

        DebugLog(( DEB_TRACE_CRED,
                   "ValidateCredential: %ws: Invalid Comment or TargetAlias or UserName\n",
                   InputCredential->TargetName ));

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    TargetAlias = InputCredential->TargetAlias;
    UserName = InputCredential->UserName;

    //
    // Validate the credential blob.
    //  The passed in blob size must be the clear text size or the encrypted text size.
    //

    CredBlobSizeToAlloc = AllocatedCredBlobSize( EncryptedInputCredential->ClearCredentialBlobSize );

    if ( CredFlags & CREDP_FLAGS_CLEAR_PASSWORD ) {
        if ( InputCredential->CredentialBlobSize != EncryptedInputCredential->ClearCredentialBlobSize ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Bad clear cred blob size %ld %ld\n",
                                      InputCredential->TargetName,
                                      InputCredential->CredentialBlobSize,
                                      EncryptedInputCredential->ClearCredentialBlobSize ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    } else {
        if ( InputCredential->CredentialBlobSize != CredBlobSizeToAlloc ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Bad encrypted cred blob size %ld %ld\n",
                                      InputCredential->TargetName,
                                      InputCredential->CredentialBlobSize,
                                      CredBlobSizeToAlloc ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


    if ( !CredpValidateBuffer( InputCredential->CredentialBlob,
                               EncryptedInputCredential->ClearCredentialBlobSize,
                               CRED_MAX_CREDENTIAL_BLOB_SIZE,
                               TRUE,
                               InputCredential->Type == CRED_TYPE_GENERIC ?
                                    ALIGN_BYTE :
                                    ALIGN_WCHAR ) ) {

        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid credential blob\n", InputCredential->TargetName ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the attribute list.
    //  Ensure RPC passed us sane information.
    //

    if ( InputCredential->AttributeCount != 0 &&
         InputCredential->Attributes == NULL ) {
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid attribute buffer\n", InputCredential->TargetName ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure there aren't too many attributes
    //

    if ( InputCredential->AttributeCount > CRED_MAX_ATTRIBUTES ) {
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Too many attributes %ld\n", InputCredential->TargetName, InputCredential->AttributeCount ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate each attribute.
    //

    VariableAttributeSize = 0;
    for ( i=0; i<InputCredential->AttributeCount; i++ ) {
        if ( !CredpValidateString( InputCredential->Attributes[i].Keyword,
                                  CRED_MAX_STRING_LENGTH,
                                  FALSE,
                                  &TempSize ) ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid attribute keyword buffer: %ld\n", InputCredential->TargetName, i ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        VariableAttributeSize += TempSize;

        if ( !CredpValidateBuffer( InputCredential->Attributes[i].Value,
                                   InputCredential->Attributes[i].ValueSize,
                                   CRED_MAX_VALUE_SIZE,
                                   TRUE,
                                   ALIGN_BYTE ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateCredential: %ws: %ws: Invalid attribute value buffer: %ld\n",
                       InputCredential->TargetName,
                       InputCredential->Attributes[i].Keyword,
                       i ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        VariableAttributeSize += InputCredential->Attributes[i].ValueSize;
    }

    //
    // Validate the credential type
    //
    // Handle generic credentials
    //

    if ( InputCredential->Type == CRED_TYPE_GENERIC ) {
        /* Drop through */


    //
    // Handle domain credentials
    //
    } else if ( CredpIsDomainCredential(InputCredential->Type) ) {

        LPWSTR RealTargetAlias; // TargetAlias sans wildcard chars
        ULONG RealTargetAliasLength;


        //
        //
        // Domain credentials have a specific Username format
        //

        Status = CredpValidateUserName( UserName, InputCredential->Type, &AllocatedUserName );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        // Recompute since CredpValidateUserName canonicalized the name
        UserName = AllocatedUserName;
        UserNameSize = (wcslen( AllocatedUserName ) + 1) * sizeof(WCHAR);



        //
        // Handle where the target alias is specified,
        //

        RealTargetAlias = TargetAlias;
        RealTargetAliasLength = (TargetAliasSize-sizeof(WCHAR))/sizeof(WCHAR);
        if ( TargetAlias != NULL ) {

            //
            // Process alias as a function of Wildcard Type
            //

            switch ( WildcardType ) {
            case WcServerName:
                /* Nothing to do here */
                break;
            case WcDfsShareName:
            case WcServerWildcard:
            case WcUniversalWildcard:
            case WcUniversalSessionWildcard:
            case WcUserName:
                //
                // Server credentials of the form *.xxx.yyy aren't allowed with TargetAliases
                // Otherwise a wildcarded DNS name would have a non-wildcarded netbios name.

                Status = STATUS_INVALID_PARAMETER;
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateCredential: %ws: TargetAlias not allowed for server wildcard credential.\n",
                           InputCredential->TargetName ));
                goto Cleanup;

            case WcDomainWildcard:
                //
                // If the TargetName is a domain wildcard, so must the TargetAlias
                //

                if ( RealTargetAliasLength > 2 &&
                     RealTargetAlias[RealTargetAliasLength-1] == L'*' &&
                     RealTargetAlias[RealTargetAliasLength-2] == L'\\' ) {

                    //
                    // Allocate a buffer for the target alias so we don't have to modify the
                    //  callers buffer.
                    //

                    SafeAllocaAllocate( AllocatedTargetAlias, TargetAliasSize );

                    if ( AllocatedTargetAlias == NULL ) {
                        Status = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    RtlCopyMemory( AllocatedTargetAlias, RealTargetAlias, TargetAliasSize );
                    RealTargetAlias = AllocatedTargetAlias;
                    RealTargetAliasLength -= 2;
                    RealTargetAlias[RealTargetAliasLength] = '\0';
                } else {

                    Status = STATUS_INVALID_PARAMETER;
                    DebugLog(( DEB_TRACE_CRED,
                               "ValidateCredential: %ws: %ws: TargetAlias must be wildcard if TargetName is.\n",
                               InputCredential->TargetName,
                               TargetAlias ));
                    goto Cleanup;
                }



                break;
            }

            //
            //  The target alias must be a netbios name.
            //
            if ( !NetpIsDomainNameValid( RealTargetAlias ) ) {
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateCredential: %ws: TargetAlias '%ws' must be a netbios name.\n",
                           InputCredential->TargetName,
                           TargetAlias ));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // The target name must be a DNS name
            //
            if ( !CredpValidateDnsString( NonWildcardedTargetName.Buffer,
                                          FALSE,
                                          DnsNameDomain,
                                          &TempTargetNameSize ) ) {
                Status = STATUS_INVALID_PARAMETER;
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateCredential: %ws: TargetName for domain or server must be a DNS name if target alias specified.\n",
                           InputCredential->TargetName ));
                goto Cleanup;
            }


        }

    } else {
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateCredential: %ws: Type %ld not valid\n",
                   InputCredential->TargetName,
                   InputCredential->Type ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the persistence.
    //

    switch ( InputCredential->Persist ) {
    case CRED_PERSIST_SESSION:
    case CRED_PERSIST_LOCAL_MACHINE:
    case CRED_PERSIST_ENTERPRISE:
        break;
    default:
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateCredential: %ws: Invalid persistance: %ld.\n",
                   InputCredential->TargetName,
                   InputCredential->Persist ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Allocate a buffer for the canonicalized credential.
    //

    AllocatedSize = (ULONG)(ROUND_UP_COUNT( sizeof(CANONICAL_CREDENTIAL), ALIGN_WORST) +
                    TargetNameSize +
                    (NonWildcardedTargetName.Buffer == NULL ?
                        0 :
                        NonWildcardedTargetName.MaximumLength ) +
                    CommentSize +
                    ROUND_UP_COUNT( CredBlobSizeToAlloc, ALIGN_WORST) +
                    InputCredential->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTE) +
                    VariableAttributeSize +
                    TargetAliasSize +
                    UserNameSize);

    ReturnCredential = (PCANONICAL_CREDENTIAL) LsapAllocateLsaHeap( AllocatedSize );


    if ( ReturnCredential == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    OldWhere = (PUCHAR)(ReturnCredential+1);
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    ReturnCredential->AllocatedSize = AllocatedSize;
    ReturnCredential->WildcardType = WildcardType;

    //
    // Copy the fixed size data
    //

    ReturnCredential->Cred.Flags = InputCredential->Flags;
    ReturnCredential->Cred.Type = InputCredential->Type;
    ReturnCredential->Cred.Persist = InputCredential->Persist;
    ReturnCredential->Cred.LastWritten = InputCredential->LastWritten;

    RtlZeroMemory( &ReturnCredential->Next, sizeof(ReturnCredential->Next) );

    //
    // Copy the 8-byte aligned data.
    //  (We don't know the format of the credential blob, but our in-process callers
    //  may have alignment requirements.)
    //

    if ( EncryptedInputCredential->ClearCredentialBlobSize != 0 ) {

        //
        // Put the credential blob in the buffer.
        //
        ReturnCredential->Cred.CredentialBlob = Where;
        ReturnCredential->Cred.CredentialBlobSize = InputCredential->CredentialBlobSize;
        ReturnCredential->ClearCredentialBlobSize = EncryptedInputCredential->ClearCredentialBlobSize;
        RtlCopyMemory( Where, InputCredential->CredentialBlob, InputCredential->CredentialBlobSize );
        Where += InputCredential->CredentialBlobSize;


        //
        // Align the running pointer again
        //
        OldWhere = Where;
        // Always leave an extra trailing byte for encrypting the buffer in place
        Where += CredBlobSizeToAlloc - InputCredential->CredentialBlobSize;
        Where = (PUCHAR) ROUND_UP_POINTER( Where, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        //
        // If the blob isn't encrypted correctly for the cache,
        //  convert it.
        //

        if ( (CredFlags & CREDP_FLAGS_IN_PROCESS) == 0 ) {

            //
            // Only decode data if it is there
            //

            if ( ReturnCredential->Cred.CredentialBlobSize != 0 ) {
                ULONG PaddingSize;


                //
                // If the password isn't already in the clear,
                //  convert it to the clear.
                //
                if ( (CredFlags & CREDP_FLAGS_CLEAR_PASSWORD) == 0 ) {

                    // Ensure we can cast between the types
                    ASSERT( offsetof( _ENCRYPTED_CREDENTIALW, Cred) == offsetof( _CANONICAL_CREDENTIAL, Cred));
                    ASSERT( offsetof( _ENCRYPTED_CREDENTIALW, ClearCredentialBlobSize) == offsetof( _CANONICAL_CREDENTIAL, ClearCredentialBlobSize));

                    if ( !CredpDecodeCredential( (PENCRYPTED_CREDENTIALW)ReturnCredential ) ) {
                        DebugLog(( DEB_TRACE_CRED,
                                   "ValidateCredential: %ws: Cannot decode cred blob\n",
                                   InputCredential->TargetName ));
                        Status = STATUS_INVALID_PARAMETER;
                        goto Cleanup;
                    }

                }

                //
                // Obfuscate the sensitive data
                //  A large enough space was already pushed above.
                //

                ReturnCredential->Cred.CredentialBlobSize = CredBlobSizeToAlloc;

                // Clear the padding at the end to ensure we can compare encrypted blobs
                PaddingSize = CredBlobSizeToAlloc -
                              ReturnCredential->ClearCredentialBlobSize;

                if ( PaddingSize != 0 ) {
                    RtlZeroMemory( &ReturnCredential->Cred.CredentialBlob[ReturnCredential->ClearCredentialBlobSize],
                                   PaddingSize );
                }

                LsaProtectMemory( ReturnCredential->Cred.CredentialBlob,
                                  ReturnCredential->Cred.CredentialBlobSize );
            }
        }

    }


    //
    // Copy the 4 byte aligned data
    //

    ReturnCredential->Cred.AttributeCount = InputCredential->AttributeCount;
    if ( InputCredential->AttributeCount != 0 ) {
        ReturnCredential->Cred.Attributes = (PCREDENTIAL_ATTRIBUTEW) Where;
        Where += ReturnCredential->Cred.AttributeCount * sizeof(CREDENTIAL_ATTRIBUTE);
    } else {
        ReturnCredential->Cred.Attributes = NULL;
    }


    //
    // Copy the 2 byte aligned data
    //

    ReturnCredential->Cred.TargetName = (LPWSTR) Where;
    RtlCopyMemory( Where, InputCredential->TargetName, TargetNameSize );
    Where += TargetNameSize;
    ReturnCredential->TargetName.Buffer = ReturnCredential->Cred.TargetName;
    ReturnCredential->TargetName.MaximumLength = (USHORT)TargetNameSize;
    ReturnCredential->TargetName.Length = ReturnCredential->TargetName.MaximumLength - sizeof(WCHAR);

    if ( NonWildcardedTargetName.Buffer != NULL ) {
        ReturnCredential->NonWildcardedTargetName.Buffer = (LPWSTR)Where;

        RtlCopyMemory( Where, NonWildcardedTargetName.Buffer, NonWildcardedTargetName.MaximumLength );
        Where += NonWildcardedTargetName.MaximumLength;

        ReturnCredential->NonWildcardedTargetName.MaximumLength = NonWildcardedTargetName.MaximumLength;
        ReturnCredential->NonWildcardedTargetName.Length = NonWildcardedTargetName.Length;
    } else {
        ReturnCredential->NonWildcardedTargetName = ReturnCredential->TargetName;
    }

    if ( CommentSize != 0 ) {
        ReturnCredential->Cred.Comment = (LPWSTR) Where;
        RtlCopyMemory( Where, InputCredential->Comment, CommentSize );
        Where += CommentSize;
    } else {
        ReturnCredential->Cred.Comment = NULL;
    }

    if ( TargetAliasSize != 0 ) {
        ReturnCredential->Cred.TargetAlias = (LPWSTR) Where;
        RtlCopyMemory( Where, TargetAlias, TargetAliasSize );
        Where += TargetAliasSize;

        ReturnCredential->TargetAlias.Buffer = ReturnCredential->Cred.TargetAlias;
        ReturnCredential->TargetAlias.MaximumLength = (USHORT)TargetAliasSize;
        ReturnCredential->TargetAlias.Length = ReturnCredential->TargetAlias.MaximumLength - sizeof(WCHAR);
    } else {
        ReturnCredential->Cred.TargetAlias = NULL;
        RtlInitUnicodeString( &ReturnCredential->TargetAlias, NULL );
    }

    if ( UserNameSize != 0 ) {
        ReturnCredential->Cred.UserName = (LPWSTR) Where;
        RtlCopyMemory( Where, UserName, UserNameSize );
        Where += UserNameSize;
        ReturnCredential->UserName.Buffer = ReturnCredential->Cred.UserName;
        ReturnCredential->UserName.MaximumLength = (USHORT)UserNameSize;
        ReturnCredential->UserName.Length = ReturnCredential->UserName.MaximumLength - sizeof(WCHAR);
    } else {
        ReturnCredential->Cred.UserName = NULL;
        RtlInitUnicodeString( &ReturnCredential->UserName, NULL );
    }

    for ( i=0; i<InputCredential->AttributeCount; i++ ) {
        TempSize = (wcslen( InputCredential->Attributes[i].Keyword ) + 1) * sizeof(WCHAR);
        ReturnCredential->Cred.Attributes[i].Keyword = (LPWSTR) Where;
        RtlCopyMemory( Where, InputCredential->Attributes[i].Keyword, TempSize );
        Where += TempSize;

        ReturnCredential->Cred.Attributes[i].Flags = InputCredential->Attributes[i].Flags;
    }


    //
    // Copy the 1 byte aligned data
    //

    for ( i=0; i<InputCredential->AttributeCount; i++ ) {

        if ( InputCredential->Attributes[i].ValueSize != 0 ) {
            ReturnCredential->Cred.Attributes[i].ValueSize =
                InputCredential->Attributes[i].ValueSize;
            ReturnCredential->Cred.Attributes[i].Value = Where;
            RtlCopyMemory( Where,
                           InputCredential->Attributes[i].Value,
                           InputCredential->Attributes[i].ValueSize );
            Where += InputCredential->Attributes[i].ValueSize;
        } else {
            ReturnCredential->Cred.Attributes[i].ValueSize = 0;
            ReturnCredential->Cred.Attributes[i].Value = NULL;
        }

        ReturnCredential->Cred.Attributes[i].Flags = InputCredential->Attributes[i].Flags;
    }


    //
    // If we have target information,
    //  use it to do an extra validation.
    //

    if ( TargetInfo != NULL ) {
        ULONG AliasIndex;

        if (!CredpCompareCredToTargetInfo( TargetInfo, ReturnCredential, &AliasIndex ) ) {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateCredential: %ws: TargetInfo doesn't match credential.\n",
                       InputCredential->TargetName ));
            goto Cleanup;
        }
    }



    //
    // Return the credential to the caller.
    //
    *ValidatedCredential = ReturnCredential;
    ReturnCredential = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    if ( ReturnCredential != NULL ) {
        LsapFreeLsaHeap( ReturnCredential );
    }
    if ( NonWildcardedTargetName.Buffer != NULL ) {
        LsapFreeLsaHeap( NonWildcardedTargetName.Buffer );
    }
    if ( AllocatedTargetAlias != NULL ) {
        SafeAllocaFree( AllocatedTargetAlias );
    }
    if ( AllocatedUserName != NULL ) {
        MIDL_user_free( AllocatedUserName );
    }

    return Status;

}

BOOLEAN
CredpValidateNames(
    IN OUT PCREDENTIAL_TARGET_INFORMATION InputTargetInfo,
    IN BOOLEAN DoServer,
    OUT PULONG NetbiosNameSize,
    OUT PULONG DnsNameSize
    )

/*++

Routine Description:

    This routine validates the server names (or domain names) in a target info structure.
    It handles the CRED_TI_*_FORMAT_UNKNOWN bit.  If specified, the routine ensures only the
    "dns" field of the name is specified.  Also, the specified name is syntax checked.
    If the specified name only matches one of the name formats, the "FORMAT_UNKNOWN" bit is
    turned off and the appropriate name is set in InputTargetInfo

Arguments:

    InputTargetInfo - Specifies the target info to validate.
        On return, the Flags and name fields my be updated to reflect the true name formats.

    DoServer - If TRUE the server names are validated.
        If FALSE, the domain names are validated.

    NetbiosNameSize - Returns the size in bytes of the netbios name

    DnsNameSize - Returns the size in bytes of the DNS name

Return Values:

    FALSE - if the names are invalid.

--*/
{
    DWORD FlagBit;
    LPWSTR *NetbiosNamePtr;
    LPWSTR *DnsNamePtr;
    DNS_NAME_FORMAT DnsNameFormat;

    //
    // Set up some locals identifying whether we're doing the server or domain.
    //

    if ( DoServer ) {
        FlagBit = CRED_TI_SERVER_FORMAT_UNKNOWN;
        NetbiosNamePtr = &InputTargetInfo->NetbiosServerName;
        DnsNamePtr = &InputTargetInfo->DnsServerName;
        DnsNameFormat = DnsNameHostnameFull;
    } else {
        FlagBit = CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        NetbiosNamePtr = &InputTargetInfo->NetbiosDomainName;
        DnsNamePtr = &InputTargetInfo->DnsDomainName;
        DnsNameFormat = DnsNameDomain;
    }


    //
    // If the format unknown bit is set,
    //  try to determine the formation.
    //

    if ( InputTargetInfo->Flags & FlagBit ) {

        BOOLEAN IsNetbios;
        BOOLEAN IsDns;
        ULONG LocalNetbiosNameSize;
        ULONG LocalDnsNameSize;

        //
        // Caller must pass the unknown name as the DNS name
        //

        if ( *NetbiosNamePtr != NULL) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateNames: Netbios name must be null.\n" ));
            return FALSE;
        }

        //
        // Determine the syntax of the passed in name.
        //

        IsNetbios = CredpValidateString( *DnsNamePtr, CNLEN, FALSE, &LocalNetbiosNameSize );
        IsDns = CredpValidateDnsString( *DnsNamePtr, FALSE, DnsNameFormat, &LocalDnsNameSize );

        //
        // If the name simply isn't valid,
        //  we're done.
        //

        if ( !IsNetbios && !IsDns ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateNames: Invalid DNS Buffer: %ws (may not be fatal).\n",
                       *DnsNamePtr ));
            return FALSE;

        //
        // If the name is only a valid DNS name
        //  use it as such
        //

        } else if ( !IsNetbios && IsDns ) {

            // Turn off the bit since the name is not ambiguous.
            InputTargetInfo->Flags &= ~FlagBit;

            *NetbiosNameSize = 0;
            *DnsNameSize = LocalDnsNameSize;

        //
        // If the name is only a valid netbios name
        //  use it as such
        //

        } else if ( IsNetbios && !IsDns ) {

            // Turn off the bit since the name is not ambiguous.
            InputTargetInfo->Flags &= ~FlagBit;

            *NetbiosNameSize = LocalNetbiosNameSize;
            *NetbiosNamePtr = *DnsNamePtr;

            *DnsNamePtr = NULL;
            *DnsNameSize = 0;


        //
        // If the name is valid for both formats,
        //  leave it ambiguous
        //

        } else {

            *NetbiosNameSize = 0;
            *DnsNameSize = LocalDnsNameSize;
        }






    } else {
        if ( !CredpValidateString( *NetbiosNamePtr, CNLEN, TRUE, NetbiosNameSize ) ||
             !CredpValidateDnsString( *DnsNamePtr, TRUE, DnsNameFormat, DnsNameSize ) ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateNames: Invalid Buffer.\n" ));
            return FALSE;
        }
    }

    return TRUE;
}

NTSTATUS
CredpValidateTargetInfo(
    IN PCREDENTIAL_TARGET_INFORMATION InputTargetInfo,
    OUT PCANONICAL_TARGET_INFO *ValidatedTargetInfo
    )

/*++

Routine Description:

    This routine validates a passed in target info structure.  It returns
    a canonicalized version of the target info.

    All DNS names have the trailing . stripped.

Arguments:

    InputTargetInfo - Specifies the target info to validate.

    ValidatedTargetInfo - Returns a pointer to the canonicalized target info.
        The caller should free this structure by calling LsapFreeLsaHeap.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARMETER - The input target info is not valid.

--*/

{
    NTSTATUS Status;
    PCANONICAL_TARGET_INFO ReturnTargetInfo = NULL;
    ULONG TempSize;

    // Local copy of InputTargetInfo that this routine can modify.
    CREDENTIAL_TARGET_INFORMATION LocalTargetInfo;

    ULONG TargetNameSize;

    ULONG NetbiosServerNameSize;
    WCHAR NetbiosServerName[CNLEN+1];

    ULONG DnsServerNameSize;
    ULONG NetbiosDomainNameSize;
    ULONG DnsDomainNameSize;
    ULONG DnsTreeNameSize;
    ULONG PackageNameSize;
    ULONG CredTypeSize;
    ULONG AllocatedSize;

    BOOLEAN FictitiousServerName = FALSE;


    LPBYTE Where;
    LPBYTE OldWhere;

    ULONG i;

    //
    // Validate the pointer itself.
    //

    if ( InputTargetInfo == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: TargetInfo NULL.\n" ));
        goto Cleanup;
    }

    //
    // Validate Flags
    //

    LocalTargetInfo = *InputTargetInfo;
    if ( (LocalTargetInfo.Flags & ~CRED_TI_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: Invalid flags 0x%lx.\n",
                   LocalTargetInfo.Flags ));
        goto Cleanup;

    }

    //
    // All share level machines are workgroup members
    //

    if ( LocalTargetInfo.Flags & CRED_TI_ONLY_PASSWORD_REQUIRED ) {
        LocalTargetInfo.Flags |= CRED_TI_WORKGROUP_MEMBER;
    }


    //
    // Validate the contained strings.
    //

    if ( !CredpValidateString( LocalTargetInfo.TargetName, CRED_MAX_DOMAIN_TARGET_NAME_LENGTH, TRUE, &TargetNameSize ) ||
         !CredpValidateDnsString( LocalTargetInfo.DnsTreeName, TRUE, DnsNameDomain, &DnsTreeNameSize ) ||
         !CredpValidateString( LocalTargetInfo.PackageName, CRED_MAX_STRING_LENGTH, TRUE, &PackageNameSize ) ) {

        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: Invalid Buffer.\n" ));
        goto Cleanup;
    }

    //
    // Supply a server name if none is present.
    //
    // pre-NTLM-V2 servers don't supply a server name in the negotiate response.  NTLM supplies
    // the TargetName from the SPN.  In that case, the TargetName makes a better server name than
    // none at all.
    //

    if ( (LocalTargetInfo.NetbiosServerName == NULL || *(LocalTargetInfo.NetbiosServerName) == L'\0') &&
         (LocalTargetInfo.DnsServerName == NULL || *(LocalTargetInfo.DnsServerName) == L'\0') &&
         TargetNameSize != 0 ) {

        LocalTargetInfo.DnsServerName = LocalTargetInfo.TargetName;
        LocalTargetInfo.Flags |= CRED_TI_SERVER_FORMAT_UNKNOWN;
        FictitiousServerName = TRUE;

    }

    //
    // Validate the server and domain names.
    //

    if ( !CredpValidateNames( &LocalTargetInfo, TRUE, &NetbiosServerNameSize, &DnsServerNameSize ) ) {

        //
        // Don't bail out if we made up the server name
        //

        if ( FictitiousServerName ) {
            LocalTargetInfo.DnsServerName = NULL;
            LocalTargetInfo.Flags &= ~CRED_TI_SERVER_FORMAT_UNKNOWN;
            FictitiousServerName = FALSE;
            NetbiosServerNameSize = 0;
            DnsServerNameSize = 0;

        } else {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateTargetInfo: Invalid server buffer.\n" ));
            goto Cleanup;
        }
    }
    if ( !CredpValidateNames( &LocalTargetInfo, FALSE, &NetbiosDomainNameSize, &DnsDomainNameSize ) ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: Invalid domain buffer.\n" ));
        goto Cleanup;
    }

    //
    // Validate the attribute list.
    //  Ensure RPC passed us sane information.
    //

    if ( LocalTargetInfo.CredTypeCount != 0 &&
         LocalTargetInfo.CredTypes == NULL ) {
        DebugLog((DEB_TRACE_CRED, "ValidateTargetInfo: Invalid cred type buffer.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the cred types
    //

    for ( i=0; i<LocalTargetInfo.CredTypeCount; i ++ ) {
        switch ( LocalTargetInfo.CredTypes[i] ) {
        case CRED_TYPE_GENERIC:
        case CRED_TYPE_DOMAIN_PASSWORD:
        case CRED_TYPE_DOMAIN_CERTIFICATE:
        case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
            break;
        default:
            DebugLog((DEB_TRACE_CRED, "ValidateTargetInfo: Invalid cred type %ld %ld.\n", i, LocalTargetInfo.CredTypes[i] ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    CredTypeSize = LocalTargetInfo.CredTypeCount * sizeof(DWORD);

    //
    // Supply a netbios server name if none is present and DNS server name is known.
    //

    if ( NetbiosServerNameSize == 0 &&
         DnsServerNameSize != 0 &&
         (LocalTargetInfo.Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) == 0 ) {

        DWORD Size = CNLEN+1;

        if ( !DnsHostnameToComputerNameW( LocalTargetInfo.DnsServerName,
                                          NetbiosServerName,
                                          &Size ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateTargetInfo: Cannot DnsHostNameToComputerName: %ld.\n",
                       GetLastError() ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        LocalTargetInfo.NetbiosServerName = NetbiosServerName;
        NetbiosServerNameSize = (Size + 1) * sizeof(WCHAR);
    }


    //
    // Supply a target name if none is present.
    //
    // NTLM authentication to Unix servers return target info.  However, the callers of SSPI
    // don't supply an SPN.  NTLM builds the TargetName from the SPN.
    //

    if ( TargetNameSize == 0 ) {

        //
        // If there's a DNS server name,
        //  use it.
        //

        if ( DnsServerNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.DnsServerName;
            TargetNameSize = DnsServerNameSize;

        //
        // If there's a netbios server name,
        //  use it.

        } else if ( NetbiosServerNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.NetbiosServerName;
            TargetNameSize = NetbiosServerNameSize;

        //
        // If there's a DNS Domain name,
        //  use it.
        //

        } else if ( DnsDomainNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.DnsDomainName;
            TargetNameSize = DnsDomainNameSize;

        //
        // If there's a netbios Domain name,
        //  use it.

        } else if ( NetbiosDomainNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.NetbiosDomainName;
            TargetNameSize = NetbiosDomainNameSize;

        //
        // If there's a DNS tree name,
        //  use it.
        //

        } else if ( DnsTreeNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.DnsTreeName;
            TargetNameSize = DnsTreeNameSize;
        }

    }

    //
    // Canonicalize the target info.
    //
    // There are several cases where authentication packages are sent invalid target info.
    // This section clears up those cases.
    //

    if ( NetbiosServerNameSize != 0 ) {
        UNICODE_STRING NetbiosServerNameString;

        NetbiosServerNameString.Buffer = LocalTargetInfo.NetbiosServerName;
        NetbiosServerNameString.MaximumLength = (USHORT) NetbiosServerNameSize;
        NetbiosServerNameString.Length = NetbiosServerNameString.MaximumLength - sizeof(WCHAR);

        //
        // Machines that are a member of a workgroup indicate that their NetbiosDomainName
        //  equals their NetbiosServerName.
        //  Instead, indicate workgroup membership by the lack of a NetbiosDomainName.
        //

        if ( NetbiosDomainNameSize != 0 ) {
            UNICODE_STRING NetbiosDomainNameString;

            NetbiosDomainNameString.Buffer = LocalTargetInfo.NetbiosDomainName;
            NetbiosDomainNameString.MaximumLength = (USHORT) NetbiosDomainNameSize;
            NetbiosDomainNameString.Length = NetbiosDomainNameString.MaximumLength - sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &NetbiosServerNameString,
                                        &NetbiosDomainNameString,
                                        TRUE ) ) {
                NetbiosDomainNameSize = 0;
                LocalTargetInfo.Flags |= CRED_TI_WORKGROUP_MEMBER;
            }
        }

        //
        // Machines that are a member of an NT 4 domain indicate that their DnsDomainName
        //  equals their NetbiosServerName.
        //  Instead, zap the DnsDomainName.
        //

        if ( DnsDomainNameSize != 0 ) {
            UNICODE_STRING DnsDomainNameString;

            DnsDomainNameString.Buffer = LocalTargetInfo.DnsDomainName;
            DnsDomainNameString.MaximumLength = (USHORT) DnsDomainNameSize;
            DnsDomainNameString.Length = DnsDomainNameString.MaximumLength - sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &NetbiosServerNameString,
                                        &DnsDomainNameString,
                                        TRUE ) ) {
                DnsDomainNameSize = 0;
            }
        }

        //
        // Some machines in a workgroup also return the DnsDomainName set to the DnsServerName.
        //  Instead, zap the DnsDomainName.

        if ( DnsDomainNameSize != 0 && DnsServerNameSize != 0 ) {
            UNICODE_STRING DnsServerNameString;
            UNICODE_STRING DnsDomainNameString;

            DnsServerNameString.Buffer = LocalTargetInfo.DnsServerName;
            DnsServerNameString.MaximumLength = (USHORT) DnsServerNameSize;
            DnsServerNameString.Length = DnsServerNameString.MaximumLength - sizeof(WCHAR);


            DnsDomainNameString.Buffer = LocalTargetInfo.DnsDomainName;
            DnsDomainNameString.MaximumLength = (USHORT) DnsDomainNameSize;
            DnsDomainNameString.Length = DnsDomainNameString.MaximumLength - sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &DnsServerNameString,
                                        &DnsDomainNameString,
                                        TRUE ) ) {
                DnsDomainNameSize = 0;
            }
        }


    }


    //
    // Allocate a buffer for the canonicalized TargetInfo.
    //

    AllocatedSize = sizeof(CANONICAL_TARGET_INFO) +
                    TargetNameSize +
                    NetbiosServerNameSize +
                    DnsServerNameSize +
                    NetbiosDomainNameSize +
                    DnsDomainNameSize +
                    DnsTreeNameSize +
                    PackageNameSize +
                    CredTypeSize;

    ReturnTargetInfo = (PCANONICAL_TARGET_INFO) LsapAllocateLsaHeap( AllocatedSize );


    if ( ReturnTargetInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Where = (PUCHAR)(ReturnTargetInfo+1);

    //
    // Copy fixed size data
    //

    ReturnTargetInfo->Flags = LocalTargetInfo.Flags;

    //
    // Copy the DWORD aligned data
    //

    ReturnTargetInfo->CredTypeCount = LocalTargetInfo.CredTypeCount;
    if ( ReturnTargetInfo->CredTypeCount != 0 ) {

        ReturnTargetInfo->CredTypes = (LPDWORD)Where;
        RtlCopyMemory( Where, LocalTargetInfo.CredTypes, CredTypeSize );
        Where += CredTypeSize;

    } else {
        ReturnTargetInfo->CredTypes = NULL;
    }


    //
    // Copy the 2 byte aligned data
    //

    if ( TargetNameSize != 0 ) {
        ReturnTargetInfo->TargetName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->TargetName.MaximumLength = (USHORT) TargetNameSize;
        ReturnTargetInfo->TargetName.Length = (USHORT)(ReturnTargetInfo->TargetName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.TargetName, TargetNameSize );
        Where += TargetNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->TargetName, NULL );
    }

    if ( NetbiosServerNameSize != 0 ) {
        ReturnTargetInfo->NetbiosServerName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->NetbiosServerName.MaximumLength = (USHORT) NetbiosServerNameSize;
        ReturnTargetInfo->NetbiosServerName.Length = (USHORT)(ReturnTargetInfo->NetbiosServerName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.NetbiosServerName, NetbiosServerNameSize );
        Where += NetbiosServerNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->NetbiosServerName, NULL );
    }

    if ( DnsServerNameSize != 0 ) {
        ReturnTargetInfo->DnsServerName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->DnsServerName.MaximumLength = (USHORT) DnsServerNameSize;
        ReturnTargetInfo->DnsServerName.Length = (USHORT)(ReturnTargetInfo->DnsServerName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.DnsServerName, DnsServerNameSize );
        Where += DnsServerNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->DnsServerName, NULL );
    }

    if ( NetbiosDomainNameSize != 0 ) {
        ReturnTargetInfo->NetbiosDomainName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->NetbiosDomainName.MaximumLength = (USHORT)(NetbiosDomainNameSize);
        ReturnTargetInfo->NetbiosDomainName.Length = (USHORT)(ReturnTargetInfo->NetbiosDomainName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.NetbiosDomainName, NetbiosDomainNameSize );
        Where += NetbiosDomainNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->NetbiosDomainName, NULL );
    }

    if ( DnsDomainNameSize != 0 ) {
        ReturnTargetInfo->DnsDomainName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->DnsDomainName.MaximumLength = (USHORT)(DnsDomainNameSize);
        ReturnTargetInfo->DnsDomainName.Length = (USHORT)(ReturnTargetInfo->DnsDomainName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.DnsDomainName, DnsDomainNameSize );
        Where += DnsDomainNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->DnsDomainName, NULL );
    }

    if ( DnsTreeNameSize != 0 ) {
        ReturnTargetInfo->DnsTreeName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->DnsTreeName.MaximumLength = (USHORT)(DnsTreeNameSize);
        ReturnTargetInfo->DnsTreeName.Length = (USHORT)(ReturnTargetInfo->DnsTreeName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.DnsTreeName, DnsTreeNameSize );
        Where += DnsTreeNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->DnsTreeName, NULL );
    }

    if ( PackageNameSize != 0 ) {
        ReturnTargetInfo->PackageName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->PackageName.MaximumLength = (USHORT)(PackageNameSize);
        ReturnTargetInfo->PackageName.Length = (USHORT)(ReturnTargetInfo->PackageName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.PackageName, PackageNameSize );
        Where += PackageNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->PackageName, NULL );
    }




    //
    // Return the TargetInfo to the caller.
    //
    *ValidatedTargetInfo = ReturnTargetInfo;
    ReturnTargetInfo = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    if ( ReturnTargetInfo != NULL ) {
        LsapFreeLsaHeap( ReturnTargetInfo );

    }

    return Status;

}


PPROMPT_DATA
CredpFindPromptData(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PUNICODE_STRING TargetName,
    IN ULONG Type,
    IN ULONG Persist
    )

/*++

Routine Description:

    This routine finds a the prompt data for a credential in a credential set.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSet - Credential set list to find the credential in.

    TargetName - Name of the credential whose prompt data is to be found.

    Type - Type of the credential whose prompt data is to be found.

    Persist - Peristence of the credential whose prompt data is to be found.

Return Values:

    Returns a pointer to the prompt data.  This pointer my be used as long as
    UserCredentialSets->CritSect remains locked.

    NULL: There is no such credential or there is no prompt data for the credential.

--*/
{
    PPROMPT_DATA PromptData;
    PLIST_ENTRY ListEntry;

    //
    // Loop through the list of prompt data trying to find this one.
    //

    for ( ListEntry = CredentialSets->SessionCredSets->PromptData.Flink ;
          ListEntry != &CredentialSets->SessionCredSets->PromptData;
          ListEntry = ListEntry->Flink) {

        PromptData = CONTAINING_RECORD( ListEntry, PROMPT_DATA, Next );

        if ( Type == PromptData->Type &&
             Persist == PromptData->Persist &&
             RtlEqualUnicodeString( TargetName,
                                    &PromptData->TargetName,
                                    TRUE ) ) {
            return PromptData;
        }

    }

    return NULL;
}


PPROMPT_DATA
CredpAllocatePromptData(
    IN PCANONICAL_CREDENTIAL Credential
    )

/*++

Routine Description:

    This routine allocates a prompt data structure that corresponds to the passed in
    credential.

Arguments:

    Credential - Specifies the credential to allocate the prompt data structure for.

Return Values:

    Returns a pointer to the prompt data.
    The buffer should be freed via LsapFreeLsaHeap.

    NULL: Memory could not be allocated.

--*/
{
    PPROMPT_DATA PromptData;
    LPBYTE Where;

    //
    // Allocate the PromptData structure.
    //

    PromptData = (PPROMPT_DATA) LsapAllocateLsaHeap(
                        sizeof(PROMPT_DATA) +
                        Credential->TargetName.Length );

    if ( PromptData == NULL ) {
        return NULL;
    }

    Where = (LPBYTE)(PromptData+1);

    //
    // Fill it in
    //

    PromptData->Type = Credential->Cred.Type;
    PromptData->Persist = Credential->Cred.Persist;
    PromptData->Written = FALSE;

    PromptData->TargetName.Buffer = (LPWSTR)Where;
    PromptData->TargetName.Length = Credential->TargetName.Length;
    PromptData->TargetName.MaximumLength = Credential->TargetName.Length;

    RtlCopyMemory( Where,
                   Credential->TargetName.Buffer,
                   PromptData->TargetName.Length );

    return PromptData;
}


PENCRYPTED_CREDENTIALW
CredpCloneCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG CredFlags,
    IN PCANONICAL_CREDENTIAL InputCredential
    )

/*++

Routine Description:

    This routine creates a credential suitable for returning out of the
    credential manager.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced redential sets the cloned credential is in.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned
        CREDP_FLAGS_USE_MIDL_HEAP - If specified, use MIDL_user_allocate to allocate memory.

    InputCredential - Specifies the credential to clone

Return Values:

    Credential to return.
    The returned credential may container pointers.  All pointer are to addresses within
    the returned allocated block.

    The caller should free this memory using LsapFreeLsaHeap.
    If CREDP_FLAGS_USE_MIDL_HEAP was specified, use MIDL_user_free.


    NULL: Memory could not be allocated


--*/

{
    PCREDENTIAL Credential;
    PENCRYPTED_CREDENTIALW EncryptedCredential;
    DWORD_PTR Offset;
    ULONG i;

    //
    // Allocate memory for the returned credential
    //

    if ( CredFlags & CREDP_FLAGS_USE_MIDL_HEAP ) {
        Credential = (PCREDENTIALW) MIDL_user_allocate( InputCredential->AllocatedSize );
    } else {
        Credential = (PCREDENTIALW) LsapAllocateLsaHeap( InputCredential->AllocatedSize );
    }

    if ( Credential == NULL ) {
        return NULL;
    }

    EncryptedCredential = (PENCRYPTED_CREDENTIALW) Credential;

    //
    // Copy the credential
    //  Note that the "fixed size" part of the structure copied below is copying a
    //  CANONICAL_CREDENTIAL to a ENCRYPTED_CREDENTIALW.  We rely on the following
    //  asserted conditions.
    //
    ASSERT( sizeof(ENCRYPTED_CREDENTIALW) <= sizeof(CANONICAL_CREDENTIAL) );
    ASSERT( offsetof( _ENCRYPTED_CREDENTIALW, Cred) == 0 );
    ASSERT( offsetof( _CANONICAL_CREDENTIAL, Cred) == 0 );

    RtlCopyMemory( Credential, InputCredential, InputCredential->AllocatedSize );

    //
    // Grab the clear text size of the blob
    //

    EncryptedCredential->ClearCredentialBlobSize = InputCredential->ClearCredentialBlobSize;
    ASSERT( InputCredential->ClearCredentialBlobSize <= InputCredential->Cred.CredentialBlobSize );


    //
    // Relocate any pointers
    //
#define RELOCATE_ONE( _x, _type ) if ( _x != NULL ) { _x = (_type) ((LPBYTE)(_x) + Offset); }

    Offset = ((LPBYTE)Credential) - ((LPBYTE)InputCredential);

    RELOCATE_ONE( Credential->TargetName, LPWSTR );
    RELOCATE_ONE( Credential->Comment, LPWSTR );

    RELOCATE_ONE( Credential->CredentialBlob, LPBYTE );

    RELOCATE_ONE( Credential->Attributes, PCREDENTIAL_ATTRIBUTEW );
    for ( i=0; i<Credential->AttributeCount; i++ ) {
        RELOCATE_ONE( Credential->Attributes[i].Keyword, LPWSTR );
        RELOCATE_ONE( Credential->Attributes[i].Value, LPBYTE );
    }

    RELOCATE_ONE( Credential->TargetAlias, LPWSTR );
    RELOCATE_ONE( Credential->UserName, LPWSTR );
#undef RELOCATE_ONE

    //
    // If we're leaving the process,
    //  handle the private data.
    //

    if ( (CredFlags & CREDP_FLAGS_IN_PROCESS) == 0 ) {

        //
        // Domain passwords or cert pins never leave the process
        //
        // "Visible Password" is for user mode implementation auth package implementations.
        // So allow "Visible Password" credentials out of process.
        //

        if ( Credential->Type != CRED_TYPE_GENERIC &&
             Credential->Type != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {

            if ( Credential->CredentialBlob != NULL &&
                 Credential->CredentialBlobSize != 0 ) {

                RtlZeroMemory( Credential->CredentialBlob, Credential->CredentialBlobSize );
                Credential->CredentialBlob = NULL;
                Credential->CredentialBlobSize = 0;
                EncryptedCredential->ClearCredentialBlobSize = 0;

            }

        //
        // Other credentials should be protected for transit on the wire.
        //
        } else {

            //
            // Only encode data if it is there
            //

            if ( Credential->CredentialBlobSize != 0 ) {

                //
                // First unprotect the memory
                //

                LsaUnprotectMemory( Credential->CredentialBlob,
                                    Credential->CredentialBlobSize );


                //
                // Encrypt for transit on the wire (always LPC)
                //

                if ( !CredpEncodeCredential( EncryptedCredential )) {

                    // Clear the possibly clear password
                    RtlZeroMemory( Credential->CredentialBlob, Credential->CredentialBlobSize );

                    if ( CredFlags & CREDP_FLAGS_USE_MIDL_HEAP ) {
                        MIDL_user_free( Credential );
                    } else {
                        LsapFreeLsaHeap( Credential );
                    }
                    return NULL;
                }

            }

        }

    }

    //
    // Return the PromptNow bit if the credential hasn't been refreshed recently.
    //

    Credential->Flags &= ~CRED_FLAGS_PROMPT_NOW;

    if ( !PersistCredBlob( Credential ) ) {
        PPROMPT_DATA PromptData;

        //
        // Get the prompt data for this credential
        //

        PromptData = CredpFindPromptData( CredentialSets,
                                          &InputCredential->TargetName,
                                          Credential->Type,
                                          Credential->Persist );

        //
        // If we've never prompted for this credential since logon,
        //  Prompt now
        //

        if ( ShouldPromptNow( PromptData )) {
            Credential->Flags |= CRED_FLAGS_PROMPT_NOW;
        }
    }


    return EncryptedCredential;

}


BOOLEAN
CredpMarshalCredentials(
    IN PCREDENTIAL_SET CredentialSet,
    OUT LPDWORD BufferSize,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    This routine grabs all of the credentials from a Credential Set and
    marshals them into a single buffer.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSet - Credential set containing the credentials to marshal

    BufferSize - Returns the size of the marshaled credentials
        Returns zero if there are no credentials.

    Buffer - Returns a buffer containing the marshaled credentials
        The buffer must be freed using LsapFreeLsaHeap.

Return Values:

    TRUE - Buffer was sucessfully marshaled

    FALSE - Buffer could not be allocated

--*/

{
    PLIST_ENTRY ListEntry;
    PCANONICAL_CREDENTIAL Credential;
    ULONG ReturnBufferSize;
    PMARSHALED_CREDENTIAL_SET ReturnBuffer;
    ULONG i;
    LPBYTE Where;
    LPBYTE OldWhere;

    LPBYTE LocalCredBlob = NULL;
    ULONG LocalCredBlobSize = 0;


    //
    // Loop through the list of credentials computing the size of the return buffer
    //

    ReturnBufferSize = 0;
    for ( ListEntry = CredentialSet->Credentials.Flink ;
          ListEntry != &CredentialSet->Credentials;
          ListEntry = ListEntry->Flink) {

        Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

        ReturnBufferSize += sizeof(MARSHALED_CREDENTIAL);

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + Credential->TargetName.MaximumLength;

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + (Credential->Cred.Comment == NULL ? 0 : ((wcslen( Credential->Cred.Comment ) + 1) * sizeof(WCHAR)));

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + Credential->TargetAlias.MaximumLength;

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + Credential->UserName.MaximumLength;

        if ( PersistCredBlob( &Credential->Cred ) ) {
            ReturnBufferSize += sizeof(ULONG) + Credential->ClearCredentialBlobSize;
            LocalCredBlobSize = max( LocalCredBlobSize, Credential->Cred.CredentialBlobSize );
        } else {
            ReturnBufferSize += sizeof(ULONG);
        }


        for ( i=0; i<Credential->Cred.AttributeCount; i++ ) {

            ReturnBufferSize += sizeof(ULONG);

            ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
            ReturnBufferSize += sizeof(ULONG) + (Credential->Cred.Attributes[i].Keyword == NULL ? 0 : (wcslen( Credential->Cred.Attributes[i].Keyword ) + 1 ) * sizeof(WCHAR) );

            ReturnBufferSize += sizeof(ULONG) + Credential->Cred.Attributes[i].ValueSize;

        }

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WORST );

    }


    //
    // If there is nothing to marshal,
    //  we're done.
    //

    if ( ReturnBufferSize == 0 ) {
        *Buffer = NULL;
        *BufferSize = 0;
        return TRUE;
    }
    //
    // Allocate a buffer to return to the caller.
    //

    ReturnBufferSize += ROUND_UP_COUNT( sizeof(MARSHALED_CREDENTIAL_SET), ALIGN_WORST );
    ReturnBuffer = (PMARSHALED_CREDENTIAL_SET) LsapAllocateLsaHeap( ReturnBufferSize );

    if ( ReturnBuffer == NULL) {
        return FALSE;
    }

    //
    // Allocate a buffer to decrypt the credential blob into
    //

    SafeAllocaAllocate( LocalCredBlob, LocalCredBlobSize );
    if ( LocalCredBlob == NULL ) {
        LsapFreeLsaHeap( ReturnBuffer );
        return FALSE;
    }

    //
    // Create the buffer header.
    //

    ReturnBuffer->Version = MARSHALED_CREDENTIAL_SET_VERSION;
    ReturnBuffer->Size = ReturnBufferSize;

    OldWhere = (PUCHAR)(ReturnBuffer+1);
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    //
    // Copy the individual credentials
    //

    for ( ListEntry = CredentialSet->Credentials.Flink ;
          ListEntry != &CredentialSet->Credentials;
          ListEntry = ListEntry->Flink) {

        PMARSHALED_CREDENTIAL CredEntry;
        ULONG CommentSize;

        Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

        CredEntry = (PMARSHALED_CREDENTIAL)Where;

        //
        // Copy the fixed size fields into the buffer.
        //

        CredEntry->Flags = Credential->Cred.Flags;
        CredEntry->Type = Credential->Cred.Type;
        CredEntry->LastWritten = Credential->Cred.LastWritten;
        CredEntry->Persist = Credential->Cred.Persist;
        CredEntry->AttributeCount = Credential->Cred.AttributeCount;
        CredEntry->Expansion1 = 0;
        CredEntry->Expansion2 = 0;

        Where = (LPBYTE)(CredEntry+1);

        //
        // Copy the strings
        //

#define CredpMarshalBytes( _Ptr, _Size, _Align ) \
        OldWhere = Where; \
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, _Align ); \
        RtlZeroMemory( OldWhere, Where-OldWhere ); \
        SmbPutUlong( Where, (_Size) ); \
        Where += sizeof(ULONG); \
        if ( _Size != 0 ) { \
            RtlCopyMemory( Where, (_Ptr), (_Size) ); \
            Where += (_Size); \
        }

        CredpMarshalBytes( Credential->TargetName.Buffer, Credential->TargetName.MaximumLength, ALIGN_WCHAR );

        CommentSize = Credential->Cred.Comment == NULL ? 0 : (wcslen( Credential->Cred.Comment ) + 1 ) * sizeof(WCHAR);
        CredpMarshalBytes( Credential->Cred.Comment, CommentSize, ALIGN_WCHAR );

        CredpMarshalBytes( Credential->TargetAlias.Buffer, Credential->TargetAlias.MaximumLength, ALIGN_WCHAR );

        CredpMarshalBytes( Credential->UserName.Buffer, Credential->UserName.MaximumLength, ALIGN_WCHAR );


        //
        // Marshal the (decrypted) credential itself
        //

        if ( PersistCredBlob( &Credential->Cred ) ) {

            //
            // Grab a local copy of the cred blob to decrypt into
            //

            if ( Credential->Cred.CredentialBlobSize != 0 ) {
                RtlCopyMemory( LocalCredBlob,
                               Credential->Cred.CredentialBlob,
                               Credential->Cred.CredentialBlobSize );

                LsaUnprotectMemory( LocalCredBlob,
                                    Credential->Cred.CredentialBlobSize );
            }

            CredpMarshalBytes( LocalCredBlob, Credential->ClearCredentialBlobSize, ALIGN_BYTE );

        } else {
            CredpMarshalBytes( NULL, 0, ALIGN_BYTE );
        }

        //
        // Marshal the attributes
        //

        for ( i=0; i<CredEntry->AttributeCount; i++ ) {
            ULONG KeywordSize;
            SmbPutUlong( Where, Credential->Cred.Attributes[i].Flags );
            Where += sizeof(ULONG);

            KeywordSize = Credential->Cred.Attributes[i].Keyword == NULL ? 0 : (wcslen( Credential->Cred.Attributes[i].Keyword ) + 1) * sizeof(WCHAR);
            CredpMarshalBytes( Credential->Cred.Attributes[i].Keyword, KeywordSize, ALIGN_WCHAR );

            CredpMarshalBytes( Credential->Cred.Attributes[i].Value,
                                Credential->Cred.Attributes[i].ValueSize,
                                ALIGN_BYTE );

        }

        //
        // Zero any padding bytes
        //
        OldWhere = Where;
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );


        //
        // Remember the size of this credential.
        //

        CredEntry->EntrySize = (ULONG)(Where - ((LPBYTE)CredEntry));

    }

    //
    // Sanity check
    //

    if ( ReturnBufferSize != (ULONG)(Where - ((LPBYTE)ReturnBuffer))) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpMarshalCredentials: Marshaled %ld bytes into a buffer %ld long.\n",
                   Where - ((LPBYTE)ReturnBuffer),
                   ReturnBufferSize ));
    }

    //
    // Return the buffer to the caller
    //

    *Buffer = (LPBYTE) ReturnBuffer;
    *BufferSize = ReturnBufferSize;

    //
    // Free the temp buffer
    //

    if ( LocalCredBlob != NULL ) {
        RtlZeroMemory( LocalCredBlob, LocalCredBlobSize );
        SafeAllocaFree( LocalCredBlob );
    }

    return TRUE;

}


DWORD
CreateNestedDirectories(
    IN      LPWSTR szFullPath,
    IN      LPWSTR szCreationStartPoint // must point in null-terminated range of szFullPath
    )
/*++

    Create all subdirectories if they do not exists starting at
    szCreationStartPoint.

    szCreationStartPoint must point to a character within the null terminated
    buffer specified by the szFullPath parameter.

    Note that szCreationStartPoint should not point at the first character
    of a drive root, eg:

    d:\foo\bar\bilge\water
    \\server\share\foo\bar
    \\?\d:\big\path\bilge\water

    Instead, szCreationStartPoint should point beyond these components, eg:

    bar\bilge\water
    foo\bar
    big\path\bilge\water

    This function does not implement logic for adjusting to compensate for these
    inputs because the environment it was design to be used in causes the input
    szCreationStartPoint to point well into the szFullPath input buffer.


    This function stolen from crypto api.

--*/
{
    DWORD i;
    DWORD cchRemaining;
    DWORD LastError = ERROR_SUCCESS;

    BOOL fSuccess = FALSE;


    if( szCreationStartPoint < szFullPath ||
        szCreationStartPoint  > (lstrlenW(szFullPath) + szFullPath)
        )
        return ERROR_INVALID_PARAMETER;

    cchRemaining = lstrlenW( szCreationStartPoint );

    //
    // scan from left to right in the szCreationStartPoint string
    // looking for directory delimiter.
    //

    for ( i = 0 ; i < cchRemaining ; i++ ) {
        WCHAR charReplaced = szCreationStartPoint[ i ];

        if( charReplaced == L'\\' || charReplaced == L'/' ) {

            szCreationStartPoint[ i ] = L'\0';

            fSuccess = CreateDirectoryW( szFullPath, NULL );

            szCreationStartPoint[ i ] = charReplaced;

            if( !fSuccess ) {
                LastError = GetLastError();
                if( LastError != ERROR_ALREADY_EXISTS ) {

                    //
                    // continue onwards, trying to create specified subdirectories.
                    // this is done to address the obscure scenario where
                    // the Bypass Traverse Checking Privilege allows the caller
                    // to create directories below an existing path where one
                    // component denies the user access.
                    // we just keep trying and the last CreateDirectory()
                    // result is returned to the caller.
                    //

                    continue;
                }
            }

            LastError = ERROR_SUCCESS;
        }
    }

    //
    // check if the last directory creation actually succeeded.
    // if it did, we need to adjust the file attributes on that directory
    // and its parent.
    //

    if( fSuccess ) {

        SetFileAttributesW( szFullPath, FILE_ATTRIBUTE_SYSTEM );

        //
        // now, scan from right to left looking for the prior directory
        // de-limiter.
        //

        if( cchRemaining < 2 )
            return LastError;

        for ( i = (cchRemaining-2) ; i > 0 ; i-- ) {
            WCHAR charReplaced = szCreationStartPoint[ i ];

            if( charReplaced == L'\\' || charReplaced == L'/' ) {

                szCreationStartPoint[ i ] = L'\0';
                SetFileAttributesW( szFullPath, FILE_ATTRIBUTE_SYSTEM );
                szCreationStartPoint[ i ] = charReplaced;

                break;
            }

        }
    }

    return LastError;
}

DWORD
GetUserStorageArea(
    IN int csidl,
    IN PSID UserSid,
    OUT LPWSTR *UserStorageArea
    )

/*++

Routine Description:

    Get the path to user's roaming profile.  The subdirectories are created as needed.

    Caller must be impersonating the user.

Arguments:

    csidl - Specifies which system directory to use as a root.

    UserSid - Sid of the user


    UserStorageArea - Returns the path of the user storage area
        The buffer must be freed using LsapFreeLsaHeap

Return Values:

    NO_ERROR: Path returned properly
    ERROR_CANTOPEN: Path could not be found

--*/
{
    DWORD WinStatus;
    NTSTATUS Status;

    WCHAR szUserStorageRoot[MAX_PATH+1];
    DWORD cbUserStorageRoot;

    const WCHAR szProductString[] = L"\\Microsoft\\Credentials\\";
    DWORD cbProductString = sizeof(szProductString) - sizeof(WCHAR);

    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE Where;
    UNICODE_STRING UserSidString;

    typedef HRESULT (WINAPI *SHGETFOLDERPATHW)(
        HWND hwnd,
        int csidl,
        HANDLE hToken,
        DWORD dwFlags,
        LPWSTR pszPath
        );

    static SHGETFOLDERPATHW _SHGetFolderPathW;
    HANDLE hToken;

    //
    // Initialization
    //
    *UserStorageArea = NULL;
    RtlInitUnicodeString( &UserSidString, NULL );

    //
    // Load shell32.dll
    //
    if(_SHGetFolderPathW == NULL) {

        HMODULE hShell32 = LoadLibraryW( L"shell32.dll" );
        if(hShell32 == NULL) {
            WinStatus = ERROR_CANTOPEN;
            goto Cleanup;
        }

        _SHGetFolderPathW = (SHGETFOLDERPATHW)GetProcAddress(hShell32, "SHGetFolderPathW");

        if( _SHGetFolderPathW == NULL ) {
            WinStatus = ERROR_CANTOPEN;
            goto Cleanup;
        }
    }

    //
    // Get the path of the "Application Data" folder
    //

    if( !OpenThreadToken( GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken )) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    WinStatus = (DWORD)_SHGetFolderPathW( NULL, csidl | CSIDL_FLAG_CREATE, hToken, 0, szUserStorageRoot );

    CloseHandle( hToken );

    if( WinStatus != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    cbUserStorageRoot = wcslen( szUserStorageRoot ) * sizeof(WCHAR);

    //
    // An empty string is not legal as the root component of the per-user
    // storage area.
    //

    if( cbUserStorageRoot == 0 ) {
        WinStatus = ERROR_CANTOPEN;
        goto Cleanup;
    }

    //
    // Ensure returned string does not have trailing \
    //

    if( szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] == L'\\' ) {

        szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] = L'\0';
        cbUserStorageRoot -= sizeof(WCHAR);
    }

    //
    // Convert the SID to a text string
    //

    Status = RtlConvertSidToUnicodeString( &UserSidString, UserSid, TRUE );

    if ( !NT_SUCCESS(Status) ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Allocate memory for the return string
    //

    *UserStorageArea = (LPWSTR)LsapAllocateLsaHeap(
                                    cbUserStorageRoot +
                                    cbProductString +
                                    UserSidString.Length +
                                    (2 * sizeof(WCHAR)) // trailing slash and NULL
                                    );

    if( *UserStorageArea == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Build the name as of the path.
    //

    Where = (PBYTE)*UserStorageArea;

    RtlCopyMemory(Where, szUserStorageRoot, cbUserStorageRoot);
    Where += cbUserStorageRoot;

    RtlCopyMemory(Where, szProductString, cbProductString);
    Where += cbProductString;

    RtlCopyMemory(Where, UserSidString.Buffer, UserSidString.Length);
    Where += UserSidString.Length; // note: does not include terminal NULL


    if( *((LPWSTR)Where - 1) != L'\\' ) {
        *(LPWSTR)Where = L'\\';
        Where += sizeof(WCHAR);
    }

    *(LPWSTR)Where = L'\0';


    //
    // Ensure the directory exists
    //

    WinStatus = CreateNestedDirectories(
                            *UserStorageArea,
                            (LPWSTR)((LPBYTE)*UserStorageArea + cbUserStorageRoot + sizeof(WCHAR)) );


Cleanup:

    RtlFreeUnicodeString( &UserSidString );

    if( WinStatus != ERROR_SUCCESS && *UserStorageArea ) {
        LsapFreeLsaHeap( *UserStorageArea );
        *UserStorageArea = NULL;
    }

    return WinStatus;
}

DWORD
OpenFileInStorageArea(
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName,
    IN OUT  HANDLE  *phFile
    )
// Routine stolen from crypto API
{
    LPWSTR szFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD LastError = ERROR_SUCCESS;

    *phFile = INVALID_HANDLE_VALUE;

    if( dwDesiredAccess & GENERIC_READ ) {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if( dwDesiredAccess & GENERIC_WRITE ) {
        dwShareMode = 0;
        dwCreationDistribution = CREATE_ALWAYS;
    }

    cbUserStorageArea = wcslen( szUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( szFileName ) * sizeof(WCHAR);

    SafeAllocaAllocate( szFilePath, cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( szFilePath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(szFilePath, szUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)szFilePath+cbUserStorageArea, szFileName, cbFileName + sizeof(WCHAR));

    if( LastError == ERROR_SUCCESS ) {

        //
        // TODO:
        // apply security descriptor to file.
        //

        *phFile = CreateFileW(
                    szFilePath,
                    dwDesiredAccess,
                    dwShareMode,
                    NULL,
                    dwCreationDistribution,
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM |
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

        if( *phFile == INVALID_HANDLE_VALUE ) {
            LastError = GetLastError();
        }


    }

    if(szFilePath)
        SafeAllocaFree(szFilePath);

    return LastError;
}

DWORD
DeleteFileInStorageArea(
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName
    )
// Routine stolen from crypto API
{
    LPWSTR szFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD LastError = ERROR_SUCCESS;

    cbUserStorageArea = wcslen( szUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( szFileName ) * sizeof(WCHAR);

    SafeAllocaAllocate( szFilePath, cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( szFilePath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(szFilePath, szUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)szFilePath+cbUserStorageArea, szFileName, cbFileName + sizeof(WCHAR));

    if ( !DeleteFileW( szFilePath ) ) {
            LastError = GetLastError();
    }

    if(szFilePath)
        SafeAllocaFree(szFilePath);

    return LastError;
}

BOOL
CredpGetUnicodeString(
    IN LPBYTE BufferEnd,
    IN OUT LPBYTE *Where,
    OUT LPWSTR *String
    )

/*++

Routine Description:

    Determine if a UNICODE string in a message buffer is valid.

    UNICODE strings always appear at a 2-byte boundary in the message.

Arguments:

    BufferEnd - A pointer to the first byte beyond the end of the buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the zero byte in the message buffer.

    String - Returns a pointer to the validated string.
        Pointer is to the buffer *Where points to.
        Returns NULL for empty strings.


Return Value:

    TRUE - the string is valid.

    FALSE - the string is invalid.

--*/

{
    DWORD Size;
    LPWSTR ZeroPtr;

    //
    // Align the unicode string on a WCHAR boundary.
    //

    *Where = (LPBYTE) ROUND_UP_POINTER( *Where, ALIGN_WCHAR );

    if ( (*Where) + sizeof(ULONG) > BufferEnd ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: String size after buffer end: %lx %lx.\n",
                   *Where,
                   BufferEnd ));
        return FALSE;
    }

    //
    // Get the string size (in bytes)
    //

    Size = SmbGetUlong( *Where );
    *Where += sizeof(ULONG);

    if ( Size == 0 ) {
        *String = NULL;
        return TRUE;
    }


    if ( *Where >= BufferEnd ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: String after buffer end: %lx %lx.\n",
                   *Where,
                   BufferEnd ));
        return FALSE;
    }

    //
    // Ensure the size is aligned
    //

    if ( Size != ROUND_UP_COUNT( Size, ALIGN_WCHAR) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: Size not aligned: %lx.\n",
                   Size ));
        return FALSE;
    }


    //
    // Limit the string to the number of bytes remaining in the message buffer.
    //

    if ( Size > (ULONG)(BufferEnd - (*Where)) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: String too big: %lx %lx %lx.\n",
                   *Where,
                   BufferEnd,
                   Size ));
        return FALSE;
    }

    //
    // Ensure the trailing zero exists
    //

    if ( ((LPWSTR)(*Where))[(Size/sizeof(WCHAR))-1] != L'\0' ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: No trailing zero: %lx.\n",
                   Size ));
        return FALSE;
    }

    //
    // Ensure there aren't extra zero bytes.
    //

    ZeroPtr = wcschr( (LPWSTR)(*Where), L'\0' );

    if ( ZeroPtr < &((LPWSTR)(*Where))[(Size/sizeof(WCHAR))-1] ) {
        DebugLog(( DEB_TRACE_CRED,
                   "Trailing zero in middle of string: %lx.\n",
                   Size ));
        return FALSE;
    }

    //
    // Position 'Where' past the end of the string.
    //

    *String = (LPWSTR)(*Where);
    *Where += Size;

    return TRUE;

}

BOOL
CredpGetBytes(
    IN LPBYTE BufferEnd,
    IN OUT LPBYTE *Where,
    OUT LPDWORD BufferSize,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    Unmarshal an array of bytes from a message buffer.

Arguments:

    BufferEnd - A pointer to the first byte beyond the end of the buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the data bytes in the message buffer.

    BufferSize - Returns the size (in bytes) of the data.

    Buffer - Returns a pointer to the validated data.
        Pointer is to the buffer *Where points to.
        Returns NULL for zero length data.


Return Value:

    TRUE - the string is valid.

    FALSE - the string is invalid.

--*/

{
    DWORD Size;

    //
    // Get the string size (in bytes)
    //

    Size = SmbGetUlong( *Where );
    *Where += sizeof(ULONG);

    if ( Size == 0 ) {
        *Buffer = NULL;
        *BufferSize = 0;
        return TRUE;
    }


    if ( *Where >= BufferEnd ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetBytes: String after buffer end: %lx %lx.\n",
                   *Where,
                   BufferEnd ));
        return FALSE;
    }

    //
    // Limit the string to the number of bytes remaining in the message buffer.
    //

    if ( Size > (ULONG)(BufferEnd - (*Where)) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetBytes: String too big: %lx %lx %lx.\n",
                   *Where,
                   BufferEnd,
                   Size ));
        return FALSE;
    }

    //
    // Position 'Where' past the end of the string.
    //

    *Buffer = *Where;
    *BufferSize = Size;
    *Where += Size;

    return TRUE;

}

VOID
CredpMarkDirty(
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG Persist,
    IN PCANONICAL_CREDENTIAL Credential OPTIONAL
    )

/*++

Routine Description:

    The routine marks a credential set dirty and updates the last written
    time on a credential.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - Credential set to mark.

    Persist - Persistence of the credential set to mark

    Credential - Specifies the modified credential.
        If NULL, no specific credential was modified.

Return Values:

    None.

--*/

{

    //
    // Mark the credential set dirty.
    //

    PersistToCredentialSet( CredentialSets, Persist )->Dirty = TRUE;

    //
    // Mark the credential as modified
    //

    if ( Credential != NULL ) {
        LsapQuerySystemTime( &Credential->Cred.LastWritten );
    }

}

DWORD
CredpReadCredSet(
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG Persist
    )

/*++

Routine Description:

    The routine reads a credential set from disk

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - Credential sets to read into

    Persist - Persistence of the credential set to read

Return Values:

    NO_ERROR - Credential set read successfully

--*/

{
    DWORD WinStatus;

    NTSTATUS Status;

    PCREDENTIAL_SET CredentialSet;
    PMARSHALED_CREDENTIAL_SET CredSetBuffer = NULL;
    ULONG CredSetBufferSize = 0;
    LPBYTE CredSetBufferEnd;
    PMARSHALED_CREDENTIAL CredEntry;
    LIST_ENTRY CredentialList;
    PCANONICAL_CREDENTIAL TempCredential;

    LPWSTR FilePath = NULL;
    LPWSTR FileName = CREDENTIAL_FILE_NAME;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PCREDENTIAL_ATTRIBUTEW Attributes = NULL;
    BOOLEAN CritSectLocked = TRUE;

    ULONG i;
    ULONG BytesRead;

    PVOID EncryptedBlob = NULL;
    ULONG EncryptedBlobSize;

    LPBYTE LocalCredBlob = NULL;
    ULONG LocalCredBlobSize = 0;


    PLIST_ENTRY ListEntry;

    LPBYTE Where;

    //
    // Initialization
    //

    InitializeListHead( &CredentialList );


    //
    // Ignore non-persistent credential sets
    //

    if ( Persist == CRED_PERSIST_SESSION ) {
        return NO_ERROR;
    }

    CredentialSet = PersistToCredentialSet( CredentialSets, Persist );


    //
    // Drop the lock while we're doing the read.  DPAPI accesses network resources
    //  while encrypting.  We don't want to hold up cred set access just because the
    //  network is slow.
    //

    RtlLeaveCriticalSection( &CredentialSets->UserCredentialSets->CritSect );
    CritSectLocked = FALSE;

    //
    // Get the name of the path to read the cred set from
    //

    WinStatus = GetUserStorageArea(
            (Persist == CRED_PERSIST_ENTERPRISE ? CSIDL_APPDATA : CSIDL_LOCAL_APPDATA),
            CredentialSets->UserCredentialSets->UserSid,
            &FilePath );

    if ( WinStatus != NO_ERROR ) {
        if ( WinStatus == ERROR_CANTOPEN ) {
            WinStatus = NO_ERROR;
        } else {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Cannot determine path to profile: %ld.\n",
                       WinStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the file
    //

    WinStatus = OpenFileInStorageArea(
                    GENERIC_READ,
                    FilePath,
                    FileName,
                    &FileHandle );

    if ( WinStatus != NO_ERROR ) {
        if ( WinStatus == ERROR_FILE_NOT_FOUND ||
             WinStatus == ERROR_PATH_NOT_FOUND ) {
            WinStatus = NO_ERROR;
        } else {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Cannot open file %ls\\%ls: %ld.\n",
                       FilePath,
                       FileName,
                       WinStatus ));
        }
        goto Cleanup;
    }


    //
    // Get the size of the file.
    //

    EncryptedBlobSize = GetFileSize( FileHandle, NULL );

    if ( EncryptedBlobSize == 0xFFFFFFFF ) {

        WinStatus = GetLastError();
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot GetFileSize %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   WinStatus ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( EncryptedBlobSize < 1 ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Size too small %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   EncryptedBlobSize ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }


    //
    // Allocate a buffer to read the file into.
    //

    SafeAllocaAllocate( EncryptedBlob, EncryptedBlobSize );

    if ( EncryptedBlob == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Read the file into the buffer.
    //

    if ( !ReadFile( FileHandle,
                    EncryptedBlob,
                    EncryptedBlobSize,
                    &BytesRead,
                    NULL ) ) {  // Not Overlapped

        WinStatus = GetLastError();
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot ReadFile %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   WinStatus ));

        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( BytesRead != EncryptedBlobSize ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot read entire file %ls\\%ls: %ld %ld.\n",
                   FilePath,
                   FileName,
                   BytesRead,
                   EncryptedBlobSize ));

        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }



    //
    // Decrypt the data
    //

    if ( !LsaICryptUnprotectData(
                              EncryptedBlob,
                              EncryptedBlobSize,
                              NULL,    // No additional entropy
                              0,
                              NULL,    // Must be NULL
                              NULL,    // Must be NULL
                              CRYPTPROTECT_SYSTEM |              // Cannot be decrypted by usermode app
                                CRYPTPROTECT_VERIFY_PROTECTION | // Tell us if the encryption algorithm needs to change
                                CRYPTPROTECT_UI_FORBIDDEN,       // No UI allowed
                              NULL,    // No description of the data
                              (PVOID *)&CredSetBuffer,
                              &CredSetBufferSize ) ) {

        WinStatus = GetLastError();

        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot CryptUnprotectData: 0x%lx.\n",
                   WinStatus ));

        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;

    }


    //
    // If the encryption algorithm changed,
    //  encrypt the data with the new algorithm
    //

    WinStatus = GetLastError();
    if ( WinStatus == CRYPT_I_NEW_PROTECTION_REQUIRED ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Need to change encryption algorithm: 0x%lx.\n",
                   WinStatus ));

        // The easiest way to do that is to simply mark the cred set as dirty.
        CredpMarkDirty( CredentialSets, Persist, NULL );
    }



    //
    // Validate the returned data.
    //

    if ( CredSetBufferSize < sizeof(MARSHALED_CREDENTIAL_SET) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Size too small %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   CredSetBufferSize ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( CredSetBuffer->Version != MARSHALED_CREDENTIAL_SET_VERSION ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Version wrong %ls\\%ls: %ld %ld.\n",
                   FilePath,
                   FileName,
                   CredSetBuffer->Version,
                   MARSHALED_CREDENTIAL_SET_VERSION ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( CredSetBuffer->Size != CredSetBufferSize ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Size wrong %ls\\%ls: %ld %ld.\n",
                   FilePath,
                   FileName,
                   CredSetBuffer->Size,
                   CredSetBufferSize ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }



    //
    // Loop through each log entry.
    //

    CredSetBufferEnd = ((LPBYTE)CredSetBuffer) + CredSetBufferSize;
    CredEntry = (PMARSHALED_CREDENTIAL)ROUND_UP_POINTER( (CredSetBuffer + 1), ALIGN_WORST );

    while ( (LPBYTE)(CredEntry+1) <= CredSetBufferEnd ) {
        LPBYTE CredEntryEnd;
        ENCRYPTED_CREDENTIALW LocalCredential;

        CredEntryEnd = ((LPBYTE)CredEntry) + CredEntry->EntrySize;

        //
        // Cleanup from a previous iteration.
        //

        if ( Attributes != NULL ) {
            LsapFreeLsaHeap( Attributes );
            Attributes = NULL;
        }

        //
        // Ensure this entry is entirely within the allocated buffer.
        //

        if  ( CredEntryEnd > CredSetBufferEnd ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Entry too big %ls\\%ls: %ld %ld.\n",
                       FilePath,
                       FileName,
                       ((LPBYTE)CredEntry)-((LPBYTE)CredSetBuffer),
                       CredEntry->EntrySize ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Validate the entry
        //

        if ( !COUNT_IS_ALIGNED(CredEntry->EntrySize, ALIGN_WORST) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: EntrySize not aligned %ls\\%ls: %ld.\n",
                       FilePath,
                       FileName,
                       CredEntry->EntrySize ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Grab the Position past the fixed size data for the entry.
        //

        Where = (LPBYTE) (CredEntry+1);
        if ( Where >= CredEntryEnd ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Data after record missing %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Copy the fixed size fields into the buffer.
        //


        RtlZeroMemory( &LocalCredential, sizeof(LocalCredential) );
        LocalCredential.Cred.Flags = CredEntry->Flags;
        LocalCredential.Cred.Type = CredEntry->Type;
        LocalCredential.Cred.LastWritten = CredEntry->LastWritten;
        LocalCredential.Cred.Persist = Persist;
        LocalCredential.Cred.AttributeCount = CredEntry->AttributeCount;

        //
        // Copy the strings
        //

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.TargetName ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: TargetName string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.Comment ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Comment string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.TargetAlias ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: TargetAlias string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.UserName ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: UserName string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Unmarshal the clear credential itself
        //

        if ( !CredpGetBytes( CredEntryEnd,
                             &Where,
                             &LocalCredential.Cred.CredentialBlobSize,
                             &LocalCredential.Cred.CredentialBlob ) ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Credential broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));

            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;

        }

        // Clear cred have both buffers the same size.
        LocalCredential.ClearCredentialBlobSize = LocalCredential.Cred.CredentialBlobSize;


        //
        // Marshal the attributes
        //

        if ( CredEntry->AttributeCount != 0) {
            //
            // Allocate an array to point to the aliases.
            //

            Attributes = (PCREDENTIAL_ATTRIBUTEW) LsapAllocateLsaHeap(
                    CredEntry->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTEW) );

            if ( Attributes == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            LocalCredential.Cred.Attributes = Attributes;

            //
            // Loop unmarshaling the aliases.
            //

            for ( i=0; i<CredEntry->AttributeCount; i++ ) {

                //
                // Get the flags
                //
                LocalCredential.Cred.Attributes[i].Flags = SmbGetUlong( Where );
                Where += sizeof(ULONG);

                //
                // Get the keyword
                //
                if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.Attributes[i].Keyword ) ) {
                    DebugLog(( DEB_TRACE_CRED,
                               "CredpReadCredSet: Keyword %ld broken %ls\\%ls: %lx %lx.\n",
                               i,
                               FilePath,
                               FileName,
                               Where,
                               CredEntryEnd ));
                    WinStatus = ERROR_INVALID_DATA;
                    goto Cleanup;
                }

                //
                // Get the value
                //

                if ( !CredpGetBytes( CredEntryEnd,
                                     &Where,
                                     &LocalCredential.Cred.Attributes[i].ValueSize,
                                     &LocalCredential.Cred.Attributes[i].Value ) ) {

                    DebugLog(( DEB_TRACE_CRED,
                               "CredpReadCredSet: Value %ld broken %ls\\%ls: %lx %lx.\n",
                               i,
                               FilePath,
                               FileName,
                               Where,
                               CredEntryEnd ));
                    WinStatus = ERROR_INVALID_DATA;
                    goto Cleanup;

                }

            }
        }

        //
        // Canonicalize the credential.
        //

        Status = CredpValidateCredential(
                        CREDP_FLAGS_CLEAR_PASSWORD,
                        NULL,   // No target info
                        &LocalCredential,
                        &TempCredential );

        if ( !NT_SUCCESS(Status) ) {
            if ( Status == ERROR_INVALID_PARAMETER ) {
                // This isn't fatal. Just ignore this one credential
            } else {
                WinStatus = RtlNtStatusToDosError( Status );
                goto Cleanup;
            }

        //
        // Put it on a local list until we finish reading the entire log file
        //

        } else {
            InsertTailList( &CredentialList, &TempCredential->Next );
        }


        //
        // Move to the next entry.
        //

        CredEntry = (PMARSHALED_CREDENTIAL)(((LPBYTE)CredEntry) + CredEntry->EntrySize);
    }


    WinStatus = NO_ERROR;


    //
    // Be tidy.
    //
Cleanup:

    if ( !CritSectLocked ) {
        RtlEnterCriticalSection( &CredentialSets->UserCredentialSets->CritSect );
    }

    //
    // Free the temp buffer
    //

    if ( LocalCredBlob != NULL ) {
        RtlZeroMemory( LocalCredBlob, LocalCredBlobSize );
        SafeAllocaFree( LocalCredBlob );
    }

    //
    // If the file cannot be read,
    //  that's not really an error.
    //

    if ( WinStatus == ERROR_INVALID_DATA ) {
        // Leave it lying around to allow debugging.
        WinStatus = NO_ERROR;
    }

    //
    // If we're successful so far,
    //  add the temporary credential list to the in-memory credential set.
    //

    if ( WinStatus == NO_ERROR ) {


        //
        // Loop through the credentials adding them to the in-memory credential set.
        //

        while ( !IsListEmpty( &CredentialList ) ) {

            ListEntry = RemoveHeadList( &CredentialList );

            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Write it to the credential set
            //

            Status = CredpWriteCredential( CredentialSets,
                                           &TempCredential,
                                           TRUE,    // Creds are from persisted file
                                           FALSE,   // Don't update pin in CSP
                                           FALSE,   // Creds have not been prompted for
                                           0,       // No flags
                                           NULL,
                                           NULL,
                                           NULL );

            if ( !NT_SUCCESS( Status )) {
                LsapFreeLsaHeap( TempCredential );

                //
                // Remember the status.  But continue on.
                //
                WinStatus = RtlNtStatusToDosError( Status );
            }

        }
    }

    //
    // Cleanup temporary credential list
    //
    while ( !IsListEmpty( &CredentialList ) ) {

        ListEntry = RemoveHeadList( &CredentialList );

        TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

        LsapFreeLsaHeap( TempCredential );

    }


    //
    // Clear the buffer with clear text passwords in it
    //

    if ( CredSetBuffer != NULL ) {
        RtlZeroMemory( CredSetBuffer, CredSetBufferSize );
        LocalFree( CredSetBuffer );
    }

    if ( EncryptedBlob != NULL ) {
        SafeAllocaFree( EncryptedBlob );
    }

    if ( FilePath != NULL ) {
        LsapFreeLsaHeap( FilePath );
    }
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    if ( Attributes != NULL ) {
        LsapFreeLsaHeap( Attributes );
        Attributes = NULL;
    }

    return WinStatus;

}

VOID
CredpLockCredSets(
    IN PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine locks a set of credential sets.

Arguments:

    CredentialSets - Credential set to lock

Return Values:

    None.

--*/

{
    DWORD WinStatus;

    //
    // Lock the credential set.
    //
    // There's one crit sect the proctects all of the cred sets for the user.
    // We could introduce one crit sect per credential set, but the user-wide crit
    // sect would always be locked along with one of the session crit sects.
    // So, the session crit sect would be wasted.
    //

    RtlEnterCriticalSection( &CredentialSets->UserCredentialSets->CritSect );


}

VOID
CredpUnlockAndFlushCredSets(
    IN PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine unlocks a set of credential sets and flushes it to disk if dirty.

Arguments:

    CredentialSets - Credential set to lock

Return Values:

    None.

--*/

{
    PCREDENTIAL_SET CredentialSet;
    PCANONICAL_CREDENTIAL Credential;
    PLIST_ENTRY ListEntry;
    ULONG Persist;

    //
    // Loop through the list of credential sets persisting each
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        //
        // Ignore non-persistent credential sets
        //

        if ( Persist == CRED_PERSIST_SESSION ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );



        //
        // If the credential set is dirty,
        //  flush it.
        //

        if ( CredentialSet->Dirty ) {

            //
            // Indicate that the credential set is no longer dirty.
            //  But increment that count of times that it has been dirty.
            //

            CredentialSet->Dirty = FALSE;
            CredentialSet->WriteCount ++;

            //
            // If no other thread is already writing it,
            //  we'll take on that responsibility.
            //
            //  Otherwise, let that thread write it again.
            //

            if ( !CredentialSet->BeingWritten ) {

                ULONG WriteCount;

                //
                // Tell other threads that we're writing
                //

                CredentialSet->BeingWritten = TRUE;

                //
                // Loop writing the credentials
                //

                do {
                    LPBYTE CredSetBuffer;
                    ULONG CredSetBufferSize;
                    LPWSTR FilePath;
                    LPWSTR FileName = CREDENTIAL_FILE_NAME;
                    DWORD WinStatus;

                    //
                    // Remember which snapshot we're writing.
                    //
                    WriteCount = CredentialSet->WriteCount;
                    FilePath = NULL;

                    //
                    // Grab a marshaled copy of the credential set
                    //

                    if ( !CredpMarshalCredentials( CredentialSet,
                                                   &CredSetBufferSize,
                                                   &CredSetBuffer ) ) {
                        //
                        // If we can't, mark them dirty for the next caller to flush
                        //
                        CredentialSet->Dirty = TRUE;
                        continue;
                    }

                    //
                    // Drop the lock while we're doing the write.  DPAPI accesses network resources
                    //  while encrypting.  We don't want to hold up cred set access just because the
                    //  network is slow.
                    //

                    RtlLeaveCriticalSection( &CredentialSets->UserCredentialSets->CritSect );

                    //
                    // Get the name of the path to write the cred set to
                    //

                    WinStatus = GetUserStorageArea(
                            (Persist == CRED_PERSIST_ENTERPRISE ? CSIDL_APPDATA : CSIDL_LOCAL_APPDATA),
                            CredentialSets->UserCredentialSets->UserSid,
                            &FilePath );

                    if ( WinStatus != NO_ERROR ) {
                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpUnlockAndFlushCredSets: Cannot determine path to profile: %ld.\n",
                                   WinStatus ));

                    } else {

                        //
                        // If the buffer is zero length,
                        //  just delete the file
                        //

                        if ( CredSetBufferSize == 0 ) {

                            WinStatus = DeleteFileInStorageArea( FilePath, FileName );

                            if ( WinStatus != NO_ERROR ) {
                                if ( WinStatus == ERROR_FILE_NOT_FOUND ||
                                     WinStatus == ERROR_PATH_NOT_FOUND ) {
                                    WinStatus = NO_ERROR;
                                } else {
                                    DebugLog(( DEB_TRACE_CRED,
                                               "CredpUnlockAndFlushCredSets: Cannot delete %ls\\%ls: %ld.\n",
                                               FilePath,
                                               FileName,
                                               WinStatus ));
                                }
                            }


                        //
                        // Otherwise, write data to the file.
                        //
                        } else {
                            PVOID EncryptedBlob;
                            ULONG EncryptedBlobSize;
                            UNICODE_STRING DescriptionString;

                            //
                            // Encrypt the data
                            //

                            RtlInitUnicodeString( &DescriptionString,
                                                  Persist == CRED_PERSIST_ENTERPRISE ?
                                                        L"Enterprise Credential Set" :
                                                        L"Local Credential Set" );

                            if ( !LsaICryptProtectData(
                                                    CredSetBuffer,
                                                    CredSetBufferSize,
                                                    &DescriptionString,
                                                    NULL,    // No additional entropy
                                                    0,
                                                    NULL,    // Must be NULL
                                                    NULL,    // Must be NULL
                                                    CRYPTPROTECT_SYSTEM |         // Cannot be decrypted by usermode app
                                                      CRYPTPROTECT_UI_FORBIDDEN,  // No UI allowed
                                                    &EncryptedBlob,
                                                    &EncryptedBlobSize ) ) {

                                WinStatus = GetLastError();

                                DebugLog(( DEB_TRACE_CRED,
                                           "CredpUnlockAndFlushCredSets: Cannot CryptProtectData: 0x%lx.\n",
                                           WinStatus ));


                            } else {

                                HANDLE FileHandle;


                                //
                                // Open the file
                                //

                                WinStatus = OpenFileInStorageArea(
                                                GENERIC_WRITE,
                                                FilePath,
                                                FileName,
                                                &FileHandle );

                                if ( WinStatus == NO_ERROR ) {
                                    ULONG BytesWritten;

                                    //
                                    // Write the file
                                    //

                                    if ( !WriteFile( FileHandle,
                                                     EncryptedBlob,
                                                     EncryptedBlobSize,
                                                     &BytesWritten,
                                                     NULL ) ) {  // Not Overlapped

                                        WinStatus = GetLastError();
                                        DebugLog(( DEB_TRACE_CRED,
                                                   "CredpUnlockAndFlushCredSets: Cannot write %ls\\%ls: %ld.\n",
                                                   FilePath,
                                                   FileName,
                                                   WinStatus ));
                                    } else {
                                        if ( BytesWritten !=  EncryptedBlobSize ) {
                                            DebugLog(( DEB_TRACE_CRED,
                                                       "CredpUnlockAndFlushCredSets: Cannot write all of %ls\\%ls: %ld %ld.\n",
                                                       FilePath,
                                                       FileName,
                                                       EncryptedBlobSize,
                                                       BytesWritten ));

                                            WinStatus = ERROR_INSUFFICIENT_BUFFER;
                                        }
                                    }

                                    CloseHandle( FileHandle );

                                }

                                LocalFree( EncryptedBlob );

                            }
                        }

                    }


                    //
                    // If we failed to write for any reason,
                    //  ensure the next caller does the flush.
                    //

                    if ( WinStatus != NO_ERROR ) {
                        CredentialSet->Dirty = FALSE;
                    }


                    //
                    // Clear the buffer with clear text passwords in it
                    //

                    if ( CredSetBufferSize != 0 ) {
                        RtlZeroMemory( CredSetBuffer, CredSetBufferSize );
                        LsapFreeLsaHeap( CredSetBuffer );
                    }

                    //
                    // Free any other resources
                    //

                    if ( FilePath != NULL ) {
                        LsapFreeLsaHeap( FilePath );
                    }

                    //
                    // Grab the lock again to see if we need to write again
                    //

                    RtlEnterCriticalSection( &CredentialSets->UserCredentialSets->CritSect );

                } while ( CredentialSet->WriteCount != WriteCount );

                //
                // Tell other threads that we're no longer writing
                //

                CredentialSet->BeingWritten = FALSE;

            }

        }
    }

    //
    // Unlock the credential set.
    //

    RtlLeaveCriticalSection( &CredentialSets->UserCredentialSets->CritSect );
}


PCANONICAL_CREDENTIAL
CredpFindCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PUNICODE_STRING TargetName,
    IN ULONG Type
    )

/*++

Routine Description:

    This routine finds a named credential in a credential set.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSet - Credential set list to find the credential in.

    TargetName - Name of the credential to find.

    Type - Type of the credential to find.

Return Values:

    Returns a pointer to the named credential.  This pointer my be used as long as
    UserCredentialSets->CritSect remains locked.

    NULL: There is no such credential.

--*/
{
    PCREDENTIAL_SET CredentialSet;
    PCANONICAL_CREDENTIAL Credential;
    PLIST_ENTRY ListEntry;
    ULONG Persist;

    //
    // Ignore queries for unsupported cred types
    //

    if ( CredDisableDomainCreds &&
         CredpIsDomainCredential( Type ) ) {

        return NULL;

    }

    //
    // Loop through the list of credentials trying to find this one.
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets->SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            if ( Type == Credential->Cred.Type &&
                 RtlEqualUnicodeString( TargetName,
                                        &Credential->TargetName,
                                        TRUE ) ) {
                return Credential;
            }

        }
    }

    return NULL;
}

NTSTATUS
CredpWritePinToCsp(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_CREDENTIAL Credential
    )
/*++

Routine Description:

    This routine write a PIN to the CSP.  CSPs implement the rules for the lifetime of
    the PIN.  Cred manager therefore doesn't hold onto the PIN, but rather gives it to
    the CSP to manage.

    The caller must be impersonating the logged on user owning the cred set.

Arguments:

    CredentialSets - Credential set the credential is in.

    Credential - Specifies the credential whose PIN is to be written.

Return Values:

    The following status codes may be returned:

        STATUS_SUCCESS - The PIN was stored successfully.
            Or the credential isn't a cert credential.

        STATUS_INVALID_PARAMETER

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    DWORD WinStatus;

    CRED_MARSHAL_TYPE CredType;
    PCERT_CREDENTIAL_INFO CredInfo;

    CRYPT_HASH_BLOB HashBlob;

    HCERTSTORE CertStoreHandle = NULL;
    PCCERT_CONTEXT CertContext = NULL;

    ULONG ProviderInfoSize;
    PCRYPT_KEY_PROV_INFO ProviderInfo = NULL;

    HCRYPTPROV ProviderHandle = NULL;

    UNICODE_STRING UnicodePin;
    ANSI_STRING AnsiPin;
    BOOLEAN ClearPin = FALSE;

    CERT_KEY_CONTEXT CertKeyContext;

    //
    // Initialization
    //

    RtlInitAnsiString( &AnsiPin, NULL );

    //
    // Ignore credentials that aren't certificate credentials
    //

    if ( Credential->Cred.Type != CRED_TYPE_DOMAIN_CERTIFICATE ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Ignore pins of zero length.
    //
    // Either the caller is writing the cred and doesn't know the PIN yet.
    // Or this cert has no PIN.
    //

    if ( Credential->Cred.CredentialBlobSize == 0 ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // If the profile hasn't been loaded,
    //  fail now.
    //
    // The "My" store open will fail below and it'd be better to give a good error code.
    //

    ClearPin = TRUE;
    if ( !CredentialSets->SessionCredSets->ProfileLoaded ) {

        Status = SCARD_E_NO_SUCH_CERTIFICATE;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: Cannot write PIN to cert since profile isn't loaded: 0x%lx.\n",
                   Credential->Cred.UserName,
                   Status ));

        goto Cleanup;

    }

    //
    // Convert the UserName of the credential to a hash of the cert
    //
    if (!CredUnmarshalCredentialW(
            Credential->Cred.UserName,
            &CredType,
            (PVOID *)&CredInfo ) ) {

        WinStatus = GetLastError();

        if ( WinStatus == ERROR_INVALID_PARAMETER ) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: Cannot unmarshal user name of cert cred: 0x%lx.\n",
                   Credential->Cred.UserName,
                   Status ));

        goto Cleanup;
    }

    if ( CredType != CertCredential ) {

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cred isn't cert cred: %ld.\n",
                   Credential->Cred.UserName,
                   CredType ));

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Open a cert store
    //

    CertStoreHandle = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,
                        0,
                        0,
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        L"MY");

    if ( CertStoreHandle == NULL ) {

        WinStatus = GetLastError();

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot open cert store: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;

    }

    //
    // Find the cert in the store which meets this hash
    //

    HashBlob.cbData = sizeof(CredInfo->rgbHashOfCert);
    HashBlob.pbData = CredInfo->rgbHashOfCert;

    CertContext = CertFindCertificateInStore(
                                        CertStoreHandle,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_HASH,
                                        &HashBlob,
                                        NULL );

    if ( CertContext == NULL ) {

        WinStatus = GetLastError();

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;
        } else if ( WinStatus == CRYPT_E_NOT_FOUND ) {
            Status = SCARD_E_NO_SUCH_CERTIFICATE;
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot find cert: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;
    }

    //
    // Get a handle to the private key
    //

    if ( !CryptAcquireCertificatePrivateKey(
            CertContext,
            CRYPT_ACQUIRE_SILENT_FLAG,  // Ensure it doesn't prompt
            NULL,           // reserved
            &ProviderHandle,
            NULL,
            NULL ) ) {

        WinStatus = GetLastError();

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;

        } else if ( WinStatus == NTE_BAD_KEYSET ) {
            // Some CSPs (Schlumberger Cryptoflex) return the wrong status
            Status = SCARD_W_REMOVED_CARD;

        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot CryptAcquireCertificatePrivateKey: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;

    }



    //
    // Convert the pin to ANSI
    //

    LsaUnprotectMemory( Credential->Cred.CredentialBlob,
                        Credential->Cred.CredentialBlobSize );

    UnicodePin.Buffer = (LPWSTR) Credential->Cred.CredentialBlob;
    UnicodePin.Length = (USHORT) Credential->ClearCredentialBlobSize;
    UnicodePin.MaximumLength = (USHORT) Credential->ClearCredentialBlobSize;

    Status = RtlUnicodeStringToAnsiString( &AnsiPin,
                                           &UnicodePin,
                                           TRUE );

    LsaProtectMemory( Credential->Cred.CredentialBlob,
                      Credential->Cred.CredentialBlobSize );

    if ( !NT_SUCCESS( Status )) {

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: Cannot convert PIN '%wZ' to ANSI: 0x%lx.\n",
                   Credential->Cred.UserName,
                   &UnicodePin,
                   Status ));

        goto Cleanup;
    }

    //
    // Set the pin in the provider
    //
    if (!CryptSetProvParam(
            ProviderHandle,
            PP_KEYEXCHANGE_PIN,
            (LPBYTE)AnsiPin.Buffer,
            0 )) {

        WinStatus = GetLastError();

        //
        // Some certs don't require a PIN
        //

        if ( WinStatus == NTE_BAD_TYPE ) {

            //
            // If the caller didn't pass us a PIN,
            //  we're fine.
            //

            if ( AnsiPin.Length == 0 ) {
                WinStatus = NO_ERROR;

            //
            // If the caller did pass us a PIN,
            //  tell him.
            //
            } else {

                WinStatus = ERROR_INVALID_PASSWORD;
            }
        }

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;

        } else if ( WinStatus == ERROR_ACCOUNT_DISABLED ) {
            // Some CSPs (Schlumberger Cryptoflex) return the wrong status
            Status = SCARD_W_CHV_BLOCKED;

        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot CryptSetProvParam: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;
    }


    Status = STATUS_SUCCESS;

    //
    // Free any locally used resources
    //
Cleanup:
    //
    // The whole reason we wrote the PIN to the CSP was so that cred man wouldn't store it.
    //  So clear it.
    //
    if ( ClearPin ) {
        if ( Credential->Cred.CredentialBlob != NULL &&
             Credential->Cred.CredentialBlobSize != 0 ) {
            RtlZeroMemory( Credential->Cred.CredentialBlob,
                           Credential->Cred.CredentialBlobSize );

        }

        Credential->Cred.CredentialBlob = NULL;
        Credential->Cred.CredentialBlobSize = 0;
        Credential->ClearCredentialBlobSize = 0;
        // Cred it already marked dirty
    }

    if ( AnsiPin.Buffer != NULL ) {
        RtlZeroMemory( AnsiPin.Buffer, AnsiPin.Length );
        RtlFreeAnsiString( &AnsiPin );
    }

    if ( ProviderHandle != NULL ) {
        CryptReleaseContext( ProviderHandle, 0 );
    }

    if (NULL != ProviderInfo) {
        LsapFreeLsaHeap( ProviderInfo );
    }

    if ( CertContext != NULL ) {
        CertFreeCertificateContext( CertContext );
    }

    if ( CertStoreHandle != NULL ) {
        CertCloseStore( CertStoreHandle, 0 );
    }

    return Status;

}


NTSTATUS
CredpWriteCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN OUT PCANONICAL_CREDENTIAL *NewCredential,
    IN BOOLEAN FromPersistedFile,
    IN BOOLEAN WritePinToCsp,
    IN BOOLEAN PromptedFor,
    IN DWORD Flags,
    OUT PCANONICAL_CREDENTIAL *OldCredential OPTIONAL,
    OUT PPROMPT_DATA *OldPromptData OPTIONAL,
    OUT PPROMPT_DATA *NewPromptData OPTIONAL
    )

/*++

Routine Description:

    The routine writes a credential to a credential set.  If the credential
    replaces an existing credential, the existing credential is delinked and
    returned to the caller.

    On entry, UserCredentialSets->CritSect must be locked.  (This design ensures
    Credential is valid upon return from the routine.)

Arguments:

    CredentialSets - Credential set to write the credential in.

    NewCredential - Specifies the credential to be written.
        If CRED_PRESERVE_CREDENTIAL_BLOB is specified, the Credential returned in this
        parameter will contain the preserved credential blob. The original credential will be
        deleted.

        If CRED_PRESERVE_CREDENTIAL_BLOB is not specified, this field will not be modified.

    FromPersistedFile - True if the credential is from a persisted file.
        Less validation is done on the credential.

    WritePinToCsp - True if the password is explicitly being set.
        If true, the PIN of certificate credentials is to be written to the CSP.
        Callers that are simply updating the in-memory credential will set this false.

    PromptedFor - Specifies whether Credential has already been prompted for

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

    OldCredential - If specified, returns a pointer to the old credential
        Returns NULL if there was no old credential.
        OldCredential should be freed using LsapFreeLsaHeap.

    OldPromptData - If specified, returns a pointer to the old prompt data for the credential
        Returns NULL if there is no old prompt data.
        OldPromptData should be freed using LsapFreeLsaHeap.

    NewPromptData - If specified, returns a pointer to the new prompt data for the credential
        Returns NULL if there is no new prompt data.
        NewPromptData is properly linked into the prompt data list and should only be freed
        (using LsapFreeLsaHeap) if it is delinked by the caller.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    PCANONICAL_CREDENTIAL Credential = *NewCredential;
    PCANONICAL_CREDENTIAL TempCredential;
    PPROMPT_DATA TempPromptData;
    PPROMPT_DATA PromptData = NULL;

    //
    // Initialization
    //

    if ( OldCredential != NULL ) {
        *OldCredential = NULL;
    }
    if ( OldPromptData != NULL ) {
        *OldPromptData = NULL;
    }
    if ( NewPromptData != NULL ) {
        *NewPromptData = NULL;
    }



    //
    // If the profile hasn't been loaded yet,
    //  don't allow writing to persistent credential sets.
    //

    if ( Credential->Cred.Persist != CRED_PERSIST_SESSION &&
         !FromPersistedFile &&
         !CredentialSets->SessionCredSets->ProfileLoaded ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write persistent cred set until profile loaded: %ld.\n",
                   Credential->Cred.Persist ));

        goto Cleanup;

    }

    //
    // If domain creds have been disabled,
    //  don't allow them to be written.
    //

    if ( CredDisableDomainCreds &&
         !FromPersistedFile &&
         CredpIsDomainCredential( Credential->Cred.Type ) ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write domain cred when feature is disabled: %ld.\n",
                   Credential->Cred.Type ));

        goto Cleanup;

    }

    //
    // If this is a personal system,
    //  and this is a domain credential other than the *Session cred,
    //  don't allow them to be written.
    //

    if ( CredIsPersonal &&
         CredpIsDomainCredential( Credential->Cred.Type ) &&
         Credential->Cred.Type != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD &&
         Credential->WildcardType != WcUniversalSessionWildcard ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write domain cred on personal: %ld.\n",
                   Credential->Cred.Type ));

        goto Cleanup;
    }

    //
    // Don't allow * credential if the user is logged onto a domain account.
    //  In that case, the system uses the logon session credential for several purposes
    //  and the * credential masks that.
    //

    if ( Credential->WildcardType == WcUniversalWildcard &&
         (CredentialSets->Flags & CREDSETS_FLAGS_LOCAL_ACCOUNT) == 0 ) {

        Status = STATUS_INVALID_PARAMETER;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write '*' cred when logged onto domain account.\n" ));

        goto Cleanup;
    }

    //
    // Allocate PromptData if user is writing an always prompt credential
    //  Assume that the user only writes such a credential because he was prompted for a password.
    //

    if ( !FromPersistedFile &&
         !PersistCredBlob( &Credential->Cred ) ) {

        PromptData = CredpAllocatePromptData( Credential );

        if ( PromptData == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

    }

    //
    // Find any existing credential by the same name.
    //

    TempCredential = CredpFindCredential(
                            CredentialSets,
                            &Credential->TargetName,
                            Credential->Cred.Type );


    //
    // Find any prompt data for the existing credential
    //
    // There are cases where there is prompt data and no credential.  That'd be the case
    //  if a machine (or enterprise) credential is deleted from another session.
    //

    TempPromptData = CredpFindPromptData(
                        CredentialSets,
                        &Credential->TargetName,
                        Credential->Cred.Type,
                        TempCredential == NULL ?
                            Credential->Cred.Persist :
                            TempCredential->Cred.Persist );



    //
    // Preserve the credential blob from this credential by the same name.
    //

    if ( Flags & CRED_PRESERVE_CREDENTIAL_BLOB ) {

        ENCRYPTED_CREDENTIALW LocalCredential;
        PCANONICAL_CREDENTIAL CompleteCredential;

        //
        // Don't allow the caller to specify a credential blob if he asked us to preserve the existing one

        if ( Credential->Cred.CredentialBlobSize != 0 ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpWriteCredential: %ws: Trying to preserve credential blob AND specify a new one.\n",
                       Credential->Cred.TargetName ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // If we need to preserve the blob,
        //  fail if there is no blob to preserve.
        //

        if ( TempCredential == NULL ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpWriteCredential: %ws: Cannot write credential with preserved blob.\n",
                       Credential->Cred.TargetName ));
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Since we're preserving the existing credential blob,
        //  we know better than the caller whether the blob has been prompted for.
        //
        // If the existing credential has a persisted credential blob,
        //  then it has been prompted for.
        //
        // Otherwise, check whether we've already cached the credential in memory.
        //
        // (Use the PromptData for that to prevent leakage from another logon session.)
        //

        if ( PersistCredBlob( &TempCredential->Cred ) ) {
            PromptedFor = TRUE;
        } else {
            PromptedFor = !ShouldPromptNow( TempPromptData );
        }

        //
        // If the new credential isn't an always prompt credential, and
        //  there isn't a existing password on the credential,
        //  then the caller should have prompted for the credential and not asked us to preserve the old one.
        //

        if ( PromptData == NULL && !PromptedFor ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpWriteCredential: %ws: Trying to preserve credential blob AND it hasn't been prompted for.\n",
                       Credential->Cred.TargetName ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }


        //
        // Build a new credential with the preserved credential blob in it.
        //

        LocalCredential.Cred = Credential->Cred;
        LocalCredential.Cred.CredentialBlob = TempCredential->Cred.CredentialBlob;
        LocalCredential.Cred.CredentialBlobSize = TempCredential->Cred.CredentialBlobSize;
        LocalCredential.ClearCredentialBlobSize = TempCredential->ClearCredentialBlobSize;

        //
        // Get a marshaled copy of the new credential
        //

        Status = CredpValidateCredential(
                            CREDP_FLAGS_IN_PROCESS,
                            NULL,   // Don't need to use TargetInfo again
                            &LocalCredential,
                            &CompleteCredential );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Use this new credential for the rest of the operation
        //

        LsapFreeLsaHeap( Credential );
        Credential = CompleteCredential;
        *NewCredential = Credential;

    }

    //
    // If this is a cert credential,
    //  write the pin into the CSP.
    //

    if ( WritePinToCsp ) {
        Status = CredpWritePinToCsp( CredentialSets, Credential );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }



    //
    // Delink the existing credential.
    //

    if ( TempCredential != NULL ) {

        RemoveEntryList( &TempCredential->Next );
        CredpMarkDirty( CredentialSets, TempCredential->Cred.Persist, NULL );
        if ( OldCredential != NULL ) {
            *OldCredential = TempCredential;
        } else {
            LsapFreeLsaHeap( TempCredential );
        }
    }



    //
    // Delink existing prompt data
    //
    if ( TempPromptData != NULL ) {

        RemoveEntryList( &TempPromptData->Next );
        if ( OldPromptData != NULL ) {
            *OldPromptData = TempPromptData;
        } else {
            LsapFreeLsaHeap( TempPromptData );
        }
    }

    //
    // Mark the credential as modified.
    //  Don't change the LastWritten date on restored credentials
    //

    CredpMarkDirty( CredentialSets,
                    Credential->Cred.Persist,
                    FromPersistedFile ? NULL : Credential );

    //
    // Link the prompt data
    //

    if ( PromptData != NULL ) {
        InsertHeadList( &CredentialSets->SessionCredSets->PromptData,
                        &PromptData->Next );

        if ( NewPromptData != NULL ) {
            *NewPromptData = PromptData;
        }

        PromptData->Written = PromptedFor;
        PromptData = NULL;
    }


    //
    // Link the new credential into the cred set.
    //

    if ( FromPersistedFile ) {
        // Preserve the order of the credentials in the file.
        InsertTailList(
            &PersistToCredentialSet( CredentialSets, Credential->Cred.Persist )->Credentials,
            &Credential->Next );
    } else {
        // Put new credentials early in the list where they can be found quickly
        InsertHeadList(
            &PersistToCredentialSet( CredentialSets, Credential->Cred.Persist )->Credentials,
            &Credential->Next );
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( PromptData != NULL ) {
        LsapFreeLsaHeap( PromptData );
    }

    return Status;

}

NTSTATUS
CredpWriteMorphedCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN BOOLEAN PromptedFor,
    IN PCANONICAL_TARGET_INFO TargetInfo OPTIONAL,
    IN PENCRYPTED_CREDENTIALW MorphedCredential,
    OUT PCANONICAL_CREDENTIAL *WrittenCredential
    )

/*++

Routine Description:

    This routine write a morphed credential to the credential set.

    Any credential by the same target name and type is delinked and deallocated.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential set.

    PromptedFor - Specifies whether the MorphedCredential should be considered
        as having been prompted for.

    TargetInfo - A description of the various aliases for a target.

    MorphedCredential - Pointer to a credential to add to the credential set.

    WrittenCredential - On success, returns a pointer to the written credential.

Return Values:

    Sundry credential write status codes.

--*/

{
    NTSTATUS Status;
    PCANONICAL_CREDENTIAL ValidatedCredential;

    //
    // Get a marshaled copy of the new credential
    //

    Status = CredpValidateCredential(
                        CREDP_FLAGS_IN_PROCESS,
                        TargetInfo,
                        MorphedCredential,
                        &ValidatedCredential );

    if ( NT_SUCCESS(Status) ) {

        //
        // Write it to the credential set
        //

        Status = CredpWriteCredential( CredentialSets,
                                       &ValidatedCredential,
                                       FALSE,   // Creds are not from persisted file
                                       FALSE,   // Don't update pin in CSP
                                       PromptedFor, // Caller knows if cred has been prompted for
                                       0,       // No flags
                                       NULL,
                                       NULL,
                                       NULL );

        if ( NT_SUCCESS( Status )) {

            *WrittenCredential = ValidatedCredential;
        } else {
            LsapFreeLsaHeap( ValidatedCredential );
        }
    }

    return Status;
}

VOID
CredpUpdatePassword2(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN DWORD CredType
    )

/*++

Routine Description:

    This routine updates the password in all credentials for UserName.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential set.

    UserName - The UserName of the user.
        Same format as in credential.

    Password - New password for the user.
        This password should be passed in hidden via LsapProtectMemory.
        Length - Clear text length of the password
        MaximumLength - Encrypted length of the password

    CredType - Specifies the credential type to change the password on.
        This should be one of CRED_TYPE_DOMAIN_*

Return Values:

    None

--*/

{
    NTSTATUS Status;
    ULONG Persist;
    PCANONICAL_CREDENTIAL TempCredential;
    PCANONICAL_CREDENTIAL WrittenCredential;
    PLIST_ENTRY ListEntry;
    ENCRYPTED_CREDENTIALW LocalCredential;

    //
    // Ignore writes for unsupported cred types
    //

    if ( CredDisableDomainCreds &&
         CredpIsDomainCredential( CredType ) ) {

        return;

    }


    //
    // Loop through the credentials finding those that match.
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {
        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets->SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ) {


            // Grab a pointer to the next entry since this one may be delinked
            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );
            ListEntry = ListEntry->Flink;


            //
            // Only do credentials of the type requested
            //
            if ( TempCredential->Cred.Type != CredType ) {
                continue;
            }


            //
            // Only do credentials with identical user names.
            //

            if ( TempCredential->UserName.Length == 0 ||
                 !RtlEqualUnicodeString( UserName,
                                         &TempCredential->UserName,
                                         TRUE ) ) {

                continue;
            }


            //
            // Only do credentials if the password doesn't match already
            //

            if ( Password->MaximumLength == TempCredential->Cred.CredentialBlobSize &&
                 Password->Length == TempCredential->ClearCredentialBlobSize &&
                 (Password->MaximumLength == 0 ||
                  RtlEqualMemory( Password->Buffer,
                                  TempCredential->Cred.CredentialBlob,
                                  Password->MaximumLength ) ) ) {

                continue;
            }

            //
            // Finally, update the credential to match the new one.
            //

            LocalCredential.Cred = TempCredential->Cred;
            LocalCredential.Cred.CredentialBlob = (LPBYTE)Password->Buffer;
            LocalCredential.Cred.CredentialBlobSize = Password->MaximumLength;
            LocalCredential.ClearCredentialBlobSize = Password->Length;

            //
            // Get a marshaled copy of the new credential
            //

            Status = CredpWriteMorphedCredential(
                                CredentialSets,
                                TRUE,       // Cred has been prompted for
                                NULL,       // No Target info since cred not for this target
                                &LocalCredential,
                                &WrittenCredential );


            //
            // Simply note success
            //
            if ( NT_SUCCESS(Status) ) {
                DebugLog((  DEB_TRACE_CRED,
                           "CredpUpdatePassword: %ws: Updated password for '%ws'.\n",
                           WrittenCredential->TargetName.Buffer,
                           UserName->Buffer ));
            }

        }

    }



}

VOID
CredpUpdatePassword(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_CREDENTIAL NewCredential
    )

/*++

Routine Description:

    This routine updates the password in all credentials to match that of the new credential.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential set.

    NewCredential - Pointer to a credential that was just added to the
        credential set.

Return Values:

    None

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Password;


    //
    // If the credential isn't a domain credential,
    //  we're done.
    //

    if ( !CredpIsDomainCredential( NewCredential->Cred.Type ) ||
         NewCredential->UserName.Length == 0 ) {
        return;
    }

    //
    // Update the password on all matching credentials.
    //

    Password.Buffer = (LPWSTR)NewCredential->Cred.CredentialBlob;
    Password.Length = (USHORT)NewCredential->ClearCredentialBlobSize;
    Password.MaximumLength = (USHORT)NewCredential->Cred.CredentialBlobSize;

    CredpUpdatePassword2( CredentialSets,
                          &NewCredential->UserName,
                          &Password,
                          NewCredential->Cred.Type );

}

VOID
CredpNotifyPasswordChange(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING NewPassword
    )

/*++

Routine Description:

    This routine updates the password of a particular user in the credential manager.

    This routine is called while impersonating the user changing the password.  That
    user isn't necessarily UserName.

Arguments:

    NetbiosDomainName - Netbios domain name of the user whose password was changed

    UserName - User name of the user whose password was changed

    DnsDomainName - If known, Dns Domain Name of the user whose password was changed

    Upn - If known, the Upn of the user whose password was changed

    NewPassword - The new password for the user.

Return Values:

    None

--*/
{
    HANDLE ClientToken;
    LUID LogonId;
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    BOOLEAN CritSectLocked = FALSE;
    UNICODE_STRING LocalUserName;
    UNICODE_STRING EncryptedNewPassword;

    //
    // Got to have at least Netbios DomainName OR DNSDomainName
    //
    if (!ARGUMENT_PRESENT(NetbiosDomainName) &&
        !ARGUMENT_PRESENT(DnsDomainName)) {

        return;
    }

    //
    // Initialization
    //

    LocalUserName.Buffer = NULL;
    EncryptedNewPassword.Buffer = NULL;

    //
    // The password needs to be protected when we put it on the credential
    //

    EncryptedNewPassword.MaximumLength = AllocatedCredBlobSize( NewPassword->Length );
    EncryptedNewPassword.Length = NewPassword->Length;

    SafeAllocaAllocate( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );

    if ( EncryptedNewPassword.Buffer == NULL ) {
        goto Cleanup;
    }

    RtlZeroMemory( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );

    RtlCopyMemory( EncryptedNewPassword.Buffer,
                   NewPassword->Buffer,
                   NewPassword->Length );

    LsaProtectMemory( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );


    //
    // Get the logon id from the token
    //

    Status = NtOpenThreadToken( NtCurrentThread(),
                                TOKEN_QUERY,
                                TRUE,
                                &ClientToken );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    } else {
        TOKEN_STATISTICS TokenStats;
        ULONG ReturnedSize;

        //
        // Get the LogonId
        //

        Status = NtQueryInformationToken( ClientToken,
                                          TokenStatistics,
                                          &TokenStats,
                                          sizeof( TokenStats ),
                                          &ReturnedSize );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Save the logon id
            //

            LogonId = TokenStats.AuthenticationId;
        }

        NtClose( ClientToken );

    }


    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( &LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // Update the password for all <NetbiosDomainName>\<UserName> credentials
    //

    if ( NetbiosDomainName != NULL ) {


        LocalUserName.Length = NetbiosDomainName->Length +
            sizeof(WCHAR) +
            UserName->Length;
        LocalUserName.MaximumLength = LocalUserName.Length;
        SafeAllocaAllocate( LocalUserName.Buffer, LocalUserName.MaximumLength );

        if ( LocalUserName.Buffer == NULL ) {
            goto Cleanup;
        }

        RtlCopyMemory( LocalUserName.Buffer, NetbiosDomainName->Buffer, NetbiosDomainName->Length );
        LocalUserName.Buffer[NetbiosDomainName->Length/sizeof(WCHAR)] = '\\';
        RtlCopyMemory( &LocalUserName.Buffer[(NetbiosDomainName->Length/sizeof(WCHAR)) + 1],
                       UserName->Buffer,
                       UserName->Length );


        CredpUpdatePassword2( &CredentialSets,
                              &LocalUserName,
                              &EncryptedNewPassword,
                              CRED_TYPE_DOMAIN_PASSWORD );

    }


    //
    // Update the password for all <DnsDomainName>\<UserName> credentials
    //

    if ( DnsDomainName != NULL ) {

        if ( LocalUserName.Buffer != NULL ) {
            SafeAllocaFree( LocalUserName.Buffer );
        }

        LocalUserName.Length = DnsDomainName->Length +
                               sizeof(WCHAR) +
                               UserName->Length;
        LocalUserName.MaximumLength = LocalUserName.Length;
        SafeAllocaAllocate( LocalUserName.Buffer, LocalUserName.MaximumLength );

        if ( LocalUserName.Buffer == NULL ) {
            goto Cleanup;
        }

        RtlCopyMemory( LocalUserName.Buffer, DnsDomainName->Buffer, DnsDomainName->Length );
        LocalUserName.Buffer[DnsDomainName->Length/sizeof(WCHAR)] = '\\';
        RtlCopyMemory( &LocalUserName.Buffer[(DnsDomainName->Length/sizeof(WCHAR)) + 1],
                       UserName->Buffer,
                       UserName->Length );


        CredpUpdatePassword2( &CredentialSets,
                              &LocalUserName,
                              &EncryptedNewPassword,
                              CRED_TYPE_DOMAIN_PASSWORD );
    }


    //
    // Update the password for all <Upn> credentials
    //

    if ( Upn != NULL ) {

        CredpUpdatePassword2( &CredentialSets,
                              Upn,
                              &EncryptedNewPassword,
                              CRED_TYPE_DOMAIN_PASSWORD );
    }


    //
    // Cleanup
    //
Cleanup:
    if ( LocalUserName.Buffer != NULL ) {
        SafeAllocaFree( LocalUserName.Buffer );
    }
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    CredpDereferenceCredSets( &CredentialSets );

    if ( EncryptedNewPassword.Buffer != NULL ) {
        SafeAllocaFree( EncryptedNewPassword.Buffer );
    }

}


NTSTATUS
CredpFindBestCredentials(
    IN PLUID LogonId,
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_TARGET_INFO TargetInfo,
    OUT PCANONICAL_CREDENTIAL *BestCredentials,
    OUT PULONG BestCredentialCount
    )

/*++

Routine Description:

    This routine finds the best credentials given a description of the target.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredentialSets - A pointer to the referenced credential set.

    TargetInfo - A description of the various aliases for a target.

    BestCredentials - Returns the best credential for each credential type.

    BestCredentialCount - Returns the number of elements returned in BestCredentials.

Return Values:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCANONICAL_CREDENTIAL Credential;
    PLIST_ENTRY ListEntry;

    ULONG TypeIndex;
    ULONG AliasIndex;

    ULONG Persist;


    //
    // This routine finds the best credentials for each credtype that match the TargetInfo.
    // This array contains the pointers to the found credentials.
    //

    PCANONICAL_CREDENTIAL SavedCredentials[CRED_TYPE_MAXIMUM];
    ULONG AliasIndices[CRED_TYPE_MAXIMUM];

    ULONG CredTypeCount;
    LPDWORD CredTypes;

    //
    // Clear our list of remembered credentials
    //

    RtlZeroMemory( &SavedCredentials, sizeof(SavedCredentials) );
    for ( TypeIndex=0; TypeIndex<CRED_TYPE_MAXIMUM; TypeIndex++ ) {
        AliasIndices[TypeIndex] = CRED_MAX_ALIASES;
    }

    //
    // Loop through the list of credentials finding all that match the TargetInfo
    //
    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets->SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Ignore unsupported cred types
            //

            if ( CredDisableDomainCreds &&
                 CredpIsDomainCredential( Credential->Cred.Type ) ) {

                continue;
            }

            //
            // If the credential matches,
            //  save it.
            //

            if ( CredpCompareCredToTargetInfo( TargetInfo,
                                               Credential,
                                               &AliasIndex ) ) {

                //
                // Compute indices into the array of saved credentials.
                //
                // Rely on the following:
                //   CompareCred* validated that the cred is a domain cred
                //   CompareCred* only returns TRUE for well known CredType values.

                TypeIndex = Credential->Cred.Type;


                //
                // If we've already found a credential in this category,
                //  keep the "better" one.
                //

                if ( SavedCredentials[TypeIndex] != NULL ) {

                    DebugLog(( DEB_TRACE_CRED,
                               "CredpFindBestCredentials: %ws: %ws: Two credentials match same target info criterias.\n",
                               SavedCredentials[TypeIndex]->TargetName.Buffer,
                               Credential->TargetName.Buffer ));

                    //
                    // If the existing credential is more specific than this one,
                    //  Keep the existing.
                    //

                    if ( AliasIndices[TypeIndex] < AliasIndex ) {

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (AI1).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If this credential is more specific than the saved one,
                    //  save this one.
                    //

                    } else if ( AliasIndices[TypeIndex] > AliasIndex ) {
                        SavedCredentials[TypeIndex] = Credential;
                        AliasIndices[TypeIndex] = AliasIndex;

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (AI1).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));

                    //
                    // If the existing credential has a more specific wildcard,
                    //  keep the existing.
                    //

                    } else if ( AliasIndex == CRED_WILDCARD_SERVER_NAME &&
                                SavedCredentials[TypeIndex]->TargetName.Length >
                                Credential->TargetName.Length ) {


                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (WC1).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If the existing credential has a less specific wildcard,
                    //  save this one.
                    //

                    } else if ( AliasIndex == CRED_WILDCARD_SERVER_NAME &&
                                SavedCredentials[TypeIndex]->TargetName.Length <
                                Credential->TargetName.Length ) {

                        SavedCredentials[TypeIndex] = Credential;
                        AliasIndices[TypeIndex] = AliasIndex;

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (WC2).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If one credential has a target alias and the other doesn't,
                    //  keep the one without an alias,
                    //  this is the case when the target info passes in a netbios name
                    //  and there is both a netbios credential and a DNS credential.
                    //  Prefer the netbios credential.
                    //

                    } else if ( SavedCredentials[TypeIndex]->TargetAlias.Length == 0 ) {

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (AL).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If one credential is session specific,
                    //  keep it (allowing the user to override persistent credentials).
                    //

                    } else if ( SavedCredentials[TypeIndex]->Cred.Persist == CRED_PERSIST_SESSION ) {

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (PE).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // Otherwise, just save this one
                    //

                    } else {
                        SavedCredentials[TypeIndex] = Credential;
                        AliasIndices[TypeIndex] = AliasIndex;

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (default).\n",
                                   Credential->TargetName.Buffer ));
                    }

                //
                // Otherwise, just save this one
                //

                } else {
                    SavedCredentials[TypeIndex] = Credential;
                    AliasIndices[TypeIndex] = AliasIndex;
                }

            }
        }

    }

    //
    // Don't return a *Session credential if our logon creds should work
    //
    // The *Session cred is a hack to force us to always use RAS dial creds on all
    //  connections to the dialed up network.  However, we don't know what network a
    //  server is on.  We still want to be able to use logon creds on the LAN.  Our
    //  best bet is to use logon creds if the server is in the same domain as our logon
    //  creds.
    //
    // If we found a password cred,
    //  and that cred is the *Session cred,
    //  and the logon creds should work,
    //  ignore the *Session cred.

    //

    if ( SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD] != NULL  &&
         AliasIndices[CRED_TYPE_DOMAIN_PASSWORD] == CRED_UNIVERSAL_SESSION_NAME ) {

        Status = CredpLogonCredsMatchTargetInfo( LogonId, TargetInfo );

        if ( NT_SUCCESS( Status )) {
            SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD] = NULL;
        } else if ( Status != STATUS_NO_MATCH ) {
            return Status;
        }

    }

    //
    // Decide the order to return the credentials in
    //

    if ( TargetInfo->CredTypeCount != 0 ) {

        // Use the order specified by the auth package
        CredTypeCount = TargetInfo->CredTypeCount;
        CredTypes = TargetInfo->CredTypes;

    } else {

        // Use the default order
        CredTypeCount = sizeof(CredTypeDefaultOrder)/sizeof(CredTypeDefaultOrder[0]);
        CredTypes = CredTypeDefaultOrder;

    }


    //
    // Return the credentials to the caller.
    //  Only return the ones requested by the caller
    //

    *BestCredentialCount = 0;

    for ( TypeIndex=0; TypeIndex<CredTypeCount; TypeIndex++ ) {

        ASSERT( CredTypes[TypeIndex] < CRED_TYPE_MAXIMUM );
        if ( CredTypes[TypeIndex] < CRED_TYPE_MAXIMUM ) {

            //
            // If we have a saved credential,
            //  return it.
            //

            if ( SavedCredentials[CredTypes[TypeIndex]] != NULL ) {
                BestCredentials[*BestCredentialCount] = SavedCredentials[CredTypes[TypeIndex]];
                *BestCredentialCount += 1;
            }
        }

    }

    Status = STATUS_SUCCESS;

    return Status;
}


extern "C"
NTSTATUS
CrediWrite(
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWrite API creates a new credential or modifies an existing
    credential in the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    The CredWrite API creates a credential if none already exists by the
    specified TargetName.  If the specified TargetName already exists, the
    specified credential replaces the existing one.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        Reserved.  Must be zero.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.


Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    PCANONICAL_CREDENTIAL PassedCredential = NULL;
    BOOLEAN CritSectLocked = FALSE;


    //
    // Validate the flags
    //

#define CREDP_WRITE_VALID_FLAGS CRED_PRESERVE_CREDENTIAL_BLOB

    if ( (Flags & ~CREDP_WRITE_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the passed in credential
    //

    Status = CredpValidateCredential( CredFlags,
                                      NULL,     // No TargetInfo
                                      Credential,
                                      &PassedCredential );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // Write the credential to the credential set.
    //

    Status = CredpWriteCredential( &CredentialSets,
                                   &PassedCredential,
                                   FALSE,   // Creds are not from persisted file
                                   TRUE,    // Update pin in CSP
                                   TRUE,    // Cred has been prompted for
                                   Flags,
                                   NULL,
                                   NULL,
                                   NULL );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Update the password for this user on all credentials.
    //

    CredpUpdatePassword( &CredentialSets,
                         PassedCredential );


    PassedCredential = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    if ( PassedCredential != NULL ) {
        LsapFreeLsaHeap( PassedCredential );
    }
    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
NTSTATUS
CrediRead (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags,
    OUT PENCRYPTED_CREDENTIALW *Credential
    )

/*++

Routine Description:

    The CredRead API reads a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned
        CREDP_FLAGS_USE_MIDL_HEAP - If specified, use MIDL_user_allocate to allocate memory.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetName - Specifies the name of the credential to read.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Credential - Returns a pointer to the credential.  The returned buffer
        must be freed by calling LsapFreeLsaHeap.
        If CREDP_FLAGS_USE_MIDL_HEAP was specified, use MIDL_user_free.

Return Values:

    STATUS_NOT_FOUND - There is no credential with the specified TargetName.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
        there is no credential set associated with this logon session.
        Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    PCANONICAL_CREDENTIAL TempCredential;
    UNICODE_STRING TargetNameString;
    DWORD TargetNameSize;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    Status = CredpValidateTargetName( TargetName,
                                      Type,
                                      MightBeUsernameTarget,
                                      NULL,         // Don't know user name
                                      NULL,         // Don't know persist
                                      &TargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Find the credential
    //

    TargetNameString.Buffer = TargetName;
    TargetNameString.MaximumLength = (USHORT) TargetNameSize;
    TargetNameString.Length = TargetNameString.MaximumLength - sizeof(WCHAR);

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    TempCredential = CredpFindCredential(
                            &CredentialSets,
                            &TargetNameString,
                            Type );

    if ( TempCredential == NULL ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Grab a copy of the credential to return to the caller.
    //

    *Credential = CredpCloneCredential( &CredentialSets, CredFlags, TempCredential );

    if ( *Credential == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
VOID
CrediFreeCredentials (
    IN ULONG Count,
    IN PENCRYPTED_CREDENTIALW *Credentials OPTIONAL
    )

/*++

Routine Description:

    This routine frees the buffers allocated by CrediEnumerate or
    CrediReadDomainCredentials.

Arguments:

    Count - Specifies the number of credentials in Credentials.

    Credentials - A pointer to an array of pointers to credentials.

Return Values:

    None.

--*/
{
    ULONG i;

    if ( Credentials != NULL ) {
        for ( i=0; i<Count; i++ ) {
            if ( Credentials[i] != NULL ) {
                MIDL_user_free( Credentials[i] );
            }
        }
        MIDL_user_free( Credentials );
    }
}


extern "C"
NTSTATUS
CrediEnumerate (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN LPWSTR Filter,
    IN ULONG Flags,
    OUT PULONG Count,
    OUT PENCRYPTED_CREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredEnumerate API enumerates the credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    Filter - Specifies a filter for the returned credentials.  Only credentials
        with a TargetName matching the filter will be returned.  The filter specifies
        a name prefix followed by an asterisk.  For instance, the filter "FRED*" will
        return all credentials with a TargetName beginning with the string "FRED".

        If NULL is specified, all credentials will be returned.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CrediFreeCredentials

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credentials matching the specified Filter.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    ULONG Persist;
    PCANONICAL_CREDENTIAL TempCredential;
    PENCRYPTED_CREDENTIALW *TempCredentials = NULL;
    DWORD FilterSize;
    ULONG CredentialCount = 0;
    ULONG CredentialIndex;
    PLIST_ENTRY ListEntry;
    BOOLEAN CritSectLocked = FALSE;

    UNICODE_STRING PassedFilter;
    BOOLEAN Wildcarded = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    if ( !CredpValidateString( Filter,
                               max(CRED_MAX_GENERIC_TARGET_NAME_LENGTH, CRED_MAX_DOMAIN_TARGET_NAME_LENGTH),
                               TRUE,   // NULL is OK
                               &FilterSize ) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CrediEnumerate: Invalid Filter buffer.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Canonicalize the filter
    //

    if ( FilterSize != 0 ) {
        PassedFilter.Buffer = Filter;
        PassedFilter.Length = (USHORT)(FilterSize - sizeof(WCHAR));
        PassedFilter.MaximumLength = (USHORT)FilterSize;

        if ( Filter[(PassedFilter.Length-sizeof(WCHAR))/sizeof(WCHAR)] == '*' ) {
            PassedFilter.Length -= sizeof(WCHAR);
            PassedFilter.MaximumLength -= sizeof(WCHAR);
            Wildcarded = TRUE;
        }
    } else {
        RtlInitUnicodeString( &PassedFilter, NULL );
    }



    //
    // Count the number of credentials the match the filter
    //

    CredentialCount = 0;
    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // Walk each credential set
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets.SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( &CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            UNICODE_STRING TempTargetName;


            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Ignore unsupported cred types
            //

            if ( CredDisableDomainCreds &&
                 CredpIsDomainCredential( TempCredential->Cred.Type ) ) {

                continue;
            }


            //
            // If wildcarding,
            //  compare the filter to the prefix of the target name.
            //

            TempTargetName = TempCredential->TargetName;
            if ( Wildcarded && TempTargetName.Length > PassedFilter.Length ) {

                TempTargetName.Length = PassedFilter.Length;
                TempTargetName.MaximumLength = PassedFilter.MaximumLength;
            }

            if ( FilterSize == 0 ||
                 RtlEqualUnicodeString( &PassedFilter,
                                        &TempTargetName,
                                        TRUE ) ) {
                CredentialCount++;
                TempCredential->ReturnMe = TRUE;
            } else {
                TempCredential->ReturnMe = FALSE;
            }

        }
    }

    if ( CredentialCount == 0 ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Allocate a buffer to return the credentials in
    //

    TempCredentials = (PENCRYPTED_CREDENTIALW *) MIDL_user_allocate( CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );

    if ( TempCredentials == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( TempCredentials, CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );


    //
    // Grab a copy of each of the credentials to return to the caller.
    //

    CredentialIndex = 0;
    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets.SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( &CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Ignore unsupported cred types
            //

            if ( CredDisableDomainCreds &&
                 CredpIsDomainCredential( TempCredential->Cred.Type ) ) {

                continue;
            }

            if ( TempCredential->ReturnMe ) {
                TempCredentials[CredentialIndex] =
                    CredpCloneCredential( &CredentialSets,
                                          CredFlags | CREDP_FLAGS_USE_MIDL_HEAP,
                                          TempCredential );

                if ( TempCredentials[CredentialIndex] == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                CredentialIndex ++;
            }

        }

    }

    *Count = CredentialCount;
    *Credentials = TempCredentials;
    TempCredentials = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    if ( TempCredentials != NULL ) {
        CrediFreeCredentials( CredentialCount, TempCredentials );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
NTSTATUS
CrediWriteDomainCredentials (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWriteDomainCredentials API writes a new domain
    credential to the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    CredWriteDomainCredentials differs from CredWrite in that it handles
    the idiosyncrasies of domain (CRED_TYPE_DOMAIN_*)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsTreeName.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        No flags are currently defined.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetInfo - Specifies the target information identifying the target server.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified
            or the credential specified did not have the Type field set to
            CRED_TYPE_DOMAIN_PASSWORD, CRED_TYPE_DOMAIN_CERTIFICATE or CRED_TYPE_DOMAIN_VISIBLE_PASSWORD.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    PCANONICAL_CREDENTIAL OldCredential = NULL;
    PPROMPT_DATA OldPromptData = NULL;
    PPROMPT_DATA NewPromptData = NULL;
    PCANONICAL_CREDENTIAL PassedCredential = NULL;
    PCANONICAL_TARGET_INFO CanonicalTargetInfo = NULL;
    ULONG AliasIndex;
    BOOLEAN CritSectLocked = FALSE;

    ULONG CredentialCount = 0;
    PCANONICAL_CREDENTIAL BestCredentials[CRED_TYPE_MAXIMUM];
    ULONG CredentialIndex;

    //
    // Validate the flags
    //
#define CREDP_WRITE_DOM_VALID_FLAGS CRED_PRESERVE_CREDENTIAL_BLOB

    if ( (Flags & ~CREDP_WRITE_DOM_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the TargetInfo
    //

    Status = CredpValidateTargetInfo( TargetInfo,
                                      &CanonicalTargetInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Validate the passed in credential
    //

    Status = CredpValidateCredential( CredFlags,
                                      CanonicalTargetInfo,
                                      Credential,
                                      &PassedCredential );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( !CredpIsDomainCredential(PassedCredential->Cred.Type) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CrediWriteDomainCredential: Only allow for domain credentials.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // Write the credential to the credential set.
    //

    Status = CredpWriteCredential( &CredentialSets,
                                   &PassedCredential,
                                   FALSE,   // Creds are not from persisted file
                                   TRUE,    // Update pin in CSP
                                   TRUE,    // Cred has been prompted for
                                   Flags,
                                   &OldCredential,
                                   &OldPromptData,
                                   &NewPromptData );


    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Ensure the written credential is the best credential for this target info
    //

    Status = CredpFindBestCredentials( LogonId,
                                       &CredentialSets,
                                       CanonicalTargetInfo,
                                       BestCredentials,
                                       &CredentialCount );

    if ( NT_SUCCESS(Status) ) {

        for ( CredentialIndex = 0; CredentialIndex<CredentialCount; CredentialIndex++ ) {

            if ( PassedCredential == BestCredentials[CredentialIndex] ) {
                break;
            }

        }

        if ( CredentialIndex >= CredentialCount ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CrediWriteDomainCredential: Credential isn't best credential for target info.\n" ));
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if ( !NT_SUCCESS(Status) ) {

        //
        // Remove the new credential from the cred set.
        //

        RemoveEntryList( &PassedCredential->Next );

        //
        // Remove the new prompt data from the cred set.
        //

        if ( NewPromptData != NULL ) {
            RemoveEntryList( &NewPromptData->Next );
            LsapFreeLsaHeap( NewPromptData );
        }

        //
        // Put the old credential back in the cred set.
        //

        if ( OldCredential != NULL ) {
            InsertHeadList(
                &PersistToCredentialSet( &CredentialSets, OldCredential->Cred.Persist )->Credentials,
                &OldCredential->Next );
            OldCredential = NULL;

            //
            // Put the old prompt data back in the cred set.
            //

            if ( OldPromptData != NULL ) {
                InsertHeadList(
                    &CredentialSets.SessionCredSets->PromptData,
                    &OldPromptData->Next );
                OldPromptData = NULL;
            }
        }

        goto Cleanup;
    }

    //
    // Update the password for this user on all credentials.
    //

    CredpUpdatePassword( &CredentialSets,
                         PassedCredential );


    PassedCredential = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    if ( PassedCredential != NULL ) {
        LsapFreeLsaHeap( PassedCredential );
    }
    if ( OldCredential != NULL ) {
        LsapFreeLsaHeap( OldCredential );
    }
    if ( OldPromptData != NULL ) {
        LsapFreeLsaHeap( OldPromptData );
    }
    if ( CanonicalTargetInfo != NULL ) {
        LsapFreeLsaHeap( CanonicalTargetInfo );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}


extern "C"
NTSTATUS
CrediReadDomainCredentials (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN ULONG Flags,
    OUT PULONG Count,
    OUT PENCRYPTED_CREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredReadDomainCredentials API reads the domain credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    CredReadDomainCredentials differs from CredRead in that it handles the
    idiosyncrasies of domain (CRED_TYPE_DOMAIN_*)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsTreeName. This API returns
    the most specific credentials that match the naming parameters.  That is, if there
    is a credential that matches the target server name and a credential that matches
    the target domain name, only the server specific credential is returned.  This is
    the credential that would be used.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned
        CREDP_FLAGS_DONT_CACHE_TI - TargetInformation shouldn't be cached for CredGetTargetInfo

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetInfo - Specifies the target information identifying the target server.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CrediFreeCredentials
Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified.

        STATUS_NOT_FOUND - There are no credentials matching the specified naming parameters.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    PENCRYPTED_CREDENTIALW *TempCredentials = NULL;
    PCANONICAL_TARGET_INFO CanonicalTargetInfo = NULL;
    ULONG CredentialCount = 0;
    PCANONICAL_CREDENTIAL BestCredentials[CRED_TYPE_MAXIMUM];
    ULONG CredentialIndex;
    PLIST_ENTRY ListEntry;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }


    //
    // Validate the TargetInfo
    //

    Status = CredpValidateTargetInfo( TargetInfo,
                                      &CanonicalTargetInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Determine the best credential of each type.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;
    Status = CredpFindBestCredentials( LogonId,
                                       &CredentialSets,
                                       CanonicalTargetInfo,
                                       BestCredentials,
                                       &CredentialCount );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( CredentialCount == 0 ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Allocate a buffer to return the credentials in
    //

    TempCredentials = (PENCRYPTED_CREDENTIALW *) MIDL_user_allocate( CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );

    if ( TempCredentials == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( TempCredentials, CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );


    //
    // Grab a copy of each of the credentials to return to the caller.
    //

    for ( CredentialIndex = 0; CredentialIndex<CredentialCount; CredentialIndex++ ) {

        TempCredentials[CredentialIndex] =
            CredpCloneCredential( &CredentialSets,
                                  CredFlags | CREDP_FLAGS_USE_MIDL_HEAP,
                                  BestCredentials[CredentialIndex] );

        if ( TempCredentials[CredentialIndex] == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

    }


    *Count = CredentialCount;
    *Credentials = TempCredentials;
    TempCredentials = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:

    if ( CanonicalTargetInfo != NULL ) {

        //
        // Cache this target info
        //
        if ( CritSectLocked &&
             (CredFlags & CREDP_FLAGS_DONT_CACHE_TI) == 0  &&
             (CanonicalTargetInfo->Flags & CRED_TI_USERNAME_TARGET) == 0 ) {

            if ( CredpCacheTargetInfo( &CredentialSets, CanonicalTargetInfo )) {
                CanonicalTargetInfo = NULL;
            }
        }

        //
        // Free the target info if it is still around
        //

        if ( CanonicalTargetInfo != NULL ) {
            LsapFreeLsaHeap( CanonicalTargetInfo );
        }
    }

    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    if ( TempCredentials != NULL ) {
        CrediFreeCredentials( CredentialCount, TempCredentials );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}


extern "C"
NTSTATUS
CrediDelete (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredDelete API deletes a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        Must be zero.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetName - Specifies the name of the credential to delete.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    PCANONICAL_CREDENTIAL TempCredential;
    PPROMPT_DATA PromptData;
    UNICODE_STRING TargetNameString;
    DWORD TargetNameSize;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    Status = CredpValidateTargetName( TargetName,
                                      Type,
                                      MightBeUsernameTarget,
                                      NULL,         // Don't know user name
                                      NULL,         // Don't know persist
                                      &TargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }



    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Find the credential
    //

    TargetNameString.Buffer = TargetName;
    TargetNameString.MaximumLength = (USHORT) TargetNameSize;
    TargetNameString.Length = TargetNameString.MaximumLength - sizeof(WCHAR);

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    TempCredential = CredpFindCredential(
                            &CredentialSets,
                            &TargetNameString,
                            Type );

    if ( TempCredential == NULL ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Find the prompt data (if any)
    //

    PromptData = CredpFindPromptData(
                            &CredentialSets,
                            &TargetNameString,
                            Type,
                            TempCredential->Cred.Persist );

    //
    // Mark the credential set as modified.
    //

    CredpMarkDirty( &CredentialSets, TempCredential->Cred.Persist, NULL );

    //
    // Delink and delete the credential.
    //

    RemoveEntryList( &TempCredential->Next );
    LsapFreeLsaHeap( TempCredential );

    //
    // Delink and delete the prompt data
    //

    if ( PromptData != NULL ) {
        RemoveEntryList( &PromptData->Next );
        LsapFreeLsaHeap( PromptData );
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

NTSTATUS
CrediRename (
    IN PLUID LogonId,
    IN LPWSTR OldTargetName,
    IN LPWSTR NewTargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredRename API renames a credential in the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    OldTargetName - Specifies the current name of the credential to rename.

    NewTargetName - Specifies the new name of the credential.

    Type - Specifies the Type of the credential to rename
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified OldTargetName.

        STATUS_OBJECT_NAME_COLLISION - There is already a credential named NewTargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;

    PPROMPT_DATA OldPromptData;
    UNICODE_STRING OldTargetNameString;
    DWORD OldTargetNameSize;
    PCANONICAL_CREDENTIAL OldCredential;

    UNICODE_STRING NewTargetNameString;
    DWORD NewTargetNameSize;
    PCANONICAL_CREDENTIAL NewCredential;

    ENCRYPTED_CREDENTIALW LocalCredential;
    PCANONICAL_CREDENTIAL WrittenCredential;


    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;



    //
    // Find the old credential
    //

    Status = CredpValidateTargetName( OldTargetName,
                                      Type,
                                      MightBeUsernameTarget,
                                      NULL,         // Don't know user name
                                      NULL,         // Don't know persist
                                      &OldTargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }

    OldTargetNameString.Buffer = OldTargetName;
    OldTargetNameString.MaximumLength = (USHORT) OldTargetNameSize;
    OldTargetNameString.Length = OldTargetNameString.MaximumLength - sizeof(WCHAR);

    OldCredential = CredpFindCredential(
                            &CredentialSets,
                            &OldTargetNameString,
                            Type );

    if ( OldCredential == NULL ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }




    //
    // Find the New credential
    //

    Status = CredpValidateTargetName( NewTargetName,
                                      Type,
                                      (OldCredential->Cred.Flags & CRED_FLAGS_USERNAME_TARGET) ?
                                            IsUsernameTarget :
                                            IsNotUsernameTarget,
                                      &OldCredential->Cred.UserName,
                                      &OldCredential->Cred.Persist,
                                      &NewTargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }

    NewTargetNameString.Buffer = NewTargetName;
    NewTargetNameString.MaximumLength = (USHORT) NewTargetNameSize;
    NewTargetNameString.Length = NewTargetNameString.MaximumLength - sizeof(WCHAR);

    NewCredential = CredpFindCredential(
                            &CredentialSets,
                            &NewTargetNameString,
                            Type );

    if ( NewCredential != NULL ) {
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto Cleanup;
    }

    //
    // Find the prompt data (if any)
    //

    OldPromptData = CredpFindPromptData(
                            &CredentialSets,
                            &OldTargetNameString,
                            Type,
                            OldCredential->Cred.Persist );


    //
    // Write the new credential
    //
    // Clear the TargetAlias.  It'll either be syntactically invalid and fail.  Or
    //  worse, it'll be syntactically valid but semantic nonsense.
    //

    LocalCredential.Cred = OldCredential->Cred;
    LocalCredential.ClearCredentialBlobSize = OldCredential->ClearCredentialBlobSize;
    LocalCredential.Cred.TargetName = NewTargetName;
    LocalCredential.Cred.TargetAlias = NULL;

    Status = CredpWriteMorphedCredential(
                        &CredentialSets,
                        !ShouldPromptNow( OldPromptData ), // Preserve the prompted for state
                        NULL,       // No Target info
                        &LocalCredential,
                        &WrittenCredential );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Mark the credential set as modified.
    //

    CredpMarkDirty( &CredentialSets, OldCredential->Cred.Persist, NULL );

    //
    // Delink and delete the old credential.
    //

    RemoveEntryList( &OldCredential->Next );
    LsapFreeLsaHeap( OldCredential );

    //
    // Delink and delete the prompt data
    //

    if ( OldPromptData != NULL ) {
        RemoveEntryList( &OldPromptData->Next );
        LsapFreeLsaHeap( OldPromptData );
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
NTSTATUS
CrediGetTargetInfo (
    IN PLUID LogonId,
    IN LPWSTR TargetServerName,
    IN ULONG Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )

/*++

Routine Description:

    The CredGetTargetInfo API gets all of the known target name information
    for the named target machine.  This API is executed locally
    and does not need any particular privilege.  The information returned is expected
    to be passed to the CredReadDomainCredentials and CredWriteDomainCredentials APIs.
    The information should not be used for any other purpose.

    Authentication packages compute TargetInfo when attempting to authenticate to
    ServerName.  The authentication packages cache this target information to make it
    available to CredGetTargetInfo.  Therefore, the target information will only be
    available if we've recently attempted to authenticate to ServerName.

Arguments:

    LogonId - LogonId of the session the target info is associated with

    TargetServerName - This parameter specifies the name of the machine to get the information
        for.

    Flags - Specifies flags to control the operation of the API.

        CRED_ALLOW_NAME_RESOLUTION - Specifies that if no target info can be found for
            TargetName, then name resolution should be done on TargetName to convert it
            to other forms.  If target info exists for any of those other forms, that
            target info is returned.  Currently only DNS name resolution is done.

            This bit is useful if the application doesn't call the authentication package
            directly.  The application might pass the TargetName to another layer of software
            to authenticate to the server.  That layer of software might resolve the name and
            pass the resolved name to the authentication package.  As such, there will be no
            target info for the original TargetName.

    TargetInfo - Returns a pointer to the target information.
        At least one of the returned fields of TargetInfo will be non-NULL.

Return Values:

    The following status codes may be returned:

        STATUS_NO_MEMORY - There isn't enough memory to complete the operation.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

--*/

{
    NTSTATUS Status;
    DWORD WinStatus;
    PCANONICAL_TARGET_INFO CanonicalTargetInfo;
    PCREDENTIAL_TARGET_INFORMATIONW LocalTargetInfo = NULL;
    ULONG TargetServerNameSize;
    LPBYTE Where;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;
    PDNS_RECORD DnsARecords = NULL;

#define CREDP_GTI_VALID_FLAGS CRED_ALLOW_NAME_RESOLUTION

    //
    // Validate the flags
    //

    if ( (Flags & ~CREDP_GTI_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    if ( !CredpValidateString( TargetServerName,
                               CRED_MAX_DOMAIN_TARGET_NAME_LENGTH,
                               FALSE,   // NULL not OK
                               &TargetServerNameSize ) ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "CrediGetTargetInfo: Invalid TargetServerName buffer.\n" ));
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Lock the credential set.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // See if the named server can be found directly
    //

    CanonicalTargetInfo = CredpFindTargetInfo( &CredentialSets, TargetServerName );

    if ( CanonicalTargetInfo == NULL ) {
        PDNS_RECORD DnsRecord;

        //
        // If the caller doesn't wants us to try name resolution in an attempt for find the target info
        //  we're done.
        //

        if ( (Flags & CRED_ALLOW_NAME_RESOLUTION) == 0 ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Query DNS for the name
        //

        WinStatus = DnsQuery_W(
                         TargetServerName,
                         DNS_TYPE_A,
                         0,     // No special flags
                         NULL,  // No special DNS servers
                         &DnsARecords,
                         NULL );

        if ( WinStatus != NO_ERROR ) {
            // Don't confuse the caller with a more specific status
            Status = STATUS_NOT_FOUND;
            goto Cleanup;

        }

        //
        // Find the first A or AAAA record
        //
        // Only look up the first name returned from DNS.  That's the name the redir used when
        // creating the SPN that the authentication packages pass us in the TargetName.
        //

        for ( DnsRecord = DnsARecords;
              DnsRecord != NULL;
              DnsRecord = DnsRecord->pNext ) {

            if ( DnsRecord->wType == DNS_TYPE_A ||
                 DnsRecord->wType == DNS_TYPE_AAAA ) {

                //
                // See if the named server can be found directly
                //

                CanonicalTargetInfo = CredpFindTargetInfo( &CredentialSets, DnsRecord->pName );

                break;
            }

        }

        if ( CanonicalTargetInfo == NULL ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

    }


    //
    // Allocate a structure to return to the caller
    //

    LocalTargetInfo = (PCREDENTIAL_TARGET_INFORMATIONW) MIDL_user_allocate(
                        sizeof(*LocalTargetInfo) +
                        CanonicalTargetInfo->CredTypeCount * sizeof(DWORD) +
                        CanonicalTargetInfo->TargetName.MaximumLength +
                        CanonicalTargetInfo->NetbiosServerName.MaximumLength +
                        CanonicalTargetInfo->DnsServerName.MaximumLength +
                        CanonicalTargetInfo->NetbiosDomainName.MaximumLength +
                        CanonicalTargetInfo->DnsDomainName.MaximumLength +
                        CanonicalTargetInfo->DnsTreeName.MaximumLength +
                        CanonicalTargetInfo->PackageName.MaximumLength );

    if ( LocalTargetInfo == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( LocalTargetInfo, sizeof(*LocalTargetInfo) );
    Where = (LPBYTE) (LocalTargetInfo+1);

    //
    // Copy the constant size data
    //

    LocalTargetInfo->Flags = CanonicalTargetInfo->Flags;

    //
    // Copy the DWORD aligned data
    //

    LocalTargetInfo->CredTypeCount = CanonicalTargetInfo->CredTypeCount;
    if ( LocalTargetInfo->CredTypeCount != 0 ) {
        LocalTargetInfo->CredTypes = (LPDWORD)Where;
        RtlCopyMemory( Where, CanonicalTargetInfo->CredTypes, CanonicalTargetInfo->CredTypeCount * sizeof(DWORD) );
        Where += CanonicalTargetInfo->CredTypeCount * sizeof(DWORD);
    } else {
        LocalTargetInfo->CredTypes = NULL;
    }

    //
    // Copy the 2-byte aligned data
    //

    if ( CanonicalTargetInfo->TargetName.Length != 0 ) {

        LocalTargetInfo->TargetName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->TargetName,
                       CanonicalTargetInfo->TargetName.Buffer,
                       CanonicalTargetInfo->TargetName.MaximumLength );

        Where += CanonicalTargetInfo->TargetName.MaximumLength;
    }

    if ( CanonicalTargetInfo->NetbiosServerName.Length != 0 ) {

        LocalTargetInfo->NetbiosServerName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->NetbiosServerName,
                       CanonicalTargetInfo->NetbiosServerName.Buffer,
                       CanonicalTargetInfo->NetbiosServerName.MaximumLength );

        Where += CanonicalTargetInfo->NetbiosServerName.MaximumLength;
    }

    if ( CanonicalTargetInfo->DnsServerName.Length != 0 ) {

        LocalTargetInfo->DnsServerName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->DnsServerName,
                       CanonicalTargetInfo->DnsServerName.Buffer,
                       CanonicalTargetInfo->DnsServerName.MaximumLength );

        Where += CanonicalTargetInfo->DnsServerName.MaximumLength;
    }

    if ( CanonicalTargetInfo->NetbiosDomainName.Length != 0 ) {

        LocalTargetInfo->NetbiosDomainName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->NetbiosDomainName,
                       CanonicalTargetInfo->NetbiosDomainName.Buffer,
                       CanonicalTargetInfo->NetbiosDomainName.MaximumLength );

        Where += CanonicalTargetInfo->NetbiosDomainName.MaximumLength;
    }

    if ( CanonicalTargetInfo->DnsDomainName.Length != 0 ) {

        LocalTargetInfo->DnsDomainName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->DnsDomainName,
                       CanonicalTargetInfo->DnsDomainName.Buffer,
                       CanonicalTargetInfo->DnsDomainName.MaximumLength );

        Where += CanonicalTargetInfo->DnsDomainName.MaximumLength;
    }

    if ( CanonicalTargetInfo->DnsTreeName.Length != 0 ) {

        LocalTargetInfo->DnsTreeName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->DnsTreeName,
                       CanonicalTargetInfo->DnsTreeName.Buffer,
                       CanonicalTargetInfo->DnsTreeName.MaximumLength );

        Where += CanonicalTargetInfo->DnsTreeName.MaximumLength;
    }

    if ( CanonicalTargetInfo->PackageName.Length != 0 ) {

        LocalTargetInfo->PackageName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->PackageName,
                       CanonicalTargetInfo->PackageName.Buffer,
                       CanonicalTargetInfo->PackageName.MaximumLength );

        Where += CanonicalTargetInfo->PackageName.MaximumLength;
    }

    //
    // Return the information to the caller
    //

    *TargetInfo = LocalTargetInfo;
    Status = STATUS_SUCCESS;


    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    if ( DnsARecords != NULL ) {
        DnsRecordListFree( DnsARecords, DnsFreeRecordListDeep );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}

NTSTATUS
CrediGetSessionTypes (
    IN PLUID LogonId,
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )

/*++

Routine Description:

    CredGetSessionTypes returns the maximum persistence supported by the current logon
    session.

    For whistler, CRED_PERSIST_LOCAL_MACHINE and CRED_PERSIST_ENTERPRISE credentials can not
    be stored for sessions where the profile is not loaded.  If future releases, credentials
    might not be associated with the user's profile.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    MaximumPersistCount - Specifies the number of elements in the MaximumPersist array.
        The caller should specify CRED_TYPE_MAXIMUM for this parameter.

    MaximumPersist - Returns the maximum persistance supported by the current logon session for
        each credential type.  Index into the array with one of the CRED_TYPE_* defines.
        Returns CRED_PERSIST_NONE if no credential of this type can be stored.
        Returns CRED_PERSIST_SESSION if only session specific credential may be stored.
        Returns CRED_PERSIST_LOCAL_MACHINE if session specific and machine specific credentials
            may be stored.
        Returns CRED_PERSIST_ENTERPRISE if any credential may be stored.

Return Values:

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;
    ULONG i;

    PCREDENTIAL_SET CredentialSet;
    ULONG Persist;

    //
    // Validate the parameters
    //

    if ( MaximumPersistCount != 0 && MaximumPersist == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Avoid huge buffers
    //  Allow some leeway to allow new applications to run on old OSes.
    //
    if ( MaximumPersistCount > CRED_TYPE_MAXIMUM+1000 ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Lock the credential set.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // Loop through the list filling in each element
    //

    for ( i=0; i<MaximumPersistCount; i++ ) {

        //
        // The default value depends on whether the profile is loaded.
        //

        if ( CredentialSets.SessionCredSets->ProfileLoaded ) {
            MaximumPersist[i] = CRED_PERSIST_ENTERPRISE;
        } else {
            MaximumPersist[i] = CRED_PERSIST_SESSION;
        }

        //
        // Some types can be disabled
        //

        if ( i == CRED_TYPE_GENERIC ) {
            /* Nothing to do here */


        //
        // Disable domain credentials based on policy
        //
        } else if ( CredpIsDomainCredential(i) ) {
            if ( CredDisableDomainCreds ) {

                MaximumPersist[i] = CRED_PERSIST_NONE;

            } else if ( CredIsPersonal &&
                        i != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {

                MaximumPersist[i] = CRED_PERSIST_NONE;
            }

        //
        // Disable all types we don't understand
        //
        } else {
            MaximumPersist[i] = CRED_PERSIST_NONE;
        }

    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}


NTSTATUS
CrediProfileLoaded (
    IN PLUID LogonId
    )

/*++

Routine Description:

    The CredProfileLoaded API is a private API used by LoadUserProfile to notify the
    credential manager that the profile for the current user has been loaded.

    The caller must be impersonating the logged on user.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    DWORD WinStatus;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;

    PCREDENTIAL_SET CredentialSet;
    ULONG Persist;

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {

        //
        // This is a notification API.  Just because there are no credentials, doesn't
        // mean the profile load should fail.  Indeed, it is already finished.
        //
        if ( Status == STATUS_NO_SUCH_LOGON_SESSION ) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // Lock the credential set.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // Mark it that the profile is now loaded.
    //

    CredentialSets.SessionCredSets->ProfileLoaded = TRUE;


    //
    // Loop through the list of credential sets reading each
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        //
        // Ignore non-persistent credential sets
        //

        if ( Persist == CRED_PERSIST_SESSION ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( &CredentialSets, Persist );

        //
        // If this cred set hasn't been read yet,
        //  read it now.
        //

        if ( !CredentialSet->FileRead ) {
            WinStatus = CredpReadCredSet( &CredentialSets, Persist );

            if ( WinStatus == NO_ERROR ) {
                CredentialSet->FileRead = TRUE;
            }
        }

    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dblookup.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dblookup.h

Abstract:

    LSA Database - Lookup Sid and Name Routine Private Data Definitions.

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      Novwember 27, 1992

Environment:

Revision History:

--*/

#include <safelock.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Private Datatypes and Defines                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


//
//  This global controls what events are logged.
//  Note each level assumes that previous levels are to be logged too
//
//  Current only two values:
//
//  0 : (default) none
//  1 : fatal errors
//
extern DWORD LsapLookupLogLevel;


//
// This boolean indicates whether a post NT4 DC should perform
// extended lookups (eg by UPN) in a mixed domain (default is FALSE).
//
extern BOOLEAN LsapAllowExtendedDownlevelLookup;


//
// Set to 0 to disable the SID cache
//
#define USE_SID_CACHE 1

//
// Maximum number of Lookup Threads and maximum number to retain.
//

#define LSAP_DB_LOOKUP_MAX_THREAD_COUNT            ((ULONG) 0x00000002)
#define LSAP_DB_LOOKUP_MAX_RET_THREAD_COUNT        ((ULONG) 0x00000002)

//
// Work Item Granularity.
//

#define LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY       ((ULONG) 0x0000000f)

//
// Parameters specific to a Lookup Sids call.
//

typedef struct _LSAP_DB_LOOKUP_SIDS_PARAMS {

    PLSAPR_SID *Sids;
    PLSAPR_TRANSLATED_NAMES_EX TranslatedNames;

} LSAP_DB_LOOKUP_SIDS_PARAMS, *PLSAP_DB_LOOKUP_SIDS_PARAMS;

//
// Parameters specific to a Lookup Names call.
//

typedef struct _LSAP_DB_LOOKUP_NAMES_PARAMS {

    PLSAPR_UNICODE_STRING Names;
    PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids;

} LSAP_DB_LOOKUP_NAMES_PARAMS, *PLSAP_DB_LOOKUP_NAMES_PARAMS;

//
// Types of Lookup Operation.
//

typedef enum {

    LookupSids = 1,
    LookupNames

} LSAP_DB_LOOKUP_TYPE, *PLSAP_DB_LOOKUP_TYPE;

//
// Work Item states - Assignable, Assigned, Completed, Reassign
//

typedef enum {

    AssignableWorkItem = 1,
    AssignedWorkItem,
    CompletedWorkItem,
    ReassignWorkItem,
    NonAssignableWorkItem

} LSAP_DB_LOOKUP_WORK_ITEM_STATE, *PLSAP_DB_LOOKUP_WORK_ITEM_STATE;

//
// Work Item Properties.
//

#define LSAP_DB_LOOKUP_WORK_ITEM_ISOL    ((ULONG) 0x00000001L)
#define LSAP_DB_LOOKUP_WORK_ITEM_XFOREST ((ULONG) 0x00000002L)

//
// Lookup Work Item.  Each work item specifies a domain and an array of
// Sids or Names to be looked up in that domain.  This array is specified
// as an array of the Sid or Name indices relevant to the arrays specified
// as parameters to the lookup call.
//

typedef struct _LSAP_DB_LOOKUP_WORK_ITEM {

    LIST_ENTRY Links;
    LSAP_DB_LOOKUP_WORK_ITEM_STATE State;
    ULONG Properties;
    LSAPR_TRUST_INFORMATION TrustInformation;
    LONG DomainIndex;
    ULONG UsedCount;
    ULONG MaximumCount;
    PULONG Indices;

} LSAP_DB_LOOKUP_WORK_ITEM, *PLSAP_DB_LOOKUP_WORK_ITEM;

//
// Lookup Work List State.
//

typedef enum {

    InactiveWorkList = 1,
    ActiveWorkList,
    CompletedWorkList

} LSAP_DB_LOOKUP_WORK_LIST_STATE, *PLSAP_DB_LOOKUP_WORK_LIST_STATE;

//
// Work List for a Lookup Operation.  These are linked together if
// concurrent lookups are permitted.
//

typedef struct _LSAP_DB_LOOKUP_WORK_LIST {

    LIST_ENTRY WorkLists;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem;
    NTSTATUS Status;
    LSAP_DB_LOOKUP_WORK_LIST_STATE State;
    LSAP_DB_LOOKUP_TYPE LookupType;
    LSAPR_HANDLE PolicyHandle;
    ULONG WorkItemCount;
    ULONG CompletedWorkItemCount;
    ULONG Count;
    LSAP_LOOKUP_LEVEL LookupLevel;
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PULONG MappedCount;
    PULONG CompletelyUnmappedCount;
    ULONG AdvisoryChildThreadCount;
    NTSTATUS NonFatalStatus;
    HANDLE   LookupCompleteEvent;

    union {

        LSAP_DB_LOOKUP_SIDS_PARAMS LookupSidsParams;
        LSAP_DB_LOOKUP_NAMES_PARAMS LookupNamesParams;
    };

    LSAP_DB_LOOKUP_WORK_ITEM DummyAnchorWorkItem;


} LSAP_DB_LOOKUP_WORK_LIST, *PLSAP_DB_LOOKUP_WORK_LIST;

//
// Lookup Operation Work Queue.  The Queue is a circular doubly linked
// list of Work Lists.  Each Work List corresponds to a single
// Lookup Operation (i.e. an LsarLookupSids or LsarLookupNames call).
// A Work List is a circular doubly linked list of Work Items, each
// of these being a list of Sids or Names belonging to a specific
// Trusted Domain.  Work Items can be given out to different threads.
//

typedef struct _LSAP_DB_LOOKUP_WORK_QUEUE {

    SAFE_CRITICAL_SECTION Lock;
    PLSAP_DB_LOOKUP_WORK_LIST AnchorWorkList;
    PLSAP_DB_LOOKUP_WORK_LIST CurrentAssignableWorkList;
    PLSAP_DB_LOOKUP_WORK_ITEM CurrentAssignableWorkItem;
    ULONG ActiveChildThreadCount;
    ULONG MaximumChildThreadCount;
    ULONG MaximumRetainedChildThreadCount;
    LSAP_DB_LOOKUP_WORK_LIST DummyAnchorWorkList;

} LSAP_DB_LOOKUP_WORK_QUEUE, *PLSAP_DB_LOOKUP_WORK_QUEUE;

static LSAP_DB_LOOKUP_WORK_QUEUE LookupWorkQueue;


//
// Index to table of the well known SIDs
//
// This type indexes the table of well-known Sids maintained by the LSA
//

typedef enum _LSAP_WELL_KNOWN_SID_INDEX {

    LsapNullSidIndex = 0,
    LsapWorldSidIndex,
    LsapLocalSidIndex,
    LsapCreatorOwnerSidIndex,
    LsapCreatorGroupSidIndex,
    LsapCreatorOwnerServerSidIndex,
    LsapCreatorGroupServerSidIndex,
    LsapNtAuthoritySidIndex,
    LsapDialupSidIndex,
    LsapNetworkSidIndex,
    LsapBatchSidIndex,
    LsapInteractiveSidIndex,
    LsapServiceSidIndex,
    LsapLogonSidIndex,
    LsapBuiltInDomainSidIndex,
    LsapLocalSystemSidIndex,
    LsapAliasAdminsSidIndex,
    LsapAliasUsersSidIndex,
    LsapAnonymousSidIndex,
    LsapProxySidIndex,
    LsapServerSidIndex,
    LsapSelfSidIndex,
    LsapAuthenticatedUserSidIndex,
    LsapRestrictedSidIndex,
    LsapInternetDomainIndex,
    LsapTerminalServerSidIndex,
    LsapLocalServiceSidIndex,
    LsapNetworkServiceSidIndex,
    LsapRemoteInteractiveSidIndex,
    LsapDummyLastSidIndex

} LSAP_WELL_KNOWN_SID_INDEX, *PLSAP_WELL_KNOWN_SID_INDEX;


//
// Macro to identify SIDs the LSA should ignore for lookups (i.e., these
// lookups are always done by SAM since the alias name may change)
//

#define  SID_IS_RESOLVED_BY_SAM(SidIndex)    \
            (((SidIndex) == LsapAliasUsersSidIndex) || ((SidIndex) == LsapAliasAdminsSidIndex))


//
// Mnemonics for Universal well known SIDs.  These reference the corresponding
// entries in the Well Known Sids table.
//

#define LsapNullSid               WellKnownSids[LsapNullSidIndex].Sid
#define LsapWorldSid              WellKnownSids[LsapWorldSidIndex].Sid
#define LsapLocalSid              WellKnownSids[LsapLocalSidIndex].Sid
#define LsapCreatorOwnerSid       WellKnownSids[LsapCreatorOwnerSidIndex].Sid
#define LsapCreatorGroupSid       WellKnownSids[LsapCreatorGroupSidIndex].Sid
#define LsapCreatorOwnerServerSid WellKnownSids[LsapCreatorOwnerServerSidIndex].Sid
#define LsapCreatorGroupServerSid WellKnownSids[LsapCreatorGroupServerSidIndex].Sid

//
// Sids defined by NT
//

#define LsapNtAuthoritySid        WellKnownSids[LsapNtAuthoritySid].Sid

#define LsapDialupSid             WellKnownSids[LsapDialupSidIndex].Sid
#define LsapNetworkSid            WellKnownSids[LsapNetworkSidIndex].Sid
#define LsapBatchSid              WellKnownSids[LsapBatchSidIndex].Sid
#define LsapInteractiveSid        WellKnownSids[LsapInteractiveSidIndex].Sid
#define LsapServiceSid            WellKnownSids[LsapServiceSidIndex].Sid
#define LsapBuiltInDomainSid      WellKnownSids[LsapBuiltInDomainSidIndex].Sid
#define LsapLocalSystemSid        WellKnownSids[LsapLocalSystemSidIndex].Sid
#define LsapLocalServiceSid       WellKnownSids[LsapLocalServiceSidIndex].Sid
#define LsapNetworkServiceSid     WellKnownSids[LsapNetworkServiceSidIndex].Sid
#define LsapRemoteInteractiveSid  WellKnownSids[LsapRemoteInteractiveSidIndex].Sid
#define LsapRestrictedSid         WellKnownSids[LsapRestrictedSidIndex].Sid
#define LsapInternetDomainSid     WellKnownSids[LsapInternetDomainIndex].Sid
#define LsapAliasAdminsSid        WellKnownSids[LsapAliasAdminsSidIndex].Sid
#define LsapAliasUsersSid         WellKnownSids[LsapAliasUsersSidIndex].Sid

#define LsapAnonymousSid          WellKnownSids[LsapAnonymousSidIndex].Sid
#define LsapServerSid             WellKnownSids[LsapServerSidIndex].Sid
#define LsapSelfSid               WellKnownSids[LsapSelfSidIndex].Sid
#define LsapAuthenticatedUserSid  WellKnownSids[LsapAuthenticatedUserSidIndex].Sid

#define LsapTerminalServerSid     WellKnownSids[LsapTerminalServerSidIndex].Sid

//
// Well known LUIDs
//

extern LUID LsapSystemLogonId;
extern LUID LsapZeroLogonId;



//
//  Well known privilege values
//


extern LUID LsapCreateTokenPrivilege;
extern LUID LsapAssignPrimaryTokenPrivilege;
extern LUID LsapLockMemoryPrivilege;
extern LUID LsapIncreaseQuotaPrivilege;
extern LUID LsapUnsolicitedInputPrivilege;
extern LUID LsapTcbPrivilege;
extern LUID LsapSecurityPrivilege;
extern LUID LsapTakeOwnershipPrivilege;

extern SID_IDENTIFIER_AUTHORITY    LsapNullSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapWorldSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapLocalSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapCreatorSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapNtAuthority;

//
// Maximum number of Subauthority levels for well known Sids
//

#define LSAP_WELL_KNOWN_MAX_SUBAUTH_LEVEL  ((ULONG) 0x00000003L)

//
// Constants relating to Sid's
//

#define LSAP_MAX_SUB_AUTH_COUNT        (0x00000010L)
#define LSAP_MAX_SIZE_TEXT_SUBA        (0x00000009L)
#define LSAP_MAX_SIZE_TEXT_SID_HDR     (0x00000020L)
#define LSAP_MAX_SIZE_TEXT_SID                               \
    (LSAP_MAX_SIZE_TEXT_SID_HDR +                            \
     (LSAP_MAX_SUB_AUTH_COUNT * LSAP_MAX_SIZE_TEXT_SUBA))


//
// Well Known Sid Table Entry
//

typedef struct _LSAP_WELL_KNOWN_SID_ENTRY {

    PSID Sid;
    SID_NAME_USE Use;
    UNICODE_STRING Name;
    UNICODE_STRING DomainName;

} LSAP_WELL_KNOWN_SID_ENTRY, *PLSAP_WELL_KNOWN_SID_ENTRY;

//
// Well Known Sid Table Pointer
//

extern PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids;

NTSTATUS
LsapDbLookupGetDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *AccountDomainInfo,
    OUT PPOLICY_DNS_DOMAIN_INFO *DnsDomainInfo
    );


///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Lookup Sids and Names - Private Function Definitions                  //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

BOOLEAN
LsaIInitializeWellKnownSids(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY *WellKnownSids
    );

BOOLEAN
LsaIInitializeWellKnownSid(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids,
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN OPTIONAL PULONG SubAuthorities,
    IN PWSTR Name,
    IN PWSTR Description,
    IN SID_NAME_USE Use
    );

BOOLEAN
LsapDbLookupIndexWellKnownSid(
    IN PLSAPR_SID Sid,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );

BOOLEAN
LsapDbLookupIndexWellKnownSidName(
    IN PLSAPR_UNICODE_STRING Name,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );

NTSTATUS
LsapDbGetNameWellKnownSid(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    OUT PLSAPR_UNICODE_STRING Name,
    OUT OPTIONAL PLSAPR_UNICODE_STRING DomainName
    );

NTSTATUS
LsapDbLookupIsolatedWellKnownSids(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupSidsInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    );

NTSTATUS
LsapDbLookupSidsInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupSidsInPrimaryDomain(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS  *NonFatalStatus,
    OUT BOOLEAN   *fDownlevelSecureChannel
    );

NTSTATUS
LsapDbLookupSidsInTrustedDomains(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN BOOLEAN    fIncludeIntraforest,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupSidsInGlobalCatalog(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN BOOLEAN    fDoSidHistory,
    OUT NTSTATUS *NonFatalStatus
    );


NTSTATUS
LsapDbLookupSidsInGlobalCatalogWks(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupSidsInDomainList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupTranslateUnknownSids(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN ULONG MappedCount
    );

NTSTATUS
LsapDbLookupTranslateUnknownSidsInDomain(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupSimpleNames(
    IN ULONG Count,
    IN ULONG LookupLevel,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupWellKnownNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupIsolatedDomainNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupIsolatedDomainName(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupIsolatedDomainNameEx(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupNamesInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    );

NTSTATUS
LsapDbLookupNamesInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupNamesInLocalDomainEx(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupNamesInPrimaryDomain(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT BOOLEAN  *fDownlevelSecureChannel,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInTrustedDomains(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInGlobalCatalog(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInGlobalCatalogWks(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupTranslateNameDomain(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OPTIONAL PLSA_TRANSLATED_SID_EX2 TranslatedSid,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLONG DomainIndex
    );

NTSTATUS
LsapDbLookupTranslateUnknownNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN ULONG MappedCount
    );

NTSTATUS
LsapDbLookupTranslateUnknownNamesInDomain(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupDispatchWorkerThreads(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapRtlValidateControllerTrustedDomain(
    IN PLSAPR_UNICODE_STRING DomainControllerName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN ACCESS_MASK DesiredAccess,
    IN LPWSTR ServerPrincipalName,
    IN PVOID ClientContext,
    OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
LsapDbLookupCreateListReferencedDomains(
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN ULONG InitialMaxEntries
    );

NTSTATUS
LsapDbLookupAddListReferencedDomains(
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    OUT PLONG DomainIndex
    );

BOOLEAN
LsapDbLookupListReferencedDomains(
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_SID DomainSid,
    OUT PLONG DomainIndex
    );

NTSTATUS
LsapDbLookupGrowListReferencedDomains(
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN ULONG MaximumEntries
    );

NTSTATUS
LsapDbLookupMergeDisjointReferencedDomains(
    IN OPTIONAL PLSAPR_REFERENCED_DOMAIN_LIST FirstReferencedDomainList,
    IN OPTIONAL PLSAPR_REFERENCED_DOMAIN_LIST SecondReferencedDomainList,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *OutputReferencedDomainList,
    IN ULONG Options
    );

NTSTATUS
LsapDbLookupInitialize(
    );

NTSTATUS
LsapDbLookupInitializeWorkQueue(
    );

NTSTATUS
LsapDbLookupInitializeWorkList(
    OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupInitializeWorkItem(
    OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    );

NTSTATUS
LsapDbLookupAcquireWorkQueueLock(
    );

VOID LsapDbLookupReleaseWorkQueueLock();

NTSTATUS
LsapDbLookupLocalDomains(
    OUT PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    OUT PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    OUT PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation
    );

NTSTATUS
LsapDbLookupNamesBuildWorkList(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupSidsBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupCreateWorkList(
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupInsertWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupDeleteWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupSignalCompletionWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupAwaitCompletionWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbAddWorkItemToWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    );

NTSTATUS
LsapDbLookupStopProcessingWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN NTSTATUS TerminationStatus
    );

VOID
LsapDbUpdateMappedCountsWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupNamesUpdateTranslatedSids(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    );

NTSTATUS
LsapDbLookupSidsUpdateTranslatedNames(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    );

VOID
LsapDbLookupWorkerThreadStart(
    );

VOID
LsapDbLookupWorkerThread(
    IN BOOLEAN PrimaryThread
    );

NTSTATUS
LsapDbLookupObtainWorkItem(
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList,
    OUT PLSAP_DB_LOOKUP_WORK_ITEM *WorkItem
    );

NTSTATUS
LsapDbLookupProcessWorkItem(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    );

NTSTATUS
LsapDbLookupCreateWorkItem(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN LONG DomainIndex,
    IN ULONG MaximumEntryCount,
    OUT PLSAP_DB_LOOKUP_WORK_ITEM *WorkItem
    );

NTSTATUS
LsapDbLookupAddIndicesToWorkItem(
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN ULONG Count,
    IN PULONG Indices
    );

NTSTATUS
LsapDbLookupComputeAdvisoryChildThreadCount(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupUpdateAssignableWorkItem(
    IN BOOLEAN MoveToNextWorkList
    );


NTSTATUS
LsapRtlExtractDomainSid(
    IN PSID Sid,
    OUT PSID *DomainSid
    );

VOID LsapDbLookupReturnThreadToPool();


/*++

PSID
LsapDbWellKnownSid(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

Routine Description:

    This macro function returns the Well Known Sid corresponding
    to an index into the Well Known Sid table.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

--*/

#define LsapDbWellKnownSid( WellKnownSidIndex )                         \
    (WellKnownSids[ WellKnownSidIndex ].Sid)

PUNICODE_STRING
LsapDbWellKnownSidName(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );


/*++

SID_NAME_USE
LsapDbWellKnownSidNameUse(
    IN LSAP_DB_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )


Routine Description:

    This macro function returns the Sid Name Use of a Well Known Sid.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

--*/

#define LsapDbWellKnownSidNameUse( WellKnownSidIndex )                       \
    (WellKnownSids[ WellKnownSidIndex ].Use)


VOID
LsapDbUpdateCountCompUnmappedNames(
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG CompletelyUnmappedCount
    );

/*++

PUNICODE_STRING
LsapDbWellKnownSidDescription(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

Routine Description:

    This macro function returns the Unicode Description of a Well Known Sid.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

--*/

#define LsapDbWellKnownSidDescription( WellKnownSidIndex )                         \
    (&(WellKnownSids[ WellKnownSidIndex ].DomainName))


PUNICODE_STRING
LsapDbWellKnownSidName(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );

#define LsapDbAccessedBySidObject( ObjectTypeId ) \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].AccessedBySid)

#define LsapDbAccessedByNameObject( ObjectTypeId ) \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].AccessedByName)

#define LsapDbCompletelyUnmappedName(TranslatedName)                \
    (((TranslatedName)->DomainIndex == LSA_UNKNOWN_INDEX) &&        \
     ((TranslatedName)->Use == SidTypeUnknown))

#define LsapDbCompletelyUnmappedSid(TranslatedSid)                  \
    (((TranslatedSid)->DomainIndex == LSA_UNKNOWN_INDEX) &&         \
     ((TranslatedSid)->Use == SidTypeUnknown))


NTSTATUS
LsapGetDomainSidByNetbiosName(
    IN LPWSTR NetbiosName,
    OUT PSID *Sid
    );

NTSTATUS
LsapGetDomainSidByDnsName(
    IN LPWSTR DnsName,
    OUT PSID *Sid
    );

NTSTATUS
LsapGetDomainNameBySid(
    IN  PSID Sid,
    OUT PUNICODE_STRING DomainName
    );

VOID
LsapConvertTrustToEx(
    IN OUT PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    );

VOID
LsapConvertExTrustToOriginal(
    IN OUT PLSAPR_TRUST_INFORMATION TrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx
    );

NTSTATUS
LsapDbOpenPolicyGc (
    OUT HANDLE *LsaPolicyHandle                        
    );


BOOLEAN
LsapRevisionCanHandleNewErrorCodes(
    IN ULONG Revision
    );

BOOLEAN
LsapIsDsDomainByNetbiosName(
    WCHAR *NetbiosName
    );

BOOLEAN
LsapIsBuiltinDomain(
    IN PSID Sid
    );

BOOLEAN
LsapDbIsStatusConnectionFailure(
    NTSTATUS st
    );

NTSTATUS
LsapDbLookupAccessCheck(
    IN LSAPR_HANDLE PolicyHandle
    );

NTSTATUS
LsapDbLookupXForestNamesBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupXForestSidsBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsaICLookupNamesWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    );


NTSTATUS
LsaICLookupSidsWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    );

NTSTATUS
LsapDbLookupNameChainRequest(
    IN LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    OUT PULONG MappedCount,
    OUT PULONG ServerRevision OPTIONAL
    );

NTSTATUS
LsaDbLookupSidChainRequest(
    IN LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    OUT PULONG ServerRevision OPTIONAL
    );

LPWSTR
LsapDbLookupGetLevel(
    IN LSAP_LOOKUP_LEVEL LookupLevel
    );

#define LsapDbLookupReportEvent0(a, b, c, d, e) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 0);}

#define LsapDbLookupReportEvent1(a, b, c, d, e, f) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 1, f);}

#define LsapDbLookupReportEvent2(a, b, c, d, e, f, g) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 2, f, g);}

#define LsapDbLookupReportEvent3(a, b, c, d, e, f, g, h) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 3, f, g, h);}

NTSTATUS
LsapLookupReallocateTranslations(
    IN OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN     ULONG Count,
    IN OUT PLSA_TRANSLATED_NAME_EX *Names, OPTIONAL
    IN OUT PLSA_TRANSLATED_SID_EX2 *Sids  OPTIONAL
    );

//
// BOOLEAN
// LsapOutboundTrustedDomain(
//  PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY x
//  );
//
// This routine returns TRUE if x is a trust to a domain
//
#define LsapOutboundTrustedDomain(x)                                           \
   (  ((x)->TrustInfoEx.TrustType == TRUST_TYPE_UPLEVEL                        \
   ||  (x)->TrustInfoEx.TrustType == TRUST_TYPE_DOWNLEVEL )                    \
   && ((x)->TrustInfoEx.Sid != NULL)                                           \
   && ((x)->TrustInfoEx.TrustDirection & TRUST_DIRECTION_OUTBOUND)             \
   && (((x)->TrustInfoEx.TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)  \
      == 0))

//
// BOOLEAN
// LsapOutboundTrustedForest(
//  PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY x
//  );
//
// This routine returns TRUE if x is a trust to a forest
//
#define LsapOutboundTrustedForest(x)                                           \
   (  ((x)->TrustInfoEx.TrustType == TRUST_TYPE_UPLEVEL)                       \
   && ((x)->TrustInfoEx.Sid != NULL)                                           \
   && ((x)->TrustInfoEx.TrustDirection & TRUST_DIRECTION_OUTBOUND)             \
   && ((x)->TrustInfoEx.TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE))  \



//
// Return values from LsapGetDomainLookupScope
//

//
// Scope is domains that we directly trust
//
#define LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT       0x00000001

//
// Scope is domains that we transitively trust
//
#define LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE   0x00000002

//
// Scope is domains that we trust via forest trust
//
#define LSAP_LOOKUP_TRUSTED_FOREST              0x00000004

//
// Scope includes to lookup trusted forest domains locally
//
#define LSAP_LOOKUP_TRUSTED_FOREST_ROOT         0x00000008

//
// Allow lookups of DNS names
//
#define LSAP_LOOKUP_DNS_SUPPORT                 0x00000010

ULONG
LsapGetDomainLookupScope(
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG             ClientRevision
    );

//
// Useful combinations
//
#define LSAP_LOOKUP_RESOLVE_ISOLATED_DOMAINS          \
            (LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT     |  \
             LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE |  \
             LSAP_LOOKUP_TRUSTED_FOREST_ROOT)

NTSTATUS
LsapDbLookupNamesAsDomainNames(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount
    );

NTSTATUS
LsapDbLookupSidsAsDomainSids(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\efsapi.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efsapi.cxx

Abstract:

    EFS (Encrypting File System) API Interfaces

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#include <lsapch.hxx>

//
// Fodder

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wincrypt.h>
#include <efsstruc.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
#include "lsapmsgs.h"

}


//Constant -- This buffer length should be enough for EFS temp file name
#define TEMPFILELEN 26

//
// Initial memory allocation block size for $EFS
//
#define INIT_EFS_BLOCK_SIZE    4096
#define INITBUFFERSIZE  4096


#define ENCRYPT 1

#define EfsErrPrint //

#define BASIC_KEY_INFO 1

//
// Global Variables
//

DESTable DesTable;

UCHAR DriverSessionKey[DES_BLOCKLEN];

HANDLE LsaPid = NULL;

//
// Prototypes
//

ULONG
StringInfoCmp(
    IN PFILE_STREAM_INFORMATION StreamInfoBase,
    IN PFILE_STREAM_INFORMATION LaterStreamInfoBase,
    IN ULONG StreamInfoSize
    );

BOOLEAN
EncryptFSCTLData(
    IN ULONG Fsctl,
    IN ULONG Psc,
    IN ULONG Csc,
    IN PVOID EfsData,
    IN ULONG EfsDataLength,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );

BOOLEAN
SendHandle(
    IN HANDLE Handle,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

BOOLEAN
SendEfs(
    IN PEFS_KEY Fek,
    IN PEFS_DATA_STREAM_HEADER Efs,
    OUT PUCHAR EfsData,
    OUT PULONG EfsDataLength
    );

BOOLEAN
SendHandleAndEfs(
    IN HANDLE Handle,
    IN PEFS_DATA_STREAM_HEADER Efs,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

NTSTATUS
SendSkFsctl(
    IN ULONG PSC,
    IN ULONG CSC,
    IN ULONG EfsCode,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    IN HANDLE Handle,
    IN ULONG FsCode,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    );

NTSTATUS
EndErrorEncryptFile(
    IN HANDLE FileHandle,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    );

NTSTATUS
GetRootHandle(
    IN HANDLE FileHandle,
    PHANDLE RootDirectoryHandle
    );

NTSTATUS
GetParentEfsStream(
    IN HANDLE CurrentFileHandle,
    IN PUNICODE_STRING CurrentFileName,
    OUT PEFS_DATA_STREAM_HEADER *ParentEfsStream
    );

DWORD
MyCopyFile(
    HANDLE SourceFile,
    PUNICODE_STRING StreamNames,
    PHANDLE StreamHandles,
    PEFS_STREAM_SIZE StreamSizes,
    ULONG StreamCount,
    HANDLE hTargetFile,
    PHANDLE * TargetStreamHandles
    );

VOID
CleanupOpenFileStreams(
       IN PHANDLE Handles OPTIONAL,
       IN PUNICODE_STRING StreamNames OPTIONAL,
       IN PEFS_STREAM_SIZE Sizes OPTIONAL,
       IN PFILE_STREAM_INFORMATION StreamInfoBase OPTIONAL,
       IN HANDLE HSourceFile OPTIONAL,
       IN ULONG StreamCount
       );


NTSTATUS
GetBackupFileName(
    LPCWSTR SourceFile,
    LPWSTR * BackupName
    );


DWORD
CopyStream(
    HANDLE Target,
    HANDLE Source,
    PEFS_STREAM_SIZE StreamSize
    );


DWORD
CheckVolumeSpace(
    PFILE_FS_SIZE_INFORMATION VolInfo,
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    );

DWORD
CompressStreams(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG State,
    ULONG StreamCount
    );

DWORD
CheckOpenSection(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    );

DWORD
CopyStreamSection(
    HANDLE Target,
    HANDLE SrcMapping,
    PLARGE_INTEGER Offset,
    PLARGE_INTEGER DataLength,
    PLARGE_INTEGER AllocationGranularity
    );

BOOL
EfspSetEfsOnFile(
    IN HANDLE hFile,
    PEFS_DATA_STREAM_HEADER pEfsStream,
    IN PEFS_KEY pNewFek
    );

NTSTATUS
GetFileEfsStream(
    IN HANDLE hFile,
    OUT PEFS_DATA_STREAM_HEADER * pEfsStream
    );

DWORD
EncryptFileSrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PUNICODE_STRING SourceFileNameU,
    IN HANDLE LogFileH
    )
/*++

Routine Description:

    This routine is the top level routine of the EncryptFile API.  It
    opens the passed source file and copies all of its data streams to
    a backup file in a known location.  It then marks all of the streams
    of the source as encrypted, and copies them back.

Arguments:

    SourceFileName - Supplies a Unicode string with the name of
        the file to be encrypted.

    LogFileH - Log file handle. Log file is zero size when passed in.


Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{
    BOOL                 b = TRUE;
    BOOLEAN              CleanupSuccessful = TRUE;
    BOOLEAN              KeepLogFile = FALSE;

    ULONG                StatusInfoOffset = 0 ;
    DWORD                hResult = ERROR_SUCCESS;
    DWORD                FileAttributes;

    HANDLE               FileHandle;
    HANDLE               hSourceFile;
    HANDLE               hBackupFile = 0;
    PHANDLE              StreamHandles = NULL;

    LPWSTR               SourceFileName;
    LPWSTR               BackupFileName;

    FILE_FS_SIZE_INFORMATION    VolInfo;
    FILE_INTERNAL_INFORMATION  SourceID;
    FILE_INTERNAL_INFORMATION  BackupID;

    NTSTATUS                 Status;

    OBJECT_ATTRIBUTES        Obja;

    PFILE_STREAM_INFORMATION LaterStreamInfoBase = NULL;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;

    PEFS_STREAM_SIZE           StreamSizes = NULL;

    PUNICODE_STRING          StreamNames = NULL;

    UINT                     TmpResult;

    ULONG                    LaterStreamInfoSize = 0;
    ULONG                    StreamCount    = 0;
    ULONG                    StreamInfoSize = 0;
    ULONG                    i;
    DWORD                   tmpDW;

    PEFS_DATA_STREAM_HEADER  ParentEfsStream = NULL;
    PEFS_DATA_STREAM_HEADER  CurrentEfsStream = NULL;

    IO_STATUS_BLOCK IoStatusBlock;
    ULONG InputDataSize;
    ULONG EfsDataLength;
    PUCHAR InputData;
    WORD WebDavPath = 0;

    //
    // Convert the source file name into an LPWSTR
    //

    if (!LogFileH) {

        //
        //  No LogFile means WEBDAVPATH
        //

        WebDavPath = WEBDAVPATH;
    }

    SourceFileName = (LPWSTR)LsapAllocateLsaHeap( SourceFileNameU->Length + sizeof( UNICODE_NULL ));

    if (SourceFileName == NULL) {

        MarkFileForDelete( LogFileH );
EfsErrPrint("Out of memory allocating SourceFileName");
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    SourceFileName[SourceFileNameU->Length/sizeof(WCHAR)] = UNICODE_NULL;

    RtlCopyMemory( SourceFileName, SourceFileNameU->Buffer, SourceFileNameU->Length );

    DebugLog((DEB_TRACE_EFS, "Encrypting file %ws \n", SourceFileName));

    FileAttributes = GetFileAttributes( SourceFileName );

     if (FileAttributes == -1) {
        if (LogFileH) {
            MarkFileForDelete( LogFileH );
        }
        LsapFreeLsaHeap( SourceFileName );
EfsErrPrint("GetFileAttributes failed with -1");
        return GetLastError();

    }

    //
    // Open the target file
    //

    if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ){
        tmpDW = FILE_FLAG_BACKUP_SEMANTICS;
    } else {
        tmpDW = FILE_FLAG_OPEN_REPARSE_POINT;
    }

    //
    // CreateFile will add FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE
    //

    hSourceFile =  CreateFile(
            SourceFileName,
            FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
            0,
            NULL,
            OPEN_EXISTING,
            tmpDW,
            NULL
            );

    if (hSourceFile != INVALID_HANDLE_VALUE) {

        NTSTATUS Status1;

        if ( FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           // Fail the call if the file is HSM or SIS file
           //
           FILE_ATTRIBUTE_TAG_INFORMATION TagInfo;

           Status = NtQueryInformationFile(
                     hSourceFile,
                     &IoStatusBlock,
                     &TagInfo,
                     sizeof ( FILE_ATTRIBUTE_TAG_INFORMATION ),
                     FileAttributeTagInformation
                     );

           if ( NT_SUCCESS( Status ) && ( (IO_REPARSE_TAG_HSM == TagInfo.ReparseTag) || (IO_REPARSE_TAG_SIS == TagInfo.ReparseTag))) {

              //
              // Log the error saying we do not support HSM and SIS
              //

              EfsLogEntry(
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_REPARSE_FILE_ERROR,
                1,
                sizeof(ULONG),
                (LPCWSTR *)&SourceFileName,
                &TagInfo.ReparseTag
                );

              if (LogFileH) {
                  MarkFileForDelete( LogFileH );
              }
              LsapFreeLsaHeap( SourceFileName );
              CloseHandle( hSourceFile );
EfsErrPrint("This is a SIS or HSM file.\n");
              return ERROR_ACCESS_DENIED;

           }

        }

        Status = NtQueryVolumeInformationFile(
            hSourceFile,
            &IoStatusBlock,
            &VolInfo,
            sizeof ( FILE_FS_SIZE_INFORMATION ),
            FileFsSizeInformation
            );

        if (WebDavPath != WEBDAVPATH) {

            Status1 = NtQueryInformationFile(
                hSourceFile,
                &IoStatusBlock,
                &SourceID,
                sizeof ( FILE_INTERNAL_INFORMATION ),
                FileInternalInformation
                );

        } else {

            //
            // SourceID not needed for WEB DAV file
            //


            Status1 = STATUS_SUCCESS;
        }

        if ( NT_SUCCESS( Status ) && NT_SUCCESS( Status1 ) ) {

 /*
            //
            //  Get parent directory $EFS
            //  We will visit this in Blackcomb
            //

            RpcRevertToSelf();
            Status =  GetParentEfsStream(
                                hSourceFile,
                                SourceFileNameU,
                                &ParentEfsStream
                                );
            
 */
    
            
            if (NT_SUCCESS( Status ) ) {

                if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                    if ( FileAttributes & FILE_ATTRIBUTE_COMPRESSED ){

                        USHORT State = COMPRESSION_FORMAT_NONE;
                        ULONG Length;

                        //
                        //  Uncompress the directory first
                        //

                        b = DeviceIoControl(hSourceFile,
                                            FSCTL_SET_COMPRESSION,
                                            &State,
                                            sizeof(USHORT),
                                            NULL,
                                            0,
                                            &Length,
                                            FALSE
                                            );

                        if ( !b ){
                            hResult = GetLastError();
                            DebugLog((DEB_WARN, "DeviceIoControl failed, setting hResult = %d\n", hResult  ));
EfsErrPrint("Uncompress the directory failed. Win Error=%d\n",hResult);
                        }

                    }

                    if (hResult == ERROR_SUCCESS) {

                        //
                        // Set_Encrypt on directory
                        //

                        //
                        //  We do not check the operation of the LOG.
                        //  Should we fail the normal operation just because the LOG operations
                        //  failed? The answer is probably not. The chance to use the LOG file is very
                        //  slim. We will use TxF when it is ready and we have time to deal with this.
                        //

                        if (LogFileH) {

                            CreateLogHeader(
                                LogFileH,
                                VolInfo.BytesPerSector,
                                &(SourceID.IndexNumber),
                                NULL,
                                SourceFileName,
                                NULL,
                                Encrypting,
                                BeginEncryptDir,
                                NULL
                                );

                        }

                        PEFS_KEY Fek ;

                        b = GenerateFEK( &Fek );

                        if (b) {

                            if (ConstructDirectoryEFS( pEfsUserInfo, Fek, &CurrentEfsStream )) {

                                //
                                // Prepare an Input data buffer in the form of
                                // PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk, $EFS]sk
                                //

                                InputDataSize = 2 * sizeof(DriverSessionKey) + 7 * sizeof(ULONG)
                                                + CurrentEfsStream->Length;

                                InputData = (PUCHAR)LsapAllocateLsaHeap( InputDataSize );

                                if ( NULL != InputData ) {

                                    EfsDataLength = InputDataSize - 3 * sizeof(ULONG);
                                    ( VOID ) SendHandleAndEfs(
                                                hSourceFile,
                                                CurrentEfsStream,
                                                InputData + 3 * sizeof(ULONG),
                                                &EfsDataLength
                                                );

                                    ( VOID ) EncryptFSCTLData(
                                                EFS_SET_ENCRYPT,
                                                EFS_ENCRYPT_STREAM,
                                                EFS_ENCRYPT_DIRSTR,
                                                InputData + 3*sizeof(ULONG),
                                                EfsDataLength,
                                                InputData,
                                                &InputDataSize
                                                );

                                    Status = NtFsControlFile(
                                                hSourceFile,
                                                0,
                                                NULL,
                                                NULL,
                                                &IoStatusBlock,
                                                FSCTL_SET_ENCRYPTION,
                                                InputData,
                                                InputDataSize,
                                                NULL,
                                                0
                                                );

                                    if (NT_SUCCESS( Status )) {

                                        hResult = ERROR_SUCCESS;

                                    } else {

                                        DebugLog((DEB_ERROR, "EncryptFileSrv: NtFsControlFile failed, status = (%x)\n" ,Status  ));
                                        hResult = RtlNtStatusToDosError( Status );

                                        //
                                        // Make sure the error was mapped
                                        //

                                        if (hResult == ERROR_MR_MID_NOT_FOUND) {

                                            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                                            hResult = ERROR_ENCRYPTION_FAILED;
                                        }
EfsErrPrint("Encrypt directory FSCTL failed. Win Error=%d\n",hResult);
                                    }


                                    LsapFreeLsaHeap( InputData );

                                } else {

                                    hResult = ERROR_NOT_ENOUGH_MEMORY;
EfsErrPrint("FSCTL input data memory allocation failed.\n");
                                }

                                LsapFreeLsaHeap( CurrentEfsStream );

                            } else {

                                hResult = GetLastError();
                                ASSERT( hResult != ERROR_SUCCESS );
                                DebugLog((DEB_WARN, "ConstructDirectoryEFS returned %x to hResult\n" ,hResult  ));
EfsErrPrint("ConstructDirectoryEFS failed. Win Error=%d\n",hResult);
                            }

                            LsapFreeLsaHeap( Fek );
                            Fek = NULL;

                        } else {

                            hResult = GetLastError();
                            ASSERT( hResult != ERROR_SUCCESS );
EfsErrPrint("Generate directory FEK failed. Win Error=%d\n",hResult);
                        }

                        if ((hResult != ERROR_SUCCESS) && ( FileAttributes & FILE_ATTRIBUTE_COMPRESSED )) {

                            //
                            // Restore the compression state
                            //

                            USHORT State = COMPRESSION_FORMAT_DEFAULT;
                            ULONG Length;

                            (VOID) DeviceIoControl(hSourceFile,
                                                FSCTL_SET_COMPRESSION,
                                                &State,
                                                sizeof(USHORT),
                                                NULL,
                                                0,
                                                &Length,
                                                FALSE
                                                );
                        }

                        //
                        // if  ConstructDirectoryEFS fail, error will be returned in the end.
                        //
                    }

                } else {

                    //
                    // It's a file, not a directory.
                    //

                    //
                    // Enumerate all the streams on the file
                    //
                    
                    Status = GetStreamInformation(
                                 hSourceFile,
                                 &StreamInfoBase,   // Free this
                                 &StreamInfoSize
                                 );

                    if (NT_SUCCESS( Status )) {

                        hResult = OpenFileStreams(
                                     hSourceFile,
                                     0,
                                     OPEN_FOR_ENC,
                                     StreamInfoBase,
                                     FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                     FILE_OPEN,
                                     FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                     &VolInfo,
                                     &StreamNames,      // Free this but not the contents!
                                     &StreamHandles,    // Free this
                                     &StreamSizes,      // Free this
                                     &StreamCount
                                     );

                        if (hResult == ERROR_SUCCESS) {

                            //
                            // We have handles to all of the streams of the file
                            //

                            //
                            // Prepare an Input data buffer in the form of
                            // PSC, [EFS_FC, CSC, Fek, [Fek]sk, $EFS]sk
                            //


                            PEFS_KEY Fek ;

                            b = GenerateFEK( &Fek );

                            if (b) {

                                b = ConstructEFS(
                                        pEfsUserInfo,
                                        Fek,
                                        ParentEfsStream,
                                        &CurrentEfsStream
                                        );

                                if (b) {

                                    InputDataSize = 2 * EFS_KEY_SIZE( Fek ) + 3 * sizeof(ULONG)
                                                    + CurrentEfsStream->Length;

                                    InputData = (PUCHAR)LsapAllocateLsaHeap( InputDataSize );

                                    if ( NULL != InputData ){

                                        //
                                        // This routine creates the backup file.
                                        //

                                        Status = CreateBackupFile(
                                                            SourceFileNameU,
                                                            &hBackupFile,
                                                            &BackupID,
                                                            &BackupFileName
                                                            );

                                        //
                                        // If power down happens right here before
                                        // the log file header is written, we will have a zero size
                                        // temp file left on the disk. This is very unlikely and not
                                        // a big deal we have a zero size file left on the disk.
                                        // After we use TxF, this will not even be an issue.
                                        //

                                        if ( NT_SUCCESS(Status) ){

                                            if (LogFileH) {

                                                Status = CreateLogHeader(
                                                                    LogFileH,
                                                                    VolInfo.BytesPerSector,
                                                                    &(SourceID.IndexNumber),
                                                                    &(BackupID.IndexNumber),
                                                                    SourceFileName,
                                                                    BackupFileName,
                                                                    Encrypting,
                                                                    BeginEncryptFile,
                                                                    &StatusInfoOffset
                                                                    );

                                            }


                                            LsapFreeLsaHeap( BackupFileName );

                                            if ( NT_SUCCESS(Status) ){

                                                if (LogFileH){

                                                    Status = WriteLogFile(
                                                                    LogFileH,
                                                                    VolInfo.BytesPerSector,
                                                                    StatusInfoOffset,
                                                                    BeginEncryptFile
                                                                    );

                                                    if ( !NT_SUCCESS(Status) ){

                                                        //
                                                        // Delete the backup file
                                                        //

                                                        MarkFileForDelete( hBackupFile );
                                                        CloseHandle( hBackupFile );
                                                        hBackupFile = 0;
    EfsErrPrint("Failed to write the log file.\n");
                                                    }
                                                }


                                            } else {
                                                MarkFileForDelete( hBackupFile );
                                                CloseHandle( hBackupFile );
                                                hBackupFile = 0;
EfsErrPrint("Failed to create the Log header.\n");
                                            }

                                        } else {

                                            //
                                            // Fail to create the backup file
                                            // Log it.
                                            //

                                            EfsLogEntry(
                                                EVENTLOG_ERROR_TYPE,
                                                0,
                                                EFS_TMP_FILE_ERROR,
                                                1,
                                                sizeof(NTSTATUS),
                                                (LPCWSTR *)&SourceFileName,
                                                &Status
                                                );

EfsErrPrint("Failed to create the backup file.");
                                        }

                                        if ( NT_SUCCESS(Status) ){

                                            EfsDataLength = InputDataSize - 3 * sizeof(ULONG);

                                            //
                                            // Prepare the FSCTL input data
                                            //

                                            ( VOID ) SendEfs(
                                                         Fek,
                                                         CurrentEfsStream,
                                                         InputData + 3 * sizeof(ULONG),
                                                         &EfsDataLength
                                                         );


                                            ( VOID ) EncryptFSCTLData(
                                                        EFS_SET_ENCRYPT,
                                                        EFS_ENCRYPT_FILE,
                                                        EFS_ENCRYPT_FILE,
                                                        InputData + 3*sizeof(ULONG),
                                                        EfsDataLength,
                                                        InputData,
                                                        &InputDataSize
                                                        );

                                            //
                                            //   Write the $EFS and turn on the bits
                                            //

                                            Status = NtFsControlFile(
                                                        hSourceFile,
                                                        0,
                                                        NULL,
                                                        NULL,
                                                        &IoStatusBlock,
                                                        FSCTL_SET_ENCRYPTION,
                                                        InputData,
                                                        InputDataSize,
                                                        NULL,
                                                        0
                                                        );

                                            if ( NT_SUCCESS( Status ) ){

                                                //
                                                // All failures from here on out need to be closed
                                                // with another FSCTL call.
                                                //


                                                //
                                                // Enumerate the streams again, and make sure nothing
                                                // has changed
                                                //
                                                
                                                Status = GetStreamInformation(
                                                             hSourceFile,
                                                             &LaterStreamInfoBase,    // Free this
                                                             &LaterStreamInfoSize
                                                             );

                                                if (NT_SUCCESS( Status )) {

                                                    if (StreamInfoSize == LaterStreamInfoSize) {

                                                        //
                                                        // Compare the original stream info structure with the one we just got,
                                                        // and make sure they're identical.  If not, punt.
                                                        //

                                                        ULONG rc = StringInfoCmp(StreamInfoBase, LaterStreamInfoBase, StreamInfoSize);

                                                        if (rc == 0) {

                                                            //
                                                            // Copy the file to the backup file.  Success if target exists
                                                            // (because the make temporary file command creates it).
                                                            //

                                                            PHANDLE TargetHandles;

                                                            //
                                                            // Revert to self to be able to open the multiple streams on the backup file
                                                            //

                                                            RpcRevertToSelf();

                                                            hResult = MyCopyFile(
                                                                        hSourceFile,        // handle to the file we're copying from (source file)
                                                                        StreamNames,        // names of the streams of the source file
                                                                        StreamHandles,      // handles to the streams of the source file
                                                                        StreamSizes,        // sizes of the streams of the source file
                                                                        StreamCount,        // number of streams we're copying, including unnamed data stream
                                                                        hBackupFile,         // Backup file handle
                                                                        &TargetHandles      // new handles of corresponding streams on backup file
                                                                        );

                                                            //
                                                            // Even the impersonation failed, it is OK. We already got all the handles we need.
                                                            //

                                                            ( VOID ) RpcImpersonateClient( NULL );

                                                            if (hResult == ERROR_SUCCESS) {

                                                                //
                                                                // The backup file now exists and has data in it.
                                                                // We do not check the error code of WriteLogFile for the following reasons,
                                                                // 1. We are overwriting the sectors, out of disk space is not possible. The sectors have
                                                                //     just been written, defective sector is very unlikely.
                                                                // 2. In case, the sector becomes defective between the two writes. More than 99.99%
                                                                //     we can still finish the job without any problem.
                                                                // 3. In real life, it is very unlikely that power down or crash happens here and the sectors
                                                                //     just become defective right after last write.
                                                                //
                                                                // When TxF is used later, this will not be an issue.
                                                                //

                                                                if (LogFileH){

                                                                    ( VOID )WriteLogFile(
                                                                                    LogFileH,
                                                                                    VolInfo.BytesPerSector,
                                                                                    StatusInfoOffset,
                                                                                    EncryptTmpFileWritten
                                                                                    );

                                                                }

                                                               hResult = CheckOpenSection(
                                                                                        StreamSizes,
                                                                                        StreamHandles,
                                                                                        StreamCount
                                                                                        );

                                                                if ( ERROR_SUCCESS == hResult ){
                                                                    hResult =  CompressStreams(
                                                                                            StreamSizes,
                                                                                            StreamHandles,
                                                                                            COMPRESSION_FORMAT_NONE,
                                                                                            StreamCount
                                                                                            );
if (ERROR_SUCCESS != hResult) {
    EfsErrPrint("CompressStreams Failed. Win Error=%d\n",hResult);
}
                                                                } else {

                                                                    DebugLog((DEB_ERROR, "CompressStreams returned %d\n" ,hResult  ));

EfsErrPrint("Failed to check the open section. Win Error=%d\n",hResult);
                                                                }


                                                                if ( ERROR_SUCCESS == hResult ){
                                                                    //
                                                                    // Reuse the input data buffer for each stream
                                                                    // FSCTL call.
                                                                    //

                                                                    ( VOID )SendEfs(
                                                                                Fek,
                                                                                CurrentEfsStream,
                                                                                InputData + 3 * sizeof(ULONG),
                                                                                &EfsDataLength
                                                                                );


                                                                    ( VOID ) EncryptFSCTLData(
                                                                                EFS_SET_ENCRYPT,
                                                                                EFS_ENCRYPT_STREAM,
                                                                                EFS_ENCRYPT_STREAM,
                                                                                InputData + 3*sizeof(ULONG),
                                                                                EfsDataLength,
                                                                                InputData,
                                                                                &InputDataSize
                                                                                );

                                                                    //
                                                                    // Copy each stream from the backup to the original.
                                                                    // CopyFileStreams attempts to undo things in case of problems,
                                                                    // so we just have to report success or failure.
                                                                    //

                                                                    hResult = CopyFileStreams(
                                                                                 TargetHandles,     // handles to streams on the backup file
                                                                                 StreamHandles,     // handles to streams on the source file
                                                                                 StreamCount,       // number of streams
                                                                                 StreamSizes,       // sizes of streams
                                                                                 Encrypting,        // mark StreamHandles as Encrypted before copy
                                                                                 InputData,         // FSCTL input data
                                                                                 InputDataSize,     // FSCTL input data size
                                                                                 &CleanupSuccessful
                                                                                 );

                                                                    if (hResult != ERROR_SUCCESS) {
EfsErrPrint("CopyFileStreams Failed. Win Error=%d\n",hResult);
                                                                        DebugLog((DEB_ERROR, "CopyFileStreams returned %d\n" ,hResult  ));
                                                                    }
                                                                }

                                                                LsapFreeLsaHeap( Fek );
                                                                Fek = NULL;

                                                                if (hResult == ERROR_SUCCESS || CleanupSuccessful) {

                                                                    if (hResult == ERROR_SUCCESS) {

                                                                        //
                                                                        // Encryption is almost done. The file is still in a transit status
                                                                        // No error checking for writing the log file for the same reason
                                                                        // mentioned above.
                                                                        //

                                                                        if (LogFileH){

                                                                            ( VOID )WriteLogFile(
                                                                                            LogFileH,
                                                                                            VolInfo.BytesPerSector,
                                                                                            StatusInfoOffset,
                                                                                            EncryptionDone
                                                                                            );

                                                                        }

                                                                        //
                                                                        // Reuse the InputData buffer.
                                                                        // FSCTL Mark encryption success
                                                                        //

                                                                        Status = SendSkFsctl(
                                                                                        0,
                                                                                        0,
                                                                                        EFS_ENCRYPT_DONE,
                                                                                        InputData,
                                                                                        InputDataSize,
                                                                                        hSourceFile,
                                                                                        FSCTL_ENCRYPTION_FSCTL_IO,
                                                                                        &IoStatusBlock
                                                                                        );

                                                                    } else {
                                                                        //
                                                                        // FSCTL Fail Encrypting. We can reuse the InputData.
                                                                        // No stream has been encrypted yet.
                                                                        // Decrypt File will do the trick to restore the file status.
                                                                        //

                                                                        if (LogFileH){

                                                                            ( VOID )WriteLogFile(
                                                                                            LogFileH,
                                                                                            VolInfo.BytesPerSector,
                                                                                            StatusInfoOffset,
                                                                                            EncryptionBackout
                                                                                            );

                                                                        }

                                                                        ( VOID ) EndErrorEncryptFile(
                                                                                            hSourceFile,
                                                                                            InputData,
                                                                                            InputDataSize,
                                                                                            &IoStatusBlock
                                                                                            );

                                                                    }

                                                                    if (LogFileH){

                                                                        ( VOID )WriteLogFile(
                                                                                        LogFileH,
                                                                                        VolInfo.BytesPerSector,
                                                                                        StatusInfoOffset,
                                                                                        EncryptionSrcDone
                                                                                        );

                                                                    }

                                                                    //
                                                                    // Either the operation worked, or it failed but we managed to clean
                                                                    // up after ourselves.  In either case, we no longer need the backup
                                                                    // file or the log file.
                                                                    //
                                                                    // Delete the backup file first.
                                                                    //

                                                                    LONG j;
                                                                    // Do we need delete each stream?
                                                                    for (j=StreamCount - 1 ; j >= 0 ; j--) {
                                                                        MarkFileForDelete( TargetHandles[j] );
                                                                    }

                                                                } else {

                                                                    //
                                                                    // The operation failed and we couldn't clean up.  Keep the
                                                                    // log file and the backup file around so we can retry on
                                                                    // reboot.
                                                                    //

                                                                    if (LogFileH){

                                                                        KeepLogFile = TRUE;

                                                                        ( VOID )WriteLogFile(
                                                                                        LogFileH,
                                                                                        VolInfo.BytesPerSector,
                                                                                        StatusInfoOffset,
                                                                                        EncryptionMessup
                                                                                        );

                                                                    }

                                                                }

                                                                //
                                                                // Regardless of what happened, we don't need these any more.
                                                                //

                                                                LONG j;

                                                                for ( j = StreamCount -1 ; j >=0; j--) {
                                                                    CloseHandle( TargetHandles[j] );
                                                                }
                                                                hBackupFile = 0;

                                                                LsapFreeLsaHeap( TargetHandles );

                                                            } else {

                                                                //
                                                                // We couldn't copy everything to the backup file.
                                                                // No need to record error log information after this point.
                                                                // Tell the driver that the operation has failed.
                                                                //
                                                                // MyCopyFile has already taken care of cleaning up the
                                                                // backup file.
                                                                //
                                                                hBackupFile = 0;
                                                                DebugLog((DEB_ERROR, "MyCopyFile failed, error = %d\n" ,hResult  ));

                                                                LsapFreeLsaHeap( Fek );
                                                                Fek = NULL;
                                                                //
                                                                // FSCTL Fail Encrypting. We can reuse the InputData.
                                                                // No stream has been encrypted yet.
                                                                // Decrypt File will do the trick to restore the file status.
                                                                //

                                                                //
                                                                // We ignore the return status from FSCTL call,
                                                                // If it is failed, the only way to restore the status
                                                                // is by rebooting the system.
                                                                //
                                                                // Robert Reichel, you need think about what happened if
                                                                // the following call failed, although it is very unlikely.
                                                                // If the call fails and the log file gets removed, the file
                                                                // will be unaccessible. Convert the return code to hResult is
                                                                // obviously not correct.
                                                                //

                                                                ( VOID ) EndErrorEncryptFile(
                                                                                    hSourceFile,
                                                                                    InputData,
                                                                                    InputDataSize,
                                                                                    &IoStatusBlock
                                                                                    );

EfsErrPrint("Failed to make a copy of the file. Win Error=%d\n",hResult);
                                                            }

                                                       } else {

                                                            //
                                                            // Somebody added/removed stream(s).
                                                            // FSCTL Fail Encrypting. We can reuse the InputData.
                                                            // No stream has been encrypted yet.
                                                            // Decrypt File will do the trick to restore the file status.
                                                            //
                                                            MarkFileForDelete( hBackupFile );

                                                            LsapFreeLsaHeap( Fek );
                                                            Fek = NULL;
                                                            ( VOID ) EndErrorEncryptFile(
                                                                                hSourceFile,
                                                                                InputData,
                                                                                InputDataSize,
                                                                                &IoStatusBlock
                                                                                );

                                                            hResult = ERROR_ENCRYPTION_FAILED;
EfsErrPrint("Streams changed while doing encryption, StringInfoCmp(). Win Error=%d\n",hResult);
                                                        }

                                                    } else {

                                                        //
                                                        // Stream info size changed
                                                        // FSCTL Fail Encrypting. We can reuse the InputData.
                                                        // No stream has been encrypted yet.
                                                        // Decrypt File will do the trick to restore the file status.
                                                        //
                                                        MarkFileForDelete( hBackupFile );

                                                        LsapFreeLsaHeap( Fek );
                                                        Fek = NULL;
                                                        //
                                                        // We ignore the return status from FSCTL call,
                                                        // If it is failed, the only way to restore the status
                                                        // is by rebooting the system.
                                                        //
                                                        // Robert Reichel, you need think about what happened if
                                                        // the following call failed, although it is very unlikely.
                                                        // If the call fails and the log file gets removed, the file
                                                        // will be unaccessible. Convert the return code to hResult is
                                                        // obviously not correct.
                                                        //

                                                        ( VOID ) EndErrorEncryptFile(
                                                                            hSourceFile,
                                                                            InputData,
                                                                            InputDataSize,
                                                                            &IoStatusBlock
                                                                            );

                                                        hResult = ERROR_ENCRYPTION_FAILED;
EfsErrPrint("Streams changed while doing encryption, Size not eaqual. Win Error=%d\n",hResult);
                                                    }

                                                    LsapFreeLsaHeap( LaterStreamInfoBase );

                                                } else {

                                                    //
                                                    // GetStreamInformation() Failed
                                                    // FSCTL Fail Encrypting. We can reuse the InputData.
                                                    // No stream has been encrypted yet.
                                                    // Decrypt File will do the trick to restore the file status.
                                                    //
                                                    MarkFileForDelete( hBackupFile );

                                                    ( VOID ) EndErrorEncryptFile(
                                                                        hSourceFile,
                                                                        InputData,
                                                                        InputDataSize,
                                                                        &IoStatusBlock
                                                                        );

                                                    LsapFreeLsaHeap( Fek );
                                                    Fek = NULL;
                                                    hResult = RtlNtStatusToDosError( Status );
                                                    DebugLog((DEB_ERROR, "GetStreamInformation failed, error = %d\n" ,hResult  ));
EfsErrPrint("Cannot get the Streams for verification. Win Error=%d\n",hResult);
                                                }
                                            } else {

                                                //
                                                // Set encryption failed. No bits are turned on.
                                                // Only the unnamed data stream is created in temp file
                                                //
                                                MarkFileForDelete( hBackupFile );

                                                LsapFreeLsaHeap( Fek );
                                                Fek = NULL;
                                                DebugLog((DEB_ERROR, "EncryptFileSrv: NtFsControlFile failed, status = (%x)\n" ,Status  ));
                                                hResult = RtlNtStatusToDosError( Status );

                                                //
                                                // Make sure the error was mapped
                                                //

                                                if (hResult == ERROR_MR_MID_NOT_FOUND) {

                                                    DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                                                    hResult = ERROR_ENCRYPTION_FAILED;
                                                }
EfsErrPrint("Failed to write the $EFS or turn on the bit. Win Error=%d\n",hResult);
                                            }

                                        } else {

                                            //
                                            // Create Backup File failed or write log file failed
                                            // Temp file is already deleted.
                                            //
                                            LsapFreeLsaHeap( Fek );
                                            Fek = NULL;
                                            DebugLog((DEB_ERROR, "EncryptFileSrv: CreateBackupFile or CreateLogHeader failed, status = (%x)\n" ,Status  ));
                                            hResult = RtlNtStatusToDosError( Status );

                                            //
                                            // Make sure the error was mapped
                                            //

                                            if (hResult == ERROR_MR_MID_NOT_FOUND) {

                                                DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                                                hResult = ERROR_ENCRYPTION_FAILED;
                                            }

                                        }

                                        if ( hBackupFile ){

                                                CloseHandle( hBackupFile );
                                                 hBackupFile = 0;

                                        }

                                        if ( InputData ){

                                            LsapFreeLsaHeap( InputData );
                                        }

                                    } else {

                                        LsapFreeLsaHeap( Fek );
                                        Fek = NULL;
                                        hResult = ERROR_NOT_ENOUGH_MEMORY;
EfsErrPrint("Out of memory.\n");
                                    }

                                    LsapFreeLsaHeap( CurrentEfsStream );

                                } else {

                                    hResult = GetLastError();

                                    DebugLog((DEB_ERROR, "ConstructEFS returned %x\n" ,hResult  ));
                                    LsapFreeLsaHeap( Fek );
                                    Fek = NULL;

EfsErrPrint("Failed to generate the FEK. Win Error=%d\n",hResult);
                                }

                            } else {

                                hResult = GetLastError();

EfsErrPrint("Failed to generate the FEK. Win Error=%d\n",hResult);
                            }

                            CleanupOpenFileStreams(
                                                StreamHandles,
                                                StreamNames,
                                                StreamSizes,
                                                NULL,
                                                hSourceFile,
                                                StreamCount
                                                );

                            StreamHandles = NULL;
                            StreamNames = NULL;
                            hSourceFile = NULL;

                        } else {

                            DebugLog((DEB_ERROR, "OpenFileStreams returned %d\n" ,hResult  ));
EfsErrPrint("Failed to open all the streams. Win Error=%d\n",hResult);
                        }


                        LsapFreeLsaHeap( StreamInfoBase );
                        StreamInfoBase = NULL;

                    } else {

                        //
                        // Unable to get stream information
                        //

                        DebugLog((DEB_ERROR, "Unable to obtain stream information, status = %x\n" ,Status  ));

                        hResult = RtlNtStatusToDosError( Status );

                        //
                        // Make sure the error was mapped
                        //

                        if (hResult == ERROR_MR_MID_NOT_FOUND) {

                            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                            hResult = ERROR_ENCRYPTION_FAILED;
                        }
EfsErrPrint("Failed to get all streams. Win Error=%d\n",hResult);
                    }
                }

                //
                // Free ParentEfsStream
                //

                if ( ParentEfsStream ){

                    LsapFreeLsaHeap( ParentEfsStream );

                }

            } else {

                //
                // GetParentEfsStream failed
                //


                hResult = RtlNtStatusToDosError( Status );

                //
                // Make sure the error was mapped
                //

                if (hResult == ERROR_MR_MID_NOT_FOUND) {

                    DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                    hResult = ERROR_ENCRYPTION_FAILED;
                }
EfsErrPrint("GetParentEfsStream failed. Win Error=%d\n",hResult);

            }
        } else {

            //
            //  Either get volume info failed or get target file ID failed
            //
            if ( !NT_SUCCESS(Status1) ){
                Status = Status1;
            }
            hResult = RtlNtStatusToDosError( Status );

            //
            // Make sure the error was mapped
            //

            if (hResult == ERROR_MR_MID_NOT_FOUND) {

                DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                hResult = ERROR_ENCRYPTION_FAILED;
            }

EfsErrPrint("Either get volume info failed or get target file ID failed. Win Error=%d\n",hResult);
        }

        if ( hSourceFile ){

            CloseHandle( hSourceFile );

        }

    } else {

        //
        // Open source file failed
        //

        hResult = GetLastError();
EfsErrPrint("EFS Open source file failed. Win Error=%d FileName=%ws\n", hResult, SourceFileName);
    }

    if (!KeepLogFile && LogFileH) {
        //
        // Delete the Log File
        //

        MarkFileForDelete( LogFileH );
    }


    LsapFreeLsaHeap( SourceFileName );

    if (hResult != ERROR_SUCCESS) {
        DebugLog((DEB_WARN, "EncryptFileSrv returning %x\n", hResult  ));
    }

    return( hResult );
}



DWORD
DecryptFileSrv(
    IN PUNICODE_STRING SourceFileNameU,
    IN HANDLE LogFileH,
    IN ULONG Recovery
    )
/*++

Routine Description:

    This routine is the top level routine of the EncryptFile API.  It
    opens the passed source file and copies all of its data streams to
    a backup file in a known location.  It then marks all of the streams
    of the source as encrypted, and copies them back.

Arguments:

    SourceFileName - Supplies a Unicode string with the name of
        the file to be encrypted.

    LogFileH - Log file handle. Log file is zero size when passed in.

    Recovery - If the decryption is for recovery or not

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{

    BOOL                     b = TRUE;
    BOOLEAN                  CleanupSuccessful = FALSE;
    BOOLEAN                  KeepLogFile = FALSE;

    ULONG                    StatusInfoOffset = 0 ;
    DWORD                    hResult = ERROR_SUCCESS;
    DWORD                    FileAttributes;

    HANDLE                   FileHandle;
    HANDLE                   hSourceFile = NULL ;
    HANDLE                   hBackupFile = 0;
    PHANDLE                 StreamHandles = NULL;

    LPWSTR                   SourceFileName;
    LPWSTR                   BackupFileName;

    FILE_FS_SIZE_INFORMATION    VolInfo;
    FILE_INTERNAL_INFORMATION  SourceID;
    FILE_INTERNAL_INFORMATION  BackupID;

    NTSTATUS                 Status = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES        Obja;

    PFILE_STREAM_INFORMATION LaterStreamInfoBase = NULL;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;

    PEFS_STREAM_SIZE           StreamSizes = NULL;

    PUNICODE_STRING          StreamNames = NULL;

    UINT                     TmpResult;

    ULONG                    LaterStreamInfoSize = 0;
    ULONG                    StreamCount    = 0;
    ULONG                    StreamInfoSize = 0;
    ULONG                    i;
    DWORD                   tmpDW;

    IO_STATUS_BLOCK IoStatusBlock;
    ULONG InputDataSize;
    ULONG EfsDataLength;
    PUCHAR InputData;
    ULONG   CreateOption = FILE_SYNCHRONOUS_IO_NONALERT;
    UNICODE_STRING SrcNtName;
    WORD WebDavPath = 0;

    if (!LogFileH) {

        //
        //  No LogFile means WEBDAVPATH
        //

        WebDavPath = WEBDAVPATH;
    }

    //
    // Convert the source file name into an LPWSTR
    //

    SourceFileName = (LPWSTR)LsapAllocateLsaHeap( SourceFileNameU->Length + sizeof( UNICODE_NULL ));

    if (SourceFileName == NULL) {

        if (LogFileH) {
            MarkFileForDelete( LogFileH );
        }
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    InputDataSize = 7 * sizeof ( ULONG ) + 2 * sizeof ( DriverSessionKey );
    InputData = (PUCHAR)LsapAllocateLsaHeap( InputDataSize );
    if ( InputData == NULL ) {

        if (LogFileH) {
            MarkFileForDelete( LogFileH );
        }
        LsapFreeLsaHeap( SourceFileName );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    EfsDataLength = InputDataSize - 3 * sizeof ( ULONG );


    SourceFileName[SourceFileNameU->Length/sizeof(WCHAR)] = UNICODE_NULL;
    RtlCopyMemory( SourceFileName, SourceFileNameU->Buffer, SourceFileNameU->Length );

    DebugLog((DEB_TRACE_EFS, "Decrypting file %ws \n", SourceFileName));

    FileAttributes = GetFileAttributes( SourceFileName );

     if (FileAttributes == -1) {

        if (LogFileH) {
            MarkFileForDelete( LogFileH );
        }
        LsapFreeLsaHeap( SourceFileName );
        LsapFreeLsaHeap( InputData );
        return GetLastError();

    }

    if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
      CreateOption |= FILE_OPEN_REPARSE_POINT;
    }

    b =  RtlDosPathNameToNtPathName_U(
                        SourceFileName,
                        &SrcNtName,
                        NULL,
                        NULL
                        );

    if ( b ){

        InitializeObjectAttributes(
                    &Obja,
                    &SrcNtName,
                    OBJ_CASE_INSENSITIVE,
                    0,
                    NULL
                    );

        Status = NtCreateFile(
                        &hSourceFile,
                        FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        0,
                        FILE_OPEN,
                        CreateOption,
                        NULL,
                        0
                        );

        //
        //  Free the NT name
        //
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            SrcNtName.Buffer
            );

    } else {

        //
        //   The error code here is not quite accurate here. It is very unlikely
        //   getting here. Possibly out of memory
        //

        Status =  STATUS_ENCRYPTION_FAILED;
        hResult = GetLastError();

    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // Determine if this path is to a directory or a file.  If it's a directory,
        // we have very little to do.
        //

        Status = NtQueryVolumeInformationFile(
            hSourceFile,
            &IoStatusBlock,
            &VolInfo,
            sizeof ( FILE_FS_SIZE_INFORMATION ),
            FileFsSizeInformation
            );

        if ( NT_SUCCESS( Status ) && (WebDavPath != WEBDAVPATH) ){

            Status = NtQueryInformationFile(
                hSourceFile,
                &IoStatusBlock,
                &SourceID,
                sizeof ( FILE_INTERNAL_INFORMATION ),
                FileInternalInformation
                );

        }

        if ( !NT_SUCCESS( Status ) ) {

            CloseHandle( hSourceFile );
            if (LogFileH) {
                MarkFileForDelete( LogFileH );
            }
            LsapFreeLsaHeap( SourceFileName );
            LsapFreeLsaHeap( InputData );
            hResult = RtlNtStatusToDosError( Status );

            //
            // Make sure the error was mapped
            //

            if (hResult == ERROR_MR_MID_NOT_FOUND) {

                DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                hResult = ERROR_DECRYPTION_FAILED;
            }

            return hResult;
        }

        if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            //  We do not check the operation of the LOG.
            //  Should we fail the normal operation just because the LOG operations
            //  failed?  The answer is probably not. The chance to use the LOG file is very
            //  slim. We will use TxF when it is ready and we have time to deal with this.
            //

            if (LogFileH) {
                CreateLogHeader(
                    LogFileH,
                    VolInfo.BytesPerSector,
                    &(SourceID.IndexNumber),
                    NULL,
                    SourceFileName,
                    NULL,
                    Decrypting,
                    BeginDecryptDir,
                    NULL
                    );
            }

            //
            // FSCTL Do Directory stuff
            //

    
            Status =  SendSkFsctl(
                            EFS_DECRYPT_STREAM,
                            EFS_DECRYPT_DIRSTR,
                            EFS_SET_ENCRYPT,
                            InputData,
                            InputDataSize,
                            hSourceFile,
                            FSCTL_SET_ENCRYPTION,
                            &IoStatusBlock
                            );

            if ( NT_SUCCESS( Status ) && IoStatusBlock.Information ){

                // 
                // IoStatusBlock.Information != 0 means there is no more encrypted
                // streams in the file (or dir).
                // If the following call failed, we could hardly restore the dir to the
                // perfect condition. It is very unlikely to fail here while we
                // succeed above.
                //

                Status =  SendSkFsctl(
                                EFS_DECRYPT_FILE,
                                EFS_DECRYPT_DIRFILE,
                                EFS_SET_ENCRYPT,
                                InputData,
                                InputDataSize,
                                hSourceFile,
                                FSCTL_SET_ENCRYPTION,
                                &IoStatusBlock
                                );

            } else if ( NT_SUCCESS( Status ) && (IoStatusBlock.Information == 0)) {

                //
                // More than 1 streams on the directory were encrypted. Log it.
                //


                EfsLogEntry(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_DIR_MULTISTR_ERROR,
                    1,
                    0,
                    (LPCWSTR *)&SourceFileName,
                    NULL
                    );

            }
    

            CloseHandle( hSourceFile );
            if (LogFileH) {
                MarkFileForDelete( LogFileH );
            }
            LsapFreeLsaHeap( SourceFileName );
            LsapFreeLsaHeap( InputData );
            if ( NT_SUCCESS( Status ) ){

                return( ERROR_SUCCESS );

            } else {

                return(ERROR_DECRYPTION_FAILED);
            }
        }

        //
        // Enumerate all the streams on the file
        //

        Status = GetStreamInformation(
                     hSourceFile,
                     &StreamInfoBase,   // Free this
                     &StreamInfoSize
                     );

        if (NT_SUCCESS( Status )) {

            hResult = OpenFileStreams(
                         hSourceFile,
                         0,
                         OPEN_FOR_DEC,
                         StreamInfoBase,
                         FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                         FILE_OPEN,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                         &VolInfo,
                         &StreamNames,      // Don't free this!
                         &StreamHandles,    // Free this
                         &StreamSizes,      // Free this
                         &StreamCount
                         );

            if (hResult == ERROR_SUCCESS) {

                //
                // This routine creates the backup file.
                //

                Status = CreateBackupFile(
                                    SourceFileNameU,
                                    &hBackupFile,
                                    &BackupID,
                                    &BackupFileName
                                    );

                //
                // If power down happens right here before
                // the log file header is written, we will have a zero size
                // temp file left on the disk. This is very unlikely and not
                // a big deal we have a zero size file left on the disk.
                //

                if ( NT_SUCCESS(Status) ){

                    if (LogFileH) {
                        Status = CreateLogHeader(
                                            LogFileH,
                                            VolInfo.BytesPerSector,
                                            &(SourceID.IndexNumber),
                                            &(BackupID.IndexNumber),
                                            SourceFileName,
                                            BackupFileName,
                                            Decrypting,
                                            BeginDecryptFile,
                                            &StatusInfoOffset
                                            );
                    }

                    //
                    // BackupFile name not needed any more.
                    //

                    LsapFreeLsaHeap( BackupFileName );

                    if ( NT_SUCCESS(Status) ){

                        if (LogFileH) {
                            Status = WriteLogFile(
                                            LogFileH,
                                            VolInfo.BytesPerSector,
                                            StatusInfoOffset,
                                            BeginDecryptFile
                                            );
                        }

                        if ( !NT_SUCCESS(Status) ){

                            //
                            // Delete the backup file
                            //

                            MarkFileForDelete( hBackupFile );
                            CloseHandle( hBackupFile );
                            hBackupFile = 0;
                        }

                    } else {
                        MarkFileForDelete( hBackupFile );
                        CloseHandle( hBackupFile );
                        hBackupFile = 0;
                    }

                } else {

                    //
                    // Fail to create the backup file
                    // Log it.
                    //


                    EfsLogEntry(
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_TMP_FILE_ERROR,
                        1,
                        sizeof(NTSTATUS),
                        (LPCWSTR *)&SourceFileName,
                        &Status
                        );

                }

                if ( NT_SUCCESS(Status) ){

                    //
                    // We have handles to all of the streams of the file
                    //
                    // Enter "Decrypting" state here.  FSCTL call.
                    //
                    // All failures from here on out need to be closed
                    // with another FSCTL call.
                    //
                    Status =  SendSkFsctl(
                                    0,
                                    0,
                                    EFS_DECRYPT_BEGIN,
                                    InputData,
                                    InputDataSize,
                                    hSourceFile,
                                    FSCTL_ENCRYPTION_FSCTL_IO,
                                    &IoStatusBlock
                                    );
                }

                if ( !NT_SUCCESS( Status ) ){

                    //
                    //  Nothing has been done to the file.
                    //

                    CleanupOpenFileStreams(
                                        StreamHandles,
                                        StreamNames,
                                        StreamSizes,
                                        StreamInfoBase,
                                        hSourceFile,
                                        StreamCount
                                        );

                    StreamHandles = NULL;
                    StreamNames = NULL;
                    StreamInfoBase = NULL;
                    if (LogFileH) {
                        MarkFileForDelete( LogFileH );
                    }
                    if ( hBackupFile ) {
                        MarkFileForDelete( hBackupFile );
                        CloseHandle( hBackupFile );
                    }
                    LsapFreeLsaHeap( SourceFileName );
                    LsapFreeLsaHeap( InputData );

                    hResult =  RtlNtStatusToDosError( Status );

                    //
                    // Make sure the error was mapped
                    //

                    if (hResult == ERROR_MR_MID_NOT_FOUND) {

                        DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                        hResult = ERROR_DECRYPTION_FAILED;
                    }

                    return hResult;
                }

                //
                // Enumerate the streams again, and make sure nothing
                // has changed. From this point on, the file is in TRANSITION
                // status. Any failure should not delete the logfile, unless the FSCTL
                // EFS_ENCRYPT_DONE is called
                //

                Status = GetStreamInformation(
                             hSourceFile,
                             &LaterStreamInfoBase,    // Free this
                             &LaterStreamInfoSize
                             );

                if (NT_SUCCESS( Status )) {

                    if (StreamInfoSize == LaterStreamInfoSize) {

                        //
                        // Compare the original stream info structure with the one we just got,
                        // and make sure they're identical.  If not, punt.
                        //

                        ULONG rc = StringInfoCmp(StreamInfoBase, LaterStreamInfoBase, StreamInfoSize);

                        if (rc == 0) {

                            //
                            // Copy the file to the backup file.  Success if target exists
                            // (because the make temporary file command creates it).
                            //

                            PHANDLE TargetHandles = NULL;

                            //
                            // Revert to self to open multiple streams on the backup file
                            //

                            RpcRevertToSelf();

                            hResult = MyCopyFile(
                                        hSourceFile,        // handle to the file we're copying from (source file)
                                        StreamNames,        // names of the streams of the source file
                                        StreamHandles,      // handles to the streams of the source file
                                        StreamSizes,        // sizes of the streams of the source file
                                        StreamCount,        // number of streams we're copying, including unnamed data stream
                                        hBackupFile,         // Backup file handle
                                        &TargetHandles      // new handles of corresponding streams on backup file
                                        );


                            //
                            // Even the impersonation failed, it is OK. We already got all the handles we need.
                            //

                            ( VOID ) RpcImpersonateClient( NULL );

                            if (hResult == ERROR_SUCCESS) {

                                //
                                // The backup file now exists and has data in it.
                                // We do not check the error code of WriteLogFile for the following reasons,
                                // 1. We are overwriting the sectors, out of disk space is not possible. The sectors have
                                //     just been written, defective sector is very unlikely.
                                // 2. In case, the sector becomes defective between the two writes. More than 99.99%
                                //     we can still finish the job without any problem.
                                // 3. In real life, it is very unlikely that power down or crash happens here and the sectors
                                //     just become defective right after last write.
                                //
                                // When later TxF is used, we will not manage the log file.
                                //

                                if (LogFileH) {
                                    ( VOID )WriteLogFile(
                                                    LogFileH,
                                                    VolInfo.BytesPerSector,
                                                    StatusInfoOffset,
                                                    DecryptTmpFileWritten
                                                    );
                                }


                                hResult = CheckOpenSection(
                                                        StreamSizes,
                                                        StreamHandles,
                                                        StreamCount
                                                        );

                                if ( ERROR_SUCCESS == hResult ){

                                   //
                                    // Reuse the input data buffer for each stream
                                    // FSCTL call.
                                    //

                                    ( VOID )SendHandle(
                                                hSourceFile,
                                                InputData + 3 * sizeof( ULONG ),
                                                &EfsDataLength
                                                );

                                    ( VOID ) EncryptFSCTLData(
                                                EFS_SET_ENCRYPT,
                                                EFS_DECRYPT_STREAM,
                                                EFS_DECRYPT_STREAM,
                                                InputData + 3 * sizeof(ULONG),
                                                EfsDataLength,
                                                InputData,
                                                &InputDataSize
                                                );

                                    //
                                    // Copy each stream from the backup to the original.
                                    // CopyFileStreams attempts to undo things in case of problems,
                                    // so we just have to report success or failure.
                                    //

                                    hResult = CopyFileStreams(
                                                 TargetHandles,     // handles to streams on the backup file
                                                 StreamHandles,     // handles to streams on the source file
                                                 StreamCount,       // number of streams
                                                 StreamSizes,       // sizes of streams
                                                 Decrypting,        // mark StreamHandles as Encrypted before copy
                                                 InputData,         // FSCTL input data
                                                 InputDataSize,     // FSCTL input data size
                                                 &CleanupSuccessful
                                                 );
                                }

                                if (hResult == ERROR_SUCCESS ) {

                                    //
                                    // Encryption is almost done. The file is still in a transit status
                                    // No error checking for writing the log file for the same reason
                                    // mentioned above.
                                    //

                                    if (LogFileH) {
                                        ( VOID )WriteLogFile(
                                                        LogFileH,
                                                        VolInfo.BytesPerSector,
                                                        StatusInfoOffset,
                                                        DecryptionDone
                                                        );
                                    }

                                    //
                                    // FSCTL Mark Decryption success
                                    //

                                    ( VOID ) SendSkFsctl(
                                                    EFS_DECRYPT_FILE,
                                                    EFS_DECRYPT_FILE,
                                                    EFS_SET_ENCRYPT,
                                                    InputData,
                                                    InputDataSize,
                                                    hSourceFile,
                                                    FSCTL_SET_ENCRYPTION,
                                                    &IoStatusBlock
                                                    );

                                    //
                                    // Delete the backup file first.
                                    //

                                    LONG j;


                                    for (j = StreamCount - 1 ; j >= 0 ; j--) {
                                        MarkFileForDelete( TargetHandles[j] );
                                    }

                                } else {

                                    if ( CleanupSuccessful ){

                                        //
                                        // The operation failed, but we could back out cleanly.
                                        // Delete the backup file first.
                                        //

                                        LONG j;


                                        for (j = StreamCount - 1 ; j >= 0 ; j--) {
                                            MarkFileForDelete( TargetHandles[j] );
                                        }


                                    } else {
                                        //
                                        // The operation failed and we couldn't clean up.  Keep the
                                        // log file and the backup file around so we can retry on
                                        // reboot.
                                        //

                                        KeepLogFile = TRUE;
                                    }


                                }

                                //
                                // Regardless of what happened, we don't need these any more.
                                //

                                LONG j;

                                for (j=StreamCount - 1 ; j >= 0 ; j--) {

                                    CloseHandle( TargetHandles[j] );

                                }

                                LsapFreeLsaHeap( TargetHandles );

                            } else {

                                //
                                // We couldn't copy everything to the backup file.
                                //
                                // Tell the driver that the operation has failed.
                                //
                                // MyCopyFile has already taken care of cleaning up the
                                // backup file.
                                //

                                DebugLog((DEB_ERROR, "MyCopyFile failed, error = %d\n" ,hResult  ));

                                //
                                // FSCTL Fail Decrypting
                                // EFS_ENCRYPT_DONE will do the trick.
                                //

                                ( VOID ) SendSkFsctl(
                                                0,
                                                0,
                                                EFS_ENCRYPT_DONE,
                                                InputData,
                                                InputDataSize,
                                                hSourceFile,
                                                FSCTL_ENCRYPTION_FSCTL_IO,
                                                &IoStatusBlock
                                                );

                                if ( hBackupFile ) {
                                    //
                                    // MyCopyFile has deleted the backup file
                                    //

                                    hBackupFile = 0;
                                }
                            }
                        } else {

                            //
                            // FSCTL Fail Decrypting
                            // EFS_ENCRYPT_DONE will do the trick.
                            //

                            ( VOID ) SendSkFsctl(
                                            0,
                                            0,
                                            EFS_ENCRYPT_DONE,
                                            InputData,
                                            InputDataSize,
                                            hSourceFile,
                                            FSCTL_ENCRYPTION_FSCTL_IO,
                                            &IoStatusBlock
                                            );

                            if ( hBackupFile ) {
                                MarkFileForDelete( hBackupFile );
                                CloseHandle( hBackupFile );
                                hBackupFile = 0;
                            }

                            hResult = ERROR_DECRYPTION_FAILED;
                        }

                    } else {

                        //
                        // FSCTL Fail Decrypting
                        // EFS_ENCRYPT_DONE will do the trick.
                        //

                        ( VOID ) SendSkFsctl(
                                        0,
                                        0,
                                        EFS_ENCRYPT_DONE,
                                        InputData,
                                        InputDataSize,
                                        hSourceFile,
                                        FSCTL_ENCRYPTION_FSCTL_IO,
                                        &IoStatusBlock
                                        );

                        if ( hBackupFile ) {
                            MarkFileForDelete( hBackupFile );
                            CloseHandle( hBackupFile );
                            hBackupFile = 0;
                        }

                        hResult = ERROR_DECRYPTION_FAILED;
                    }


                    LsapFreeLsaHeap( LaterStreamInfoBase );

                } else {

                    //
                    // FSCTL Fail Decrypting
                    // EFS_ENCRYPT_DONE will do the trick.
                    //

                    ( VOID ) SendSkFsctl(
                                    0,
                                    0,
                                    EFS_ENCRYPT_DONE,
                                    InputData,
                                    InputDataSize,
                                    hSourceFile,
                                    FSCTL_ENCRYPTION_FSCTL_IO,
                                    &IoStatusBlock
                                    );

                    if ( hBackupFile ) {
                        MarkFileForDelete( hBackupFile );
                        CloseHandle( hBackupFile );
                        hBackupFile = 0;
                    }

                    hResult = RtlNtStatusToDosError( Status );

                    //
                    // Make sure the error was mapped
                    //

                    if (hResult == ERROR_MR_MID_NOT_FOUND) {

                        DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                        hResult = ERROR_DECRYPTION_FAILED;
                    }

                }

                CleanupOpenFileStreams(
                                    StreamHandles,
                                    StreamNames,
                                    StreamSizes,
                                    NULL,
                                    hSourceFile,
                                    StreamCount
                                    );

                StreamHandles = NULL;
                StreamNames = NULL;
                hSourceFile = NULL;
            }

            LsapFreeLsaHeap( StreamInfoBase );

        } else {

            hResult = RtlNtStatusToDosError( Status );

            //
            // Make sure the error was mapped
            //

            if (hResult == ERROR_MR_MID_NOT_FOUND) {

                DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                hResult = ERROR_DECRYPTION_FAILED;
            }
        }

        if ( hSourceFile ){

            CloseHandle( hSourceFile );

        }

    } else {

        if ( Status != STATUS_ENCRYPTION_FAILED ){
            //
            // NtCreateFile failed
            //

            if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
                hResult = ERROR_FILE_READ_ONLY;
            } else {

                hResult = RtlNtStatusToDosError( Status );

                //
                // Make sure the error was mapped
                //

                if (hResult == ERROR_MR_MID_NOT_FOUND) {

                    DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                    hResult = ERROR_DECRYPTION_FAILED;
                }

            }

        }

        // else   Convert Dos name failed
    }

    if (!KeepLogFile && LogFileH) {
        MarkFileForDelete( LogFileH );
    }

    //
    // Free memory
    //

    LsapFreeLsaHeap( SourceFileName );
    LsapFreeLsaHeap( InputData );

    return( hResult );
}



DWORD
MyCopyFile(
    HANDLE hSourceFile,
    PUNICODE_STRING StreamNames,
    PHANDLE StreamHandles,
    PEFS_STREAM_SIZE StreamSizes,
    ULONG StreamCount,
    HANDLE hTargetFile,
    PHANDLE * TargetStreamHandles
    )
{

    ULONG i;
    NTSTATUS Status;
    PHANDLE TargetHandles;
    DWORD hResult = 0;
    IO_STATUS_BLOCK IoStatusBlock;

    TargetHandles = (PHANDLE)LsapAllocateLsaHeap( StreamCount * sizeof( HANDLE ));

    if (TargetHandles == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    RtlZeroMemory( TargetHandles, StreamCount * sizeof( HANDLE ));
    for (i=0 ; i<StreamCount ; i++) {

        //
        // For each stream on the source, create a stream with the same name on the target
        //

        if ( (DEF_STR_LEN == StreamNames[i].Length) &&
             !memcmp( StreamNames[i].Buffer,
                    DEFAULT_STREAM,
                    StreamNames[i].Length
                    )){

            //
            // Default stream
            //

            TargetHandles[i] = hTargetFile;

            if ( !(StreamSizes[i].StreamFlag & FILE_ATTRIBUTE_SPARSE_FILE) ){

                //
                // Reserve space for non sparse stream
                //
                FILE_END_OF_FILE_INFORMATION    FileSize;

                FileSize.EndOfFile = StreamSizes[i].EOFSize;
                Status = NtSetInformationFile(
                            TargetHandles[i],
                            &IoStatusBlock,
                            &FileSize,
                            sizeof(FileSize),
                            FileEndOfFileInformation
                            );

            }  else {

                Status = STATUS_SUCCESS;

            }

        } else {
            OBJECT_ATTRIBUTES Obja;
            PLARGE_INTEGER  AllocSize;

            if ( !(StreamSizes[i].StreamFlag & FILE_ATTRIBUTE_SPARSE_FILE) ){

                //
                // Reserve space for non sparse stream
                //

                AllocSize = &(StreamSizes[i].EOFSize);

            } else {

                AllocSize = NULL;

            }

            InitializeObjectAttributes(
                &Obja,
                &StreamNames[i],
                0,
                hTargetFile,
                NULL
                );

            Status = NtCreateFile(
                        &TargetHandles[i],
#ifdef EFSDBG
                        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
#else
                        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
#endif
                        &Obja,
                        &IoStatusBlock,
                        AllocSize,
                        0,
#ifdef EFSDBG
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,        // have to share with delete-ers, since the main stream is open for delete
#else
                        FILE_SHARE_DELETE,        // have to share with delete-ers, since the main stream is open for delete
#endif
                        FILE_CREATE,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                        NULL,
                        0
                        );

            if (!NT_SUCCESS( Status )){

                    //
                    // Just make sure it is zero
                    //

                    TargetHandles[i] = 0;
            }

        }

        if (NT_SUCCESS( Status )) {

            USHORT State = COMPRESSION_FORMAT_NONE;
            ULONG Length;

            if ( StreamSizes[i].StreamFlag & FILE_ATTRIBUTE_COMPRESSED ){

                State = COMPRESSION_FORMAT_DEFAULT;

            }

            //
            // Return code is not checked. Failing to compress or decompress  the
            // the temp file should not prevent the encryption operation.
            //

            (VOID) DeviceIoControl(
                                TargetHandles[i],
                                FSCTL_SET_COMPRESSION,
                                &State,
                                sizeof(USHORT),
                                NULL,
                                0,
                                &Length,
                                FALSE
                                );

            hResult = CopyStream( TargetHandles[i], StreamHandles[i], &StreamSizes[i] );
        }

        if (!NT_SUCCESS( Status ) || hResult != ERROR_SUCCESS) {

            //
            // We either failed in creating a new stream on the target,
            // or in copying it from the source to the target.  Regardless,
            // for each stream we created in the target, delete it.
            //

            ULONG StreamsCreated;

            if (NT_SUCCESS( Status ) || TargetHandles[i]) {

                StreamsCreated = i;

            } else {

                StreamsCreated = i-1;
            }

            ULONG j;

            //
            //  Default stream handle is in TargetHandles[0]
            //

            for ( j = 0 ; j <=StreamsCreated ; j++) {

                //
                // Paranoia: check if the handle is valid.
                //

                if (TargetHandles[j]){
                    MarkFileForDelete( TargetHandles[j] );
                    CloseHandle( TargetHandles[j] );
                }
            }

            LsapFreeLsaHeap( TargetHandles );

            //
            // Just to be safe
            //

            TargetHandles = NULL;

            if (!NT_SUCCESS( Status )) {
                hResult = RtlNtStatusToDosError( Status );
            }
            break;
        }
    }

    *TargetStreamHandles = TargetHandles;

    return( hResult );
}

DWORD
OpenFileStreams(
    IN HANDLE hSourceFile,
    IN ULONG ShareMode,
    IN ULONG Flag,
    IN PFILE_STREAM_INFORMATION StreamInfoBase,
    IN ULONG FileAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOption,
    IN  PFILE_FS_SIZE_INFORMATION VolInfo,
    OUT PUNICODE_STRING * StreamNames,
    OUT PHANDLE * StreamHandles,
    OUT PEFS_STREAM_SIZE * StreamSizes,
    OUT PULONG StreamCount
    )
/*++

Routine Description:

    This routine opens the streams of file hSourceFile.

Arguments:

    hSourceFile - Supplies an opened handle to the file being worked.

    ShareMode - The share mode to open the streams.

    Flags - The reason for open the streams.

    StreamInfoBase - Information about the streams;

    StreamNames - The names of the streams.

    StreamHandles - The handles of the streams.

    StreamCount - Number strteams in the file.

    FileAccess - Desired access to the streams.

    CreateDisposition - Create disposition of the streams.

    CreateOption - Create options of the streams.

    StreamSizes - the sizes and attributes of the streams.

Return Value:

    Result of the operation.
--*/
{
    NTSTATUS Status;
    PUNICODE_STRING Names = NULL;
    PHANDLE Handles = NULL;
    PEFS_STREAM_SIZE Sizes = NULL;
    DWORD rc = ERROR_SUCCESS;

    PFILE_STREAM_INFORMATION StreamInfo = StreamInfoBase;
    BOOL b;

    //
    // First, count the number of streams
    //

    if (StreamInfoBase == NULL) {

        //
        // No stream to open. TRUE for most DIR.
        //

        *StreamCount = 0;
        return ERROR_SUCCESS;

    }

    *StreamCount = 0;

    while ( StreamInfo ) {

        (*StreamCount)++;

        if (StreamInfo->NextEntryOffset){
            StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
        } else {
            StreamInfo = NULL;
        }
    }

    DebugLog((DEB_TRACE_EFS, "Found %d streams\n",*StreamCount));

    //
    // Allocate enough room for pointers and handles to the streams and their names
    //

    Handles = (PHANDLE)       LsapAllocateLsaHeap( *StreamCount * sizeof( HANDLE ));
    Names = (PUNICODE_STRING) LsapAllocateLsaHeap( *StreamCount * sizeof( UNICODE_STRING ));
    if ( StreamSizes ){
        Sizes = (PEFS_STREAM_SIZE)  LsapAllocateLsaHeap( *StreamCount * sizeof( EFS_STREAM_SIZE ));
    }

    if (Names == NULL || Handles == NULL || (StreamSizes && (Sizes == NULL))) {

        if (Handles != NULL) {
            LsapFreeLsaHeap( Handles );
        }

        if (Names != NULL) {
            LsapFreeLsaHeap( Names );
        }

        if (Sizes != NULL) {
            LsapFreeLsaHeap( Sizes );
        }

        DebugLog((DEB_ERROR, "Out of heap in OpenFileStreams\n"));
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Zero out the handle array to simplify cleanup later
    //

    RtlZeroMemory( Handles, *StreamCount * sizeof( HANDLE ));

    //
    // Open a handle to each stream for exclusive access
    //

    StreamInfo = StreamInfoBase;

    ULONG i = 0;

    while ( StreamInfo ) {

        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Build a string descriptor for the name of the stream.
        //

        Names[i].Buffer = &StreamInfo->StreamName[0];
        Names[i].MaximumLength = Names[i].Length = (USHORT) StreamInfo->StreamNameLength;

        if (Sizes != NULL) {
            Sizes[i].EOFSize = StreamInfo->StreamSize;
            Sizes[i].AllocSize = StreamInfo->StreamAllocationSize;
        }

        DebugLog((DEB_TRACE_EFS, "Opening stream %wZ\n",&Names[i]));

        if ( StreamInfo->NextEntryOffset ){
            StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
        } else {
            StreamInfo = NULL;
        }

        //
        // To avoid sharing violation, we do not open the default stream again.
        // This also improves the performance
        //

        if ( (DEF_STR_LEN == Names[i].Length) &&
             !memcmp( Names[i].Buffer,
                    DEFAULT_STREAM,
                    DEF_STR_LEN
                    )
           ){

            Handles[i] = hSourceFile;
            Status = STATUS_SUCCESS;

        } else {

            //
            // Open the source stream.
            //

            OBJECT_ATTRIBUTES Obja;

            InitializeObjectAttributes(
                &Obja,
                &Names[i],
                0,
                hSourceFile,
                NULL
                );

            Status = NtCreateFile(
                        &Handles[i],
                        FileAccess,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        ShareMode,
                        FILE_OPEN,
                        CreateOption,
                        NULL,
                        0
                        );

        }

        if ( NT_SUCCESS(Status) && ( Flag != OPEN_FOR_EXP ) ){

            //
            // Flush the streams. This is not allowed in export because of the permission.
            //

            Status = NtFlushBuffersFile(
                                Handles[i],
                                &IoStatusBlock
                                );

        }

        if ( (Sizes != NULL) && NT_SUCCESS(Status) ) {

            FILE_BASIC_INFORMATION  StreamBasicInfo;
            IO_STATUS_BLOCK IoStatusBlock;

            //
            // Get File Attributes
            //
            Status = NtQueryInformationFile(
                Handles[i],
                &IoStatusBlock,
                &StreamBasicInfo,
                sizeof ( FILE_BASIC_INFORMATION ),
                FileBasicInformation
                );

            if (NT_SUCCESS(Status)){
                Sizes[i].StreamFlag = StreamBasicInfo.FileAttributes;
            }

        }

        if ( !NT_SUCCESS(Status) ) {

            DebugLog((DEB_ERROR, "Unable to open stream %wZ, status = (%x)\n", &Names[i], Status ));
            rc = RtlNtStatusToDosError( Status );

            //
            // In case the error isn't mapped, make sure we return something intelligent
            //

            if (rc == ERROR_MR_MID_NOT_FOUND) {
                DebugLog((DEB_TRACE_EFS, "OpenFileStreams returning ERROR_ENCRYPTION_FAILED\n" ));
                rc = ERROR_ENCRYPTION_FAILED;
            }

           break;

        }
        i++;

    }

    //
    // Estimate the space for Encrypt or Decrypt operation
    //

    if ( (rc == ERROR_SUCCESS) &&
          ((Flag == OPEN_FOR_ENC) || (Flag == OPEN_FOR_DEC))){

        rc = CheckVolumeSpace( VolInfo, Sizes, Handles, *StreamCount);

    }

    if ( rc != ERROR_SUCCESS ) {

            ULONG j;

            for (j=0 ; j<i ; j++) {
                if ( hSourceFile != Handles[j] ){
                    NtClose( Handles[j] );
                }
            }
    }

    if ( rc == ERROR_SUCCESS ) {

        *StreamNames = Names;
        *StreamHandles = Handles;
        if (StreamSizes){
            *StreamSizes = Sizes;
        }

    } else {

        LsapFreeLsaHeap( Names);
        LsapFreeLsaHeap( Handles);
        if ( Sizes ){
            LsapFreeLsaHeap( Sizes);
        }

    }

    return( rc );
}

NTSTATUS
GetStreamInformation(
    IN HANDLE SourceFile,
    OUT PFILE_STREAM_INFORMATION * StreamInfoBase,
    OUT PULONG StreamInfoSize
    )

/*++

Routine Description:

    This routine queries the stream information from the passed source file.

Arguments:

    SourceFile - Supplies an opened handle to the file being queried.

    StreamInfoBase - Returns a pointer to the stream information as returned
        by NtQueryInformationFile().

    StreamInfoSize - Returns the size of the information returned in the
        StreamInfoBase parameter.

Return Value:

    STATUS_SUCCESS on success, else failure, either from RtlAllocateHeap()
        or NtQueryInformationFile();

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    *StreamInfoSize = 4096;

    //
    // Stolen from CreateDirectoryExW (base\client\dir.c)
    //

    do {
        *StreamInfoBase = (PFILE_STREAM_INFORMATION)LsapAllocateLsaHeap( *StreamInfoSize);
        if ( NULL == *StreamInfoBase ) {
            return( STATUS_NO_MEMORY );
            }
        RtlZeroMemory(*StreamInfoBase, *StreamInfoSize);

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatusBlock,
                    (PVOID) *StreamInfoBase,
                    *StreamInfoSize,
                    FileStreamInformation
                    );

        if ( !NT_SUCCESS(Status) ) {
            LsapFreeLsaHeap( *StreamInfoBase);
            *StreamInfoBase = NULL;
            *StreamInfoSize *= 2;
        } else {
            if (IoStatusBlock.Information == 0) {

                //
                // No data stream were found. True for most DIR.
                //

                LsapFreeLsaHeap( *StreamInfoBase);
                *StreamInfoBase = NULL;
                *StreamInfoSize = 0;

            }
        }

    } while ( Status == STATUS_BUFFER_OVERFLOW ||
              Status == STATUS_BUFFER_TOO_SMALL );

    return( Status );
}


DWORD
CopyFileStreams(
    PHANDLE SourceStreams,
    PHANDLE StreamHandles,
    ULONG StreamCount,
    PEFS_STREAM_SIZE StreamSizes,
    EFSP_OPERATION Operation,
    PUCHAR FsInputData,
    ULONG FsInputDataSize,
    PBOOLEAN CleanupSuccessful
    )

/*++

Routine Description:

    This routine takes an array of source handles and target handles
    and attempts to copy the sources to the targets, in the order
    that the handles appear in the arrays.

    If there is an error part of the way through, this routine will
    try to clean up as well as it can, and return to the user whether
    or not to consider the target file corrupted.

Arguments:

    SourceStreams - Supplies an array of handles to streams to be copied.

    StreamHandles - Supplies an array of handles of target streams to be
        copied into.

    StreamCount - Supplies the number of elemets in the first two arrays.

    StreamSizes - Supplies an array of sizes of the streams being copied.

    Operation - Whether the streams are being encrypted or decrypted.

    FsInputData - Supplies the input data for the FSCTL_SET_ENCRYPTION call.

    FsInputDataSize - The length of FsInputData.

    CleanupSuccessful - If there is a failure, this parameter will return
        whether or not one or more of the streams on the file has been
        corrupted.


Return Value:

    ERROR_SUCCESS on success, failure otherwise.  In case of failure,
    callers should examine the CleanupSuccessful flag to determine the
    state of the target file.

--*/
{
    ULONG StreamIndex;
    DWORD hResult = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL b = TRUE;
    ULONG i;
    DWORD rc = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION  StreamBasicInfo = { 0 };

    *CleanupSuccessful = TRUE;

    for (StreamIndex = 0; StreamIndex < StreamCount ; StreamIndex++) {

        if ( Operation == EncryptRecovering ) {

            //
            // Called for recovering an unsuccessful encrypt. Get the attributes first.
            //

            Status = NtQueryInformationFile(
                StreamHandles[StreamIndex],
                &IoStatusBlock,
                &StreamBasicInfo,
                sizeof ( FILE_BASIC_INFORMATION ),
                FileBasicInformation
                );

            if ( !NT_SUCCESS( Status )) {

                b = FALSE;
                break;

            }
        }

        if ( ( Operation != EncryptRecovering ) ||
             (StreamBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ){
            //
            // Mark target stream encrypted or decrypted.
            // Encrypt or decrypt information is in the input data
            //
            Status = NtFsControlFile(
                        StreamHandles[StreamIndex],
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_SET_ENCRYPTION,
                        FsInputData,
                        FsInputDataSize,
                        NULL,
                        0
                        );
        }


        if (NT_SUCCESS( Status )) {

            if ( Operation == EncryptRecovering ) {

                //
                // Check if we need to re-compress the file
                //

                if ( StreamSizes[StreamIndex].StreamFlag & FILE_ATTRIBUTE_COMPRESSED ){

                    //
                    //  Compress the target stream
                    //

                    USHORT State = COMPRESSION_FORMAT_DEFAULT;
                    ULONG Length;

                    //
                    // Return code is not checked. Failing to compress or decompress  the
                    // the original file should not prevent the recovery.
                    //

                    (VOID) DeviceIoControl(
                                        StreamHandles[StreamIndex],
                                        FSCTL_SET_COMPRESSION,
                                        &State,
                                        sizeof(USHORT),
                                        NULL,
                                        0,
                                        &Length,
                                        FALSE
                                        );

                }

            }

            hResult = CopyStream( StreamHandles[StreamIndex], SourceStreams[StreamIndex], &StreamSizes[StreamIndex] );

        } else {

            //
            // Not successful, but if we haven't modified the file at all, we can
            // still back out cleanly.
            //

            if (StreamIndex == 0) {
                return( RtlNtStatusToDosError( Status ) );
            }
        }

        if (!NT_SUCCESS( Status ) || hResult != ERROR_SUCCESS) {

            b = FALSE;
            break;
        }
    }

    if (!b) {

        if (!NT_SUCCESS( Status )) {

            //
            // Save the reason why we failed so we can return it.
            //

            rc = RtlNtStatusToDosError( Status );

        } else {

            rc = hResult;
        }

        //
        // Something failed, back up and clean up.  StreamIndex has the
        // index of the last stream we were operating on.
        //

        if (Operation == Encrypting) {

            //
            // If we were encrypting, then we need to go back and mark each
            // stream decrypted, and attempt to restore it from the backup.
            // If either of those fail, we're hosed.
            //

            for (i=0; i<StreamIndex ; i++) {

                //
                // Mark stream decrypted. We can reuse the input data buffer
                // here.
                //

                ( VOID )GetDecryptFsInput(
                            StreamHandles[StreamIndex],
                            FsInputData,
                            &FsInputDataSize
                            );

                Status = NtFsControlFile(
                            StreamHandles[StreamIndex],
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_SET_ENCRYPTION,
                            FsInputData,
                            FsInputDataSize,
                            NULL,
                            0
                            );

                //
                // Attempt to copy the stream from backup
                //

                hResult = CopyStream( StreamHandles[StreamIndex], SourceStreams[StreamIndex], &StreamSizes[StreamIndex] );

                if (!NT_SUCCESS( Status ) || hResult != ERROR_SUCCESS) {

                    *CleanupSuccessful = FALSE;

                    //
                    // Give up
                    //

                    break;
                }
            }

        } else {

            //
            // Decrypting.  Not a whole lot we can do here, because
            // we can't put the file back the way it was.
            //

            *CleanupSuccessful = FALSE;
        }
    }

    return( rc );
}


DWORD
CopyStream(
    HANDLE Target,
    HANDLE Source,
    PEFS_STREAM_SIZE StreamSize
    )
/*++

Routine Description:

    This routine copies a file stream from a source stream to a target
    stream.  It assumes that the streams have been opened for appropriate
    access.

Arguments:

    Target - Supplies a handle to the stream to be written to.  This handle
        must be open for WRITE access.

    Source - Supplies a stream handle to copy from.  This handle must be open
        for READ access.

    StreamSize - Supplies the size of the stream in bytes.


Return Value:

    ERROR_SUCCESS on success, failure otherwise.

--*/
{

    SYSTEM_INFO SystemInfo;
    LARGE_INTEGER StreamOffset;
    LARGE_INTEGER AllocationGranularity;
    HANDLE hStreamMapping;
    DWORD rc = NO_ERROR;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    if ( 0 == (StreamSize->EOFSize).QuadPart ){

        return ERROR_SUCCESS;

    }

    GetSystemInfo( &SystemInfo );
    SetFilePointer( Target, 0, NULL, FILE_BEGIN);

    AllocationGranularity.HighPart = 0;
    AllocationGranularity.LowPart = SystemInfo.dwAllocationGranularity;

    hStreamMapping = CreateFileMapping( Source, NULL, PAGE_READONLY, 0, 0, NULL );

    if (hStreamMapping == NULL) {
        return( GetLastError() );
    }

    if ( StreamSize->StreamFlag & FILE_ATTRIBUTE_SPARSE_FILE ){

        //
        // Sparsed stream. Query the ranges first.
        //

        FILE_ALLOCATED_RANGE_BUFFER InputData;
        PFILE_ALLOCATED_RANGE_BUFFER Ranges;
        ULONG OutDataBufferSize;
        ULONG   RangeCount;

        //
        // Set the target as a sparse file
        //

        Status = NtFsControlFile(
                    Target,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_SET_SPARSE,
                    NULL,
                    0,
                    NULL,
                    0
                    );

        if ( NT_SUCCESS(Status) ){

            //
            // Set the EOF of the target
            //
            FILE_END_OF_FILE_INFORMATION    FileSize;

            FileSize.EndOfFile = StreamSize->EOFSize;
            Status = NtSetInformationFile(
                        Target,
                        &IoStatusBlock,
                        &FileSize,
                        sizeof(FileSize),
                        FileEndOfFileInformation
                        );

        }

        if ( !NT_SUCCESS(Status) ){

            CloseHandle( hStreamMapping );
            return RtlNtStatusToDosError( Status );

        }

        InputData.FileOffset.QuadPart = 0;
        InputData.Length.QuadPart = 0x7fffffffffffffff;

        OutDataBufferSize = INITBUFFERSIZE;

        do {

            Ranges = (PFILE_ALLOCATED_RANGE_BUFFER)LsapAllocateLsaHeap( OutDataBufferSize );

            if ( NULL == Ranges ){
                CloseHandle( hStreamMapping );
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            Status = NtFsControlFile(
                        Source,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_QUERY_ALLOCATED_RANGES,
                        &InputData,
                        sizeof( FILE_ALLOCATED_RANGE_BUFFER ),
                        Ranges,
                        OutDataBufferSize
                        );

            if (Status == STATUS_PENDING){

                ASSERT(TRUE);
                WaitForSingleObject(
                                       Source,
                                       INFINITE
                                       );

                Status = IoStatusBlock.Status;
            }

            if ( !NT_SUCCESS(Status) ) {
                LsapFreeLsaHeap( Ranges );
                Ranges = NULL;
                OutDataBufferSize += INITBUFFERSIZE;
            }

        } while ( Status == STATUS_BUFFER_OVERFLOW );

        if ( NT_SUCCESS(Status) ){

            //
            //  We got the ranges
            //

            RangeCount = (ULONG)IoStatusBlock.Information / sizeof (FILE_ALLOCATED_RANGE_BUFFER);
            for ( ULONG ii = 0; ii < RangeCount; ii++ ){

                DWORD LowMoved;

                //
                // Move the target file pointer first
                //

                StreamOffset = Ranges[ii].FileOffset;
                LowMoved = SetFilePointer(
                                        Target,
                                        StreamOffset.LowPart,
                                        &StreamOffset.HighPart,
                                        FILE_BEGIN
                                        );
                if ( ( LowMoved != 0xFFFFFFFF ) || ( NO_ERROR != (rc = GetLastError()))){

                    rc = CopyStreamSection(
                            Target,
                            hStreamMapping,
                            &StreamOffset,
                            &(Ranges[ii].Length),
                            &AllocationGranularity
                            );

                }
                if ( NO_ERROR != rc ) {

                    break;

                }

            }

            LsapFreeLsaHeap( Ranges );
            Ranges = NULL;

        } else {

            rc = RtlNtStatusToDosError( Status );
            if ( Ranges ) {
                LsapFreeLsaHeap( Ranges );
                Ranges = NULL;
            }

        }

    } else {

        //
        // Non sparsed stream
        //

        StreamOffset.HighPart = 0;
        StreamOffset.LowPart = 0;

        rc = CopyStreamSection(
                Target,
                hStreamMapping,
                &StreamOffset,
                &(StreamSize->EOFSize),
                &AllocationGranularity
                );

    }

    CloseHandle( hStreamMapping );

    if ( rc == NO_ERROR ) {

        //
        // Flush the stream
        //

        Status = NtFlushBuffersFile(
                            Target,
                            &IoStatusBlock
                            );

        if ( !NT_SUCCESS(Status) ) {
            rc = RtlNtStatusToDosError( Status );
        }
    }

    return( rc );
}


VOID
CleanupOpenFileStreams(
       IN PHANDLE Handles OPTIONAL,
       IN PUNICODE_STRING StreamNames OPTIONAL,
       IN PEFS_STREAM_SIZE Sizes OPTIONAL,
       IN PFILE_STREAM_INFORMATION StreamInfoBase OPTIONAL,
       IN HANDLE HSourceFile OPTIONAL,
       IN ULONG StreamCount
       )
/*++

Routine Description:

    This routine cleans up after a call to OpenFileStreams.

Arguments:

    Handles - Supplies the array of handles returned from OpenFileStreams.

    Sizes - Supplies the array of stream sizes returned from OpenFileStreams.

    StreamCount - Supplies the number of streams returned from OpenFileStreams.


Return Value:

    None.  This is no recovery operation should this routine fail.

--*/
{
    ULONG i;

    if ( Handles ){

        for (ULONG i = 0; i<StreamCount ; i++) {
            if (HSourceFile == Handles[i]) {
                HSourceFile = 0;
            }
            NtClose( Handles[i] );
        }
        LsapFreeLsaHeap( Handles);
        if (HSourceFile) {

            //
            // Dir with data streams will get here
            //

            NtClose( HSourceFile );

        }

    } else if ( HSourceFile ){

        //
        //  HSourceFile is among one of Handles[]
        //


        NtClose( HSourceFile );

    }

    if ( StreamNames ){
        LsapFreeLsaHeap( StreamNames);
    }

    if ( Sizes ){
        LsapFreeLsaHeap( Sizes);
    }

    if ( StreamInfoBase ){
        LsapFreeLsaHeap( StreamInfoBase );
    }

    return;
}


VOID
MarkFileForDelete(
    HANDLE FileHandle
    )

/*++

Routine Description:

    This function marks the passed file for delete, so that it
    will be deleted by the system when its last handle is closed.

Arguments:

    FileHandle - A handle to a file that has been opened for DELETE
        access (see comments in the procedure body about this).


Return Value:

    None.

--*/


{
    FILE_DISPOSITION_INFORMATION Disposition;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

#ifdef EFSDBG

    //
    // If we're in debugging mode, the file has not been opened
    // for delete access, since that would prohibit any other
    // process from accessing the file (which we want to do during
    // the debugging phase).
    //
    // Open the file again, for delete access this time, and
    // mark it for delete.  In the normal case, we don't have
    // to do this.
    //

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Unicode;

    RtlInitUnicodeString( &Unicode, NULL );

    InitializeObjectAttributes(
        &Obja,
        &Unicode,
        0,
        FileHandle,
        NULL
        );

    Status = NtCreateFile(
                &FileHandle,         // yes, overwrite the parameter
                DELETE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("NtCreateFile in MarkFileForDelete failed, status = %x\n",Status);
    }

#endif

//
// "DeleteFile is defined to be DeleteFileW, so undef it here...
//

#undef DeleteFile

        Disposition.DeleteFile = TRUE;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoStatusBlock,
                    &Disposition,
                    sizeof(Disposition),
                    FileDispositionInformation
                    );

        if (!NT_SUCCESS( Status )) {

            WCHAR   ErrorCode[16];
            LPWSTR  pErrorCode;

            _ltow( Status, ErrorCode, 16 );
            pErrorCode = &ErrorCode[0];

            EfsLogEntry(
              EVENTLOG_WARNING_TYPE,
              0,
              EFS_DEL_LOGFILE_ERROR,
              1,
              0,
              (LPCWSTR *)&pErrorCode,
              NULL
              );

        }

#ifdef EFSDBG

        CloseHandle( FileHandle );

#endif
}

BOOLEAN
SendHandle(
    IN HANDLE Handle,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    )

/*++

Routine Description:

    Constructs an EFS Data section of the form (Handle will be truncated to ULONG for SunDown)

    SK, Handle, Handle, [SK, Handle, Handle]sk

Arguments:

    Handle - Supplies the handle value to be encoded

    EfsData - Supplies a buffer large enough to contain the
        output data.

    EfsDataLength - Supplies the length of the EfsData, and
        returns either the length required or the length
        used.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    //
    // Compute the total size required
    //

    ULONG TotalSize = 4 * sizeof( ULONG ) + 2 * sizeof( DriverSessionKey );

    if (*EfsDataLength < TotalSize) {
        *EfsDataLength = TotalSize;
        return( FALSE );
    }

    *EfsDataLength = TotalSize;

    //
    // Copy everything in, and encrypt what needs to be encrypted.
    //

    PUCHAR Where = EfsData;

    RtlCopyMemory( Where, DriverSessionKey, sizeof( DriverSessionKey ) );
    Where += sizeof( DriverSessionKey );

    PULONG pUlong = (PULONG)Where;
    *pUlong = PtrToUlong(Handle);
    Where += sizeof( ULONG );

    pUlong = (PULONG)Where;
    *pUlong = PtrToUlong(Handle);
    Where += sizeof( ULONG );

    PUCHAR CryptData = Where;

    RtlCopyMemory( CryptData, EfsData, TotalSize/2 );

    //
    // Now encrypt the data starting at CryptData
    //

    LONG bytesToBeEnc = (LONG)(TotalSize/2);
    ASSERT( (bytesToBeEnc % DES_BLOCKLEN) == 0 );

    while ( bytesToBeEnc > 0 ) {

        //
        // Encrypt data with DES
        //

        des( CryptData,
             CryptData,
             &DesTable,
             ENCRYPT
           );

        CryptData += DES_BLOCKLEN;
        bytesToBeEnc -= DES_BLOCKLEN;
    }

    return( TRUE );
}


BOOLEAN
SendEfs(
    IN PEFS_KEY Fek,
    IN PEFS_DATA_STREAM_HEADER Efs,
    OUT PUCHAR EfsData,
    OUT PULONG EfsDataLength
    )
/*++

Routine Description:

    Constructs an EFS Data section of the form

    FEK, [FEK]sk, $EFS

Arguments:

    Fek - Supplies the FEK to be encoded

    Efs - Supplies the EFS to be encoded

    EfsData - Supplies a buffer large enough for the returned
        data.

    EfsDataLength - Supplies the length of the EfsData, and
        returns either the length required or the length
        used.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    //
    // Compute the total size required
    //

    ULONG TotalSize = 2 * EFS_KEY_SIZE( Fek ) + Efs->Length;

    if (*EfsDataLength < TotalSize) {
        *EfsDataLength = TotalSize;
        return( FALSE );
    }

    *EfsDataLength = TotalSize;

    //
    // Copy in the FEK twice, followed by the EFS stream
    //

    PUCHAR Where = EfsData;

    RtlCopyMemory( Where, Fek, EFS_KEY_SIZE( Fek ) );
    Where += EFS_KEY_SIZE( Fek );

    //
    // Save the location that we're going to encrypt
    //

    PUCHAR CryptData = Where;

    RtlCopyMemory( Where, Fek, EFS_KEY_SIZE( Fek ) );
    Where += EFS_KEY_SIZE( Fek );

    if ( Where != (PUCHAR) Efs ){
        RtlCopyMemory( Where, Efs, Efs->Length );
    }

    //
    // Encrypt the second FEK
    //

    LONG bytesToBeEnc = (LONG)(EFS_KEY_SIZE( Fek ));
    ASSERT( (bytesToBeEnc % DES_BLOCKLEN) == 0 );

    while ( bytesToBeEnc > 0 ) {

        //
        // Encrypt data with DES
        //

        des( CryptData,
             CryptData,
             &DesTable,
             ENCRYPT
           );

        CryptData += DES_BLOCKLEN;
        bytesToBeEnc -= DES_BLOCKLEN;
    }

    return( TRUE );
}

BOOLEAN
SendHandleAndEfs(
    IN HANDLE Handle,
    IN PEFS_DATA_STREAM_HEADER Efs,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    )
/*++

Routine Description:

    Constructs an EFS Data section of the form (Handle will be truncated to ULONG for SunDown)

    SK, Handle, Handle, [SK, Handle, Handle]sk $EFS

Arguments:

    Fek - Supplies the FEK to be encoded

    Efs - Supplies the EFS to be encoded

    EfsData - Returns a buffer containing the EFS data

    EfsDataLength - Returns the length of the EFS data.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    ULONG TotalSize = 4 * sizeof( ULONG ) + 2 * sizeof( DriverSessionKey ) + Efs->Length;

    if (*EfsDataLength < TotalSize) {
        *EfsDataLength = TotalSize;
        return( FALSE );
    }

    if ( SendHandle( Handle, EfsData, EfsDataLength ) ) {

        //
        // Tack the EFS onto the end of the buffer
        //

        RtlCopyMemory( EfsData + (*EfsDataLength), Efs, Efs->Length );
        *EfsDataLength += Efs->Length;
        return( TRUE );

    } else {

        return( FALSE );
    }
}


BOOLEAN
EncryptFSCTLData(
    IN ULONG Fsctl,
    IN ULONG Psc,
    IN ULONG Csc,
    IN PVOID EfsData,
    IN ULONG EfsDataLength,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    Constructs the input to the various FSCTL routines based
    on the passed parameters.  The general form is:

    PSC, [EFS_FC, CSC, [EFS Data]]sk

Arguments:


Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    ULONG TotalSize = 3 * sizeof( ULONG ) + EfsDataLength;

    if (*BufferLength < TotalSize) {
        *BufferLength = TotalSize;
        return( FALSE );
    }

    *BufferLength = TotalSize;

    //
    // Copy all the data in, and encrypt what needs to be encrypted
    //

    PULONG pUlong = (PULONG)Buffer;

    *pUlong++ = Psc;
    *pUlong++ = Fsctl;
    *pUlong++ = Csc;

    //
    // EfsData might point to inside Buffer and the data already in place
    //

    if ( (PVOID)pUlong != (PVOID)EfsData )
        RtlCopyMemory( (PUCHAR)pUlong, EfsData, EfsDataLength );

    LONG bytesToBeEnc = (LONG)(2 * sizeof(ULONG) + EfsDataLength);
    ASSERT( (bytesToBeEnc % DES_BLOCKLEN) == 0 );

    PUCHAR CryptData = Buffer + sizeof( ULONG );

    while ( bytesToBeEnc > 0 ) {

        //
        // Encrypt data with DES
        //

        des( CryptData,
             CryptData,
             &DesTable,
             ENCRYPT
           );

        CryptData += DES_BLOCKLEN;
        bytesToBeEnc -= DES_BLOCKLEN;
    }

    return( TRUE );
}


NTSTATUS
GetParentEfsStream(
    IN HANDLE CurrentFileHandle,
    IN PUNICODE_STRING CurrentFileName,
    OUT PEFS_DATA_STREAM_HEADER *ParentEfsStream
    )
/*++

Routine Description:

    Get the $EFS from the parent directory

Arguments:

    SourceFileName -- Current file or directory name.

    ParentEfsStream

Return Value:

    Status of operation.

--*/

{

    ULONG Index;
    HANDLE ParentDir;
    PUCHAR InputData;
    ULONG InputDataSize;
    ULONG OutputDataSize;
    ULONG EfsDataLength;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Get the parent name
    //

    *ParentEfsStream = NULL;

    Index = (CurrentFileName->Length)/sizeof( WCHAR ) - 1;
    while ( (Index > 0) && ( CurrentFileName->Buffer[Index] != L'\\') )
        Index--;

    if ( Index <= 0 )
        return STATUS_OBJECT_PATH_NOT_FOUND;

    LPWSTR ParentDirName;
/*
    if ( CurrentFileName->Buffer[Index-1] == L':' ){

        //
        // Parent is a root directory
        //

        Status = GetRootHandle( CurrentFileHandle, &ParentDir );

        if (!NT_SUCCESS( Status )){

            *ParentEfsStream = NULL;
            return STATUS_OBJECT_PATH_NOT_FOUND;
        }


    } else {
*/

        //
        // A normal directory. We can use WIN 32 API to open it.
        //

        ParentDirName = (LPWSTR) LsapAllocateLsaHeap( ( Index + 1 ) * sizeof(WCHAR) );
        if ( ParentDirName == NULL ) {

            *ParentEfsStream = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlCopyMemory( ParentDirName, &CurrentFileName->Buffer[0], Index * sizeof(WCHAR));
        ParentDirName[Index] = UNICODE_NULL;

        //
        // FILE_FLAG_BACKUP_SEMANTICS is required to open a directory.
        // How about if a user does not have the backup privilege?
        //

        ParentDir = CreateFile(
                            ParentDirName,
                            FILE_READ_ATTRIBUTES,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL
                            );
        //
        // There is no need for us to hold ParentDirName any more
        //

        LsapFreeLsaHeap( ParentDirName );

        if ( ParentDir == INVALID_HANDLE_VALUE ){
            return STATUS_OBJECT_PATH_NOT_FOUND;
        }
/*
    }
*/

    //
    // Now we got a handle to the parent directory in ParentDir.
    // Allocate input and output data buffer
    //

    OutputDataSize = INIT_EFS_BLOCK_SIZE;
    *ParentEfsStream = (PEFS_DATA_STREAM_HEADER) LsapAllocateLsaHeap( OutputDataSize );
    if ( *ParentEfsStream == NULL ){

        CloseHandle( ParentDir );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // PSC, [EFS_FC, CSC , SK, H, H, [SK, H, H]sk]sk
    // PSC, CSC are ignored in this FSCTL call
    //

    InputDataSize = 2 * sizeof(DriverSessionKey) + 7 * sizeof(ULONG);
    InputData = (PUCHAR)LsapAllocateLsaHeap( InputDataSize );
    if ( InputData == NULL ){

        LsapFreeLsaHeap( *ParentEfsStream );
        *ParentEfsStream = NULL;
        CloseHandle( ParentDir );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Prepare an input data for making a FSCTL call to get the $EFS
    //

    EfsDataLength = 2 * sizeof(DriverSessionKey) + 4 * sizeof(ULONG);
    SendHandle( ParentDir, InputData + 3*sizeof(ULONG), &EfsDataLength );

    (VOID) EncryptFSCTLData(
                EFS_GET_ATTRIBUTE,
                0,
                0,
                InputData + 3*sizeof(ULONG),
                EfsDataLength,
                InputData,
                &InputDataSize
                );

    Status = NtFsControlFile(
                ParentDir,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_ENCRYPTION_FSCTL_IO,
                InputData,
                InputDataSize,
                *ParentEfsStream,
                OutputDataSize
                );

    if (!NT_SUCCESS( Status )) {

        //
        //  Check if the output data buffer too small
        //  Try again if it is.
        //

        if ( Status == STATUS_BUFFER_TOO_SMALL ){

            OutputDataSize = *(ULONG*)(*ParentEfsStream);
            if (OutputDataSize > INIT_EFS_BLOCK_SIZE){

                LsapFreeLsaHeap( *ParentEfsStream );
                *ParentEfsStream = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( OutputDataSize );
                if ( *ParentEfsStream ) {
                    Status = NtFsControlFile(
                            ParentDir,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_ENCRYPTION_FSCTL_IO,
                            InputData,
                            InputDataSize,
                            *ParentEfsStream,
                            OutputDataSize
                            );
                }
            }
        }

        if ( !NT_SUCCESS( Status ) ){

            if ( *ParentEfsStream ){
                LsapFreeLsaHeap( *ParentEfsStream );
                *ParentEfsStream = NULL;
            }

            Status = STATUS_SUCCESS;

        }
    }

    LsapFreeLsaHeap( InputData );
    CloseHandle( ParentDir );
    return Status;
}

NTSTATUS
GetRootHandle(
    IN HANDLE FileHandle,
    PHANDLE RootDirectoryHandle
    )
/*++

Routine Description:

    Get the handle to the root directory

Arguments:

    FileHandle -- Current file or directory handle.

    RootDirectoryHandle -- Parent directory

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileId;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // This is magic.  It opens the root directory of a volume by ID,
    // relative to the passed file name.
    //

    ULONG FileIdBuffer[2];

    FileIdBuffer[0] = 0x00000005;
    FileIdBuffer[1] = 0x00050000;

    FileId.Length = FileId.MaximumLength = 8;
    FileId.Buffer = (PWSTR)FileIdBuffer;

    InitializeObjectAttributes(
        &Obja,
        &FileId,
        0,
        FileHandle,
        NULL
        );

    Status = NtCreateFile(
                RootDirectoryHandle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ,
                FILE_OPEN,
                FILE_OPEN_BY_FILE_ID,
                NULL,
                0
                );

    return( Status );
}

BOOLEAN
GetDecryptFsInput(
    IN HANDLE Handle,
    OUT PUCHAR  InputData,
    OUT PULONG  InputDataSize
    )
/*++

Routine Description:

    Get the handle to the root directory

Arguments:

    Handle -- Current file or directory handle.

    InputData -- Data buffer for the decrypt FSCTL input data.
                 PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk]sk

    InputDataSize -- FSCTL input data length.

Return Value:

    TRUE IF SUCCESSFUL.

--*/
{
    ULONG RequiredSize;
    ULONG EfsDataSize;

    RequiredSize = 7 * sizeof( ULONG ) + 2 * sizeof(DriverSessionKey);
    if ( *InputDataSize < RequiredSize ){
        *InputDataSize = RequiredSize;
        return FALSE;
    }

    *InputDataSize = RequiredSize;
    EfsDataSize = RequiredSize - 3 * sizeof( ULONG );

    ( VOID )SendHandle(
                Handle,
                InputData + 3 * sizeof( ULONG ),
                &EfsDataSize
                );

    ( VOID ) EncryptFSCTLData(
                EFS_SET_ENCRYPT,
                EFS_DECRYPT_STREAM,
                EFS_DECRYPT_STREAM,
                InputData + 3 * sizeof(ULONG),
                EfsDataSize,
                InputData,
                InputDataSize
                );

    return TRUE;
}

NTSTATUS
EndErrorEncryptFile(
    IN HANDLE FileHandle,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    )

/*++

Routine Description:

    Removed the $EFS and clear the encrypt bit for the file.

Arguments:

    FileHandle -- Current file handle.

    InputData -- Data buffer for the decrypt FSCTL input data.
                 PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk]sk

    InputDataSize -- FSCTL input data length.

    IoStatusBlock -- Status information from FSCTL call.

Return Value:

    The status of operation.

--*/

{

    return (SendSkFsctl(
                EFS_DECRYPT_FILE,
                EFS_DECRYPT_FILE,
                EFS_SET_ENCRYPT,
                InputData,
                InputDataSize,
                FileHandle,
                FSCTL_SET_ENCRYPTION,
                IoStatusBlock
                )
            );

}

NTSTATUS
SendSkFsctl(
    IN ULONG Psc,
    IN ULONG Csc,
    IN ULONG EfsCode,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    IN HANDLE Handle,
    IN ULONG FsCode,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    )

/*++

Routine Description:

    Send FSCTL call with general EFS Data format. See comments
    for InputData

Arguments:

    Psc -- Plain subcode.

    Csc -- Cipher subcode

    EfsCode -- EFS function code.

    InputData -- Data buffer for the decrypt FSCTL input data.
                 PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk]sk

    InputDataSize -- FSCTL input data length.

    Handle -- Current stream handle.

    FsCode -- FSCTL control code.

    IoStatusBlock -- Status information from FSCTL call.

Return Value:

    The status of operation.

--*/
{

    ULONG EfsDataLength = InputDataSize - 3 * sizeof (ULONG);
    ULONG RequiredSize = 7 * sizeof( ULONG ) + 2 * sizeof(DriverSessionKey);
    BOOLEAN DummyOutput = FALSE;
    ULONG   OutPutLen = 0;
    VOID    *OutPutData = NULL;

    if ( InputDataSize < RequiredSize ){
        return STATUS_BUFFER_TOO_SMALL;
    }

    ( VOID )SendHandle(
                Handle,
                InputData + 3 * sizeof( ULONG ),
                &EfsDataLength
                );

    ( VOID ) EncryptFSCTLData(
                EfsCode,
                Psc,
                Csc,
                InputData + 3 * sizeof(ULONG),
                EfsDataLength,
                InputData,
                &InputDataSize
                );

    if (EFS_DECRYPT_STREAM == Psc) {
       OutPutData = (VOID *)&DummyOutput;
       OutPutLen = sizeof(BOOLEAN);
    }
    return ( NtFsControlFile(
                Handle,
                0,
                NULL,
                NULL,
                IoStatusBlock,
                FsCode,
                InputData,
                InputDataSize,
                OutPutData,
                OutPutLen
                )
            );

}

DWORD
GetVolumeRoot(
    IN PUNICODE_STRING  SrcFileName,
    OUT PUNICODE_STRING  RootPath
)

/*++

Routine Description:

    Get the root path name from the target file name

Arguments:

    SrcFileName -- Target file name.
    RootPathInfo -- Root path information

Return Value:

    The status of operation.

--*/

{

    ULONG BufferLength;
    WCHAR *PathName;
    BOOL    GotRoot;
    DWORD    RetCode = ERROR_SUCCESS;

    BufferLength = (ULONG)((SrcFileName->Length + sizeof(WCHAR)) <= MAX_PATH * sizeof(WCHAR)?
                            (MAX_PATH + 1) * sizeof(WCHAR) : (SrcFileName->Length + sizeof (WCHAR)));
    PathName = (WCHAR *) LsapAllocateLsaHeap(BufferLength);

    if ( !PathName  ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RootPath->MaximumLength = (USHORT) BufferLength;
    GotRoot = GetVolumePathName(
                    SrcFileName->Buffer,
                    PathName,
                    BufferLength
                    );

    if (GotRoot){
        RootPath->Buffer = PathName;
        RootPath->Length = (USHORT) wcslen(PathName) * sizeof (WCHAR);
    } else {
        RetCode = GetLastError();
        RootPath->Buffer = NULL;
        RootPath->Length = 0;
        RootPath->MaximumLength = 0;
        LsapFreeLsaHeap( PathName );
    }


    return RetCode;
}

NTSTATUS
GetLogFile(
    IN PUNICODE_STRING RootPath,
    OUT HANDLE *LogFile
)

/*++

Routine Description:

    Create the log file.

Arguments:

    RootPath -- Volume root name.
    LogFile -- Log file handle

Return Value:

    The status of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE FileHdl;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING  FileName;
    UNICODE_STRING  RootNtName;
    UNICODE_STRING  LogFileName;
    DWORD                  FileAttributes;
    PSECURITY_DESCRIPTOR SD;
    BOOLEAN b;

    b =  RtlDosPathNameToNtPathName_U(
                        RootPath->Buffer,
                        &RootNtName,
                        NULL,
                        NULL
                        );

    if ( b ) {
        //
        //  Allocate space for the temp log file name
        //

        FileName.Buffer = (WCHAR *) LsapAllocateLsaHeap(
                                                                   RootNtName.Length +
                                                                   EFSDIRLEN +
                                                                   TEMPFILELEN);
        if ( !FileName.Buffer ){

            //
            //  Free the NT name
            //
            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                RootNtName.Buffer
                );

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Make the EFS directory name of the volume
        //

        RtlCopyMemory(FileName.Buffer, RootNtName.Buffer, RootNtName.Length - sizeof(WCHAR));
        RtlCopyMemory(
            FileName.Buffer + (RootNtName.Length / sizeof(WCHAR)) - 1,
            EFSDIR,
            EFSDIRLEN
            );
        FileName.Length = RootNtName.Length + EFSDIRLEN - sizeof(WCHAR);
        FileName.MaximumLength = RootNtName.Length + EFSDIRLEN + TEMPFILELEN;
        FileName.Buffer[FileName.Length / sizeof (WCHAR)] = 0;

        //
        //  Free the NT name
        //
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            RootNtName.Buffer
            );

        //
        //   Create the LOG directory and file Security Descriptor
        //

        Status = MakeSystemFullControlSD( &SD );
        if ( NT_SUCCESS(Status) ){

            InitializeObjectAttributes(
                        &Obja,
                        &FileName,
                        OBJ_CASE_INSENSITIVE,
                        0,
                        SD
                        );

            //
            //  Open the EFS Log directory or Create if not exist
            //

            Status = NtCreateFile(
                        &FileHdl,
                        MAXIMUM_ALLOWED,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_OPEN_IF,
                        FILE_DIRECTORY_FILE ,
                        NULL,
                        0
                        );

            if (NT_SUCCESS(Status)){

                //
                //  The cache directory is created hidden and system access only. This will be
                //  created before any real encryption is done. So there is no need for us to check
                //  the encryption status of this directory.
                //

                CloseHandle(FileHdl);

                //
                //  Now trying to get the logfile name and create it
                //

                Status = CreateLogFile( &FileName, SD, LogFile );

            } else {

                //
                //  Cannot open the EFSCACHE dir
                //

                EfsLogEntry(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_OPEN_CACHE_ERROR,
                    0,
                    sizeof(NTSTATUS),
                    NULL,
                    &Status
                    );

            }
            {

                //
                // Delete SD
                //

                NTSTATUS TmpStatus;
                BOOLEAN Present;
                BOOLEAN b;
                PACL pAcl;

                TmpStatus = RtlGetDaclSecurityDescriptor(SD, &Present, &pAcl, &b);
                if ( NT_SUCCESS(TmpStatus) && Present ){

                    LsapFreeLsaHeap(pAcl);

                }
                LsapFreeLsaHeap(SD);
            }
        }

        LsapFreeLsaHeap( FileName.Buffer );
    } else {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return Status;
}

NTSTATUS
MakeSystemFullControlSD(
    OUT PSECURITY_DESCRIPTOR *ppSD
)

/*++

Routine Description:

    Create a system full control Security Descriptor.

Arguments:

    ppSD -- System full control security descriptor

Return Value:

    The status of operation.

--*/

{

    NTSTATUS NtStatus       = STATUS_SUCCESS;
    PSID SystemSid          =NULL;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority=SECURITY_NT_AUTHORITY;
    PACL pAcl               =NULL;
    DWORD                   cAclSize, cSDSize=0;

    //
    // build system sid
    //
    SystemSid = (PSID) LsapAllocateLsaHeap(RtlLengthRequiredSid(1));

    if ( NULL == SystemSid )
        return(STATUS_INSUFFICIENT_RESOURCES);

    NtStatus = RtlInitializeSid(SystemSid, &IdentifierAuthority, (UCHAR)1);
    if ( !NT_SUCCESS(NtStatus) ){
        LsapFreeLsaHeap( SystemSid );
        return NtStatus;
    }

    *(RtlSubAuthoritySid(SystemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;

    //
    // build a DACL for system full control
    //

    cAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_OBJECT_ACE) +
                    RtlLengthSid(SystemSid);

    pAcl = (PACL)LsapAllocateLsaHeap(cAclSize);
    *ppSD = (PSECURITY_DESCRIPTOR) LsapAllocateLsaHeap(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if ( ( NULL == pAcl ) || ( NULL == *ppSD ) ){
        if ( pAcl ) {
            LsapFreeLsaHeap( pAcl );
        }
        if ( *ppSD ) {
            LsapFreeLsaHeap( *ppSD );
            *ppSD = NULL;
        }
        LsapFreeLsaHeap( SystemSid );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAcl, cAclSize);

    pAcl->AclRevision = ACL_REVISION_DS;
    pAcl->Sbz1        = (BYTE)0;
    pAcl->AclSize     = (USHORT)cAclSize;
    pAcl->AceCount    = 0;

    //
    // add a ace to the acl for System full control for file objects
    // the access type is ACCESS_ALLOWED_ACE
    // inheritance flag is CIOI
    //
    NtStatus = RtlAddAccessAllowedAceEx (
                        pAcl,
                        ACL_REVISION_DS,
                        OBJECT_INHERIT_ACE  |
                        CONTAINER_INHERIT_ACE,
                        GENERIC_ALL,
                        SystemSid
                        );

    if ( NT_SUCCESS(NtStatus) ){

        NtStatus = RtlCreateSecurityDescriptor( *ppSD,
                                SECURITY_DESCRIPTOR_REVISION );

        if ( NT_SUCCESS(NtStatus) ){

            //
            // Then set DACL (permission) to the security descriptor
            //

            NtStatus = RtlSetDaclSecurityDescriptor (
                                *ppSD,
                                TRUE,
                                pAcl,
                                FALSE
                                );

            if ( NT_SUCCESS(NtStatus) ){

                ((SECURITY_DESCRIPTOR *) *ppSD)->Control |= SE_DACL_PROTECTED;

            }
        }
    }

    //
    // free memory for SystemSid
    //

    LsapFreeLsaHeap( SystemSid );

    if (!NT_SUCCESS(NtStatus)){
        LsapFreeLsaHeap( pAcl );
        LsapFreeLsaHeap( *ppSD );
        *ppSD = NULL;
    }

    return (NtStatus);

}

NTSTATUS
CreateLogFile(
    IN PUNICODE_STRING FileName,
    IN PSECURITY_DESCRIPTOR SD,
    OUT HANDLE *LogFile
)

/*++

Routine Description:

    Create a temp log file. We could not use the API GetTempFile to get the temp log file.
    We need our special Security Descriptor.

Arguments:

    FileName -- Directory to create the temp log file. Has enough space to add temporary
                    file name.

    SD -- Security Descriptor.

    LogFile -- File handle.

Return Value:

    The status of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    PWCHAR TempLogFileName;
    int TempFileNameLen;
    USHORT OldLength;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN StopLoop = FALSE;

    OldLength = FileName->Length + sizeof (WCHAR);
    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = L'\\';
    TempLogFileName = FileName->Buffer + OldLength/sizeof (WCHAR) ;

    for (; Index < 10000; Index++){
        TempFileNameLen = swprintf( TempLogFileName, L"EFS%d.LOG", Index);
        FileName->Length = OldLength + (USHORT) TempFileNameLen * sizeof (WCHAR);
        InitializeObjectAttributes(
                    &Obja,
                    FileName,
                    OBJ_CASE_INSENSITIVE,
                    0,
                    SD
                    );

        Status = NtCreateFile(
                    LogFile,
                    FILE_READ_DATA | FILE_WRITE_DATA | DELETE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_HIDDEN,
                    0,
                    FILE_CREATE,
                    FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_NONALERT ,
                    NULL,
                    0
                    );

        switch (Status) {
          case STATUS_SUCCESS:
          case STATUS_NO_SUCH_FILE:
          case STATUS_OBJECT_PATH_INVALID:
          case STATUS_OBJECT_PATH_SYNTAX_BAD:
          case STATUS_DIRECTORY_IS_A_REPARSE_POINT:
          case STATUS_OBJECT_PATH_NOT_FOUND:
          case STATUS_ACCESS_DENIED:
          case STATUS_DISK_CORRUPT_ERROR:
          case STATUS_FILE_CORRUPT_ERROR:
          case STATUS_DISK_FULL:
              StopLoop = TRUE;
              break;
          default:
              break;

        }
        if (StopLoop) {
           break;
        }
    }

    return Status;

}

NTSTATUS
CreateLogHeader(
    IN HANDLE LogFile,
    IN ULONG   SectorSize,
    IN PLARGE_INTEGER TragetID,
    IN PLARGE_INTEGER BackupID  OPTIONAL,
    IN LPCWSTR  SrcFileName,
    IN LPCWSTR  BackupFileName OPTIONAL,
    IN EFSP_OPERATION Operation,
    IN EFS_ACTION_STATUS Action,
    OUT ULONG *LogInfoOffset OPTIONAL
    )
/*++

Routine Description:

    Create a log file header.

Arguments:

    LogFile -- A handle to the log file

    SectorSize -- Sector size of the volume which the log file is in.

    TragetID -- Target file ID.

    BackupID -- Backup file ID.

    SrcFileName -- Target file path

    BackupFileName -- Backup file path

    Operation -- Encrypting or Decrypting

    Action -- The status of the operation.

    LogInfoOffset -- Starting offset of status info copy

Return Value:

    The status of operation.

--*/
{
    BYTE *WorkBuffer;
    PULONG tmpULong;
    PLARGE_INTEGER tmpLL;
    ULONG WorkOffset;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    ULONG   BufferSize;
    ULONG   HeadDataSize;
    ULONG   SrcFileNameLen; // File path name length in bytes
    ULONG   BackupFileNameLen;

    SrcFileNameLen = (wcslen ( SrcFileName ) + 1 ) * sizeof (WCHAR);
    if ( BackupFileName ) {
        BackupFileNameLen = (wcslen ( BackupFileName ) + 1) * sizeof (WCHAR);
    } else {
        BackupFileNameLen = 0;
    }

    HeadDataSize = sizeof ( LOGHEADER ) + SrcFileNameLen + BackupFileNameLen;

    BufferSize = HeadDataSize + sizeof (ULONG); // Data + CheckSum
    if ( BufferSize <= SectorSize ){
        BufferSize = SectorSize;
    } else {
        BufferSize = ((ULONG)((BufferSize - 1) / SectorSize ) + 1) * SectorSize;
    }

    //
    // The memory used here must be aligned with sector boundary.
    // We cannot use LsapAllocateLsaHeap() here
    //

    WorkBuffer = (BYTE *) VirtualAlloc(
                                NULL,
                                BufferSize,
                                MEM_COMMIT,
                                PAGE_READWRITE
                                );
    if ( NULL == WorkBuffer ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Prepare common log header
    //
    RtlCopyMemory( ((PLOGHEADER)WorkBuffer)->SIGNATURE, LOGSIG, sizeof(WCHAR) * LOGSIGLEN );
    ((PLOGHEADER)WorkBuffer)->VerID =  LOGVERID;
    ((PLOGHEADER)WorkBuffer)->SectorSize = SectorSize;
    if ( Decrypting == Operation ) {
        ((PLOGHEADER)WorkBuffer)->Flag = LOG_DECRYPTION;
    } else {
        ((PLOGHEADER)WorkBuffer)->Flag = 0;
    }

    ((PLOGHEADER)WorkBuffer)->HeaderSize = HeadDataSize;
    ((PLOGHEADER)WorkBuffer)->HeaderBlockSize = BufferSize;
    ((PLOGHEADER)WorkBuffer)->TargetFilePathOffset = sizeof( LOGHEADER );
    ((PLOGHEADER)WorkBuffer)->TargetFilePathLength = SrcFileNameLen;
    RtlCopyMemory(
                    WorkBuffer + ((PLOGHEADER)WorkBuffer)->TargetFilePathOffset,
                    SrcFileName,
                    SrcFileNameLen
                    );

    if ( BackupFileName ){

        ((PLOGHEADER)WorkBuffer)->TempFilePathOffset = sizeof( LOGHEADER ) + SrcFileNameLen;
        ((PLOGHEADER)WorkBuffer)->TempFilePathLength = BackupFileNameLen;
        ((PLOGHEADER)WorkBuffer)->TempFileInternalName.QuadPart = BackupID->QuadPart;
        RtlCopyMemory(
                        WorkBuffer + ((PLOGHEADER)WorkBuffer)->TempFilePathOffset,
                        BackupFileName,
                        BackupFileNameLen
                        );

    } else {

        ((PLOGHEADER)WorkBuffer)->TempFilePathOffset = 0;
        ((PLOGHEADER)WorkBuffer)->TempFilePathLength = 0;
        ((PLOGHEADER)WorkBuffer)->TempFileInternalName.QuadPart = (LONGLONG) 0;

    }

    ((PLOGHEADER)WorkBuffer)->LengthOfTargetFileInternalName = sizeof (LARGE_INTEGER);
    ((PLOGHEADER)WorkBuffer)->TargetFileInternalName.QuadPart = TragetID->QuadPart;
    ((PLOGHEADER)WorkBuffer)->LengthOfTempFileInternalName = sizeof (LARGE_INTEGER);


    switch (Action){
        case BeginEncryptDir:
        case BeginDecryptDir:

            //
            //  No status information required for directory operation
            //  If crash happens before the completion, we always switch the status
            //  to decrypted status.
            //

            ((PLOGHEADER)WorkBuffer)->OffsetStatus1 = 0;
            ((PLOGHEADER)WorkBuffer)->OffsetStatus2 =0;
            ((PLOGHEADER)WorkBuffer)->Flag |= LOG_DIRECTORY;
            break;

        case BeginEncryptFile:
        case BeginDecryptFile:

            //
            //  To guarantee the atomic operation, status info copy begins
            //  at sector boundary.
            //

            ((PLOGHEADER)WorkBuffer)->OffsetStatus1 = BufferSize;
            ((PLOGHEADER)WorkBuffer)->OffsetStatus2 = BufferSize + SectorSize;
            if ( LogInfoOffset ){
                *LogInfoOffset = BufferSize;
            }

            break;
        default:
            break;
    }

    CreateBlockSum(WorkBuffer, HeadDataSize, BufferSize );

    //
    //  Write out the header sector
    //
    ByteOffset.QuadPart = (LONGLONG) 0;

    Status = NtWriteFile(
                    LogFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    WorkBuffer,
                    BufferSize,
                    &ByteOffset,
                    NULL
                    );

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );

    return Status;

}

NTSTATUS
WriteLogFile(
    IN HANDLE LogFile,
    IN ULONG SectorSize,
    IN ULONG StartOffset,
    IN EFS_ACTION_STATUS Action
    )
/*++
Routine Description:

    Write Log Information.

Arguments:

    LogFile -- A handle to the log file

    SectorSize -- Sector size of the volume which the log file is in.

    Action -- The status of the operation.

Return Value:

    The status of operation.
--*/
{
    BYTE *WorkBuffer;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    PULONG  tmpULong;

    //
    // The memory used here must be aligned with sector boundary.
    // We cannot use LsapAllocateLsaHeap() here
    //

    WorkBuffer = (BYTE *) VirtualAlloc(
                                            NULL,
                                            SectorSize,
                                            MEM_COMMIT,
                                            PAGE_READWRITE
                                            );
    if ( NULL == WorkBuffer ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    tmpULong = (PULONG) WorkBuffer;
    *tmpULong =  2 * sizeof ( ULONG );
    * (tmpULong + 1) = Action;
    CreateBlockSum(WorkBuffer, *tmpULong, SectorSize );

    //
    //  Write out the header sector
    //
    ByteOffset.QuadPart = (LONGLONG) StartOffset;

    Status = NtWriteFile(
                    LogFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    WorkBuffer,
                    SectorSize,
                    &ByteOffset,
                    NULL
                    );

    if ( NT_SUCCESS(Status) ) {
        ByteOffset.QuadPart = (LONGLONG) (StartOffset + SectorSize);

        Status = NtWriteFile(
                        LogFile,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        WorkBuffer,
                        SectorSize,
                        &ByteOffset,
                        NULL
                        );
    }

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );
    return Status;

}

ULONG
GetCheckSum(
    IN BYTE *WorkBuffer,
    IN ULONG    Length
    )
/*++
Routine Description:

    Get the checksum of the written info. A simple checksum
    algorithm is used.

Arguments:

    WorkBuffer -- Starting point

    Length -- Length of the data to be checksumed.

Return Value:

    None.

--*/
{
    ULONG CheckSum = 0;
    ULONG *WorkData;

    WorkData =  (ULONG*)WorkBuffer;
    while ( WorkData < (ULONG *)(WorkBuffer + Length) ){

        //
        //  It is OK to add more bytes beyond WorkBuffer + Length if
        //  Length is not a multiple of sizeof (ULONG)
        //

        CheckSum += *WorkData++;
    }

    return CheckSum;

}

VOID
CreateBlockSum(
    IN BYTE *WorkBuffer,
    IN ULONG    Length,
    IN ULONG    BlockSize
    )
/*++
Routine Description:

    Create a simple checksum for the sector. The checksum is not security
    sensitive. Only for the purpose of detecting disk write error. A simple checksum
    algorithm is used.

Arguments:

    WorkBuffer -- Starting point

    Length -- Length of the data to be checksumed.

    SectorSize -- Sector size of the volume which the log file is in.

Return Value:

    None.

--*/
{
    ULONG CheckSum = 0;
    ULONG *WorkData;

    ASSERT ( Length <= BlockSize - sizeof (ULONG));

    CheckSum = GetCheckSum( WorkBuffer, Length );

    //
    //  Put the checksum at the end of sector
    //

    WorkData =  (ULONG*) (WorkBuffer + BlockSize - sizeof(ULONG));
    *WorkData = CheckSum;
    return;

}

NTSTATUS
CreateBackupFile(
    IN PUNICODE_STRING SourceFileNameU,
    OUT HANDLE *BackupFileHdl,
    OUT FILE_INTERNAL_INFORMATION *BackupID,
    OUT LPWSTR *BackupFileName
    )
/*++

Routine Description:

    Create a backup file

Arguments:

    SourceFileName -- Source file name

    BackupFileHdl -- Backup file handle pointer

    BackupID -- Backup file ID information.

Return Value:

    The status of operation.

--*/
{
    LONG   Index;
    int TempFileNameLen;
    LPWSTR BackupPureName;
    UNICODE_STRING  BackupFile;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PSECURITY_DESCRIPTOR    SD;
    NTSTATUS    Status;

    //
    //   Assume source file name in the format XXX...XXX\XXX or XXX
    //   No format of X:XXX. (Must be X:\XXX)
    //   The name was converted by APIs. The above assumption should be correct.
    //

    Index = SourceFileNameU->Length/sizeof(WCHAR) - 1;
    while ( Index >= 0 ){
        //
        //  Find the last '\'
        //
        if ( SourceFileNameU->Buffer[Index--] == L'\\'){
            break;
        }
    }

    Index++;

    //
    // Adjust the Index to point to the end of the directory not including '\'
    //

    if ( SourceFileNameU->Buffer[Index] ==  L'\\'){
        Index++;
    }

    //
    //   Allocate space for the backup file name
    //

    *BackupFileName = (LPWSTR) LsapAllocateLsaHeap( (Index + 20) * sizeof( WCHAR ));

    if ( NULL ==  *BackupFileName ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( *BackupFileName, SourceFileNameU->Buffer, Index * sizeof(WCHAR));
    BackupPureName = *BackupFileName + Index;

    //
    //   Create file Security Descriptor
    //

    Status = MakeSystemFullControlSD( &SD );
    if ( NT_SUCCESS(Status) ){

        BOOLEAN StopLoop = FALSE;

        for (ULONG ii = 0; ii < 100000; ii++){

            BOOLEAN b;

            TempFileNameLen = swprintf(BackupPureName, L"EFS%d.TMP", ii);
            b = RtlDosPathNameToNtPathName_U(
                            *BackupFileName,
                            &BackupFile,
                            NULL,
                            NULL
                            );

            if ( b ){

                InitializeObjectAttributes(
                            &Obja,
                            &BackupFile,
                            OBJ_CASE_INSENSITIVE,
                            0,
                            SD
                            );

                //
                //  Create the EFS Temp file
                //  Does not hurt using FILE_OPEN_REPARSE_POINT
                //

                Status = NtCreateFile(
                            BackupFileHdl,
                            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                            0,
                            FILE_CREATE,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                            NULL,
                            0
                            );
                if ( STATUS_ACCESS_DENIED == Status ) {

                    //
                    // Let's try to open it in the Local_System
                    //


                    RpcRevertToSelf();
                    Status =  NtCreateFile(
                            BackupFileHdl,
                            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                            0,
                            FILE_CREATE,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                            NULL,
                            0
                            );
        
                    if (RPC_S_OK != RpcImpersonateClient( NULL )){

                        //
                        // This is very unlikely. We have did this before and it all succeeded.
                        // If this happens, let's quit as if we get STATUS_ACCESS_DENIED.
                        //

                        if (NT_SUCCESS(Status)) {
                            MarkFileForDelete(*BackupFileHdl);
                            CloseHandle( *BackupFileHdl );
                            *BackupFileHdl = 0;
                        }

                        Status = STATUS_ACCESS_DENIED;
                    }

                }

                RtlFreeHeap(
                    RtlProcessHeap(),
                    0,
                    BackupFile.Buffer
                    );

                switch (Status) {
                  case STATUS_SUCCESS:
                  case STATUS_NO_SUCH_FILE:
                  case STATUS_OBJECT_PATH_INVALID:
                  case STATUS_OBJECT_PATH_SYNTAX_BAD:
                  case STATUS_DIRECTORY_IS_A_REPARSE_POINT:
                  case STATUS_OBJECT_PATH_NOT_FOUND:
                  case STATUS_ACCESS_DENIED:
                  case STATUS_DISK_CORRUPT_ERROR:
                  case STATUS_FILE_CORRUPT_ERROR:
                  case STATUS_DISK_FULL:
                      StopLoop = TRUE;
                      break;
                  default:
                      break;

                }
                if (StopLoop) {
                   break;
                }
            }
        }

        if ( NT_SUCCESS(Status) ){
            if ( NT_SUCCESS(Status) ){

                //
                // Get FileID
                //
                Status = NtQueryInformationFile(
                    *BackupFileHdl,
                    &IoStatusBlock,
                    BackupID,
                    sizeof ( FILE_INTERNAL_INFORMATION ),
                    FileInternalInformation
                    );

                if ( !NT_SUCCESS(Status) ){
                    MarkFileForDelete(*BackupFileHdl);
                    CloseHandle( *BackupFileHdl );
                    *BackupFileHdl = 0;
                }

            } else {

                MarkFileForDelete(*BackupFileHdl);
                CloseHandle( *BackupFileHdl );
                *BackupFileHdl = 0;

            }
        }

        {

            //
            // Delete SD
            //

            NTSTATUS TmpStatus;
            BOOLEAN Present;
            BOOLEAN b;
            PACL pAcl;

            TmpStatus = RtlGetDaclSecurityDescriptor(SD, &Present, &pAcl, &b);
            if ( NT_SUCCESS(TmpStatus) && Present ){

                LsapFreeLsaHeap(pAcl);

            }
            LsapFreeLsaHeap(SD);
        }

    }

    if ( !NT_SUCCESS(Status) ){

        LsapFreeLsaHeap( *BackupFileName );
        *BackupFileName = NULL;

    }

    return Status;

}



NTSTATUS
SendGenFsctl(
    IN HANDLE Target,
    IN ULONG Psc,
    IN ULONG Csc,
    IN ULONG EfsCode,
    IN ULONG FsCode
    )
/*++
Routine Description:

    Set the encrypted file status to normal.

Arguments:

    Target -- A handle to the target file or directory.

    Psc -- Plain sub code

    Csc -- Cipher sub code

    EfsCode -- Efs function code

    FsCode -- FSCTL code

Return Value:

    The status of operation.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG InputDataSize;
    PUCHAR InputData;
    IO_STATUS_BLOCK IoStatusBlock;

    InputDataSize = 7 * sizeof ( ULONG ) + 2 * sizeof ( DriverSessionKey );
    InputData = (PUCHAR)LsapAllocateLsaHeap( InputDataSize );

    if ( InputData == NULL ) {

        //
        //   This is unlikely to happen during the boot time.
        //

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Sync FSCTL assumed
    //

    Status = SendSkFsctl(
                    Psc,
                    Csc,
                    EfsCode,
                    InputData,
                    InputDataSize,
                    Target,
                    FsCode,
                    &IoStatusBlock
                    );

    LsapFreeLsaHeap( InputData );
    return Status;
}


DWORD
EfsOpenFileRaw(
    IN      LPCWSTR     FileName,
    IN      LPCWSTR     LocalFileName,
    IN      BOOL        NetSession,
    IN      ULONG       Flags,
    OUT     PVOID *     Context
    )

/*++

Routine Description:

    This routine is used to open an encrypted file. It opens the file and
    prepares the necessary context to be used in ReadRaw data and WriteRaw
    data.


Arguments:

    FileName  --  Remote File name of the file to be exported. Used to check the share.

    LocalFileName -- Local file name for real jobs.

    NetSession -- Indicates network session.

    Flags -- Indicating if open for export or import; for directory or file.

    Context - Export context to be used by READ operation later. Caller should
              pass this back in ReadRaw().


Return Value:

    Result of the operation.

--*/

{
    ULONG   FileAttributes = FILE_ATTRIBUTE_NORMAL;
    ACCESS_MASK   FileAccess = 0 ;
    BOOL    Privilege = FALSE; // FALSE - not a backup operator
    ULONG   CreateDist = 0;
    ULONG   CreateOptions = 0;
    ULONG   ShareMode = 0;
    HANDLE  HSourceFile;
    NTSTATUS NtStatus;
    DWORD   HResult;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES NetObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    UNICODE_STRING  UniFileName;
    UNICODE_STRING  UniNetFileName={0,0,NULL};
    BOOLEAN TranslationStatus;

    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG                    StreamInfoSize = 0;

    PUNICODE_STRING          StreamNames = NULL;
    PHANDLE                  StreamHandles = NULL;
    ULONG                    StreamCount    = 0;

    TOKEN_PRIVILEGES        Privs;
    PTOKEN_PRIVILEGES       OldPrivs;
    BOOL                    b;
    HANDLE                  TokenHandle = 0;
    DWORD                   ReturnLength;

    //
    // Convert file name to UNICODE_STRING and UNC format
    // Create an OBJECT_ATTRIBUTES
    //

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            LocalFileName,
                            &UniFileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {

        return ERROR_PATH_NOT_FOUND;

    }

    if (NetSession) {

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                FileName,
                                &UniNetFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                UniFileName.Buffer
                );

            return ERROR_PATH_NOT_FOUND;

        }

        InitializeObjectAttributes(
                        &NetObjectAttributes,
                        &UniNetFileName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    }

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UniFileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

    if ( Flags & CREATE_FOR_IMPORT ){

        //
        // Prepare parameters for create of import
        //

        FileAccess = FILE_WRITE_ATTRIBUTES;

        if ( Flags & CREATE_FOR_DIR ){

            //
            // Import a directory
            //

            FileAccess |= FILE_WRITE_DATA | FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE;
            CreateDist = FILE_OPEN_IF;
            CreateOptions |= FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_COMPRESSION;
            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

        } else {

            //
            // Import file
            // Should we use FILE_SUPERSEDE here?
            //

            FileAccess |= SYNCHRONIZE;
            CreateDist = FILE_OVERWRITE_IF;
            CreateOptions |= FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_COMPRESSION;
            if (Flags & OVERWRITE_HIDDEN) {
                FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

        }


    } else {

        //
        // If export is requested and the file is not encrypted,
        // Fail the call.
        //

        FileAccess = FILE_READ_ATTRIBUTES;

        //
        // Prepare parameters for create of export
        //

        CreateDist = FILE_OPEN;
        if ( Flags & CREATE_FOR_DIR ){

            //
            // Export a directory
            //

            FileAccess |= FILE_READ_DATA;
            CreateOptions |= FILE_DIRECTORY_FILE;

        } else {
            FileAccess |= SYNCHRONIZE;
            CreateOptions |= FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;
        }

    }

    OldPrivs = ( TOKEN_PRIVILEGES *) LsapAllocateLsaHeap(sizeof( TOKEN_PRIVILEGES ));

    if ( OldPrivs == NULL ){

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            UniFileName.Buffer
            );

        if (NetSession) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                UniNetFileName.Buffer
                );

        }


        return ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // We're impersonating, use the thread token.
    //

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            FALSE,
            &TokenHandle
            );

    if ( b ) {

        //
        // We've got a token handle
        //

        //
        // If we're doing a create for import, enable restore privilege,
        // otherwise enable backup privilege.
        //


        Privs.PrivilegeCount = 1;
        Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( !(Flags & CREATE_FOR_IMPORT) ){

            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_BACKUP_PRIVILEGE);

        } else {

            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
        }

        ReturnLength = sizeof( TOKEN_PRIVILEGES );

        (VOID) AdjustTokenPrivileges (
                    TokenHandle,
                    FALSE,
                    &Privs,
                    sizeof( TOKEN_PRIVILEGES ),
                    OldPrivs,
                    &ReturnLength
                    );

        if ( ERROR_SUCCESS == GetLastError() ) {

            Privilege = TRUE;

        } else {

            //
            // Privilege adjust failed
            //

            CloseHandle( TokenHandle );
            TokenHandle = 0;

        }

    } else {

        //
        // We did not get the handle.
        //

        TokenHandle = 0;

    }

    //
    // Caller will call RpcRevertToSelf().
    // OldPrivs is not needed any more.
    //

    LsapFreeLsaHeap( OldPrivs );
    OldPrivs = NULL;

    if ( !Privilege ){

        //
        // Not a backup operator
        //
        if ( !(Flags & CREATE_FOR_IMPORT) ){

            FileAccess |= FILE_READ_DATA;

        } else {

            FileAccess |= FILE_WRITE_DATA;

        }
    } else {

        //
        //  A backup operator or the user with the privilege
        //

        CreateOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
        if ( !(Flags & CREATE_FOR_DIR) ){

            FileAccess |= DELETE;

        }

    }

    if (NetSession) {

        //
        // This create is for checking share access only. The handle from this is not good for
        // FSCTL with data buffer larger than 64K.
        //

        NtStatus = NtCreateFile(
                        &HSourceFile,
                        FileAccess,
                        &NetObjectAttributes,
                        &IoStatus,
                        (PLARGE_INTEGER) NULL,
                        FileAttributes,
                        ShareMode,
                        CreateDist,
                        CreateOptions,
                        (PVOID) NULL,
                        0L
                        );

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            UniNetFileName.Buffer
            );

        if (NT_SUCCESS(NtStatus)) {
             CloseHandle( HSourceFile );
        } else {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                UniFileName.Buffer
                );

            if ( TokenHandle ){
                CloseHandle( TokenHandle );
            }

            return RtlNtStatusToDosError( NtStatus );
        }

    }

    NtStatus = NtCreateFile(
                    &HSourceFile,
                    FileAccess,
                    &ObjectAttributes,
                    &IoStatus,
                    (PLARGE_INTEGER) NULL,
                    FileAttributes,
                    ShareMode,
                    CreateDist,
                    CreateOptions,
                    (PVOID) NULL,
                    0L
                    );

    RtlFreeHeap(
        RtlProcessHeap(),
        0,
        UniFileName.Buffer
        );

    //
    // No need for FILE_DIRECTORY_FILE any more
    //

    CreateOptions &= ~FILE_DIRECTORY_FILE;
    FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;

    if (NT_SUCCESS(NtStatus)){

        if ( Flags & CREATE_FOR_IMPORT ){

            if (Flags & CREATE_FOR_DIR) {

                //
                //  If the dir existed and compressed, we need extra steps to uncompressed it
                //


                FILE_BASIC_INFORMATION  StreamBasicInfo;
    
                //
                // Get File Attributes
                //
                NtStatus = NtQueryInformationFile(
                    HSourceFile,
                    &IoStatus,
                    &StreamBasicInfo,
                    sizeof ( FILE_BASIC_INFORMATION ),
                    FileBasicInformation
                    );
    
                if (NT_SUCCESS(NtStatus)){
                    if (StreamBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED){

                        USHORT State = COMPRESSION_FORMAT_NONE;
                        ULONG Length;
        
                        //
                        // Attempt to uncompress the directory
                        //
        
                        b = DeviceIoControl(
                                            HSourceFile,
                                            FSCTL_SET_COMPRESSION,
                                            &State,
                                            sizeof(USHORT),
                                            NULL,
                                            0,
                                            &Length,
                                            FALSE
                                            );
        
                        if (!b) {
                            HResult = GetLastError();
                            CloseHandle( HSourceFile );
                            if ( TokenHandle ){
                                CloseHandle( TokenHandle );
                            }
                            return HResult;
                        }
                    }
                } else {

                    CloseHandle( HSourceFile );
                    if ( TokenHandle ){
                        CloseHandle( TokenHandle );
                    }
                    return RtlNtStatusToDosError( NtStatus );

                }

            }
            //
            // Prepare import context
            //

            *Context = LsapAllocateLsaHeap(sizeof( IMPORT_CONTEXT ));

            if ( *Context ){

                (( PIMPORT_CONTEXT ) *Context)->Flag = CONTEXT_FOR_IMPORT;
                if (Flags & CREATE_FOR_DIR) {
                    (( PIMPORT_CONTEXT ) *Context)->Flag |= CONTEXT_OPEN_FOR_DIR;
                }
                (( PIMPORT_CONTEXT ) *Context)->Handle = HSourceFile;
                (( PIMPORT_CONTEXT ) *Context)->ContextID = EFS_CONTEXT_ID;
                (( PIMPORT_CONTEXT ) *Context)->Attribute = FileAttributes;
                (( PIMPORT_CONTEXT ) *Context)->CreateDisposition = CreateDist;
                (( PIMPORT_CONTEXT ) *Context)->CreateOptions = CreateOptions;
                (( PIMPORT_CONTEXT ) *Context)->DesiredAccess = FileAccess;

            } else {

                CloseHandle( HSourceFile );
                HSourceFile = 0;

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            }

        } else {


            FILE_BASIC_INFORMATION  StreamBasicInfo;
            IO_STATUS_BLOCK IoStatusBlock;

            //
            // Get File Attributes
            //
            NtStatus = NtQueryInformationFile(
                HSourceFile,
                &IoStatusBlock,
                &StreamBasicInfo,
                sizeof ( FILE_BASIC_INFORMATION ),
                FileBasicInformation
                );

            if ( NT_SUCCESS(NtStatus)) {

                if ( !(StreamBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ){

                    NtStatus = STATUS_ACCESS_DENIED;

                }

            }

            if (!NT_SUCCESS(NtStatus)) {

                CloseHandle( HSourceFile );
                HSourceFile = 0;

                if ( TokenHandle ){
                    CloseHandle( TokenHandle );
                }

                return RtlNtStatusToDosError( NtStatus );

            }

            //
            // Prepare export context
            //

            NtStatus = GetStreamInformation(
                            HSourceFile,
                            &StreamInfoBase,
                            &StreamInfoSize
                            );

            if (NT_SUCCESS(NtStatus)){

                if (FileAccess & DELETE) {
                    ShareMode |= FILE_SHARE_DELETE;
                }

                HResult = OpenFileStreams(
                                HSourceFile,
                                ShareMode,
                                OPEN_FOR_EXP,
                                StreamInfoBase,
                                FileAccess,
                                CreateDist,
                                CreateOptions,
                                NULL,
                                &StreamNames,
                                &StreamHandles,
                                NULL,
                                &StreamCount
                                );

                if ( HResult == NO_ERROR ) {

                    *Context = LsapAllocateLsaHeap( sizeof( EXPORT_CONTEXT ) );

                    if ( *Context ){

                        ((PEXPORT_CONTEXT) *Context)->Flag = CONTEXT_FOR_EXPORT;
                        if (Flags & CREATE_FOR_DIR) {
                            (( PEXPORT_CONTEXT ) *Context)->Flag |= CONTEXT_OPEN_FOR_DIR;
                        }
                        ((PEXPORT_CONTEXT) *Context)->Handle = HSourceFile;
                        ((PEXPORT_CONTEXT ) *Context)->ContextID = EFS_CONTEXT_ID;
                        ((PEXPORT_CONTEXT) *Context)->NumberOfStreams = StreamCount;
                        ((PEXPORT_CONTEXT) *Context)->StreamHandles = StreamHandles;
                        ((PEXPORT_CONTEXT) *Context)->StreamNames = StreamNames;
                        ((PEXPORT_CONTEXT) *Context)->StreamInfoBase = StreamInfoBase;

                    } else {

                        //
                        // Out of memory
                        //

                        CleanupOpenFileStreams(
                                            StreamHandles,
                                            StreamNames,
                                            NULL,
                                            StreamInfoBase,
                                            HSourceFile,
                                            StreamCount
                                            );

                        StreamHandles = NULL;
                        StreamNames = NULL;
                        StreamInfoBase = NULL;
                        HSourceFile = 0;
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                    }

                } else {

                    //
                    // Open streams wrong, free StreamInfoBase
                    //

                    if (StreamInfoBase) {
                        LsapFreeLsaHeap( StreamInfoBase );
                        StreamInfoBase = NULL;
                    }
                    CloseHandle( HSourceFile );
                    HSourceFile = 0;
                    if ( TokenHandle ){
                        CloseHandle( TokenHandle );
                    }

                    return HResult;

                }

            } else {

                //
                // Get stream info wrong
                //

                CloseHandle( HSourceFile );
                HSourceFile = 0;

            }
        }

    }

    if ( TokenHandle ){
        CloseHandle( TokenHandle );
    }

    return RtlNtStatusToDosError( NtStatus );

}

VOID
EfsCloseFileRaw(
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine frees the resources allocated by the CreateRaw

Arguments:

    Context - Created by the EfsOpenFileRaw.

Return Value:

    NO.

--*/
{
    if ( !Context || (((PEXPORT_CONTEXT) Context)->ContextID != EFS_CONTEXT_ID) ){
        return;
    }

    if ( !(((PEXPORT_CONTEXT) Context)->Flag & CONTEXT_INVALID) ){

        if ( ((PEXPORT_CONTEXT) Context)->Flag & CONTEXT_FOR_IMPORT ){

            //
            // Free import context
            //

            CleanupOpenFileStreams(
                NULL,
                NULL,
                NULL,
                NULL,
                ((PIMPORT_CONTEXT) Context)->Handle,
                0
                );

            //
            // Defensive code
            //

            ((PIMPORT_CONTEXT) Context)->Flag |= CONTEXT_INVALID;

       } else {

            //
            // Free export context
            //

            CleanupOpenFileStreams(
                ((PEXPORT_CONTEXT) Context)->StreamHandles,
                ((PEXPORT_CONTEXT) Context)->StreamNames,
                NULL,
                ((PEXPORT_CONTEXT) Context)->StreamInfoBase,
                ((PEXPORT_CONTEXT) Context)->Handle,
                ((PEXPORT_CONTEXT) Context)->NumberOfStreams
                );

            //
            // Defensive code
            //

            ((PEXPORT_CONTEXT) Context)->Flag |= CONTEXT_INVALID;

        }

    }

    LsapFreeLsaHeap( Context);

}

long EfsReadFileRaw(
    PVOID           Context,
    PVOID           EfsOutPipe
    )
/*++

Routine Description:

    This routine is used to read encrypted file's raw data. It uses
    NTFS FSCTL to get the data.

Arguments:

    Context -- Context handle.
    EfsOutPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{

    VOID    *FsctlInput = NULL;
    VOID    *WorkBuffer = NULL;
    VOID    *BufPointer;
    VOID    *FsctlOutput;
    USHORT  *PUShort;
    PULONG  PUlong;
    ULONG   FsctlInputLength;
    ULONG   EfsDataLength;
    ULONG   FsctlOutputLength;
    ULONG   SendDataLength;
    ULONG   WkBufLength;
    ULONG   BytesAdvanced;
    DWORD   HResult = NO_ERROR;
    BOOLEAN MoreToRead = TRUE;
    BOOLEAN StreamEncrypted = TRUE;
    ULONG   StreamIndex;
    LONGLONG StreamOffset;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION StreamInfo;
    ULONG   ii;

    if ( !Context ||
         ( ( (PEXPORT_CONTEXT) Context)->Flag &
           ( CONTEXT_FOR_IMPORT | CONTEXT_INVALID )) ||
         (((PEXPORT_CONTEXT) Context)->ContextID != EFS_CONTEXT_ID)
       ){

        //
        // Flush the pipe and return error.
        //

        HResult = EFSSendPipeData( (char *)&SendDataLength, 0, EfsOutPipe );
        return ERROR_ACCESS_DENIED;

    }

    //
    // Allocate necessary memory
    //

    FsctlInput = LsapAllocateLsaHeap( FSCTL_EXPORT_INPUT_LENGTH );

    //
    // Try to allocate a reasonable size buffer. The size can be fine tuned later, but should
    // at least one page plus 4K.  FSCTL_OUTPUT_LESS_LENGTH should be n * page size.
    // FSCTL_OUTPUT_MIN_LENGTH can be fine tuned later. It should be at least one page
    // plus 4K.
    //

    WkBufLength = FSCTL_OUTPUT_INITIAL_LENGTH;

    while ( !WorkBuffer && WkBufLength >= FSCTL_OUTPUT_MIN_LENGTH ){

        //
        // Sector alignment is required here.
        //

        WorkBuffer = VirtualAlloc(
                        NULL,
                        WkBufLength,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );

        if ( !WorkBuffer ){

            //
            // Memory allocation failed.
            // Try smaller allocation.
            //

            WkBufLength -= FSCTL_OUTPUT_LESS_LENGTH;

        }

    }

    if ( !WorkBuffer || !FsctlInput ){

        //
        // Not enough memory to run export
        //

        if ( WorkBuffer ){

            VirtualFree(
                WorkBuffer,
                0,
                MEM_RELEASE
                );

        }

        if ( FsctlInput ){

            LsapFreeLsaHeap( FsctlInput );

        }

        //
        // Flush the pipe and return error.
        //

        HResult = EFSSendPipeData( (char *)&SendDataLength, 0, EfsOutPipe );
        return ERROR_OUTOFMEMORY;

    }

    RtlZeroMemory( FsctlInput, FSCTL_EXPORT_INPUT_LENGTH );
    RtlZeroMemory( WorkBuffer, WkBufLength );

    //
    // Prepare the export file header
    //

    (( PEFSEXP_FILE_HEADER )WorkBuffer )->VersionID = EFS_EXP_FORMAT_CURRENT_VERSION;
    RtlCopyMemory( &((( PEFSEXP_FILE_HEADER )WorkBuffer )->FileSignature[0]),
                   FILE_SIGNATURE,
                   EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
                 );

    BufPointer = (char *) WorkBuffer + sizeof ( EFSEXP_FILE_HEADER );
    (( PEFSEXP_STREAM_HEADER )BufPointer )->Length = sizeof (USHORT) +
                                                     sizeof (EFSEXP_STREAM_HEADER);

    RtlCopyMemory( &((( PEFSEXP_STREAM_HEADER )BufPointer )->StreamSignature[0]),
               STREAM_SIGNATURE,
               EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
             );
    (( PEFSEXP_STREAM_HEADER )BufPointer )->NameLength = sizeof (USHORT);

    BufPointer = (char *)BufPointer + sizeof (EFSEXP_STREAM_HEADER);
    PUShort = (USHORT *)BufPointer;
    *PUShort = EFS_STREAM_ID;

    //
    // Let's send out the File header and stream header
    //


    SendDataLength = (ULONG)((char *)BufPointer - (char *)WorkBuffer) + sizeof (USHORT);
    HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );
    if (HResult != NO_ERROR) {

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );


        LsapFreeLsaHeap( FsctlInput );


        //
        // Flush the pipe and return error.
        //

        (void) EFSSendPipeData( (char *)&SendDataLength, 0, EfsOutPipe );
        return HResult;
    }

    //
    // Reset BufPointer so that it is aligned again.
    //

    RtlZeroMemory( WorkBuffer, SendDataLength );
    BufPointer = WorkBuffer;

    RtlCopyMemory( &((( PEFSEXP_DATA_HEADER )BufPointer )->DataSignature[0]),
               DATA_SIGNATURE,
               EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
             );
    FsctlOutput = (char *)BufPointer + sizeof ( EFSEXP_DATA_HEADER );
    FsctlOutputLength = WkBufLength - ( (ULONG) (( char* ) FsctlOutput - ( char* )WorkBuffer) );

    //
    // Issue the FSCTL to get the $EFS
    //
    EfsDataLength = FsctlInputLength = COMMON_FSCTL_HEADER_SIZE;

    ( VOID )SendHandle(
                ((PEXPORT_CONTEXT) Context)->Handle,
                (PUCHAR)FsctlInput + 3 * sizeof( ULONG ),
                &EfsDataLength
                );

    ( VOID ) EncryptFSCTLData(
                EFS_GET_ATTRIBUTE,
                0,
                0,
                (PUCHAR)FsctlInput  + 3 * sizeof(ULONG),
                EfsDataLength,
                (PUCHAR)FsctlInput,
                &FsctlInputLength
                );

    NtStatus = NtFsControlFile(
                ((PEXPORT_CONTEXT) Context)->Handle,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_ENCRYPTION_FSCTL_IO,
                FsctlInput,
                FsctlInputLength,
                FsctlOutput,
                FsctlOutputLength
                );

    if (!NT_SUCCESS( NtStatus )) {

        //
        //  Check if the output data buffer too small
        //  Try again if it is.
        //

        if ( NtStatus == STATUS_BUFFER_TOO_SMALL ){

            ULONG EfsMetaDataLength;
            ULONG BytesInBuffer;
            VOID  *TmpBuffer;

            EfsMetaDataLength = *((ULONG *)FsctlOutput);
            BytesInBuffer = (ULONG) (( char* ) FsctlOutput - ( char* )WorkBuffer);
            WkBufLength = EfsMetaDataLength + BytesInBuffer;

            // Make it a multiple of 4K

            WkBufLength = ((WkBufLength + FSCTL_OUTPUT_MISC_LENGTH - 1) / FSCTL_OUTPUT_MISC_LENGTH) * FSCTL_OUTPUT_MISC_LENGTH;

            TmpBuffer = VirtualAlloc(
                            NULL,
                            WkBufLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );

            if (TmpBuffer) {
                RtlCopyMemory(TmpBuffer, WorkBuffer, BytesInBuffer);

                VirtualFree(
                    WorkBuffer,
                    0,
                    MEM_RELEASE
                    );
                WorkBuffer = TmpBuffer;
                FsctlOutput = (char *)WorkBuffer + BytesInBuffer;
                FsctlOutputLength = WkBufLength - BytesInBuffer;
                BufPointer = WorkBuffer;

                NtStatus = NtFsControlFile(
                            ((PEXPORT_CONTEXT) Context)->Handle,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_ENCRYPTION_FSCTL_IO,
                            FsctlInput,
                            FsctlInputLength,
                            FsctlOutput,
                            FsctlOutputLength
                            );
            } else {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if ( NT_SUCCESS(NtStatus)){

        (( PEFSEXP_DATA_HEADER )BufPointer )->Length = sizeof (EFSEXP_DATA_HEADER) + *((ULONG *)FsctlOutput);

        //
        // Send out the $EFS stream
        //

        SendDataLength = WkBufLength - FsctlOutputLength + *((ULONG *)FsctlOutput);

        HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );

        //
        // Now begin to processing other data streams
        //


        StreamIndex = 0;
        StreamOffset = 0;

        if (((PEXPORT_CONTEXT) Context)->NumberOfStreams == 0) {

            MoreToRead = FALSE;

        } else {

            ( (PREQUEST_RAW_ENCRYPTED_DATA)FsctlInput )->Length = WkBufLength - FSCTL_OUTPUT_MISC_LENGTH;
            FsctlInputLength = sizeof ( REQUEST_RAW_ENCRYPTED_DATA );

        }

        while ( (HResult == NO_ERROR) && MoreToRead ){

            //
            // Fill the request header
            //

            ( (PREQUEST_RAW_ENCRYPTED_DATA)FsctlInput )->FileOffset = StreamOffset;

            //
            // Prepare output data
            //

            BufPointer = WorkBuffer ;

            if ( 0 == StreamOffset ){

                //
                //  Check if the stream is encrypted or not
                //  For the current version, we only support non-encrypted
                //  stream in directory file. Non-encrypted stream in normal
                //  file may be exported but import is not supported. EFS does
                //  not support mixed data stream in a file.
                //

                NtStatus = NtQueryInformationFile(
                            ((PEXPORT_CONTEXT) Context)->StreamHandles[ StreamIndex ],
                            &IoStatusBlock,
                            &StreamInfo,
                            sizeof (FILE_BASIC_INFORMATION),
                            FileBasicInformation
                            );

                if ( !NT_SUCCESS( NtStatus ) ){

                    //
                    // Error occured. Quit processing.
                    //

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                if ( StreamInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED ){

                            StreamEncrypted = TRUE;
                            (( PEFSEXP_STREAM_HEADER )BufPointer )->Flag = 0;

                } else {

                            StreamEncrypted = FALSE;
                            (( PEFSEXP_STREAM_HEADER )BufPointer )->Flag = STREAM_NOT_ENCRYPTED;

                }

                //
                // A new stream started. Insert a stream header
                //

                (( PEFSEXP_STREAM_HEADER )BufPointer )->NameLength =
                        ((PEXPORT_CONTEXT) Context)->StreamNames[ StreamIndex ].Length;
                SendDataLength = (( PEFSEXP_STREAM_HEADER )BufPointer )->Length =
                        (( PEFSEXP_STREAM_HEADER )BufPointer )->NameLength +
                        sizeof (EFSEXP_STREAM_HEADER);

                RtlCopyMemory( &((( PEFSEXP_STREAM_HEADER )BufPointer )->StreamSignature[0]),
                        STREAM_SIGNATURE,
                        EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
                        );

                (( PEFSEXP_STREAM_HEADER )BufPointer )->Reserved[0] =
                        (( PEFSEXP_STREAM_HEADER )BufPointer )->Reserved[1] =
                        0;

                BufPointer = (char *)BufPointer + sizeof (EFSEXP_STREAM_HEADER);

                RtlCopyMemory( BufPointer,
                        ((PEXPORT_CONTEXT) Context)->StreamNames[ StreamIndex ].Buffer,
                        ((PEXPORT_CONTEXT) Context)->StreamNames[ StreamIndex ].Length
                        );

                //
                // Let's send out the data so that we can better aligned for data section
                //

                HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );
                if (HResult != NO_ERROR) {
                    break;
                } else {
                    BufPointer =  WorkBuffer;
                }

            }

            //
            // Prepare data header
            //

            (( PEFSEXP_DATA_HEADER )BufPointer )->Flag = 0;
            RtlCopyMemory( &((( PEFSEXP_DATA_HEADER )BufPointer )->DataSignature[0]),
                       DATA_SIGNATURE,
                       EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
                     );
            FsctlOutput = (char *)BufPointer + sizeof ( EFSEXP_DATA_HEADER );
            FsctlOutputLength = WkBufLength - (ULONG)( ( char* ) FsctlOutput - ( char* )WorkBuffer);

            //
            // Read raw data
            //
            if ( StreamEncrypted ){

                //
                // Stream Encrypted. This is a sync call.
                //

                NtStatus = NtFsControlFile(
                            ((PEXPORT_CONTEXT) Context)->StreamHandles[ StreamIndex ],
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_READ_RAW_ENCRYPTED,
                            FsctlInput,
                            FsctlInputLength,
                            FsctlOutput,
                            FsctlOutputLength
                            );


                if ( !NT_SUCCESS( NtStatus ) && ( STATUS_END_OF_FILE != NtStatus) ){

                    //
                    // Error occured. Quit processing.
                    //

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                //
                // Calculate the length of data send to caller
                //
                SendDataLength = ((PENCRYPTED_DATA_INFO)FsctlOutput)->OutputBufferOffset;
                for ( ii=0; ii < ((PENCRYPTED_DATA_INFO)FsctlOutput)->NumberOfDataBlocks; ii++){

                    SendDataLength += ((PENCRYPTED_DATA_INFO)FsctlOutput)->DataBlockSize[ii];

                }

                (( PEFSEXP_DATA_HEADER )BufPointer )->Length = SendDataLength +
                                                               sizeof ( EFSEXP_DATA_HEADER );
                SendDataLength += (ULONG)(( char* ) FsctlOutput - ( char* )WorkBuffer);

                //
                // Check if this is the last stream block
                //

                BytesAdvanced = ((PENCRYPTED_DATA_INFO)FsctlOutput)->NumberOfDataBlocks <<
                                ((PENCRYPTED_DATA_INFO)FsctlOutput)->DataUnitShift;

                if ( ( STATUS_END_OF_FILE == NtStatus ) ||
                     (((PENCRYPTED_DATA_INFO)FsctlOutput)->BytesWithinFileSize < BytesAdvanced)
                    ) {

                    //
                    // Last block in this stream
                    //

                    StreamOffset = 0;
                    StreamIndex++;
                    if ( StreamIndex >= ((PEXPORT_CONTEXT) Context)->NumberOfStreams ){

                        MoreToRead = FALSE;
                        HResult = NO_ERROR;

                    }

                    if ( STATUS_END_OF_FILE == NtStatus ){

                        //
                        //  End of file. No need to send data to caller
                        //

                        continue;
                    }

                } else {

                    //
                    // More data block to be read for this stream.
                    //

                    StreamOffset = ((PENCRYPTED_DATA_INFO)FsctlOutput)->StartingFileOffset
                                   + BytesAdvanced;

                }

            } else {

                //
                // Not encrypted stream. Use normal read.
                //

                NtStatus = NtReadFile(
                    ((PEXPORT_CONTEXT) Context)->StreamHandles[ StreamIndex ],
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FsctlOutput,
                    FsctlOutputLength,
                    (PLARGE_INTEGER)&StreamOffset,
                    NULL
                    );

                if ( !NT_SUCCESS( NtStatus ) && ( STATUS_END_OF_FILE != NtStatus) ){

                    //
                    // Error occured. Quit processing.
                    //

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                //
                // Calculate the length of data send to caller
                //

                SendDataLength = (ULONG)IoStatusBlock.Information;
                (( PEFSEXP_DATA_HEADER )BufPointer )->Length = SendDataLength +
                                                               sizeof ( EFSEXP_DATA_HEADER );

                SendDataLength += (ULONG)(( char* ) FsctlOutput - ( char* )WorkBuffer);

                //
                // Check if this is the last stream block
                //

                BytesAdvanced = (ULONG)IoStatusBlock.Information;

                if ( ( STATUS_END_OF_FILE == NtStatus ) || (FsctlOutputLength > BytesAdvanced)) {

                    //
                    // Last block in this stream
                    //

                    StreamOffset = 0;
                    StreamIndex++;
                    if ( StreamIndex >= ((PEXPORT_CONTEXT) Context)->NumberOfStreams ){

                        MoreToRead = FALSE;
                        HResult = NO_ERROR;

                    }

                    if ( STATUS_END_OF_FILE == NtStatus ){

                        //
                        //  End of file. No need to send data to caller
                        //

                        continue;
                    }

                } else {

                    //
                    // More data block to be read for this stream.
                    //

                    StreamOffset += BytesAdvanced;

                }

            }

            HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );

        }//while

    } else {

        //
        //  Read $EFS wrong
        //

        HResult = RtlNtStatusToDosError( NtStatus );

    }

    //
    // End the sending data with length of 0 byte. (This flushes the pipe.)
    //

    EFSSendPipeData( (char *)WorkBuffer, 0, EfsOutPipe );

    //
    //  Finished. Clean up the memory.
    //

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );

    LsapFreeLsaHeap( FsctlInput );

    return HResult;

}

ULONG
CheckSignature(
    void *Signature
    )

/*++

Routine Description:

    This routine returns the signature type.

Arguments:

    Signature - Signature string.

Return Value:

    The type of signature. 0 for bogus signature.

--*/
{

    if ( !memcmp( Signature, FILE_SIGNATURE, SIG_LENGTH )){

        return SIG_EFS_FILE;

    }

    if ( !memcmp( Signature, STREAM_SIGNATURE, SIG_LENGTH )){

        return SIG_EFS_STREAM;

    }

    if ( !memcmp( Signature, DATA_SIGNATURE, SIG_LENGTH )){

        return SIG_EFS_DATA;

    }

    return SIG_NO_MATCH;
}

long
EfsWriteFileRaw(
    PVOID           Context,
    PVOID           EfsInPipe
    )
/*++

Routine Description:

    This routine is used to write encrypted file's raw data. It uses
    NTFS FSCTL to put the data.

Arguments:

    Context -- Context handle.
    EfsInPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    DWORD   HResult = NO_ERROR;
    ULONG   GetDataLength;
    ULONG   NextToRead;
    ULONG   FsctlInputLength;
    ULONG   BytesInBuffer;
    VOID    *WorkBuffer = NULL;
    VOID    *ReadBuffer = NULL;
    VOID    *FsctlInput;
    VOID    *BufPointer;

    NTSTATUS NtStatus;
    IO_STATUS_BLOCK  IoStatusBlock;
    HANDLE  CurrentStream = 0;
    LONGLONG StreamOffset;
    ULONG   SigID;
    UNICODE_STRING StreamName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PEFSEXP_STREAM_HEADER StreamHeader;
    TOKEN_PRIVILEGES    Privs;
    PTOKEN_PRIVILEGES   OldPrivs = NULL;
    HANDLE  TokenHandle = 0;
    DWORD   ReturnLength;
    BOOL    GotToken;
    BOOLEAN PrivilegeEnabled = FALSE;
    BOOLEAN MoreByteToWrite = TRUE;
    BOOLEAN CrntStrIsDefault = FALSE;
    BOOLEAN CrntStreamEncrypted = TRUE;

    if ( !Context ||
         !( ((PIMPORT_CONTEXT) Context)->Flag & CONTEXT_FOR_IMPORT ) ||
         ( ((PIMPORT_CONTEXT) Context)->Flag & CONTEXT_INVALID ) ||
         (((PEXPORT_CONTEXT) Context)->ContextID != EFS_CONTEXT_ID)
       ){

        return ERROR_ACCESS_DENIED;

    }

    //
    // Allocate necessary memory
    //

    WorkBuffer = VirtualAlloc(
                    NULL,
                    FSCTL_OUTPUT_INITIAL_LENGTH,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

    if ( !WorkBuffer ){
            return ERROR_OUTOFMEMORY;
    }

    //
    //  Read in the file headers first.
    //

    GetDataLength = sizeof ( EFSEXP_FILE_HEADER ) +
                    sizeof ( EFSEXP_STREAM_HEADER ) +
                    sizeof ( USHORT ) +
                    sizeof ( EFSEXP_DATA_HEADER ) +
                    sizeof ( ULONG );

    HResult = EFSReceivePipeData( (char *)WorkBuffer, &GetDataLength, EfsInPipe );

    if ( NO_ERROR != HResult ){

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );
        return HResult;

    }

    //
    // Verify file format
    //

    if ( SIG_EFS_FILE != CheckSignature(
                                (char *)WorkBuffer +
                                sizeof( ULONG)
                                ) ||
         SIG_EFS_STREAM != CheckSignature(
                                (char *)WorkBuffer +
                                sizeof( EFSEXP_FILE_HEADER ) +
                                sizeof( ULONG)
                                ) ||
         SIG_EFS_DATA != CheckSignature(
                                (char *)WorkBuffer +
                                sizeof( EFSEXP_FILE_HEADER ) +
                                sizeof ( EFSEXP_STREAM_HEADER ) +
                                sizeof ( USHORT ) +
                                sizeof( ULONG)
                                ) ||
         EFS_STREAM_ID != *((USHORT *)(
                                (char *)WorkBuffer +
                                sizeof( EFSEXP_FILE_HEADER ) +
                                sizeof ( EFSEXP_STREAM_HEADER )
                                )) ||
         EFS_EXP_FORMAT_CURRENT_VERSION != ((PEFSEXP_FILE_HEADER)WorkBuffer)->VersionID ){

        //
        // Signature does not match. This includes file which has less bytes than
        // expected head information.
        //

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );

        return ERROR_BAD_FORMAT;

    }

    //
    // Read in $EFS
    //


    RtlCopyMemory( WorkBuffer, (char *)WorkBuffer + GetDataLength - sizeof(ULONG), sizeof( ULONG ) );
    BytesInBuffer = sizeof(ULONG);
    BufPointer = (char *)WorkBuffer + BytesInBuffer;

    //
    // The read will include the length of the next block.
    //

    NextToRead = GetDataLength = *((PULONG)WorkBuffer) ;
    FsctlInputLength = FSCTL_OUTPUT_INITIAL_LENGTH - BytesInBuffer;

    if ((NextToRead + NextToRead + FSCTL_OUTPUT_MISC_LENGTH) > (FSCTL_OUTPUT_INITIAL_LENGTH - BytesInBuffer)) {

        //
        // We need a large buffer to hold 2 $EFS plus some head info
        //

        VOID *TmpBuffer;
        ULONG NewBufferLength;

        NewBufferLength = ((NextToRead + NextToRead + FSCTL_OUTPUT_MISC_LENGTH + BytesInBuffer
                           + FSCTL_OUTPUT_MISC_LENGTH - 1) / FSCTL_OUTPUT_MISC_LENGTH) * FSCTL_OUTPUT_MISC_LENGTH;

        TmpBuffer = VirtualAlloc(
                        NULL,
                        NewBufferLength,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );
        if (TmpBuffer) {

            RtlCopyMemory( TmpBuffer, WorkBuffer, BytesInBuffer);

            VirtualFree(
                WorkBuffer,
                0,
                MEM_RELEASE
                );
            WorkBuffer = TmpBuffer;
            BufPointer = (char *)WorkBuffer + BytesInBuffer;
            FsctlInputLength = NewBufferLength - BytesInBuffer;

        } else {

            VirtualFree(
                WorkBuffer,
                0,
                MEM_RELEASE
                );
            return ERROR_OUTOFMEMORY;
        }

    }

    HResult = EFSReceivePipeData( (char *)BufPointer, &NextToRead, EfsInPipe );
    if ( NO_ERROR != HResult ){

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );
        return HResult;

    }

    if ( GetDataLength > NextToRead){

        //
        // No data stream followed $EFS. This is either a 0 length file
        // Or a directory file.
        //

        MoreByteToWrite = FALSE;
        NextToRead = 0;

    }  else {

        NextToRead = *(ULONG UNALIGNED *)(( char *) BufPointer + GetDataLength - sizeof (ULONG));

    }

    //
    //  The $EFS is in. Write it out!
    //  First prepare the FsctlInput
    //

    FsctlInput = (char*) BufPointer + GetDataLength;
    FsctlInputLength -= GetDataLength;

    //
    // Send FsctlInputData to the server
    //

    HResult = GetOverWriteEfsAttrFsctlInput(
                        (( PIMPORT_CONTEXT ) Context)->Flag,
                        (( PIMPORT_CONTEXT ) Context)->DesiredAccess,
                        ( char * )BufPointer - sizeof (ULONG),
                        GetDataLength,
                        (char *)FsctlInput,
                        &FsctlInputLength
                        );

    if ( NO_ERROR != HResult ){

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );
        return HResult;

    }

    NtStatus = NtFsControlFile(
                ((PIMPORT_CONTEXT) Context)->Handle,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_SET_ENCRYPTION ,
                FsctlInput,
                FsctlInputLength,
                NULL,
                NULL
                );

    if ( NT_SUCCESS( NtStatus )){

        DWORD ShareMode = 0;

        //
        // $EFS is written now
        //

        StreamOffset = 0;

        //
        // ********* Trick Trick Trick *********
        // NTFS will have better performance if align the data block.
        // We already have the length field of the block which is a ULONG
        // field. Here we start our offset at sizeof (ULONG).
        // Not only performance, now is required by NTFS. Otherwise it will
        // fail.
        //

        BufPointer = (char *)WorkBuffer + sizeof (ULONG);

        while ( MoreByteToWrite ){

            GetDataLength = NextToRead;

            //
            // The read will include the length of the next block.
            // No backward reading here.
            //

            HResult = EFSReceivePipeData( (char *)BufPointer, &GetDataLength, EfsInPipe );

            if ( NO_ERROR != HResult ){

                break;

            }

            if ( GetDataLength < NextToRead ){

                //
                // End of file reached
                //

                MoreByteToWrite = FALSE;
                NextToRead = 0;

            } else {

                //
                // Prepare for next read block. Be careful about the alignment here.
                //

                RtlCopyMemory((char *) &NextToRead,
                              (char *) BufPointer +  GetDataLength - sizeof (ULONG),
                              sizeof (ULONG)
                              );

            }

            SigID = CheckSignature( BufPointer );
            if ( SIG_EFS_STREAM == SigID ){

                //
                // This is a stream block. Create a new stream.
                //

                StreamHeader = (PEFSEXP_STREAM_HEADER)((char *)BufPointer - sizeof( ULONG ));
                if ( StreamHeader->Flag & STREAM_NOT_ENCRYPTED ){

                    CrntStreamEncrypted = FALSE;

                } else {

                    CrntStreamEncrypted = TRUE;
                }

                StreamName.Length = (USHORT) StreamHeader->NameLength;

                StreamName.Buffer = ( USHORT* )((char *)BufPointer +
                    sizeof ( EFSEXP_STREAM_HEADER ) -
                    sizeof ( ULONG ));

                if ( CurrentStream && !CrntStrIsDefault){

                    //
                    // Close the previous stream
                    //

                    NtClose(CurrentStream);
                    CurrentStream = 0;

                }

                if ( (DEF_STR_LEN == StreamName.Length) &&
                     !memcmp( StreamName.Buffer,
                            DEFAULT_STREAM,
                            StreamName.Length
                            )
                   ){

                    //
                    // Default data stream to be processed.
                    // This is the most case. We need to optimize this!!!
                    //

                    CurrentStream = ((PIMPORT_CONTEXT) Context)->Handle;
                    CrntStrIsDefault = TRUE;

                } else {

                    //
                    //  Other data streams
                    //

                    if ( (((( PIMPORT_CONTEXT ) Context)->CreateOptions) & FILE_OPEN_FOR_BACKUP_INTENT) &&
                          ( !PrivilegeEnabled)  ){

                        //
                        // Enable the Privilege. We only enable once. If fail, we return.
                        //

                        PrivilegeEnabled = TRUE;

                        OldPrivs = ( TOKEN_PRIVILEGES *) LsapAllocateLsaHeap(sizeof( TOKEN_PRIVILEGES ));

                        if ( OldPrivs == NULL ){

                           HResult = ERROR_NOT_ENOUGH_MEMORY;
                            break;

                        }

                        //
                        // We're impersonating, use the thread token.
                        //

                        GotToken = OpenThreadToken(
                                GetCurrentThread(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                FALSE,
                                &TokenHandle
                                );

                        if ( GotToken ) {

                            //
                            // We've got a token handle
                            //

                            Privs.PrivilegeCount = 1;
                            Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);

                            ReturnLength = sizeof( TOKEN_PRIVILEGES );

                            (VOID) AdjustTokenPrivileges (
                                        TokenHandle,
                                        FALSE,
                                        &Privs,
                                        sizeof( TOKEN_PRIVILEGES ),
                                        OldPrivs,
                                        &ReturnLength
                                        );

                            HResult = GetLastError();

                            //
                            // Caller will call RpcRevertToSelf().
                            // OldPrivs is not needed any more.
                            //

                            LsapFreeLsaHeap( OldPrivs );
                            OldPrivs = NULL;

                            if ( ERROR_SUCCESS != HResult ) {

                                //
                                // Privilege adjust failed
                                //

                                CloseHandle( TokenHandle );
                                TokenHandle = 0;
                                break;

                            }

                        } else {

                            //
                            // We did not get the handle.
                            //

                            TokenHandle = 0;
                            HResult = GetLastError();
                            LsapFreeLsaHeap( OldPrivs );
                            OldPrivs = NULL;
                            break;

                        }

                        if (((PIMPORT_CONTEXT) Context)->DesiredAccess & DELETE) {
                            ShareMode = FILE_SHARE_DELETE;
                        }
                    }

                    StreamName.MaximumLength = StreamName.Length;

                    CrntStrIsDefault = FALSE;

                    InitializeObjectAttributes(
                            &ObjectAttributes,
                            &StreamName,
                            0,
                            ((PIMPORT_CONTEXT) Context)->Handle,
                            NULL
                            );

                    NtStatus = NtCreateFile(
                                    &CurrentStream,
                                    ((PIMPORT_CONTEXT) Context)->DesiredAccess,
                                    &ObjectAttributes,
                                    &IoStatusBlock,
                                    (PLARGE_INTEGER) NULL,
                                    ((PIMPORT_CONTEXT) Context)->Attribute,
                                    ShareMode,
                                    ((PIMPORT_CONTEXT) Context)->CreateDisposition,
                                    ((PIMPORT_CONTEXT) Context)->CreateOptions,
                                    (PVOID) NULL,
                                    0L
                                    );

                    if ( !NT_SUCCESS( NtStatus ) ){

                        HResult = RtlNtStatusToDosError( NtStatus );
                        break;

                    }
                }

                //
                // Stream header processed. Adjust BufPointer to make it consistant with ReadRaw
                //

                BufPointer = (char *)WorkBuffer + sizeof (ULONG);
                continue;

            }

            if ( SIG_EFS_DATA != SigID ){

                //
                // Corrupted file
                //
                HResult = ERROR_FILE_CORRUPT;
                break;

            }

            //
            // Processing the data block
            // After all the above is done, this should be a piece of cake!
            //

            FsctlInput = (char *)BufPointer + sizeof (EFSEXP_DATA_HEADER) - sizeof (ULONG);
            FsctlInputLength = GetDataLength - sizeof (EFSEXP_DATA_HEADER);
            if ( !MoreByteToWrite ){

                //
                //  Adjust for the last block. There is no extra length
                //  field for the next block.
                //

                FsctlInputLength += sizeof (ULONG);
            }

            if ( CrntStreamEncrypted ){

                //
                // Most of the case.
                //

                //
                //  finally writing data out
                //

                NtStatus = NtFsControlFile(
                            CurrentStream,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_WRITE_RAW_ENCRYPTED,
                            FsctlInput,
                            FsctlInputLength,
                            NULL,
                            0
                            );

            } else {

                //
                // Currently only support plain data stream on directory
                //

                NtStatus = NtWriteFile(
                    CurrentStream,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FsctlInput,
                    FsctlInputLength,
                    NULL,
                    NULL
                    );

            }

            if ( !NT_SUCCESS( NtStatus ) ){

                HResult = RtlNtStatusToDosError( NtStatus );
                break;

            }

            BufPointer = (char *)WorkBuffer + sizeof (ULONG);
            HResult = NO_ERROR;

        } //while loop

    } else {

        //
        // Writing $EFS error
        //

        HResult = RtlNtStatusToDosError( NtStatus );

    }

    if ( CurrentStream && !CrntStrIsDefault ){

        NtClose(CurrentStream);

    }

    if ( TokenHandle ){
        CloseHandle( TokenHandle );
    }

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );
    return HResult;

}

DWORD
GetOverWriteEfsAttrFsctlInput(
    ULONG Flag,
    ULONG AccessFlag,
    char *InputData,
    ULONG InputDataLength,
    char *OutputData,
    ULONG *OutputDataLength
    )
/*++

Routine Description:

    This routine is used to prepare the FSCTL input data buffer for
    EFS_OVERWRITE_ATTRIBUTE used in import.

Arguments:

    Flag -- Indicate the type of the target.

    AccessFlag -- Indicate the kind of access required.

    InputData -- Required input data ($EFS)

    InputDataLength -- The length of the input data.

    OutputData -- The prepared data as the result of this routine.

    OutputDataLength -- The length of the output data.

Return Value:

    The result of operation.

--*/
{
    DWORD   HResult = NO_ERROR;
    PEFS_KEY Fek = NULL;
    PEFS_DATA_STREAM_HEADER NewEfs = NULL;
    ULONG EfsDataLength = 0 ;
    ULONG OutBufLen = *OutputDataLength;
    BOOLEAN WithFek = FALSE;
    PBYTE SourceEfs;
    ULONG CipherSubCode;
    HANDLE hToken;
    HANDLE hProfile;
    EFS_USER_INFO EfsUserInfo;


    if ( !(Flag & CONTEXT_OPEN_FOR_DIR) ){

        //
        // Not for directory file. Check if we can get
        // FEK or not.
        //

        if (EfspGetUserInfo( &EfsUserInfo )) {

            if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

                HResult = DecryptFek(
                            &EfsUserInfo,
                            ( PEFS_DATA_STREAM_HEADER ) InputData,
                            &Fek,
                            &NewEfs,
                            0
                            );

                EfspUnloadUserProfile( hToken, hProfile );

            } else {

                HResult = GetLastError();

            }

            EfspFreeUserInfo( &EfsUserInfo );

        } else {

            HResult = GetLastError();

        }

        if ( NO_ERROR == HResult ){

            WithFek = TRUE;

        } else {

            if ( AccessFlag & FILE_WRITE_DATA ){

                //
                //  A general user without the key.
                //



                return ERROR_ACCESS_DENIED;

            } else {

                HResult = NO_ERROR;

            }

        }
    }

    if ( WithFek ){

        //
        // Calculate the length of output buffer
        // and the offset to put the $EFS
        //

        *OutputDataLength = 3 * sizeof(ULONG) +
                                  2 * EFS_KEY_SIZE( Fek );

        if (NewEfs){
            SourceEfs = (PBYTE) NewEfs;
        } else {
            SourceEfs = (PBYTE) InputData;
        }
        *OutputDataLength += *(PULONG)SourceEfs;

        if (OutBufLen >= *OutputDataLength) {

           EfsDataLength = *OutputDataLength - 3 * sizeof(ULONG);

           ( VOID ) SendEfs(
                        Fek,
                        (PEFS_DATA_STREAM_HEADER) SourceEfs,
                        (PBYTE) OutputData + 3 * sizeof(ULONG),
                        &EfsDataLength
                        );
        } else {
           HResult = ERROR_INSUFFICIENT_BUFFER;
        }

        //
        //  Free the memory we have allocated.
        //

        if ( Fek ){

            LsapFreeLsaHeap( Fek );

        }
        if ( NewEfs ){

            LsapFreeLsaHeap( NewEfs );

        }

        CipherSubCode = WRITE_EFS_ATTRIBUTE | SET_EFS_KEYBLOB;

    } else {

        //
        // No FEK required.
        //

        *OutputDataLength = COMMON_FSCTL_HEADER_SIZE +
                                  *(PULONG)InputData;


        if (OutBufLen >= *OutputDataLength) {
           EfsDataLength = *OutputDataLength - 3 * sizeof(ULONG);

           ( VOID ) SendHandleAndEfs(
                       (HANDLE) ULongToPtr(Flag),
                       (PEFS_DATA_STREAM_HEADER) InputData,
                       (PBYTE) OutputData + 3 * sizeof(ULONG),
                       &EfsDataLength
                       );
        } else {
           HResult = ERROR_INSUFFICIENT_BUFFER;
        }

        CipherSubCode = WRITE_EFS_ATTRIBUTE;

    }

    if ( NO_ERROR == HResult ) {

       ( VOID ) EncryptFSCTLData(
                   EFS_OVERWRITE_ATTRIBUTE,
                   EFS_ENCRYPT_STREAM,
                   CipherSubCode,
                   (PBYTE) OutputData + 3 * sizeof(ULONG),
                   EfsDataLength,
                   (PBYTE) OutputData,
                   OutputDataLength
                   );

    }

    return HResult;

}

DWORD
CheckVolumeSpace(
    PFILE_FS_SIZE_INFORMATION VolInfo,
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    )
/*++

Routine Description:

    This routine estimates if the volume has enough disk space to do the encryption or
    decryption operation. The estimates is not accurate. System overheads are not included.
    Real available space could be more or less when the operation begins. If we are not sure,
    the operation will continue until we really run out of space.

Arguments:

    VolInfo -- Information to calculate how much space left.

    StreamSizes -- Information to calculate how much space needed.

    StreamCount -- Number of data streams.

Return Value:

    ERROR_SUCCESS returned if there might be enough space.

--*/
{
    LARGE_INTEGER   SpaceLeft;
    LARGE_INTEGER   SpaceNeeded;
    ULONG   ClusterSize;
    ULONG ii;

    SpaceLeft = VolInfo->AvailableAllocationUnits;
    ClusterSize = VolInfo->SectorsPerAllocationUnit * VolInfo->BytesPerSector;
    SpaceLeft.QuadPart *= ClusterSize;
    for ( ii = 0, SpaceNeeded.QuadPart = 0; ii < StreamCount; ii++)
    {
        if ( StreamSizes[ii].StreamFlag & ( FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE ) ){

            FILE_STANDARD_INFORMATION   StreamStdInfo;
            IO_STATUS_BLOCK IoStatusBlock;
            NTSTATUS Status;

            //
            // Get File Attributes
            //
            Status = NtQueryInformationFile(
                StreamHandles[ii],
                &IoStatusBlock,
                &StreamStdInfo,
                sizeof ( FILE_STANDARD_INFORMATION ),
                FileStandardInformation
                );

            if (!NT_SUCCESS(Status)){

                //
                // We got error. We are not sure if we have enough space. Give it a try.
                //

                return ERROR_SUCCESS;
            }

            if ( StreamSizes[ii].StreamFlag &  FILE_ATTRIBUTE_SPARSE_FILE ){

                //
                // A sparse file (may be compressed). The more accurate way is to query
                // the ranges. Even with that is still a rough estimate. For better performance,
                // we use the STD info.
                //

                SpaceNeeded.QuadPart += StreamStdInfo.AllocationSize.QuadPart;

            } else {

                //
                // Compressed file. Using Virtual Allocation Size + Total Allocation Size
                //

                SpaceNeeded.QuadPart += StreamSizes[ii].AllocSize.QuadPart + StreamStdInfo.AllocationSize.QuadPart;

            }

        } else {
            SpaceNeeded.QuadPart += StreamSizes[ii].AllocSize.QuadPart;
        }

        if ( SpaceNeeded.QuadPart >=  SpaceLeft.QuadPart ){
            return ERROR_DISK_FULL;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CompressStreams(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG State,
    ULONG StreamCount
    )
/*++

Routine Description:

    This routine compresses or decompresses the passed in streams.

Arguments:

    StreamSizes -- Holding streams' original state info.

    StreamHandles -- Stream handles.

    State -- New compressed state.

    StreamCount -- Number of data streams.

Return Value:

    ERROR_SUCCESS returned if there might be enough space.

--*/
{
    DWORD rc = ERROR_SUCCESS;
    ULONG Length;
    ULONG ii;
    BOOL b = TRUE;

    for (ii = 0; ii < StreamCount; ii++){

        b = DeviceIoControl(
                            StreamHandles[ii],
                            FSCTL_SET_COMPRESSION,
                            &State,
                            sizeof(USHORT),
                            NULL,
                            0,
                            &Length,
                            FALSE
                            );

        if ( !b ){
            rc = GetLastError();
            break;
        }

    }

    if ( !b ){

        //
        //  Error happened. Try to restore the stream state.
        //

        for ( ULONG jj = 0; jj < ii; jj++){

            if ( StreamSizes[ jj ].StreamFlag & FILE_ATTRIBUTE_COMPRESSED ){

                State =  COMPRESSION_FORMAT_DEFAULT;

            } else {

                State =  COMPRESSION_FORMAT_NONE;

            }

            //
            // Error is not checked. We can only recover the state as much
            // as we can.
            //

            (VOID) DeviceIoControl(
                                StreamHandles[jj],
                                FSCTL_SET_COMPRESSION,
                                &State,
                                sizeof(USHORT),
                                NULL,
                                0,
                                &Length,
                                FALSE
                                );
        }

    }

    return rc;
}

DWORD
CheckOpenSection(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    )
/*++

Routine Description:

    This routine set EOF of a stream to 0 and then back to its original size.
    All the stream content is lost. Valid length is set to 0. This process will also
    speed up a compressed file encryption.

Arguments:

    StreamSizes -- Holding streams' original state info.

    StreamHandles -- Stream handles.

    StreamCount -- Number of data streams.

Return Value:

    ERROR_SUCCESS returned if succeed.

--*/
{
    ULONG ii;
    FILE_END_OF_FILE_INFORMATION    FileSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status = STATUS_SUCCESS;

    for (ii = 0; ii < StreamCount; ii++){
        FileSize.EndOfFile.QuadPart = 0;
        Status = NtSetInformationFile(
                    StreamHandles[ii],
                    &IoStatusBlock,
                    &FileSize,
                    sizeof(FileSize),
                    FileEndOfFileInformation
                    );
        if ( !NT_SUCCESS(Status) ){

            //
            // A section handle may be open on the stream.
            //

            break;
        }
    }

    if ( NT_SUCCESS(Status) ){
        for (ii = 0; ii < StreamCount; ii++){
            FileSize.EndOfFile = StreamSizes[ii].EOFSize;
            Status = NtSetInformationFile(
                        StreamHandles[ii],
                        &IoStatusBlock,
                        &FileSize,
                        sizeof(FileSize),
                        FileEndOfFileInformation
                        );
            if ( !NT_SUCCESS(Status) ){
                break;
            }
        }
    }

    return RtlNtStatusToDosError( Status );
}

DWORD
CopyStreamSection(
    HANDLE Target,
    HANDLE SrcMapping,
    PLARGE_INTEGER Offset,
    PLARGE_INTEGER DataLength,
    PLARGE_INTEGER AllocationGranularity
    )
/*++

Routine Description:

    This routine copies a section of data from source stream
    to target stream.

Arguments:

    Target -- Destination stream handle.

    SrcMapping -- Source stream mapping handle.

    Offset -- Data offdset in the stream.

    DataLength -- Byte count to be copied.

    AllocationGranularity -- Allocation granularity.

Return Value:

    Results of the operation.

--*/
{
    LARGE_INTEGER RemainingData = *DataLength;
    LARGE_INTEGER StreamOffset = *Offset;
    ULONG BytesToCopy;
    PVOID pbFile;
    DWORD BytesWritten;
    BOOL b;
    DWORD rc = NO_ERROR;

    while ( RemainingData.QuadPart > 0 ) {

        //
        // Determine number of bytes to be mapped
        //

        if (  RemainingData.QuadPart < AllocationGranularity->QuadPart ) {
            BytesToCopy = RemainingData.LowPart;
        } else {
            BytesToCopy = AllocationGranularity->LowPart;
        }

        pbFile = MapViewOfFile(
                      SrcMapping,
                      FILE_MAP_READ,
                      StreamOffset.HighPart,
                      StreamOffset.LowPart,
                      BytesToCopy
                      );

        if (pbFile != NULL) {

            //
            // Write the data to the target stream
            //

            b = WriteFile(
                       Target,
                       pbFile,
                       BytesToCopy,
                       &BytesWritten,
                       NULL
                       );

            UnmapViewOfFile( pbFile );

            LARGE_INTEGER BytesCopied;

            BytesCopied.HighPart = 0;
            BytesCopied.LowPart = BytesToCopy;

            RemainingData.QuadPart -= BytesCopied.QuadPart;
            StreamOffset.QuadPart += BytesCopied.QuadPart;

            if (!b) {
                rc = GetLastError();
                DebugLog((DEB_ERROR, "WriteFile failed, error = %d\n", rc ));
                break;
            }

        } else {

            rc = GetLastError();
            DebugLog((DEB_ERROR, "MapViewOfFile failed, error = %d\n" ,rc));
            break;
        }
    }

    return rc;

}

NTSTATUS
GetFileEfsStream(
    IN HANDLE hFile,
    OUT PEFS_DATA_STREAM_HEADER * pEfsStream
    )
/*++

Routine Description:

    Get the $EFS from the passed file or directory

Arguments:

    hFile - An open handle the the file or directory of interest.

    pEfsStream - Returns a pointer to a block of memory containing the EFS stream
        for the passed file.  Free with LsapFreeLsaHeap();

Return Value:

    Status of operation.

--*/

{

    ULONG Index;
    ULONG cbOutputData;
    ULONG EfsDataLength;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG TmpOutputData;

    *pEfsStream = NULL;

    //
    // Now we got a handle to the parent directory in ParentDir.
    // Allocate input and output data buffer
    //

    cbOutputData = sizeof( ULONG );

    //
    // PSC, [EFS_FC, CSC , SK, H, H, [SK, H, H]sk]sk
    // PSC, CSC are ignored in this FSCTL call
    //

    const ULONG InputDataSize = (2 * sizeof(DriverSessionKey)) + (7 * sizeof(ULONG));
    BYTE InputData[InputDataSize];

    ULONG cbInputData = InputDataSize;

    //
    // Prepare an input data for making a FSCTL call to get the $EFS
    //

    EfsDataLength = 2 * sizeof(DriverSessionKey) + 4 * sizeof(ULONG);
    SendHandle( hFile, InputData + 3*sizeof(ULONG), &EfsDataLength );

    (VOID) EncryptFSCTLData(
                EFS_GET_ATTRIBUTE,
                0,
                0,
                InputData + (3 * sizeof(ULONG)),
                EfsDataLength,
                InputData,
                &cbInputData
                );

    //
    // First call to get the size
    //

    Status = NtFsControlFile(
                hFile,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_ENCRYPTION_FSCTL_IO,
                InputData,
                cbInputData,
                &TmpOutputData,
                cbOutputData
                );

    ASSERT(!NT_SUCCESS( Status ));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        //
        //  Check if the output data buffer too small
        //  Try again if it is.
        //

        cbOutputData = TmpOutputData;
        *pEfsStream = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( cbOutputData );

        if ( *pEfsStream ) {

            Status = NtFsControlFile(
                    hFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_ENCRYPTION_FSCTL_IO,
                    InputData,
                    cbInputData,
                    *pEfsStream,
                    cbOutputData
                    );
        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( !NT_SUCCESS( Status ) ){

            if ( *pEfsStream ){
                LsapFreeLsaHeap( *pEfsStream );
                *pEfsStream = NULL;
            }
        }
    }

    return Status;
}


ULONG
StringInfoCmp(
    IN PFILE_STREAM_INFORMATION StreamInfoBaseSrc,
    IN PFILE_STREAM_INFORMATION StreamInfoBaseDst,
    IN ULONG StreamInfoSize
    )
/*++

Routine Description:

    This routine compares to blocks FILE_STREAM_INFORMATION. The StreamAllocationSize
    cound differ and they should still be thought as eaqual.

Arguments:

    StreamInfoBaseSrc - Source block

    StreamInfoBaseDst - Dstination block

    StreamInfoSize - Block size in bytes

Return Value:

    0 if compares same.

--*/
{
   ULONG rc;

   rc = memcmp(StreamInfoBaseSrc, StreamInfoBaseDst, StreamInfoSize);
   if (rc) {
      do {

         rc = memcmp(StreamInfoBaseSrc->StreamName,
                     StreamInfoBaseDst->StreamName,
                     StreamInfoBaseSrc->StreamNameLength
                     );

         if (StreamInfoBaseSrc->NextEntryOffset){
             StreamInfoBaseSrc = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfoBaseSrc + StreamInfoBaseSrc->NextEntryOffset);
         } else {
             StreamInfoBaseSrc = NULL;
         }

         if (StreamInfoBaseDst->NextEntryOffset){
             StreamInfoBaseDst = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfoBaseDst + StreamInfoBaseDst->NextEntryOffset);
         } else {
             StreamInfoBaseDst = NULL;
         }

         if (((StreamInfoBaseSrc == NULL) || (StreamInfoBaseDst == NULL)) && (StreamInfoBaseSrc != StreamInfoBaseDst)) {
            rc = 1;
         }

      } while ( (rc == 0) && StreamInfoBaseSrc );
   }

   return rc;
}

//
//  Beta 2 API
//





DWORD
AddUsersToFileSrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN LPCTSTR lpFileName,
    IN DWORD nUsers,
    IN PENCRYPTION_CERTIFICATE * pEncryptionCertificates
    )

/*++

Routine Description:

    This routine will add an entry in the DDF field of the passed file
    for each certificate passed.

    The file will not be modified at all if any errors occur
    during processing.

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.  File may
        be local or remote.  It will be opened for exclusive access.

    dwCertificates - Supplies the number of certificate structures in the
        pEncryptionCertificates array.

    pEncryptionCertificates - Supplies an array of pointers to certificate
        structures, one for each user to be added to the file.


Return Value:

    This routine will fail under the following circumstances:

    Passed file is not encrypted.

    Passed file cannot be opened for exclusive access.

    Caller does not have keys to decrypt the file.

    A passed certificate was not structurally valid.  In this case,
    the entire operation will fail.

    And all the other reasons why an EFS operation can fail
    (EFS not present, no recovery policy, etc)

--*/
{
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;

    //
    // Open the passed file and get the EFS stream
    //

    //
    // Open for READ_ATTRIBUTES so we don't go through all the noise of
    // decrypting the FEK when we don't really care to (we're going to have to
    // do that here anyway).  We could open the file just to be sure the decrypt
    // is going to work, but there's no point in speeding up the failure case.
    //

    PEFS_DATA_STREAM_HEADER pEfsStream = NULL;

    HANDLE hFile;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES | FILE_WRITE_DATA,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            //
            // Decrypt the FEK, if possible
            //

            PEFS_KEY Fek;
            PEFS_DATA_STREAM_HEADER UpdatedEfs = NULL;

            rc = DecryptFek( pEfsUserInfo, pEfsStream, &Fek, &UpdatedEfs, 0 );

            if (rc == ERROR_SUCCESS) {

                if (UpdatedEfs != NULL) {

                    //
                    // Something changed since the last time this file was
                    // opened.
                    //

                    LsapFreeLsaHeap( pEfsStream );
                    pEfsStream = UpdatedEfs;
                    UpdatedEfs = NULL;
                }

                //
                // For each certificate passed to us,
                // add it to the EFS stream.
                //

                for (DWORD i=0; i<nUsers ; i++) {

                    PENCRYPTION_CERTIFICATE pEncryptionCert;
                    BOOLEAN bRet;

                    __try{

                        pEncryptionCert= pEncryptionCertificates[i];
                        bRet = AddUserToEFS(
                            pEfsStream,
                            pEncryptionCert->pUserSid,
                            Fek,
                            pEncryptionCert->pCertBlob->pbData,
                            pEncryptionCert->pCertBlob->cbData,
                            &UpdatedEfs
                            );
                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        bRet = FALSE;
                        SetLastError( ERROR_INVALID_PARAMETER );

                    }


                    if (bRet) {

                        //
                        // Toss the old EFS stream and pick up the new one.
                        //

                        if (UpdatedEfs) {
                           b = TRUE;
                           LsapFreeLsaHeap( pEfsStream );
                           pEfsStream = UpdatedEfs;
                           UpdatedEfs = NULL;
                        }

                    } else {

                        b = FALSE;
                        rc = GetLastError();
                        break;

                    }
                }

                //
                // If we got out with everything working,
                // set the new EFS stream on the file.  Otherwise,
                // clean up and fail the entire operation.
                //

                if (b) {

                    //
                    // Set the new EFS stream on the file.
                    //

                    if (!EfspSetEfsOnFile( hFile, pEfsStream, NULL )) {
                        rc = GetLastError();
                    }
                }
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    return( rc );
}


BOOL
EfspSetEfsOnFile(
    IN HANDLE hFile,
    PEFS_DATA_STREAM_HEADER pEfsStream,
    IN PEFS_KEY pNewFek OPTIONAL
    )
/*++

Routine Description:

    The routine sets the passed EFS stream onto the passed file.  The
    file must be open for WRITE_DATA access.

Arguments:

    hFile - Supplies a handle to the file being modified.

    pEfsStream - Supplies the new EFS stream to be placed on the file.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOL b = FALSE;

    DWORD OutputDataLength = 0;
    DWORD EfsDataLength = 0;
    PBYTE OutputData = NULL;

    if (ARGUMENT_PRESENT( pNewFek )) {

        OutputDataLength = 3 * sizeof(ULONG) + 2 * EFS_KEY_SIZE( pNewFek ) + pEfsStream->Length;

        EfsDataLength = OutputDataLength - 3 * sizeof(ULONG);

        OutputData = (PBYTE)LsapAllocateLsaHeap( OutputDataLength );

        if (OutputData) {

            b = SendEfs(
                    pNewFek,
                    pEfsStream,
                    (PBYTE) OutputData + 3 * sizeof(ULONG),
                    &EfsDataLength
                    );
        }

    } else {

        //
        // Not changing the FEK on the file.
        //

        OutputDataLength = COMMON_FSCTL_HEADER_SIZE + pEfsStream->Length;

        EfsDataLength = OutputDataLength - 3 * sizeof(ULONG);

        OutputData = (PBYTE)LsapAllocateLsaHeap( OutputDataLength );

        if (OutputData) {

            b = SendHandleAndEfs(
                       hFile,
                       pEfsStream,
                       (PBYTE) OutputData + 3 * sizeof(ULONG),
                       &EfsDataLength
                       );
        }
    }

    if (b) {

        DWORD Attributes = WRITE_EFS_ATTRIBUTE;

        if (ARGUMENT_PRESENT( pNewFek )) {
            Attributes |= SET_EFS_KEYBLOB;
        }

        b = EncryptFSCTLData(
                   EFS_OVERWRITE_ATTRIBUTE,
                   EFS_ENCRYPT_STREAM,
                   Attributes,
                   (PBYTE) OutputData + 3 * sizeof(ULONG),
                   EfsDataLength,
                   (PBYTE) OutputData,
                   &OutputDataLength
                   );

        //
        // As currently implemented, this routine cannot fail.
        //

        ASSERT(b);

        NTSTATUS NtStatus;
        IO_STATUS_BLOCK IoStatusBlock;

        DWORD FsControl;

        if (ARGUMENT_PRESENT( pNewFek )) {
            FsControl = FSCTL_SET_ENCRYPTION;
        } else {
            FsControl = FSCTL_ENCRYPTION_FSCTL_IO;
        }

        NtStatus = NtFsControlFile(
                    hFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FsControl,
                    OutputData,
                    OutputDataLength,
                    NULL,
                    NULL
                    );

        if ( NT_SUCCESS( NtStatus )){

            b = TRUE;

        } else {

            b = FALSE;

            SetLastError( RtlNtStatusToDosError( NtStatus ) );
        }
    }

    if (OutputData != NULL) {
        LsapFreeLsaHeap( OutputData );
    }

    return( b );
}


DWORD
QueryUsersOnFileSrv(
    IN  LPCTSTR lpFileName,
    OUT PDWORD pnUsers,
    OUT PENCRYPTION_CERTIFICATE_HASH ** pUsers
    )
/*++

Routine Description:

    This routine will return a buffer containing the certificate hashes
    and SIDs for the users who can decrypt the specified file.

    Note that the current user does not need to be able to decrypt the
    file.

Arguments:

    lpFileName - Supplies the file to be examined.  This file will be opened
        for exclusive access.  The caller must have READ_ATTRIBUTES access to
        the file.

    pnUsers - Returns the number of entries in the pHashes array.  This field will be
        set even if pHashes is NULL.

    pHashes - Supplies a buffer to be filled with an array of ENCRYPTION_CERTIFICATE_HASH
        structures, one for each user listed in the DDF of the file.  This parameter may
        be NULL if the caller is trying to determine the required size.


Return Value:

    This routine will fail if:

    The passed file is not encrypted.

    The passed buffer is non-NULL but not large enough.

    The current user does not have READ_ATTRIBUTES access to the file.

--*/

{
    //
    // Open the file
    //

    BOOL b = FALSE;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream;
    DWORD rc = ERROR_SUCCESS;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    *pnUsers = NULL;
    *pUsers = NULL;


    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfsStream );

            __try {

                //
                // We may have gotten corrupted bits off the disk.  We can't
                // verify the checksum on the EfsStream, because we don't have the
                // FEK (and we don't want to require the caller to have to decrypt
                // the file to get this information).  So wrap this call in a
                // try-except so we don't risk blowing up.
                //

                b = QueryCertsFromEncryptedKeys(
                        pDDF,
                        pnUsers,
                        pUsers
                        );

                if (!b) {
                    rc = GetLastError();
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                b = FALSE;

                rc = GetExceptionCode();

                if (ERROR_NOACCESS == rc) {
                    rc = ERROR_FILE_CORRUPT;
                }
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    if (rc != ERROR_SUCCESS) {
        DebugLog((DEB_WARN, "QueryUsersOnFileSrv returning %x\n" ,rc  ));
    }

    return( rc );
}


DWORD
QueryRecoveryAgentsSrv(
    IN LPCTSTR lpFileName,
    OUT PDWORD pnRecoveryAgents,
    OUT PENCRYPTION_CERTIFICATE_HASH ** pRecoveryAgents
    )
/*++

Routine Description:

    This routine will return a buffer containing the certificate hashes
    for the recovery agents on the passed file.

    Note that the current user does not need to be able to decrypt the
    file.

    [ Should we combine this routine with the one above, and just take a
    flag?  Or should there be one routine that returns everything, perhaps
    with a mark for each user that is in the DRF?  There are several ways
    to do this. ]

Arguments:

    lpFileName - Supplies the file to be examined.  This file will be opened
        for exclusive access.  The caller must have READ_ATTRIBUTES access to
        the file.

    pcbBuffer - Supplies/returns the size of the buffer passed in the in pHashes
        parameter.  If pHashes is NULL, the function will succeed and the required
        size will be returned.

    pHashes - Supplies a buffer to be filled with an array of ENCRYPTION_CERTIFICATE_HASH
        structures, one for each user listed in the DRF of the file.  This parameter may
        be NULL if the caller is trying to determine the required size.


Return Value:

    This routine will fail if:

    The passed file is not encrypted.

    The passed buffer is non-NULL but not large enough.

    The current user does not have READ_ATTRIBUTES access to the file.

--*/

{
    //
    // Open the file
    //

    BOOL b = FALSE;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream;
    DWORD rc = ERROR_SUCCESS;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    *pnRecoveryAgents = 0;
    *pRecoveryAgents = NULL;

    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, pEfsStream );

            if ( (PVOID)pDRF != (PVOID)pEfsStream) {

                __try {
    
                    b = QueryCertsFromEncryptedKeys(
                            pDRF,
                            pnRecoveryAgents,
                            pRecoveryAgents
                            );
    
                    if (!b) {
                        rc = GetLastError();
                    }
    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
    
                    b = FALSE;
    
                    rc = GetExceptionCode();
    
                    if (ERROR_NOACCESS == rc) {
                        rc = ERROR_FILE_CORRUPT;
                    }
                }

            }


            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    if (rc != ERROR_SUCCESS) {
        DebugLog((DEB_WARN, "QueryRecoveryAgentsSrv returning %x\n" ,rc  ));
    }

    return( rc );
}


DWORD
RemoveUsersFromFileSrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN LPCTSTR lpFileName,
    IN DWORD nUsers,
    IN PENCRYPTION_CERTIFICATE_HASH * pHashes
    )

/*++

Routine Description:

    This routine will remove the passed users from the list
    of people who can decrypt the passed file.

    The file will not be modified at all if any errors occur
    during processing.

Arguments:

    lpFileName - Supplies a pointer to the file to be edited.  This file
        will be opened for exclusive access.

    nHashes - Supplies the number of hashes in the pHashes array.

    pHashes - Supplies an array of pointers to hash structures for subjects to be
        removed from the file.


Return Value:

    This function will fail if:

    The passed file is not encrypted.

    The user does not have sufficient access to the file.

--*/
{
    PEFS_DATA_STREAM_HEADER UpdatedEfs = NULL;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream = NULL;
    DWORD rc                           = ERROR_SUCCESS;
    PEFS_KEY Fek                       = NULL;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                lpFileName,
                FILE_READ_ATTRIBUTES| FILE_WRITE_DATA,
                0,
                NULL,
                OPEN_EXISTING,
                Flags,
                NULL
                );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            rc = DecryptFek( pEfsUserInfo, pEfsStream, &Fek, &UpdatedEfs, 0 );

            if (ERROR_SUCCESS == rc) {

                //
                // If we got an EFS stream back, toss the
                // one from the file and use it.
                //

                if ( UpdatedEfs != NULL ) {
                    LsapFreeLsaHeap( pEfsStream );
                    pEfsStream = UpdatedEfs;
                    UpdatedEfs = NULL;
                }

                if (RemoveUsersFromEfsStream(
                        pEfsStream,
                        nUsers,
                        pHashes,
                        Fek,
                        &UpdatedEfs
                        )) {

                    //
                    // If we got an EFS stream back, toss the old EFS
                    // stream and pick up the new one.  We'll only get
                    // an EFS stream back if we found someone to remove.
                    //

                    if (UpdatedEfs != NULL) {

                        LsapFreeLsaHeap( pEfsStream );
                        pEfsStream = UpdatedEfs;
                        UpdatedEfs = NULL;

                        if (!EfspSetEfsOnFile( hFile, pEfsStream, NULL )) {
                            rc = GetLastError();
                        }
                    }

                } else {

                    rc = GetLastError();
                }

                if (UpdatedEfs != NULL) {
                    LsapFreeLsaHeap( UpdatedEfs );
                }

                LsapFreeLsaHeap( Fek );
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    return( rc );
}


DWORD
SetFileEncryptionKeySrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{
    DWORD rc = ERROR_SUCCESS;
    PBYTE      pbHash = NULL;
    DWORD      cbHash;


    //
    // Get the current cert hash
    //

    (void) GetCurrentHash(
            pEfsUserInfo,
            &pbHash,
            &cbHash
            );

    //
    // If no certificate was passed, call the code to create
    // a new user key from scratch.
    //

    if (!ARGUMENT_PRESENT( pEncryptionCertificate )) {

        //
        // Create a new key
        //

        rc = EfspReplaceUserKeyInformation( pEfsUserInfo );

    } else {

        __try{

            if ( pEncryptionCertificate->pCertBlob ){
                rc = EfspInstallCertAsUserKey( pEfsUserInfo, pEncryptionCertificate );
            } else {
                rc = ERROR_INVALID_PARAMETER;
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            rc = ERROR_INVALID_PARAMETER;

        }

    }

    if ( (ERROR_SUCCESS == rc) && pbHash) {

        //
        // Operation succeeded and there was a current key. Make our best effort
        // to mark the old cert as archived.
        //

        PCCERT_CONTEXT pCertContext;

        pCertContext = GetCertContextFromCertHash(
                            pbHash,
                            cbHash,
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG | CERT_SYSTEM_STORE_CURRENT_USER
                            );

        if (pCertContext != NULL) {

            CRYPT_DATA_BLOB dataBlob = {0, NULL};

            //
            // This is best effort. We do not need to check the return code.
            //

            (void) CertSetCertificateContextProperty(
                        pCertContext,
                        CERT_ARCHIVED_PROP_ID,
                        0,
                        &dataBlob
                        );


            CertFreeCertificateContext( pCertContext );

        }
    }

    if (pbHash) {
        LsapFreeLsaHeap(pbHash);
    }



    return( rc );
}

DWORD
DuplicateEncryptionInfoFileSrv (
    PEFS_USER_INFO pEfsUserInfo,
    LPCWSTR lpSrcFileName,
    LPCWSTR lpDestFileName,
    LPCWSTR lpDestUncName,
    DWORD   dwCreationDistribution,
    DWORD   dwAttributes,
    PEFS_RPC_BLOB pRelativeSD,
    BOOL    bInheritHandle
    )
/*++

Routine Description:

    This routine will transfer the EFS information from the source file
    to the target file.  It assumes

    The caller has FILE_READ_ATTRIBUTES access to the source file

    The caller has WRITE_ATTRIBUTE and WRITE_DATA access to the target.  If the target
    is encrypted, the caller must be able to decrypt it.

Arguments:

    pEfsUserInfo - Supplies the user info structure for the current caller.

    lpSrcFileName - Supplies a pointer to the name of the source file.

    lpDestFileName - Supplies a pointer to the name of the destination file.

    dwCreationDistribution - CreationDistribution used in CreateFile.

    dwAttributes - File attributes used in CreateFile.

    pRelativeSD - Relative Security Descriptor.

    BOOL - bInheritHandle.

Return Value:

    Win32 error.

--*/

{
    //
    // Get the encryption information off of the src file.
    //

    HANDLE hSrcFile;
    HANDLE hDestFile;
    DWORD rc = ERROR_SUCCESS;
    BOOLEAN fResult = FALSE;
    PEFS_KEY Fek;

    DWORD                FileAttributes;
    DWORD                FileAttributesDst;
    DWORD                FlagsSrc = 0;
    DWORD                creationDistribution = 0;

    FileAttributes = GetFileAttributes( lpSrcFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       FlagsSrc = FILE_FLAG_BACKUP_SEMANTICS;
    }

    //
    // Try to open the file.
    //

    hSrcFile =  CreateFile(
                    lpSrcFileName,
                    FILE_READ_ATTRIBUTES,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FlagsSrc,
                    NULL
                    );

    if (hSrcFile != INVALID_HANDLE_VALUE) {

        NTSTATUS Status;
        PEFS_DATA_STREAM_HEADER pEfsStream;

        Status = GetFileEfsStream(
                     hSrcFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            PEFS_DATA_STREAM_HEADER NewEfs = NULL;
            GUID NewId;

            //
            // We need to change the file ID here. DecryptFek will recalculate
            // the checksum for us.
            //

            RPC_STATUS RpcStatus = UuidCreate ( &NewId );

            if (RpcStatus == ERROR_SUCCESS || RpcStatus == RPC_S_UUID_LOCAL_ONLY) {
                RtlCopyMemory( &(pEfsStream->EfsId), &NewId, sizeof( GUID ) );
            }

            rc = DecryptFek(
                     pEfsUserInfo,
                     pEfsStream,
                     &Fek,
                     &NewEfs,
                     0
                     );

            if (rc == ERROR_SUCCESS) {

                //
                // Got the $EFS, now prepares to create destination
                //

                FileAttributesDst =  GetFileAttributes( lpDestFileName );
                if (FileAttributesDst == -1) {

                    rc = GetLastError();

                    FileAttributesDst = 0;

                    if ((ERROR_FILE_NOT_FOUND == rc) || (ERROR_PATH_NOT_FOUND == rc)) {
                        rc = ERROR_SUCCESS;
                        if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                            creationDistribution = FILE_CREATE;

                            //
                            // Force the new destination to be a directory
                            //

                            dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                        }
                    }

                } else {

                    //
                    // File exist. Check if Dir to Dir or File to File
                    //

                    if (dwCreationDistribution == CREATE_NEW) {

                        //
                        // The file is already existed. CREATE_NEW will fail.
                        //

                        rc = ERROR_FILE_EXISTS;

                    } else if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY){

                        if (!(FileAttributesDst & FILE_ATTRIBUTE_DIRECTORY)) {

                            rc =  ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;

                        } else {

                            if (FileAttributesDst & FILE_ATTRIBUTE_ENCRYPTED) {
                                creationDistribution = FILE_OPEN;
                            }

                        }
                    } else {

                        if (FileAttributesDst & FILE_ATTRIBUTE_DIRECTORY) {

                          rc =  ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;

                        }

                    }

                }


                //
                // Now we can Create/open the destination.
                // We have not validate the share access yet. We will use the UNC name
                // to validate if it is a network session.
                //

                OBJECT_ATTRIBUTES        Obja;
                UNICODE_STRING           DstNtName;
                LPWSTR                   DstFileName = NULL;
                LPWSTR                   LongFileName = NULL;
                DWORD                    FileNameLength;
                BOOL                     b = TRUE;
                ULONG                    CreateOptions = 0;
                IO_STATUS_BLOCK          IoStatusBlock;

                RtlInitUnicodeString(
                    &DstNtName,
                    NULL
                    );

                if (rc == ERROR_SUCCESS) {

                    if (lpDestUncName) {


                        if ( (FileNameLength = wcslen(lpDestUncName)) >= MAX_PATH ) {

                            //
                            // We need \\?\UNC\server\share\dir\file format to open the file.
                            //

                            DstFileName = LongFileName = (LPWSTR)LsapAllocateLsaHeap( (FileNameLength + 8) * sizeof (WCHAR) );
                            if (!LongFileName) {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            } else {

                                wcscpy(LongFileName, L"\\\\?\\UNC");
                                wcscat(LongFileName, &lpDestUncName[1]);

                            }

                        } else {

                            DstFileName = (LPWSTR) lpDestUncName;

                        }

                    } else {

                       DstFileName = (LPWSTR) lpDestFileName;

                    }

                }


                if ( rc != ERROR_SUCCESS ) {

                    if (NewEfs) {
                        LsapFreeLsaHeap( NewEfs );
                    }
                    LsapFreeLsaHeap( Fek );
                    LsapFreeLsaHeap( pEfsStream );
                    CloseHandle( hSrcFile );
                    return rc;

                }

                b =  RtlDosPathNameToNtPathName_U(
                                    DstFileName,
                                    &DstNtName,
                                    NULL,
                                    NULL
                                    );

                if ( b ){

                    if (!creationDistribution) {
                        creationDistribution = (dwCreationDistribution == CREATE_NEW) ? FILE_CREATE : FILE_OVERWRITE_IF;
                    }

                    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        CreateOptions = FILE_DIRECTORY_FILE;
                    } else {

                        //
                        // NTFS does not support FILE_NO_COPRESSION for the dir.
                        //

                        CreateOptions |= FILE_NO_COMPRESSION;
                    }


                    //
                    // Encryption bit is not needed. We will encrypt it any way.
                    //

                    dwAttributes &= ~(FILE_ATTRIBUTE_ENCRYPTED | FILE_ATTRIBUTE_READONLY);

                    InitializeObjectAttributes(
                                &Obja,
                                &DstNtName,
                                bInheritHandle ? OBJ_INHERIT | OBJ_CASE_INSENSITIVE : OBJ_CASE_INSENSITIVE,
                                0,
                                pRelativeSD? pRelativeSD->pbData:NULL
                                );

                    Status = NtCreateFile(
                                    &hDestFile,
                                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    dwAttributes,
                                    0,
                                    creationDistribution,
                                    CreateOptions | FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0
                                    );

                    if ( NT_SUCCESS(Status) && lpDestUncName ) {

                        //
                        // If this is a net session, we need to close the loopback handle.
                        // This handle is not good to send large FSCTL request.
                        // In this case, the file should already exist or overwritten.
                        // No parameters for create new file are needed, such as SD.
                        //

                        RtlFreeHeap(
                            RtlProcessHeap(),
                            0,
                            DstNtName.Buffer
                            );

                        RtlInitUnicodeString(
                            &DstNtName,
                            NULL
                            );

                        CloseHandle( hDestFile );

                        Status = STATUS_NO_SUCH_FILE;

                        b =  RtlDosPathNameToNtPathName_U(
                                            lpDestFileName,
                                            &DstNtName,
                                            NULL,
                                            NULL
                                            );

                        if ( b ){

                            InitializeObjectAttributes(
                                        &Obja,
                                        &DstNtName,
                                        bInheritHandle ? OBJ_INHERIT | OBJ_CASE_INSENSITIVE : OBJ_CASE_INSENSITIVE,
                                        0,
                                        NULL
                                        );

                            Status = NtCreateFile(
                                            &hDestFile,
                                            FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            dwAttributes,
                                            0,
                                            FILE_OPEN,
                                            CreateOptions | FILE_SYNCHRONOUS_IO_NONALERT,
                                            NULL,
                                            0
                                            );
                        }

                    }

                    if (NT_SUCCESS(Status)) {

                        //
                        // Work around for FILE_NO_COMPRESSION
                        //

                        if ((FileAttributesDst & FILE_ATTRIBUTE_COMPRESSED) || ((dwCreationDistribution == CREATE_NEW) && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY))) {

                            //
                            // Let's decompressed the dir
                            //

                            USHORT State = COMPRESSION_FORMAT_NONE;
                            ULONG Length;

                            //
                            // Attempt to uncompress the directory. Best effort. If it fails, we still continue.
                            //

                            b = DeviceIoControl(
                                                hDestFile,
                                                FSCTL_SET_COMPRESSION,
                                                &State,
                                                sizeof(USHORT),
                                                NULL,
                                                0,
                                                &Length,
                                                FALSE
                                                );

                        }

                        if (!EfspSetEfsOnFile( hDestFile, NewEfs? NewEfs : pEfsStream, Fek )) {

                            rc = GetLastError();
                            if ( ERROR_INVALID_FUNCTION == rc ) {

                                //
                                // lpDestFileName is a local path. Change it to be a volume name.
                                //

                                DWORD FileSystemFlags;
                                WCHAR RootDirName[4];

                                wcsncpy(RootDirName, lpDestFileName, 3);
                                RootDirName[3] = 0;
                                if(GetVolumeInformation(
                                    RootDirName,
                                    NULL, // Volume name.
                                    0, // Volume name length.
                                    NULL, // Serial number.
                                    NULL, // Maximum length.
                                    &FileSystemFlags,
                                    NULL, // File system type.
                                    0
                                    )){

                                    if (!(FileSystemFlags & FILE_SUPPORTS_ENCRYPTION)) {

                                        //
                                        //  Let's map the error.
                                        //

                                        rc = ERROR_VOLUME_NOT_SUPPORT_EFS;
                                        if (dwCreationDistribution == CREATE_NEW) {
                                            CloseHandle( hDestFile );
                                            hDestFile = 0;
                                            DeleteFileW(lpDestFileName);
                                        }


                                    }

                                }

                            }
                        }

                        if (hDestFile) {
                            CloseHandle( hDestFile );
                        }

                    } else {

                        rc = RtlNtStatusToDosError( Status );

                    }
                } else {

                    rc = GetLastError();

                }

                if (DstNtName.Buffer) {
                    RtlFreeHeap(
                        RtlProcessHeap(),
                        0,
                        DstNtName.Buffer
                        );
                }

                if (LongFileName) {
                    LsapFreeLsaHeap( LongFileName );
                }

                if (NewEfs) {
                    LsapFreeLsaHeap( NewEfs );
                }
                LsapFreeLsaHeap( Fek );
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hSrcFile );

    } else {

        rc = GetLastError();
    }

    return( rc );
}

VOID
EfsLogEntry (
    WORD    wType,
    WORD    wCategory,
    DWORD   dwEventID,
    WORD    wNumStrings,
    DWORD   dwDataSize,
    LPCTSTR *lpStrings,
    LPVOID  lpRawData
    )
/*++
Routine Description:

    This routine wraps the call to ReportEvent.
Arguments:

    See info for ReportEvent.

Return Value:

    None.
--*/
{

    HANDLE EventHandleLog;

    EventHandleLog = RegisterEventSource(
                             NULL,
                             EFSSOURCE
                             );

    if ( EventHandleLog ){

       ReportEvent(
           EventHandleLog,
           wType,
           wCategory,
           dwEventID,
           NULL,
           wNumStrings,
           dwDataSize,
           lpStrings,
           lpRawData
           );
       DeregisterEventSource( EventHandleLog );
    }
}


DWORD
EfsFileKeyInfoSrv(
    IN  LPCWSTR lpFileName,
    IN  DWORD   InfoClass,
    OUT PDWORD  nbData,
    OUT PBYTE   *pbData
    )
/*++

Routine Description:

    This routine gets the internal info about the encryption used on the file.

Arguments:

    lpFileName - File name.

    nbData - Length of pbData returned.

    pbData - Info returned

Return Value:

    Win32 error.

--*/
{
    PEFS_KEY Fek = NULL;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream = NULL;
    NTSTATUS Status;
    DWORD rc = ERROR_SUCCESS;
    DWORD  FileAttributes;
    DWORD  Flags = 0;

    EFS_USER_INFO EfsUserInfo;
    PEFS_KEY_INFO pKeyInfo;

    *nbData = 0;
    *pbData = NULL;

    if (InfoClass != BASIC_KEY_INFO) {
        return ERROR_INVALID_PARAMETER;
    }
    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if ((FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) == 0) {
        return ERROR_FILE_NOT_ENCRYPTED;
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );
    if (hFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }


    Status = GetFileEfsStream(
                 hFile,
                 &pEfsStream
                 );
    CloseHandle(hFile);

    if (NT_SUCCESS( Status )){
        if (EfspGetUserInfo( &EfsUserInfo )) {

            HANDLE hToken;
            HANDLE hProfile;

            if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

                rc = EfsGetFek(
                        &EfsUserInfo,
                        pEfsStream,
                        &Fek
                        );

                if (ERROR_SUCCESS == rc) {
                    pKeyInfo = (PEFS_KEY_INFO) MIDL_user_allocate( sizeof(EFS_KEY_INFO) );
                    pKeyInfo->dwVersion = 1;
                    pKeyInfo->Entropy = Fek->Entropy;
                    pKeyInfo->Algorithm = Fek->Algorithm;
                    pKeyInfo->KeyLength = Fek->KeyLength;
                    *pbData = (PBYTE) pKeyInfo;
                    *nbData = sizeof(EFS_KEY_INFO);
                    LsapFreeLsaHeap( Fek );

                }

                EfspUnloadUserProfile( hToken, hProfile );

            }
            EfspFreeUserInfo( &EfsUserInfo );
        }
    } else {
        rc = RtlNtStatusToDosError( Status );
    }
    LsapFreeLsaHeap( pEfsStream );

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <dsysdbg.h>

// The following Debug Flags can be turned on to trace different areas to
// trace while executing.  Feel free to add more levels.

#define DEB_TRACE_VERB      0x00000008  // Verbose tracing (parameter dumps)
#define DEB_TRACE_WAPI      0x00000010  // Trace Worker APIs
#define DEB_TRACE_HELPERS   0x00000020  // Trace SPHelp functions
#define DEB_TRACE_RM        0x00000040  // Trace Reference Monitor stuff
#define DEB_TRACE_INIT      0x00000080  // Trace initialization msgs
#define DEB_TRACE_SCAV      0x00000100  // Trace scavenger operations
#define DEB_TRACE_CRED      0x00000200  // Trace supp. credentials
#define DEB_TRACE_LSA_AU    0x00000400  // Trace LSA AU functions
#define DEB_TRACE_LPC       0x00000800  // Trace LPC stuff
#define DEB_TRACE_NEG       0x00001000  // Trace Negotiate functions
#define DEB_TRACE_SAM       0x00002000  // Trace SAM hooks
#define DEB_TRACE_LSA       0x00004000  // Trace LSA support for DS
#define DEB_TRACE_SPECIAL   0x00008000  // Trace Special stuff
#define DEB_TRACE_QUEUE     0x00010000  // Trace queue and tasks
#define DEB_TRACE_HANDLES   0x00020000  // Trace handle code
#define DEB_TRACE_NEG_LOCKS 0x00040000  // Trace negotiate locks
#define DEB_TRACE_AUDIT     0x00080000  // Trace audit activity
#define DEB_TRACE_EFS       0x00100000  // Trace EFS functions
#define DEB_LOG_ONLY        0x80000000  // Do not log this to the debugger
#define DEB_BREAK_ON_ERROR  0x40000000  // BreakOnError macro enabled (see below)

// The following flags control when the SPM will raise breakpoints for
// debugging through a remote debugger.  Setting these bits on and enabling
// DEB_BREAK_ON_ERROR will cause a breakpoint at the following conditions

#define BREAK_ON_BEGIN_INIT 0x01    // Break point at beginning of init
#define BREAK_ON_BEGIN_END  0x02    // Break point at complete of init
#define BREAK_ON_P_CONNECT  0x04    // Break at process connect
#define BREAK_ON_SP_EXCEPT  0x08    // Break if a package causes an exception
#define BREAK_ON_PROBLEM    0x10    // Break if a serious problem occurs
#define BREAK_ON_SHUTDOWN   0x20    // Break on beginning of shutdown
#define BREAK_ON_LOAD       0x40    // Break when a package is loaded


//
// Negotiation specific debugging
//

#define DEB_TRACE_LOCKS     0x00000010

#if DBG

// Debugging support prototypes:

void    InitDebugSupport(void);
void    LogEvent(long, const char *, ...);

extern SECPKG_FUNCTION_TABLE   DbgTable;

DECLARE_DEBUG2(SPM);
DECLARE_DEBUG2(Neg);

extern  DWORD   BreakFlags;         // Breakpoints

#define DebugLog(x) SPMDebugPrint x
#define DebugLogEx(x) SPMDebugPrint x
#define NegDebugLog(x)  NegDebugPrint x
#define DebugStmt(x)    x
#define BreakOnError(x) \
            if ((x & BreakFlags) && \
                (SPMInfoLevel & DEB_BREAK_ON_ERROR)) \
                { \
                    DebugLog((DEB_BREAK_ON_ERROR, "Breakpoint requested\n" )); \
                    DbgUserBreakPoint(); \
                }

#define ASSERT_CONTINUE 0
#define ASSERT_BREAK    1
#define ASSERT_SUSPEND  2
#define ASSERT_KILL     3
#define ASSERT_PROMPT   4
#define ASSERT_DEBUGGER 5


#define SpmAssertEx( exp , ContinueCode ) \
            DsysAssertEx( exp, ContinueCode )

#define SpmAssertMsgEx( Msg, exp, ContinueCode ) \
            DsysAssertMsgEx( exp, Msg, ContinueCode )

#define SpmAssert(exp)          SpmAssertEx(exp, ASSERT_DEBUGGER)
#define SpmAssertMsg(Msg, exp)  SpmAssertMsgEx(Msg, exp, ASSERT_DEBUGGER )
#define SpmpThreadStartup()     SpmpThreadStartupEx()
#define SpmpThreadExit()        SpmpThreadExitEx()

void
SpmpThreadStartupEx(void);

void
SpmpThreadExitEx(void);



#else   // Not DBG

#define DebugLog(x)

#define NegDebugLog(x) 

#ifdef DBG_ERRORS
void ExLogEvent(long, const char *, ...);
#define DebugLogEx(x)   ExLogEvent x
#else
#define DebugLogEx(x)
#endif

#define DebugStmt(x)

#define BreakOnError(x)

#define SpmAssertEx(exp, ContinueCode)

#define SpmAssert(exp)

#define SpmAssertMsg(Msg, exp)

#define SpmAssertMsgEx(Msg, exp, ContinueCode)
#define SpmpThreadStartup()
#define SpmpThreadExit()

#endif


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\efsrpc_s_stub.c ===
#include "efsrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\efsinit.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efsinit.cxx

Abstract:

    EFS (Encrypting File System) Server

Author:

    Robert Reichel      (RobertRe)     July 4, 1997
    Robert Gu           (RobertGu)     Jan 7, 1998

Environment:

Revision History:

--*/
#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <efsstruc.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
#include <cfgmgr32.h>
#include <initguid.h>
#include <mountmgr.h>
#include <Userenv.h>
}

#define  TIME_UNIT 10000000         // 1 TIME_UNIT == 1 second
#define  CERT_VALID_TIME 86400 // seconds - Default cache length 1 day

//
// Local prototypes of CFGMGR32 functions for dynamic load
//

typedef CMAPI CONFIGRET (WINAPI *
    CM_GET_DEVICE_INTERFACE_LISTW)(
        IN LPGUID,
        IN DEVINSTID_W,
        OUT PWCHAR,
        IN ULONG,
        IN ULONG );

typedef CMAPI CONFIGRET (WINAPI *
    CM_GET_DEVICE_INTERFACE_LIST_SIZEW)(
        IN PULONG,
        IN LPGUID,
        IN DEVINSTID_W,
        IN ULONG
        );

typedef CONFIGRET ( * CMP_WAITSERVICESAVAILABLE)(
        IN HMACHINE
        );


//
// Extern Vars
//

extern RTL_RESOURCE RecoveryPolicyResource;
extern CURRENT_RECOVERY_POLICY CurrentRecoveryPolicy;
extern "C" BOOLEAN EfsDisabled;


//
//  Event handle used to sync with the driver
//

HANDLE EfsInitEventHandle = 0;

//
// Efs event handle to get policy change notification
//

HANDLE EfsPolicyEventHandle = 0;
HANDLE EfsWaitHandle = 0;
EFS_POL_CALLBACK EfsPolCallBack;

BOOLEAN EfsServerInitialized = FALSE;
extern "C" BOOLEAN EfsPersonalVer = TRUE;

BOOLEAN EfspInDomain = FALSE;

//
// Cache values
//

HCRYPTPROV hProvVerify = 0;

WCHAR EfsComputerName[MAX_COMPUTERNAME_LENGTH + 1];
LIST_ENTRY UserCacheList;
RTL_CRITICAL_SECTION GuardCacheListLock;
LONG UserCacheListLimit = 5; // We might read this number from the registry in the future
LONG UserCacheListCount = 0;

LONGLONG CACHE_CERT_VALID_TIME;
LONG RecoveryCertIsValidating = 0;

static PSID LocalSystemSid;

DWORD
InitRecoveryPolicy(
    VOID
    );

DWORD
SetDefaultRecoveryPolicy(
    VOID
    );

DWORD
ParseRecoveryPolicy_1_1(
    IN  PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo OPTIONAL,
    OUT PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    );

VOID
EfsGetRegSettings(
    VOID
    );

NTSTATUS
EfsServerInit(
    VOID
    )
/*++

Routine Description:

    This routine is called during server initialization to allow
    EFS to initialize its data structures and inform the EFS Driver
    that it's up and running.

Arguments:

    None.

Return Value:

    None.

--*/

{

    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    UNICODE_STRING EfsInitEventName;
    OSVERSIONINFOEX Osvi;
    DWORD Result;
    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;

    CACHE_CERT_VALID_TIME = (LONGLONG) CERT_VALID_TIME;
    CACHE_CERT_VALID_TIME *= (LONGLONG) TIME_UNIT; 

    if ( !GetComputerName ( EfsComputerName, &nSize )){

        KdPrint(("EfsServerInit - GetComputerName failed 0x%lx\n", GetLastError()));
        return STATUS_UNSUCCESSFUL;

    }

    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO)&Osvi)){

        if ((Osvi.wProductType == VER_NT_WORKSTATION) && ( Osvi.wSuiteMask & VER_SUITE_PERSONAL)) {

            EfsPersonalVer = TRUE;
            return STATUS_UNSUCCESSFUL;

        } else {
            EfsPersonalVer = FALSE;
        }

    } else {

        //
        // Treat as personal
        //

        EfsPersonalVer = TRUE;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Init the cache list
    //

    InitializeListHead(&UserCacheList);
    Status = RtlInitializeCriticalSection(&GuardCacheListLock);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    EfsGetRegSettings();

    Status = InitDriverSessionKey();
    if (!NT_SUCCESS(Status)) {

        KdPrint(("EfsServerInit - EFS Init Session Key failed 0x%lx\n", Status));
        return( Status );

    }

    DebugLog((DEB_TRACE_EFS, "In EfsServerInit\n"   ));

    //
    // Zero out the initial recovery policy structure
    //

    Result = ParseRecoveryPolicy_1_1(
                 NULL,
                 &CurrentRecoveryPolicy
                 );

    //
    // Determine if we're in a domain or not.  This must be done
    // before checking the recovery policy.
    //

    EfspRoleChangeCallback( (POLICY_NOTIFICATION_INFORMATION_CLASS)NULL );

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                 &EfspRoleChangeCallback,
                 PolicyNotifyDnsDomainInformation
                 );

    //
    // Try to get the current recovery policy.
    //

    __try
    {
        RtlInitializeResource( &RecoveryPolicyResource );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if ( !NT_SUCCESS( Status ) ) {
        return Status ;
    }

    Result = InitRecoveryPolicy();

    if (ERROR_SUCCESS != Result) {

        //
        // We couldn't initialize our recovery policy.  Continue to
        // initialize the server so that the driver can proceed.
        //

        DebugLog((DEB_ERROR, "EfsServerInit - EFS Init Recovery Policy failed 0x%lx\n\n" ,Result  ));
    }

    //
    // Try to establish connection with the driver.
    // Normally, the driver has not been loaded yet. Create
    // an event and wait for the driver. If the event already
    // exists, signal it.
    //

    RtlInitUnicodeString( &EfsInitEventName, L"\\EFSInitEvent" );

    InitializeObjectAttributes(
        &ObjA,
        &EfsInitEventName,
        0,
        NULL,
        NULL
        );

    Status = NtCreateEvent(
                 &EfsInitEventHandle,
                 EVENT_MODIFY_STATE,
                 &ObjA,
                 NotificationEvent,
                 FALSE
                 );

    if (!NT_SUCCESS(Status)) {

        if (STATUS_OBJECT_NAME_COLLISION == Status) {

            //
            // EFS driver has been loaded.
            // Open and signal the event. Event handle will be closed
            // in GenerateDriverSessionKey()
            //

            Status = NtOpenEvent(
                         &EfsInitEventHandle,
                         EVENT_MODIFY_STATE,
                         &ObjA
                         );

            //
            // If the EFS Init event could not be opened, the EFS Server cannot
            // synchronize with the EFS Driver so neither component will
            // function correctly.
            //

            if (!NT_SUCCESS(Status)) {

                KdPrint(("EfsServerInit - Connection with the driver failed 0x%lx\n",Status));
                return( Status );

            }

            //
            // Signal the EFS Init Event.  If the signalling fails, the EFS Server
            // is not able to synchronize properly with the EFS Driver.
            // This is a serious error which prevents both components from
            // functioning correctly.
            //

            Status = NtSetEvent( EfsInitEventHandle, NULL );

            if (!NT_SUCCESS(Status)) {

                KdPrint(("EfsServerInit - Init Event Set failed 0x%lx\n",Status));
                return( Status );
            }

        } else {

            //
            //  Other unexpected error
            //

            KdPrint(("EfsServerInit - Event handling failed 0x%lx\n",Status));
            return( Status );

        }
    }

    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 );

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                 &RecoveryInformationCallback,
                 PolicyNotifyDomainEfsInformation
                 );

    //
    // Check EFS disable policy if a DC member
    //

    if (EfspInDomain) {

        //
        // Only do this if in the domain
        //

        EfsPolicyEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (EfsPolicyEventHandle) {

            HANDLE waitHandle;


            EfsPolCallBack.EfsDisable = &EfsDisabled;
            EfsPolCallBack.EfsPolicyEventHandle = &EfsPolicyEventHandle;

            //
            // We got the event handle. Let's register it to the GP notification.
            // If we can't wait on it, we don't need to register it.
            //

            if (RegisterGPNotification(EfsPolicyEventHandle, TRUE)){
                if (!NT_SUCCESS(RtlRegisterWait(
                                    &EfsWaitHandle,
                                    EfsPolicyEventHandle, 
                                    EfsGetPolRegSettings, 
                                    &EfsPolCallBack, 
                                    INFINITE, 
                                    WT_EXECUTEONLYONCE))){
            
                    //
                    //  We couldn't use the thread pool. 
                    //
    
                    UnregisterGPNotification(EfsPolicyEventHandle);

                    CloseHandle(EfsPolicyEventHandle);
                    EfsPolicyEventHandle = 0;
    
                }
            } else {
                //
                // We failed to register. No need to wait for the notification.
                //

                //RtlDeregisterWait(EfsWaitHandle);
                CloseHandle(EfsPolicyEventHandle);
                EfsPolicyEventHandle = 0;

            }
            

        }

        //
        //  Now let's read the policy data left by the last session.
        //  Pass in &EfsDisabled so that later we could easily change this to
        //  include more features, such as algorithms controlled by the policy.
        //

        EfsApplyLastPolicy(&EfsDisabled);


    } else {

        //
        // Delete the possible left over key if there is. We may move this to
        // DC disjoin later.
        //

        EfsRemoveKey();

    }
    

    EfsServerInitialized  =  TRUE;

    if (NT_SUCCESS( Status )) {
        DebugLog((DEB_TRACE_EFS, "EFS Server initialized successfully\n"   ));
    } else {
        DebugLog((DEB_ERROR, "EFS Server Init failed, Status = %x\n" ,Status  ));
    }

    return( Status );
}

NTSTATUS
InitDriverSessionKey(
    VOID
    )
/*++

Routine Description:

    Generates a session key to be used by the driver and the server
    for sending information back and forth securely.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS on success, STATUS_UNSUCCESSFUL otherwise.

--*/
{
    BOOL rc;

    //
    // hProvVerify will remain open until the process is shut down.
    // CryptReleaseContext(hProvVerify, 0) will not be called for this handle.
    //
    //

    if (!CryptAcquireContext(&hProvVerify, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {

        KdPrint(("InitDriverSessionKey - CryptAcquireContext failed, error = %x\n", GetLastError()));
        return( STATUS_UNSUCCESSFUL );

    }

    rc = CryptGenRandom( hProvVerify, SESSION_KEY_SIZE, DriverSessionKey );

    if (!rc) {
        return( STATUS_UNSUCCESSFUL );
    } else {

        LsaPid = (HANDLE) LongToPtr(GetCurrentProcessId());

        deskey( &DesTable, DriverSessionKey );

        return( STATUS_SUCCESS );
    }
}

NTSTATUS
GenerateDriverSessionKey(
    OUT PEFS_INIT_DATAEXG InitDataExg
    )
/*++

Routine Description:

    Actually it just sends the pre-created session key back to the
    caller. The key is generated in InitDriverSessionKey.

Arguments:

    InitDataExg - Supplies a pointer to a structure in which to put
        the initial data to be sent to the driver.

Return Value:

    STATUS_SUCCESS.

--*/

{
    memcpy( InitDataExg->Key, DriverSessionKey, SESSION_KEY_SIZE );
    InitDataExg->LsaProcessID = LsaPid;

    if ( EfsInitEventHandle ){

        //
        // Connection to driver established
        //

        NtClose( EfsInitEventHandle );
        EfsInitEventHandle = 0;

    }

    return( STATUS_SUCCESS );
}

inline
VOID
AcquireRecoveryPolicyWriteLock()
{
    BOOL b = RtlAcquireResourceExclusive( &RecoveryPolicyResource, TRUE );

    ASSERT( b );
}

inline
VOID
ReleaseRecoveryPolicyWriteLock()
{
    RtlReleaseResource( &RecoveryPolicyResource );
}


DWORD
InitRecoveryPolicy(
    VOID
    )

/*++

Routine Description:

    This routine is used to initialize the current recovery policy.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    // Attempt to query the recovery policy
    // from LSA, and if there isn't any,
    // attempt to create a default set.
    //

    DWORD Result = ERROR_SUCCESS;
    PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo = NULL;

    NTSTATUS Status = LsarQueryDomainInformationPolicy(
                          LsapPolicyHandle,
                          PolicyDomainEfsInformation,
                          (PLSAPR_POLICY_DOMAIN_INFORMATION *)&PolicyEfsInfo
                          );

    if (!NT_SUCCESS( Status )) {
        return( RtlNtStatusToDosError(Status) );
    }

    //
    // We're going to parse it right into the global that maintains
    // the current recovery data, so take the write lock.
    //

    AcquireRecoveryPolicyWriteLock();

    //
    // Free the old parsed recovery bits
    //

    FreeParsedRecoveryPolicy( &CurrentRecoveryPolicy );

    Result = ParseRecoveryPolicy_1_1( PolicyEfsInfo, &CurrentRecoveryPolicy );

    if (PolicyEfsInfo != NULL) {

        LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
            PolicyDomainEfsInformation,
            (PLSAPR_POLICY_DOMAIN_INFORMATION)PolicyEfsInfo
            );
    }

    ReleaseRecoveryPolicyWriteLock();

    return( Result );
}


DWORD
ParseRecoveryPolicy_1_1(
    IN  PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo OPTIONAL,
    OUT PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    )

/*++

Routine Description:

    This routine takes the currently defined recovery policy and parses
    it into a form that can be used conveniently.

Arguments:

    PolicyEfsInfo - Optionally supplies a pointer to the current
        recovery policy from the LSA.

    ParsedRecoveryPolicy - Returns a structure containing recovery information
        in an easy-to-digest format.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    //
    // Fill in the contents of the ParsedRecoveryPolicy structure
    // with the contents of the passed policy information.
    //

    PRECOVERY_POLICY_1_1 RecoveryPolicy;
    DWORD Found = 0;
    PRECOVERY_KEY_1_1 RecoveryKey;
    DWORD rc = ERROR_SUCCESS;
    BOOL b = FALSE;

    if (PolicyEfsInfo == NULL) {

        //
        // NULL recovery policy
        //

        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_NULL;
        goto NoPolicy1;
    }

    RecoveryPolicy = (PRECOVERY_POLICY_1_1)PolicyEfsInfo->EfsBlob;

    if (RecoveryPolicy == NULL) {

        //
        // Empty recovery policy
        //

        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_EMPTY;
        goto NoPolicy1;
    }

    ParsedRecoveryPolicy->dwKeyCount = RecoveryPolicy->RecoveryPolicyHeader.RecoveryKeyCount;

    if (ParsedRecoveryPolicy->dwKeyCount == 0) {
        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_NO_AGENT;
        goto NoPolicy1;
    }


    __try {

        //
        // Scan the recovery data looking for recovery keys in a format we understand
        //

        ULONG i;
        RecoveryKey = (PRECOVERY_KEY_1_1) &(RecoveryPolicy->RecoveryKeyList[0]);

        for (i=0 ; i< (ParsedRecoveryPolicy->dwKeyCount) ; i++) {

            PEFS_PUBLIC_KEY_INFO PublicKeyInfo = &RecoveryKey->PublicKeyInfo;

            if (* ((ULONG UNALIGNED *) &(PublicKeyInfo->KeySourceTag)) == EfsCertificate) {
                Found++;
            }

            RecoveryKey = (PRECOVERY_KEY_1_1)( ((PBYTE)RecoveryKey) + * ((ULONG UNALIGNED *) &(RecoveryKey->TotalLength)) );
        }

        if (0 == Found) {

            ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_BAD_POLICY;
            goto NoPolicy1;

        } else {

            ParsedRecoveryPolicy->Base = (PBYTE)LsapAllocateLsaHeap( 7 * sizeof( PVOID ) * Found );

            if (ParsedRecoveryPolicy->Base) {

                ZeroMemory( ParsedRecoveryPolicy->Base, 7 * sizeof( PVOID ) * Found);

                PBYTE Base = ParsedRecoveryPolicy->Base;

                ParsedRecoveryPolicy->pbHash = (PBYTE *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->cbHash = (PDWORD)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->pbPublicKeys = (PBYTE *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->cbPublicKeys = (PDWORD)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->lpDisplayInfo = (LPWSTR *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->pCertContext = (PCCERT_CONTEXT *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->pSid = (PSID *)Base;
            } else {

                ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_NO_MEMORY;
                return( ERROR_NOT_ENOUGH_MEMORY );
            }

            ParsedRecoveryPolicy->dwKeyCount = Found;
            ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_OK;

            //
            // Make a copy of the policy information so we can free what we were passed in the caller
            //

            RecoveryKey = (PRECOVERY_KEY_1_1) &(RecoveryPolicy->RecoveryKeyList[0]);


            for (i=0 ; i< (ParsedRecoveryPolicy->dwKeyCount) ; i++) {

                PEFS_PUBLIC_KEY_INFO PublicKeyInfo = &RecoveryKey->PublicKeyInfo;

                if (* ((ULONG UNALIGNED *) &(PublicKeyInfo->KeySourceTag)) == EfsCertificate) {

                    b = ParseRecoveryCertificate( PublicKeyInfo,
                                                  &ParsedRecoveryPolicy->pbHash[i],
                                                  &ParsedRecoveryPolicy->cbHash[i],
                                                  &ParsedRecoveryPolicy->pbPublicKeys[i],
                                                  &ParsedRecoveryPolicy->cbPublicKeys[i],
                                                  &ParsedRecoveryPolicy->lpDisplayInfo[i],
                                                  &ParsedRecoveryPolicy->pCertContext[i],
                                                  &ParsedRecoveryPolicy->pSid[i]
                                                  );

                    if (!b) {
                        break;
                    }
                }

                RecoveryKey = (PRECOVERY_KEY_1_1)( ((PBYTE)RecoveryKey) + * ((ULONG UNALIGNED *) &(RecoveryKey->TotalLength)) );
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        b = FALSE;

        //
        // There was something wrong with the recovery policy.
        // Return this so we can at least print out an error.
        //

        rc = GetExceptionCode();
    }

    if (!b) {

        //
        // Something failed, clean up
        //

        rc = GetLastError();
        FreeParsedRecoveryPolicy( ParsedRecoveryPolicy );
        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_UNKNOWN_BAD;

        DebugLog((DEB_WARN, "Error parsing recovery policy\n"   ));
    }

    //
    // Policy refreshed. The Cert validation needs to be refreshed.
    //

    ParsedRecoveryPolicy->CertValidated   = CERT_NOT_VALIDATED;

    return( rc );


NoPolicy1:

    ParsedRecoveryPolicy->dwKeyCount       = 0;
    ParsedRecoveryPolicy->TimeStamp.QuadPart = 0;
    ParsedRecoveryPolicy->CertValidated   = CERT_NOT_VALIDATED;
    ParsedRecoveryPolicy->Base             = NULL;
    ParsedRecoveryPolicy->pbHash           = NULL;
    ParsedRecoveryPolicy->cbHash           = NULL;
    ParsedRecoveryPolicy->pbPublicKeys     = NULL;
    ParsedRecoveryPolicy->cbPublicKeys     = NULL;
    ParsedRecoveryPolicy->lpDisplayInfo    = NULL;
    ParsedRecoveryPolicy->pCertContext     = NULL;
    ParsedRecoveryPolicy->pSid             = NULL;

    return( ERROR_SUCCESS );
}


VOID
FreeParsedRecoveryPolicy(
    PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    )
/*++

Routine Description:

    This routine will free the allocated memory in a
    CURRENT_RECOVERY_POLICY structure.

Arguments:

    ParsedRecoveryPolicy - Supplies a structure that has
        had data parsed into it.

Return Value:

    None.

--*/

{
    //
    // Walk through the recovery policy and free everything
    //

    DWORD i;

    if (ParsedRecoveryPolicy->Base) {

        for (i=0; i<ParsedRecoveryPolicy->dwKeyCount; i++) {

            if (ParsedRecoveryPolicy->pbHash[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->pbHash[i] );
            }

            if (ParsedRecoveryPolicy->pbPublicKeys[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->pbPublicKeys[i] );
            }

            if (ParsedRecoveryPolicy->lpDisplayInfo[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->lpDisplayInfo[i] );
            }

            if (ParsedRecoveryPolicy->pCertContext[i] != NULL) {
                CertFreeCertificateContext( ParsedRecoveryPolicy->pCertContext[i] );
            }

            if (ParsedRecoveryPolicy->pSid[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->pSid[i] );
            }
        }

        LsapFreeLsaHeap( ParsedRecoveryPolicy->Base );
    }

    //
    // Paranoia
    //

    ParsedRecoveryPolicy->Base          = NULL;
    ParsedRecoveryPolicy->CertValidated  = CERT_NOT_VALIDATED;
    ParsedRecoveryPolicy->PolicyStatus  = RECOVERY_POLICY_NULL;
    ParsedRecoveryPolicy->dwKeyCount    = 0;
    ParsedRecoveryPolicy->pbHash        = NULL;
    ParsedRecoveryPolicy->cbHash        = NULL;
    ParsedRecoveryPolicy->pbPublicKeys  = NULL;
    ParsedRecoveryPolicy->cbPublicKeys  = NULL;
    ParsedRecoveryPolicy->lpDisplayInfo = NULL;
    ParsedRecoveryPolicy->pCertContext  = NULL;
    ParsedRecoveryPolicy->pSid          = NULL;
}

DWORD WINAPI
EFSRecover(
    IN LPVOID Param
    )
/*++
Routine Description:

    Enumerate the volumes and do the possible recovery jobs caused by
    power outage or crash during encryption or decryption.

Arguments:

    Param -- Standard parameter for thread. Not used.

Return Value:

    Operation result.

--*/
{
    CONFIGRET RetCode;
    WCHAR  *VolBuffer;
    WCHAR *PathName;
    ULONG  VolOffset;
    ULONG   bufLen;
    HMODULE hCfgMgr ;
    CMP_WAITSERVICESAVAILABLE pCMP_WaitServicesAvailable ;
    CM_GET_DEVICE_INTERFACE_LIST_SIZEW pCM_Get_Device_Interface_List_Size ;
    CM_GET_DEVICE_INTERFACE_LISTW pCM_Get_Device_Interface_List ;

//    hCfgMgr = LoadLibrary( TEXT("cfgmgr32.dll" ) );

    hCfgMgr = LoadLibrary( TEXT("setupapi.dll" ) );

    if ( hCfgMgr )
    {
        pCMP_WaitServicesAvailable = (CMP_WAITSERVICESAVAILABLE)
                                            GetProcAddress( hCfgMgr,
                                                            "CMP_WaitServicesAvailable" );
        pCM_Get_Device_Interface_List_Size = (CM_GET_DEVICE_INTERFACE_LIST_SIZEW)
                                            GetProcAddress( hCfgMgr,
                                                            "CM_Get_Device_Interface_List_SizeW" );

        pCM_Get_Device_Interface_List = (CM_GET_DEVICE_INTERFACE_LISTW)
                                            GetProcAddress( hCfgMgr,
                                                            "CM_Get_Device_Interface_ListW" );

        if ( (!pCMP_WaitServicesAvailable) ||
             (!pCM_Get_Device_Interface_List_Size) ||
             (!pCM_Get_Device_Interface_List) )
        {
            FreeLibrary( hCfgMgr );

            return GetLastError() ;
        }
    } else {
       return GetLastError() ;
    }


    RetCode = pCMP_WaitServicesAvailable( NULL );

    if ( CR_SUCCESS != RetCode ){
        FreeLibrary( hCfgMgr );
        return RetCode;
    }


    RetCode = pCM_Get_Device_Interface_List_Size(
                                    &bufLen,
                                    (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                    NULL,
                                    CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                                    );



    if ( CR_SUCCESS == RetCode ){

        VolBuffer = (WCHAR *) LsapAllocateLsaHeap( bufLen * sizeof(WCHAR) );
        PathName = (WCHAR *) LsapAllocateLsaHeap( MAX_PATH_LENGTH );

        if ( (NULL != VolBuffer) && (NULL != PathName) ){

            RetCode = pCM_Get_Device_Interface_List(
                                (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                NULL,
                                VolBuffer,
                                bufLen,
                                CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                            );

            if ( CR_SUCCESS == RetCode ){

                VolOffset = 0;
                while (*(VolBuffer + VolOffset)) {

                    //
                    // See if recovery is needed on the volume
                    //

                    wcscpy(PathName, VolBuffer + VolOffset);
                    wcscat(PathName, EFSDIR);
                    TryRecoverVol(VolBuffer + VolOffset, PathName);
                    while (*(VolBuffer + VolOffset++));

                }
            } else {

                HANDLE EventHandleLog = RegisterEventSource(
                                                                                NULL,
                                                                                EFSSOURCE
                                                                                );

                if ( EventHandleLog ){
                    ReportEvent(
                        EventHandleLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_GET_VOLUMES_ERROR,
                        NULL,
                        0,
                        4,
                        NULL,
                        &RetCode
                        );
                    DeregisterEventSource( EventHandleLog );

                }


                if ( CR_REGISTRY_ERROR == RetCode ){

                    //
                    // Map CR error to winerror
                    //

                    RetCode = ERROR_REGISTRY_CORRUPT;

                }
            }

            LsapFreeLsaHeap( VolBuffer );
            LsapFreeLsaHeap( PathName );

        } else {

            if ( NULL != PathName ){
                LsapFreeLsaHeap( PathName );
            }

            if ( NULL != VolBuffer ) {
                LsapFreeLsaHeap( VolBuffer );
            }

            RetCode =  ERROR_NOT_ENOUGH_MEMORY;

        }
    } else {

        DWORD  RetCode1 = GetLastError();
        HANDLE EventHandleLog = RegisterEventSource(
                                    NULL,
                                    EFSSOURCE
                                    );


        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_PNP_NOT_READY,
                NULL,
                0,
                4,
                NULL,
                &RetCode1
                );
            DeregisterEventSource( EventHandleLog );

        }

        if ( CR_REGISTRY_ERROR == RetCode1 ){

            //
            // Map CR error to winerror
            //

            RetCode = ERROR_REGISTRY_CORRUPT;

        }
    }

    FreeLibrary( hCfgMgr );

    return RetCode;
}

void
TryRecoverVol(
    IN const WCHAR *VolumeName,
    IN WCHAR *CacheDir
    )
/*++
Routine Description:

    Do the possible recovery jobs caused by
    power outage or crash during encryption or decryption on the volume.

Arguments:

    VolumeName -- volume name to be checked.

    CacheDir -- EFSCACHE dir. The buffer can be used in this routine.

Return Value:

    None.

--*/
{
    HANDLE EfsCacheDir;
    LPWIN32_FIND_DATA   FindFileInfo;
    HANDLE  FindHandle;

    //
    // Check if the directory EFSCACHE exist or not
    //

        EfsCacheDir = CreateFile(
                CacheDir,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                0
                );

        if (EfsCacheDir == INVALID_HANDLE_VALUE){
        //
        //  No recovery needed
        //

        return;
        }

    CloseHandle(EfsCacheDir);

    //
    //  Search the possible log file
    //

    FindFileInfo =  ( LPWIN32_FIND_DATA ) LsapAllocateLsaHeap ( sizeof ( WIN32_FIND_DATA ));

    ASSERT( FindFileInfo );
    if ( NULL == FindFileInfo ){

        return;

    }

    wcscat(CacheDir, EFSLOGPATTERN);

    FindHandle =  FindFirstFile( CacheDir, FindFileInfo );

        if (FindHandle == INVALID_HANDLE_VALUE){
        //
        //  No LogFile found. No recovery needed
        //

        LsapFreeLsaHeap( FindFileInfo);
        return;
        }

    //
    // Log file found. FT procedure begins
    //
    HANDLE EventHandleLog = RegisterEventSource(
                                                                    NULL,
                                                                    EFSSOURCE
                                                                    );

    if ( EventHandleLog ){

        //
        // Error in handling Event Log should not prevent real FT job.
        //

        ReportEvent(
            EventHandleLog,
            EVENTLOG_INFORMATION_TYPE,
            0,
            EFS_FT_STARTED,
            NULL,
            0,
            0,
            NULL,
            NULL
            );
    }

    for (;;){

        BOOL b;

        TryRecoverFile( VolumeName, FindFileInfo, EventHandleLog );

        b = FindNextFile( FindHandle, FindFileInfo );
        if ( !b ) {
            break;
        }
    }

    if ( EventHandleLog ){
        DeregisterEventSource( EventHandleLog );
    }
    LsapFreeLsaHeap( FindFileInfo);
    FindClose( FindHandle );
    return;

}

void
TryRecoverFile(
    IN const WCHAR *VolumeName,
    IN LPWIN32_FIND_DATA   FindFileInfo,
    IN HANDLE  EventHandleLog
    )
/*++
Routine Description:

    Do the possible recovery jobs caused by
    power outage or crash during encryption or decryption for the file.

Arguments:

    VolumeName -- volume name the log file is in.

    FindFileInfo -- Information about this log file.

Return Value:

    None.

--*/
{

    WCHAR   *FileName;
    HANDLE  LogFile;
    HANDLE  TmpFile;
    HANDLE  Target;
    HANDLE  VolumeHandle;
    LPWSTR  TargetName;
    LPWSTR  TmpName = NULL;
    LOGHEADER   FileHeader;
    ULONG   SectorSize;
    BYTE    *ReadBuffer;
    BYTE    *StatusBuffer;
    BOOL    b;
    ULONG   BufferSize;
    DWORD   BytesRead;
    ULONG   CheckSum;
    EFS_ACTION_STATUS   Action;
    NTSTATUS Status;
    UNICODE_STRING FileId;

    VolumeHandle = CreateFile(
                                VolumeName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_BACKUP_SEMANTICS,
                                0
                                );

    if ( INVALID_HANDLE_VALUE == VolumeHandle ){

        //
        // Directory on this volume opened successfully. It is unlikely that we will
        // come here.
        //
        return;
    }

    FileName = (WCHAR *) LsapAllocateLsaHeap( MAX_PATH_LENGTH );

    //
    //  Out of memory is unlikely at the boot time
    //

    ASSERT (FileName);
    if ( NULL == FileName ){
        CloseHandle( VolumeHandle );
        return;
    }

    //
    // Construct the log file name
    //

    wcscpy( FileName, VolumeName );
    wcscat( FileName,  EFSDIR );
    wcscat( FileName, L"\\");
    wcscat( FileName,  FindFileInfo->cFileName);

    LogFile = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE | DELETE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    0
                    );

    if ( INVALID_HANDLE_VALUE == LogFile ){

        DWORD   ErrCode = GetLastError();

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_OPEN_LOGFILE_ERROR,
                NULL,
                0,
                4,
                NULL,
                &ErrCode
                );
        }

        CloseHandle( VolumeHandle );
        LsapFreeLsaHeap(FileName);
        return;

    }

    b = ReadFile(
        LogFile,
        &FileHeader,
        sizeof( LOGHEADER ),
        &BytesRead,
        NULL
        );

    if ( !b ){

        //
        //  File IO error
        //
        DWORD   ErrCode = GetLastError();

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_READ_LOGFILE_ERROR,
                NULL,
                0,
                4,
                NULL,
                &ErrCode
                );
        }

        CloseHandle( LogFile );
        CloseHandle( VolumeHandle );
        LsapFreeLsaHeap(FileName);
        return;

    }

    if ( 0 == BytesRead ){

        //
        // Zero length log file. Nothing started. Delete it.
        //

        MarkFileForDelete( LogFile );
        CloseHandle( LogFile );
        CloseHandle( VolumeHandle );
        LsapFreeLsaHeap(FileName);
        return;

    }

    if ( (BytesRead < sizeof( LOGHEADER )) ||
         (LOGSIGLEN * sizeof (WCHAR) != RtlCompareMemory(
                                &(FileHeader.SIGNATURE[0]),
                                LOGSIG,
                                LOGSIGLEN * sizeof (WCHAR)
                                        )) ||
          ( LOGVERID != FileHeader.VerID )){
        //
        // Probably not our log file
        //

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_INFORMATION_TYPE,
                0,
                EFS_LOGFILE_FORMAT_ERROR,
                NULL,
                0,
                0,
                NULL,
                NULL
                );
        }

        CloseHandle( LogFile );
        CloseHandle( VolumeHandle );
        LsapFreeLsaHeap(FileName);
        return;

    }

    //
    //  Read in the whole header to continue the process
    //

    SectorSize = FileHeader.SectorSize;
    BufferSize = FileHeader.HeaderBlockSize;

    ASSERT( BufferSize % SectorSize == 0 );

    ReadBuffer = (BYTE *) LsapAllocateLsaHeap( BufferSize );

    //
    // StatusBuffer must be aligned for cached IO.
    // LsapAllocateLsaHeap() is not aligned.
    //

    if ((FileHeader.Flag & LOG_DIRECTORY) == 0) {
        StatusBuffer = (BYTE *) VirtualAlloc(
                                NULL,
                                FileHeader.OffsetStatus2 - FileHeader.OffsetStatus1,
                                MEM_COMMIT,
                                PAGE_READWRITE
                                );
    } else {
        StatusBuffer = NULL;
    }

    ASSERT( (FileHeader.OffsetStatus2 - FileHeader.OffsetStatus1) % SectorSize == 0 );
    ASSERT( ReadBuffer );
    if ( (NULL == ReadBuffer) || ((NULL == StatusBuffer) && ((FileHeader.Flag & LOG_DIRECTORY) == 0)) ){

        //
        //  Out of memory is almost impossible during the boot time.
        //

        if ( ReadBuffer ) {
            LsapFreeLsaHeap(ReadBuffer);
        }
        if ( StatusBuffer ) {
            VirtualFree(
                StatusBuffer,
                0,
                MEM_RELEASE
                );
        }
        CloseHandle( LogFile );
        CloseHandle( VolumeHandle );
        LsapFreeLsaHeap(FileName);
        return;
    }

    SetFilePointer( LogFile, 0, NULL, FILE_BEGIN);

    b = ReadFile(
        LogFile,
        ReadBuffer,
        BufferSize,
        &BytesRead,
        NULL
        );

    if ( !b || ( BytesRead != BufferSize ) ){

        //
        //  File IO error, Should sent out some debug Info?
        //

        DWORD   ErrCode = GetLastError();

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_READ_LOGFILE_ERROR,
                NULL,
                0,
                4,
                NULL,
                &ErrCode
                );
        }

        CloseHandle( LogFile );
        CloseHandle( VolumeHandle );
        LsapFreeLsaHeap(ReadBuffer);
        VirtualFree(
            StatusBuffer,
            0,
            MEM_RELEASE
            );
        LsapFreeLsaHeap(FileName);
        return;

    }

    CheckSum = GetCheckSum(ReadBuffer, FileHeader.HeaderSize );
    if (CheckSum == *(ULONG* ) (ReadBuffer + BufferSize - sizeof(ULONG))){

        OBJECT_ATTRIBUTES Obja;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        //  The header is in good condition. Get TargetName and TmpName for the error
        //  msg in system log.
        //

        TargetName = (WCHAR *)( ReadBuffer + FileHeader.TargetFilePathOffset );

        if ( (FileHeader.Flag & LOG_DIRECTORY) == 0 ){

            //
            // Operation was on File not on Directory
            // The real status is in Status block. Read in the status block.
            // Log file may updated. We need to reopen it with non-cached IO.
            //

            CloseHandle( LogFile );
            LogFile = CreateFile(
                                    FileName,
                                    GENERIC_READ | GENERIC_WRITE | DELETE,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_NO_BUFFERING,
                                    0
                                    );

            //
            //  Log File name is done. We are going to use FileName memory space
            //  to get a temp file name.
            //

            if ( INVALID_HANDLE_VALUE == LogFile ){

                //
                // Log File cannot be open as non-cached IO. Try next time.
                // This is weird.
                //
                DWORD   ErrCode = GetLastError();

                ASSERT (FALSE);

                if ( EventHandleLog ){
                    ReportEvent(
                        EventHandleLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_OPEN_LOGFILE_NC_ERROR,
                        NULL,
                        0,
                        4,
                        NULL,
                        &ErrCode
                        );
                }
                LsapFreeLsaHeap(FileName);
                CloseHandle( VolumeHandle );
                LsapFreeLsaHeap(ReadBuffer);
                VirtualFree(
                    StatusBuffer,
                    0,
                    MEM_RELEASE
                    );
                return;

            }

            //
            // Open the temp file first.
            //

            TmpName = (WCHAR *)( ReadBuffer + FileHeader.TempFilePathOffset );
            FileId.Buffer = (WCHAR *) &(FileHeader.TempFileInternalName);
            FileId.Length = FileId.MaximumLength = sizeof (LARGE_INTEGER);
            InitializeObjectAttributes(
                &Obja,
                &FileId,
                0,
                VolumeHandle,
                NULL
                );

            Status = NtCreateFile(
                        &TmpFile,
                        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        0,
                        FILE_OPEN,
                        FILE_OPEN_BY_FILE_ID | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                        NULL,
                        0
                        );

            if (NT_SUCCESS( Status )){

                OBJECT_NAME_INFORMATION *ATempFileName;
                ULONG PathLength;

                //
                //  Temp file opened with File ID. File open by ID cannot be deleted. So
                //  we need to get a name and reopen it using the name with DELETE
                //  access
                //

                ATempFileName = (OBJECT_NAME_INFORMATION *)FileName;
                Status = NtQueryObject(
                    TmpFile,
                    ObjectNameInformation,
                    ATempFileName,
                    MAX_PATH_LENGTH,
                    &PathLength
                    );

                if ( NT_SUCCESS( Status ) ){

                    CloseHandle(TmpFile);
                    TmpFile = 0;
                    InitializeObjectAttributes(
                        &Obja,
                        &(ATempFileName->Name),
                        0,
                        0,
                        NULL
                        );

                    Status = NtCreateFile(
                                &TmpFile,
                                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                0,
                                0,
                                FILE_OPEN,
                                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                NULL,
                                0
                                );

                    if (!NT_SUCCESS( Status )){

                        //
                        //  Well, we cannot open with the name got. Strange.
                        //  Reopen it with File ID. Temp file is not going to be deleted.
                        //

                        ASSERT(FALSE);
                        if ( EventHandleLog ){

                            LPWSTR lpStrings[2];
                            lpStrings[1] = TargetName;
                            lpStrings[0] = TmpName;

                            ReportEvent(
                                EventHandleLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                EFS_TMP_OPEN_NAME_ERROR,
                                NULL,
                                2,
                                4,
                                (LPCTSTR *) &lpStrings[0],
                                &Status
                                );
                        }

                        InitializeObjectAttributes(
                            &Obja,
                            &FileId,
                            0,
                            VolumeHandle,
                            NULL
                            );

                        Status = NtCreateFile(
                                    &TmpFile,
                                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    0,
                                    0,
                                    FILE_OPEN,
                                    FILE_OPEN_BY_FILE_ID | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                    NULL,
                                    0
                                    );

                        if (!NT_SUCCESS( Status )){

                            //
                            //  Well, more strange. We cannot even open the file we opened
                            //  Nothing we can do this time. Try next time.
                            //

                            if ( EventHandleLog ){

                                LPWSTR lpStrings[2];
                                lpStrings[1] = TargetName;
                                lpStrings[0] = TmpName;

                                ReportEvent(
                                    EventHandleLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    EFS_TMP_FILEID_ERROR,
                                    NULL,
                                    2,
                                    4,
                                    (LPCTSTR*) &lpStrings[0],
                                    &Status
                                    );
                            }

                            LsapFreeLsaHeap(FileName);
                            CloseHandle( VolumeHandle );
                            LsapFreeLsaHeap(ReadBuffer);
                            VirtualFree(
                                StatusBuffer,
                                0,
                                MEM_RELEASE
                                );
                            return;

                        }
                    }
                } else {

                    if ( EventHandleLog ){

                        LPWSTR lpStrings[2];
                        lpStrings[0] = TargetName;
                        lpStrings[1] = TmpName;

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            EFS_TMP_FILENAME_ERROR,
                            NULL,
                            2,
                            4,
                            (LPCTSTR*) &lpStrings[0],
                            &Status
                            );
                    }

                }

                //
                //  If a name cannot be got, the following apply.
                //  Temp file is existed. But we cannot get a name. Weird.
                //  The recover will go on. But the temp file will not be deleted
                //

            } else {

                //
                // Temp file is not exist. May be deleted by our operations.
                //  Make sure the handle is 0.
                //

                TmpFile = 0;
            }

            //
            //  FileName is done.
            //

            LsapFreeLsaHeap(FileName);
            FileName = NULL;

            Status = ReadLogFile(
                            LogFile,
                            StatusBuffer,
                            FileHeader.OffsetStatus1,
                            FileHeader.OffsetStatus2
                            );

            if (!NT_SUCCESS( Status )) {

                //
                // Status copies are not valid.  Nothing have started or we can do nothing
                // to recover. Delete the log file.
                //

                MarkFileForDelete( LogFile );
                CloseHandle( LogFile );
                if ( TmpFile ){
                    CloseHandle( TmpFile );
                }
                CloseHandle( VolumeHandle );
                LsapFreeLsaHeap(ReadBuffer);
                VirtualFree(
                    StatusBuffer,
                    0,
                    MEM_RELEASE
                    );
                return;

            }

            Action =  * (EFS_ACTION_STATUS *) (StatusBuffer + sizeof (ULONG));

        } else {

            //
            //  Operations were on a directory
            //

            if ( FileHeader.Flag & LOG_DECRYPTION ){

                Action = BeginDecryptDir;

            } else {

                Action = BeginEncryptDir;

            }

            TmpFile = 0;
        }

        //
        // Open the target file.
        //

        if (StatusBuffer) {
            VirtualFree(
                StatusBuffer,
                0,
                MEM_RELEASE
                );
        }

        FileId.Buffer = (WCHAR* ) &(FileHeader.TargetFileInternalName);
        FileId.Length = FileId.MaximumLength = sizeof (LARGE_INTEGER);
        InitializeObjectAttributes(
            &Obja,
            &FileId,
            0,
            VolumeHandle,
            NULL
            );

        Status = NtCreateFile(
                    &Target,
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE ,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    0,
                    0,
                    FILE_OPEN,
                    FILE_OPEN_BY_FILE_ID | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS( Status )) {

            //
            // OOPS! We can not open the target. What can we do without the target.
            // Delete the log file.
            //

            if ( EventHandleLog ){

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    EFS_TARGET_OPEN_ERROR,
                    NULL,
                    1,
                    4,
                    (LPCTSTR*) &TargetName,
                    &Status
                    );
            }

            MarkFileForDelete( LogFile );
            CloseHandle( LogFile );
            CloseHandle( VolumeHandle );
            if ( TmpFile ){
                CloseHandle( TmpFile );
            }
            LsapFreeLsaHeap(ReadBuffer);
            return;

        }

        //
        //  We survived so far. Now is the show time!
        //

        DoRecover(
            Target,
            TmpFile,
            LogFile,
            TargetName,
            TmpName,
            FileHeader.OffsetStatus2 - FileHeader.OffsetStatus1,
            FileHeader.OffsetStatus1,
            Action,
            EventHandleLog
            );

        CloseHandle ( Target );
        if ( TmpFile ){
            CloseHandle( TmpFile );
        }

    } else {

        //
        // The header is not fully written. Nothing could have be done.
        // Just delete the log file and we are done.
        //

        MarkFileForDelete( LogFile );
        if (StatusBuffer) {
            VirtualFree(
                StatusBuffer,
                0,
                MEM_RELEASE
                );
        }
        LsapFreeLsaHeap(FileName);
    }

    LsapFreeLsaHeap(ReadBuffer);
    CloseHandle( LogFile );
    CloseHandle( VolumeHandle );
    return;

}

NTSTATUS
ReadLogFile(
    IN HANDLE LogFile,
    OUT BYTE* ReadBuffer,
    IN ULONG FirstCopy,
    IN ULONG SecondCopy
    )
/*++
Routine Description:

    Read Status Log Information.

Arguments:

    LogFile -- A handle to the log file

    ReadBuffer -- Buffer for the output data.

    FirstCopy -- Offset of first status information copy in the logfile.

    SecondCopy -- Offset of second status information copy in the logfile.

Return Value:

    The status of operation.
--*/
{
    ULONG ReadBytes;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    ULONG CheckSum;
    BOOLEAN WrongCheckSum = FALSE;


    //
    //  Write out the header sector
    //
    ByteOffset.QuadPart = (LONGLONG) FirstCopy;
    ReadBytes = SecondCopy - FirstCopy;

    Status = NtReadFile(
                    LogFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    ReadBuffer,
                    ReadBytes,
                    &ByteOffset,
                    NULL
                    );

    if ( NT_SUCCESS(Status) ) {

        //
        // Check the integrity of the data
        //


        CheckSum = GetCheckSum( ReadBuffer, 2 * sizeof (ULONG)  );
        if ( CheckSum != *(ULONG *)( ReadBuffer + ReadBytes - sizeof (ULONG) )){

            WrongCheckSum =  TRUE;

        }

    }

    if ( !NT_SUCCESS(Status) || WrongCheckSum ) {

        ByteOffset.QuadPart = (LONGLONG) SecondCopy;
        Status = NtReadFile(
                        LogFile,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        ReadBuffer,
                        ReadBytes,
                        &ByteOffset,
                        NULL
                        );

        if ( NT_SUCCESS(Status) ) {

            //
            // Check the integrity of the data
            //


            CheckSum = GetCheckSum( ReadBuffer, 2 * sizeof (ULONG)  );
            if ( CheckSum != *(ULONG *)( ReadBuffer + ReadBytes - sizeof (ULONG) )){

                //
                //  Both status copy are bad.
                //

                Status =  STATUS_FILE_CORRUPT_ERROR;
            }
        }
    }

    return Status;
}

NTSTATUS
DoRecover(
    IN HANDLE Target,
    IN HANDLE TmpFile  OPTIONAL,
    IN HANDLE LogFile,
    IN LPCWSTR  TargetName,
    IN LPCWSTR  TmpName OPTIONAL,
    IN ULONG StatusCopySize,
    IN ULONG StatusStartOffset,
    IN ULONG   Action,
    IN HANDLE  EventHandleLog
    )
/*++
Routine Description:

    Do the real dirty recovery job here.

Arguments:

    Target -- A handle to the target file or directory.

    TmpFile -- A handle to the temp file if Target is a file.

    LogFile -- A handle to the log file.

    TargetName -- Target file name. This info is used for error log only.

    TmpName -- Temp backup file name. This info is used for error log only.

    StatusCopySize -- Log file status copy section size.

    StatusStartOffset --  Offset of status copy in the log file.

    Action -- The status to begin.

    EventHandleLog -- Event log handle.

Return Value:

    The status of operation.
--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    EFSP_OPERATION Operation = EncryptRecovering;

    if ( ( BeginEncryptDir == Action ) || ( BeginDecryptDir == Action ) ){

        //
        // In both cases, we will do Decrypt on the directory
        //

        Status = DecryptDir( Target, TargetName );
        if ( NT_SUCCESS(Status) ) {

            //
            // The operation was successful
            //
            if ( EventHandleLog ){

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    EFS_TARGET_RECOVERED,
                    NULL,
                    1,
                    0,
                    (LPCTSTR*) &TargetName,
                    NULL
                    );
            }

            MarkFileForDelete( LogFile );

        } else {

            //
            //  EFS driver might not be loaded. Log the information.
            //

            if ( EventHandleLog ){

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_DRIVER_MISSING,
                    NULL,
                    1,
                    0,
                    (LPCTSTR*) &TargetName,
                    NULL
                    );
            }
        }
    }  else {

        //
        // File operations
        //

        switch ( Action ) {
            case EncryptionMessup:

                //
                //  The original file is messed up due to the unknown reason.
                //  Operation required,
                //      Same as  EncryptTmpFileWritten.
                //

                Operation = EncryptRecovering;

                // ***** Fall through intended *****

            case DecryptTmpFileWritten:

                //
                //  Temp file is created and written during the decryption. The original file is probably
                //  damaged. Operation required,
                //      Same as the EncryptTmpFileWritten. The file will end up as plain text.
                //

                if ( DecryptTmpFileWritten == Action ){
                    Operation = DecryptRecovering;
                }

                //
                // ***** Fall through intended *****
                //

            case EncryptTmpFileWritten:

                if ( EncryptTmpFileWritten == Action ){

                    Operation = EncryptRecovering;

                }

                //
                //  Temp file is created and written during the encryption. The original file is probably
                //  damaged. Operation required,
                //      FSCTL decrypt each stream, copy the data back to the original file. Log file
                //      will be updated to BeginEncryptFile after all the streams are copied back. Then
                //      continue the case indicated in BeginEncryptFile.
                //
                if ( !TmpFile ){

                    //
                    //  Temp backup not existed or open failed, we can do nothing for this.
                    //  Log the error information and quit.
                    //
                    if ( EventHandleLog ){

                        LPCWSTR lpStrings[2];
                        lpStrings[1] = TargetName;
                        lpStrings[0] = TmpName;

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_TMPFILE_MISSING,
                            NULL,
                            2,
                            4,
                            &lpStrings[0],
                            &Status
                            );
                    }

                    return STATUS_NO_SUCH_FILE;
                }

                Status = RestoreTarget(
                            Target,
                            TmpFile,
                            TargetName,
                            TmpName,
                            EventHandleLog,
                            Operation
                            );

                if ( NT_SUCCESS(Status) ) {

                    WriteLogFile(
                        LogFile,
                        StatusCopySize,
                        StatusStartOffset,
                        BeginEncryptFile
                        );

                } else {

                    return Status;

                }

                // ***** Fall through intended *****

            case DecryptionDone:

                //
                //  All the streams are marked decrypted. The file might still have the flag set.
                //  Operation required,
                //      Same as BeginEncryptFile.
                //

                // ***** Fall through intended *****

            case EncryptionBackout:

                //
                //  Encryption failed but we managed the original streams back. The file might
                //  be in a transition status.
                //  Operation required,
                //      Same as BeginEncryptFile.
                //

                // ***** Fall through intended *****

            case BeginEncryptFile:

                //
                //  File encryption just begin. Original file is not changed.
                //  Operation required,
                //      Remove the $EFS, remove the tempfile if existed and remove the log file.
                //

                Status = SendGenFsctl(
                                        Target,
                                        EFS_DECRYPT_FILE,
                                        EFS_DECRYPT_FILE,
                                        EFS_SET_ENCRYPT,
                                        FSCTL_SET_ENCRYPTION
                                        );

                if ( NT_SUCCESS(Status) ) {

                    if ( TmpFile ){
                        MarkFileForDelete( TmpFile );
                    }
                    MarkFileForDelete( LogFile );

                    if ( EventHandleLog ){

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            EFS_TARGET_RECOVERED,
                            NULL,
                            1,
                            0,
                            &TargetName,
                            NULL
                            );
                    }
                } else {

                    //
                    //  EFS driver may not be loaded. Write the log info.
                    //

                    if ( EventHandleLog ){

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_DRIVER_MISSING,
                            NULL,
                            1,
                            0,
                            &TargetName,
                            NULL
                            );
                    }
                }

                break;

            case BeginDecryptFile:

                //
                //  File decryption just begin. Original file is not changed.
                //  Operation required,
                //      Set the transition status to normal, remove the tempfile if existed and
                //      remove the log file.
                //

                // ***** Fall through intended *****

            case EncryptionDone:

                //
                //  All the streams were encrypted. The original file might be in transition status.
                //  Operation required,
                //      FSCTL to set the transition status to normal. Update the log status to
                //      EncryptionSrcDone. Continue to EncryptionSrcDone.
                //

                Status = SendGenFsctl(
                                        Target,
                                        0,
                                        0,
                                        EFS_ENCRYPT_DONE,
                                        FSCTL_ENCRYPTION_FSCTL_IO
                                        );

                if ( !NT_SUCCESS(Status) ) {

                    //
                    //  EFS driver might not be loaded. Log error.
                    //

                    if ( EventHandleLog ){

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_DRIVER_MISSING,
                            NULL,
                            1,
                            0,
                            &TargetName,
                            NULL
                            );
                    }
                    return Status;

                }

                // ***** Fall through intended *****

            case EncryptionSrcDone:

                //
                //  The original file is encrypted successfully. The temp file might still be left.
                //  Operation required,
                //      Remove the temp file if existed and remove the log file.
                //

                if ( TmpFile ){
                    MarkFileForDelete( TmpFile );
                }
                MarkFileForDelete( LogFile );

                if ( EventHandleLog ){

                    ReportEvent(
                        EventHandleLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        EFS_TARGET_RECOVERED,
                        NULL,
                        1,
                        0,
                        &TargetName,
                        NULL
                        );
                }
                break;

            default:

                //
                // Not our log file or tempered by someone.
                // Write to the log to notify the user.
                //

                Status = STATUS_FILE_CORRUPT_ERROR;
                break;
        }
    }

    return Status;
}

NTSTATUS
DecryptDir(
    IN HANDLE Target,
    IN LPCWSTR  TargetName
    )
/*++
Routine Description:

    Decrypt a directory.

Arguments:

    Target -- A handle to the target file or directory.

    TargetName -- Target file name. This info is used for error log only.

Return Value:

    The status of operation.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = SendGenFsctl(
                            Target,
                            EFS_DECRYPT_STREAM,
                            EFS_DECRYPT_DIRSTR,
                            EFS_SET_ENCRYPT,
                            FSCTL_SET_ENCRYPTION
                            );

    if ( NT_SUCCESS( Status ) ){

        Status = SendGenFsctl(
                                Target,
                                EFS_DECRYPT_FILE,
                                EFS_DECRYPT_DIRFILE,
                                EFS_SET_ENCRYPT,
                                FSCTL_SET_ENCRYPTION
                                );
    }

    return Status;

}

NTSTATUS
RestoreTarget(
    IN HANDLE   Target,
    IN HANDLE   TmpFile,
    IN LPCWSTR   TargetName,
    IN LPCWSTR   TmpName,
    IN HANDLE   EventHandleLog,
    EFSP_OPERATION Operation
    )
/*++
Routine Description:

    Copy all the streams in the temp backup file to the original target file.

Arguments:

    Target -- A handle to the target file or directory.

    TmpFile -- A handle to the temp file if Target is a file.

    TargetName -- Target file name. This info is used for error log only.

    TmpName -- Temp backup file name. This info is used for error log only.

    Operation -- Indicate if encryption or decryption was tried.

Return Value:

    The status of operation.
--*/
{
    NTSTATUS Status;
    DWORD hResult;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG   StreamInfoSize = 0;
    ULONG   StreamCount = 0;
    PEFS_STREAM_SIZE  StreamSizes;
    PHANDLE  StreamHandles;
    PUNICODE_STRING StreamNames;

    Status = GetStreamInformation(
                 TmpFile,
                 &StreamInfoBase,
                 &StreamInfoSize
                 );

    if ( NT_SUCCESS( Status ) ){

        hResult = OpenFileStreams(
                    TmpFile,
                    FILE_SHARE_DELETE,        // have to share with delete-ers, since the main stream is open for delete
                    OPEN_FOR_FTR,
                    StreamInfoBase,
                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                    NULL,
                    &StreamNames,      // Free this but not the contents!
                    &StreamHandles,    // Free this
                    &StreamSizes,      // Free this
                    &StreamCount
                    );

        if (hResult == ERROR_SUCCESS) {

            ULONG   FsInputDataSize;
            PUCHAR  FsInputData;
            PHANDLE  TargetStreamHandles;
            LONG   ArrIndex;

            TargetStreamHandles = ( PHANDLE ) LsapAllocateLsaHeap(StreamCount * sizeof (HANDLE));
            if ( TargetStreamHandles ){

                //
                // Open streams at the original target file
                //
                for ( ArrIndex = 0; ArrIndex < (LONG) StreamCount; ArrIndex++){
                    if ( StreamHandles[ArrIndex] == TmpFile ){
                        TargetStreamHandles[ArrIndex] = Target;
                    } else {
                        OBJECT_ATTRIBUTES Obja;
                        IO_STATUS_BLOCK IoStatusBlock;

                        InitializeObjectAttributes(
                            &Obja,
                            &StreamNames[ArrIndex],
                            0,
                            Target,
                            NULL
                            );

                        Status = NtCreateFile(
                                    &TargetStreamHandles[ArrIndex],
                                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    0,
                                    0,
                                    FILE_OPEN_IF,
                                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                    NULL,
                                    0
                                    );
                        if (!NT_SUCCESS( Status )){

                            if ( EventHandleLog ){

                                ReportEvent(
                                    EventHandleLog,
                                    EVENTLOG_ERROR_TYPE,
                                    0,
                                    EFS_TARGET_STREAM_OPEN_ERROR,
                                    NULL,
                                    1,
                                    4,
                                    &TargetName,
                                    &Status
                                    );
                            }

                            break;
                        }
                    }
                }

                if ( NT_SUCCESS( Status ) ){

                    //
                    //  Adjust ArrIndex for clean up
                    //

                    ArrIndex--;

                    //
                    //  Make a FSCTL request input data block
                    //

                    FsInputDataSize = 7 * sizeof( ULONG ) + 2 * sizeof(DriverSessionKey);
                    FsInputData = (PUCHAR) LsapAllocateLsaHeap(FsInputDataSize);

                    if ( FsInputData ){

                        BOOLEAN CleanupSuccessful;

                        ( VOID )GetDecryptFsInput(
                                    Target,
                                    FsInputData,
                                    &FsInputDataSize
                                    );

                        hResult = CopyFileStreams(
                                     StreamHandles,     // handles to streams on the backup file
                                     TargetStreamHandles, // Handles to the streams on the original file
                                     StreamCount,       // number of streams
                                     StreamSizes,       // sizes of streams
                                     Operation,         // mark StreamHandles as Decrypted before copy
                                     FsInputData,         // FSCTL input data
                                     FsInputDataSize,     // FSCTL input data size
                                     &CleanupSuccessful
                                     );

                        LsapFreeLsaHeap( FsInputData );

                        if ( hResult != ERROR_SUCCESS ){

                            if ( EventHandleLog ){

                                ReportEvent(
                                    EventHandleLog,
                                    EVENTLOG_ERROR_TYPE,
                                    0,
                                    EFS_STREAM_COPY_ERROR,
                                    NULL,
                                    1,
                                    4,
                                    &TargetName,
                                    &hResult
                                    );
                            }

                            Status = STATUS_UNSUCCESSFUL;
                        }
                    } else {

                        //
                        //  Out of memory. Almost impossible during LSA init.
                        //

                        ASSERT(FALSE);
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                //
                //  Clean up TargetStreamHandles at the target.
                //

                while (ArrIndex >= 0){
                    if ( TargetStreamHandles[ArrIndex] != Target ){
                        CloseHandle(TargetStreamHandles[ArrIndex]);
                    }
                    ArrIndex--;
                }
                LsapFreeLsaHeap( TargetStreamHandles );

            }

            //
            //  Clean up StreamHandles and etc.
            //

            for (ArrIndex = 0; ArrIndex< (LONG) StreamCount ; ArrIndex++) {
                if ( StreamHandles[ArrIndex] != TmpFile){
                    NtClose( StreamHandles[ArrIndex] );
                }
            }

            LsapFreeLsaHeap( StreamHandles);
            LsapFreeLsaHeap( StreamNames);
            LsapFreeLsaHeap( StreamSizes);

        } else {

            //
            //  Not all the requested streams could be opened.
            //  Write the log info.
            //
            if ( EventHandleLog ){

                LPCWSTR lpStrings[2];
                lpStrings[1] = TargetName;
                lpStrings[0] = TmpName;

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_TMP_STREAM_OPEN_ERROR,
                    NULL,
                    2,
                    4,
                    &lpStrings[0],
                    &hResult
                    );
            }

            Status = STATUS_UNSUCCESSFUL;
        }

        LsapFreeLsaHeap( StreamInfoBase );

    }  else {

        //
        //  Stream info cannot be got. Write LOG info.
        //
        if ( EventHandleLog ){

            LPCWSTR lpStrings[2];
            lpStrings[1] = TargetName;
            lpStrings[0] = TmpName;

            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_TMP_STREAM_INFO_ERROR,
                NULL,
                2,
                4,
                &lpStrings[0],
                &Status
                );
        }

    }

    return Status;
}

BOOL
ParseRecoveryCertificate(
    IN  PEFS_PUBLIC_KEY_INFO  pPublicKeyInfo,
    OUT PBYTE               * pbHash,
    OUT PDWORD                cbHash,
    OUT PBYTE               * pbPublicKey,
    OUT PDWORD                cbPublicKey,
    OUT LPWSTR              * lpDisplayInfo,
    OUT PCCERT_CONTEXT      * pCertContext,
    OUT PSID                * pSid
    )

/*++

Routine Description:

    This routine takes a certificate passed in the recovery policy and
    extracts the interesting information.

Arguments:

    pPublicKeyInfo - Takes the public key info structure from the
        recovery policy.

    pbHash - Returns the hash of the passed certificate.

    cbHash - Returns the lengh in bytes of the returned hash.

    pbPublicKey - Returns a pointer to the public key blob of the certificate.

    cbPublicKey - Returns the length in bytes of the public key.

    lpDisplayInfo - Returns display information about the certificate.

    pCertContext - Cert context for the passed certificate.

    pSid - Returns SID of the recovery agent

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    //
    // Get the certificate out of the public key info structure
    //


    PEFS_PUBLIC_KEY_INFO pAlignedPublicKeyInfo;
    BOOLEAN freeAlignedInfo;
    DWORD rc = ERROR_SUCCESS;

    rc =  EfsAlignBlock(
                    pPublicKeyInfo,
                    (PVOID *)&pAlignedPublicKeyInfo,
                    &freeAlignedInfo
                    );
    if (!pAlignedPublicKeyInfo) {

        //
        // OOM. Treat it as not current.
        //

        rc = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;

    }

    ASSERT( pAlignedPublicKeyInfo->KeySourceTag == EfsCertificate );

    //
    // Initialize OUT parameters
    //

    *pbHash        = NULL;
    *pbPublicKey   = NULL;
    *lpDisplayInfo = NULL;
    *pCertContext  = NULL;
    *pSid          = NULL;


    PBYTE pbCert = (PBYTE)OFFSET_TO_POINTER(CertificateInfo.Certificate, pAlignedPublicKeyInfo);
    DWORD cbCert = pAlignedPublicKeyInfo->CertificateInfo.CertificateLength;

    *pCertContext = CertCreateCertificateContext(
                          CRYPT_ASN_ENCODING,
                          (const PBYTE)pbCert,
                          cbCert);

    if (*pCertContext) {

        PCERT_INFO pCertInfo = (*pCertContext)->pCertInfo;
        CERT_PUBLIC_KEY_INFO * pSubjectPublicKeyInfo = &pCertInfo->SubjectPublicKeyInfo;
        CRYPT_BIT_BLOB * PublicKey = &pSubjectPublicKeyInfo->PublicKey;

        *cbPublicKey = 0;

        if (CryptDecodeObject(
                CRYPT_ASN_ENCODING,
                RSA_CSP_PUBLICKEYBLOB,
                PublicKey->pbData,
                PublicKey->cbData,
                0,
                NULL,
                cbPublicKey
                )) {

            if (*pbPublicKey = (PBYTE)LsapAllocateLsaHeap( *cbPublicKey )) {

                if (CryptDecodeObject(
                        CRYPT_ASN_ENCODING,
                        RSA_CSP_PUBLICKEYBLOB,
                        PublicKey->pbData,
                        PublicKey->cbData,
                        0,
                        *pbPublicKey,
                        cbPublicKey
                        )) {

                    //
                    // Get the certificate hash
                    //

                    *cbHash = 0;

                    if (CertGetCertificateContextProperty(
                                 *pCertContext,
                                 CERT_HASH_PROP_ID,
                                 NULL,
                                 cbHash
                                 )) {

                        *pbHash = (PBYTE)LsapAllocateLsaHeap( *cbHash );

                        if (*pbHash) {

                            if (CertGetCertificateContextProperty(
                                         *pCertContext,
                                         CERT_HASH_PROP_ID,
                                         *pbHash,
                                         cbHash
                                         )) {

                                //
                                // Get the display information
                                //

                                *lpDisplayInfo = EfspGetCertDisplayInformation( *pCertContext );

                                if (*lpDisplayInfo == NULL) {

                                    rc = GetLastError();
                                }

                                //
                                // Try to get the recovery agent SID
                                // This info is not very important. If we fail, we should continue.
                                //

                                if (pAlignedPublicKeyInfo->PossibleKeyOwner) {

                                    DWORD SidLength;
                                    PSID  RecSid = (PSID) OFFSET_TO_POINTER( PossibleKeyOwner, pAlignedPublicKeyInfo );

                                    SidLength = GetLengthSid(RecSid);
                                    *pSid = (PSID)LsapAllocateLsaHeap( SidLength );
                                    if (*pSid) {
                                        RtlCopyMemory( *pSid, RecSid, SidLength );
                                    }
                                }


                            } else {

                                rc = GetLastError();
                            }

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {

                        rc = GetLastError();
                    }

                } else {

                    rc = GetLastError();
                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            rc = GetLastError();
        }

    } else {

        rc = GetLastError();
    }

    if (freeAlignedInfo) {
        LsapFreeLsaHeap( pAlignedPublicKeyInfo );
    }

    if (rc != ERROR_SUCCESS) {

        //
        // Free the stuff we were going to return
        //

        if (*pbHash != NULL) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (*pbPublicKey != NULL) {
            LsapFreeLsaHeap( *pbPublicKey );
            *pbPublicKey = NULL;
        }

        if (*lpDisplayInfo != NULL) {
            LsapFreeLsaHeap( *lpDisplayInfo );
            *lpDisplayInfo = NULL;
        }

        if (*pCertContext != NULL) {
            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;
        }

        if (*pSid != NULL) {
            LsapFreeLsaHeap( *pSid );
            *pSid = NULL;
        }
    }

    SetLastError( rc );

    return( rc == ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\efscert.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efscert.cxx

Abstract:

    EFS Certificate management code

Author:

    Robert Reichel      (RobertRe)     July 4, 1997
    Robert Gu           (RobertG)      Dec. 4, 1997

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wincrypt.h>
#include <efsstruc.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
}


/////////////////////////////////////////////////////////////////////////////////////
//                                                                                  /
//                                                                                  /
//                              Helper Functions                                    /
//                                                                                  /
//                                                                                  /
/////////////////////////////////////////////////////////////////////////////////////

PCCERT_CONTEXT
GetCertContextFromCertHash(
    IN PBYTE pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Finds the cert with the passed cert hash in the user's MY store
    and returns a context pointer.

Arguments:

    pbHash - Supplies a pointer to the hash to be matched.

    cbHash - Supplies the length in bytes of the passed hash.
    
    dwFlags - Supplies flags to CertOpenStore

Return Value:

    Returns a pointer to a certificate context, or NULL.
    The returned context must be freed via CertFreeCertificateContext()

--*/

{
    CRYPT_HASH_BLOB hashBlob;
    PCCERT_CONTEXT pCertContext = NULL;

    //HCERTSTORE hStore = CertOpenSystemStoreW( NULL, L"MY");

    HCERTSTORE hStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            dwFlags,
                            L"My"
                            );

    if (hStore != NULL) {

        //
        // Find our cert via the hash
        //

        hashBlob.cbData = cbHash;
        hashBlob.pbData = pbHash;

        pCertContext = CertFindCertificateInStore( hStore,
                                                   CRYPT_ASN_ENCODING,
                                                   0,
                                                   CERT_FIND_HASH,
                                                   &hashBlob,
                                                   NULL
                                                   );
        CertCloseStore( hStore, 0 );
    }

    return( pCertContext );
}


LPWSTR
EfspGetCertDisplayInformation(
    IN PCCERT_CONTEXT pCertContext
    )
/*++

Routine Description:

    Returns the display string from the passed certificate context.

Arguments:

    pCertContext - Supplies a pointer to an open certificate context.

Return Value:

    On success, pointer to display string.  Caller must call
    LsapFreeLsaHeap() to free.

    NULL on failure.

--*/

{
    DWORD rc;
    LPWSTR UserDispName = NULL;

    rc = EfsGetCertNameFromCertContext(
                pCertContext,
                &UserDispName
                );

    if (rc == ERROR_SUCCESS) {
        return UserDispName;
    } else {
        SetLastError(rc);
        return NULL;
    }

}

PBYTE
GetCertHashFromCertContext(
    IN PCCERT_CONTEXT pCertContext,
    OUT PDWORD pcbHash
    )
/*++

Routine Description:

    Helper routine, takes a cert context and extracts the hash.

Arguments:

    pCertContext - Supplies the cert context.

    pcbHash - Returns the length in bytes of the returned hash.

Return Value:

    Returns a pointer to a hash block allocated out of heap memory,
    or NULL if either the attempt to get the hash failed or the attempt
    to allocate memory failed.

    Call GetLastError() for more details in case of failure.

--*/
{
    PBYTE pbHash = NULL;
    *pcbHash = 0;

    if (CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_HASH_PROP_ID,
                 NULL,
                 pcbHash
                 )) {

        pbHash = (PBYTE)LsapAllocateLsaHeap( *pcbHash );

        if (pbHash != NULL) {

            if (!CertGetCertificateContextProperty(
                         pCertContext,
                         CERT_HASH_PROP_ID,
                         pbHash,
                         pcbHash
                         )) {

                LsapFreeLsaHeap( pbHash );
                pbHash = NULL;
                *pcbHash = 0;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( pbHash );
}

PCERT_PUBLIC_KEY_INFO
     ExportPublicKeyInfo(
     IN HCRYPTPROV hProv,
     IN DWORD dwKeySpec,
     IN DWORD dwCertEncodingType,
     IN OUT DWORD *pcbInfo
     )
{
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;

    if ( CryptExportPublicKeyInfo(
         hProv,
         dwKeySpec,
         dwCertEncodingType,
         NULL,
         pcbInfo)) {

        pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) LsapAllocateLsaHeap(*pcbInfo);

        if (pPubKeyInfo) {

            if (!CryptExportPublicKeyInfo( hProv,
                 dwKeySpec,
                 dwCertEncodingType,
                 pPubKeyInfo,
                 pcbInfo)) {

                LsapFreeLsaHeap( pPubKeyInfo );
                pPubKeyInfo = NULL;
                *pcbInfo = 0;
            }
        }
    }

    return ( pPubKeyInfo );
}

BOOL
EncodeAndAlloc(
    DWORD dwEncodingType,
    LPCSTR lpszStructType,
    const void * pvStructInfo,
    PBYTE * pbEncoded,
    PDWORD pcbEncoded
    )
{
    BOOL b = FALSE;

    if (CryptEncodeObject(
          dwEncodingType,
          lpszStructType,
          pvStructInfo,
          NULL,
          pcbEncoded )) {

        *pbEncoded = (PBYTE)LsapAllocateLsaHeap( *pcbEncoded );

        if (*pbEncoded) {

            if (CryptEncodeObject(
                  dwEncodingType,
                  lpszStructType,
                  pvStructInfo,
                  *pbEncoded,
                  pcbEncoded )) {

                b = TRUE;

            } else {

                LsapFreeLsaHeap( *pbEncoded );
                *pbEncoded = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( b );
}

DWORD
EfsMakeCertNames(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT LPWSTR *DispInfo,
    OUT LPWSTR *SubjectName,
    OUT LPWSTR *UPNName
    )
{
    DWORD rc = ERROR_SUCCESS;
    
    *DispInfo = NULL;
    *UPNName = NULL;

    if (pEfsUserInfo->bDomainAccount) {

        //
        // Domain Account
        //

        HRESULT hr;
        HANDLE  hDS = NULL;
        DS_NAME_RESULT* UserName = NULL;

        hr = DsBind(NULL, NULL, &hDS);
        if (hr == NO_ERROR) {
            
            rc = DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_SID_OR_SID_HISTORY_NAME,
                    DS_USER_PRINCIPAL_NAME,
                    1,
                    &(pEfsUserInfo->lpUserSid),
                    &UserName
                    );

            if (ERROR_SUCCESS == rc) {

                if (UserName->rItems[0].status == DS_NAME_NO_ERROR) {

                    *UPNName = (LPWSTR) LsapAllocateLsaHeap((wcslen(UserName->rItems[0].pName) + 1) * sizeof (WCHAR));
                    *DispInfo = (LPWSTR) LsapAllocateLsaHeap(
                                    (wcslen(UserName->rItems[0].pName) +
                                    wcslen(pEfsUserInfo->lpUserName) +
                                    3) * sizeof (WCHAR));
                    *SubjectName = (LPWSTR) LsapAllocateLsaHeap((wcslen(pEfsUserInfo->lpUserName)+4) * sizeof (WCHAR));
    
                    if (*UPNName && *DispInfo && *SubjectName ){
                        wcscpy(*UPNName, UserName->rItems[0].pName);
                        wcscpy(*DispInfo, pEfsUserInfo->lpUserName);
                        wcscat(*DispInfo, L"(");
                        wcscat(*DispInfo, *UPNName);
                        wcscat(*DispInfo, L")");
                        wcscpy(*SubjectName, L"CN=");
                        wcscat(*SubjectName, pEfsUserInfo->lpUserName);
                    } else {
    
                        if (*UPNName) {
                            LsapFreeLsaHeap( *UPNName );
                            *UPNName = NULL;
                        }
                        if (*DispInfo) {
                            LsapFreeLsaHeap( *DispInfo );
                            *DispInfo = NULL;
                        }
                        if (*SubjectName) {
                            LsapFreeLsaHeap( *SubjectName );
                            *SubjectName = NULL;
                        }
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }

                }


                if (UserName){
                    DsFreeNameResult(UserName);
                    UserName = NULL;
                }

            }

            DsUnBindW( &hDS );

        }
    }


    if (NULL == *UPNName) {

        //
        // If Local Account, let the UPNNmae be User@Computer. DispInfo be User(User@Computer).
        // Else let the UPNName be User@Domain. DispInfo be User(User@Domain)
        //

        *UPNName = (LPWSTR) LsapAllocateLsaHeap(
                        (wcslen(pEfsUserInfo->lpUserName) + 
                        wcslen(pEfsUserInfo->lpDomainName) + 
                        2) * sizeof (WCHAR));
        *DispInfo = (LPWSTR) LsapAllocateLsaHeap(
                        (wcslen(pEfsUserInfo->lpDomainName) +
                        wcslen(pEfsUserInfo->lpUserName) * 2 +
                        4) * sizeof (WCHAR));
        *SubjectName = (LPWSTR) LsapAllocateLsaHeap(
                        (wcslen(pEfsUserInfo->lpUserName)+
                        4) * sizeof (WCHAR));

        if (*UPNName && *DispInfo && *SubjectName){
            wcscpy(*UPNName, pEfsUserInfo->lpUserName);
            wcscat(*UPNName, L"@");
            wcscat(*UPNName, pEfsUserInfo->lpDomainName);
            wcscpy(*DispInfo, pEfsUserInfo->lpUserName);
            wcscat(*DispInfo, L"(");
            wcscat(*DispInfo, *UPNName);
            wcscat(*DispInfo, L")");
            wcscpy(*SubjectName, L"CN=");
            wcscat(*SubjectName, pEfsUserInfo->lpUserName);
        } else {

            if (*UPNName) {
                LsapFreeLsaHeap( *UPNName );
                *UPNName = NULL;
            }
            if (*DispInfo) {
                LsapFreeLsaHeap( *DispInfo );
                *DispInfo = NULL;
            }
            if (*SubjectName) {
                LsapFreeLsaHeap( *SubjectName );
                *SubjectName = NULL;
            }
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    }
    return rc;
}


#if 0

LPWSTR
MakeDNName(
    BOOLEAN RecoveryKey,
    IN  PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    Fabricates a display name for a locally built self-signed cert

Arguments:

    RecoveryKey - Specifies if this is a recovery key or not.

Return Value:

    Returns a string containing a display name, or NULL.

--*/

{
    NTSTATUS    Status;
    LPWSTR      DNName = NULL;
    LPCWSTR     DNNameTemplate = L"CN=%ws,L=EFS,OU=EFS File Encryption Certificate";
    DWORD       cbDNName = 0;

    if (RecoveryKey) {


        cbDNName = (wcslen( DNNameTemplate ) + 1) * sizeof( WCHAR ) + (wcslen( EfsComputerName ) + 1) * sizeof( WCHAR );

        DNName = (LPWSTR)LsapAllocateLsaHeap( cbDNName );

        if (DNName) {

            swprintf( DNName, DNNameTemplate, EfsComputerName );

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

    } else {


            //
            // This will be an overestimate, but only by a little.
            //

            cbDNName = (wcslen( DNNameTemplate ) * sizeof( WCHAR )) + (wcslen( pEfsUserInfo->lpUserName ) + 1) * sizeof( WCHAR );

            DNName = (LPWSTR)LsapAllocateLsaHeap( cbDNName );

            if (DNName != NULL) {

                swprintf( DNName, DNNameTemplate, pEfsUserInfo->lpUserName );

            } else {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }


    }

    return( DNName );
}

#endif


DWORD
EfsFindCertOid(
    IN LPSTR pEfsCertOid,
    IN PCCERT_CONTEXT pCertContext,
    OUT BOOL *OidFound
    )

/*++

Routine Description:

    This routine takes a cert context and an Efs Oid. It will check if the cert has the Efs Oid or not.
    
Arguments:

    pEfsCertOid - Efs Oid to be searched for.
    
    pCertContext - The cert to be searched for.

    OidFound - The result. TRUE if the oid is found.

Return Value:

    Win32 Error code.
    
--*/
{
    BOOL bRet;
    PCERT_ENHKEY_USAGE pUsage;
    DWORD pcbUsage = 0;
    DWORD rc = ERROR_SUCCESS;
    DWORD ii;

    *OidFound = FALSE;

    bRet = CertGetEnhancedKeyUsage(
               pCertContext,
               0,
               NULL,
               &pcbUsage
               );
    if (bRet) {
        pUsage = (PCERT_ENHKEY_USAGE) LsapAllocateLsaHeap(pcbUsage);
        if (pUsage) {
            bRet = CertGetEnhancedKeyUsage(
                       pCertContext,
                       0,
                       pUsage,
                       &pcbUsage
                       );
            if (bRet){
                for (ii=0; ii<pUsage->cUsageIdentifier;ii++) {
                    if (!strcmp(pUsage->rgpszUsageIdentifier[ii], pEfsCertOid)){

                        //
                        // We found the OID
                        //
                        *OidFound = TRUE;
                        break;
                    }
                }

            } else {
                rc = GetLastError();
            }

            LsapFreeLsaHeap(pUsage);

        } else {
           rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        rc = GetLastError();
    }
    return rc;
}


DWORD
GetKeyInfoFromCertHash(
    IN OUT PEFS_USER_INFO pEfsUserInfo,
    IN  PBYTE        pbHash,
    IN  DWORD        cbHash,
    OUT HCRYPTKEY  * hKey               OPTIONAL,
    OUT HCRYPTPROV * hProv              OPTIONAL,
    OUT LPWSTR     * ContainerName      OPTIONAL,
    OUT LPWSTR     * ProviderName       OPTIONAL,
    OUT LPWSTR     * DisplayInformation OPTIONAL,
    OUT PBOOLEAN     pbIsValid          OPTIONAL
    )
/*++

Routine Description:

    This routine takes a certificate hash and extracts from it information
    about the key it represents.  If the key information from this
    cert does not exist in the current context, it will return an error.

Arguments:

    pEfsUserInfo - User Information

    pbHash - Takes a pointer to the certificate hash.

    cbHash - The length in bytes of the certificate hash.

    hKey - Returns the handle to the key corresponding to this
        certificate.  Must be passed of hProv is passed.

    hProv - Returns the handle to the context corresponding to this
        certificate.  Must be passed of hKey is passed.

    ContainerName - Returns a string with the name of the container of the
        key in this certificate.

    ProviderName - Returns a string with the name of the provider of the
        key in this certificate.

    DisplayInformation - Returns the display information for the certificate.

    pbIsValid - If present, causes the cert to be validity checked and the
        results returned.

Return Value:

    ERROR_SUCCESS - The passed certificate is in the current user's MY
        store and the key it represents is in his context.

    !ERROR_SUCCESS - Either the certificate could not be found in the
        user's MY store, or the key in the certificate could not be
        instantiated.

--*/

{
    PCCERT_CONTEXT pCertContext;

    //
    // Don't trust CryptoAPI to set last error properly,
    // keep track of success and failure on our own.
    //

    BOOLEAN b = TRUE;
    BOOLEAN CreateCache = FALSE;
    BOOLEAN LocalCertValidated = FALSE;
    BOOLEAN DataNotCached = TRUE;
    DWORD rc = ERROR_SUCCESS;
    DWORD rc2 = ERROR_SUCCESS;

    HCRYPTKEY  hLocalKey = NULL;
    HCRYPTPROV hLocalProv = NULL;
    LPWSTR     LocalContainerName = NULL;
    LPWSTR     LocalProviderName = NULL;
    LPWSTR     LocalDisplayInformation = NULL;

    //
    // Output parameters
    //

    if (ARGUMENT_PRESENT(ContainerName)) {
        *ContainerName = NULL;
    }

    if (ARGUMENT_PRESENT(ProviderName)) {
        *ProviderName = NULL;
    }

    if (ARGUMENT_PRESENT(DisplayInformation)) {
        *DisplayInformation = NULL;
    }

    if (ARGUMENT_PRESENT(hProv)) {
        *hProv = NULL;
    }

    if (ARGUMENT_PRESENT(hKey)) {
        *hKey = NULL;
    }

    if (ARGUMENT_PRESENT( pbIsValid )){
        *pbIsValid = FALSE;
    }

    //
    //  Check if a cache node is available
    //

    if (!pEfsUserInfo->UserCacheStop) {
        if (pEfsUserInfo->pUserCache) {

            //
            // The user has a cache, check if the Hash matches
            //

            if ( pEfsUserInfo->pUserCache->cbHash == cbHash ) {

                if(RtlEqualMemory( pEfsUserInfo->pUserCache->pbHash, pbHash, cbHash)){

                    //
                    // Cache is valid. Use the cache
                    //


                    if (ARGUMENT_PRESENT( pbIsValid )){
                        *pbIsValid = (pEfsUserInfo->pUserCache->CertValidated == CERT_VALIDATED);
                    }
                    return ERROR_SUCCESS;

                }

                //
                // User might use an old key, do not put in the cache.
                //

            }

        } else {

            CreateCache = TRUE;

        }
    }


    //
    // Find our cert via the hash
    //

    pCertContext = GetCertContextFromCertHash(
                        pbHash,
                        cbHash,
                        CERT_SYSTEM_STORE_CURRENT_USER
                        );

    if (pCertContext != NULL) {

        PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );

        if (pCryptKeyProvInfo != NULL) {

            //
            // Copy out the container name and provider name if requested.
            //


            if (pCryptKeyProvInfo->pwszContainerName) {
               LocalContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
               if (LocalContainerName != NULL) {
                  wcscpy( LocalContainerName, pCryptKeyProvInfo->pwszContainerName );
               } else {
                  rc = ERROR_NOT_ENOUGH_MEMORY;
                  b = FALSE;
               }
            }
            if (b && pCryptKeyProvInfo->pwszProvName) {
               LocalProviderName =  (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
               if (LocalProviderName != NULL) {
                  wcscpy( LocalProviderName,  pCryptKeyProvInfo->pwszProvName );
               }
               else {
                  rc = ERROR_NOT_ENOUGH_MEMORY;
                  b = FALSE;
               }
            }
            if (!(LocalDisplayInformation = EfspGetCertDisplayInformation( pCertContext ))) {

               //
               // At least for now, we do not accept Cert without display name
               //

               rc = GetLastError();
               b = FALSE;
            }

            //
            // Get the key information
            //

            if (b) {

                if (CryptAcquireContext( &hLocalProv, pCryptKeyProvInfo->pwszContainerName, pCryptKeyProvInfo->pwszProvName, PROV_RSA_FULL, CRYPT_SILENT)) {

                    if (!CryptGetUserKey(hLocalProv, AT_KEYEXCHANGE, &hLocalKey)) {

                        rc = GetLastError();
                        b = FALSE;
                    }

                } else {

                    rc = GetLastError();
                    b = FALSE;
                }

            }

            if (b) {

                if ( ARGUMENT_PRESENT( pbIsValid ) || CreateCache ) {

                    //
                    // Do cert validity checking. Check time and usage.
                    //
    
                    if ( CertVerifyTimeValidity(
                            NULL,
                            pCertContext->pCertInfo
                            )){

                        rc2 = CERT_E_EXPIRED;

                        //b = FALSE;

                    } else {

                        //
                        // Test the cert usage here.
                        // CERT_E_WRONG_USAGE
                        //

                        BOOL OidFound;
                        

                        rc = EfsFindCertOid(
                                szOID_KP_EFS,
                                pCertContext,
                                &OidFound
                                );

                        if (ERROR_SUCCESS == rc) {
                            if (OidFound) {

                                LocalCertValidated = TRUE;

                            }

                        } else {

                            b = FALSE;

                        }

                        
                    }


                    if (ARGUMENT_PRESENT( pbIsValid )) {

                        //
                        // We need the validation info.
                        //

                        *pbIsValid = LocalCertValidated;

                    }

                }

                if ( CreateCache ) {

                    DWORD    certFlag;
    
                    //
                    // Todetermine if we can put the data in cache.
                    //

                    if (CurrentHashOK(pEfsUserInfo, pbHash, cbHash, &certFlag)) {

                        //
                        // This pbHash is in the user's key or has been put in. Let's create the cache node.
                        //

                        PUSER_CACHE pCacheNode;
                        PBYTE pbWkHash;
                        DWORD ImpersonationError = 0;

                        if (certFlag != CERTINLMTRUSTEDSTORE) {

                            DWORD sevRc;

                            //
                            // The cert is not in the LM Trusted store. Upgrade system from Win2K, or Beta 1 Whistler.
                            //

                            if (ERROR_SUCCESS == (sevRc = EfsAddCertToTrustStoreStore(pCertContext, &ImpersonationError))) {
                                EfsMarkCertAddedToStore(pEfsUserInfo);
                            } else {
                                if (ImpersonationError) {

                                    //
                                    // Got in trouble. We could not impersonate back.
                                    //

                                    ASSERT(FALSE);
                                    rc = sevRc;
                                    b = FALSE;

                                }
                            }

                        }

                        if (!ImpersonationError) {

                            pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));
    
                            pbWkHash = (PBYTE) LsapAllocateLsaHeap(cbHash);
    
                            if (pCacheNode && pbWkHash) {
        
                                memset( pCacheNode, 0, sizeof( USER_CACHE ));
                                RtlCopyMemory(pbWkHash, pbHash, cbHash);
    
    
                                if (NT_SUCCESS( NtQuerySystemTime(&(pCacheNode->TimeStamp)))){
    
                                    if (EfspInitUserCacheNode(
                                                 pCacheNode,
                                                 pbWkHash,
                                                 cbHash,
                                                 LocalContainerName,
                                                 LocalProviderName,
                                                 LocalDisplayInformation,
                                                 pCertContext,
                                                 hLocalKey,
                                                 hLocalProv,
                                                 &(pEfsUserInfo->AuthId),
                                                 LocalCertValidated? CERT_VALIDATED:CERT_VALIDATION_FAILED
                                                 )){
    
                                        //
                                        //  Cache node created and ready for use. Do not delete or close the info
                                        //  we just got.
                                        //
    
                                        LocalContainerName = NULL;
                                        LocalProviderName = NULL;
                                        LocalDisplayInformation = NULL;
                                        hLocalKey = NULL;
                                        hLocalProv = NULL;
                                        pEfsUserInfo->pUserCache = pCacheNode;
    
                                        pCertContext = NULL; 
                                        DataNotCached = FALSE;
                                        rc = ERROR_SUCCESS;
                                        b = TRUE;              // We can have a non-validated cache node for the use of open file
    
                                    } else {
    
                                        LsapFreeLsaHeap(pCacheNode);
                                        LsapFreeLsaHeap(pbWkHash);
                                        pbWkHash = NULL;
                                        pCacheNode = NULL;
    
                                    }
    
                                } else {
    
                                    LsapFreeLsaHeap(pCacheNode);
                                    LsapFreeLsaHeap(pbWkHash);
                                    pbWkHash = NULL;
                                    pCacheNode = NULL;
    
                                }
        
                            } else {
                                if (pCacheNode) {
                                   LsapFreeLsaHeap(pCacheNode);
                                   pCacheNode = NULL;
                                }
                                if (pbWkHash) {
                                    LsapFreeLsaHeap(pbWkHash);
                                    pbWkHash = NULL;
                                }
                            }
                        }

                    } 
    
                }

                if (DataNotCached && b) {

                    //
                    // We need to returned the data to outside
                    //


                    if (ARGUMENT_PRESENT(ContainerName)) {

                        *ContainerName = LocalContainerName;
                        LocalContainerName = NULL;

                    }
            
                    if (ARGUMENT_PRESENT(ProviderName)) {
                        *ProviderName = LocalProviderName;
                        LocalProviderName = NULL;
                    }
            
                    if (ARGUMENT_PRESENT(DisplayInformation)) {
                        *DisplayInformation = LocalDisplayInformation;
                        LocalDisplayInformation = NULL;
                    }
            
                    if (ARGUMENT_PRESENT(hKey)) {
                        *hKey = hLocalKey;
                        hLocalKey = NULL;

                    }
            
                    if (ARGUMENT_PRESENT(hProv)) {
                        *hProv = hLocalProv;
                        hLocalProv = NULL;
                    }

                }

            }

            LsapFreeLsaHeap( pCryptKeyProvInfo );


        } else {

            rc = GetLastError();
            b = FALSE;
        }

        if (pCertContext) {

            CertFreeCertificateContext( pCertContext );

        }


    } else {

        rc = GetLastError();
        b = FALSE;
    }

    if (!b) {

        ASSERT( rc != ERROR_SUCCESS );

        //
        // Something failed, cleanup the stuff we were going to return
        //

        if ( LocalContainerName) {
            LsapFreeLsaHeap( LocalContainerName );
        }

        if (LocalProviderName) {
            LsapFreeLsaHeap( LocalProviderName );
        }

        if (LocalDisplayInformation) {
            LsapFreeLsaHeap( LocalDisplayInformation );
        }

        if (hLocalKey) {
            CryptDestroyKey( hLocalKey );
        }

        if (hLocalProv) {
            CryptReleaseContext( hLocalProv, 0 );
        }
    }

    if (ARGUMENT_PRESENT( pbIsValid ) && !LocalCertValidated ) {
        if (rc == ERROR_SUCCESS) {
            rc = rc2;
        }
    }

    return( rc );
}


PCRYPT_KEY_PROV_INFO
GetKeyProvInfo(
    PCCERT_CONTEXT pCertContext
    )

/*++

Routine Description:

    This routine will extract the Key Provider Information from
    the passed certificate context.

Arguments:

    pCertContext - Supplies a pointer to a certificate context.

Return Value:

    Returns a pointer to a PCRYPT_KEY_PROV_INFO structure on success,
        otherwise returns NULL, which usually means that the certificate
        did not have the context property we were looking for (meaning
        that it probably isn't an EFS certificate).
--*/

{

    DWORD cbData = 0;
    BOOL b;
    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;

    b = CertGetCertificateContextProperty(
             pCertContext,
             CERT_KEY_PROV_INFO_PROP_ID,
             NULL,
             &cbData
             );

    if (b) {

        pCryptKeyProvInfo = (PCRYPT_KEY_PROV_INFO)LsapAllocateLsaHeap( cbData );

        if (pCryptKeyProvInfo != NULL) {

            b = CertGetCertificateContextProperty(
                     pCertContext,
                     CERT_KEY_PROV_INFO_PROP_ID,
                     pCryptKeyProvInfo,
                     &cbData
                     );

            if (!b) {

                LsapFreeLsaHeap( pCryptKeyProvInfo );
                pCryptKeyProvInfo = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return ( pCryptKeyProvInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\encrypt.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    encrypt.cxx

Abstract:

    Contains routine to check whether encryption is supported on this
    system or not.

Author:

    Mike Swift (MikeSw) 2-Aug-1994

Revision History:

    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\common\encrypt.c
    MikeSw    06-Oct-1996 Stolen from security\msv_sspi\encrypt.cxx

--*/
#include <lsapch.hxx>

extern "C"
BOOLEAN
LsapIsEncryptionPermitted(
    VOID
    )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }
    CountryValue = (ULONG) wcstol(CountryCode,NULL,10);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\efssrv.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efssrv.cxx                                             

Abstract:

    EFS (Encrypting File System) Server

Author:

    Robert Reichel      (RobertRe)     
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <efsstruc.h>
#include <lmaccess.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <userenv.h>
#include <userenvp.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
}

#define ALGORITHM_ID      TEXT("AlgorithmID")
#define KEYCACHEPERIOD    TEXT("KeyCacheValidationPeriod")
#define FIPSPOLICY        TEXT("FipsAlgorithmPolicy")
#define EFSCONFIG         TEXT("EfsConfiguration")
#define EFSLASTGOODCONFIG TEXT("LastGoodEfsConfiguration")

#define TRUSTEDPEOPLE     TEXT("TrustedPeople")

//
// The following key GPOSTATUSKEY is a temp solution. GPO should provide an API to tell people
// if the GP propagation succeeded or not.
//

#define GPOSTATUSKEY      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}")
#define GPSTATUS          TEXT("Status")

//
// EFS key
//

#define EFSMACHINEKEY     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\EFS")
#define EFSPOLKEY         TEXT("SOFTWARE\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\EFS")

#define POLICYUSEFIPS     1
#define DISABLEEFS        0x00000001

// Default cache length is 3600 seconds

#define MAXCACHELENGTH    86400 * 7  // Max cache period - 7 Days. We only check time valid.
#define MINCACHELENGTH    1800       // Min cache period - 0.5 Hours

#define  TIME_UNIT 10000000         // 1 TIME_UNIT == 1 second

extern LONG RecoveryCertIsValidating;
extern HANDLE EfsWaitHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// Define how long our FEKs can be.  An FEK will be allocated into a fixed    /
// size buffer, but only a certain number of bits of entropy may be used in   /
// the export version.                                                        /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

//
// This number affects the FEK generation algorithm.  It represents the number
// of bits of entropy in the key.
//

const EXPORT_KEY_STRENGTH = 56;
const DOMESTIC_KEY_STRENGTH = 128;
const EXPORT_DESX_SALT_LENGTH = 9;
const DES3_KEY_STRENGTH = 168;
const AES_KEY_STRENGTH_256 = 256;

const DWORD WAITFORCERTVALIDATE = 10000;

#ifndef LSASRV_EXPORT

    const DWORD KeyEntropy = DOMESTIC_KEY_STRENGTH;

#else

    const DWORD KeyEntropy = EXPORT_KEY_STRENGTH;

#endif

LONG EFSDebugLevel = 0;


ALG_ID  EfsAlgInForce = CALG_AES_256;
extern "C" BOOLEAN EfsDisabled = FALSE;

//
// Current recovery policy
//

RTL_RESOURCE RecoveryPolicyResource;

CURRENT_RECOVERY_POLICY CurrentRecoveryPolicy;

DWORD   MissingRecoveryPolicyLogged = 0;

//
// Functions in EFSAPI.CXX
//

BOOLEAN
EncryptFSCTLData(
    IN ULONG Fsctl,
    IN ULONG Psc,
    IN ULONG Csc,
    IN PVOID EfsData,
    IN ULONG EfsDataLength,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );

BOOLEAN
SendHandle(
    IN HANDLE Handle,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

BOOLEAN
SendEfs(
    IN PEFS_KEY Fek,
    IN PEFS_DATA_STREAM_HEADER Efs,
    OUT PUCHAR EfsData,
    OUT PULONG EfsDataLength
    );

BOOLEAN
SendHandleAndEfs(
    IN HANDLE Handle,
    IN PEFS_DATA_STREAM_HEADER Efs,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

//
// Function prototypes in this module
//

BOOLEAN
CreatePublicKeyInformationThumbprint(
    IN PSID  pUserSid,
    IN PBYTE pbCertHash,
    IN DWORD cbCertHash,
    IN LPWSTR lpDisplayInformation OPTIONAL,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR ProviderName OPTIONAL,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    );

PBYTE
EncryptFEK(
    IN PEFS_KEY Fek,
    IN HCRYPTKEY hRSAKey,
    OUT PDWORD dwEncryptedFEKLength
    );

PEFS_KEY
ExtractFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTED_KEY EncryptedKey,
    IN BOOL CheckBits
    );

DWORD
ConstructEncryptedKey(
    IN PBYTE EncryptedFEK,
    IN DWORD dwEncryptedFEKLength,
    IN PEFS_PUBLIC_KEY_INFO PublicKeyInformation,
    IN PEFS_KEY_SALT pEfsKeySalt,
    OUT PENCRYPTED_KEY *EncryptedKey,
    IN OUT PDWORD EncryptedKeySize
    );

DWORD
ConstructKeyRing(
    IN PEFS_KEY Fek,
    IN DWORD KeyCount,
    IN LPWSTR KeyNames[] OPTIONAL,
    IN LPWSTR ProviderNames[] OPTIONAL,
    IN PBYTE PublicKeys[],
    IN DWORD PublicKeyLengths[],
    IN PBYTE pbHashes[],
    IN DWORD cbHashes[],
    IN LPWSTR lpDisplayInformation[],
    IN PSID  pSid[],
    IN BOOLEAN PublicKeyHandle,
    OUT PENCRYPTED_KEYS *KeyRing,
    OUT PDWORD KeyRingLength
    );

DWORD
ReformatPolicyInformation(
    PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo,
    PLSAPR_POLICY_DOMAIN_EFS_INFO * NewPolicyEfsInfo,
    PBOOLEAN Reformatted
    );

DWORD
InitRecoveryPolicy(
    VOID
    );


DWORD
ParseOldRecoveryData(
    IN  PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo OPTIONAL,
    OUT PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    );

VOID
DumpPublicKeyInfo(
    PEFS_PUBLIC_KEY_INFO PublicKeyInfo
    );

void
DumpRecoveryKey(
    PRECOVERY_KEY_1_1 pRecoveryKey
    );

PEFS_DATA_STREAM_HEADER
AssembleEfsStream(
    IN PENCRYPTED_KEYS pDDF,
    IN DWORD cbDDF,
    IN PENCRYPTED_KEYS pDRF,
    IN DWORD cbDRF,
    IN PEFS_KEY Fek
    );

PENCRYPTED_KEY
GetEncryptedKeyByIndex(
    PENCRYPTED_KEYS pEncryptedKeys,
    DWORD KeyIndex
    );

BOOL
DeleteEncryptedKeyByIndex(
   IN PEFS_DATA_STREAM_HEADER pEfs,
   IN DWORD KeyIndex,
   IN PEFS_KEY Fek,
   OUT PEFS_DATA_STREAM_HEADER * pNewEfs
   );

BOOLEAN
EqualEncryptedKeys(
    IN PENCRYPTED_KEYS SrcKeys, 
    IN PENCRYPTED_KEYS DstKeys, 
    IN DWORD           cbDstKeys
  );

//
// Server
//

VOID
EfsGetRegSettings(
    VOID
    )
/*++

Routine Description:

    This routine is called during server initialization to set
    the EFS encryption algorithm.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG rc;
    HKEY EfsKey;
    DWORD AlgId;
    DWORD CacheLength;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;
    

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                       0,
                       GENERIC_READ,
                       &EfsKey
                     );

    if (rc == ERROR_SUCCESS) {

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                FIPSPOLICY,
                NULL,
                &Type,
                (PUCHAR) &AlgId,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {

            if ( AlgId== POLICYUSEFIPS ) {
                EfsAlgInForce = CALG_3DES;
            }

        }
        RegCloseKey( EfsKey );
    }

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       EFSMACHINEKEY,
                       0,
                       GENERIC_READ,
                       &EfsKey
                     );
    if (rc == ERROR_SUCCESS) {

        if (EfsAlgInForce == CALG_AES_256) {

            //
            // FIPS Policy does not say we have to use FIPS. Let's check if user says EFS
            // should use specific algorithm.
            //

            SizeInfo = sizeof(DWORD);
            rc = RegQueryValueEx(
                    EfsKey,
                    ALGORITHM_ID,
                    NULL,
                    &Type,
                    (PUCHAR) &AlgId,
                    &SizeInfo
                    );
    
            if (rc == ERROR_SUCCESS) {
                switch (AlgId) {
    
                    case CALG_3DES:
    
                        EfsAlgInForce = CALG_3DES; //0x6603
                        break;
    
                    case CALG_DESX:
                        EfsAlgInForce = CALG_DESX; //0x6604
                        break;
    
                    case CALG_AES_256:
    
                        //
                        // Fall through intended
                        //
    
                    default:
                        // EfsAlgInForce = CALG_AES_256;//0x6610
                        break;
        
                }
            }
    
        }

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                KEYCACHEPERIOD,
                NULL,
                &Type,
                (PUCHAR) &CacheLength,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if ((CacheLength >= MINCACHELENGTH) && (CacheLength <= MAXCACHELENGTH)){
                CACHE_CERT_VALID_TIME = CacheLength * TIME_UNIT;
            }
        }

        //
        // Check if EFS is disabled in Policy
        //

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                EFSCONFIG,
                NULL,
                &Type,
                (PUCHAR) &EfsConfig,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if (EfsConfig & DISABLEEFS){
                EfsDisabled = TRUE;
            }
        }
        RegCloseKey( EfsKey );

    }
}

BOOL
EfsIsGpoGood(
    VOID
    )
/*++

Routine Description:

    This is a temp workaround to check if GP propagation succeeded or not.
    
    GP should provide an API to do this.
        
Arguments:

    Not used.

Return Value:

    None.

--*/
{
    LONG rc;
    HKEY PolKey;
    DWORD SizeInfo;
    DWORD PolStatus = 0;
    DWORD Type;
    BOOL  GoodPol = TRUE;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       GPOSTATUSKEY,
                       0,
                       GENERIC_READ,
                       &PolKey
                     );

    if (rc == ERROR_SUCCESS) {
    
        //
        // Check if EFS is disabled in Policy
        //

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                PolKey,
                GPSTATUS,
                NULL,
                &Type,
                (PUCHAR) &PolStatus,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if (PolStatus) {

                //
                //Last policy propagation failed
                //

                GoodPol = FALSE;
            }
        } else {

            //
            // Assuming last propagation failed
            //

            GoodPol = FALSE;
        }

        RegCloseKey( PolKey );

    } else {

        GoodPol = FALSE;
        
    }

    return GoodPol;
    
}

VOID
EfsRemoveKey(
    VOID
    )
/*++

Routine Description:

    This routine removes EFS Last Good Policy Key.
        
Arguments:

    No.
    
Return Value:

    No.
    
--*/
{

    LONG rc;
    HKEY EfsKey;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                   EFSMACHINEKEY,
                   0,
                   GENERIC_READ | KEY_SET_VALUE,
                   &EfsKey
                 );

    if (rc == ERROR_SUCCESS) {

        //
        // Delete the last good key
        //

        RegDeleteValue(
            EfsKey,            
            EFSLASTGOODCONFIG
            );

        RegCloseKey( EfsKey );

    } 
}

BOOL
EfsApplyGoodPolicy(
    IN BOOLEAN* pEfsDisabled
    )
/*++

Routine Description:

    This routine is a common routine to apply good policy data.
        
Arguments:

    pEfsDisabled -- Point to the global EfsDisabled. 
    
Return Value:

    TRUE if we applied the data. FALSE if no data available.

--*/
{

    LONG rc;
    HKEY EfsKey;
    HKEY EfsPolKey;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;
    BOOL PolicyValueApplied = FALSE;

    //
    // Open EFS policy key
    //

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       EFSPOLKEY,
                       0,
                       GENERIC_READ,
                       &EfsPolKey
                     );

    if (rc == ERROR_SUCCESS) {

        //
        // Let's try to get the latest value
        //


        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsPolKey,
                EFSCONFIG,
                NULL,
                &Type,
                (PUCHAR) &EfsConfig,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {

            PolicyValueApplied = TRUE;

            if (EfsConfig & DISABLEEFS){

                if (!(*pEfsDisabled)) {
                    *pEfsDisabled = TRUE;
                }

            } else {

                if (*pEfsDisabled) {
                    *pEfsDisabled = FALSE;
                }

            }

            //
            // We need to update our LAST Good key.
            //

            DWORD Disposition = 0;
                    
            rc = RegCreateKeyEx(
                     HKEY_LOCAL_MACHINE,
                     EFSMACHINEKEY,
                     0,
                     TEXT("REG_SZ"),
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS,
                     NULL,
                     &EfsKey,
                     &Disposition    // address of disposition value buffer
                     );

            if (rc == ERROR_SUCCESS) {

                //
                // OK. Let's upadte the value
                //

                RegSetValueEx(
                    EfsKey,
                    EFSLASTGOODCONFIG,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&EfsConfig,
                    sizeof(DWORD)
                    );

                RegCloseKey( EfsKey );

            }

        }

        RegCloseKey( EfsPolKey );

    } 
        
    return (PolicyValueApplied);

}

VOID
EfsApplyLastPolicy(
    IN BOOLEAN *pEfsDisabled
    )

/*++

Routine Description:

    This routine is called during boot init time.
        
Arguments:

    pEfsDisabled -- Point to the global EfsDisabled. May be changed to a structure pointer later
                    to support more EFS policy vars.

Return Value:

    None.

--*/
{

    LONG rc;
    HKEY EfsKey;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;

    if (EfsIsGpoGood()) {

        //
        // We got a good policy.
        //

        BOOL PolicyValueApplied;

        PolicyValueApplied = EfsApplyGoodPolicy(
                                pEfsDisabled
                                );
            
        if (!PolicyValueApplied) {

            //
            // Policy key is missing or value removed. We need to delete the last good value.
            // The last good value could be non-existing. It does not hurt to try again during
            // the boot.
            //

            EfsRemoveKey();
        
        }

    } else {

        //
        // Last Policy propagation failed. Tried to get the last good one if there is one.
        //

        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       EFSMACHINEKEY,
                       0,
                       GENERIC_READ,
                       &EfsKey
                     );

        if (rc == ERROR_SUCCESS) {

            SizeInfo = sizeof(DWORD);
            rc = RegQueryValueEx(
                    EfsKey,
                    EFSLASTGOODCONFIG,
                    NULL,
                    &Type,
                    (PUCHAR) &EfsConfig,
                    &SizeInfo
                    );
    
            if (rc == ERROR_SUCCESS) {
                if (EfsConfig & DISABLEEFS){

                    if (!(*pEfsDisabled)) {
                        *pEfsDisabled = TRUE;
                    }

                } else {

                    if (*pEfsDisabled) {
                        *pEfsDisabled = FALSE;
                    }

                }
            }

            RegCloseKey( EfsKey );

        }
    }
}

VOID
EfsGetPolRegSettings(
    IN PVOID pEfsPolCallBack,
    IN BOOLEAN timeExpired
    )
/*++

Routine Description:

    This routine is called during policy propagation.
        
Arguments:

    pEfsDisabled -- Point to a structure EFS_POL_CALLBACK.
                    
    timeExpired -- FALSE if trigged by the event.

Return Value:

    None.

--*/
{

    LONG rc;
    HKEY EfsKey;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;
    BOOLEAN * CrntEfsDisabled = ((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsDisable; 

    if (timeExpired) {

        //
        // May be killed.
        //

        if (*(((PEFS_POL_CALLBACK)pEfsPolCallBack)->EfsPolicyEventHandle)) {
            UnregisterGPNotification(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));
            CloseHandle(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));
            *(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle) = 0;
        }
        if (EfsWaitHandle) {
            RtlDeregisterWait(EfsWaitHandle);
            EfsWaitHandle = 0;
        }
        return;
    }

    if (EfsIsGpoGood()) {

        //
        // We got a good policy.
        //

        BOOL PolicyValueApplied;

        PolicyValueApplied = EfsApplyGoodPolicy(
                                CrntEfsDisabled
                                );
            
        if (!PolicyValueApplied) {

            //
            // Policy key is missing or value removed. We need to delete the last good value.
            //

            rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           EFSMACHINEKEY,
                           0,
                           GENERIC_READ | KEY_SET_VALUE,
                           &EfsKey
                         );

            if (rc == ERROR_SUCCESS) {

                //
                // Set back the default value first.
                //

                SizeInfo = sizeof(DWORD);
                rc = RegQueryValueEx(
                        EfsKey,
                        EFSCONFIG,
                        NULL,
                        &Type,
                        (PUCHAR) &EfsConfig,
                        &SizeInfo
                        );
        
                if (rc == ERROR_SUCCESS) {
                    if (EfsConfig & DISABLEEFS){
    
                        if (!(*CrntEfsDisabled)) {
                            *CrntEfsDisabled = TRUE;
                        }
    
                    } else {
    
                        if (*CrntEfsDisabled) {
                            *CrntEfsDisabled = FALSE;
                        }
    
                    }
                } else {

                    //
                    // No default value is treated as enable EFS
                    //

                    if (*CrntEfsDisabled) {
                        *CrntEfsDisabled = FALSE;
                    }
                }

                //
                // Delete the last good key
                //

                RegDeleteValue(
                    EfsKey,            
                    EFSLASTGOODCONFIG
                    );

                RegCloseKey( EfsKey );

            } else {

                //
                // No default key value. Enable EFS if not now.
                //

                if (*CrntEfsDisabled) {
                    *CrntEfsDisabled = FALSE;
                }

            }

        }
    }
    

    if (EfsWaitHandle) {

        //
        // Unregister the last one
        //

        RtlDeregisterWait(EfsWaitHandle);
        EfsWaitHandle = 0;

        //
        // Reset the notification event
        //

        if (*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle)) {

            ResetEvent(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));


            //
            // Reregister for a new one
            //

            if (!NT_SUCCESS(RtlRegisterWait(
                                &EfsWaitHandle,
                                *(((PEFS_POL_CALLBACK)pEfsPolCallBack)->EfsPolicyEventHandle), 
                                EfsGetPolRegSettings, 
                                pEfsPolCallBack, 
                                INFINITE, 
                                WT_EXECUTEONLYONCE))){
        
                //
                //  We couldn't use the thread pool. 
                //
    
                UnregisterGPNotification(*(((PEFS_POL_CALLBACK)pEfsPolCallBack)->EfsPolicyEventHandle));
                CloseHandle(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));
                *(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle) = 0;
    
            }
        }

    }

}


VOID
RecoveryInformationCallback(
    POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
/*++

Routine Description:

    Callback for when EFS Recovery policy information changes

Arguments:

    ChangedInfoClass - The info class that changed.

Return Value:

    None.

--*/

{
    InitRecoveryPolicy();
    return;
}


VOID
EfspRoleChangeCallback(
    POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
/*++

Routine Description:

    Callback for when the role of the machine in a domain changes.

Arguments:

    ChangedInfoClass - The info class that changed.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;

    Status = LsarQueryInformationPolicy(LsapPolicyHandle,
                                        PolicyPrimaryDomainInformation,
                                        (PLSAPR_POLICY_INFORMATION *)&PrimaryDomainInfo
                                        );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", Status));
    } else {
        if (PrimaryDomainInfo->Sid != NULL) {
            EfspInDomain = TRUE;
        } else {
            EfspInDomain = FALSE;
        }

        LsaFreeMemory( PrimaryDomainInfo );
    }

    return;
}

#if 0

    //
    // We may revisit this function in inheritance work. Keep it for now.
    //

BOOL
GetPublicKey(
     HCRYPTKEY hKey,
     PBYTE * PublicKeyBlob,
     PDWORD KeyLength
     )
/*++

Routine Description:

    Exports a public key

Arguments:

    hKey - Supplies the key handle to be exported

    PublicKeyBlob - Returns a buffer containing the exported key

    KeyLength - Returns the length of the exported key buffer in bytes.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    *KeyLength = 0;
    *PublicKeyBlob = NULL;

    if (hKey == NULL) {
        ASSERT( FALSE );
        return( FALSE );
    }

    BOOL b = CryptExportKey( hKey, 0, PUBLICKEYBLOB, 0, NULL, KeyLength );

    if (b) {

        *PublicKeyBlob = (PBYTE) LsapAllocateLsaHeap( *KeyLength );

        if (*PublicKeyBlob != NULL) {

            b = CryptExportKey( hKey, 0, PUBLICKEYBLOB, 0, *PublicKeyBlob, KeyLength );

            if (!b) {

                LsapFreeLsaHeap( *PublicKeyBlob );
                *PublicKeyBlob = NULL;
            }

        } else {

            b = FALSE;
        }
    }

    return( b );
}
#endif

inline
VOID
AcquireRecoveryPolicyReadLock()
{
    BOOL b = RtlAcquireResourceShared( &RecoveryPolicyResource, TRUE );

    ASSERT( b );
}

inline
VOID
ReleaseRecoveryPolicyReadLock()
{
    RtlReleaseResource( &RecoveryPolicyResource );
}

inline
VOID
ReleaseRecoveryData()
{
    ReleaseRecoveryPolicyReadLock();
}



DWORD  
GetRecoveryData(
    OUT PDWORD   dwKeyCount,
    OUT PDWORD   dwPolicyStatus,
    OUT PBYTE  * pbPublicKeys[],
    OUT DWORD  * cbPublicKeys[],
    OUT PBYTE  * pbHashes[],
    OUT DWORD  * cbHashes[],
    OUT LPWSTR * lpDisplayInfo[] OPTIONAL,
    OUT PSID   * pSid[] OPTIONAL
    )
/*++

Routine Description:

    This routine returns the current recovery data.  It takes a read
    lock on the recovery data so that it cannot be modified while in use.
    This lock must be freed by calling ReleaseRecoveryData().

Arguments:

    dwKeyCount - Returns the list of keys in the current recovery data.
    
    dwPolicyStatus - The status of the recovery policy.

    pbPublicKeys - Returns an array of pointers to exported public key blobs that will be used
        to encrypt the FEK.

    cbPublicKeys - Specifies the length (in bytes) of each of the keys returned
        in the PublicKeys array.
      
    pbHashes - Returns an array of pointers to the key hashes.
    
    cbHashes - Specifies the length (in bytes) of each of the key hashes.
    
    lpDisplayInfo - Recovery cert display information.

    pSid - Sids of the recovery agents

Return Value:

    ERROR_SUCCESS for succeed.

--*/

{
    AcquireRecoveryPolicyReadLock();

    //
    // Verify that all of the cert contexts are still valid.
    //
    // If any of them fail, say that there is no recovery
    // policy on the system.
    //

    DWORD i;
    BOOLEAN fResult = TRUE;

    LARGE_INTEGER  TimeStamp;

    if ( (*dwPolicyStatus = CurrentRecoveryPolicy.PolicyStatus) < RECOVERY_POLICY_OK) {

        *dwKeyCount   = CurrentRecoveryPolicy.dwKeyCount;
        *pbPublicKeys = CurrentRecoveryPolicy.pbPublicKeys;
        *cbPublicKeys = CurrentRecoveryPolicy.cbPublicKeys;
        *pbHashes     = CurrentRecoveryPolicy.pbHash;
        *cbHashes     = CurrentRecoveryPolicy.cbHash;

        if (lpDisplayInfo) {
            *lpDisplayInfo = CurrentRecoveryPolicy.lpDisplayInfo;
        }

        if (pSid) {
            *pSid = CurrentRecoveryPolicy.pSid;
        }
    
        return( ERROR_SUCCESS );
    }

    TimeStamp.QuadPart = 0;

    //
    // Check if we need validate the certs again
    //

    if ((NT_SUCCESS( NtQuerySystemTime(&TimeStamp)) && 
        (TimeStamp.QuadPart - CurrentRecoveryPolicy.TimeStamp.QuadPart > CACHE_CERT_VALID_TIME )) ||
        (CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED)){

        //
        // We only let one thread in here.
        //

        LONG IsCertBeingValidated;

        IsCertBeingValidated = InterlockedExchange(&RecoveryCertIsValidating, 1);

        if ((CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED) && (IsCertBeingValidated == 1)) {

            //
            // If the recovery cert has not been validated and some other thread is validating, 
            // let's wait for a 10 seconds.
            //

            Sleep(WAITFORCERTVALIDATE);
            if (CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED) {

                //
                // Not validated yet. Let's try to grab the lock. Let other thread to wait.
                //

                IsCertBeingValidated = InterlockedExchange(&RecoveryCertIsValidating, 1);
            }
            
        }

        if ( (IsCertBeingValidated != 1) || (CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED) ) {

            //
            // No thread is validating the cert, let's do it
            //

            for (i=0; i<CurrentRecoveryPolicy.dwKeyCount; i++) {

                //
                // We only check the time in the cert
                //

                LONG CertTimeValid;

                if (CertTimeValid = CertVerifyTimeValidity(
                                        NULL,
                                        CurrentRecoveryPolicy.pCertContext[i]->pCertInfo
                                        )){
                    if ( CertTimeValid > 0 ) {

                        DebugLog((DEB_WARN, "Expired certificate in recovery policy\n"));
                        *dwPolicyStatus = RECOVERY_POLICY_EXPIRED_CERTS;

                        fResult = FALSE;
                        break;
                    } else {
                        DebugLog((DEB_WARN, "Expired certificate in recovery policy\n"));
                        *dwPolicyStatus = RECOVERY_POLICY_NOT_EFFECT_CERTS;

                        fResult = FALSE;
                        break;
                    }
                }

            }
    
            //
            // When policy is propagated, the write lock is acquired. When we get here, we are having read lock and no one
            // is having the write lock. It is OK for threads stepping each other on writing CertValidated and TimeStamp here.
            // We are checking the validation in hours, a fraction of a second window here can be ignored.
            //
    
            if (CurrentRecoveryPolicy.dwKeyCount && fResult) {
                CurrentRecoveryPolicy.CertValidated = CERT_VALIDATED;
            } else if ( CurrentRecoveryPolicy.dwKeyCount ) {
                CurrentRecoveryPolicy.CertValidated = CERT_VALIDATION_FAILED;
            }
    
            if (CurrentRecoveryPolicy.CertValidated != CERT_NOT_VALIDATED) {
                CurrentRecoveryPolicy.TimeStamp.QuadPart = TimeStamp.QuadPart;
            }

            if (IsCertBeingValidated != 1) {
                InterlockedExchange(&RecoveryCertIsValidating, IsCertBeingValidated);
            }

        }

    }

    if (CurrentRecoveryPolicy.CertValidated == CERT_VALIDATED) {

        *dwKeyCount   = CurrentRecoveryPolicy.dwKeyCount;
        *pbPublicKeys = CurrentRecoveryPolicy.pbPublicKeys;
        *cbPublicKeys = CurrentRecoveryPolicy.cbPublicKeys;
        *pbHashes     = CurrentRecoveryPolicy.pbHash;
        *cbHashes     = CurrentRecoveryPolicy.cbHash;

        if (lpDisplayInfo) {
            *lpDisplayInfo = CurrentRecoveryPolicy.lpDisplayInfo;
        }

        if (pSid) {
            *pSid = CurrentRecoveryPolicy.pSid;
        }

    } else {

        *dwKeyCount = 0;
    }

    if ( ((RECOVERY_POLICY_EXPIRED_CERTS == *dwPolicyStatus) || 
          (RECOVERY_POLICY_NOT_EFFECT_CERTS == *dwPolicyStatus)) && 
         ( 0 == MissingRecoveryPolicyLogged) ) {

        DWORD  eventID = EFS_INVALID_RECOVERY_POLICY_ERROR;

        //
        // Log the fail to get the recovery policy
        //

        MissingRecoveryPolicyLogged = 1;

        EfsLogEntry(
          EVENTLOG_ERROR_TYPE,
          0,
          eventID,
          0,
          0,
          NULL,
          NULL
          );
    }

    return( ERROR_SUCCESS );
}


BOOLEAN
ConstructEFS(
    PEFS_USER_INFO pEfsUserInfo,
    PEFS_KEY Fek,
    PEFS_DATA_STREAM_HEADER ParentEfsStreamHeader,
    PEFS_DATA_STREAM_HEADER * EfsStreamHeader
    )
/*++

Routine Description:

    This routine will construct an EFS stream.  It is intended to be used
    whenever an entire EFS stream is required, such as when a new file is
    created.

    An EFS stream contains a header, a DDF (which contains current user key
    information), and a DRF (which contains recovery information).

Arguments:

    Fek - Supplies a pointer to a partially filled in EFS_KEY structure,
        specifying the length of the desired key and the algorithm that
        will be used with the key to encrypt the file.

        It is important that the algorithm field be filled in, since this
        key will be eventually encrypted in its entirety, and all the fields
        must be present for that to work.

    ParentEfsStreamHeader - Supplies the EFS stream from the containing directory,
        if one exists.  This parameter is not currently used, because we do
        not support inheritance from directories to files (yet).

    EfsStreamHeader - Returns a pointer to an EFS_DATA_STREAM_HEADER which is
        the head of an EFS stream.  This header is followed by variable length
        data containing the actual EFS data.


Return Value:

--*/
{

    LPWSTR      ContainerName        = NULL;
    HCRYPTPROV  hProv                = 0;
    HCRYPTKEY   hUserKey             = 0;
    LPWSTR      lpDisplayInformation = NULL;
    LPWSTR      ProviderName         = NULL;
    DWORD       ProviderType         = 0;
    PUCHAR      PublicKey            = NULL;
    HCRYPTKEY   hWkUserKey           = NULL;
    DWORD       rc;

    PEFS_DATA_STREAM_HEADER EFS = NULL;

    DWORD       DRFLength            = 0;
    DWORD       DDFLength            = 0;

    PENCRYPTED_KEYS pDRF = NULL;
    PENCRYPTED_KEYS pDDF = NULL;

    PBYTE       pbHash;
    DWORD       cbHash;

    BOOLEAN     b                    = FALSE;

    //
    // To build the DDF, we need the user's current key from the registry.
    // This routine will get the key information from the registry and open
    // the context containing the key.
    //

    rc = GetCurrentKey(
             pEfsUserInfo,
             &hUserKey,
             &hProv,
             &ContainerName,
             &ProviderName,
             &ProviderType,
             &lpDisplayInformation,
             &pbHash,
             &cbHash
             );

    if (ERROR_SUCCESS == rc) {

        if (hUserKey) {
            hWkUserKey = hUserKey;
        } else {

            //
            // Use the key in the cache
            //

            ASSERT(pEfsUserInfo->pUserCache);
            ASSERT(pEfsUserInfo->pUserCache->hUserKey);

            hWkUserKey = pEfsUserInfo->pUserCache->hUserKey;

        }

    } else {

        SetLastError( rc );
        return( FALSE );
    }

    //
    // Before we exit, make sure to clean up ContainerName, ProviderName, pbHash, hUserKey, hProv
    //
    
    rc = GenerateDRF( Fek, &pDRF, &DRFLength);

    if (ERROR_SUCCESS == rc) {

        LPWSTR      lpWkContainerName;
        LPWSTR      lpWkDisplayInformation;
        LPWSTR      lpWkProviderName;
        PBYTE       pbWkHash;
        DWORD       cbWkHash;

        if (hUserKey) {

            //
            // Do not use the cache
            //

            lpWkContainerName = ContainerName;
            lpWkProviderName =  ProviderName;
            lpWkDisplayInformation = lpDisplayInformation;
            pbWkHash = pbHash;
            cbWkHash = cbHash;

        } else {

            //
            // Use the cache
            //

            lpWkContainerName = pEfsUserInfo->pUserCache->ContainerName;
            lpWkProviderName =  pEfsUserInfo->pUserCache->ProviderName;
            lpWkDisplayInformation = pEfsUserInfo->pUserCache->DisplayInformation;
            pbWkHash = pEfsUserInfo->pUserCache->pbHash;
            cbWkHash = pEfsUserInfo->pUserCache->cbHash;

        }

        rc = ConstructKeyRing(
                Fek,
                1,
                &lpWkContainerName,
                &lpWkProviderName,
                (PBYTE *)&hWkUserKey,
                NULL,
                &pbWkHash,
                &cbWkHash,
                &lpWkDisplayInformation,
                &(pEfsUserInfo->pTokenUser->User.Sid),
                TRUE,
                &pDDF,
                &DDFLength
                );

        if (ERROR_SUCCESS == rc) {

            DWORD EfsLength = DDFLength + DRFLength + sizeof( EFS_DATA_STREAM_HEADER );

            //
            // Efs has to be a multiple of 8 in length to encrypt properly.
            //

            EfsLength = (EfsLength + 7) & 0xfffffff8;

            EFS = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( EfsLength );

            if (EFS != NULL) {

                memset( EFS, 0, sizeof( EFS_DATA_STREAM_HEADER ));

                EFS->Length = EfsLength;
                EFS->State = 0;            // used by the server
                EFS->EfsVersion = EFS_CURRENT_VERSION;

                RPC_STATUS RpcStatus = UuidCreate ( &EFS->EfsId );

                if (RpcStatus == ERROR_SUCCESS || RpcStatus == RPC_S_UUID_LOCAL_ONLY) {

                    //
                    // A "local-only" UUID is ok in this case
                    //

                    EFS->DataDecryptionField = (ULONG)sizeof(EFS_DATA_STREAM_HEADER );
                    memcpy( (PENCRYPTED_KEYS)((PBYTE)EFS + sizeof( EFS_DATA_STREAM_HEADER )), pDDF, DDFLength );

                    if ( 0 == DRFLength) {
                        EFS->DataRecoveryField = 0;
                    } else {
                        EFS->DataRecoveryField = (ULONG)(sizeof(EFS_DATA_STREAM_HEADER ) + DDFLength);
                        memcpy( (PENCRYPTED_KEYS)((PBYTE)EFS + sizeof( EFS_DATA_STREAM_HEADER ) + DDFLength ), pDRF, DRFLength );
                    }

       /*
                    BOOLEAN f = EfspChecksumEfs( EFS, Fek );

                    ASSERT( f );

                    if (!f) {
                        rc = GetLastError();
                        ASSERT( rc != ERROR_SUCCESS );
                        LsapFreeLsaHeap( EFS );
                        *EfsStreamHeader = NULL;
                    } else {

                        //
                        // Everything worked, return success.
                        //

                        *EfsStreamHeader = EFS;
                        b = TRUE;
                    }
        */

                    *EfsStreamHeader = EFS;
                    b = TRUE;


                }
            } else {

                rc = GetLastError();

            }
        }

    }

    ReleaseRecoveryData();

    if (pDDF) {

        LsapFreeLsaHeap(pDDF);

    }

    if (pDRF) {

        LsapFreeLsaHeap(pDRF);
    }


    if (ContainerName) {

       //
       //  Defensive checking
       //

       LsapFreeLsaHeap( ContainerName );
    }
   
    if (ProviderName) {
       LsapFreeLsaHeap( ProviderName );
    }
   
    if (lpDisplayInformation) {
       LsapFreeLsaHeap( lpDisplayInformation );
    }
   
    if (PublicKey) {
       LsapFreeLsaHeap( PublicKey );
    }
   
    if (pbHash) {
       LsapFreeLsaHeap( pbHash );
    }

    if (hUserKey) {
       CryptDestroyKey( hUserKey );
    }
    if (hProv) {
       CryptReleaseContext( hProv, 0 );
    }

    if (EFSDebugLevel > 0) {
        DumpEFS( *EfsStreamHeader );
    }

    SetLastError( rc );


#if DBG

    if (!b) {
        ASSERT( rc != ERROR_SUCCESS );
    }

#endif

    return( b );

}

DWORD
CopyEfsStream(
    OUT PEFS_DATA_STREAM_HEADER * Target,
    IN PEFS_DATA_STREAM_HEADER Source
    )

/*++

Routine Description:

    Makes a copy of the passed EFS stream.  Allocates memory for the target
    which must be freed.

Arguments:

    Target - Takes a pointer which is filled in with a pointer to the copy
        of the EFS stream.  This pointer must be freed.


Return Value:

    ERROR_SUCCESS, or ERROR_NOT_ENOUGH_MEMORY if we can't allocate memory for the
    target buffer.

--*/

{
    *Target = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( Source->Length );

    if (*Target) {
        memcpy( *Target, Source, Source->Length );
    } else {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( ERROR_SUCCESS );
}


BOOLEAN
ConstructDirectoryEFS(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PEFS_KEY Fek,
    OUT PEFS_DATA_STREAM_HEADER * EfsStreamHeader
    )

/*++

Routine Description:

    This routine constructs the EFS stream for a directory.

Arguments:

    pEfsUserInfo - Supplies useful information about our caller.

    Fek - Supplies the Fek to put into the EFS stream.

    EfsStreamHeader - Returns a pointer to the new EFS stream.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    return( ConstructEFS( pEfsUserInfo, Fek, NULL, EfsStreamHeader ) );
}



DWORD
ConstructKeyRing(
    IN PEFS_KEY Fek,
    IN DWORD KeyCount,
    IN LPWSTR KeyNames[] OPTIONAL,
    IN LPWSTR ProviderNames[] OPTIONAL,
    IN PBYTE PublicKeys[],
    IN DWORD PublicKeyLengths[],
    IN PBYTE pbHashes[],
    IN DWORD cbHashes[],
    IN LPWSTR lpDisplayInformation[],
    IN PSID pSid[],
    IN BOOLEAN PublicKeyHandle,
    OUT PENCRYPTED_KEYS *KeyRing,
    OUT PDWORD KeyRingLength
    )

/*++

Routine Description:

    This routine will construct a key ring (DDF or DRF) structure.  A keyring
    contains one or more ENCRYPTED_KEY structures, each of which represents
    an encoding of the FEK with a different user key.

    The caller is expected to call this routine twice, once to determine the
    length of the structure, and a second time to actually create the key ring
    structure.

    Note that the passed keys do not need to exist in the current context,
    and if we are building a DRF structure, most likely will not exist
    in the current context.

Arguments:

    Fek - Provides the unencrypted FEK for the file.

    KeyCount - Provides the number of keys that are going to be placed in this
        keyring.

    KeyNames - Provides an array of NULL-terminated WCHAR strings, each naming
        a key.

    ProviderNames - Provides an array of providers that is parallel to the
        KeyNames array.

    PublicKeys - Provides an array of pointers to PUBLICKEYBLOB structures,
        one for each named key.

    PublicKeyLengths - Provides an array of lengths of the PUBLICKEYBLOB
        structures pointed to by the PublicKeys array. It could also points to the key
        handle.

    pSid - Users' SIDs
    
    PublicKeyHandle - Indicate if PublicKeys point to PUBLICKEYBLOB or key handles.

    KeyRing - Returns a pointer to the constructed keyring.  If this parameter
        is NULL, only the length will be computed and returned.

    KeyRingLength - Provides the size of the passed KeyRing buffer, or or if the
        KeyRing pointer is NULL, the size of the buffer that must be passed in to
        return the KeyRing.

Return Value:

    ERROR_SUCCESS - Returned if successful.


    ERROR_NOT_ENOUGH_MEMORY - Some attempt to allocate memory from the local
        heap failed.

--*/

{
    //
    // For each Key passed in, import the public key blob
    // and export the session key encrypted with that blob.
    // The FEK will be encrypted with the same session key
    // in each entry.
    //

    PEFS_KEY_SALT pEfsKeySalt = NULL;

    PENCRYPTED_KEY * EncryptedKey = NULL;
    BOOL             GotPublicKey = TRUE;

    EncryptedKey = (PENCRYPTED_KEY *)LsapAllocateLsaHeap( KeyCount * sizeof(PENCRYPTED_KEY) );

    *KeyRing = NULL;

    if (EncryptedKey == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    PDWORD EncryptedKeySize = (PDWORD)LsapAllocateLsaHeap( KeyCount * sizeof( DWORD ));

    if (EncryptedKeySize == NULL) {

        LsapFreeLsaHeap( EncryptedKey );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    DWORD i;

    DWORD rc = ERROR_SUCCESS;

    for (i = 0 ; i<KeyCount ; i++) {

        EncryptedKey[i] = NULL;
        EncryptedKeySize[i] = 0;
    }

    for ( i = 0; i<KeyCount && rc==ERROR_SUCCESS ; i++ ) {

        //
        // Import the passed public key
        //

        HCRYPTKEY hXchgKey = 0;

        if (PublicKeyHandle) {

            GotPublicKey = TRUE;
            hXchgKey = (HCRYPTKEY)PublicKeys[i];

        } else {
            GotPublicKey = CryptImportKey( hProvVerify, PublicKeys[i], PublicKeyLengths[i], 0, CRYPT_EXPORTABLE, &hXchgKey );
        }

        if (GotPublicKey) {

            DWORD dwEncryptedFEKLength = 0;

            PBYTE EncryptedFEK = EncryptFEK( Fek, hXchgKey, &dwEncryptedFEKLength );

            if (EncryptedFEK == NULL) {

                rc = GetLastError();
                ASSERT( rc != ERROR_SUCCESS );

            } else {

                PEFS_PUBLIC_KEY_INFO PublicKeyInformation = NULL;

                LPWSTR KeyName;
                LPWSTR ProviderName;

                if (KeyNames && ProviderNames) {

                    KeyName = KeyNames[i];
                    ProviderName = ProviderNames[i];

                } else {

                    KeyName = NULL;
                    ProviderName = NULL;
                }

                if  (CreatePublicKeyInformationThumbprint(
                         pSid[i],
                         pbHashes[i],
                         cbHashes[i],
                         lpDisplayInformation[i],
                         KeyName,
                         ProviderName,
                         &PublicKeyInformation
                         )) {

                    if ( Fek->Entropy <= EXPORT_KEY_STRENGTH ){

                        DWORD SaltLength;
                        DWORD SaltBlockLength;

                        if (GetSaltLength(Fek->Algorithm, &SaltLength, &SaltBlockLength)){

                            pEfsKeySalt = (PEFS_KEY_SALT)LsapAllocateLsaHeap( sizeof( EFS_KEY_SALT ) + SaltBlockLength );
                            if (pEfsKeySalt){
                                pEfsKeySalt->Length = sizeof( EFS_KEY_SALT ) + SaltBlockLength;
                                pEfsKeySalt->SaltType = Fek->Algorithm;
                                RtlCopyMemory( (PBYTE)pEfsKeySalt + sizeof( EFS_KEY_SALT ),
                                                EFS_KEY_DATA( Fek ),
                                                SaltLength
                                              );
                            }
                        }

                    } else {
                        pEfsKeySalt = NULL;
                    }

                    if (pEfsKeySalt || (Fek->Entropy > EXPORT_KEY_STRENGTH)) {


                        rc = ConstructEncryptedKey( EncryptedFEK,
                                                    dwEncryptedFEKLength,
                                                    PublicKeyInformation,
                                                    pEfsKeySalt,
                                                    &EncryptedKey[i],
                                                    &EncryptedKeySize[i]
                                                    );

                    }


                    //
                    // Clean up output from CreatePublicKeyInformation
                    //

                    LsapFreeLsaHeap( PublicKeyInformation );
                    if (pEfsKeySalt){
                        LsapFreeLsaHeap( pEfsKeySalt );
                    }

                } else {

                    rc = GetLastError();
                }

                //
                // Clean up output from EncryptFEK
                //

                LsapFreeLsaHeap( EncryptedFEK );
            }

            //
            // If the we imported the key, don't need this key any more, get rid of it.
            //

            if (!PublicKeyHandle) {
                CryptDestroyKey( hXchgKey );
            }

        } else {

            //
            // Couldn't import a public key, pick up error code
            //

            rc = GetLastError();
        }


        if (rc != ERROR_SUCCESS) {

            //
            // Something failed along the way, clean up all previous allocations
            //

            for (DWORD j = 0; j < i ; j++ ) {
                if (EncryptedKey[j]) {
                    LsapFreeLsaHeap( EncryptedKey[j] );
                }
            }

            LsapFreeLsaHeap( EncryptedKey );

            LsapFreeLsaHeap( EncryptedKeySize );

            return( rc );
        }
    }


    //
    // We successfully created all of the EncryptedKey structures.  Assemble them
    // all into a KeyRing and return the result.
    //


    *KeyRingLength = 0;

    for (i=0 ; i<KeyCount ; i++) {
        *KeyRingLength += EncryptedKeySize[i];
    }

    *KeyRingLength += (sizeof ( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY ));


    *KeyRing = (PENCRYPTED_KEYS)LsapAllocateLsaHeap( *KeyRingLength );

    if (NULL != *KeyRing) {

        (*KeyRing)->KeyCount = KeyCount;
    
        PBYTE Base = (PBYTE) &((*KeyRing)->EncryptedKey[0]);
    
        for (i=0 ; i<KeyCount ; i++) {
    
            memcpy( Base, EncryptedKey[i], EncryptedKey[i]->Length );
            Base += EncryptedKey[i]->Length;
        }
    
    } else {
        *KeyRingLength = 0;
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }



    //
    // Clean everything up and return
    //

    for (i = 0; i<KeyCount ; i++ ) {
        LsapFreeLsaHeap( EncryptedKey[i] );
    }

    LsapFreeLsaHeap( EncryptedKey );

    LsapFreeLsaHeap( EncryptedKeySize );

    return( rc );
}


PEFS_KEY
GetFekFromEncryptedKeys(
    IN OUT PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTED_KEYS Keys,
    IN BOOL CheckBits,
    OUT PDWORD KeyIndex
    )

/*++

Routine Description:

    This routine will attempt to decode the FEK from an ENCRYPTED_KEYS
    structure.  It will do this by iterating through all of the fields in the
    DRF and attempting to use each one to decrypt the FEK.

Arguments:

    pEfsUserInfo - User information.

    Keys - Provides the ENCRYPTED_KEYS to be examined.
    
    CheckBits - If we need to check international version or not. TRUE will check.
    
    KeyIndex - Which encrypted key is used.

Return Value:

    On success, returns a pointer to an FEK, which must be freed when no longer
    needed.  Returns NULL on error.

--*/
{
    //
    // Walk down the list of key names in the ENCRYTPED_KEYS
    //

    if (Keys != NULL) {

        PENCRYPTED_KEY pEncryptedKey = &Keys->EncryptedKey[0];
        ULONG keyCount = *(ULONG UNALIGNED*)&(Keys->KeyCount);

        for (*KeyIndex=0 ; *KeyIndex<keyCount ; (*KeyIndex)++) {

            PENCRYPTED_KEY pAlignedKey;
            BOOLEAN freeAlignedKey;
            DWORD   retCode;
    
            retCode =  EfsAlignBlock(
                            pEncryptedKey,
                            (PVOID *)&pAlignedKey,
                            &freeAlignedKey
                            );
            if (!pAlignedKey) {
    
                //
                // OOM. Treat it as not current.
                //
    
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return NULL;
    
            }

            PEFS_KEY Fek = ExtractFek( pEfsUserInfo, pAlignedKey, CheckBits );

            if (Fek != NULL) {

                //
                // Decryption worked, return the key
                //

                if (freeAlignedKey) {
                    LsapFreeLsaHeap( pAlignedKey );
                }
                return( Fek );
            }

            pEncryptedKey = (PENCRYPTED_KEY)( ((PBYTE)pEncryptedKey) + pAlignedKey->Length );
            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );
            }
        }
    }

    return( NULL );
}


DWORD
GetLengthEncryptedKeys(
    IN PENCRYPTED_KEYS pEncryptedKeys
    )

/*++

Routine Description:

    Computes the total size in bytes of an ENCRYPTED_KEYS structure.

Arguments:

    pEncryptedKeys - Supplies a pointer to an ENCRYPTED_KEYS structre.

Return Value:

    The length in bytes of the passed structure.

--*/

{
    DWORD cb=0;
    ULONG keyCount = *((ULONG UNALIGNED *) &(pEncryptedKeys->KeyCount));
    ULONG keyLength;

    PENCRYPTED_KEY pEncryptedKey = &pEncryptedKeys->EncryptedKey[0];

    for (DWORD i=0; i<keyCount ; i++) {

        keyLength = *((ULONG UNALIGNED *) &(pEncryptedKey->Length));
        cb += keyLength;
        pEncryptedKey = (PENCRYPTED_KEY)( ((PBYTE)pEncryptedKey) + keyLength );
    }

    cb += sizeof( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY );

    return( cb );
}

BOOL
AppendEncryptedKeyToDDF(
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    IN PENCRYPTED_KEY EncryptedKey,
    IN PEFS_KEY Fek,
    OUT PEFS_DATA_STREAM_HEADER * OutputEfs
    )

/*++

Routine Description:

    This routine will take an existing EFS stream and append the
    passed encrypted key to the end of the DDF section.  It does
    not check to see if the key is already there or not.

Arguments:

    EfsStream - The existing EFS stream.

    EncryptedKey - The FEK encrypted with the new public key.

    OutputEfs - Receives the new EFS stream to be placed on the
        file.

Return Value:

--*/

{
    BOOL b = FALSE;

    //
    // This is a simple append operation.
    //
    // The new size is the size of the old EFS stream
    // plus the size of the new key.  Allocate space for it.
    //

    DWORD EfsLength = EfsStream->Length + EncryptedKey->Length;
    EfsLength = (EfsLength + 7) & 0xfffffff8;

    *OutputEfs = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( EfsLength );

    if (*OutputEfs) {

        memset( *OutputEfs, 0, sizeof( EFS_DATA_STREAM_HEADER ));

        //
        // Copy the header
        //

        PEFS_DATA_STREAM_HEADER Efs = *OutputEfs;
        *Efs = *EfsStream;

        Efs->Length = EfsLength;

        //
        // Start copying the DDF at the base of the EFS
        // structure.  Copy the whole thing.  Do ourselves a
        // favor and don't assume that the DDF or DRF are in
        // any particular order in the EFS structure.
        //

        PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );
        DWORD cbDDF = GetLengthEncryptedKeys( pDDF );

        //
        // Store away the offset to the beginning on the DDF
        //

        Efs->DataDecryptionField = (ULONG)sizeof( EFS_DATA_STREAM_HEADER );

        PBYTE Base = (PBYTE)OFFSET_TO_POINTER( DataDecryptionField, Efs );
        memcpy( Base, pDDF, cbDDF );

        //
        // Point to the new DDF, we need to fix it up a little
        //

        PENCRYPTED_KEYS pNewDDF = (PENCRYPTED_KEYS)Base;
        pNewDDF->KeyCount++;

        Base += cbDDF;

        memcpy( Base, EncryptedKey, EncryptedKey->Length );

        Base += EncryptedKey->Length;

        //
        // Now copy the DRF onto the end and we're done.
        //


        PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, EfsStream );

        if ((PVOID) pDRF == (PVOID) EfsStream) {

            Efs->DataRecoveryField = 0;

        } else {

            DWORD cbDRF = GetLengthEncryptedKeys( pDRF );
            Efs->DataRecoveryField = (ULONG)POINTER_TO_OFFSET( Base, Efs );
            memcpy( Base, pDRF, cbDRF );

        }


//        Base += cbDRF

        b = TRUE;

//        memset( &(Efs->EfsHash), 0, MD5_HASH_SIZE );
//        EfspChecksumEfs( Efs, Fek );

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( b );
}


BOOLEAN
EfspCertInEFS(
    IN PBYTE pbHash,
    IN DWORD cbHash,
    IN PEFS_DATA_STREAM_HEADER pEfsStream
    )

/*++

Routine Description:

    Searches the passed EFS stream for an entry with the same hash as passed.

Arguments:

    pbHash - Supplies a pointer to the hash being queried

    cbHash - Supplies the length in bytes of the hash being queried

    pEfsStream - Supplies the EFS stream from the file being queried


Return Value:

    TRUE if the passed hash is found, FALSE otherwise.

--*/

{
    BOOLEAN fFound = FALSE;
    DWORD KeyIndex;

    //
    // Check the hash in each entry in the DDF.  If
    // we get a match, return success.
    //

    PDDF Keys = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfsStream );

    PENCRYPTED_KEY pEncryptedKey = &Keys->EncryptedKey[0];

    for (KeyIndex=0 ; KeyIndex<Keys->KeyCount ; KeyIndex++) {

        PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)( (PUCHAR)pEncryptedKey + *(ULONG UNALIGNED *) &(pEncryptedKey->PublicKeyInfo) );
        PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)( (PUCHAR) PublicKeyInfo + *(ULONG UNALIGNED *) &(PublicKeyInfo->CertificateThumbprint.CertHashData));
        
        if (*(DWORD UNALIGNED *)&(CertHashData->cbHash) == cbHash) {

            PBYTE pbSrcHash = (PBYTE)CertHashData + *(ULONG UNALIGNED *) &(CertHashData->pbHash); 

            if (memcmp(pbSrcHash, pbHash, cbHash) == 0) {
                fFound = TRUE;
                break;
            }
        }

        pEncryptedKey = NEXT_ENCRYPTED_KEY( pEncryptedKey );
    }

    return( fFound );
}



BOOLEAN
AddUserToEFS(
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    IN PSID NewUserSid OPTIONAL,
    IN PEFS_KEY Fek,
    IN PBYTE pbCert,
    IN DWORD cbCert,
    OUT PEFS_DATA_STREAM_HEADER * NewEfs
    )

/*++

Routine Description:

    This routine adds a new encrypted key block to the DDF of the passed
    EFS stream.

Arguments:

    EfsStream - Takes a pointer to the EFS stream to be modified.

    NewUserSid - Optionally supplies a pointer to the SID of the new user.

    Fek - Supplies the FEK of the file being modified.

    pbCert - Supplies a pointer to the certificate of the new user.

    cbCert - Supplies the lenght in bytes of the certificate.

    NewEfs - Returns a pointer to the new EFS stream.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    DWORD rc;
    PEFS_DATA_STREAM_HEADER Efs = NULL;
    BOOLEAN b = FALSE;
    PEFS_KEY_SALT pEfsKeySalt = NULL;

    //
    // Get the key information from the passed cert
    //

    PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                                      X509_ASN_ENCODING,
                                      pbCert,
                                      cbCert
                                      );
    if (pCertContext != NULL) {

        PBYTE pbHash;
        DWORD cbHash;

        pbHash = GetCertHashFromCertContext(
                     pCertContext,
                     &cbHash
                     );

        if (pbHash) {

            //
            // See if this hash is already on the file.  If so, return error.
            //

            if (!EfspCertInEFS( pbHash, cbHash, EfsStream )) {

                //
                // Now get the public key out of the cert so we can
                // encrypt the FEK
                //

                PCERT_PUBLIC_KEY_INFO pSubjectPublicKeyInfo = &pCertContext->pCertInfo->SubjectPublicKeyInfo;

                //
                // Import the public key into a context
                //

                HCRYPTKEY hKey;

                if (CryptImportPublicKeyInfo( hProvVerify, X509_ASN_ENCODING, pSubjectPublicKeyInfo, &hKey )) {

                    //
                    // Use the newly imported key to encrypt the FEK
                    //

                    DWORD dwEncryptedFEKLength = 0;

                    PBYTE EncryptedFEK = EncryptFEK( Fek, hKey, &dwEncryptedFEKLength );

                    if (EncryptedFEK != NULL) {

                        PEFS_PUBLIC_KEY_INFO PublicKeyInformation = NULL;

                        //
                        // This may come back NULL, but that's ok.
                        //

                        LPWSTR lpDisplayName = EfspGetCertDisplayInformation( pCertContext );

                        b = CreatePublicKeyInformationThumbprint(
                                NewUserSid,
                                pbHash,
                                cbHash,
                                lpDisplayName,
                                NULL,
                                NULL,
                                &PublicKeyInformation
                                );

                        if (lpDisplayName) {
                            LsapFreeLsaHeap( lpDisplayName );
                        }

                        if (b) {

                            if (Fek->Entropy <= EXPORT_KEY_STRENGTH) {

                                DWORD SaltLength;
                                DWORD SaltBlockLength;

                                if (GetSaltLength(Fek->Algorithm, &SaltLength, &SaltBlockLength)) {

                                    pEfsKeySalt = (PEFS_KEY_SALT)LsapAllocateLsaHeap( sizeof( EFS_KEY_SALT ) + SaltBlockLength );
                                    if (pEfsKeySalt) {
                                        pEfsKeySalt->Length = sizeof( EFS_KEY_SALT ) + SaltBlockLength;
                                        pEfsKeySalt->SaltType = Fek->Algorithm;
                                        RtlCopyMemory( (PBYTE)pEfsKeySalt + sizeof( EFS_KEY_SALT ),
                                            EFS_KEY_DATA( Fek ),
                                            SaltLength
                                            );
                                    }
                                }

                            } else {
                                pEfsKeySalt = NULL;
                            }

                            if (pEfsKeySalt || (Fek->Entropy > EXPORT_KEY_STRENGTH)) {


                                DWORD EncryptedKeySize = 0;
                                PENCRYPTED_KEY EncryptedKey;

                                rc = ConstructEncryptedKey( EncryptedFEK,
                                         dwEncryptedFEKLength,
                                         PublicKeyInformation,
                                         pEfsKeySalt,
                                         &EncryptedKey,
                                         &EncryptedKeySize
                                         );
                                //
                                // We'll check the return code below
                                //

                                if (rc == ERROR_SUCCESS) {

                                    b = AppendEncryptedKeyToDDF(
                                            EfsStream,
                                            EncryptedKey,
                                            Fek,
                                            NewEfs
                                            ) != 0;

                                    LsapFreeLsaHeap( EncryptedKey );

                                } else {

                                    SetLastError( rc );
                                }

                                if (pEfsKeySalt) {
                                    LsapFreeLsaHeap( pEfsKeySalt );
                                }

                            } else {

                                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                            }

                            LsapFreeLsaHeap( PublicKeyInformation );
                        }

                        LsapFreeLsaHeap( EncryptedFEK );
                    }

                    CryptDestroyKey( hKey );
                }

            } else {

               //
               // Adding duplicate cert considered succeed
               //

               b = TRUE;
            }

            LsapFreeLsaHeap( pbHash );
        }

        CertFreeCertificateContext( pCertContext );
    }

    if (!b) {

        //
        // If we're not going to return success, clean up everything we were
        // planning on returning.
        //

        if (*NewEfs != NULL) {
            LsapFreeLsaHeap( *NewEfs );
        }
    }

    return( b );
}


PENCRYPTED_KEY
GetEncryptedKeyByIndex(
    PENCRYPTED_KEYS pEncryptedKeys,
    DWORD KeyIndex
    )
{
    ASSERT( KeyIndex < *((ULONG UNALIGNED *)&(pEncryptedKeys->KeyCount)) );

    PENCRYPTED_KEY pEncryptedKey = &pEncryptedKeys->EncryptedKey[0];

    if (KeyIndex == 0) {
        return( pEncryptedKey );
    }

    for (DWORD i=0; i<KeyIndex ; i++, pEncryptedKey = (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + *(ULONG UNALIGNED *)&((PENCRYPTED_KEY)(pEncryptedKey))->Length)) ;

    return( pEncryptedKey );
}

BOOL
UserKeyCurrent(
    PEFS_USER_INFO pEfsUserInfo,
    PDDF Ddf,
    DWORD KeyIndex
    )
/*++

Routine Description:

    This routine checks to see if the key used to decrypt the file
    is the user's current encryption key.

Arguments:

    Ddf - Supplies the DDF of the file being accessed.

    KeyIndex - Supplies the index of the key in the DDF that was
        used to open the file.

Return Value:

    TRUE if the key used corresponds to the user's encryption key.

    FALSE otherwise.

--*/

{
    BOOL b = TRUE;
    DWORD rc = ERROR_SUCCESS;

    PBYTE pbCurrentKeyHash = NULL;
    DWORD cbCurrentKeyHash;
    PBYTE pbHash;
    DWORD cbHash;
    PBYTE pbWkHash = NULL;

    //
    // Compare the current user key with the contents
    // of the specified key, and see if they're in sync.
    //

    PENCRYPTED_KEY pEncryptedKey = GetEncryptedKeyByIndex( Ddf, KeyIndex );

    PENCRYPTED_KEY pAlignedKey;
    BOOLEAN freeAlignedKey;

    rc =  EfsAlignBlock(
                    pEncryptedKey,
                    (PVOID *)&pAlignedKey,
                    &freeAlignedKey
                    );
    if (!pAlignedKey) {

        //
        // OOM. Treat it as current.
        //

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return TRUE;

    }

    PEFS_PUBLIC_KEY_INFO pPublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );

    if (pPublicKeyInfo->KeySourceTag != EfsCertificateThumbprint) {

        //
        // The user key may be current, but the key on the file isn't.
        // Return FALSE so as to regenerate the EFS on this file.
        //

        DebugLog((DEB_WARN, "Updating downlevel file\n"   ));
        if (freeAlignedKey) {
            LsapFreeLsaHeap( pAlignedKey );
        }

        return( FALSE );
    }

    PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, pPublicKeyInfo );
    pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
    cbHash = CertHashData->cbHash;

    if (pEfsUserInfo->pUserCache) {

        //
        // Check the current against the cache
        //

        pbWkHash = pEfsUserInfo->pUserCache->pbHash;
        cbCurrentKeyHash = pEfsUserInfo->pUserCache->cbHash;

    } else {

        rc = GetCurrentHash(
                 pEfsUserInfo,
                 &pbCurrentKeyHash,
                 &cbCurrentKeyHash
                 );

        if (rc == ERROR_SUCCESS) {

            pbWkHash = pbCurrentKeyHash;

        }

    }

    //
    // Compare the hash stored in the current user key
    // with the hash in the specified public key info.
    //

    if (rc == ERROR_SUCCESS) {

        //
        // Compare the thumbprint in the public key info against
        // the user's current.
        //



        if (cbHash == cbCurrentKeyHash) {

            if (memcmp(pbWkHash, pbHash, cbHash) != 0) {

                b = FALSE;

            }
        } else {

            b = FALSE;

        }

    }

    if (pbCurrentKeyHash) {
        LsapFreeLsaHeap( pbCurrentKeyHash );
    }

    if (freeAlignedKey) {
        LsapFreeLsaHeap( pAlignedKey );
    }

    //
    // If we failed to get the current key hash and reach here, this means we also failed to create the hash.
    // This could mean that we could not set the current key. We could not test if the hash could be the current.
    // We could not replace the DDF with a current one anyway. We assume the passed in hash as the current.
    // Could I be wrong here?
    //

    return( b );
}

BOOL
ReplaceUserKey(
    PEFS_USER_INFO pEfsUserInfo,
    PEFS_KEY Fek,
    PEFS_DATA_STREAM_HEADER EfsStream,
    DWORD KeyIndex,
    PEFS_DATA_STREAM_HEADER * UpdatedEfs
    )
/*++

Routine Description:

    This routine will replace the user key specified by the passed KeyIndex
    with another one that uses the current user EFS keys.

    It assumes that we are in the context of the caller who owns this key.

Arguments:

    Fek - Supplies the decrypted FEK for the file.

    EfsStream - Supplies the EFS stream on the file.

    KeyIndex - Supplies the index of the key to be replaced.

    UpdatedEfs - Receives a pointer to the new EFS stream to be
        placed on the file.

Return Value:

--*/
{
    //
    // Query the current user keys.  This will give me
    // back a hash and a container and provider name.
    //

    HCRYPTKEY hKey;
    HCRYPTPROV hProv;
    PBYTE pbHash;
    DWORD cbHash;
    PEFS_KEY_SALT pEfsKeySalt = NULL;

    BOOL b = FALSE;
    DWORD rc;

    LPWSTR ContainerName;
    LPWSTR ProviderName;
    LPWSTR DisplayInfo;
    DWORD ProviderType;

    DebugLog((DEB_WARN, "Updating EFS stream\n"   ));

    PSID NewUserSid = pEfsUserInfo->pTokenUser->User.Sid;

    rc = GetCurrentKey(
             pEfsUserInfo,
             &hKey,
             &hProv,
             &ContainerName,
             &ProviderName,
             &ProviderType,
             &DisplayInfo,
             &pbHash,
             &cbHash
             );

    //
    // Use this key information to encrypt the FEK
    // and generate an encrypted key structure.
    //

    if (rc == ERROR_SUCCESS) {

        DWORD dwEncryptedFEKLength = 0;

        PBYTE EncryptedFEK;
        HCRYPTKEY hLocalKey;
        HCRYPTPROV hLocalProv;
        PBYTE pbLocalHash;
        DWORD cbLocalHash;
        LPWSTR lpLocalContainerName;
        LPWSTR lpLocalProviderName;
        LPWSTR lpLocalDisplayInfo;

        if (pbHash) {
            pbLocalHash = pbHash;
            cbLocalHash = cbHash;
            hLocalKey = hKey;
            hLocalProv = hProv;
            lpLocalContainerName = ContainerName;
            lpLocalProviderName = ProviderName;
            lpLocalDisplayInfo = DisplayInfo;
        } else {

            ASSERT(pEfsUserInfo->pUserCache);

            pbLocalHash = pEfsUserInfo->pUserCache->pbHash;
            cbLocalHash = pEfsUserInfo->pUserCache->cbHash;
            hLocalKey = pEfsUserInfo->pUserCache->hUserKey;
            hLocalProv = pEfsUserInfo->pUserCache->hProv;
            lpLocalContainerName = pEfsUserInfo->pUserCache->ContainerName;
            lpLocalProviderName = pEfsUserInfo->pUserCache->ProviderName;
            lpLocalDisplayInfo = pEfsUserInfo->pUserCache->DisplayInformation;

        }
         
        EncryptedFEK = EncryptFEK( Fek, hLocalKey, &dwEncryptedFEKLength );

        if (EncryptedFEK != NULL) {

            PEFS_PUBLIC_KEY_INFO PublicKeyInformation = NULL;

            if (CreatePublicKeyInformationThumbprint(
                    NewUserSid,
                    pbLocalHash,
                    cbLocalHash,
                    lpLocalDisplayInfo,
                    lpLocalContainerName,
                    lpLocalProviderName,
                    &PublicKeyInformation
                    )) {

                if ( Fek->Entropy <= EXPORT_KEY_STRENGTH ){

                    DWORD SaltLength;
                    DWORD SaltBlockLength;

                    if (GetSaltLength(Fek->Algorithm, &SaltLength, &SaltBlockLength)){

                        pEfsKeySalt = (PEFS_KEY_SALT)LsapAllocateLsaHeap( sizeof( EFS_KEY_SALT ) + SaltBlockLength );

                        if (pEfsKeySalt){
                            pEfsKeySalt->Length = sizeof( EFS_KEY_SALT ) + SaltBlockLength;
                            pEfsKeySalt->SaltType = Fek->Algorithm;
                            RtlCopyMemory( (PBYTE)pEfsKeySalt + sizeof( EFS_KEY_SALT ),
                                            EFS_KEY_DATA( Fek ),
                                            SaltLength
                                          );
                        }
                    }

                } else {

                    pEfsKeySalt = NULL;
                }

                if (pEfsKeySalt || (Fek->Entropy > EXPORT_KEY_STRENGTH)) {

                    //
                    // This should return an error
                    //

                    DWORD EncryptedKeySize = 0;
                    PENCRYPTED_KEY EncryptedKey;

                    rc = ConstructEncryptedKey( EncryptedFEK,
                                                dwEncryptedFEKLength,
                                                PublicKeyInformation,
                                                pEfsKeySalt,
                                                &EncryptedKey,
                                                &EncryptedKeySize
                                                );
                    //
                    // We'll check the return code below
                    //

                    if (rc == ERROR_SUCCESS) {


                        PEFS_DATA_STREAM_HEADER NewEfs = NULL;

                        if (AppendEncryptedKeyToDDF(
                                EfsStream,
                                EncryptedKey,
                                Fek,
                                &NewEfs
                                )) {

                            PEFS_DATA_STREAM_HEADER pNewEfs2 = NULL;

                            if (DeleteEncryptedKeyByIndex(
                                    NewEfs,
                                    KeyIndex,
                                    Fek,
                                    &pNewEfs2
                                    )) {

                                *UpdatedEfs = pNewEfs2;
                                b = TRUE;

                            } else {

                                *UpdatedEfs = NULL;  // paranoia
                            }

                            LsapFreeLsaHeap( NewEfs );
                        }

                        LsapFreeLsaHeap( EncryptedKey );

                    }

                    if (pEfsKeySalt){
                        LsapFreeLsaHeap( pEfsKeySalt );
                    }
                }

                LsapFreeLsaHeap( PublicKeyInformation );
            }

            LsapFreeLsaHeap( EncryptedFEK );
        } else {

            rc = GetLastError();

        }

        if (ContainerName) {
            LsapFreeLsaHeap( ContainerName );
        }

        if (ProviderName) {
            LsapFreeLsaHeap( ProviderName );
        }

        if (DisplayInfo) {
            LsapFreeLsaHeap( DisplayInfo );
        }

        if (pbHash) {
            LsapFreeLsaHeap( pbHash );
        }

        if (hKey) {
            CryptDestroyKey( hKey );
        }

        if (hProv) {
            CryptReleaseContext( hProv, 0 );
        }

    }

    SetLastError( rc );

    if (!b) {
        DebugLog((DEB_ERROR, "Update failed, error = %x\n" ,GetLastError()  ));
    }

    return( b );
}

BOOL
DeleteEncryptedKeyByIndex(
   IN PEFS_DATA_STREAM_HEADER pEfs,
   IN DWORD KeyIndex,
   IN PEFS_KEY Fek,
   OUT PEFS_DATA_STREAM_HEADER * pNewEfs
   )

/*++

Routine Description:

    This routine deletes the passed key from the DDF of the passed
    EFS stream, and returns a new EFS stream.  It does not deallocate
    the original EFS stream.

Arguments:

    pEfs - Supplies a pointer to the original EFS stream.

    KeyIndex - Supplies the index of the key to delete.

    pNewEfs - Returns a pointer to the new EFS stream allocated
        out of heap.

Return Value:

    TRUE on success, FALSE on failure.  GetLastError() will return more information.

--*/

{
    BOOL b = FALSE;

    //
    // Do this the lazy way: build the new DDF
    // and copy it into the EFS stream.
    //

    PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfs );

    //
    // This is an over estimate, but it will do.
    //

    PENCRYPTED_KEYS pNewDDF = (PENCRYPTED_KEYS)LsapAllocateLsaHeap( GetLengthEncryptedKeys( pDDF ) );

    if (pNewDDF) {

        pNewDDF->KeyCount = pDDF->KeyCount - 1;
        DWORD cbNewDDF = sizeof( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY );

        PBYTE Target = (PBYTE)(&pNewDDF->EncryptedKey[0]);
        PBYTE Source = (PBYTE)(&pDDF->EncryptedKey[0]);

        for (DWORD i=0; i<pDDF->KeyCount ; i++) {

            if (i != KeyIndex) {

                //
                // We want this one.  Copy it.
                //

                DWORD KeyLength = *((DWORD UNALIGNED*) &((PENCRYPTED_KEY)Source)->Length);
                cbNewDDF += KeyLength;

                memcpy( Target, Source, KeyLength );

                Target = (PBYTE)NEXT_ENCRYPTED_KEY( Target );
                Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );

            } else {

                //
                // Skip this one.
                //

                Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );
            }
        }

        //
        // pNewDDF contains a pointer to our new DDF.
        //

        PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, pEfs );
        DWORD cbDRF;

        if ((PVOID)pDRF == (PVOID)pEfs) {

            //
            //  There was no DRF
            //

            cbDRF = 0;
            pDRF = NULL;

        } else {
            cbDRF = GetLengthEncryptedKeys( pDRF );
        }

        *pNewEfs = AssembleEfsStream( pNewDDF, cbNewDDF, pDRF, cbDRF, Fek );

        if (*pNewEfs) {
            b = TRUE;
        } else {
            *pNewEfs = NULL;    // paranoia
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

        LsapFreeLsaHeap( pNewDDF );

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( b );
}


PEFS_DATA_STREAM_HEADER
AssembleEfsStream(
    IN PENCRYPTED_KEYS pDDF,
    IN DWORD cbDDF,
    IN PENCRYPTED_KEYS pDRF,
    IN DWORD cbDRF,
    IN PEFS_KEY Fek
    )
/*++

Routine Description:

    This routine takes the pieces of an EFS stream and assembles them into
    an EFS stream.

Arguments:

    pDDF - Supplies a pointer to the DDF for the new EFS stream.

    cbDDF - Supplies the length in bytes of the DDF.

    pDRF - Supplies a pointer to the DRF for the new EFS stream.

    cbDRF - Supplies the length in bytes of the DRF.

Return Value:

    Returns a pointer to a new EFS stream, or NULL.  Caller is responsible
    for freeing the returned memory.

--*/

{
    //
    // Compute the total size of the new EFS stream
    //

    DWORD cbNewEFS = sizeof( EFS_DATA_STREAM_HEADER ) + cbDDF + cbDRF;
    cbNewEFS = (cbNewEFS + 7) & 0xfffffff8;

    PEFS_DATA_STREAM_HEADER pNewEFS = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( cbNewEFS );

    if (pNewEFS) {

        memset( pNewEFS, 0, sizeof( EFS_DATA_STREAM_HEADER ) );

        pNewEFS->Length     = cbNewEFS;
        pNewEFS->State      = 0;
        pNewEFS->EfsVersion = EFS_CURRENT_VERSION;

        RPC_STATUS RpcStatus = UuidCreate( &pNewEFS->EfsId );

        if (RpcStatus == ERROR_SUCCESS || RpcStatus == RPC_S_UUID_LOCAL_ONLY) {

            //
            // Copy in the DDF
            //

            PBYTE Base = (PBYTE)(((PBYTE)pNewEFS) + sizeof( EFS_DATA_STREAM_HEADER ));
            pNewEFS->DataDecryptionField = (ULONG)POINTER_TO_OFFSET( Base, pNewEFS  );
            memcpy( Base, pDDF, cbDDF );

            Base += cbDDF;

            //
            // Copy the DRF
            //

            if (pDRF) {
                memcpy( Base, pDRF, cbDRF );
                pNewEFS->DataRecoveryField = (ULONG)POINTER_TO_OFFSET( Base, pNewEFS );
            } else {
                pNewEFS->DataRecoveryField = 0;
            }


            // Base += cbDRF

            // EfspChecksumEfs( pNewEFS, Fek );

        } else {

            //
            // Couldn't get a UUID, fail
            //

            LsapFreeLsaHeap( pNewEFS );
            pNewEFS = NULL;
        }
    }

    return( pNewEFS );
}

BOOL
RecoveryInformationCurrent(
    PEFS_DATA_STREAM_HEADER EfsStream
    )
/*++

Routine Description:

    This routine examines the recovery information in an EFS stream and determines if
    the system recovery information has changed since this stream was generated.  It
    does this by comparing the certificate hashes stored in the current recovery
    information with the certificate hashes stored in the passed DRF.

Arguments:

    EfsStream - Supplies a pointer to the EFS stream to be examined.

Return Value:

    TRUE - Recovery information is up to date.

    FALSE - DRF must be regenerated with new recovery information.

--*/
{

    //
    // Assume that the entries in the DRF correspond to entries in the
    // current recovery information array in order.  That will simplify
    // this operation considerably.
    //

    //
    // Get a pointer to the DRF
    //

    PDRF pDrf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, EfsStream );

    //
    // For each entry in the DRF, compare hash to corresponding entry in recovery
    // policy.  Fail on first mismatch.
    //

    ULONG KeyCount = 0;

    if ((PVOID)pDrf == (PVOID)EfsStream) {

        //
        // No DRF field.
        //

        pDrf = NULL;

    }
     
    //
    // pDrf->KeyCount could be unaligned
    //

    if (pDrf) {
        RtlCopyMemory(&KeyCount, &pDrf->KeyCount, sizeof(ULONG));
    }
    
/*
    //
    // There may not be a recovery policy on this machine.  If that's the case,
    // we're just going to leave this file alone.
    //

    if (CurrentRecoveryPolicy.dwKeyCount == 0) {
        return( TRUE );
    }
*/

    if (!pDrf && CurrentRecoveryPolicy.PolicyStatus < RECOVERY_POLICY_OK) {

        //
        // Current recovery policy has no valid recovery agent and the existing $EFS
        // has no valid agent too.
        //

        return (TRUE);

    }

    if (CurrentRecoveryPolicy.dwKeyCount != KeyCount) {
        return( FALSE );
    }

    ASSERT(pDrf);
    if (!pDrf) {

        //
        // We should never get into this. This is only for the purpose of defensive.
        //

        return (TRUE);
    }

    PENCRYPTED_KEY pEncryptedKey = &pDrf->EncryptedKey[0];

    for (ULONG i=0; i<KeyCount ; i++) {

        PENCRYPTED_KEY pAlignedKey;
        BOOLEAN freeAlignedKey;

        (VOID) EfsAlignBlock(
            pEncryptedKey,
            (PVOID *)&pAlignedKey,
            &freeAlignedKey
            );
        if (!pAlignedKey) {

            //
            // OOM. Treat it as not current.
            //

            return (FALSE);

        }

        PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );
        ASSERT( PublicKeyInfo->KeySourceTag  == EfsCertificateThumbprint );

        PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, PublicKeyInfo );
        PBYTE pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
        DWORD cbHash = CertHashData->cbHash;
         
        if ((cbHash != CurrentRecoveryPolicy.cbHash[i]) || (memcmp(pbHash, CurrentRecoveryPolicy.pbHash[i], cbHash) != 0)) {

            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );                
            }
            return( FALSE );

        } else {

            pEncryptedKey = (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + pAlignedKey->Length);
            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );                
            }
        }
    }

    return( TRUE );
}


DWORD
UpdateRecoveryInformation(
    PEFS_KEY Fek,
    PEFS_DATA_STREAM_HEADER EfsStream,
    PEFS_DATA_STREAM_HEADER * UpdatedEfs
    )
/*++

Routine Description:

    This routine will create a new EFS stream based on the passed in one.
    The new EFS stream will contain a DRF based on the current recovery
    policy.  It is assumed that someone else has already verified that
    the DRF is this stream is out of date, this routine will not do that.

Arguments:

    Fek - The FEK for the file being updated.

    EfsStream - Supplies the existing EFS stream for the file.

    UpdatedEfs - Returns an updated EFS stream for the file, allocated out of heap.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{

    DWORD rc;
    DWORD cbDDF = 0;
    DWORD cbDRF = 0;
    PENCRYPTED_KEYS pNewDRF;

    *UpdatedEfs = NULL;


    //
    // Simply generate a new DRF and stick it onto the end of the existing EFS
    // stream.
    //

    PDDF pDdf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );

    cbDDF = GetLengthEncryptedKeys( pDdf );

    rc = GenerateDRF( Fek, &pNewDRF, &cbDRF);

    if (rc == ERROR_SUCCESS) {

        *UpdatedEfs = AssembleEfsStream( pDdf, cbDDF, pNewDRF, cbDRF, Fek );

        if (*UpdatedEfs == NULL) {

            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        LsapFreeLsaHeap( pNewDRF );

    }

    ReleaseRecoveryData();

    return( rc );
}


DWORD
DecryptFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    OUT PEFS_KEY * Fek,
    OUT PEFS_DATA_STREAM_HEADER * NewEfs,
    IN ULONG OpenType
    )
/*++

Routine Description:

    This routine will extract the FEK from the passed Efs stream.
    It will also check to see if the EFS stream is up to date w.r.t.
    current keys and recovery policy, and if not, it will generate
    a new one.

Arguments:


    EfsStream - Supplies the EFS stream from the file being opened.

    Fek - Returns the decrypted FEK from the EFS stream.  This data is
        allocated out of local heap and must be freed by the caller.

    NewEfs - Returns a new EFS stream for the file if necessary, otherwise
        returns NULL.  This data is allocated out of local heap and must be
        freed by the caller

    OpenType - Whether this is a normal open or an open for recovery.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD rc = ERROR_SUCCESS;
    DWORD KeyIndex;
    PEFS_DATA_STREAM_HEADER UpdatedEfs = NULL;
    BOOLEAN Recovery = FALSE;
    BOOLEAN bEfsInvalid = FALSE;
    BOOLEAN DRFIsCurrent = FALSE;
    BOOLEAN ReqUpdateDRF = FALSE;

    *Fek = NULL;
    *NewEfs = NULL;

    if (EfsStream->EfsVersion > EFS_CURRENT_VERSION) {
        return ERROR_EFS_VERSION_NOT_SUPPORT;
    }

    __try {

#if DBG

        UUID * EfsUuid = &EfsStream->EfsId;

        WCHAR * StringUuid;

        if (STATUS_SUCCESS == UuidToString ( EfsUuid, &StringUuid )) {

            DebugLog((DEB_TRACE_EFS, "Found $EFS w/ id: %ws\n" ,StringUuid  ));

            RpcStringFree( &StringUuid) ;
        }

#endif

        //
        // First try the DDF, and if we strike out there, the DRF.
        //

        PDDF Ddf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );
        PDRF Drf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField,   EfsStream );

        if ((PVOID)Drf == (PVOID)EfsStream) {

            //
            // No DRF field.
            //

            Drf = NULL;

        }

        *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Ddf, TRUE, &KeyIndex );

        if ((NULL == *Fek) && Drf) {

            *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Drf, TRUE, &KeyIndex );
            Recovery = TRUE;
        }

        if (*Fek == NULL) {

            //
            // Bad keyset means that none of the keysets in the current
            // context could decrypt this file.
            //

            if (GetLastError() == NTE_BAD_KEYSET) {

                return ( ERROR_DECRYPTION_FAILED );

            } else {

                return ( GetLastError() );
            }

        } else {

            //
            // If we opened the file via the DDF, make sure
            // that the entry we used is current for the current
            // user.
            //

            if (!Recovery) {

                if (!UserKeyCurrent( pEfsUserInfo, Ddf, KeyIndex )) {

                    //
                    // The index we used to open the file
                    // is not current. Replace with the current user
                    // key.
                    //

                    (VOID) ReplaceUserKey( pEfsUserInfo, *Fek, EfsStream, KeyIndex, &UpdatedEfs );
                }
            }

            // 
            // Checksum the EFS stream to make sure it has not been tampered with.
            // If it is changed, we will try to see if the DRF has been checnged or not.
            //
/*
            if (!EfspValidateEfsStream( EfsStream, *Fek )) {

                //
                // Checksum not match. See if the DRF changed
                //

                PENCRYPTED_KEYS  pNewDRF;
                DWORD            cbDRF;

                rc = GenerateDRF(*Fek, &pNewDRF, &cbDRF);
                if ( ERROR_SUCCESS == rc ) {

                    //
                    // Let's see if the DRF matches
                    //

                    if (EqualEncryptedKeys(Drf, pNewDRF, cbDRF)) {

                        //
                        // DRF is not modified. We can't fix the modification
                        // Regenerate the check sum.
                        //

                        DRFIsCurrent = TRUE;

                        if (!UpdatedEfs) {

                            //
                            // If $EFS is updated above, we don't need to generate the check sum again.
                            //
                        
                            UpdatedEfs = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( EfsStream->Length );
                            if (UpdatedEfs) {

                                RtlCopyMemory(UpdatedEfs, EfsStream, EfsStream->Length);
                                memset( &UpdatedEfs->EfsHash, 0, MD5_HASH_SIZE );
                                EfspChecksumEfs( UpdatedEfs, *Fek );

                            }

                        }

                        //
                        //  This is the best effort. If we failed to get the memory in the above
                        //  We will still try to let user open the file. But not fix the check sum
                        //



                    } else {

                        //
                        // Either the checksum is modified, or the DRF is modified.
                        // Do the check sum with the new DRF
                        //

                        ReqUpdateDRF = TRUE;

                    }

                    LsapFreeLsaHeap( pNewDRF );

                }

                ReleaseRecoveryData();

            }
*/


            //
            // Regardless of whether we did a recovery or not,
            // we still need to check to see if the recovery
            // information is up to snuff.
            //

            if ( !RecoveryInformationCurrent( EfsStream ) ) {

                //
                // We may have fixed up the current user key
                // above.  If so, modify that EFS stream.
                // Otherwise, use the one that the user
                // passed in.
                //

                if (UpdatedEfs) {

                    PEFS_DATA_STREAM_HEADER Tmp;
                    rc = UpdateRecoveryInformation( *Fek, UpdatedEfs, &Tmp );

                    if (ERROR_SUCCESS == rc) {
                        LsapFreeLsaHeap( UpdatedEfs );
                        UpdatedEfs = Tmp;
                    }

                } else {

                    rc = UpdateRecoveryInformation( *Fek, EfsStream, &UpdatedEfs );
                }
            }

            //
            // We successfully decrypted the file, but we may
            // not have been able to update the various parts
            // That's ok, we'll let the file decrypt.
            //
            // Note that, if there have been no updates,
            // UpdatedEfs is NULL, so this is a safe thing to do.
            //

            *NewEfs = UpdatedEfs;

            return ( ERROR_SUCCESS );
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = GetExceptionCode();
        
        //
        // Clean up
        //
        
        if (UpdatedEfs) {
          LsapFreeLsaHeap( UpdatedEfs );
        }
        
        if (*Fek != NULL) {
          LsapFreeLsaHeap( *Fek );
          *Fek = NULL;
        }
    }

    return( rc );
}



DWORD
EfsGetFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    OUT PEFS_KEY * Fek
    )
/*++

Routine Description:

    This routine will extract the FEK from the passed Efs stream.

Arguments:


    EfsStream - Supplies the EFS stream from the file being opened.

    Fek - Returns the decrypted FEK from the EFS stream.  This data is
        allocated out of local heap and must be freed by the caller.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD rc = ERROR_SUCCESS;
    DWORD KeyIndex;

    *Fek = NULL;

    __try {


        //
        // First try the DDF, and if we strike out there, the DRF.
        //

        PDDF Ddf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );
        PDRF Drf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField,   EfsStream );

        *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Ddf, FALSE, &KeyIndex );

        if ((NULL == *Fek) && ( (PVOID)Drf != (PVOID)EfsStream) ) {

            *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Drf, FALSE, &KeyIndex );
        
        }

        if (*Fek == NULL) {

                return (rc = GetLastError() );

        }
    }  __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = GetExceptionCode();
        
        if (*Fek != NULL) {
          LsapFreeLsaHeap( *Fek );
          *Fek = NULL;
        }
    }

    return( rc );

}


PEFS_KEY
ExtractFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTED_KEY EncryptedKey,
    IN BOOL CheckBits
    )

/*++

Routine Description:

    This routine will take the passed EncryptedKey structure and attempt
    to decrypt the FEK encoded in the structure.  It will do this by first
    attempting to create context using the Provider and Container names
    contained in the structure.  If such a context exists, its key
    exchange key is used to import the encrypted session key from the
    structure.

    Once the session key has been imported, it is used to decrypt the encrypted
    FEK structure.  All of the pieces are then used to reconstruct the key
    integrity information structure, and if this verifies, then it is assumed
    that the FEK has been decoded correctly.

Arguments:

    pEfsUserInfo - User Info.

    EncryptedKey - Supplies a pointer to an EncryptedKey from the file being opened.
    
    CheckBits - TRUE will check the encryption bits against current version.

Return Value:

    On success, returns a pointer to a decrypted FEK.  On failure, returns NULL.

    The returned pointer is allocated out of heap and must be freed.

--*/
{
    //
    // Obtain a context to the user's RSA key
    //

    DWORD LastError = ERROR_SUCCESS;
    PEFS_KEY DecryptedFEK = NULL;
    PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO) OFFSET_TO_POINTER(PublicKeyInfo, EncryptedKey);
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey;

    HCRYPTPROV hWkProv;
    HCRYPTKEY hWkKey;

    switch (PublicKeyInfo->KeySourceTag) {
        case EfsCertificateThumbprint:
            {
                //
                // See if there is a cert in the current context
                // that corresponds to this thumbprint.  If so,
                // we're in business.
                // The KeySourceTag has been changed a couple of times
                // during the development. Now this is the only valid tag.
                //

                PBYTE pbHash;
                DWORD cbHash;

                PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, PublicKeyInfo );
                pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
                cbHash = CertHashData->cbHash;

                LastError = GetKeyInfoFromCertHash(
                                pEfsUserInfo,
                                pbHash,
                                cbHash,
                                &hKey,
                                &hProv,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

                if (LastError != ERROR_SUCCESS) {
                    SetLastError( LastError );
                    return( NULL );
                }

                break;
            }

        default:
            return( NULL );
            break;
    }

    if (hKey) {

        //
        //  We are not using the cache.
        //

        hWkKey = hKey;

    } else {

        ASSERT(pEfsUserInfo->pUserCache);

        hWkKey = pEfsUserInfo->pUserCache->hUserKey;

    }

    //
    // Decrypt the FEK field with the session key
    //

    PBYTE EncryptedFEK = (PBYTE)OFFSET_TO_POINTER( EncryptedFEK, EncryptedKey );

    //
    // Copy the FEK into a temporary buffer for decryption
    //

    DWORD cbData = EncryptedKey->EncryptedFEKLength;

    DecryptedFEK = (PEFS_KEY)LsapAllocateLsaHeap( cbData );

    if (DecryptedFEK != NULL) {

        memcpy( DecryptedFEK, EncryptedFEK, cbData );

        BOOL Verified = FALSE;

        if (CryptDecrypt( hWkKey, 0, TRUE, 0, (PBYTE)DecryptedFEK, &cbData )) {

            //
            // First, perform a sanity check: make sure the key we just decrypted has a length field
            // that's reasonable.  If not, we got back garbage.
            //

            if (EFS_KEY_SIZE( DecryptedFEK) <= cbData) {

                //
                // Check the Entropy and the salt here
                //

                PEFS_KEY_SALT pEfsKeySalt = (PEFS_KEY_SALT)OFFSET_TO_POINTER( EfsKeySalt, EncryptedKey );

                if ( (KeyEntropy == EXPORT_KEY_STRENGTH) && CheckBits){
                    if ( DecryptedFEK->Entropy <= KeyEntropy ){

                        //
                        // Check the salt
                        //

                        DWORD SaltLength;
                        DWORD SaltBlockLength;

                        if (GetSaltLength(DecryptedFEK->Algorithm, &SaltLength,&SaltBlockLength)){
                            if ( pEfsKeySalt ){
                                Verified = (memcmp( EFS_KEY_DATA(DecryptedFEK), (PBYTE)pEfsKeySalt + sizeof(EFS_KEY_SALT), SaltLength ) == 0);
                            } else {

                                //
                                // This should not happen
                                //

                                ASSERT(FALSE);
                                Verified = FALSE;
                            }

                        } else {

                            //
                            // This algorithm has no salt
                            //

                            Verified = TRUE;
                        }

                    } else {

                        //
                        // Export version cannot decrypt files encrypted with longer keys
                        //

                        Verified = FALSE;
                    }

                } else {

                    Verified = TRUE;
                }

//robertg       Now you have a pointer to the salt structure to play with.  Set Verified == TRUE if
//              everything checks out.

            }

        } else {

            //
            // If we got back a bad length error, that means that the plaintext of
            // FEK was larger than the cyphertext.  Assume that this can't happen,
            // since the CryptDecrypt interface doesn't seem to be able to handle
            // this situation.
            //

            ASSERT(GetLastError() != NTE_BAD_LEN);

            LastError = GetLastError();
        }

        if (!Verified) {

            LsapFreeLsaHeap( DecryptedFEK );
            DecryptedFEK = NULL;

            LastError = ERROR_DECRYPTION_FAILED;
        }

    } else {

        LastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Clean up what we allocated.
    //

    if (hKey) {

        CryptDestroyKey( hKey );
        CryptReleaseContext( hProv, 0 );

    }


    SetLastError( LastError );

    return( DecryptedFEK );
}


BOOLEAN
GenerateFEK(
    IN OUT PEFS_KEY *Key
    )

/*++

Routine Description:

    Generates a new File Encryption Key (FEK).

Arguments:

    Key - Supplies a pointer to PEFS_KEY.

Return Value:

    Error if not enough space can be located.


--*/
{
    PBYTE KeyData;
    ULONG   KeyLength;
    BOOL b = FALSE;
    DWORD LiveKeyEntropy;

    //
    // Allocate the buffer for the EFS_KEY.
    // Set the algorithm and key length here.
    //

    switch (EfsAlgInForce) {

        case CALG_3DES:
    
            //
            // DES3 has no international version
            //
    
            KeyLength = DES3_KEYSIZE;
            LiveKeyEntropy = DES3_KEY_STRENGTH;
            break;
    
        case CALG_DESX:
            KeyLength = DESX_KEYSIZE - 8;
            LiveKeyEntropy = KeyEntropy;
            break;
    
        case CALG_AES_256:
        default:
            
            KeyLength = AES_KEYSIZE_256;
            LiveKeyEntropy = AES_KEY_STRENGTH_256;
            break;

    }

    *Key = (PEFS_KEY)LsapAllocateLsaHeap( sizeof( EFS_KEY ) + KeyLength );
    if ( NULL == *Key ){
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    (*Key)->KeyLength = KeyLength;
    (*Key)->Algorithm = EfsAlgInForce;


    KeyData = (PBYTE)(((PBYTE)*Key) + sizeof( EFS_KEY ));

    if (b = CryptGenRandom( hProvVerify, (*Key)->KeyLength, KeyData )) {
        (*Key)->Entropy = LiveKeyEntropy;
    } else {
        LsapFreeLsaHeap( *Key );
        *Key = NULL;
    }


    return( b != 0);
}



DWORD
CreatePublicKeyInformationCertificate(
    IN PSID  pUserSid OPTIONAL,
    PBYTE pbCert,
    DWORD cbCert,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    )
{
    DWORD PublicKeyInformationLength = 0;
    DWORD UserSidLength = 0;
    PWCHAR Base;

    if (pUserSid != NULL) {
        UserSidLength = GetLengthSid( pUserSid );
    }

    //
    // Total size is the size of the public key info structure, the size of the
    // cert hash data structure, the length of the thumbprint, and the lengths of the
    // container name and provider name if they were passed.
    //

    PublicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + UserSidLength + cbCert;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO)LsapAllocateLsaHeap( PublicKeyInformationLength );

    if (*PublicKeyInformation == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    (*PublicKeyInformation)->Length = PublicKeyInformationLength;
    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificate;

    //
    // Copy the string and SID data to the end of the structure.
    //

    Base = (PWCHAR)(*PublicKeyInformation);
    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_PUBLIC_KEY_INFO ));

    if (pUserSid != NULL) {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );
        CopySid( UserSidLength, (PSID)Base, pUserSid );

    } else {

        (*PublicKeyInformation)->PossibleKeyOwner = 0;
    }

    Base = (PWCHAR)((PBYTE)Base + UserSidLength);

    (*PublicKeyInformation)->CertificateInfo.CertificateLength = cbCert;
    (*PublicKeyInformation)->CertificateInfo.Certificate = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );

    memcpy( (PBYTE)Base, pbCert, cbCert );

    return( ERROR_SUCCESS );

}



BOOLEAN
CreatePublicKeyInformationThumbprint(
    IN PSID  pUserSid OPTIONAL,
    IN PBYTE pbCertHash,
    IN DWORD cbCertHash,
    IN LPWSTR lpDisplayInformation OPTIONAL,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR ProviderName OPTIONAL,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    )

/*++

Routine Description:

    This routine creates an EFS_PUBLIC_KEY_INFO structure that can be
    placed in an EFS stream.

Arguments:

    ContainerName - The name of the container containing the public key.  This
        parameter is not optional if ProviderName is passed.

    ProviderName - The name of the provider containing the public key.  This
        parameter is not optional if ContainerName is passed.

    pbPublicKeyBlob - The actual public key blob exported from CryptAPI

    KeySource - Data for the KeySource field in the public key structure

    cbPublicKeyBlob - The length of the public key blob in bytes

    PublicKeyInformation - Returns the filled in EFS_PUBLIC_KEY_INFO
        structure.


Return Value:

    ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY as appropriate

--*/
{
    DWORD PublicKeyInformationLength = 0;
    DWORD cbThumbprint = 0;
    DWORD UserSidLength = 0;
    PWCHAR Base;

    if (pUserSid != NULL) {
        UserSidLength = GetLengthSid( pUserSid );
    }

    //
    // Total size is the size of the public key info structure, the size of the
    // cert hash data structure, the length of the thumbprint, and the lengths of the
    // container name and provider name if they were passed.
    //

    PublicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + UserSidLength;

    cbThumbprint = sizeof( EFS_CERT_HASH_DATA ) + cbCertHash;

    if (ContainerName != NULL ) {
        cbThumbprint += (wcslen( ContainerName ) + 1) * sizeof( WCHAR );
    }

    if (ProviderName != NULL ) {
       cbThumbprint += (wcslen( ProviderName ) + 1) * sizeof( WCHAR );
    }

    if (lpDisplayInformation != NULL) {
        cbThumbprint += (wcslen( lpDisplayInformation ) + 1) * sizeof( WCHAR );
    }

    PublicKeyInformationLength += cbThumbprint;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO)LsapAllocateLsaHeap( PublicKeyInformationLength );

    if (*PublicKeyInformation == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );
    }

    (*PublicKeyInformation)->Length = PublicKeyInformationLength;

    //
    // Mark the information as from CryptoAPI, since that's all we support right now.
    //

    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificateThumbprint;

    //
    // Copy the string and SID data to the end of the structure.
    //

    Base = (PWCHAR)(*PublicKeyInformation);
    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_PUBLIC_KEY_INFO ));

    if (pUserSid != NULL) {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );
        CopySid( UserSidLength, (PSID)Base, pUserSid );

    } else {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)0;
    }

    Base = (PWCHAR)((PBYTE)Base + UserSidLength);

    PEFS_CERT_HASH_DATA pCertHashData;

    (*PublicKeyInformation)->CertificateThumbprint.ThumbprintLength = cbThumbprint;
    (*PublicKeyInformation)->CertificateThumbprint.CertHashData = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );

    pCertHashData = (PEFS_CERT_HASH_DATA)Base;

    //
    // Zero the header, eliminate the garbage if any of Container, Provide or Display
    // Information is NULL.
    //

    RtlZeroMemory(pCertHashData, sizeof( EFS_CERT_HASH_DATA ));

    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_CERT_HASH_DATA ));

    //
    // Copy the hash data to the end of the cert hash data block,
    // and set the offset from the *beginning of the cert hash data block
    // (not the beginning of the public key info structure)
    //

    pCertHashData->cbHash = cbCertHash;
    pCertHashData->pbHash = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
    memcpy( (PBYTE)Base, pbCertHash, cbCertHash );

    Base = (PWCHAR)((PBYTE)Base + cbCertHash);

    //
    // If we have Container/Provider hint info, copy them in now
    //

    if (ContainerName != NULL) {

        pCertHashData->ContainerName = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
        wcscpy( (PWCHAR)Base, ContainerName );

        //
        // wcscpy copies trailing NULL characters, but wcslen doesn't include them in returned lengths,
        // so add 1 to adjust.
        //

        Base += (wcslen( ContainerName ) + 1);

    }

    if (ProviderName != NULL) {

       //
       // Store the offset into the session key structure
       //

       pCertHashData->ProviderName = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
       wcscpy( (PWCHAR)Base, ProviderName );

       Base += (wcslen( ProviderName ) + 1);

    }

    if (lpDisplayInformation != NULL) {
        pCertHashData->lpDisplayInformation = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
        wcscpy( (PWCHAR)Base, lpDisplayInformation );

        Base += (wcslen( lpDisplayInformation ) + 1);
    }

    return( TRUE );
}


DWORD
ConstructEncryptedKey(
    PBYTE EncryptedFEK,
    DWORD dwEncryptedFEKLength,
    PEFS_PUBLIC_KEY_INFO PublicKeyInformation,
    PEFS_KEY_SALT pEfsKeySalt OPTIONAL,
    OUT PENCRYPTED_KEY *EncryptedKey,
    OUT PDWORD EncryptedKeySize
    )

/*++

Routine Description:

    This routine constructs an ENCRYPTED_KEY structure from the passed
    arguments.

Arguments:

    EncryptedFEK - The encrypted FEK.

    dwEncryptedFEKLength - The length of the encrypted FEK in bytes.

    PublicKeyInformation - The public key information stucture containing
        the public key.

    pEfsKeySalt - Salt block.

    EncryptedKey - Returns the encrypted key structure.

    EncryptedKeySize - Supplies the length of the encrypted
        key structure.  Returns the actual length used or required.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Out of memory.

    ERROR_SUCCESS - Success

--*/
{
    //
    // We now have all the information we need to construct the EncryptedKeys structure
    // Compute the total size required
    //

    DWORD KeySize = sizeof( ENCRYPTED_KEY )   +
                    dwEncryptedFEKLength       +
                    PublicKeyInformation->Length;

    if (pEfsKeySalt){
        KeySize += pEfsKeySalt->Length;
    }

    *EncryptedKey = (PENCRYPTED_KEY) LsapAllocateLsaHeap( KeySize );

    if ( NULL == *EncryptedKey ) {
        *EncryptedKeySize = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *EncryptedKeySize = KeySize;


    PBYTE Base;

    (*EncryptedKey)->Length = *EncryptedKeySize;
    Base = (PBYTE)(((PBYTE)*EncryptedKey) + sizeof( ENCRYPTED_KEY ));

    //
    // Copy in the public key info structure
    //

    memcpy( Base, PublicKeyInformation, PublicKeyInformation->Length );

    //
    // Save offset to what we just copied.
    //

    (*EncryptedKey)->PublicKeyInfo = (ULONG)POINTER_TO_OFFSET(Base, *EncryptedKey);
    Base += PublicKeyInformation->Length;


    //
    // Copy the FEK, which is a completely encrypted structure
    //

    memcpy( Base, EncryptedFEK, dwEncryptedFEKLength );
    (*EncryptedKey)->EncryptedFEK = (ULONG)POINTER_TO_OFFSET(Base, *EncryptedKey);
    (*EncryptedKey)->EncryptedFEKLength = dwEncryptedFEKLength;
    Base += dwEncryptedFEKLength;

    //
    // Copy the Salt Information
    //

    if (pEfsKeySalt){
        memcpy( Base, pEfsKeySalt, pEfsKeySalt->Length );
        (*EncryptedKey)->EfsKeySalt = (ULONG)POINTER_TO_OFFSET(Base, *EncryptedKey);
    } else {
        (*EncryptedKey)->EfsKeySalt = 0;
    }

    return( ERROR_SUCCESS );
}


PBYTE
EncryptFEK(
    IN PEFS_KEY Fek,
    IN HCRYPTKEY hRSAKey,
    OUT PDWORD dwEncryptedFEKLength
    )
{
    DWORD rc=ERROR_SUCCESS;
    
    *dwEncryptedFEKLength = EFS_KEY_SIZE( Fek );

    //
    // If CryptoAPI worked properly, we wouldn't need this, but it doesn't,
    // so we do.
    //


    if (CryptEncrypt( hRSAKey, 0, TRUE, 0, NULL, dwEncryptedFEKLength, 0 )) {

        DWORD BufferLength = (*dwEncryptedFEKLength < EFS_KEY_SIZE(Fek)) ? EFS_KEY_SIZE(Fek) : *dwEncryptedFEKLength;

        PBYTE EncryptedFEK = (PBYTE)LsapAllocateLsaHeap( BufferLength );

        if (EncryptedFEK != NULL) {

            //
            // Copy the FEK into our new buffer and encrypt it there.
            //

            memcpy( EncryptedFEK, Fek, EFS_KEY_SIZE( Fek ) );

            //
            // Reset the length of the data to be encrypted
            //

            *dwEncryptedFEKLength = EFS_KEY_SIZE( Fek );

            if (CryptEncrypt( hRSAKey, 0, TRUE, 0, EncryptedFEK, dwEncryptedFEKLength, BufferLength )) {
                return( EncryptedFEK );

            } else {

                rc = GetLastError();
                DebugLog((DEB_ERROR, "EncryptFEK: 2nd CryptEncrypt failed, error = %x\n" , rc  ));
            }

            //
            // If we're here, we failed, clean up
            //

            LsapFreeLsaHeap( EncryptedFEK );

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        rc = GetLastError();
        DebugLog((DEB_ERROR, "EncryptFEK: 1st CryptEncrypt failed, error = %x\n" , rc  ));
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
    }
    return( NULL );
}

BOOL
RemoveUsersFromEfsStream(
    IN PEFS_DATA_STREAM_HEADER pEfsStream,
    IN DWORD nHashes,
    IN PENCRYPTION_CERTIFICATE_HASH * pHashes,
    IN PEFS_KEY Fek,
    OUT PEFS_DATA_STREAM_HEADER * pNewEfsStream
    )
/*++

Routine Description:

    This routine removes the passed users from the passed EFS
    stream, and returns a new one to be applied to the file.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    //
    // First, see how many matches there are so we can compute
    // the final size of the structure we're going to have to
    // allocate.
    //

    DWORD cbSizeToDelete = 0;
    DWORD nKeysToDelete = 0;
    DWORD rc = ERROR_SUCCESS;
    BOOL b = FALSE;

    PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfsStream );

    DWORD KeyCount = pDDF->KeyCount;

    PDWORD KeyIndiciesToDelete = (PDWORD)LsapAllocateLsaHeap( KeyCount * sizeof( DWORD ));

    if (KeyIndiciesToDelete) {

        memset( KeyIndiciesToDelete, 0, KeyCount * sizeof( DWORD ));

        //
        // First pass: walk the list of keys in the DDF and compare each one to the
        // keys in the list of hashes passed.  Count the matches and keep track of the
        // total size of the resulting structure.
        //

        PENCRYPTED_KEY pEncryptedKey = &pDDF->EncryptedKey[0];

        for (DWORD i=0; i<KeyCount ; i++, pEncryptedKey = NEXT_ENCRYPTED_KEY( pEncryptedKey )) {


            PENCRYPTED_KEY pAlignedKey;
            BOOLEAN freeAlignedKey;
    
            rc =  EfsAlignBlock(
                            pEncryptedKey,
                            (PVOID *)&pAlignedKey,
                            &freeAlignedKey
                            );
            if (!pAlignedKey) {
    
                //
                // OOM. Treat it as not current.
                //
    
                rc = ERROR_NOT_ENOUGH_MEMORY; 
                nKeysToDelete = 0;
                break;
    
            }

            PEFS_PUBLIC_KEY_INFO pPublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );

            ASSERT( pPublicKeyInfo->KeySourceTag == EfsCertificateThumbprint );

            PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, pPublicKeyInfo );
            DWORD cbHash = CertHashData->cbHash;
            PBYTE pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );

            //
            // Compare the hash data with all of the data in the array
            //

            __try{

                for (DWORD j=0; j<nHashes ; j++) {
    
                    PENCRYPTION_CERTIFICATE_HASH pHash = pHashes[j];
                    PEFS_HASH_BLOB pHashBlob = pHash->pHash;
    
                    if (pHashBlob->cbData == cbHash ) {
    
                        if (memcmp( pHashBlob->pbData, pbHash, cbHash ) == 0) {
    
                            //
                            // We have a match.  That means that this entry is going to be removed from
                            // the DDF when it is rebuilt.
                            //
    
                            cbSizeToDelete += pAlignedKey->Length;
                            KeyIndiciesToDelete[nKeysToDelete] = i;
                            nKeysToDelete++;
    
                            break;
                        }
                    }
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                //
                // The passed in pHashes is bad
                //

                nKeysToDelete = 0;
                rc = ERROR_INVALID_PARAMETER;

            }

            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );
            }

            if (ERROR_INVALID_PARAMETER == rc) {
                break;
            }
        }

        if (nKeysToDelete != 0) {

            //
            // We made at least one match.  The size of the new efs stream is the size of
            // the old one minus the size of the stuff we're deleting.
            //

            DWORD cbNewEfsStream = pEfsStream->Length - cbSizeToDelete;
            cbNewEfsStream = (cbNewEfsStream + 7) & 0xfffffff8;

            *pNewEfsStream = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( cbNewEfsStream );

            if (*pNewEfsStream) {

                //
                // Copy the old header to the new structure.
                //

                **pNewEfsStream = *pEfsStream;
                ((PEFS_DATA_STREAM_HEADER)*pNewEfsStream)->Length = cbNewEfsStream;

                //
                // Copy the old DDF to the new DDF, skipping the
                // ones we want to delete
                //

                //
                // Base is our target.  Make it point to the end of the header, which
                // is where we're going to start copying the new DDF.
                //

                PBYTE Base = (PBYTE) (((PBYTE)(*pNewEfsStream)) + sizeof( EFS_DATA_STREAM_HEADER ));

                //
                // Set the offset of the new DDF into the header.
                //

                (*pNewEfsStream)->DataDecryptionField = (ULONG)POINTER_TO_OFFSET( Base, *pNewEfsStream );

                //
                // Start to assemble the new DDF
                //

                PENCRYPTED_KEYS pNewDDF = (PENCRYPTED_KEYS)Base;
                pNewDDF->KeyCount = KeyCount - nKeysToDelete;

                Base = (PBYTE)(&pNewDDF->EncryptedKey[0]);
                PBYTE Source = (PBYTE)(&pDDF->EncryptedKey[0]);

                DWORD NextKeyIndexToDelete = 0;

                for (DWORD i=0; i<KeyCount ; i++) {

                    if (KeyIndiciesToDelete[NextKeyIndexToDelete] != i) {

                        //
                        // We're not going to delete this one, copy it.
                        //

                        DWORD KeyLength = * (DWORD UNALIGNED *) &(((PENCRYPTED_KEY)Source)->Length);

                        memcpy( Base, Source, KeyLength );

                        Base = (PBYTE)NEXT_ENCRYPTED_KEY( Base );
                        Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );

                    } else {

                        //
                        // We're going to delete this one.  Leave Base
                        // alone, but bump Source to the next key.
                        //

                        Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );
                        NextKeyIndexToDelete++;

                    }
                }

                //
                // The new DDF is in place.  Copy the recovery information
                // from the old EFS stream into the new one.
                //
                // Base points to where the DRF needs to go, and Source
                // points to where the old one is (in theory).
                //

                ASSERT( Source == (PBYTE)OFFSET_TO_POINTER( DataRecoveryField, pEfsStream ));

                PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)Source;

                //
                // Set the offset of the new DRF into the new EFS stream.
                //

                if ((PVOID)pDRF == (PVOID)pEfsStream) {

                    //
                    // No DRF in the old $EFS
                    //

                    (*pNewEfsStream)->DataRecoveryField = 0;

                } else {

                    (*pNewEfsStream)->DataRecoveryField = (ULONG)POINTER_TO_OFFSET( Base, *pNewEfsStream );
    
                    //
                    // We can copy the old DRF directly into the new one, since nothing in
                    // it is changing.
                    //
    
                    //
                    // Base now points to the top of an ENCRYPTED_KEYS structure.
                    // Fill in its header.
                    //
    
                    PENCRYPTED_KEYS pNewDRF = (PENCRYPTED_KEYS)Base;
                    RtlCopyMemory(&(pNewDRF->KeyCount), &(pDRF->KeyCount), sizeof(ULONG));
                    RtlCopyMemory(&KeyCount, &(pDRF->KeyCount), sizeof(ULONG));
                    //
                    // That was the header.  Now start copying the
                    // encrypted keys themselves.
                    //
    
                    Base = (PBYTE)(&pNewDRF->EncryptedKey[0]);
                    Source = (PBYTE)(&pDRF->EncryptedKey[0]);
    
                    for (i=0; i<KeyCount ; i++) {
    
                        DWORD KeyLength = * (DWORD UNALIGNED *) &(((PENCRYPTED_KEY)Source)->Length);
    
                        memcpy( Base, Source, KeyLength );
    
                        Base = (PBYTE)NEXT_ENCRYPTED_KEY( Base );
                        Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );
                    }

                }

                b = TRUE;


//                memset( &((*pNewEfsStream)->EfsHash), 0, MD5_HASH_SIZE );
//                if (EfspChecksumEfs( *pNewEfsStream, Fek )) {
//                    b = TRUE;
//                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            if (ERROR_SUCCESS == rc) {
               b = TRUE;
            }

        }

        LsapFreeLsaHeap( KeyIndiciesToDelete );

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;

    }

    if (!b) {

        //
        // Something failed, clean up what we were going
        // to return.
        //

        if (*pNewEfsStream) {
            LsapFreeLsaHeap( *pNewEfsStream );
            *pNewEfsStream = NULL;  // paranoia
        }
    }

    SetLastError(rc);
    return( b );
}


BOOL
QueryCertsFromEncryptedKeys(
    IN PENCRYPTED_KEYS pEncryptedKeys,
    OUT PDWORD pnUsers,
    OUT PENCRYPTION_CERTIFICATE_HASH ** pHashes
    )
/*++

Routine Description:

    This routine takes a set of encrypted keys and returns the data
    that we wish to display about each one.

Arguments:

    pEncryptedKeys - Supplies the array of encrypted keys.

    pnUsers - Returns the number of users on the file.

    pHashes - Returns the hash information about each user.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    DWORD rc = ERROR_SUCCESS;
    PENCRYPTION_CERTIFICATE_HASH pTmp = NULL;

    //
    // Walk the entries in the encrypted keys and return the information we want about each one.
    //

    DWORD KeyCount = * (DWORD UNALIGNED *) &(pEncryptedKeys->KeyCount);
    *pnUsers = KeyCount;
    PENCRYPTED_KEY pEncryptedKey = &pEncryptedKeys->EncryptedKey[0];

    //
    // *pHashes points to an array of pointers to ENCRYPTION_CERTIFICATE_HASH structures.
    // There will be one entry for each Key on the file
    //

    *pHashes = (PENCRYPTION_CERTIFICATE_HASH *)MIDL_user_allocate( sizeof(PENCRYPTION_CERTIFICATE_HASH) * KeyCount );

    if (*pHashes) {

        memset( *pHashes, 0, sizeof(PENCRYPTION_CERTIFICATE_HASH) * KeyCount );

        for (DWORD i=0;
             i < KeyCount;
             i++, pEncryptedKey = NEXT_ENCRYPTED_KEY( pEncryptedKey )
             ) {


            PENCRYPTED_KEY pAlignedKey;
            BOOLEAN freeAlignedKey;
    
            rc =  EfsAlignBlock(
                            pEncryptedKey,
                            (PVOID *)&pAlignedKey,
                            &freeAlignedKey
                            );
            if (!pAlignedKey) {
    
                //
                // OOM. Treat it as not current.
                //
    
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
    
            }

            PEFS_PUBLIC_KEY_INFO pPublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );

            ASSERT( pPublicKeyInfo->KeySourceTag == EfsCertificateThumbprint );

            PENCRYPTION_CERTIFICATE_HASH pTmp = (PENCRYPTION_CERTIFICATE_HASH) MIDL_user_allocate( sizeof(ENCRYPTION_CERTIFICATE_HASH ));

            if (pTmp) {

                memset( pTmp, 0, sizeof( ENCRYPTION_CERTIFICATE_HASH ));

                pTmp->cbTotalLength = sizeof( ENCRYPTION_CERTIFICATE_HASH );

                if (pPublicKeyInfo->PossibleKeyOwner) {

                    PSID pUserSid = ( PSID )OFFSET_TO_POINTER( PossibleKeyOwner, pPublicKeyInfo );

                    pTmp->pUserSid = (SID *)MIDL_user_allocate( GetLengthSid( pUserSid ));

                    if (pTmp->pUserSid) {

                        CopySid( GetLengthSid( pUserSid ),
                                 pTmp->pUserSid,
                                 pUserSid
                                 );
                    } else {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }

                } else {

                    pTmp->pUserSid = NULL;
                }

                //
                // Copy the hash
                //

                if (rc == ERROR_SUCCESS) {

                    pTmp->pHash = (PEFS_HASH_BLOB)MIDL_user_allocate( sizeof( EFS_HASH_BLOB ));

                    if (pTmp->pHash) {

                        PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, pPublicKeyInfo );

                        pTmp->pHash->cbData = CertHashData->cbHash;
                        pTmp->pHash->pbData = (PBYTE)MIDL_user_allocate( pTmp->pHash->cbData );

                        if (pTmp->pHash->pbData) {

                            memcpy( pTmp->pHash->pbData, OFFSET_TO_POINTER( pbHash, CertHashData ), pTmp->pHash->cbData );
                            ASSERT( rc == ERROR_SUCCESS );

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if (rc == ERROR_SUCCESS) {

                            //
                            // Allocate and fill in the display information field.
                            //

                            if (CertHashData->lpDisplayInformation) {

                                LPWSTR lpDisplayInformation = (LPWSTR)OFFSET_TO_POINTER( lpDisplayInformation, CertHashData );

                                pTmp->lpDisplayInformation = (LPWSTR)MIDL_user_allocate( (wcslen( lpDisplayInformation ) + 1) * sizeof( WCHAR ));

                                if (pTmp->lpDisplayInformation) {

                                    wcscpy( pTmp->lpDisplayInformation, lpDisplayInformation );
                                    (pTmp->lpDisplayInformation)[wcslen(lpDisplayInformation)] = UNICODE_NULL;

                                    ASSERT( rc == ERROR_SUCCESS );

                                } else {

                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }
                        }

                    } else {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (rc != ERROR_SUCCESS) {

                //
                // We couldn't successfully build this structure.  Free up
                // all the stuff we were going to return and drop out of the loop.
                //

                if (pTmp) {
                    if (pTmp->pHash) {
                        if (pTmp->pHash->pbData) {
                           MIDL_user_free( pTmp->pHash->pbData );
                        }
                        MIDL_user_free( pTmp->pHash );
                    }
   
                    if (pTmp->lpDisplayInformation) {
                        MIDL_user_free( pTmp->lpDisplayInformation );
                    }
   
                    if (pTmp->pUserSid) {
                        MIDL_user_free( pTmp->pUserSid );
                    }
   
                    MIDL_user_free( pTmp );
                }

                if (freeAlignedKey) {
                    LsapFreeLsaHeap( pAlignedKey );
                }

                break;

            } else {

                (*pHashes)[i] = pTmp;
                if (freeAlignedKey) {
                    LsapFreeLsaHeap( pAlignedKey );
                }
            }
        }

        if (rc != ERROR_SUCCESS) {

            //
            // Something failed along the way, walk down the list of ones
            // we successfully allocated and free them up.  Any partially
            // allocated ones will have been cleaned up above.
            //

            DWORD i=0;

            while ( (*pHashes)[i] ) {

                pTmp = (*pHashes)[i];

                ASSERT( pTmp->pHash );
                ASSERT( pTmp->pHash->pbData );

                MIDL_user_free( pTmp->pHash->pbData );
                MIDL_user_free( pTmp->pHash );
                if (pTmp->lpDisplayInformation) {
                    MIDL_user_free( pTmp->lpDisplayInformation );
                }
                if (pTmp->pUserSid) {
                    MIDL_user_free( pTmp->pUserSid );
                }
                MIDL_user_free( pTmp );

                (*pHashes)[i] = NULL;
                i++;
            }

            MIDL_user_free( *pHashes );
        }

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError( rc );

    return( ERROR_SUCCESS == rc ? TRUE : FALSE );
}


BOOL
EfsErrorToNtStatus(
    IN DWORD WinError,
    OUT PNTSTATUS NtStatus
    )
{
    switch (WinError) {
        case ERROR_ENCRYPTION_FAILED:
            {
                *NtStatus = STATUS_ENCRYPTION_FAILED;
                break;
            }
        case NTE_BAD_KEYSET:
        case CRYPT_E_NOT_FOUND:
        case ERROR_DECRYPTION_FAILED:
            {
                *NtStatus = STATUS_DECRYPTION_FAILED;
                break;
            }
        case ERROR_FILE_ENCRYPTED:
            {
                *NtStatus = STATUS_FILE_ENCRYPTED;
                break;
            }
        case ERROR_NO_RECOVERY_POLICY:
            {
                *NtStatus = STATUS_NO_RECOVERY_POLICY;
                break;
            }
        case ERROR_NO_EFS:
            {
                *NtStatus = STATUS_NO_EFS;
                break;
            }
        case ERROR_WRONG_EFS:
            {
                *NtStatus = STATUS_WRONG_EFS;
                break;
            }
        case ERROR_NO_USER_KEYS:
            {
                *NtStatus = STATUS_NO_USER_KEYS;
                break;
            }
        case ERROR_FILE_NOT_ENCRYPTED:
            {
                *NtStatus = STATUS_FILE_NOT_ENCRYPTED;
                break;
            }
        case ERROR_NOT_EXPORT_FORMAT:
            {
                *NtStatus = STATUS_NOT_EXPORT_FORMAT;
                break;
            }
        case ERROR_OUTOFMEMORY:
            {
                *NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        case ERROR_ACCESS_DENIED:
            {
                *NtStatus = STATUS_ACCESS_DENIED;
                break;
            }
        default:
            {
                DebugLog((DEB_WARN, "EfsErrorToNtStatus, unable to translate 0x%x\n" , WinError  ));
                return( FALSE );
                break;
            }
    }

    return( TRUE );
}


VOID
DumpBytes(
    PBYTE Blob,
    ULONG Length,
    ULONG IndentLevel
    )
{

    const UINT Columns = 8;
    UINT Rows = Length / Columns;
    if (Length % Columns != 0) {
        Rows++;
    }

    for (UINT j=0; j<Rows ; j++) {
        for (UINT k=0; k<IndentLevel ; k++) {
            DbgPrint("\t");
        }
        for (UINT i=0; i<Columns ; i++) {
            DbgPrint("%02X ",Blob[ j*Columns + i ]);
            if ((j*Columns + i) == Length) {
                break;
            }
        }
        DbgPrint("\n");
    }
}


VOID
DumpPublicKeyInfo(
    PEFS_PUBLIC_KEY_INFO PublicKeyInfo
    )
{
    DbgPrint("\t\tPublicKeyInfo:\n");
    DbgPrint("\t\tLength = 0x%x\n",PublicKeyInfo->Length);

    if (PublicKeyInfo->PossibleKeyOwner != NULL) {

        PWCHAR SidString = ConvertSidToWideCharString( OFFSET_TO_POINTER( PossibleKeyOwner, PublicKeyInfo) );
        DbgPrint("\t\tUserSid = %ws\n",SidString);
        LsapFreeLsaHeap( SidString );

    } else {

        DbgPrint("\t\tUserSid = NULL\n");
    }

    switch (PublicKeyInfo->KeySourceTag) {
        case EfsCryptoAPIContainer:
            {
                DbgPrint("\t\tTag = EfsCryptoAPIContainer\n");
                DbgPrint("\t\tContainerName = %ws\n",OFFSET_TO_POINTER( ContainerInfo.ContainerName, PublicKeyInfo ));
                DbgPrint("\t\tProviderName = %ws\n",OFFSET_TO_POINTER( ContainerInfo.ProviderName, PublicKeyInfo ));

                DbgPrint("\t\tPublicKeyBlobLength = 0x%x\n",PublicKeyInfo->ContainerInfo.PublicKeyBlobLength);

                DumpBytes( (PBYTE)OFFSET_TO_POINTER( ContainerInfo.PublicKeyBlob, PublicKeyInfo ), PublicKeyInfo->ContainerInfo.PublicKeyBlobLength, 2 );

                break;
            }
        case EfsCertificateThumbprint:
            {

                DbgPrint("\t\tTag = EfsCertificateThumbprint\n");
                PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, PublicKeyInfo );

                LPWSTR ContainerName = NULL;

                if (CertHashData->ContainerName) {
                    LPWSTR ContainerName = (LPWSTR)OFFSET_TO_POINTER( ContainerName ,CertHashData);
                    DbgPrint("\t\tContainerName = %ws\n",ContainerName);
                } else {
                    DbgPrint("\t\tContainerName = NULL\n");
                }

                LPWSTR ProviderName = NULL;

                if (CertHashData->ProviderName) {
                    LPWSTR ProviderName = (LPWSTR)OFFSET_TO_POINTER( ProviderName ,CertHashData);
                    DbgPrint("\t\tProviderName = %ws\n",ProviderName);
                } else {
                    DbgPrint("\t\tProviderName = NULL\n");
                }

                LPWSTR lpDisplayInformation = NULL;

                if (CertHashData->lpDisplayInformation) {
                    LPWSTR lpDisplayInformation = (LPWSTR)OFFSET_TO_POINTER( lpDisplayInformation ,CertHashData);
                    DbgPrint("\t\tlpDisplayInformation = %ws\n",lpDisplayInformation);
                } else {
                    DbgPrint("\t\tlpDisplayInformation = NULL\n");
                }

                DbgPrint("\t\tcbHash = 0x%x\n",CertHashData->cbHash );
                DbgPrint("\t\tpbHash = \n");
                PBYTE pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
                DumpBytes( pbHash, CertHashData->cbHash, 2);
                break;
            }
        case EfsCertificate:
            {
                DbgPrint("KeySourceTag of EfsCertificate unexpected\n");
                break;
            }

        default:
            {
                DbgPrint("Unknown KeySourceTag value: %d\n",PublicKeyInfo->KeySourceTag );
                break;
            }
    }
}

VOID
DumpEncryptedKey(
    PENCRYPTED_KEY EncryptedKey
    )
{
    DbgPrint("\tLength = 0x%x\n",EncryptedKey->Length);

    PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, EncryptedKey );
    DumpPublicKeyInfo( PublicKeyInfo );

    DbgPrint("\tEncryptedFEKLength = 0x%x\n",EncryptedKey->EncryptedFEKLength);
    DbgPrint("\tEncryptedFEK = \n");
    DumpBytes( (PBYTE)OFFSET_TO_POINTER( EncryptedFEK, EncryptedKey ), EncryptedKey->EncryptedFEKLength, 1 );

}


void
DumpRecoveryKey(
    PRECOVERY_KEY_1_1 pRecoveryKey
    )
{
    DbgPrint("\nRecovery key @ 0x%x\n",pRecoveryKey);

    DbgPrint("Length = 0x%x\n",pRecoveryKey->TotalLength);
    DbgPrint("PublicKeyInfo:\n");
    DumpPublicKeyInfo( &pRecoveryKey->PublicKeyInfo );
}


VOID
DumpEFS(
    PEFS_DATA_STREAM_HEADER Efs
    )
{
    DbgPrint("\nEFS @ 0x%x:\n",Efs);


    DbgPrint("Length = \t\t0x%x\n",Efs->Length);
    DbgPrint("State = \t\t%d\n",Efs->State);
    DbgPrint("EfsVersion = \t\t%d\n",Efs->EfsVersion);
    DbgPrint("CryptoApiVersion = \t%d\n",Efs->CryptoApiVersion);
    DbgPrint("Offset to DDF = \t0x%x\n",Efs->DataDecryptionField);
    DbgPrint("Offset to DRF = \t0x%x\n",Efs->DataRecoveryField);
    DbgPrint("Reserved = \t0x%x\n",Efs->Reserved);

    DbgPrint("\nDDF:\n");

    PENCRYPTED_KEYS Ddf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, Efs );

    DbgPrint("Number of keys = %d\n",Ddf->KeyCount );

    UINT i;

    PENCRYPTED_KEY EncryptedKey = &Ddf->EncryptedKey[0];
    for (i=0; i<Ddf->KeyCount; i++) {
        DbgPrint("\tKey %d:\n",i);
        DumpEncryptedKey( EncryptedKey );
        EncryptedKey = (PENCRYPTED_KEY)(((PBYTE)EncryptedKey) + EncryptedKey->Length);
    }

    DbgPrint("\nDRF:\n");

    PENCRYPTED_KEYS Drf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, Efs );

    DbgPrint("Number of keys = %d\n",Drf->KeyCount );

    EncryptedKey = &Drf->EncryptedKey[0];
    for (i=0; i<Drf->KeyCount; i++) {
        DbgPrint("\tKey %d:\n",i);
        DumpEncryptedKey( EncryptedKey );
        EncryptedKey = (PENCRYPTED_KEY)(((PBYTE)EncryptedKey) + EncryptedKey->Length);
    }
}


#if 0

BOOLEAN
EfspChecksumEfs(
    PEFS_DATA_STREAM_HEADER pEFS,
    PEFS_KEY Fek
    )
/*++

Routine Description:

    This routine will checksum the passed EFS stream and fill in the checksum
    field in the header.  Assumes that the checksum field itself is set to 0.

Arguments:

    pEFS - Supplies the EFS stream to be checksum'd.  Assume that this structure
        has been fully filled in.

    Fek - Supplies a pointer to the FEK for the file.

Return Value:

    TRUE on success, FALSE on failure.  Sets LastErrror.

--*/

{
    HCRYPTHASH hHash = 0;
    DWORD dwHashedDataLength = MD5_HASH_SIZE;
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;


    if (CryptCreateHash( hProvVerify, CALG_MD5, 0, 0, &hHash )) {

        if (CryptHashData( hHash, (PBYTE)pEFS, pEFS->Length, 0 )) {

            if (CryptHashData( hHash, EFS_KEY_DATA( Fek ), Fek->KeyLength, 0 )) {

                if (CryptGetHashParam( hHash, HP_HASHVAL, (PBYTE)(&pEFS->EfsHash), &dwHashedDataLength, 0 )) {

                    ASSERT( dwHashedDataLength == MD5_HASH_SIZE );

                    b = TRUE;

                } else {

                    rc = GetLastError();
                    ASSERT( rc != ERROR_SUCCESS );
                }

            } else {

                rc = GetLastError();
                ASSERT( rc != ERROR_SUCCESS );
            }

        } else {

            rc = GetLastError();
            ASSERT( rc != ERROR_SUCCESS );
        }

        CryptDestroyHash( hHash );

    } else {

        rc = GetLastError();
        ASSERT( rc != ERROR_SUCCESS );
    }


    SetLastError( rc );

    return( b != 0);
}


BOOLEAN
EfspValidateEfsStream(
    PEFS_DATA_STREAM_HEADER pEFS,
    PEFS_KEY Fek
    )
/*++

Routine Description:

    This routine checks the checksum in an EFS stream.

Arguments:

    pEFS - Supplies the EFS stream to be validated.

    Fek - Supplies the FEK of the encrypted file.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    DWORD dwHashSize =   MD5_HASH_SIZE  ;

    UCHAR SavedChecksum[ MD5_HASH_SIZE ];
    UCHAR NewCheckSum  [ MD5_HASH_SIZE ];

    BOOL b = FALSE;
    HCRYPTHASH hHash = 0;
    HCRYPTPROV hProv;

    DWORD rc = ERROR_SUCCESS;

    //
    // We have to do the checksum with the checksum in the header
    // zero'd out.  Save the original in a local.
    //

    memcpy( SavedChecksum, &pEFS->EfsHash, MD5_HASH_SIZE );
    memset( &pEFS->EfsHash, 0, MD5_HASH_SIZE );

    if (CryptCreateHash( hProvVerify, CALG_MD5, 0, 0, &hHash )) {

        if (CryptHashData( hHash, (PBYTE)pEFS, pEFS->Length, 0 )) {

            if (CryptHashData( hHash, EFS_KEY_DATA( Fek ), Fek->KeyLength, 0 )) {

                if (CryptGetHashParam( hHash, HP_HASHVAL, NewCheckSum, &dwHashSize, 0 )) {

                    ASSERT( dwHashSize == MD5_HASH_SIZE );

                    if (memcmp( NewCheckSum, SavedChecksum, MD5_HASH_SIZE ) == 0) {
                        b = TRUE;
                    } else {
                        rc = ERROR_ACCESS_DENIED;
                    }

                } else {

                    rc = GetLastError();
                    ASSERT( rc != ERROR_SUCCESS );
                }

            } else {

                rc = GetLastError();
                ASSERT( rc != ERROR_SUCCESS );
            }

        } else {

            rc = GetLastError();
            ASSERT( rc != ERROR_SUCCESS );
        }

        CryptDestroyHash( hHash );

    } else {

        rc = GetLastError();
        ASSERT( rc != ERROR_SUCCESS );
    }


    //
    // Copy back the original
    //

    memcpy( &pEFS->EfsHash, SavedChecksum, MD5_HASH_SIZE );

    SetLastError( rc );

    return( b != 0);
}

#endif

BOOL
GetSaltLength(
    ALG_ID AlgID,
    DWORD *SaltLength,
    DWORD *SaltBlockLength
    )
/*++

Routine Description:

    This routine returns the length of key salt

Arguments:

    AlgID - Encryption Algorithm ID.

    SaltLength - Bytes to be copied from key.

    SaltBlockLength - Bytes of key salt block in $EFS

Return Value:

    TRUE on success, FALSE on failure.
--*/
{
    BOOL b = FALSE;

    switch (AlgID){
        case CALG_DESX:
            *SaltLength = EXPORT_DESX_SALT_LENGTH;
            *SaltBlockLength = (EXPORT_DESX_SALT_LENGTH + 4 ) & 0xfffffffc;
            b = TRUE;
            break;
        default:
            *SaltLength = 0;
            *SaltBlockLength = 0;
            break;
    }
    return b;
}


VOID
EfspUnloadUserProfile(
    IN HANDLE hToken,
    IN HANDLE hProfile
    )
/*++

Routine Description:

    Cleans up after a call to EfspLoadUserProfile.  Returns impersonating our client.

Arguments:

    hToken - The token handle returned from EfspLoadUserProfile.  This handle will be closed!

    hProfile - The profile handle returned from EfspLoadUserProfile.  This handle will not
        be modified.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    if (!hToken) {

        //
        // SYSTEM context. The profile was not loaded by EFS.
        //

        return;

    }

    RevertToSelf();

    (VOID) UnloadUserProfile (hToken, hProfile);

    //
    // Start impersonating again
    //

    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &hToken,
                sizeof(HANDLE)
                );

    if (!NT_SUCCESS( Status )) {
        DebugLog((DEB_ERROR, "EfspUnloadUserProfile: NtSetInformationThread returned %x\n" ,Status  ));
    }

    NtClose( hToken );

    return;
}

VOID
EfspFreeUserCache( 
    IN PUSER_CACHE pUserCache
    )
{
    if (pUserCache == NULL){
        return;
    }
    if (pUserCache->pbHash) {

         LsapFreeLsaHeap( pUserCache->pbHash );

    }

    if (pUserCache->ContainerName) {

         LsapFreeLsaHeap( pUserCache->ContainerName );

    }
    if (pUserCache->DisplayInformation) {

         LsapFreeLsaHeap( pUserCache->DisplayInformation );

    }
    if (pUserCache->ProviderName) {

         LsapFreeLsaHeap( pUserCache->ProviderName );

    }
    if (pUserCache->pCertContext) {
       
        CertFreeCertificateContext( pUserCache->pCertContext );

    }
    if (pUserCache->hUserKey) {

       CryptDestroyKey( pUserCache->hUserKey );

    }
    if (pUserCache->hProv) {

       CryptReleaseContext( pUserCache->hProv, 0 );

    }

    LsapFreeLsaHeap( pUserCache );

}

VOID
EfspReleaseUserCache(
    IN PUSER_CACHE pUserCache
    )

/*++

Routine Description:

    Decrease the ref count increased by the EfspGetUserCache

Arguments:

    pUserCache - Cache node

Return Value:

    
--*/
{
    RtlEnterCriticalSection( &GuardCacheListLock );
    pUserCache->UseRefCount-- ;
    RtlLeaveCriticalSection( &GuardCacheListLock );
}

PUSER_CACHE
EfspGetUserCache(
    IN OUT PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    This routine will try to find the user's cert info in the cache list.
    
    If return not NULL, this call must be balanced with a EfspReleaseUserCache(PUSER_CACHE pUserCache)

Arguments:

    pEfsUserInfo - User Info

Return Value:

    User cache list node, if match found in the cache.
    NULL if not found.
    
--*/
{
    PLIST_ENTRY pListHead, pLink;
    PUSER_CACHE pUserCache;

    //
    // Check to see if there is cache available
    //

    pEfsUserInfo->UserCacheStop = FALSE;

    RtlEnterCriticalSection( &GuardCacheListLock );

    if (UserCacheList.Flink == &UserCacheList) {

        //
        // list empty
        //

        RtlLeaveCriticalSection( &GuardCacheListLock );
        return NULL;
    }
    for (pLink = UserCacheList.Flink; pLink != &UserCacheList; pLink = pLink->Flink) {
        pUserCache = CONTAINING_RECORD(pLink, USER_CACHE, CacheChain);

        ASSERT( pLink );
        ASSERT( pLink->Flink );

        if ( (pEfsUserInfo->AuthId.LowPart == pUserCache->AuthId.LowPart) &&
             (pEfsUserInfo->AuthId.HighPart == pUserCache->AuthId.HighPart)) {

            //
            //  Find the cache node. Hold it
            //

            if (pUserCache->StopUseCount) {

                //
                //  Free cache waiting
                //  When cache for a session is stopped, both interactive and non-interactive should be stopped
                //

                pEfsUserInfo->UserCacheStop = TRUE;

                RtlLeaveCriticalSection( &GuardCacheListLock );
                return NULL;

            }


            pUserCache->UseRefCount++;
            RtlLeaveCriticalSection( &GuardCacheListLock );
            return pUserCache;

        }

    }
    RtlLeaveCriticalSection( &GuardCacheListLock );

    return NULL;
}


BOOLEAN
EfspAddUserCache(
    IN  PUSER_CACHE pUserCache
    )
/*++

Routine Description:

    This routine will try to add the user's cert info in the cache list.
    
    If return TRUE, this call must be balanced with a EfspReleaseUserCache(PUSER_CACHE pUserCache)

Arguments:

    pUserCache - User Cache node.

Return Value:

    TRUE if added successfully
    FALSE if the list is full.
    
--*/
{
    PLIST_ENTRY pListHead, pLink;
    PUSER_CACHE pUserTmpCache;

    RtlEnterCriticalSection( &GuardCacheListLock );

    if (UserCacheListCount >= UserCacheListLimit) {

        //
        // Let's see if we can kick someone out.
        //

        pLink = UserCacheList.Blink;
        while ( pLink != &UserCacheList ){

            pUserTmpCache = CONTAINING_RECORD(pLink, USER_CACHE, CacheChain);

            ASSERT( pLink );
            ASSERT( pLink->Blink );

            pLink = pLink->Blink;
            if ( pUserTmpCache->UseRefCount <= 0 ){

                //
                // No one is using it. Let's remove it.
                //

                RemoveEntryList(&( pUserTmpCache->CacheChain ));
                UserCacheListCount--;
                EfspFreeUserCache( pUserTmpCache );
                break;

            }
        }

        if (UserCacheListCount >= UserCacheListLimit) {
            RtlLeaveCriticalSection( &GuardCacheListLock );
            return FALSE;
        }

    }


    
    InsertHeadList(&UserCacheList, &( pUserCache->CacheChain ));
    UserCacheListCount++;

    RtlLeaveCriticalSection( &GuardCacheListLock );
    return TRUE;
}


BOOLEAN
EfspGetUserInfo(
    IN OUT PEFS_USER_INFO pEfsUserInfo
    )

/*++

Routine Description:

    This routine obtains all the interesting information about the user
    that we're going to need later.

Arguments:

    pEfsUserInfo - Supplies a pointer to an EfsUserInfo structure which
        will be filled in.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NTSTATUS Status;
    BOOLEAN fReturn = FALSE;
    DWORD rc = ERROR_SUCCESS;

    memset( pEfsUserInfo, 0, sizeof( EFS_USER_INFO ));

    Status = EfspGetUserName(pEfsUserInfo);

    if (NT_SUCCESS( Status )) {

        EfspIsDomainUser( pEfsUserInfo->lpDomainName, &pEfsUserInfo->bDomainAccount );

        EfspIsSystem( pEfsUserInfo, &pEfsUserInfo->bIsSystem );
        if (pEfsUserInfo->bIsSystem) {
            pEfsUserInfo->bDomainAccount = FALSE;
        }

        fReturn = TRUE;
    
        pEfsUserInfo->pUserCache = EfspGetUserCache( pEfsUserInfo );


    } else {

        rc = RtlNtStatusToDosError( Status );
    }

    SetLastError( rc );

    return( fReturn );
}

VOID
EfspFreeUserInfo(
    IN PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    Frees the memory allocated by EfspGetUserInfo().  Does
    not free the passed structure.

Arguments:

    pEfsUserInfo - Supplies a pointer to the structure to be
        de-allocated.


Return Value:

    None.

--*/
{
    if (pEfsUserInfo->lpUserName) {
        LsapFreeLsaHeap( pEfsUserInfo->lpUserName );
    }

    if (pEfsUserInfo->lpDomainName) {
        LsapFreeLsaHeap( pEfsUserInfo->lpDomainName );
    }

    if (pEfsUserInfo->lpProfilePath) {
        LsapFreeLsaHeap( pEfsUserInfo->lpProfilePath );
    }

    if (pEfsUserInfo->pTokenUser) {
        LsapFreeLsaHeap( pEfsUserInfo->pTokenUser );
    }

    if (pEfsUserInfo->lpUserSid) {
        UNICODE_STRING Dummy;
        Dummy.Buffer = pEfsUserInfo->lpUserSid;
        RtlFreeUnicodeString(&Dummy);
    }

    if (pEfsUserInfo->lpKeyPath) {
        LsapFreeLsaHeap( pEfsUserInfo->lpKeyPath );
    }

    if (pEfsUserInfo->pUserCache) {
/*
#if DBG

        DbgPrint("Cache Ref Count Before Release = %ld\n",pEfsUserInfo->pUserCache->UseRefCount);

#endif
*/

        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
/*
#if DBG

        DbgPrint("Cache Ref Count After Release = %ld\n",pEfsUserInfo->pUserCache->UseRefCount);

#endif
*/

    }

    return;
}


BOOL
EfspLoadUserProfile(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT PHANDLE        hToken,
    OUT PHANDLE        hProfile
    )
/*++

Routine Description:

    This routine attempts to determine if the user's profile is loaded,
    and if it is not, loads it.

    Callers are expected to call EfspUnloadUserProfile() during their cleanup.

Arguments:

    pEfsUserInfo - Supplies useful information about the current user.

    hToken - Returns a handle to the user's token.

    hProfile - Returns a handle to the user's profile.

Return Value:

    TRUE if the profile is already loaded or if this routine loads it successfully,
    FALSE otherwise.

--*/

{
    DWORD           rc                 = ERROR_SUCCESS;

    BOOLEAN         b                  = FALSE;
    BOOL            fReturn            = FALSE;

    LPWSTR          lpServerName       = NULL;
    PUSER_INFO_3    lpUserInfo         = NULL;
    LPWSTR          lpLocalProfilePath = NULL;

    BOOLEAN         DomainUser         = pEfsUserInfo->bDomainAccount;
    BOOLEAN         IsSystem           = pEfsUserInfo->bIsSystem;
    LPWSTR          lpDomainName       = pEfsUserInfo->lpDomainName;
    LPWSTR          lpProfilePath      = pEfsUserInfo->lpProfilePath;
    LPWSTR          lpUserName         = pEfsUserInfo->lpUserName;
    LPWSTR          SidString          = pEfsUserInfo->lpUserSid;

    NTSTATUS        Status;

    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;

    *hToken   = NULL;
    *hProfile = NULL;

    if (IsSystem) {
        return TRUE;
    }

    if (pEfsUserInfo->InterActiveUser == USER_INTERACTIVE) {
        return TRUE;
    }

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                 TRUE,                    // OpenAsSelf
                 hToken
                 );

    if (NT_SUCCESS( Status )) {

        LONG lRet;
        HKEY phKeyCurrentUser;

        lRet = RegOpenKeyExW(
                      HKEY_USERS,
                      SidString,
                      0,      // dwOptions
                      MAXIMUM_ALLOWED,
                      &phKeyCurrentUser
                      );

        if (ERROR_SUCCESS == lRet) {

            //
            // The profile is loaded.  Ref it so it doesn't disappear.
            //

            PROFILEINFO pi;

            ZeroMemory (&pi, sizeof(pi));
            pi.dwSize = sizeof(pi);
            pi.lpUserName = lpUserName;
            pi.dwFlags = PI_LITELOAD;

            //
            // Cannot be impersonating when loading the profile
            //

            RevertToSelf();

            __try {

                fReturn = LoadUserProfile (*hToken, &pi);

            } __except( EXCEPTION_EXECUTE_HANDLER ) {

                  fReturn = FALSE;
                  SetLastError( GetExceptionCode() );
            }

            if (!fReturn) {

                rc = GetLastError();

            } else {

                *hProfile = pi.hProfile;
            }

            //
            // Start impersonating again
            //

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID) hToken,
                        sizeof(HANDLE)
                        );

            if (!NT_SUCCESS( Status )) {

                //
                // Well, if we can't start impersonating again,
                // we're not going to be able to continue the operation.
                // So unload the profile and fail this whole thing.
                //

                if (fReturn) {
                    (VOID) UnloadUserProfile (*hToken, *hProfile);
                }

                fReturn = FALSE;
                DebugLog((DEB_ERROR, "EfspLoadUserProfile: Unloading profile, NtSetInformationThread returned %x\n" ,Status  ));

                rc = RtlNtStatusToDosError( Status );
            }

            RegCloseKey( phKeyCurrentUser );

        } else {

            //
            // The profile is not loaded.  Load it.
            //

            if (IsSystem) {

                lpLocalProfilePath = NULL;
                DebugLog((DEB_TRACE_EFS, "Attempting to open stream from System context\n"   ));

            } else {

                if (lpProfilePath != NULL) {

                    //
                    // We got the profile path from the logon information.
                    //

                    DebugLog((DEB_TRACE_EFS, "Got profile path %ws from logon information", lpProfilePath ));

                    //
                    // Do this up here so we can have common code below.
                    //

                    // RevertToSelf();

                    lpLocalProfilePath = lpProfilePath;

                } else {

                    //
                    // We didn't get a profile path from the logon information,
                    // do it the slow way.
                    //

                    DebugLog((DEB_TRACE_EFS, "Attempting to compute profile information\n"   ));

                    BOOLEAN fGotServerName = TRUE;

                    if (DomainUser) {

                        //
                        // Determine the name of the DC for this domain
                        //

                        rc = DsGetDcName(
                                 NULL,
                                 lpDomainName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &DomainControllerInfo
                                 );

                        if (ERROR_SUCCESS == rc) {

                            lpServerName = DomainControllerInfo->DomainControllerName;

                        } else {

                            DebugLog((DEB_ERROR, "Failed to obtain DC Name from DsGetDcName, error = %d\n" ,rc  ));
                            fGotServerName = FALSE;
                        }

                    } else {

                        //
                        // Local user, query the local machine
                        //

                        lpServerName = NULL;
                    }

                    if (fGotServerName) {

                        //
                        // Need to do this so that NetUserGetInfo will work.
                        // If we don't, the server may fail trying to impersonate us,
                        // and then the API will fail.  If we revert, then it will only
                        // fail if the machine has been denied access.
                        //

                        // RevertToSelf();

                        rc = NetUserGetInfo( lpServerName, lpUserName, 3, (LPBYTE *)&lpUserInfo );

                        if (ERROR_SUCCESS == rc) {

                            lpLocalProfilePath = lpUserInfo->usri3_profile;

                        } else {

                            DebugLog((DEB_ERROR, "NetUserGetInfo failed, error = %d\n" ,rc  ));

                            //
                            // Start impersonating again
                            //

                            /* No need to do this. We are still impersonating.
                            
                            Status = NtSetInformationThread(
                                        NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID) hToken,
                                        sizeof(HANDLE)
                                        );

                            if (!NT_SUCCESS( Status )) {

                                fReturn = FALSE;
                                DebugLog((DEB_ERROR, "EfspLoadUserProfile: NtSetInformationThread returned %x\n" ,Status  ));

                                rc = RtlNtStatusToDosError( Status );
                            }
                            */
                        }
                    }
                }
            }

            //
            // Make sure we revert before calling LoadUserProfile
            //

            RevertToSelf();

            //
            // We have a profile path.  Note that it may be NULL.
            //

            DebugLog((DEB_TRACE_EFS, "Loading profile path %ws\n" , (lpLocalProfilePath == NULL ? L"NULL" : lpLocalProfilePath)));

            PROFILEINFO pi;

            ZeroMemory (&pi, sizeof(pi));
            pi.dwSize = sizeof(pi);
            pi.lpUserName = lpUserName;
            pi.lpProfilePath = lpLocalProfilePath;
            pi.dwFlags = PI_LITELOAD;

            __try {

                fReturn = LoadUserProfile (*hToken, &pi);

            } __except( EXCEPTION_EXECUTE_HANDLER ) {

                  fReturn = FALSE;
                  SetLastError( GetExceptionCode() );
            }

            if (!fReturn) {

                rc = GetLastError();
                DebugLog((DEB_ERROR, "LoadUserProfile failed, error = %d\n" ,rc  ));

            } else {

                *hProfile = pi.hProfile;
            }

            //
            // Start impersonating again, at least until LoadUserProfile
            // stops turning off impersonation.
            //

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID) hToken,
                        sizeof(HANDLE)
                        );

            if (!NT_SUCCESS( Status )) {

                fReturn = FALSE;
                DebugLog((DEB_ERROR, "EfspLoadUserProfile: NtSetInformationThread returned %x\n" ,Status  ));

                rc = RtlNtStatusToDosError( Status );
            }

            if (lpUserInfo != NULL) {
                NetApiBufferFree( lpUserInfo );
            }
        }

        if (lpServerName) {
            NetApiBufferFree( DomainControllerInfo );
        }

        if (!fReturn) {

            //
            // We did not succeed for some reason.
            // Clean up what we were going to return.
            //

            NtClose( *hToken );
        }

    } else {

        SetLastError( RtlNtStatusToDosError( Status ));
    }

    SetLastError( rc );

    return( fReturn );
}

DWORD
GenerateDRF(
    IN  PEFS_KEY  Fek,
    OUT PENCRYPTED_KEYS *pNewDRF,
    OUT DWORD *cbDRF
    )
{
    DWORD rc;
    DWORD    DRFKeyCount;
    DWORD    DRFStatus;
    PBYTE  * DRFPublicKeys;
    DWORD  * DRFPublicKeyLengths;
    PBYTE  * DRFCertHashes;
    DWORD  * DRFCertHashLengths;
    LPWSTR * DRFDisplayInformation;
    PSID   * pDRFSid;

    *pNewDRF = NULL;
    *cbDRF = 0;

    rc = GetRecoveryData(
            &DRFKeyCount,
            &DRFStatus,
            &DRFPublicKeys,
            &DRFPublicKeyLengths,
            &DRFCertHashes,
            &DRFCertHashLengths,
            &DRFDisplayInformation,
            &pDRFSid
            );

    if (rc == ERROR_SUCCESS) {

        if (DRFKeyCount > 0) {

            rc = ConstructKeyRing(
                    Fek,
                    DRFKeyCount,
                    NULL,         // No key name information for recovery agents
                    NULL,
                    DRFPublicKeys,
                    DRFPublicKeyLengths,
                    DRFCertHashes,
                    DRFCertHashLengths,
                    DRFDisplayInformation,
                    pDRFSid,
                    FALSE,
                    pNewDRF,
                    cbDRF
                    );

        } else {

            //
            // No DRF will be returned
            //

            if (DRFStatus < RECOVERY_POLICY_OK) {

                //
                // EFS will go ahead with encryption without DRF
                //

                rc = ERROR_SUCCESS;


            } else {

                rc = ERROR_BAD_RECOVERY_POLICY; 

            }

        }
    }

    return rc;
}

BOOLEAN
EqualEncryptedKeys(
    IN PENCRYPTED_KEYS SrcKeys, 
    IN PENCRYPTED_KEYS DstKeys, 
    IN DWORD           cbDstKeys
    )
/*++

Routine Description:

    This routine compares two encrypted key arrays.

Arguments:

    SrcKeys - Source key arrays.

    DstKeys - Destination key arrays.

    cbDstKeys - Destination key array size.

Return Value:

    TRUE if the profile is already loaded or if this routine loads it successfully,
    FALSE otherwise.

--*/
{
    DWORD cbSrcKeys = 0;
    ULONG KeyCount =  *(ULONG UNALIGNED *) &(SrcKeys->KeyCount);
    PENCRYPTED_KEY pEncryptedKey;
    ULONG keyLength;

    if (KeyCount != DstKeys->KeyCount ) {
        return FALSE;
    }
        
    pEncryptedKey = &(SrcKeys->EncryptedKey[0]);
 
    while ( KeyCount > 0 ) {
        keyLength = * (ULONG UNALIGNED *) &(pEncryptedKey->Length);
        cbSrcKeys += keyLength;
        pEncryptedKey = (PENCRYPTED_KEY)( ((PBYTE)pEncryptedKey) + keyLength );
        KeyCount--;
    }

    cbSrcKeys += (sizeof ( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY ));

    if ( cbSrcKeys != cbDstKeys ) {

        return FALSE;

    }

    return RtlEqualMemory( SrcKeys, DstKeys, cbDstKeys);

}

DWORD
EfsGetCertNameFromCertContext(
    PCCERT_CONTEXT CertContext,
    LPWSTR * UserDispName
    )
/*++
Routine Description:
    Get the user name from the certificate
Arguments:
    CertContext -- Cert Context
    UserCertName -- User Common Name ( Caller is responsible to delete this memory )
Return Value:
     ERROR_SUCCESS if succeed.
     If No Name found. "USER_UNKNOWN is returned".
--*/

{
    DWORD   NameLength;
    DWORD   UserNameBufLen = 0;
    DWORD   BlobLen = 0;
    PCERT_EXTENSION AlterNameExt = NULL;
    BOOL    b;
    LPWSTR  DNSName = NULL;
    LPWSTR  UPNName = NULL;
    LPWSTR  CommonName = NULL;
    DWORD   rc = ERROR_SUCCESS;

    if ( NULL == UserDispName ){
        return ERROR_SUCCESS;
    }

    *UserDispName = NULL;

    AlterNameExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME2,
            CertContext->pCertInfo->cExtension,
            CertContext->pCertInfo->rgExtension
            );

    if (AlterNameExt){

        //
        // Find the alternative name
        //

        b = CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                szOID_SUBJECT_ALT_NAME ,
                AlterNameExt->Value.pbData,
                AlterNameExt->Value.cbData,
                0,
                NULL,
                &BlobLen
                );
        if (b){

            //
            // Let's decode it
            //

            CERT_ALT_NAME_INFO *AltNameInfo = NULL;

            AltNameInfo = (CERT_ALT_NAME_INFO *) LsapAllocateLsaHeap( BlobLen );
            if (AltNameInfo){

                b = CryptDecodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        szOID_SUBJECT_ALT_NAME,
                        AlterNameExt->Value.pbData,
                        AlterNameExt->Value.cbData,
                        0,
                        AltNameInfo,
                        &BlobLen
                        );
                if (b){

                    //
                    // Now search for the UPN, SPN, DNS, EFS name
                    //

                    DWORD   cAltEntry = AltNameInfo->cAltEntry;
                    DWORD   ii = 0;

                    while (ii < cAltEntry){
                        if ((AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_OTHER_NAME ) &&
                             !strcmp(szOID_NT_PRINCIPAL_NAME, AltNameInfo->rgAltEntry[ii].pOtherName->pszObjId)
                            ){

                            //
                            // We found the UPN name
                            //

                            CERT_NAME_VALUE* CertUPNName = NULL;

                            b = CryptDecodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_UNICODE_ANY_STRING,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                    0,
                                    NULL,
                                    &BlobLen
                                    );
                            if (b){

                                CertUPNName = (CERT_NAME_VALUE *) LsapAllocateLsaHeap(BlobLen);
                                if (CertUPNName){
                                    b = CryptDecodeObject(
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                            0,
                                            CertUPNName,
                                            &BlobLen
                                            );
                                    if (b){
                                        UPNName = (LPWSTR)LsapAllocateLsaHeap( CertUPNName->Value.cbData + sizeof(WCHAR) );
                                        if (UPNName){
                                            wcscpy(UPNName, (LPCWSTR) CertUPNName->Value.pbData);
                                        }
                                    }
                                    LsapFreeLsaHeap(CertUPNName);
                                    if (UPNName){

                                        //
                                        // Got the UPN name. Stop searching.
                                        //
                                        break;
                                    }
                                }
                            }

                                            
                        } else {

                            //
                            // Check for other alternative name
                            //

                            if (AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_DNS_NAME){
                                DNSName = AltNameInfo->rgAltEntry[ii].pwszDNSName;
                            } 

                        }

                        ii++;

                    }

                    if ( NULL == UPNName ){

                        //
                        // No UPN name, let's get the other option
                        //

                        if (DNSName){
                            UPNName = (LPTSTR) LsapAllocateLsaHeap ( sizeof(WCHAR) * (wcslen( DNSName ) + 1));
                            if (UPNName){
                                wcscpy(UPNName, DNSName);
                            }
                        }

                    }
                }
                LsapFreeLsaHeap(AltNameInfo);
            }

        }
    }


    NameLength = CertGetNameString(
                                CertContext,
                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                0,
                                NULL,
                                NULL,
                                0
                                );

    if ( NameLength > 1){

        //
        // The display name exist. Go get the display name.
        //

        CommonName = (LPWSTR) LsapAllocateLsaHeap( sizeof(WCHAR) * NameLength);
        if ( NULL == CommonName ){
            if (UPNName){
                LsapFreeLsaHeap( UPNName );
            }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        UserNameBufLen = NameLength;
        NameLength = CertGetNameString(
                                    CertContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    0,
                                    NULL,
                                    CommonName,
                                    UserNameBufLen
                                    );

        ASSERT (NameLength == UserNameBufLen);

    } 


    if (CommonName || UPNName){

        NameLength = 3;
        if (CommonName){
            NameLength += wcslen(CommonName);
        }
        if (UPNName){
            NameLength += wcslen(UPNName);
        }
        

        *UserDispName = (LPWSTR)LsapAllocateLsaHeap(sizeof(WCHAR) * NameLength);
        if (*UserDispName) {
            if (CommonName){
                wcscpy(*UserDispName, CommonName);
                if (UPNName){
                    wcscat(*UserDispName, L"(");
                    wcscat(*UserDispName, UPNName);
                    wcscat(*UserDispName, L")");
                }
            } else {
                wcscpy(*UserDispName, UPNName);
            }
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (CommonName){
            LsapFreeLsaHeap( CommonName );
        }
        if (UPNName){
            LsapFreeLsaHeap( UPNName );
        }
        return rc;
    } 

    return DISP_E_UNKNOWNNAME;

}


DWORD
EfsAddCertToTrustStoreStore(
    IN PCCERT_CONTEXT pCert,
    OUT DWORD   *ImpersonationError
    )

/*++

Routine Description:

    This routine adds the cert to the LM Trusted store.

Arguments:

    pCert -- The cert to be added.
    ImpersonationError -- Error indicate that we could impersonate after revert to self. This should not be the case.
    
Return Value:

    Win32 error code
    
--*/
{


    NTSTATUS        Status;
    HANDLE          hToken;
    DWORD           errCode = ERROR_SUCCESS;
    HCERTSTORE      localStore;

    *ImpersonationError = 0;
    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY | TOKEN_IMPERSONATE,
                 TRUE,                    // OpenAsSelf
                 &hToken
                 );

    if (NT_SUCCESS( Status )) {

        RevertToSelf();

        localStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE  | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            TRUSTEDPEOPLE
                            );
        if (localStore) {
            LPWSTR crntUserName;
            LPWSTR userName;
            PCCERT_CONTEXT userCert = NULL;
            CERT_ENHKEY_USAGE certEnhKeyUsage;
            LPSTR lpstr = szOID_EFS_CRYPTO;

            certEnhKeyUsage.cUsageIdentifier = 1;
            certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

            errCode = EfsGetCertNameFromCertContext(
                                pCert,
                                &crntUserName
                                );

            if (crntUserName) {

                //
                // Let's enumerate the certs in the store to see if we need to remove the old similar
                // EFS cert.
                //

                do {

                    userCert = CertFindCertificateInStore(
                                       localStore,
                                       X509_ASN_ENCODING,
                                       0, //CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                       CERT_FIND_ENHKEY_USAGE,
                                       &certEnhKeyUsage,
                                       userCert
                                       );
                    if (userCert) {

                        EfsGetCertNameFromCertContext(
                                            userCert,
                                            &userName
                                            );
                        if (userName) {

                            if (!wcscmp(userName, crntUserName) ) {

                                //
                                // Find the name match. Remove it.
                                //

                                PCCERT_CONTEXT tmpCert;

                                tmpCert = CertDuplicateCertificateContext(userCert);
                                if (tmpCert) {
                                    CertDeleteCertificateFromStore(tmpCert);
                                }

                            }

                            LsapFreeLsaHeap( userName );

                        }
                    }

                } while (userCert);

                if(!CertAddCertificateContextToStore(
                       localStore,
                       pCert,
                       CERT_STORE_ADD_NEW,
                       NULL) ) {
    
                    errCode = GetLastError();
    
                }

                LsapFreeLsaHeap( crntUserName );

            } else {
                errCode = GetLastError();
            }

            CertCloseStore( localStore, 0 );
        }

        Status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    (PVOID) &hToken,
                    sizeof(HANDLE)
                    );

        if (!NT_SUCCESS( Status )) {
            ASSERT(FALSE);
            *ImpersonationError = 1;
            errCode = RtlNtStatusToDosError( Status );

        }

    } else {
        errCode = RtlNtStatusToDosError( Status );
    }

    return errCode;

}

DWORD
EfsAlignBlock(
    IN PVOID InPointer,
    OUT PVOID   *OutPointer,
    OUT BOOLEAN *NewMemory
    )

/*++

Routine Description:

    This routine will align the structure with the first ULONG as the length of the structure
    so that we don't get alignment faults.

Arguments:

    InPointer -- Original Block
    OutPointer -- Aligned Block
    NewMemory -- If new memory block allocated
            
Return Value:

    Win32 error code
    
--*/
{

    if ( ((INT_PTR) InPointer & 0x03) == 0) {
         *OutPointer = InPointer;
         *NewMemory = FALSE;
         return ERROR_SUCCESS;
    }

    ULONG length;
    DWORD result=ERROR_SUCCESS;

    RtlCopyMemory(&length, InPointer, sizeof (ULONG));
    *OutPointer = (PENCRYPTED_KEY)LsapAllocateLsaHeap(length);
    if (*OutPointer) {

        RtlCopyMemory(*OutPointer, InPointer, length);
        *NewMemory = TRUE;
    } else {
        *NewMemory = FALSE;
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lht.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       lht.cxx
//
//  Contents:   Context handle management for servers
//
//  Classes:
//
//  Functions:
//
//  History:    1-31-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#include "sht.hxx"
#include "lht.hxx"

//
// Due to the high number of connections for servers, the client context list
// for a particular session could grow into the thousands.  At that stage, a
// linear list that is searched to validate a handle is prohibitively expensive.
//
// Thus, the faster, if more expensive to set up and add handle package
//

HP_INITIALIZE_FN    LhtInitialize ;
HP_CREATE_FN        LhtCreate ;
HP_DELETE_FN        LhtDelete ;
HP_ADD_HANDLE_FN    LhtAddHandle ;
HP_DELETE_HANDLE_FN LhtDeleteHandle ;
HP_VALIDATE_HANDLE_FN LhtValidateHandle ;
HP_REF_HANDLE_FN    LhtRefHandle ;
HP_DEREF_HANDLE_KEY_FN LhtDerefHandleKey ;
HP_GET_HANDLE_CONTEXT_FN LhtGetHandleContext ;
HP_RELEASE_CONTEXT_FN LhtReleaseContext ;

HANDLE_PACKAGE  LargeHandlePackage = {
                    sizeof( LARGE_HANDLE_TABLE ),
                    LhtInitialize,
                    LhtCreate,
                    LhtDelete,
                    LhtAddHandle,
                    LhtDeleteHandle,
                    LhtValidateHandle,
                    LhtRefHandle,
                    LhtDerefHandleKey,
                    LhtGetHandleContext,
                    LhtReleaseContext
                    };


ULONG   LhtFastMem ;
ULONG   LhtShiftValues[] = { 4, 12, 16, 20 };


#define IndexFromHandle( Level, Handle )    \
            ( ( ((PSecHandle) Handle)->dwUpper >> LhtShiftValues[ Level ] ) & HANDLE_TABLE_MASK )

#define LhtLockTable( t ) \
            if ( (((PLARGE_HANDLE_TABLE) t)->Flags & LHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlEnterCriticalSection( &((PLARGE_HANDLE_TABLE)t)->Lock ); \
            }

#define LhtUnlockTable( t ) \
            if ( (((PLARGE_HANDLE_TABLE) t)->Flags & LHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlLeaveCriticalSection( &((PLARGE_HANDLE_TABLE)t)->Lock ); \
            }


#define LHT_ACTION_ADDREF       0
#define LHT_ACTION_DELREF       1
#define LHT_ACTION_FORCEDEL     2
#define LHT_ACTION_VALIDATE     3
#define LHT_ACTION_ADDHANDLE    4
#define LHT_ACTION_DELHANDLE    5

#define LHT_ACTION_MASK     0x0000FFFF
#define LHT_ACTION_LOCKED   0x00010000
#define LHTP_DEREF_NOT_DEL  0x10000000
#define LHTP_HANDLE_CHECKED 0x20000000

//+---------------------------------------------------------------------------
//
//  Function:   LhtInitialize
//
//  Synopsis:   Initializes the LHT handle package
//
//  Arguments:  (none)
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtInitialize(
    VOID
    )
{
    return TRUE ;
}



//+---------------------------------------------------------------------------
//
//  Function:   LhtCreate
//
//  Synopsis:   Creates a large handle table.  The table is referenced through
//              the returned pointer
//
//  Arguments:  [Flags] -- Flags as defined by handle.hxx
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
LhtCreate(
    IN ULONG Flags,
    IN PVOID HandleTable,
    IN PHP_ENUM_CALLBACK_FN Callback
    )
{
    PLARGE_HANDLE_TABLE Table ;
    ULONG i;

    if ( HandleTable )
    {
        Table = (PLARGE_HANDLE_TABLE) HandleTable ;
    }
    else
    {
        Table = (PLARGE_HANDLE_TABLE) LsapAllocatePrivateHeap( sizeof( LARGE_HANDLE_TABLE ) );
    }

    if ( Table )
    {
        Table->Tag = LHT_TAG ;
        Table->Flags = 0 ;

        Table->Flags = (Flags & HANDLE_PACKAGE_GENERAL_FLAGS);


        if ( Flags & HANDLE_PACKAGE_CALLBACK_ON_DELETE )
        {
            Table->DeleteCallback = Callback ;
        }
        else
        {
            Table->DeleteCallback = NULL ;
        }

        if ( HandleTable )
        {
            Table->Flags |= LHT_NO_FREE ;
        }

        Table->Depth = 0 ;


        if ( ( Flags & LHT_NO_SERIALIZE ) == 0 )
        {
            NTSTATUS Status = RtlInitializeCriticalSection( &Table->Lock );

            if (!NT_SUCCESS(Status))
            {
                if ( !HandleTable )
                {
                    LsapFreePrivateHeap( Table );
                }

                Table = NULL ;
            }
        }
    }

    if ( Table )
    {

        for ( i = 0 ; i < HANDLE_TABLE_SIZE ; i++ )
        {
            SmallHandlePackage.Create( Flags | HANDLE_PACKAGE_NO_SERIALIZE,
                                        & Table->Lists[i],
                                        Callback );
        }

    }

    return Table ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LhtpDeleteTable
//
//  Synopsis:   Delete table worker function
//
//  Arguments:  [Table]    --
//              [Callback] --
//
//  History:    4-15-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LhtpDeleteTable(
    PLARGE_HANDLE_TABLE Table,
    PHP_ENUM_CALLBACK_FN Callback
    )
{
    ULONG Index ;
    PSEC_HANDLE_ENTRY Entry ;
    PLIST_ENTRY Scan ;

    LhtLockTable( Table );

    for ( Index = 0 ; Index < HANDLE_TABLE_SIZE ; Index++ )
    {
        if ( Table->Lists[Index].Flags & LHT_SUB_TABLE )
        {
            LhtpDeleteTable( (PLARGE_HANDLE_TABLE) Table->Lists[Index].List.Flink,
                             Callback );

        }
        else
        {
            SmallHandlePackage.Delete( &Table->Lists[ Index ], Callback );
        }
    }

    LhtUnlockTable( Table );

    if ( (Table->Flags & LHT_NO_SERIALIZE) == 0 )
    {
        RtlDeleteCriticalSection(  &Table->Lock );
    }

    if ( ( Table->Flags & LHT_NO_FREE ) == 0 )
    {
        LsapFreePrivateHeap( Table );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtDelete
//
//  Synopsis:   Delete a table
//
//  Arguments:  [HandleTable] --
//              [Callback]    --
//
//  History:    4-15-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtDelete(
    PVOID   HandleTable,
    PHP_ENUM_CALLBACK_FN Callback
    )
{
    PLARGE_HANDLE_TABLE Table ;

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtLockTable( Table );

    Table->Flags |= LHT_DELETE_PENDING ;

    LhtpDeleteTable( Table, Callback );

    return TRUE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtpFindHandle
//
//  Synopsis:   Worker function that grovels a handle table
//
//  Arguments:  [HandleTable] -- Table to scan
//              [Handle]      -- handle to search for
//              [Action]      -- action to take on the handle record
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSEC_HANDLE_ENTRY
LhtpFindHandle(
    PVOID   HandleTable,
    PSecHandle  Handle,
    ULONG   Action,
    PBOOL   Removed,
    PVOID * FinalTable OPTIONAL
    )
{
    PLARGE_HANDLE_TABLE Table ;
    PSEC_HANDLE_ENTRY   Entry ;
    PLIST_ENTRY         Scan ;
    ULONG Index ;
    BOOL Locked ;

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtLockTable( Table );

    Entry = NULL ;

    while ( TRUE )
    {
        Index = (ULONG) IndexFromHandle( Table->Depth, Handle );

        if ( Table->Lists[ Index ].Flags & LHT_SUB_TABLE )
        {
            Table = (PLARGE_HANDLE_TABLE) Table->Lists[ Index ].List.Flink ;

            continue;
        }

        Entry = ShtpFindHandle( &Table->Lists[ Index ], Handle, Action, Removed );

        if ( FinalTable )
        {
            *FinalTable = &Table->Lists[ Index ] ;
        }

        break;
    }

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtUnlockTable( Table );

    return Entry ;


}

//+---------------------------------------------------------------------------
//
//  Function:   LhtpConvertSmallToLarge
//
//  Synopsis:   Worker to convert small tables to large
//
//  Arguments:  [Small] --
//              [Large] --
//
//  History:    7-08-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtpConvertSmallToLarge(
    PSMALL_HANDLE_TABLE Small,
    PLARGE_HANDLE_TABLE Large
    )
{
    ULONG NewIndex ;
    PSEC_HANDLE_ENTRY Entry ;

    while ( Entry = ShtpPopHandle( Small ) )
    {
        NewIndex = (ULONG) IndexFromHandle( Large->Depth, &(Entry->Handle) );

        ShtpInsertHandle( &Large->Lists[ NewIndex ], Entry );

    }

    return TRUE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LhtpExpandTable
//
//  Synopsis:   Expands the given index into its own table
//
//  Effects:    New table associated with given index
//
//  Arguments:  [Table] -- Source table
//              [Index] -- Source index
//
//  Requires:   Table must be write-locked
//
//  History:    1-31-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtpExpandTable(
   PLARGE_HANDLE_TABLE  Table,
   ULONG    Index
   )
{
    PLARGE_HANDLE_TABLE NewTable ;
    PLIST_ENTRY List;
    ULONG NewFlags ;

    NewFlags = HANDLE_PACKAGE_NO_SERIALIZE ;

    if ( Table->DeleteCallback )
    {
        NewFlags |= HANDLE_PACKAGE_CALLBACK_ON_DELETE ;
    }

    NewTable = (PLARGE_HANDLE_TABLE) LhtCreate( NewFlags |
                                                    LHT_CHILD,
                                                NULL,
                                                Table->DeleteCallback );

    if ( !NewTable )
    {
        return FALSE ;
    }

    NewTable->Depth = Table->Depth + 1 ;

    NewTable->Parent = Table ;

    NewTable->IndexOfParent = Index ;

    LhtpConvertSmallToLarge( &Table->Lists[ Index ], NewTable );

    Table->Lists[ Index ].List.Flink = (PLIST_ENTRY) NewTable ;

    Table->Lists[ Index ].Flags = LHT_SUB_TABLE ;

    return TRUE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LhtConvertSmallToLarge
//
//  Synopsis:   Converts a small handle table to a large one
//
//  Arguments:  [Small] --
//
//  History:    7-08-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
LhtConvertSmallToLarge(
    PVOID Small
    )
{
    PLARGE_HANDLE_TABLE Large ;
    PSMALL_HANDLE_TABLE SmallTable = (PSMALL_HANDLE_TABLE) Small ;
    PULONG Tag ;

    Tag = (PULONG) Small ;

    if ( *Tag == LHT_TAG )
    {
        return Small ;
    }

    if ( *Tag != SHT_TAG )
    {
        return NULL ;
    }

    Large = (PLARGE_HANDLE_TABLE) LhtCreate( (SmallTable->DeleteCallback ?
                                                HANDLE_PACKAGE_CALLBACK_ON_DELETE : 0),
                                             NULL,
                                             SmallTable->DeleteCallback );

    if ( Large )
    {
        LhtpConvertSmallToLarge( SmallTable, Large );

        ShtDelete( Small, NULL );

        return Large ;
    }

    return NULL ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtAddHandle
//
//  Synopsis:   Add a handle to a handle table
//
//  Arguments:  [HandleTable] -- Table to add the handle to
//              [Handle]      -- Handle to add
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtAddHandle(
    PVOID   HandleTable,
    PSecHandle  Handle,
    PVOID   Context,
    ULONG Flags
    )
{
    PSEC_HANDLE_ENTRY   Entry ;
    PLARGE_HANDLE_TABLE Table ;
    ULONG Index ;


    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtLockTable( Table );

    Entry = LhtpFindHandle( HandleTable, 
                            Handle, 
                            LHT_ACTION_ADDHANDLE, 
                            NULL, 
                            NULL );

    if ( Entry )
    {
        LhtUnlockTable( Table );

        return TRUE ;
    }

    //
    // No entry, need to insert one.
    //

    while ( TRUE )
    {
        Index = (ULONG) IndexFromHandle( Table->Depth, Handle );

        if ( Table->Lists[ Index ].Flags & LHT_SUB_TABLE )
        {
            Table = (PLARGE_HANDLE_TABLE) Table->Lists[ Index ].List.Flink ;

            continue;
        }

        if(SmallHandlePackage.AddHandle( &Table->Lists[ Index ], Handle, Context, Flags ))
        {
            if ( Table->Lists[ Index ].Count > HANDLE_SPLIT_THRESHOLD )
            {
                LhtpExpandTable( Table, Index );
            }

            break;
        }

        LhtUnlockTable( (PLARGE_HANDLE_TABLE)HandleTable );
        return FALSE;
    }

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    Table->Count++;

    LhtUnlockTable( Table );

    return TRUE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtDeleteHandle
//
//  Synopsis:   Delete a handle from the table
//
//  Arguments:  [HandleTable] -- Table
//              [Handle]      -- Handle to delete
//              [Force]       -- Force delete, even if handle is not ref'd to zero
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtDeleteHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    ULONG       Options
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    PLARGE_HANDLE_TABLE Table ;
    BOOL Removed;
    ULONG Action ;

    if ( Options & DELHANDLE_FORCE )
    {
        Action = LHT_ACTION_FORCEDEL ;
    }
    else if ( Options & LHTP_DEREF_NOT_DEL )
    {
        Action = LHT_ACTION_DELREF | LHTP_HANDLE_CHECKED ;
    }
    else 
    {
        Action = LHT_ACTION_DELHANDLE ;
    }


    Entry = LhtpFindHandle( HandleTable,
                           Handle,
                           Action,
                           &Removed,
                           NULL );

    if ( Entry )
    {
        if ( Removed )
        {
            Table = (PLARGE_HANDLE_TABLE) HandleTable ;

            LhtLockTable( Table );

            Table->Count--;

            LhtUnlockTable( Table );

            if ( (Table->DeleteCallback) &&
                 ((Options & DELHANDLE_NO_CALLBACK) == 0 ) &&
                 ((Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback(
                                &Entry->Handle,
                                Entry->Context,
                                Entry->HandleIssuedCount    // Entry->RefCount
                                );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }

    return FALSE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LhtValidateHandle
//
//  Synopsis:   Validate that a handle is within the table
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtValidateHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    BOOL        Deref
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    PLARGE_HANDLE_TABLE Table ;
    BOOL Removed ;

    Entry = LhtpFindHandle( 
                HandleTable, 
                Handle, 
                (Deref ? LHT_ACTION_DELHANDLE : LHT_ACTION_VALIDATE), 
                &Removed,
                NULL );

    if ( Entry )
    {

        if ( Removed )
        {
            Table = (PLARGE_HANDLE_TABLE) HandleTable ;

            LhtLockTable( Table );

            Table->Count--;

            LhtUnlockTable( Table );

            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK) == 0 ) )
            {
                Table->DeleteCallback(
                            &Entry->Handle,
                            Entry->Context,
                            Entry->HandleIssuedCount    // Entry->RefCount
                            );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }
    else
    {
        return FALSE ;
    }
}

PVOID
LhtRefHandle(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = LhtpFindHandle(
                HandleTable,
                Handle,
                LHT_ACTION_ADDREF,
                NULL,
                NULL );

    return Entry ;
}

VOID
LhtDerefHandleKey(
    PVOID HandleTable,
    PVOID HandleKey
    )
{
    PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) HandleKey ;

    LhtDeleteHandle( HandleTable, &Entry->Handle, LHTP_DEREF_NOT_DEL );
}

PVOID
LhtGetHandleContext(
    PVOID       HandleTable,
    PSecHandle  Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = LhtpFindHandle( 
                HandleTable, 
                Handle, 
                LHT_ACTION_ADDREF, 
                NULL,
                NULL );

    if ( Entry )
    {
        return Entry->Context ;
    }
    else
    {
        return NULL ;
    }
}


BOOL
LhtReleaseContext(
    PVOID       HandleTable,
    PSecHandle  Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    PLARGE_HANDLE_TABLE Table ;
    BOOL Removed;

    Entry = LhtpFindHandle( HandleTable,
                           Handle,
                           LHT_ACTION_DELREF,
                           &Removed,
                           NULL );

    if ( Entry )
    {
        if ( Removed )
        {
            Table = (PLARGE_HANDLE_TABLE) HandleTable ;

            LhtLockTable( Table );

            Table->Count--;

            LhtUnlockTable( Table );

            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback( &Entry->Handle, Entry->Context, Entry->RefCount );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\handle.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       handle.hxx
//
//  Contents:   Handle Package interface
//
//  Classes:
//
//  Functions:
//
//  History:    2-03-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __HANDLE_HXX__
#define __HANDLE_HXX__

typedef
VOID (WINAPI HP_ENUM_CALLBACK_FN)(
    PSecHandle  Handle,
    PVOID Context,
    ULONG RefCount
    );

typedef HP_ENUM_CALLBACK_FN * PHP_ENUM_CALLBACK_FN;

typedef struct _SEC_HANDLE_ENTRY {
    LIST_ENTRY  List ;
    SecHandle   Handle ;
    PVOID       Context ;
    ULONG       HandleCount ;
    ULONG       RefCount ;
    ULONG       HandleIssuedCount ; // same as HandleCount, but doesn't go down.
    ULONG       Flags ;
} SEC_HANDLE_ENTRY, * PSEC_HANDLE_ENTRY ;

#define SEC_HANDLE_FLAG_LOCKED          0x00000001
#define SEC_HANDLE_FLAG_DELETE_PENDING  0x00000002
#define SEC_HANDLE_FLAG_NO_CALLBACK     0x00000004

typedef
BOOL (WINAPI HP_INITIALIZE_FN)(
    VOID
    );

typedef
PVOID (WINAPI HP_CREATE_FN)(
    IN ULONG    Flags,
    IN PVOID    HandleTable OPTIONAL,
    IN PHP_ENUM_CALLBACK_FN Callback OPTIONAL
    );

#define HANDLE_PACKAGE_NO_SERIALIZE         0x00000001
#define HANDLE_PACKAGE_CALLBACK_ON_DELETE   0x00000002
#define HANDLE_PACKAGE_REQUIRE_UNIQUE       0x00000004

#define HANDLE_PACKAGE_MAX_FLAG             0x00000004
#define HANDLE_PACKAGE_GENERAL_FLAGS        0x00000007


typedef
BOOL (WINAPI HP_DELETE_FN)(
    PVOID   HandleTable,
    PHP_ENUM_CALLBACK_FN Callback
    );

typedef
BOOL (WINAPI HP_ADD_HANDLE_FN)(
    PVOID   HandleTable,
    PSecHandle  Handle,
    PVOID Context,
    ULONG Flags
    );

typedef
BOOL (WINAPI HP_DELETE_HANDLE_FN)(
    PVOID   HandleTable,
    PSecHandle Handle,
    ULONG   Options
    );

#define DELHANDLE_FORCE         0x00000001
#define DELHANDLE_NO_CALLBACK   0x00000002

typedef
BOOL (WINAPI HP_VALIDATE_HANDLE_FN)(
    PVOID   HandleTable,
    PSecHandle  Handle,
    BOOL Deref
    );

typedef 
PVOID (WINAPI HP_REF_HANDLE_FN)(
    PVOID HandleTable,
    PSecHandle Handle
    );

typedef 
VOID (WINAPI HP_DEREF_HANDLE_KEY_FN)(
    PVOID HandleTable,
    PVOID HandleKey
    );
                                        

typedef
PVOID (WINAPI HP_GET_HANDLE_CONTEXT_FN)(
    PVOID HandleTable,
    PSecHandle Handle
    );

typedef
BOOL (WINAPI HP_RELEASE_CONTEXT_FN)(
    PVOID HandleTable,
    PSecHandle Handle
    );

typedef HP_INITIALIZE_FN * PHP_INITIALIZE_FN;
typedef HP_CREATE_FN * PHP_CREATE_FN ;
typedef HP_DELETE_FN * PHP_DELETE_FN ;
typedef HP_ADD_HANDLE_FN * PHP_ADD_HANDLE_FN ;
typedef HP_DELETE_HANDLE_FN * PHP_DELETE_HANDLE_FN ;
typedef HP_VALIDATE_HANDLE_FN * PHP_VALIDATE_HANDLE_FN ;
typedef HP_REF_HANDLE_FN * PHP_REF_HANDLE_FN ;
typedef HP_DEREF_HANDLE_KEY_FN * PHP_DEREF_HANDLE_KEY_FN ;
typedef HP_GET_HANDLE_CONTEXT_FN * PHP_GET_HANDLE_CONTEXT_FN ;
typedef HP_RELEASE_CONTEXT_FN * PHP_RELEASE_CONTEXT_FN ;

typedef struct _HANDLE_PACKAGE {
    ULONG                   TableSize ;
    PHP_INITIALIZE_FN       Initialize ;
    PHP_CREATE_FN           Create ;
    PHP_DELETE_FN           Delete ;
    PHP_ADD_HANDLE_FN       AddHandle ;
    PHP_DELETE_HANDLE_FN    DeleteHandle ;
    PHP_VALIDATE_HANDLE_FN  ValidateHandle ;
    PHP_REF_HANDLE_FN       RefHandle ;
    PHP_DEREF_HANDLE_KEY_FN DerefHandleKey ;
    PHP_GET_HANDLE_CONTEXT_FN GetHandleContext ;
    PHP_RELEASE_CONTEXT_FN  ReleaseContext ;
} HANDLE_PACKAGE, * PHANDLE_PACKAGE ;



PVOID
LhtConvertSmallToLarge(
    PVOID Small
    );

extern HANDLE_PACKAGE   LargeHandlePackage ;
extern HANDLE_PACKAGE   SmallHandlePackage ;

#endif // __HANDLE_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\klpcstub.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        klpcstub.h
//
// Contents:    prototypes for lpc server stubs
//
//
// History:     3-11-94     MikeSw      Created
//
//------------------------------------------------------------------------


LSA_DISPATCH_FN LpcLsaLookupPackage;
LSA_DISPATCH_FN LpcLsaLogonUser;
LSA_DISPATCH_FN LpcLsaCallPackage;
LSA_DISPATCH_FN LpcLsaDeregisterLogonProcess;
LSA_DISPATCH_FN LpcPing;
LSA_DISPATCH_FN LpcDetach;
LSA_DISPATCH_FN LpcGetState;
LSA_DISPATCH_FN LpcGetBinding;
LSA_DISPATCH_FN LpcSetSession;
LSA_DISPATCH_FN LpcFindPackage;
LSA_DISPATCH_FN LpcEnumPackages;
LSA_DISPATCH_FN LpcAcquireCreds;
LSA_DISPATCH_FN LpcEstablishCreds;
LSA_DISPATCH_FN LpcFreeCredHandle;
LSA_DISPATCH_FN LpcLogonUser;
LSA_DISPATCH_FN LpcInitContext;
LSA_DISPATCH_FN LpcAcceptContext;
LSA_DISPATCH_FN LpcApplyToken;
LSA_DISPATCH_FN LpcDeleteContext;
LSA_DISPATCH_FN LpcSecPkgControl;
LSA_DISPATCH_FN LpcQueryPackage;
LSA_DISPATCH_FN LpcFindDC;
LSA_DISPATCH_FN LpcFindDomain;
LSA_DISPATCH_FN LpcGetUserInfo;
LSA_DISPATCH_FN LpcGetCreds;
LSA_DISPATCH_FN LpcSaveCreds;
LSA_DISPATCH_FN LpcDeleteCreds;
LSA_DISPATCH_FN LpcParseName;
LSA_DISPATCH_FN LpcFindRemoteDomain;
LSA_DISPATCH_FN LpcQueryCredAttributes;
LSA_DISPATCH_FN LpcChangeState;
LSA_DISPATCH_FN LpcQueryState;
LSA_DISPATCH_FN LpcStoreSecret;
LSA_DISPATCH_FN LpcRetrieveSecret;
LSA_DISPATCH_FN LpcEnumerateSecrets;
LSA_DISPATCH_FN LpcLocatorOp;
LSA_DISPATCH_FN LpcGrantProxy;
LSA_DISPATCH_FN LpcRevokeProxy;
LSA_DISPATCH_FN LpcInvokeProxy;
LSA_DISPATCH_FN LpcRenewProxy;
LSA_DISPATCH_FN LpcAddPackage;
LSA_DISPATCH_FN LpcDeletePackage;
LSA_DISPATCH_FN LpcEfsGenerateKey;
LSA_DISPATCH_FN LpcEfsGenerateDirEfs;
LSA_DISPATCH_FN LpcEfsDecryptFek;
LSA_DISPATCH_FN LpcEfsGenerateSessionKey;
LSA_DISPATCH_FN LpcQueryContextAttributes;
LSA_DISPATCH_FN LpcSetContextAttributes;
LSA_DISPATCH_FN LpcCallback;
SECURITY_STATUS LpcLsaPolicyChangeNotify( PSPM_LPC_MESSAGE pApiMessage );
LSA_DISPATCH_FN LpcGetUserName;
LSA_DISPATCH_FN LpcAddCredentials ;
LSA_DISPATCH_FN LpcEnumLogonSessions ;
LSA_DISPATCH_FN LpcGetLogonSessionData ;
LSA_DISPATCH_FN LpcLookupAccountName ;
LSA_DISPATCH_FN LpcLookupAccountSid ;

LSA_DISPATCH_FN DispatchAPI ;
LSA_DISPATCH_FN DispatchAPIDirect ;
extern PLSA_DISPATCH_FN DllCallbackHandler ;

NTSTATUS
LsapClientCallback(
    PSession Session,
    ULONG   Type,
    PVOID   Function,
    PVOID Argument1,
    PVOID Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    );

typedef PVOID (NTAPI DSA_THSave)(VOID);
typedef VOID (NTAPI DSA_THRestore)(PVOID);


extern  BOOL    fAllowInProcSessions ;
extern  DSA_THSave *    GetDsaThreadState ;
extern  DSA_THRestore * RestoreDsaThreadState ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\klpc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KLPC.C
//
// Contents:    LPC Support for the KSEC device driver
//
// Functions:   CreateLpcPort
//              AcceptConnection
//              LPCServerThread
//              HandleLPCError
//              ShutdownServerThread
//              StartLPCThread
//              StopLPCThread
//
// History:     20 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C" {
#include "klpcstub.h"
}

// Convenient defines

#define MESSAGE_SIZE    sizeof( SPM_LPC_MESSAGE )


// Module variables:

WCHAR   szPortName[] = SPM_PORTNAME;

HANDLE  hListenThread;

HANDLE  hLpcPort;           // This port ID is used for everything.

SECURITY_STATUS LsapTrapStatusCode ;

DSA_THSave *    GetDsaThreadState ;
DSA_THRestore * RestoreDsaThreadState ;

PLSAP_API_LOG   LpcApiLog ;

#define DBG_CONNECT     ((ULONG) 0xFFFFFFFF)
#define DBG_DISCONNECT  ((ULONG) 0xFFFFFFFE)


//
// Local Prototypes:
//

NTSTATUS CreateLpcPort(HANDLE *, PWSTR, DWORD, DWORD, DWORD);

DWORD           LpcHandler(PVOID    pMsg);
DWORD           RundownConnection(PVOID pMessage);
DWORD
RundownConnectionNoFree(PVOID pMsg);


PLSAP_API_LOG
ApiLogCreate(
    ULONG Entries
    )
{
    PLSAP_API_LOG ApiLog ;
    ULONG Size ;

    if ( Entries == 0 )
    {
        Entries = DEFAULT_LOG_SIZE;
    }
    DsysAssert( ((Entries & (Entries - 1) ) == 0 ) );

    if ( Entries & (Entries - 1 ))
    {
        return NULL ;
    }

    Size = sizeof( LSAP_API_LOG ) + ( sizeof( LSAP_API_LOG_ENTRY ) * (Entries - 1) ) ;

    ApiLog = (PLSAP_API_LOG) LsapAllocatePrivateHeap( Size );

    if ( ApiLog )
    {
        ApiLog->TotalSize = Entries ;
        ApiLog->ModSize = Entries - 1;


        LsaIAddTouchAddress( ApiLog, Size );
    }

    return ApiLog ;

}

PLSAP_API_LOG_ENTRY 
ApiLogAlloc(
    PLSAP_API_LOG Log 
    )
{
    ULONG WatchDog ;
    PLSAP_API_LOG_ENTRY Entry = NULL ;

    if ( !Log )
    {
        return NULL ;
    }

    WatchDog = Log->TotalSize * 2 ;

    while ( ( Log->Entries[ Log->Current ].ThreadId != 0 ) &&
            ( Log->Entries[ Log->Current ].ThreadId != 0xFFFFFFFF ) &&
            ( WatchDog ) )
    {
        Log->Current++ ;
        Log->Current &= Log->ModSize ;
        WatchDog-- ;
    }

    if ( WatchDog )
    {
        Entry = & Log->Entries[ Log->Current ] ;
        Entry->ThreadId = 0 ;
        
        Log->Current ++ ;
        Log->Current &=  Log->ModSize;
    }
    
    return Entry ;

}

PLSAP_API_LOG_ENTRY
ApiLogLocate(
    PLSAP_API_LOG Log,
    ULONG MessageId
    )
{
    ULONG i ;
    PLSAP_API_LOG_ENTRY Entry = NULL ;

    for ( i = 0 ; i < Log->TotalSize ; i++ )
    {
        if ( Log->Entries[ i ].MessageId == MessageId )
        {
            Entry = &Log->Entries[ i ];
            break;
        }
    }

    return Entry ;

}



//+-------------------------------------------------------------------------
//
//  Function:   SetKsecEvent
//
//  Synopsis:   Triggers the event releasing the KSecDD
//
//  Effects:    Better be ready for LPC by when this call is executed
//
//--------------------------------------------------------------------------
NTSTATUS
SetKsecEvent(void)
{
    HANDLE  hEvent;

    hEvent = SpmOpenEvent(EVENT_ALL_ACCESS,FALSE, SPM_EVENTNAME);

    if (!hEvent)
    {
        DebugLog((DEB_WARN, "Could not open %ws, %d\n", SPM_EVENTNAME, GetLastError()));
        return(STATUS_INVALID_HANDLE);
    }

    if (!SetEvent(hEvent))
    {
        DebugLog((DEB_ERROR, "Failed to set ksec event, %d\n", GetLastError()));
        (void) CloseHandle(hEvent);
        return(STATUS_INVALID_HANDLE);
    }

    (void) CloseHandle(hEvent);
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapBuildSD
//
//  Synopsis:   Shared code to build the SD for either the KsecEvent or
//              the LPC port.  For the KsecEvent, give everybody
//              GENERIC_EXECUTE access.  For the LPC port, give everybody
//              access to call in on it.
//
//  Effects:    For KsecEvent, sets the security on the event.
//              For LPC port, returns the SD as an OUT parameter
//
//--------------------------------------------------------------------------
NTSTATUS
LsapBuildSD(
    IN ULONG dwType,
    OUT PSECURITY_DESCRIPTOR *ppSD  OPTIONAL
    )
{
    HANDLE  hEvent = NULL;
    NTSTATUS Status;
    ULONG SDLength;
    PACL pEventDacl = NULL;
    PSECURITY_DESCRIPTOR pEventSD = NULL;
    ULONG ulWorldAccess = 0;
    ULONG ulAdminAccess = 0;

    if (dwType == BUILD_KSEC_SD)
    {
        hEvent = SpmOpenEvent(EVENT_ALL_ACCESS,FALSE, SPM_EVENTNAME);

        if (!hEvent)
        {
            DebugLog((DEB_WARN, "Could not open %ws, %d\n", SPM_EVENTNAME, GetLastError()));
            return(STATUS_INVALID_HANDLE);
        }

        //
        // The default DACL is the same as SePublicDefaultDacl in ntos\se
        //
        // World gets GENERIC_EXECUTE
        // Admin gets GENERIC_READ, GENERIC_EXECUTE, READ_CONTROL
        // System gets GENERIC_ALL
        //

        ulWorldAccess = GENERIC_EXECUTE | GENERIC_READ;
        ulAdminAccess = GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;
    }
    else
    {
        //
        // ppSD is an OUT parameter for BUILD_LPC_SD
        //
        ASSERT(ppSD != NULL);

        ulWorldAccess = SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE;
        ulAdminAccess = GENERIC_ALL;
    }

    SDLength = sizeof(SECURITY_DESCRIPTOR) +
                   (ULONG) sizeof(ACL) +
                   (3 * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                   RtlLengthSid( LsapLocalSystemSid ) +
                   RtlLengthSid( LsapAliasAdminsSid ) +
                   RtlLengthSid( LsapWorldSid );

    pEventSD = (PSECURITY_DESCRIPTOR) LsapAllocateLsaHeap(SDLength);

    if (pEventSD == NULL)
    {
        if (dwType == BUILD_KSEC_SD)
        {
            CloseHandle(hEvent);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pEventDacl = (PACL) ((PBYTE) pEventSD + sizeof(SECURITY_DESCRIPTOR));

    Status = RtlCreateAcl( pEventDacl,
                           SDLength - sizeof(SECURITY_DESCRIPTOR),
                           ACL_REVISION);

    ASSERT( NT_SUCCESS(Status) );


    //
    // WORLD access
    //

    Status = RtlAddAccessAllowedAce (
                 pEventDacl,
                 ACL_REVISION,
                 ulWorldAccess,
                 LsapWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    //
    // SYSTEM access

    //

    Status = RtlAddAccessAllowedAce (
                 pEventDacl,
                 ACL_REVISION,
                 GENERIC_ALL,
                 LsapLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    //
    // ADMINISTRATORS access
    //

    Status = RtlAddAccessAllowedAce (
                 pEventDacl,
                 ACL_REVISION,
                 ulAdminAccess,
                 LsapAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    //
    // Now initialize security descriptors
    // that export this protection
    //

    Status = RtlCreateSecurityDescriptor(
                 pEventSD,
                 SECURITY_DESCRIPTOR_REVISION1
                 );

    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetDaclSecurityDescriptor(
                 pEventSD,
                 TRUE,                       // DaclPresent
                 pEventDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );

    if (dwType == BUILD_KSEC_SD)
    {
        Status = NtSetSecurityObject(
                    hEvent,
                    DACL_SECURITY_INFORMATION,
                    pEventSD
                    );

        CloseHandle(hEvent);
        LsapFreeLsaHeap(pEventSD);

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to set event SD: 0x%x\n",Status));
        }
    }
    else
    {
        ASSERT(hEvent == NULL);

        if (NT_SUCCESS(Status))
        {
            *ppSD = pEventSD;
        }
        else
        {
            DebugLog((DEB_ERROR, "Failed to create LPC SD: 0x%x\n", Status));
            LsapFreeLsaHeap(pEventSD);
        }
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateLpcPort
//
//  Synopsis:   Creates an LPC port and returns a handle to it.
//
//  Effects:
//
//  Arguments:  phPort      - receives port handle
//              pszPortName - Unicode name of port
//              cbConnect   - Size of the connect message data
//              cbMessage   - Size of the messages
//              cMessages   - Max number of messages queued
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateLpcPort(  HANDLE *    phPort,
                PWSTR       pszPortName,
                DWORD       cbConnect,
                DWORD       cbMessage,
                DWORD       cMessages)
{
    NTSTATUS             nsReturn;
    OBJECT_ATTRIBUTES    PortObjAttr;
    UNICODE_STRING       ucsPortName;
    PSECURITY_DESCRIPTOR psdPort;


    //
    // Create a security descriptor for the port we are about to create
    //

    nsReturn = LsapBuildSD(BUILD_LPC_SD, &psdPort);

    if (!NT_SUCCESS(nsReturn))
    {
        return nsReturn;
    }

    //
    // Create the name
    //

    RtlInitUnicodeString(&ucsPortName, pszPortName);

    InitializeObjectAttributes(&PortObjAttr, &ucsPortName, 0, NULL, psdPort);

    //
    // Create the port

    nsReturn = NtCreatePort(phPort,                 // returned handle
                            &PortObjAttr,           // name, etc.
                            cbConnect,              // size of a connect msg
                            cbMessage,              // size of a normal msg
                            cMessages * cbMessage   // number of msgs to buffer
                            );                      // communication

    LsapFreeLsaHeap(psdPort);

    return nsReturn;
}




//+---------------------------------------------------------------------------
//
//  Function:   AcceptConnection
//
//  Synopsis:   Accepts a connection from a client.
//
//  Effects:
//
//  Arguments:  [ConnectReq]  --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    7-22-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


DWORD
AcceptConnection(
    PVOID   pvConnect
    )
{
    PSession            pSession = NULL ;
    HANDLE              hCommPort;
    PHANDLE             phPort;
    NTSTATUS            scRet;
    BOOLEAN             bAccept = TRUE;
    NTSTATUS            Status;
    PSPM_LPC_MESSAGE    ConnectReq = (PSPM_LPC_MESSAGE) pvConnect;
    PLSAP_AU_REGISTER_CONNECT_RESP Response;
    PLSAP_TASK_QUEUE          pQueue;
    WCHAR               LogonProcessName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
    CHAR                NarrowLogonName[ LSAP_MAX_PACKAGE_NAME_LENGTH + 1 ];
    SECPKG_CLIENT_INFO  ClientInfo;
    LUID                LogonId;
    ULONG               Flags = 0;
    LSA_CALL_INFO       CallInfo ;

    DBG_DISPATCH_PROLOGUE( LpcApiLog, pvConnect, CallInfo );

    scRet = LsapValidLogonProcess(
                &ConnectReq->ConnectionRequest,
                ConnectReq->pmMessage.u1.s1.DataLength,
                &ConnectReq->pmMessage.ClientId,
                &LogonId,
                &Flags
                );



    if (NT_SUCCESS(scRet))
    {
        //
        // Create a session to represent the client.
        //

        strncpy(
            NarrowLogonName,
            ConnectReq->ConnectionRequest.LogonProcessName,
            LSAP_MAX_PACKAGE_NAME_LENGTH
            );

        NarrowLogonName[ LSAP_MAX_PACKAGE_NAME_LENGTH ] = '\0';

        mbstowcs(
            LogonProcessName,
            NarrowLogonName,
            LSAP_MAX_PACKAGE_NAME_LENGTH+1
            );

        scRet = CreateSession(  &ConnectReq->pmMessage.ClientId,
                                TRUE,
                                LogonProcessName,
                                Flags,
                                &pSession);
    }

    if (!NT_SUCCESS(scRet))
    {
        bAccept = FALSE;
        phPort = &hCommPort;
        if ( pSession )
        {
            SpmpDereferenceSession( pSession );
            pSession = NULL ;
        }

    }
    else
    {
        phPort = &pSession->hPort;

        //
        // Fill in the complete connection info:
        //

        Response = (PLSAP_AU_REGISTER_CONNECT_RESP) &ConnectReq->ConnectionRequest;

        if ( pSession->dwProcessID == pDefaultSession->dwProcessID ) 
        {
            //
            // We're connecting to us.  Set a flag:
            //

            Response->SecurityMode |= LSA_MODE_SAME_PROCESS ;
        }

        Response->CompletionStatus = STATUS_SUCCESS;
        Response->PackageCount = SpmpCurrentPackageCount();


    }

    //
    // Accept the connection
    //

    DebugLog((DEB_TRACE, "LpcListen:  %sing connection from %x.%x\n",
               (bAccept ? "Accept" : "Reject"),
               ConnectReq->pmMessage.ClientId.UniqueProcess,
               ConnectReq->pmMessage.ClientId.UniqueThread ));


    Status = NtAcceptConnectPort(phPort,        // Save the port handle
                                pSession,       // Associate the session
                                (PPORT_MESSAGE) ConnectReq,
                                                // Connection request to accept
                                bAccept,        // Accept the connection
                                NULL,           // Server view (none)
                                NULL            // Client view (none)
                                );

    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failed to respond appropriately.  If we had 
        // set things up for this session, tear them down
        //

        if ( NT_SUCCESS( scRet ) )
        {
            SpmpDereferenceSession( pSession );
            pSession = NULL ;

            goto Cleanup ;
        }
    }

    if ((!NT_SUCCESS(scRet)) || (!bAccept))
    {
        if ( scRet == STATUS_INVALID_CID )
        {
            PPORT_MESSAGE Message = (PPORT_MESSAGE) ConnectReq ;

            DbgPrint( "LSA: Failed to %s client [%x.%x, Message %x] because of invalid clientid\n",
                        ( bAccept ? "accept" : "reject" ),
                        Message->ClientId.UniqueProcess,
                        Message->ClientId.UniqueThread,
                        Message->MessageId );

        }
        DebugLog((DEB_ERROR, "Failed to accept 0x%08x\n", scRet));

        //
        // Delete the session we just created:
        //

        if ( pSession )
        {
            SpmpDereferenceSession( pSession );
        }

        goto Cleanup;
    }

    //
    // Must complete the session record *BEFORE* calling CompleteConnectPort,
    // since as soon as that happens, the other guy could send another message
    // and we might hit an assert.
    //

    if (bAccept)
    {
        Status = NtCompleteConnectPort(pSession->hPort);
    }


Cleanup:

    DBG_DISPATCH_POSTLOGUE( (NT_SUCCESS(Status) ? ULongToPtr(scRet) : ULongToPtr(Status)),
                            LongToPtr(DBG_CONNECT) );

    LsapFreePrivateHeap( ConnectReq );

    return( 0 );

}

//+---------------------------------------------------------------------------
//
//  Function:   LpcServerThread
//
//  Synopsis:   Handles all requests from clients
//
//  Arguments:  [pvIgnored] --
//
//  History:    7-23-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG
LpcServerThread(PVOID   pvIgnored)
{
    PSession            pSession;
    PSession            pMySession = GetCurrentSession();
    NTSTATUS             scRet;
    PSPM_LPC_MESSAGE    pMessage;
    CSHORT              sMessageType;
    NTSTATUS            Status;
    UCHAR               PanicBuffer[sizeof(SPM_LPC_MESSAGE)];
    BOOLEAN             OutOfMemory;
    HANDLE              hDummy;
    PVOID               TaskPointer ;
    LPTHREAD_START_ROUTINE TaskFunction ;
    BOOL                ScheduleUrgent ;
    BOOL                ExecNow ;
    ULONG               ErrorCount ;
#if DBG_TRACK_API
    PLSAP_API_LOG_ENTRY Entry ;
#endif


    //
    // First, create the port:
    //

    DebugLog((DEB_TRACE_INIT, "LpcServerThread starting up, creating port\n"));

    scRet = CreateLpcPort(  &hLpcPort,          // Handle that stores the port
                            szPortName,         // Name of the port.
                            sizeof(SPMConnect), // Size of a connect message
                            MESSAGE_SIZE,       // Size of a request message
                            16);                // Number of messages to queue

    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "CreateLpcPort returned 0x%08x\n", scRet));
        return((ULONG) scRet);
    }

    DebugLog((DEB_TRACE, "LPCServerThread started on port %ws\n", szPortName));

    DebugLog((DEB_TRACE_INIT, "LpcServerThread starting up:  setting event\n"));

    //
    // Trigger the KSec event that will cause the device driver to allow
    // connections
    //

    scRet = SetKsecEvent();

#if DBG
    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "Error setting event, %x\n", scRet));
    }
#endif

#if DBG_TRACK_API

    LpcApiLog = ApiLogCreate( 0 );

    if ( !LpcApiLog )
    {
        NtClose( hLpcPort );

        return STATUS_NO_MEMORY ;
    }


#endif 
    //
    // All we do is wait here:
    //

    for (; ; )
    {
        //
        // Allocate memory for the message
        //

        pMessage = (PSPM_LPC_MESSAGE) LsapAllocatePrivateHeap(
                                sizeof( SPM_LPC_MESSAGE ) );

        if (pMessage)
        {
            OutOfMemory = FALSE;
        }
        else
        {
            OutOfMemory = TRUE;
            pMessage = (PSPM_LPC_MESSAGE) PanicBuffer;
        }

        //
        // Wait for a message from one of the critters
        //
        pSession = NULL;
        ExecNow = FALSE ;

        Status = NtReplyWaitReceivePort(hLpcPort,                   // Port
                                        (void **)&pSession,         // Get session
                                        NULL,                       // No reply
                                        (PPORT_MESSAGE) pMessage);  // Recvd msg

        if ( !NT_SUCCESS( Status ) )
        {
            DebugLog(( DEB_ERROR, "LpcServer:  ReplyWaitReceive returned %x\n",
                       Status ));

            if ( !OutOfMemory )
            {
                LsapFreePrivateHeap( pMessage );
            }

            continue;
        }

        DebugLog((DEB_TRACE_WAPI, "LpcServer:  Received msg from %x.%x\n",
                    pMessage->pmMessage.ClientId.UniqueProcess,
                    pMessage->pmMessage.ClientId.UniqueThread));

        if (pSession)
        {
            DsysAssert(pSession->hPort);
        }
        else
        {
            DsysAssert(pMessage->pmMessage.u2.s2.Type == LPC_CONNECTION_REQUEST);
        }

        if (OutOfMemory)
        {
            //
            // Generate a fail
            //
            DebugLog((DEB_ERROR, "KLPC:  out of memory, failing request %x\n",
                        pMessage->pmMessage.MessageId));

            if (pMessage->pmMessage.u2.s2.Type == LPC_CONNECTION_REQUEST)
            {
                Status = NtAcceptConnectPort(
                                &hDummy,
                                NULL,
                                (PPORT_MESSAGE) pMessage,
                                FALSE,
                                NULL,
                                NULL);

            }
            else if (pMessage->pmMessage.u2.s2.Type == LPC_REQUEST)
            {
                pMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
                pMessage->ApiMessage.scRet = STATUS_INSUFFICIENT_RESOURCES;
                Status = NtReplyPort(pSession->hPort,
                                     (PPORT_MESSAGE) pMessage);
            }
            else if (pMessage->pmMessage.u2.s2.Type == LPC_PORT_CLOSED)
            {
                SetCurrentSession( pSession );

                RundownConnectionNoFree( pMessage );

                SetCurrentSession( pMySession );

            }
            else
            {
                DebugLog((DEB_ERROR, "Unknown Message received, punting\n"));

            }

            continue;
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Discarding message, %x\n", scRet));

            LsapFreePrivateHeap( pMessage );

            continue;
        }

        //
        // Check message for LPC errors
        //

#if DBG_TRACK_API

        Entry = ApiLogAlloc( LpcApiLog );

        if ( Entry )
        {
            Entry->MessageId = pMessage->pmMessage.MessageId ;
            Entry->pvMessage = pMessage ;
            GetSystemTimeAsFileTime( (LPFILETIME) &Entry->QueueTime );
        }

#endif

        sMessageType = pMessage->pmMessage.u2.s2.Type;
        switch(sMessageType & ~LPC_KERNELMODE_MESSAGE)
        {
            case LPC_REQUEST:
            case LPC_REPLY:
            case LPC_DATAGRAM:

                //
                // "Normal" API requests.  Route to the standard
                // handler, non urgent:
                //

                TaskFunction = LpcHandler ;
                ScheduleUrgent = FALSE ;

                if ((pMessage->ApiMessage.dwAPI > LsapAuMaxApiNumber) &&
                    (pMessage->ApiMessage.dwAPI < SPMAPI_MaxApiNumber) && 
                    (pMessage->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_EXEC_NOW) )
                {
                    ExecNow = TRUE ;
                }

                break;

            case LPC_CONNECTION_REQUEST:

                //
                // New connection request.  Handle with some priority
                //

                TaskFunction = AcceptConnection ;
                ScheduleUrgent = TRUE ;
                pSession = pMySession ;
                break;

            case LPC_PORT_CLOSED:

                //
                // Client has gone away.  Make sure we clean up
                //

                TaskFunction = RundownConnection ;
                ScheduleUrgent = FALSE ;

                DebugLog((DEB_TRACE, "Client %d.%d died, running down session\n",
                                pMessage->pmMessage.ClientId.UniqueProcess,
                                pMessage->pmMessage.ClientId.UniqueThread));

                break ;



            case LPC_LOST_REPLY:
            case LPC_CLIENT_DIED:
            case LPC_EXCEPTION:
            case LPC_DEBUG_EVENT:
            case LPC_ERROR_EVENT:
            default:

                //
                // These are debugger messages, so we should never see them.
                //

                DebugLog((DEB_WARN,"Discarding message type %d\n",sMessageType));

                LsapFreePrivateHeap( pMessage );

                continue;

        }

        //
        // If the message has the EXEC_NOW flag on, that means that the caller
        // deemed this urgent, and not to be spawned to another thread.
        //
        if ( ExecNow )
        {
            TlsSetValue(dwSession, pSession);
            LpcHandler(pMessage);
            TlsSetValue(dwSession, pMySession);
            continue;
        }


        //
        // Assign a thread to handle the request, and
        // then loop back and wait again.
        //

        TaskPointer = LsapAssignThread(
                        TaskFunction,
                        pMessage,
                        pSession,
                        ScheduleUrgent != 0);

        if ( !TaskPointer )
        {
            //
            // Generate a fail
            //
            DebugLog((DEB_ERROR, "KLPC:  out of memory, failing request %x\n",
                        pMessage->pmMessage.MessageId));

            pMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
            pMessage->ApiMessage.scRet = STATUS_INSUFFICIENT_RESOURCES;
            Status = NtReplyPort(pSession->hPort,
                                     (PPORT_MESSAGE) pMessage);

            DBG_DISPATCH_POSTLOGUE( ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ), 0 );

            LsapFreePrivateHeap( pMessage );


        }

#if DBG_TRACK_API

        if ( Entry )
        {
            Entry->WorkItem = TaskPointer ;
        }
#endif

    }

    return((ULONG) scRet);

}



//+---------------------------------------------------------------------------
//
//  Function:   LpcHandler
//
//  Synopsis:   Generic threadpool function called to handle an LPC request
//
//  Arguments:  [pMsg] -- Message to process
//
//  History:    7-23-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
LpcHandler(
    PVOID    pMsg
    )
{
    PSPM_LPC_MESSAGE    pApi = (PSPM_LPC_MESSAGE) pMsg ;
    PSession            pSession = (PSession) TlsGetValue(dwSession);
    NTSTATUS            Status = STATUS_SUCCESS;
    DWORD                 i;
    LSA_CALL_INFO CallInfo ;
    PULONG_PTR Where ;
    BOOL                BreakOnCall = FALSE;

    ZeroMemory( &CallInfo, sizeof(CallInfo) );

    DBG_DISPATCH_PROLOGUE( LpcApiLog, pApi, CallInfo );


    DsysAssert( pSession != pDefaultSession );


    //
    // Verify that if the caller claimed to be from Kernel mode
    // that they still are.  If the session is still indefinite,
    // fix that up now:
    //

    if ( ( pSession->fSession & SESFLAG_MAYBEKERNEL ) != 0 )
    {
        if ( ( pApi->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE ) != 0 )
        {
            pSession->fSession &= ~(SESFLAG_MAYBEKERNEL | SESFLAG_WOW_PROCESS) ;
            pSession->fSession |= SESFLAG_KERNEL ;

            if ( pEfsSession )
            {
                if ( (pEfsSession->fSession & SESFLAG_EFS) == 0 )
                {
                    LsapUpdateEfsSession( pSession );
                }
            }
        }
        else
        {
            //
            // This was a very bad caller.  They set the flag that it
            // was going to be a kernel mode session, but then they turned
            // out not to be in kernel mode.  Kill this session
            //

            LockSession( pSession );
            if ( pSession->hPort )
            {
                NtClose( pSession->hPort );
                pSession->hPort = NULL ;
            }
            UnlockSession( pSession );

            goto Cleanup;
        }
    }


    if ((pApi->ApiMessage.dwAPI > LsapAuMaxApiNumber) &&
        ((pSession->fSession & SESFLAG_KERNEL) != 0))
    {
        if ((pApi->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0)
        {
            DebugLog((DEB_ERROR,"Caller claimed to be from kernelmode but sent non-kernelmode message\n"));
            pApi->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
            Status = STATUS_ACCESS_DENIED;
        }
    }

    CallInfo.Message = pApi ;
    CallInfo.CallInfo.ProcessId = HandleToUlong(pApi->pmMessage.ClientId.UniqueProcess);
    CallInfo.CallInfo.ThreadId = HandleToUlong(pApi->pmMessage.ClientId.UniqueThread);
    CallInfo.CallInfo.Attributes = 0 ;
    CallInfo.InProcCall = FALSE ;
    CallInfo.Session = pSession ;

    if (((pSession->fSession & SESFLAG_TCB_PRIV) != 0) ||
        ((pSession->fSession & SESFLAG_KERNEL) != 0))
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_IS_TCB ;
    }

    if ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ANSI_CALL)
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_ANSI ;
    }

    if ( pApi->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE )
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_KERNEL_MODE ;

        if ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_KMAP_MEM )
        {
            CallInfo.Flags |= CALL_FLAG_KERNEL_POOL ;
            CallInfo.KMap = (PKSEC_LSA_MEMORY_HEADER) pApi->ApiMessage.Args.SpmArguments.ContextPointer;
        }
    }

    //
    // If the kernel driver has set the error-ret flag, then we have 
    // been asked to break in by the driver.  If we're allowed to take
    // breakpoints (checked later), we'll break in.  For now, set the flag
    // that we should check:
    //


    if ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ERROR_RET )
    {
        if ( CallInfo.CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE )
        {
            BreakOnCall = TRUE ;
            
        }
        
    }

    if ( pSession->fSession & SESFLAG_WOW_PROCESS )
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_WOWCLIENT ;
    }


    CallInfo.Allocs = 0 ;


    if (NT_SUCCESS(Status))
    {
        DebugLog((DEB_TRACE_WAPI, "[%x.%x] Dispatching API (Message %x)\n",
                    pApi->pmMessage.ClientId.UniqueProcess,
                    pApi->pmMessage.ClientId.UniqueThread,
                    pApi->pmMessage.MessageId));

        LsapSetCurrentCall( &CallInfo );

        //
        // Call the dispatcher, and have the request routed to the security package
        //
    #ifdef PERF
        PerfApiCount[pApi->ApiMessage.dwAPI]++;
    #endif

        DsysAssert( pSession->hPort );

        //
        // If we need a breakpoint, this will do it.  Note that this
        // will return immediately if we weren't started under a debugger.
        //

        if ( BreakOnCall )
        {
            LsapInternalBreak();
            
        }

        Status = DispatchAPI( pApi );

        LsapSetCurrentCall( NULL );

#if DBG
        if ( ( LsapTrapStatusCode != 0 ) )
        {
            DsysAssert( LsapTrapStatusCode != pApi->ApiMessage.scRet );
        }
#endif 

    }

    //
    // Done.  Send the message back to the caller, and return to the
    // thread pool.
    //

    if ( ( pApi->ApiMessage.dwAPI > LsapAuMaxApiNumber ) &&
         ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ALLOCS ) )
    {
        if ( CallInfo.Allocs )
        {
            Where = (PULONG_PTR) pApi->ApiMessage.bData ;

            *Where++ = CallInfo.Allocs ;

            for ( i = 0 ; i < CallInfo.Allocs ; i++ )
            {
                *Where++ = (ULONG_PTR) CallInfo.Buffers[ i ];
            }

        }
        else
        {
            pApi->ApiMessage.Args.SpmArguments.fAPI &= ~(SPMAPI_FLAG_ALLOCS) ;
        }
    }

    DsysAssert(pSession->hPort);


    do
    {


        Status = NtReplyPort(   pSession->hPort,
                                (PPORT_MESSAGE) pApi);

        if ( ! NT_SUCCESS( Status ) )
        {
            if (Status == STATUS_NO_MEMORY)
            {
                Sleep(125);     // Sleep for an eighth of a second, and retry
                continue;
            }


            if (Status == STATUS_INVALID_CID)
            {
                //
                // Already received the CLIENT_DIED and has been run down,
                // and the session has been deref'd, so when we go, it will
                // be closed completely.
                //

                break ;
            }

            //
            // All other errors, until we have something more sensible to
            // do,
            //

            break;

        }

    } while ( !NT_SUCCESS(Status)  );


Cleanup:
    DBG_DISPATCH_POSTLOGUE(
            (NT_SUCCESS( Status ) ? ULongToPtr(pApi->ApiMessage.scRet) : ULongToPtr(Status)),
            LongToPtr(pApi->ApiMessage.dwAPI) );

    LsapFreePrivateHeap( pApi );

    //
    // We're out of here.
    //

    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   RundownConnection
//
//  Synopsis:   Handles running down a closed connection
//
//  Arguments:  [pMsg] -- Message
//
//  History:    4-01-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
RundownConnectionNoFree(PVOID pMsg)
{
    NTSTATUS       scRet;
    PSession    pSession;
    LSA_CALL_INFO CallInfo ;

    DBG_DISPATCH_PROLOGUE( LpcApiLog, pMsg, CallInfo );

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] Process Detach\n", pSession->dwProcessID));

    //
    // Call the session manager to do preliminary cleanup:
    //

    LsapSessionDisconnect( pSession );

    //
    // Deref the session.  Note that a client may have died while we were
    // processing one or more requests in other threads.  So, this is a
    // safe (possibly deferred) dereference operation.
    //
    SpmpDereferenceSession(pSession);

    //
    // Use the default, spmgr session.
    //

    TlsSetValue(dwSession, pDefaultSession);

    //
    // Clean up and we're out of here...
    //
    DBG_DISPATCH_POSTLOGUE( ULongToPtr(STATUS_SUCCESS), LongToPtr(DBG_DISCONNECT) );


    return(0);

}

DWORD
RundownConnection( 
    PVOID pMessage 
    )
{
    RundownConnectionNoFree( pMessage );

    LsapFreePrivateHeap( pMessage );

    return 0 ;
}

//+---------------------------------------------------------------------------
//
//  Function:   CatchLpcDeath
//
//  Synopsis:   This function is invoked when the LPC thread dies
//
//  Arguments:  [PVOID] --
//
//  History:    9-13-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


DWORD
CatchLpcDeath(
    PVOID pvIgnored)
{

    DsysAssertMsg(FALSE, "LPC Thread died");

    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   StartLpcThread
//
//  Synopsis:   Initializes the LPC server.
//
//  Arguments:  (none)
//
//  History:    7-23-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


NTSTATUS
StartLpcThread(void)
{

    DWORD   tid;


    hListenThread = LsapCreateThread(
                        NULL,
                        0,
                        LpcServerThread,
                        0,
                        0,
                        &tid
                        );

    if (!hListenThread)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    LsaIRegisterNotification(
        CatchLpcDeath,
        NULL,
        NOTIFIER_TYPE_HANDLE_WAIT,
        0,
        NOTIFIER_FLAG_ONE_SHOT,
        0,
        hListenThread
        );

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\logons.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       logons.h
//
//  Contents:   Replacement logon session list code
//
//  Classes:
//
//  Functions:
//
//  History:    8-17-98   RichardW   Created
//
//----------------------------------------------------------------------------


#ifndef __LOGONS_H__
#define __LOGONS_H__



#define LsapConvertLuidToSecHandle( L, H ) \
            ((PSecHandle) H)->dwLower = ((PLUID) L)->HighPart ;  \
            ((PSecHandle) H)->dwUpper = ((PLUID) L)->LowPart ;

#define LsapConvertSecHandleToLuid( H, L ) \
            ((PLUID) L)->HighPart = ((PSecHandle) H)->dwLower ; \
            ((PLUID) L)->LowPart  = ((PSecHandle) H)->dwUpper ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\klpcstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KLPCSTUB.CXX
//
// Contents:    LPC Support for the KSEC device driver
//              API Dispatcher
//              (Un)Marshalling code
//
//
// Functions:   GetClientString
//              LpcAcquireCreds
//              LpcInitContext
//              LpcAcceptContext
//
//              DispatchAPI
//
// History:     20 May 92   RichardW    Created
//              11 Mar 94   MikeSw      Renamed from klpc2.c
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "klpcstub.h"
#include <efsstruc.h>
#include "efssrv.hxx"
#include "sphelp.h"
}
ULONG LsapPageSize ;
LONG InternalMessageId ;
PLSAP_API_LOG   InternalApiLog ;
//
// Maximum size of a string.  This is the max size of
// a short, less the null terminator
//
#define LSAP_MAX_STRING_LENGTH (0xfffc)

//#define LSAP_CATCH_BAD_VM

static  EfsSessionKeySent = FALSE;

extern  "C" BOOLEAN EfsPersonalVer;

extern  "C" BOOLEAN EfsDisabled;

#if DBG
char * SessionStatLabels[] = {  "<Disconnect>",
                                "<Connect>",
                                "LsaLookupPackage",
                                "LsaLogonUser",
                                "LsaCallPackage",
                                "LsaDeregisterLogonProcess",
                                "<empty>",
                                "(I) GetBinding",
                                "(I) SetSession",
                                "(I) FindPackage",
                                "EnumeratePackages",
                                "AcquireCredentialHandle",
                                "EstablishCredentials",
                                "FreeCredentialHandle",
                                "InitializeSecurityContext",
                                "AcceptSecurityContext",
                                "ApplyControlToken",
                                "DeleteSecurityContext",
                                "QueryPackage",
                                "GetUserInfo",
                                "GetCredentials",
                                "SaveCredentials",
                                "DeleteCredentials",
                                "QueryCredAttributes",
                                "AddPackage",
                                "DeletePackage",
                                "GenerateKey",
                                "GenerateDirEfs",
                                "DecryptFek",
                                "GenerateSessionKey",
                                "Callback",
                                "QueryContextAttributes",
                                "PolicyChangeNotify",
                                "GetUserName",
                                "AddCredentials",
                                "EnumLogonSessions",
                                "GetLogonSessionData",
                                "SetContextAttribute",
                                "LookupAccountName",
                                "LookupAccountSid",
                                "<empty>" };
#define ApiLabel(x) (((x+2) < sizeof(SessionStatLabels) / sizeof(char *)) ?  \
                        SessionStatLabels[(x+2)] : "[Illegal API Number!]")
#endif



PLSA_DISPATCH_FN DllCallbackHandler ;
//
// Function orders after LsapAuMaxApiNumber must match SPM_API and
// SPM_API_NUMBER defined in ..\h\spmlpc.h
//
PLSA_DISPATCH_FN LpcDispatchTable[ SPMAPI_MaxApiNumber ] =
{
    LpcLsaLookupPackage,
    LpcLsaLogonUser,
    LpcLsaCallPackage,
    LpcLsaDeregisterLogonProcess,
    NULL, // LsapAuMaxApiNumber
    LpcGetBinding,
    LpcSetSession,
    LpcFindPackage,
    LpcEnumPackages,
    LpcAcquireCreds,
    LpcEstablishCreds,
    LpcFreeCredHandle,
    LpcInitContext,
    LpcAcceptContext,
    LpcApplyToken,
    LpcDeleteContext,
    LpcQueryPackage,
    LpcGetUserInfo,
    LpcGetCreds,
    LpcSaveCreds,
    LpcDeleteCreds,
    LpcQueryCredAttributes,
    LpcAddPackage,
    LpcDeletePackage,
    LpcEfsGenerateKey,
    LpcEfsGenerateDirEfs,
    LpcEfsDecryptFek,
    LpcEfsGenerateSessionKey,
    LpcCallback,
    LpcQueryContextAttributes,
    LpcLsaPolicyChangeNotify,
    LpcGetUserName,
    LpcAddCredentials,
    LpcEnumLogonSessions,
    LpcGetLogonSessionData,
    LpcSetContextAttributes,
    LpcLookupAccountName,
    LpcLookupAccountSid
};

NTSTATUS
MapTokenBuffer(
    PSecBufferDesc  pInput,
    BOOLEAN         fDoClientCopy
    );

#define KLPC_FLAG_RESET (~(SPMAPI_FLAG_ERROR_RET |                      \
                            SPMAPI_FLAG_MEMORY | SPMAPI_FLAG_PREPACK |  \
                            SPMAPI_FLAG_EXEC_NOW ) )

//+---------------------------------------------------------------------------
//
//  Function:   AbortLpcContext
//
//  Synopsis:   Aborts a security context if something goes wrong.
//
//  Effects:    Calls a DeleteContext() on the context.
//
//  Arguments:  [phContext] -- Context to abort
//
//  History:    6-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
AbortLpcContext(
    PCtxtHandle phContext
    )
{
    PSession            pSession ;
    NTSTATUS             scRet;
    PLSA_CALL_INFO      CallInfo ;

    pSession = GetCurrentSession();

    CallInfo = LsapGetCurrentCall();

    CallInfo->Flags |= CALL_FLAG_NO_HANDLE_CHK ;

    DebugLog((DEB_WARN, "[%x] Aborting context %p:%p\n",
                    pSession->dwProcessID, phContext->dwUpper,
                    phContext->dwLower));


    scRet = WLsaDeleteContext(  phContext );

    if (FAILED(scRet))
    {
        DebugLog((DEB_WARN, "[%x] DeleteContext failed (%x) on context %p:%p\n",
                        pSession->dwProcessID, scRet, phContext->dwUpper,
                        phContext->dwLower));

    }

    CallInfo->Flags &= (~(CALL_FLAG_NO_HANDLE_CHK));

}

//+-------------------------------------------------------------------------
//
//  Function:   GetClientString
//
//  Synopsis:   Get a string from client memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
GetClientString(
    PUNICODE_STRING pssSource,
    PUNICODE_STRING pssDest,
    PSPM_LPC_MESSAGE pMessage,
    PUCHAR * Where
    )
{
    NTSTATUS   scRet = S_OK;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    *pssDest = *pssSource;


    if ( pssDest->Length > LSAP_MAX_STRING_LENGTH )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    if ( CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        if ((ULONG_PTR) pssSource->Buffer >= (ULONG_PTR) sizeof( SPM_LPC_MESSAGE ) )
        {
            *pssDest = *pssSource ;
            if ( pssDest->Length < pssDest->MaximumLength )
            {
                pssDest->Buffer[ pssDest->Length / sizeof( WCHAR )] = L'\0';
                
            }
            return STATUS_SUCCESS ;
        }

        
    }

    pssDest->Buffer = (LPWSTR) LsapAllocatePrivateHeap(pssDest->Length+sizeof(WCHAR));
    if (pssDest->Buffer)
    {
        pssDest->MaximumLength = pssDest->Length+sizeof(WCHAR);

        if (pssSource->Length != 0)
        {
            if ((ULONG_PTR) pssSource->Buffer >= (ULONG_PTR) sizeof( SPM_LPC_MESSAGE ) )
            {
                scRet = LsapCopyFromClient(  pssSource->Buffer,
                                            pssDest->Buffer,
                                            pssDest->Length);
                if (FAILED(scRet))
                {
                    LsapFreePrivateHeap(pssDest->Buffer);
                    pssDest->Buffer = NULL;
                }
            }
            else
            {
                //
                // prepacked buffers
                //

                if ( pssSource->Length > CBPREPACK )
                {
                    LsapFreePrivateHeap( pssDest->Buffer );

                    pssDest->Buffer = NULL ;

                    return STATUS_INVALID_PARAMETER ;
                }

                *Where = (PUCHAR) (pMessage) + (ULONG_PTR) pssSource->Buffer ;

                if (*Where == NULL)
                {
                    *Where = pMessage->ApiMessage.bData;
                }

                RtlCopyMemory(
                    pssDest->Buffer,
                    *Where,
                    pssDest->Length);

                *Where += pssDest->Length;

            }
        }

        return(scRet);
    }
    return(SEC_E_INSUFFICIENT_MEMORY);
}


//+-------------------------------------------------------------------------
//
//  Function:   PutClientString
//
//  Synopsis:   Get a string from client memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
PutClientString(
    PUNICODE_STRING pssSource,
    PUNICODE_STRING pssDest
    )
{
    NTSTATUS   scRet;

    pssDest->Length = pssSource->Length;

    //
    // If the destination buffer isn't allocated yet, allocate it.
    //

    if (!pssDest->Buffer)
    {
        pssDest->Buffer = (LPWSTR) LsapClientAllocate(pssDest->Length+sizeof(WCHAR));
        pssDest->MaximumLength = pssDest->Length+sizeof(WCHAR);
    }

    if (pssDest->Buffer)
    {
        scRet = LsapCopyToClient(  pssSource->Buffer,
                                  pssDest->Buffer,
                                  pssDest->Length);
        if (FAILED(scRet))
        {
            LsapClientFree(pssDest->Buffer);
            pssDest->Buffer = NULL;
        }

        return(scRet);
    }
    return(SEC_E_INSUFFICIENT_MEMORY);
}



//+-------------------------------------------------------------------------
//
//  Function:   MapTokenBuffer
//
//  Synopsis:   Maps the security token buffer into local memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
MapTokenBuffer(
    PSecBufferDesc  pInput,
    BOOLEAN         fDoClientCopy
    )
{
    ULONG i;
    NTSTATUS scRet = STATUS_SUCCESS;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // Mark all buffers as unmapped in case of failure
    //

    for (i = 0; i < pInput->cBuffers ; i++ )
    {
        pInput->pBuffers[i].BufferType |= SECBUFFER_UNMAPPED;
    }

    for (i = 0; i < pInput->cBuffers ; i++ )
    {

        //
        // Always map the security token - it is assumed that this
        // is always wanted by all packages
        //

        if ((pInput->pBuffers[i].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
        {
            if (fDoClientCopy)
            {
                scRet = LsapMapClientBuffer( &pInput->pBuffers[i],
                                            &pInput->pBuffers[i] );
            }
            else
            {
                pInput->pBuffers[i].pvBuffer = LsapAllocateLsaHeap(pInput->pBuffers[i].cbBuffer);
                if (!pInput->pBuffers[i].pvBuffer)
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                }
                pInput->pBuffers[i].BufferType &= ~SECBUFFER_UNMAPPED;
            }
            if (FAILED(scRet))
            {
                return(scRet);
            }
        }
        else
        {
            NOTHING ;

        }


    }
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   AllocateClientBuffers
//
//  Synopsis:   Allocate space in the client process for TOKEN type buffers
//
//  Arguments:  [pOutput]       --
//              [pClientOutput] --
//              [pFlags]        --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
AllocateClientBuffers(
    PSecBufferDesc pOutput,
    PSecBufferDesc pClientOutput,
    PUSHORT pFlags)
{
    ULONG i;


    DsysAssert(pOutput->cBuffers <= MAX_SECBUFFERS);
    if (pOutput->cBuffers > MAX_SECBUFFERS)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    for (i = 0; i < pOutput->cBuffers ; i++ )
    {
        pClientOutput->pBuffers[i] = pOutput->pBuffers[i];
        if (((pOutput->pBuffers[i].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
             && (pOutput->pBuffers[i].cbBuffer))
        {
            pClientOutput->pBuffers[i].pvBuffer =
                    LsapClientAllocate(pOutput->pBuffers[i].cbBuffer);

            if (!pClientOutput->pBuffers[i].pvBuffer)
            {
                return( SEC_E_INSUFFICIENT_MEMORY );
            }

            *pFlags |= SPMAPI_FLAG_MEMORY;

        }

    }

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   CopyClientBuffers
//
//  Synopsis:   Copies any mapped buffers over to the client's address
//              space.  The length is also copies for those buffers.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
CopyClientBuffers(
    PSecBufferDesc pSource,
    PSecBufferDesc pDest)
{
    ULONG i;
    NTSTATUS scRet;

    for (i = 0; i < pSource->cBuffers ; i++ )
    {
        //
        // Only copy it if the buffer exists and is unmapped -
        // otherwise nothing changed or there is nothing and it is
        // a waste of time.
        //


        if (pSource->pBuffers[i].pvBuffer &&
            !(pSource->pBuffers[i].BufferType & SECBUFFER_UNMAPPED))
        {
            DsysAssert(pSource->pBuffers[i].cbBuffer <= pDest->pBuffers[i].cbBuffer);

            scRet = LsapCopyToClient(    pSource->pBuffers[i].pvBuffer,
                                        pDest->pBuffers[i].pvBuffer,
                                        pSource->pBuffers[i].cbBuffer );

            if (FAILED(scRet))
            {
                //
                // Again, we have a real problem when this fails.  We
                // abort the context and return an error.
                //

                return(SEC_E_INSUFFICIENT_MEMORY);



            }

            //
            // Copy the length over also
            //

            pDest->pBuffers[i].cbBuffer = pSource->pBuffers[i].cbBuffer;
            pDest->pBuffers[i].BufferType = pSource->pBuffers[i].BufferType &
                                                (~SECBUFFER_ATTRMASK) ;
        }
    }
    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetClientBuffer
//
//  Synopsis:   Maps a client's SecBuffer into the caller's address space or
//              from prepacked area
//
//  Effects:    Clears the SECBUFFER_UNMAPPED field of the BufferType of
//              the return SecBuffer
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Doesn't modify pOutput until the end, so it is o.k. to pass
//              the same thing for pInput and pOutput.
//
//
//--------------------------------------------------------------------------
NTSTATUS
GetClientBuffer(
    IN PSecBuffer pInput,
    OUT PSecBuffer pOutput,
    IN PSPM_LPC_MESSAGE pMessage,
    IN OUT PUCHAR *         Where
    )
{
    NTSTATUS hrRet = STATUS_SUCCESS;
    SecBuffer Output;
    Output = *pInput;

    //
    // If the buffer is already mapped or it doesn't exist (is NULL) we
    // are done.
    //

    if (!(pInput->BufferType & SECBUFFER_UNMAPPED) ||
        !pInput->pvBuffer)
    {
        return(S_OK);
    }

    Output.BufferType &= ~SECBUFFER_UNMAPPED;
    Output.pvBuffer = LsapAllocateLsaHeap(pInput->cbBuffer);
    if (!(Output.pvBuffer))
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    if (pInput->pvBuffer != (PVOID) SEC_PACKED_BUFFER_VALUE)
    {
        hrRet = LsapCopyFromClient( pInput->pvBuffer,
                                   Output.pvBuffer,
                                   Output.cbBuffer );
    }
    else
    {
        if (*Where == NULL)
        {
            *Where = pMessage->ApiMessage.bData;
        }
        RtlCopyMemory( Output.pvBuffer, *Where, Output.cbBuffer);
        *Where += Output.cbBuffer;
    }
    if (FAILED(hrRet))
    {
        LsapFreeLsaHeap(Output.pvBuffer);
    }
    else
    {
        *pOutput = Output;
    }
    return(hrRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapWriteClientBuffer
//
//  Synopsis:   Allocates and copies a buffer out to the client
//
//  Arguments:  [LsaBuffer]    --
//              [ClientBuffer] --
//
//  History:    4-11-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapWriteClientBuffer(
    IN PSecBuffer   LsaBuffer,
    OUT PSecBuffer  ClientBuffer
    )
{
    NTSTATUS Status ;
    PVOID Client ;

    Status = LsapAllocateClientBuffer( NULL,
                                        LsaBuffer->cbBuffer,
                                        &Client );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsapCopyToClientBuffer( NULL,
                                         LsaBuffer->cbBuffer,
                                         Client,
                                         LsaBuffer->pvBuffer );

        if ( NT_SUCCESS( Status ) )
        {
            ClientBuffer->BufferType = LsaBuffer->BufferType ;
            ClientBuffer->cbBuffer = LsaBuffer->cbBuffer ;
            ClientBuffer->pvBuffer = Client ;
        }
        else
        {
            LsapFreeClientBuffer( NULL, Client );
        }
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapChangeHandle
//
//  Synopsis:   Changes a handle, based on the current API, session
//
//  Arguments:  [HandleOp]  --
//              [OldHandle] --
//              [NewHandle] --
//
//  History:    9-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LsapChangeHandle(
    SECHANDLE_OPS   HandleOp,
    PSecHandle  OldHandle,
    PSecHandle  NewHandle
    )
{
    PLSA_CALL_INFO CallInfo ;
    PSPM_LPC_MESSAGE    pMessage;
    SPMAcquireCredsAPI *pAcquireCreds;
    SPMInitContextAPI * pInitContext;
    SPMAcceptContextAPI *pAcceptContext;
    BOOL ContextHandle ;
    PSession pSession ;
    SecHandle RemoveHandle = { 0 };
    PVOID Key ;


    CallInfo = LsapGetCurrentCall();

    if ( !CallInfo )
    {
        return FALSE ;
    }

    pMessage = CallInfo->Message ;

    pSession = CallInfo->Session ;


    ContextHandle = TRUE ;

    if ( HandleOp == HandleRemoveReplace )
    {
        RemoveHandle = *OldHandle ;
    }

    switch ( pMessage->ApiMessage.dwAPI )
    {
        case SPMAPI_AcquireCreds:
            pAcquireCreds = LPC_MESSAGE_ARGSP( pMessage, AcquireCreds );

            if ( HandleOp == HandleReplace )
            {
                RemoveHandle = pAcquireCreds->hCredential ;
            }

            DebugLog((DEB_TRACE, "[%x] Changing Handle %p : %p to %p : %p\n",
                pSession->dwProcessID,
                pAcquireCreds->hCredential.dwUpper, pAcquireCreds->hCredential.dwLower,
                NewHandle->dwUpper, NewHandle->dwLower ));

            pAcquireCreds->hCredential = *NewHandle ;

            ContextHandle = FALSE ;

            break;

        case SPMAPI_InitContext:
            pInitContext = LPC_MESSAGE_ARGSP( pMessage, InitContext );

            if ( HandleOp == HandleReplace )
            {
                RemoveHandle = pInitContext->hContext ;
            }

            DebugLog((DEB_TRACE, "[%x] Changing Handle %p : %p to %p : %p\n",
                pSession->dwProcessID,
                pInitContext->hContext.dwUpper, pInitContext->hContext.dwLower,
                NewHandle->dwUpper, NewHandle->dwLower ));

            pInitContext->hNewContext = *NewHandle ;

            break;

        case SPMAPI_AcceptContext:
            pAcceptContext = LPC_MESSAGE_ARGSP( pMessage, AcceptContext );

            if ( HandleOp == HandleReplace )
            {
                RemoveHandle = pAcceptContext->hContext ;
            }

            DebugLog((DEB_TRACE, "[%x] Changing Handle %p : %p to %p : %p\n",
                pSession->dwProcessID,
                pAcceptContext->hNewContext.dwUpper, pAcceptContext->hNewContext.dwLower,
                NewHandle->dwUpper, NewHandle->dwLower ));

            pAcceptContext->hNewContext = *NewHandle ;

            break;

        default:

            return( FALSE );
    }

    pMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_HANDLE_CHG ;

    //
    // Clean up the handle references.  The old handle is dereferenced,
    // the new handle is referenced once (to make up for it).
    //

    if ( ContextHandle )
    {
        if ( HandleOp != HandleSet )
        {
            DebugLog(( DEB_TRACE, "[%x] Deleting old context handle %p : %p\n",
                            pSession->dwProcessID,
                            RemoveHandle.dwUpper, RemoveHandle.dwLower ));

            ValidateAndDerefContextHandle( pSession, &RemoveHandle );

            // ValidateContextHandle( pSession, NewHandle, &Key );
        }

    }
    else
    {
        if ( HandleOp != HandleSet )
        {
            DebugLog(( DEB_TRACE, "[%x] Deleting old credential handle %p : %p\n",
                            pSession->dwProcessID,
                            RemoveHandle.dwUpper, RemoveHandle.dwLower ));

            ValidateAndDerefCredHandle( pSession, &RemoveHandle );

            // ValidateCredHandle( pSession, NewHandle, &Key );
        }

    }

    return( TRUE );

}

NTSTATUS
LsapFixupAuthIdentity(
    PKSEC_LSA_MEMORY_HEADER KMap,
    PVOID AuthIdentity
    )
{
    PSEC_WINNT_AUTH_IDENTITY_EX AuthEx ;
    NTSTATUS Status = STATUS_SUCCESS ;
    ULONG_PTR PoolBase = (ULONG_PTR) -1 ;
    USHORT i ;

    AuthEx = (PSEC_WINNT_AUTH_IDENTITY_EX) AuthIdentity ;

    DsysAssert( AuthEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION );

    for ( i = 0 ; i < KMap->MapCount ; i++ )
    {
        if ( (PUCHAR) KMap + KMap->PoolMap[ i ].Offset == (PUCHAR) AuthIdentity )
        {
            PoolBase = (ULONG_PTR) KMap->PoolMap[ i ].Pool ;
            break;
        }
        
    }

    if ( AuthEx->User )
    {
        if ( (ULONG_PTR) AuthEx->User > PoolBase)
        {
            AuthEx->User = (PWSTR) ( (ULONG_PTR) AuthEx->User - PoolBase );
            
        }
        if ( (ULONG_PTR) AuthEx->User < 0x10000 )
        {
            AuthEx->User = (PWSTR) ((ULONG_PTR)AuthEx->User + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->User ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }
        
    }
    if ( AuthEx->Domain )
    {
        if ( (ULONG_PTR) AuthEx->Domain > PoolBase)
        {
            AuthEx->Domain = (PWSTR) ( (ULONG_PTR) AuthEx->Domain - PoolBase );
            
        }
        if ( (ULONG_PTR) AuthEx->Domain < 0x10000 )
        {
            AuthEx->Domain = (PWSTR) ((ULONG_PTR)AuthEx->Domain + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->Domain ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }
        
    }
    if ( AuthEx->Password )
    {
        if ( (ULONG_PTR) AuthEx->Password > PoolBase)
        {
            AuthEx->Password = (PWSTR) ( (ULONG_PTR) AuthEx->Password - PoolBase );
            
        }
        if ( (ULONG_PTR) AuthEx->Password < 0x10000 )
        {
            AuthEx->Password = (PWSTR) ((ULONG_PTR)AuthEx->Password + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->Password ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }
        
    }
    if ( AuthEx->PackageList )
    {
        if ( (ULONG_PTR) AuthEx->PackageList > PoolBase)
        {
            AuthEx->PackageList = (PWSTR) ( (ULONG_PTR) AuthEx->PackageList - PoolBase );
            
        }
        if ( (ULONG_PTR) AuthEx->PackageList < 0x10000 )
        {
            AuthEx->PackageList = (PWSTR) ((ULONG_PTR)AuthEx->PackageList + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->PackageList ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }
        
    }

    return Status ;
}

//+-------------------------------------------------------------------------
//
//  Function:   LpcAcquireCreds()
//
//  Synopsis:   Lpc stub for AcquireCredHandle
//
//  Effects:    Calls the WLsaAcquire function
//
//  Arguments:  pApiMessage - Input message
//              pApiMessage   - Output message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LpcAcquireCreds(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    UNICODE_STRING  ssPrincipalName;
    UNICODE_STRING  ssPackageName;
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMAcquireCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.AcquireCreds;

    PSession        pSession ;
    PLSA_CALL_INFO  CallInfo ;
    PUCHAR Where = NULL;

    pSession = GetCurrentSession();
    CallInfo = LsapGetCurrentCall();

    DebugLog((DEB_TRACE, "[%x] LpcAcquireCreds()\n", pSession->dwProcessID));

    ssPrincipalName.Buffer = NULL;
    ssPackageName.Buffer = NULL;

    if (pArgs->ssPrincipal.Buffer )
    {
        scRet = GetClientString(&pArgs->ssPrincipal,
                            &ssPrincipalName,
                            pApiMessage,
                            &Where);
        if (FAILED(scRet))
        {
            DebugLog((DEB_ERROR, "GetClientString failed to get principal name 0x%08x\n", scRet));
            pApiMessage->ApiMessage.scRet = scRet;
            return(scRet);
        }

    } else {
        ssPrincipalName.MaximumLength = 0;
        ssPrincipalName.Length = 0;
        ssPrincipalName.Buffer = NULL;
    }

    scRet = GetClientString(&pArgs->ssSecPackage,
                            &ssPackageName,
                            pApiMessage,
                            &Where);

    if (FAILED(scRet))
    {
        LsapFreePrivateHeap(ssPrincipalName.Buffer);
        DebugLog((DEB_ERROR, "GetClientString failed to get package name 0x%08x\n", scRet));
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    if ( CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        scRet = LsapFixupAuthIdentity( CallInfo->KMap, pArgs->pvAuthData );
        if ( !NT_SUCCESS( scRet ) )
        {
            LsapFreePrivateHeap(ssPrincipalName.Buffer);
            LsapFreePrivateHeap(ssPackageName.Buffer);
            DebugLog((DEB_ERROR, "AuthData in KMap not formatted correctly\n" ));

            pApiMessage->ApiMessage.scRet = scRet;
            return(scRet);

            
        }
        
    }


    scApiRet = WLsaAcquireCredHandle(   (PSECURITY_STRING) &ssPrincipalName,
                                        (PSECURITY_STRING) &ssPackageName,
                                        pArgs->fCredentialUse,
                                        &pArgs->LogonID,
                                        (PVOID) pArgs->pvAuthData,
                                        (PVOID) pArgs->pvGetKeyFn,
                                        (PVOID) pArgs->ulGetKeyArgument,
                                        &pArgs->hCredential,
                                        &pArgs->tsExpiry);


    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    DebugLog((DEB_TRACE_VERB, "[%x] WLsaAcquire returned %x\n", pSession->dwProcessID, scRet));

    LsapFreePrivateHeap(ssPackageName.Buffer);

    LsapFreePrivateHeap(ssPrincipalName.Buffer);

    pApiMessage->ApiMessage.scRet = scApiRet;
    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }
    return(S_OK);

}


//+---------------------------------------------------------------------------
//
//  Function:   LpcFreeCredHandle
//
//  Synopsis:   Free a credential handle
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcFreeCredHandle(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    PSession    pSession ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcFreeCreds\n", pSession->dwProcessID));

    hrApiRet = WLsaFreeCredHandle(&pApiMessage->ApiMessage.Args.SpmArguments.API.FreeCredHandle.hCredential);

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCaptureBuffers
//
//  Synopsis:   Capture client buffers and counts to local memory, validating
//              as we go.
//
//  Arguments:  [InputBuffers]   --
//              [MappedBuffers]  --
//              [MapTokenBuffer] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapCaptureBuffers(
    IN PUCHAR          Base,
    IN PSecBufferDesc  InputBuffers,
    OUT PSecBufferDesc MappedBuffers,
    OUT PVOID *        CapturedBuffers,
    IN BOOLEAN         MapTokenBuffers
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PSecBuffer LocalCopy ;
    PSecBufferDesc Capture ;
    ULONG i ;

    //
    // Initialize them first:
    //

    *CapturedBuffers = NULL ;

    RtlZeroMemory(
        MappedBuffers->pBuffers,
        MappedBuffers->cBuffers * sizeof( SecBuffer ) );

    for (i = 0 ; i < MappedBuffers->cBuffers ; i++ )
    {
        MappedBuffers->pBuffers[ i ].BufferType = SECBUFFER_UNMAPPED ;
    }

    if ( InputBuffers->cBuffers > MappedBuffers->cBuffers )
    {
        return STATUS_INVALID_PARAMETER ;
    }


    //
    // Sizewise, we're safe to copy now:
    //


    if ( (ULONG_PTR) InputBuffers->pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
    {
        if ( InputBuffers->cBuffers * sizeof( SecBuffer ) > CBPREPACK )
        {
            return STATUS_INVALID_PARAMETER ;
        }

        LocalCopy = (PSecBuffer) (Base +
                                (ULONG_PTR) InputBuffers->pBuffers );

        RtlCopyMemory(
            MappedBuffers->pBuffers,
            LocalCopy,
            InputBuffers->cBuffers * sizeof( SecBuffer ) );
    }
    else
    {
        //
        // They were too big to fit.  Copy them directly from the client
        // process:
        //


        Capture = (PSecBufferDesc) LsapAllocatePrivateHeap( sizeof( SecBufferDesc ) +
                                          sizeof( SecBuffer ) * InputBuffers->cBuffers );

        if ( Capture == NULL )
        {
            Status = SEC_E_INSUFFICIENT_MEMORY ;
        }
        else
        {
            Capture->pBuffers = (PSecBuffer) (Capture + 1);
            Capture->cBuffers = InputBuffers->cBuffers ;
            Capture->ulVersion = SECBUFFER_VERSION ;

            Status = LsapCopyFromClient(
                            InputBuffers->pBuffers,
                            MappedBuffers->pBuffers,
                            InputBuffers->cBuffers * sizeof( SecBuffer ) );

            if ( NT_SUCCESS( Status ) )
            {
                RtlCopyMemory(
                    Capture->pBuffers,
                    MappedBuffers->pBuffers,
                    InputBuffers->cBuffers * sizeof( SecBuffer ) );

                *CapturedBuffers = Capture ;
            }
            else
            {
                LsapFreePrivateHeap( Capture );
            }

        }


    }

    if ( !NT_SUCCESS( Status ) )
    {
        for ( i = 0 ; i < MappedBuffers->cBuffers ; i++ )
        {
            MappedBuffers->pBuffers[ i ].BufferType = SECBUFFER_UNMAPPED ;
        }
        return Status ;
    }

    //
    // Touch up the mapped buffers so that the count is correct
    //

    MappedBuffers->cBuffers = InputBuffers->cBuffers ;

    //
    // try to map the security blob one:
    //

    if ( MapTokenBuffers )
    {
        Status = MapTokenBuffer(
                    MappedBuffers,
                    TRUE );
    }
    else
    {
        Status = STATUS_SUCCESS ;
    }


    return Status ;

}


VOID
LsapResetKsecBuffer(
    PKSEC_LSA_MEMORY_HEADER Header
    )
{
    Header->Consumed = Header->Preserve ;
    Header->MapCount = 0 ;
    RtlZeroMemory( Header->PoolMap, sizeof( KSEC_LSA_POOL_MAP ) * KSEC_LSA_MAX_MAPS );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCreateKsecBuffer
//
//  Synopsis:   Creates a kmap buffer to return to ksecdd
//
//  Arguments:  [InitialSize] -- Minimum size of the buffer
//
//  History:    2-9-01    RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PKSEC_LSA_MEMORY_HEADER
LsapCreateKsecBuffer(
    SIZE_T InitialSize
    )
{
    PKSEC_LSA_MEMORY_HEADER Header = NULL ;
    NTSTATUS Status ;
    SIZE_T Size = LSA_MAX_KMAP_SIZE ;
    

    InitialSize += sizeof( KSEC_LSA_MEMORY_HEADER );

    DsysAssert( InitialSize < Size );

    Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    (PVOID *) &Header,
                    0,
                    &Size,
                    MEM_RESERVE,
                    PAGE_READWRITE );

    if ( NT_SUCCESS( Status ) )
    {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    (PVOID *) &Header,
                    0,
                    &InitialSize,
                    MEM_COMMIT,
                    PAGE_READWRITE );

        if ( NT_SUCCESS( Status ) )
        {
            Header->Size = LSA_MAX_KMAP_SIZE ;
            Header->Commit = (ULONG) InitialSize ;
            Header->Preserve = sizeof( KSEC_LSA_MEMORY_HEADER );

            LsapResetKsecBuffer( Header );
            
        }
        else
        {
            NtFreeVirtualMemory(
                    NtCurrentProcess(),
                    (PVOID *) &Header,
                    0,
                    MEM_RELEASE );

            Header = NULL ;
        }
    }

    return Header ;


}


PVOID
LsapAllocateFromKsecBuffer(
    PKSEC_LSA_MEMORY_HEADER Header,
    ULONG Size
    )
{

    SIZE_T DesiredSize ;
    NTSTATUS Status ;
    PVOID Block ;
    PVOID Page ;


    Size = ROUND_UP_COUNT( Size, ALIGN_LPVOID ); 

    if ( Header->Consumed + Size > Header->Commit )
    {
        DesiredSize = Header->Commit - Header->Consumed + Size ;

        DesiredSize = ROUND_UP_COUNT( DesiredSize, LsapPageSize );

        Page = (PUCHAR) Header + Header->Commit ;

        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &Page,
                    0,
                    &DesiredSize,
                    MEM_COMMIT,
                    PAGE_READWRITE );

        if ( NT_SUCCESS( Status ) )
        {
            Header->Commit += (ULONG) DesiredSize ;
            
        }
        
    }

    if ( Header->Consumed + Size <= Header->Commit )
    {
        Block = (PVOID) ((PUCHAR) Header + Header->Consumed) ;

        Header->Consumed += Size ;

    }
    else
    {

        Block = NULL ;
    }

    return Block ;
}




//+---------------------------------------------------------------------------
//
//  Function:   LsapUncaptureBuffers
//
//  Synopsis:   Return all the buffers to the client process.
//
//  Arguments:  [Base]           -- Base address of message
//              [CapturedBuffers]-- Captured buffer descriptions
//              [InputBuffers]   -- Buffers supplied by the client
//              [MappedBuffers]  -- Mapped buffers
//              [AllocateMemory] -- Allocate memory for 
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapUncaptureBuffers(
    IN PUCHAR  Base,
    IN OUT PVOID * CapturedBuffers,
    IN OUT PSecBufferDesc InputBuffers,
    IN OUT PSecBufferDesc MappedBuffers,
    IN BOOL AllocateMemory,
    IN BOOL CopyBack,
    OUT PULONG pFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PSecBuffer Buffers ;
    PSecBufferDesc Capture ;
    ULONG i ;
    PVOID Scratch ;
    PVOID ScratchBuffers[ MAX_SECBUFFERS ];
    PSecBufferDesc Input;
    SecBufferDesc InputFixup ;
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();

    DebugLog(( DEB_TRACE_SPECIAL, "LsapUncaptureBuffers:\n" ));

    RtlZeroMemory( ScratchBuffers, sizeof( ScratchBuffers ) );

    Capture = (PSecBufferDesc) *CapturedBuffers ;

    if ( InputBuffers )
    {
        

        if ( Capture )
        {
            DebugLog(( DEB_TRACE_SPECIAL, "  using captured buffers\n" ));
            Input = Capture ;
        }
        else
        {
            if ( (ULONG_PTR) InputBuffers->pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH  )
            {
                //
                // Time to fix up:
                //

                InputFixup.pBuffers = (PSecBuffer) (Base + (ULONG_PTR) InputBuffers->pBuffers );
                InputFixup.cBuffers = InputBuffers->cBuffers ;
                InputFixup.ulVersion = SECBUFFER_VERSION ;

                Input = &InputFixup ;
                DebugLog(( DEB_TRACE_SPECIAL, "  using buffers in message\n" ));
            }
            else
            {
                Input = InputBuffers ;
                DebugLog(( DEB_TRACE_SPECIAL, "  using buffers from caller\n" ));
            }

        }

        //
        // First, handle the map back to the client process
        //

        for ( i = 0 ; i < MappedBuffers->cBuffers ; i++ )
        {

            //
            // If this is a read only buffer, or it was not mapped across,
            // skip it.  There is no change that will go back to the client.
            //

            DebugLog(( DEB_TRACE_SPECIAL, " Processing buffer %d, <t=%x [%c%c%c],cb=%x,pv=%p>\n",
                        i,
                        MappedBuffers->pBuffers[ i ].BufferType & ~SECBUFFER_ATTRMASK,
                        (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_READONLY ? 'R' : ' '),
                        (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_UNMAPPED ? 'U' : ' '),
                        (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_KERNEL_MAP ? 'K' : ' '),
                        MappedBuffers->pBuffers[ i ].cbBuffer,
                        MappedBuffers->pBuffers[ i ].pvBuffer ));

            //
            // For readonly or untouched buffers, skip them.
            //

            if ( ( MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_ATTRMASK ) ==
                    ( SECBUFFER_READONLY | SECBUFFER_UNMAPPED ) )
            {
                DebugLog(( DEB_TRACE_SPECIAL, "  Buffer %d: skipped\n", i ));
                continue;
            }

            //
            // If this is a SSPI security blob (aka a token), decide what
            // needs to be done:
            //
            if ( ( MappedBuffers->pBuffers[ i ].BufferType & (~SECBUFFER_ATTRMASK) )
                      == SECBUFFER_TOKEN )
            {
                if ( ( MappedBuffers->pBuffers[ i ].cbBuffer > 0 ) &&
                     ( CopyBack ) )
                {
                    DebugLog(( DEB_TRACE_SPECIAL, "  Copying back buffer %d\n", i ));

                    if ( CallInfo->Flags & CALL_FLAG_KMAP_USED )
                    {
                        //
                        // KMap case:
                        //

                        Scratch = LsapAllocateFromKsecBuffer(
                                        CallInfo->KMap,
                                        MappedBuffers->pBuffers[ i ].cbBuffer 
                                        );

                        if ( !Scratch )
                        {
                            Status = SEC_E_INSUFFICIENT_MEMORY ;
                            break;

                        }

                        *pFlags |= SPMAPI_FLAG_KMAP_MEM ;

                    }
                    else if ( AllocateMemory )
                    {
                        Scratch = LsapClientAllocate(
                                        MappedBuffers->pBuffers[ i ].cbBuffer
                                        );

                        //
                        // Allocation failed, break out of the loop with a failure
                        // status code, and handle the failure there:
                        //

                        if ( !Scratch )
                        {
                            Status = SEC_E_INSUFFICIENT_MEMORY ;
                            break;
                        }

                        *pFlags |= SPMAPI_FLAG_MEMORY;
                    }
                    else
                    {

                        Scratch = Input->pBuffers[ i ].pvBuffer ;
                        if ( Input->pBuffers[ i ].cbBuffer <
                                MappedBuffers->pBuffers[ i ].cbBuffer )
                        {
                            //
                            // Buffer too small.  Break out and return the failure
                            //

                            Status = STATUS_BUFFER_TOO_SMALL ;
                            break;
                        }
                    }

                    //
                    // Copy the buffer back to the client address space
                    //

                    ScratchBuffers[ i ] = Scratch ;

                    if ( CallInfo->Flags & CALL_FLAG_KMAP_USED )
                    {
                        DebugLog(( DEB_TRACE_SPECIAL, "  Copying %x bytes from %p to %p [KMap]\n",
                               MappedBuffers->pBuffers[ i ].cbBuffer,
                               MappedBuffers->pBuffers[ i ].pvBuffer,
                               Scratch ));

                        RtlCopyMemory(
                            Scratch,
                            MappedBuffers->pBuffers[ i ].pvBuffer,
                            MappedBuffers->pBuffers[ i ].cbBuffer );

                        Status = STATUS_SUCCESS ;

                    }
                    else
                    {
                        DebugLog(( DEB_TRACE_SPECIAL, "  Copying %x bytes from %p to %p\n",
                                   MappedBuffers->pBuffers[ i ].cbBuffer,
                                   MappedBuffers->pBuffers[ i ].pvBuffer,
                                   Scratch ));

                        Status = LsapCopyToClient(
                                    MappedBuffers->pBuffers[ i ].pvBuffer,
                                    Scratch,
                                    MappedBuffers->pBuffers[ i ].cbBuffer
                                    );

                    }

                    if ( !NT_SUCCESS( Status ) )
                    {
                        break;
                    }

                }
                else
                {
                    //
                    // For zero length buffers that appear to be mapped, set scratch
                    // equal to the original input value.
                    //

                    DebugLog(( DEB_TRACE_SPECIAL, "  Zero length buffer\n" ));

                    ScratchBuffers[ i ] = Input->pBuffers[ i ].pvBuffer ;
                }
            }
            else
            {
                //
                // This is not a token buffer, it is a EXTRA, or PADDING, or
                // one of those.  Turn off the mapping bit, and copy out
                // the buffer value.
                //
                DebugLog(( DEB_TRACE_SPECIAL, "  Special buffer [%p] passed back\n", 
                            Input->pBuffers[ i ].pvBuffer ));

                ScratchBuffers[ i ] = Input->pBuffers[ i ].pvBuffer ;
            }

        }
    }
    else
    {

        DebugLog(( DEB_TRACE_SPECIAL, "InputBuffers is NULL, just walking and freeing\n" ));
    }

    //
    // Now go through and free any allocated memory
    //

    for ( i = 0 ; i < MappedBuffers->cBuffers ; i++ )
    {
        if ( (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_UNMAPPED) == 0 )
        {
            //
            // This buffer was mapped in.  Free it.
            //

            if ( !LsapIsBlockInKMap( CallInfo->KMap, MappedBuffers->pBuffers[ i ].pvBuffer ) )
            {
                LsapFreeLsaHeap( MappedBuffers->pBuffers[ i ].pvBuffer );
                
            }
            else
            {
                DebugLog(( DEB_TRACE_SPECIAL, "Buffer at %p is in KMap\n", MappedBuffers->pBuffers[ i ].pvBuffer ));
            }
        }

        //
        // Turn off our bit
        //

        MappedBuffers->pBuffers[ i ].BufferType &= ~(SECBUFFER_UNMAPPED);

        //
        // If we allocated a new buffer (here or in the client), it's
        // been stored away in the scratch array, and we copy it in
        //


        if ( ScratchBuffers[ i ] )
        {
            MappedBuffers->pBuffers[ i ].pvBuffer = ScratchBuffers[ i ];
        }
    }

    if ( InputBuffers )
    {
        if ( NT_SUCCESS( Status ) )
        {
            //
            // Now, copy back the buffer descriptors.  Note that in the normal (optimal)
            // case, this will fit into the LPC message.  Otherwise, we have to copy

            if ( (ULONG_PTR) InputBuffers->pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
            {
                Buffers = (PSecBuffer) (Base + (ULONG_PTR) InputBuffers->pBuffers );

                RtlCopyMemory(
                    Buffers,
                    MappedBuffers->pBuffers,
                    MappedBuffers->cBuffers * sizeof( SecBuffer ) );
            }
            else
            {
                Status = LsapCopyToClient(
                    MappedBuffers->pBuffers,
                    InputBuffers->pBuffers,
                    MappedBuffers->cBuffers * sizeof( SecBuffer ) );
            }

            InputBuffers->cBuffers = MappedBuffers->cBuffers ;
        }
        
    }


    if ( Capture )
    {
        LsapFreePrivateHeap( Capture );
        *CapturedBuffers = NULL ;
    }

    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapChangeBuffer
//
//  Synopsis:   Switches a buffer around.  If the old one needs to be freed,
//              it is cleaned up.
//
//  Arguments:  [Old] -- 
//              [New] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
LsapChangeBuffer(
    PSecBuffer Old,
    PSecBuffer New
    )
{
    if ( ( Old->BufferType & SECBUFFER_KERNEL_MAP ) == 0 )
    {
        if ( ( Old->BufferType & SECBUFFER_UNMAPPED ) == 0 )
        {
            LsapFreeLsaHeap( Old->pvBuffer );
        }
        
    }

    *Old = *New ;

    return STATUS_SUCCESS ;
}


NTSTATUS
LsapCheckMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName
    )
{
    PWSTR Candidate;
    ULONG CandidateSize;

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // if target info wasn't supplied, or the length doesn't look like it
    // includes the marshalled version, do nothing.
    //

    if( (TargetServerName == NULL) ||
        (TargetServerName->Buffer == NULL) ||
        (TargetServerName->Length < (sizeof( CREDENTIAL_TARGET_INFORMATIONW ) / (sizeof(ULONG_PTR)/2)) )
        )
    {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
            &CandidateSize,
            (PBYTE)TargetServerName->Buffer + TargetServerName->Length - sizeof(ULONG),
            sizeof( CandidateSize )
            );

    if( TargetServerName->Length <= CandidateSize )
    {
        return STATUS_SUCCESS;
    }

    Candidate = (PWSTR)(
            (PBYTE)TargetServerName->Buffer + TargetServerName->Length - CandidateSize
            );

    Status = CredUnmarshalTargetInfo (
                    Candidate,
                    CandidateSize,
                    NULL
                    );

    if( !NT_SUCCESS(Status) )
    {
        if( Status == STATUS_INVALID_PARAMETER )
        {
            Status = STATUS_SUCCESS;
        }
    } else {

        //
        // marshalled information was found.  adjust the Length to
        // represent the non-marshalled content, and MaximumLength to
        // include non-marshalled+marshalled content.  This allows legacy
        // packages to continue to handle the TargetServerName string properly.
        //

        TargetServerName->MaximumLength = TargetServerName->Length;
        TargetServerName->Length -= (USHORT)CandidateSize;
    }

    return Status ;
}



//+-------------------------------------------------------------------------
//
//  Function:   LpcInitContext()
//
//  Synopsis:   LPC Serverside InitializeSecurityContext
//
//  Notes:      OutputBuffers and LocalOutput are the local copy of the
//              output buffers.  The secbuffers in the ApiMessage point
//              to client addresses.
//
//--------------------------------------------------------------------------
NTSTATUS
LpcInitContext(
    PSPM_LPC_MESSAGE  pApiMessage
    )

{
    UNICODE_STRING  ssTarget = {0,0,NULL};
    NTSTATUS         scApiRet;
    NTSTATUS         scRet;
    ULONG           i;
    PSecBufferDesc  pOutput = NULL;
    PSecBufferDesc  pInput = NULL;
    PVOID           CapturedInput = NULL ;
    PVOID           CapturedOutput = NULL  ;
    SecBufferDesc   LocalOutput;
    SecBufferDesc   LocalInput ;
    SPMInitContextAPI  * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.InitContext;
    PUCHAR Where = NULL;
    SecBuffer       ContextData = {0,0,NULL};
    SecBuffer       OutputBuffers[MAX_SECBUFFERS];
    SecBuffer       InputBuffers[MAX_SECBUFFERS];
    PSession        pSession ;
    BOOLEAN         MappedOutput = FALSE;
    BOOLEAN         FirstCall ;
    DWORD Flags ;
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();


    pSession = GetCurrentSession();


    DebugLog((DEB_TRACE, "[%x] LpcInitContext()\n", pSession->dwProcessID));

    DebugLog((DEB_TRACE_VERB, "  hCredentials = %d:%d\n",
              pArgs->hCredential.dwUpper,
              pArgs->hCredential.dwLower));



    //
    // Copy target string to local space:
    //


    scRet = GetClientString(&pArgs->ssTarget,
                            &ssTarget,
                            pApiMessage,
                            &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
        DebugLog((DEB_ERROR, "LpcInitContext, no target, error %x\n", scRet));
        return(scRet);
    }

    //
    // check if the caller supplied marshalled target info.
    // this will update the Length and MaximumLength fields
    // if marshalled info was present.
    //

    LsapCheckMarshalledTargetInfo( &ssTarget );

    //
    // Set all the SecBuffer's to be unmapped, but map the Security token
    //

    LocalInput.pBuffers = InputBuffers ;
    LocalInput.ulVersion = SECBUFFER_VERSION ;

    if (pArgs->sbdInput.cBuffers)
    {

        pInput = &pArgs->sbdInput;

        //
        // If there is a buffer, reset the pointer and
        // map it
        //

        LocalInput.cBuffers = MAX_SECBUFFERS ;

        scRet = LsapCaptureBuffers(
                        (PUCHAR) pArgs,
                        pInput,
                        &LocalInput,
                        &CapturedInput,
                        TRUE );

        if ( !NT_SUCCESS( scRet ) )
        {
            pInput = NULL ;
            scApiRet = scRet ;
            goto InitCleanExit ;
        }

    }
    else
    {
        LocalInput.pBuffers = InputBuffers ;
        LocalInput.cBuffers = 0 ;
        LocalInput.ulVersion = SECBUFFER_VERSION ;
    }

    //
    // Copy the output SecBuffer's so that if they get mapped we can
    // still copy back the data
    //

    pOutput = &pArgs->sbdOutput;
    if (pOutput->cBuffers)
    {
        LocalOutput.cBuffers = MAX_SECBUFFERS ;
        LocalOutput.pBuffers = OutputBuffers;
        LocalOutput.ulVersion = SECBUFFER_VERSION ;

        scRet = LsapCaptureBuffers(
                    (PUCHAR) pArgs,
                    pOutput,
                    &LocalOutput,
                    &CapturedOutput,
                    FALSE );


        if ( !NT_SUCCESS( scRet ) )
        {
            scApiRet = scRet ;
            goto Init_FreeStringAndExit ;
        }


        MappedOutput = TRUE;
    }
    else
    {
        LocalOutput.cBuffers = 0 ;
        LocalOutput.pBuffers = OutputBuffers ;
        LocalOutput.ulVersion = SECBUFFER_VERSION ;
    }

    if (pArgs->sbdOutput.cBuffers &&
        !(pArgs->fContextReq & ISC_REQ_ALLOCATE_MEMORY))
    {
        if (FAILED(scRet = MapTokenBuffer(&LocalOutput, FALSE)))
        {
            scApiRet = scRet;
            goto InitCleanExit;
        }
    }

    //
    // Call the worker for relay to the package:
    //

    if ( ( pArgs->hContext.dwUpper == 0 ) &&
         ( pArgs->hContext.dwLower == 0 ) )
    {
        FirstCall = TRUE ;
    }
    else
    {
        FirstCall = FALSE ;
    }

    scApiRet = WLsaInitContext( &pArgs->hCredential,
                                &pArgs->hContext,
                                (PSECURITY_STRING) &ssTarget,
                                pArgs->fContextReq,
                                pArgs->dwReserved1,
                                pArgs->TargetDataRep,
                                &LocalInput,          // &pArgs->sbdInput,
                                pArgs->dwReserved2,
                                &pArgs->hNewContext,
                                &LocalOutput,
                                &pArgs->fContextAttr,
                                &pArgs->tsExpiry,
                                &pArgs->MappedContext,
                                &ContextData );

    // DsysAssert( scApiRet != SEC_E_INVALID_HANDLE );
    if( scApiRet == SEC_E_INVALID_HANDLE ||
        scApiRet == STATUS_INVALID_HANDLE )
    {
        DebugLog((DEB_ERROR, "[%x] LpcInitContext() returning invalid handle\n", pSession->dwProcessID));

        DebugLog((DEB_ERROR, "  hCredentials = %p:%p\n",
              pArgs->hCredential.dwUpper,
              pArgs->hCredential.dwLower));
        DebugLog((DEB_ERROR, "  hContext = %p:%p\n",
              pArgs->hContext.dwUpper,
              pArgs->hContext.dwLower));

        DsysAssert( scApiRet == STATUS_SUCCESS );
    }

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    //
    // If this is the failure case, don't bother copying everything down.
    //

    if (FAILED(scApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

        //
        // Unmap any output buffers
        //

        Flags = 0 ;

        scRet = LsapUncaptureBuffers(
                    (PUCHAR) pArgs,
                    &CapturedOutput,
                    &pArgs->sbdOutput,
                    &LocalOutput,
                    FALSE,
                    FALSE,
                    &Flags );


    }
    else
    {
        //
        // Now we have to look at the output and copy all the mapped
        // buffers back.
        //

        Flags = pApiMessage->ApiMessage.Args.SpmArguments.fAPI ;

        //
        // if a KMap is present, use it.
        //

        if ( CallInfo->KMap )
        {
            CallInfo->Flags |= CALL_FLAG_KMAP_USED ;
        }

        scRet = LsapUncaptureBuffers(
                    (PUCHAR) pArgs,
                    &CapturedOutput,
                    &pArgs->sbdOutput,
                    &LocalOutput,
                    (pArgs->fContextReq & ISC_REQ_ALLOCATE_MEMORY) ? TRUE : FALSE,
                    TRUE,
                    &Flags );

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI = (USHORT) Flags ;

        if (NT_SUCCESS(scRet) && (ContextData.cbBuffer != 0))
        {
            pArgs->ContextData = ContextData;
            pArgs->ContextData.pvBuffer = LsapClientAllocate(ContextData.cbBuffer);
            if ( pArgs->ContextData.pvBuffer )
            {
                scRet = LsapCopyToClient(
                            ContextData.pvBuffer,
                            pArgs->ContextData.pvBuffer,
                            ContextData.cbBuffer
                            );
            }
            else
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;
            }
        }


        if (FAILED(scRet))
        {
            //
            // Again, we have a real problem when this fails.  We
            // abort the context and return an error.
            //

            if ( FirstCall )
            {
                AbortLpcContext(&pArgs->hContext);
            }

            scApiRet = scRet;

            goto InitCleanExit;

        }



    }

InitCleanExit:

    pApiMessage->ApiMessage.scRet = scApiRet;

    //
    // Unmap the input buffers
    //


    scRet = LsapUncaptureBuffers(
                (PUCHAR) pArgs,
                &CapturedInput,
                &pArgs->sbdInput,
                &LocalInput,
                FALSE,
                FALSE,
                NULL );


    if (ContextData.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(ContextData.pvBuffer);
    }

    if (FAILED(scRet) && (pArgs->ContextData.pvBuffer != NULL))
    {
            LsapClientFree(pArgs->ContextData.pvBuffer);
            pArgs->ContextData.pvBuffer;

    }

Init_FreeStringAndExit:


    //
    // Test the string pointer.  If it is within the KMap, do 
    // not free it.  If there is no KMap, or it was separately
    // allocated, free it:
    //

    if (  !LsapIsBlockInKMap( CallInfo->KMap, ssTarget.Buffer ) )
    {
        LsapFreePrivateHeap( ssTarget.Buffer );
        
    }

    return(scRet);
}





//+-------------------------------------------------------------------------
//
//  Function:   LpcAcceptContext()
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The memory management is kind of weird.  The input buffers
//              are mapped into the SPMgr's memory and can be freed.  Easy.
//              The output buffers are more complex.  The original buffer
//              pointers are kep in the arguments structure, while the
//              local copies are kept in LocalOutput.
//
//--------------------------------------------------------------------------
NTSTATUS
LpcAcceptContext(
    PSPM_LPC_MESSAGE  pApiMessage
    )

{
    NTSTATUS        scRet = S_OK;
    NTSTATUS        scApiRet;
    PSession        pSession ;
    ULONG           i;
    SecBufferDesc   LocalOutput;
    SecBufferDesc   LocalInput ;
    PSecBufferDesc  pInput = NULL;
    PSecBufferDesc  pOutput = NULL ;
    SPMAcceptContextAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.AcceptContext;
    BOOLEAN MappedOutput = FALSE;
    BOOLEAN FirstCall ;
    BOOL CopyBack = FALSE ;
    DWORD Flags ;
    PVOID CapturedInput = NULL ;
    PVOID CapturedOutput = NULL ;


    SecBuffer OutputBuffers[MAX_SECBUFFERS];
    SecBuffer InputBuffers[MAX_SECBUFFERS];
    SecBuffer ContextData = {0,0,NULL};
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcAcceptContext\n", pSession->dwProcessID));

    // Copy input token to local space:
    //
    // Set all the SecBuffer's to be unmapped, but map the Security token
    //

    pInput = &pArgs->sbdInput;

    LocalInput.pBuffers = InputBuffers ;
    LocalInput.cBuffers = MAX_SECBUFFERS ;
    LocalInput.ulVersion = SECBUFFER_VERSION ;

    if (pInput->cBuffers)
    {

        scRet = LsapCaptureBuffers(
                    (PUCHAR) pArgs,
                    pInput,
                    &LocalInput,
                    &CapturedInput,
                    TRUE );


        if ( !NT_SUCCESS( scRet ) )
        {
            scApiRet = scRet;
            goto AcceptCleanExit;
        }
    }
    else
    {
        LocalInput.cBuffers = 0 ;
    }

    //
    // Copy the output SecBuffer's so that if they get mapped we can
    // still copy back the data
    //


    LocalOutput.cBuffers = MAX_SECBUFFERS ;
    LocalOutput.pBuffers = OutputBuffers ;
    LocalOutput.ulVersion = SECBUFFER_VERSION ;

    pOutput = &pArgs->sbdOutput ;

    if ( pOutput->cBuffers )
    {
        scRet = LsapCaptureBuffers(
                    (PUCHAR) pArgs,
                    pOutput,
                    &LocalOutput,
                    &CapturedOutput,
                    FALSE );

        if ( !NT_SUCCESS( scRet ) )
        {
            scApiRet = scRet ;

            goto AcceptCleanExit ;
        }

#if DBG
        if ( (pArgs->fContextReq & ASC_REQ_ALLOCATE_MEMORY ) == 0 )
        {
            for ( i = 0 ; i < LocalOutput.cBuffers ; i++ )
            {
                if ( (LocalOutput.pBuffers[ i ].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN )
                {
                    DsysAssert( LocalOutput.pBuffers[ i ].cbBuffer > 0 );
                    
                }
                
            }
            
        }
#endif 

    }
    else
    {
        LocalOutput.cBuffers = 0 ;
    }


    MappedOutput = TRUE;
    if (LocalOutput.cBuffers &&
        !(pArgs->fContextReq & ASC_REQ_ALLOCATE_MEMORY))
    {


        if (FAILED(scRet = MapTokenBuffer(&LocalOutput,FALSE)))
        {
            scApiRet = scRet;
            goto AcceptCleanExit;
        }
    }
    else
    {
        //
        // Since they asked us to allocate memory, ensure the output
        // buffers are NULL.
        //

        for (i = 0; i < LocalOutput.cBuffers ; i++ )
        {
            LocalOutput.pBuffers[i].pvBuffer = NULL;
        }
    }

    if ( ( pArgs->hContext.dwUpper == 0 ) &&
         ( pArgs->hContext.dwLower == 0 ) )
    {
        FirstCall = TRUE ;
    }
    else
    {
        FirstCall = FALSE ;
    }

    scApiRet = WLsaAcceptContext(   &pArgs->hCredential,
                                    &pArgs->hContext,
                                    &LocalInput,
                                    pArgs->fContextReq,
                                    pArgs->TargetDataRep,
                                    &pArgs->hNewContext,
                                    &LocalOutput,
                                    &pArgs->fContextAttr,
                                    &pArgs->tsExpiry,
                                    &pArgs->MappedContext,
                                    &ContextData );

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET;


    if (FAILED(scApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

        //
        // Copy the sizes from the output security buffers in case they
        // are used to indicate how much space is required
        //

        if ((pArgs->fContextAttr & ASC_RET_EXTENDED_ERROR) == 0)
        {
            CopyBack = FALSE ;
        }
        else
        {
            CopyBack = TRUE ;
        }
    }
    else
    {
        CopyBack = TRUE ;
    }

    //
    // Turn on this flag on return, so that all allocations will come 
    // out of the map.  This is safe because KMap would only be set 
    // for the right callers.
    //
    if ( CallInfo->KMap )
    {
        CallInfo->Flags |= CALL_FLAG_KMAP_USED ;
    }

    if (NT_SUCCESS(scRet) && (ContextData.cbBuffer != 0))
    {
        pArgs->ContextData = ContextData;
        pArgs->ContextData.pvBuffer = LsapClientAllocate(ContextData.cbBuffer);
        if (pArgs->ContextData.pvBuffer == NULL)
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY;
        }
        else
        {
            scRet = LsapCopyToClient(
                        ContextData.pvBuffer,
                        pArgs->ContextData.pvBuffer,
                        ContextData.cbBuffer
                        );

            if ( !NT_SUCCESS( scRet ) )
            {
                DebugLog(( DEB_ERROR, "Copy to Client failed, %x.  Client addr %p, size %#x\n",
                          scRet, pArgs->ContextData.pvBuffer, ContextData.cbBuffer ));
                
            }

        }
    }



    if ( NT_SUCCESS( scRet ) )
    {
        Flags = pApiMessage->ApiMessage.Args.SpmArguments.fAPI ;

#if DBG
        if ( ( scRet == SEC_I_CONTINUE_NEEDED ) &&
             ( LocalInput.pBuffers[0].cbBuffer < 2048 ) )
        {
            ULONG t ;

            for ( t = 0 ; t < LocalOutput.cBuffers ; t++ )
            {
                if ( ( LocalOutput.pBuffers[ t ].BufferType & 0xFFFF ) == SECBUFFER_TOKEN )
                {
                    DsysAssert( LocalOutput.pBuffers[ t ].cbBuffer > 0 );
                    
                }

                
            }
            
        }
#endif 

        scRet = LsapUncaptureBuffers(
                    (PUCHAR) pArgs,
                    &CapturedOutput,
                    &pArgs->sbdOutput,
                    &LocalOutput,
                    (pArgs->fContextReq & ASC_REQ_ALLOCATE_MEMORY ) ? TRUE : FALSE,
                    CopyBack,
                    &Flags );

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI = (USHORT) Flags ;

    }


    if (FAILED(scRet))
    {

        if ( FirstCall )
        {
            AbortLpcContext(&pArgs->hNewContext);
        }

        if( scRet == SEC_E_INSUFFICIENT_MEMORY )
        {
            DebugLog((DEB_ERROR,"[%x] Accept Failed, low memory handle passed: %p:%p\n",
                pSession->dwProcessID,
                pArgs->hNewContext.dwUpper,
                pArgs->hNewContext.dwLower
                ));
        }

        //
        // Turn off any flags that would cause the client to try and send
        // an invalid blob:
        //

        pArgs->fContextAttr &= ~ ( ASC_RET_EXTENDED_ERROR );

        scApiRet = scRet;

        goto AcceptCleanExit;
    }


AcceptCleanExit:

    pApiMessage->ApiMessage.scRet = scApiRet;

    //
    // This is cool.  Either I allocated the buffer, and I can free it this
    // way, or the package allocated it.  If the package allocated, then the
    // address is in this buffer, and I free it.  So cool.
    //

    scRet = LsapUncaptureBuffers(
                (PUCHAR) pArgs,
                &CapturedInput,
                &pArgs->sbdInput,
                &LocalInput,
                FALSE,
                FALSE,
                NULL );

    if (ContextData.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(ContextData.pvBuffer);
    }

    if (FAILED(scRet) && (pArgs->ContextData.pvBuffer != NULL))
    {
        LsapClientFree(pArgs->ContextData.pvBuffer);
        pArgs->ContextData.pvBuffer = NULL;
    }


    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   LpcEstablishCreds
//
//  Synopsis:   Lpc stub for WLsaEstablishCreds()
//
//  Notes:      obsolete
//
//--------------------------------------------------------------------------
NTSTATUS
LpcEstablishCreds(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED ;
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

    return STATUS_SUCCESS ;
}








//+-------------------------------------------------------------------------
//
//  Function:   LpcDeleteContext
//
//  Synopsis:   Delete context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LpcDeleteContext(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMDeleteContextAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.DeleteContext;


    scRet = WLsaDeleteContext(  &pArgs->hContext );

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = scRet;


    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:   LpcGetBinding
//
//  Synopsis:   Get the DLL binding info for a package
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcGetBinding(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    SPMGetBindingAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetBinding;
    NTSTATUS scRet;
    ULONG Size;
    PWSTR Base;
    PWSTR Remote;

    pArgs->BindingInfo.PackageName.Buffer = NULL ;
    pArgs->BindingInfo.Comment.Buffer = NULL ;

    scRet = WLsaGetBinding( pArgs->ulPackageId,
                            &pArgs->BindingInfo,
                            &Size,
                            &Base );

    if (SUCCEEDED(scRet))
    {
        //
        // We succeeded so now we have to copy the two strings
        //

        Remote = (PWSTR) LsapClientAllocate( Size );

        if (Remote != NULL)
        {
            LsapCopyToClient( Base, Remote, Size );

            pArgs->BindingInfo.PackageName.Buffer = Remote ;
            pArgs->BindingInfo.Comment.Buffer = Remote +
                                pArgs->BindingInfo.PackageName.MaximumLength / 2;

            pArgs->BindingInfo.ModuleName.Buffer = pArgs->BindingInfo.Comment.Buffer +
                                            pArgs->BindingInfo.Comment.MaximumLength / 2;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY;
        }

        LsapFreeLsaHeap( Base );

    }
    pApiMessage->ApiMessage.scRet = scRet;

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   LpcSetSession
//
//  Synopsis:   Internal function to set session options, including the
//              hook to do direct calls while in-process.
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcSetSession(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    SPMSetSessionAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.SetSession ;

    DebugLog((DEB_TRACE_VERB,"SetSession\n"));

    scRet = LsapSetSessionOptions( Args->Request,
                                   Args->Argument,
                                   &Args->Response );

    pApiMessage->ApiMessage.scRet = STATUS_SUCCESS;

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcFindPackage
//
//  Synopsis:   Locates a package by id
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcFindPackage(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    SECURITY_STRING ssPackageName;
    SPMFindPackageAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.FindPackage;
    PUCHAR Where = NULL;

    scRet = GetClientString(&pArgs->ssPackageName,&ssPackageName, pApiMessage, &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    DebugLog((DEB_TRACE_VERB,"Find Package called for %wZ\n",&ssPackageName));

    scRet = WLsaFindPackage(&ssPackageName,&pArgs->ulPackageId);

    LsapFreePrivateHeap(ssPackageName.Buffer);

    pApiMessage->ApiMessage.scRet = scRet;
    return(scRet);

}


//+---------------------------------------------------------------------------
//
//  Function:   LpcEnumPackages
//
//  Synopsis:   Enumerate available packages
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcEnumPackages(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    SPMEnumPackagesAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.EnumPackages;

    scRet = WLsaEnumeratePackages(&pArgs->cPackages,&pArgs->pPackages);

    pApiMessage->ApiMessage.scRet = scRet;
    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   LpcApplyToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LpcApplyToken(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMApplyTokenAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.ApplyToken;
    ULONG i;



    pArgs->sbdInput.pBuffers = pArgs->sbInputBuffer;

    scRet = MapTokenBuffer(&pArgs->sbdInput, TRUE);
    if (FAILED(scRet))
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    scRet = WLsaApplyControlToken(  &pArgs->hContext,
                                    &pArgs->sbdInput);

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = scRet;


    for (i = 0; i < pArgs->sbdInput.cBuffers; i++ )
    {
        if (!(pArgs->sbdInput.pBuffers[i].BufferType & SECBUFFER_UNMAPPED))
        {
            LsapFreeLsaHeap(pArgs->sbdInput.pBuffers[i].pvBuffer);
        }
    }


    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   LpcQueryPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcQueryPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMQueryPackageAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.QueryPackage;
    SECURITY_STRING ssPackageName;
    BOOLEAN fNameAlloc = FALSE;
    BOOLEAN fCommentAlloc = FALSE;
    LPWSTR pszNameString = NULL;
    LPWSTR pszCommentString = NULL;
    ULONG cbLength;
    PUCHAR Where = NULL;



    scRet = GetClientString(&pArgs->ssPackageName,&ssPackageName, pApiMessage, &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    DebugLog((DEB_TRACE_VERB,"Querying package %wZ\n",&ssPackageName));

    scRet = WLsaQueryPackageInfo(   &ssPackageName,
                                    &pArgs->pPackageInfo);

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    DebugLog((DEB_TRACE_VERB,"Querying package returned %x\n",scRet));

    LsapFreePrivateHeap(ssPackageName.Buffer);
    pApiMessage->ApiMessage.scRet = scRet;

    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   LpcGetUserInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcGetUserInfo(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    static LUID lFake = {0,0};
    SPMGetUserInfoAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetUserInfo;
    PLUID pLogonId;

    if ((pArgs->LogonId.LowPart == 0) &&
        (pArgs->LogonId.HighPart == 0))
    {
        pLogonId = NULL;
    }
    else pLogonId = &pArgs->LogonId;

    scRet = WLsaGetSecurityUserInfo(
                pLogonId,
                pArgs->fFlags,
                &pArgs->pUserInfo
                );

    pApiMessage->ApiMessage.scRet = scRet;
    return(scRet);

}


//+-------------------------------------------------------------------------
//
//  Function:   LpcGetCreds
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LpcGetCreds(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMGetCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetCreds;

    scRet = SEC_E_UNSUPPORTED_FUNCTION;

    pApiMessage->ApiMessage.scRet = scRet;

    //
    // It is up to the package to do the right thing with the
    // buffer (for now).
    //

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LpcSaveCreds
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LpcSaveCreds(PSPM_LPC_MESSAGE pApiMessage)
{
    NTSTATUS scRet;
    SPMSaveCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.SaveCreds;

    scRet = SEC_E_UNSUPPORTED_FUNCTION;

    pApiMessage->ApiMessage.scRet = scRet;


    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   LpcDeleteCreds
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcDeleteCreds(PSPM_LPC_MESSAGE pApiMessage)
{
    NTSTATUS scRet;
    SPMDeleteCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.DeleteCreds;

    scRet = SEC_E_UNSUPPORTED_FUNCTION;

    pApiMessage->ApiMessage.scRet = scRet;


    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   LpcLsaLookupPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcLsaLookupPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;
    UNICODE_STRING  sPackageName;
    ANSI_STRING     sAnsiName;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    NTSTATUS Status;

    //
    //  First, convert ANSI name to UNICODE
    //

    if ( pLsaMessage->Arguments.LookupPackage.PackageNameLength >
            LSAP_MAX_PACKAGE_NAME_LENGTH )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    sAnsiName.Length = (USHORT) pLsaMessage->Arguments.LookupPackage.PackageNameLength;
    sAnsiName.MaximumLength = LSAP_MAX_PACKAGE_NAME_LENGTH+1;
    sAnsiName.Buffer = pLsaMessage->Arguments.LookupPackage.PackageName;

    Status = RtlAnsiStringToUnicodeString(&sPackageName, &sAnsiName, TRUE);
    if ( !NT_SUCCESS(Status) )
    {
        pLsaMessage->Arguments.LookupPackage.AuthenticationPackage = (ULONG) -1;
        pLsaMessage->ReturnedStatus = Status;
    }
    else
    {
        //
        // Now, look up the package.
        //
        pspPackage = SpmpLookupPackage(&sPackageName);

        if (pspPackage)
        {
            pLsaMessage->Arguments.LookupPackage.AuthenticationPackage = (DWORD) pspPackage->dwPackageID;
            pLsaMessage->ReturnedStatus = STATUS_SUCCESS;
        }
        else
        {
            pLsaMessage->Arguments.LookupPackage.AuthenticationPackage = (ULONG) -1;
            pLsaMessage->ReturnedStatus = STATUS_NO_SUCH_PACKAGE;
        }
        RtlFreeUnicodeString(&sPackageName);
    }

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   LpcLsaDeregisterLogonProcess
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcLsaDeregisterLogonProcess(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;


    //
    // The client side will close the handle (or not, not a big deal), and
    // we will run down the session at that time.  Safer that way, as well.
    //


    pLsaMessage->ReturnedStatus = STATUS_SUCCESS;

    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:   LpcLsaLogonUser
//
//  Synopsis:   Unmarshalls everything for a call to WLsaLogonUserWhoopee
//
//  Arguments:  [pApiMessage] --
//
//  History:    6-14-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcLsaLogonUser(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS Status;
    LSAP_CLIENT_REQUEST ClientRequest;
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;
    PSession Session = GetCurrentSession();

    ClientRequest.Request = (PLSAP_AU_API_MESSAGE) pApiMessage;

    pLsaMessage->ReturnedStatus = LsapAuApiDispatchLogonUser(&ClientRequest);

    if ( NT_SUCCESS( pLsaMessage->ReturnedStatus ) )
    {
        if ( ( pLsaMessage->Arguments.LogonUser.LogonType == Interactive ) &&
             ( pLsaMessage->Arguments.LogonUser.ProfileBuffer == NULL ) )
        {
            DsysAssertMsg( pLsaMessage->Arguments.LogonUser.ProfileBuffer,
                           "Successful logon, but profile is NULL. w\n" );
        }
    }

    return(STATUS_SUCCESS);

}

//+-------------------------------------------------------------------------
//
//  Function:   LpcLsaCallPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcLsaCallPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    LSAP_CLIENT_REQUEST ClientRequest;
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;
    PSession Session = GetCurrentSession();

    ClientRequest.Request = (PLSAP_AU_API_MESSAGE) pApiMessage;

    pLsaMessage->ReturnedStatus = LsapAuApiDispatchCallPackage(&ClientRequest);

    return(STATUS_SUCCESS);
}





//+-------------------------------------------------------------------------
//
//  Function:   LpcQueryCredAttributes
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcQueryCredAttributes(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    SPMQueryCredAttributesAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.QueryCredAttributes;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    hrApiRet = WLsaQueryCredAttributes(
                    &pArgs->hCredentials,
                    pArgs->ulAttribute,
                    pArgs->pBuffer
                    );

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    if ( CallInfo->Allocs )
    {
        ULONG i ;

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ALLOCS ;

        pArgs->Allocs = CallInfo->Allocs ;
        for ( i = 0 ; i < CallInfo->Allocs ; i++ )
        {
            pArgs->Buffers[i] = CallInfo->Buffers[i] ;
        }
    }

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}




//+---------------------------------------------------------------------------
//
//  Function:   LpcAddPackage
//
//  Algorithm:
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
LpcAddPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    SPMAddPackageAPI * pArgs;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet ;
    PUCHAR Where = NULL;
    SECURITY_PACKAGE_OPTIONS Options;

    pArgs = LPC_MESSAGE_ARGSP( pApiMessage, AddPackage );

    scRet = GetClientString(    &pArgs->Package,
                                &PackageName,
                                pApiMessage,
                                &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;

        return(scRet);
    }

    DebugLog((DEB_TRACE_VERB,"Add Package called for %ws\n",
                        PackageName.Buffer ));

    Options.Flags = pArgs->OptionsFlags ;
    Options.Size = sizeof( SECURITY_PACKAGE_OPTIONS );

    scRet = WLsaAddPackage( &PackageName,
                            &Options );

    LsapFreePrivateHeap( PackageName.Buffer );

    pApiMessage->ApiMessage.scRet = scRet;

    return( scRet );

}

//+---------------------------------------------------------------------------
//
//  Function:   LpcDeletePackage
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
LpcDeletePackage(
    PSPM_LPC_MESSAGE pApiMessage)
{
    pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION ;

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcQueryContextAttributes
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcQueryContextAttributes(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    SPMQueryContextAttrAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.QueryContextAttr;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    hrApiRet = WLsaQueryContextAttributes(
                    &pArgs->hContext,
                    pArgs->ulAttribute,
                    pArgs->pBuffer
                    );


    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if ( CallInfo->Allocs )
    {
        ULONG i ;

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ALLOCS ;

        pArgs->Allocs = CallInfo->Allocs ;
        for ( i = 0 ; i < CallInfo->Allocs ; i++ )
        {
            pArgs->Buffers[i] = CallInfo->Buffers[i] ;
        }
        pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( CallInfo->Allocs * sizeof( PVOID ) );
        pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( CallInfo->Allocs * sizeof( PVOID ) );
    }


    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcSetContextAttributes
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcSetContextAttributes(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    SPMSetContextAttrAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.SetContextAttr;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    hrApiRet = WLsaSetContextAttributes(
                    &pArgs->hContext,
                    pArgs->ulAttribute,
                    pArgs->pBuffer,
                    pArgs->cbBuffer
                    );


    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcCallback
//
//  Synopsis:   Callback handler.  Should never be hit.
//
//  Arguments:  [pApiMessage] --
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcCallback(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION ;
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;
    return S_OK ;
}



NTSTATUS
WLsaGenerateKey(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PULONG  EfsLength,
    PEFS_KEY * Fek
    )
{
    NTSTATUS        Status;
    DWORD           HResult;

    HANDLE          hToken      = NULL;
    HANDLE          hProfile    = NULL;

    PEFS_DATA_STREAM_HEADER EfsStreamHeader;

    //
    // Impersonate the client
    //

    Status = LsapImpersonateClient( );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    EFS_USER_INFO   EfsUserInfo;

    if (EfspGetUserInfo( &EfsUserInfo )) {

        BOOL b = EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile );

        if (!b) {

            HResult = GetLastError();
            if (!EfsErrorToNtStatus(HResult, &Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }

        } else {

            //
            // Generate the Fek.  This routine will fill in the
            // EFS_KEY structure with key data.
            //

            if (GenerateFEK( Fek )) {

                if (!ConstructEFS( &EfsUserInfo, *Fek, DirectoryEfsStream, &EfsStreamHeader )) {

                    HResult = GetLastError();

                    ASSERT( HResult != ERROR_SUCCESS );

                    DebugLog((DEB_ERROR, "ConstructEFS failed, error = (%x)\n" ,HResult  ));

                    LsapFreeLsaHeap( *Fek );
                    *Fek = NULL;

                    if (!EfsErrorToNtStatus(HResult, &Status)) {
                        Status = STATUS_UNSUCCESSFUL;
                    }

                } else {

                    *EfsStream = EfsStreamHeader;
                    *EfsLength = EfsStreamHeader->Length;
                }

            } else {

                HResult = GetLastError();
                if (!EfsErrorToNtStatus(HResult, &Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            EfspUnloadUserProfile( hToken, hProfile );
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        HResult = GetLastError();
        if (!EfsErrorToNtStatus(HResult, &Status)) {
            Status = STATUS_UNSUCCESSFUL;
        }

    }


    RevertToSelf();

    return Status;
}

NTSTATUS
WLsaGenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    PEFS_DATA_STREAM_HEADER * EfsStream
    )
{
    NTSTATUS Status;
    DWORD HResult;

    HANDLE hToken = NULL;
    HANDLE hProfile = NULL;
    PEFS_KEY Fek = NULL;

    Status = LsapImpersonateClient( );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    EFS_USER_INFO   EfsUserInfo;

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (!EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

            HResult = GetLastError();
            if (!EfsErrorToNtStatus(HResult, &Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }

        } else {

            if (GenerateFEK( &Fek )) {

                if (!ConstructDirectoryEFS(
                             &EfsUserInfo,
                             Fek,
                             EfsStream
                             )) {

                    HResult = GetLastError();
                    ASSERT( HResult != ERROR_SUCCESS );
                    DebugLog((DEB_ERROR, "ConstructDirectoryEFS failed, error = (%x)\n" ,HResult  ));
                    if (!EfsErrorToNtStatus(HResult, &Status)) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }

                LsapFreeLsaHeap( Fek );

            } else {

                HResult = GetLastError();
                if (!EfsErrorToNtStatus(HResult, &Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            EfspUnloadUserProfile( hToken, hProfile );
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        HResult = GetLastError();
        if (!EfsErrorToNtStatus(HResult, &Status)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    RevertToSelf();

    return Status;
}



NTSTATUS
LpcEfsGenerateKey(   PSPM_LPC_MESSAGE    pApiMessage)

/*++

Routine Description:

    This routine generates an FEK and an EFS stream for the file
    being encrypted.

Arguments:

    pApiMessage - Supplies the LPC message from the driver.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NTSTATUS scRet;
    SPMEfsGenerateKeyAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateKey ;
    ULONG EfsLength = 0;
    PEFS_KEY Fek = NULL;
    PEFS_DATA_STREAM_HEADER EfsStream;
    SIZE_T BufferLength;

    DebugLog((DEB_TRACE_EFS,"LpcEfsGenerateKey, Args is at %x\n",Args));

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if (EfsPersonalVer || EfsDisabled) {
        pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED;
        return STATUS_NOT_SUPPORTED;
    }

    scRet = WLsaGenerateKey(
               (PEFS_DATA_STREAM_HEADER)Args->DirectoryEfsStream,
               &EfsStream,
               &EfsLength,
               &Fek
               );

    if (NT_SUCCESS( scRet )) {

        //
        // Copy the FEK to the client's address space
        //

        PVOID Target = NULL;

        BufferLength = EFS_KEY_SIZE( Fek ) + EfsLength;

#ifdef LSAP_CATCH_BAD_VM
        if ( BufferLength > 0x2000000 )
        {
            DbgPrint("Allocation too large\n" );
            DbgBreakPoint();
        }
#endif
        scRet = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &Target,
                            0,
                            &BufferLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );

        Args->BufferLength = (ULONG) BufferLength;
        if (NT_SUCCESS( scRet )) {

            //
            // Save away the base of the allocation so that the driver may free it
            // when it's finished with it.
            //

            Args->BufferBase = Target;
            Args->Fek = Target;

            RtlCopyMemory(
                Target,
                (PVOID)Fek,
                EFS_KEY_SIZE( Fek )
                );


            Target = (PVOID)((ULONG_PTR)Target + EFS_KEY_SIZE( Fek ));
            Args->EfsStream = Target;

            RtlCopyMemory(
                Target,
                (PVOID)EfsStream,
                EfsLength
                );

        } else {

            Args->BufferBase = NULL;
            Args->BufferLength = 0;
            Args->Fek = NULL;
            Args->EfsStream = NULL;

        }

        if ( Fek ){
            LsapFreeLsaHeap( Fek );
        }

        if ( EfsStream ){
            LsapFreeLsaHeap( EfsStream );
        }
    }

    pApiMessage->ApiMessage.scRet = scRet;
    return( scRet );
}


NTSTATUS
LpcEfsGenerateDirEfs(
    PSPM_LPC_MESSAGE pApiMessage
    )
/*++

Routine Description:

    Lpc stub for GenerateDirEfs

Arguments:

    pApiMessage - LPC Message

Return Value:

    NtStatus

--*/
{
    SPMEfsGenerateDirEfsAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateDirEfs ;
    PEFS_DATA_STREAM_HEADER EfsStream;
    NTSTATUS scRet;
    ULONG EfsLength = 0;

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if (EfsPersonalVer || EfsDisabled) {
        pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED;
        return STATUS_NOT_SUPPORTED;
    }

    scRet = WLsaGenerateDirEfs(
        (PEFS_DATA_STREAM_HEADER)Args->DirectoryEfsStream,
        &EfsStream
        );

    if (NT_SUCCESS( scRet )) {

        PVOID Target = NULL;

        SIZE_T EfsLength = EfsStream->Length;

#ifdef LSAP_CATCH_BAD_VM
        if ( EfsLength > 0x2000000 )
        {
            DbgPrint("Allocation too large\n" );
            DbgBreakPoint();
        }
#endif

        scRet = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &Target,
                            0,
                            &EfsLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );

        if (NT_SUCCESS( scRet )) {

            Args->BufferBase = Target;
            Args->BufferLength = EfsStream->Length;
            Args->EfsStream = Target;

            RtlCopyMemory(
                Target,
                (PVOID)EfsStream,
                EfsStream->Length
                );

        } else {

                Args->BufferBase = NULL;
                Args->BufferLength = 0;
                Args->EfsStream = NULL;
        }

        if (EfsStream){
            LsapFreeLsaHeap( EfsStream );
        }
    }

    pApiMessage->ApiMessage.scRet = scRet;
    return( scRet );
}

NTSTATUS
WLsaDecryptFek(
    PEFS_DATA_STREAM_HEADER EfsStream,
    PEFS_KEY * Fek,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    ULONG OpenType
    )

/*++

Routine Description:

    Worker function for DecryptFek

Arguments:

    EfsStream - The $EFS attribute for the file being decrypted.

    Fek - Returns the FEK for the file being decrypted.  This structure
        is allocated out of heap and must be freed by the caller.

    NewEfs - Optionally returns a new $EFS stream to be applied to
        the file.

    OpenType - Whether this is a decrypt or recovery operation.


Return Value:

    NtStatus

--*/

{
    NTSTATUS Status;
    DWORD HResult;
    DWORD rc;

    HANDLE hToken = NULL;
    HANDLE hProfile = NULL;

    Status = LsapImpersonateClient( );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    EFS_USER_INFO EfsUserInfo;

    if (EfspGetUserInfo( &EfsUserInfo ) ) {

        if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

            HResult = DecryptFek( &EfsUserInfo, EfsStream, Fek, NewEfs, OpenType );

            if (HResult != ERROR_SUCCESS) {
                DebugLog((DEB_ERROR, "WLsaDecryptFek: DecryptFek failed, error = %x\n" ,HResult  ));
                if (!EfsErrorToNtStatus(HResult, &Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            EfspUnloadUserProfile( hToken, hProfile );

        } else {

            HResult = GetLastError();
            if (!EfsErrorToNtStatus(HResult, &Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        HResult = GetLastError();
        if (!EfsErrorToNtStatus(HResult, &Status)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    RevertToSelf();

    return Status;
}


NTSTATUS
LpcEfsDecryptFek(   PSPM_LPC_MESSAGE    pApiMessage)
{
    SPMEfsDecryptFekAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsDecryptFek ;
    PEFS_DATA_STREAM_HEADER NewEfs;
    NTSTATUS Status;
    ULONG EfsLength = 0;
    PEFS_KEY Fek;
    SIZE_T BufferLength;

    Args->BufferBase = NULL;
    Args->BufferLength = 0;
    Args->Fek = NULL;
    Args->NewEfs = NULL;

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if (EfsPersonalVer || EfsDisabled) {
        pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED;
        return STATUS_NOT_SUPPORTED;
    }

    Status = WLsaDecryptFek( (PEFS_DATA_STREAM_HEADER)Args->EfsStream, &Fek, &NewEfs, Args->OpenType  );


    if (NT_SUCCESS( Status )) {

        BufferLength = EFS_KEY_SIZE( Fek );

        if (NewEfs != NULL) {
            BufferLength += NewEfs->Length;
        }

        PVOID Target = NULL;

#ifdef LSAP_CATCH_BAD_VM
        if ( BufferLength > 0x2000000 )
        {
            DbgPrint("Allocation too large\n" );
            DbgBreakPoint();
        }
#endif
        Status = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &Target,
                            0,
                            &BufferLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );


        Args->BufferLength = (ULONG) BufferLength;
        if (NT_SUCCESS( Status )) {

            Args->BufferBase = Target;
            Args->Fek = Target;

            RtlCopyMemory(
                Target,
                (PVOID)Fek,
                EFS_KEY_SIZE( Fek )
                );

            if (NewEfs != NULL) {

                Target = (PVOID)((DWORD_PTR)Target + EFS_KEY_SIZE( Fek ));
                Args->NewEfs = Target;

                RtlCopyMemory(
                    Target,
                    (PVOID)NewEfs,
                    NewEfs->Length
                    );

            }

        } else {

            Args->BufferBase = NULL;
            Args->BufferLength = 0;
            Args->Fek = NULL;

        }

        if ( Fek){
            LsapFreeLsaHeap( Fek );
        }

        if ( NewEfs ){
            LsapFreeLsaHeap( NewEfs );
        }
    }

    pApiMessage->ApiMessage.scRet = Status;

    return( Status );
}


NTSTATUS
LpcEfsGenerateSessionKey(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    SPMEfsGenerateSessionKeyAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateSessionKey ;
    NTSTATUS scRet;

    EFS_INIT_DATAEXG InitDataExg;

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if ( EfsSessionKeySent ){
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    scRet = GenerateDriverSessionKey( &InitDataExg );

    if (NT_SUCCESS( scRet )) {

        //
        // Copy the returned session key into the argument buffer
        //

        RtlCopyMemory( &Args->InitDataExg, &InitDataExg, sizeof( EFS_INIT_DATAEXG ));

        pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( sizeof( EFS_INIT_DATAEXG ) );
        pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( sizeof( EFS_INIT_DATAEXG ) );

        EfsSessionKeySent = TRUE;
    }

    pApiMessage->ApiMessage.scRet = scRet;

    return( scRet );
}

NTSTATUS
LpcGetUserName(
    PSPM_LPC_MESSAGE pApiMessage
    )
{

    LUID LogonId ;
    PLSAP_LOGON_SESSION LogonSession ;
    NTSTATUS Status ;
    SECPKG_CLIENT_INFO ClientInfo ;
    SPMGetUserNameXAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetUserNameX ;
    PLSAP_DS_NAME_MAP Map ;
    PLSAP_DS_NAME_MAP SamMap = NULL ;
    UNICODE_STRING String ;
    PWSTR Scan ;
    PWSTR DnsDomainName = NULL;

    Status = LsapGetClientInfo( &ClientInfo );

    if ( NT_SUCCESS( Status ) )
    {
        LogonSession = LsapLocateLogonSession( &ClientInfo.LogonId );

        if ( LogonSession )
        {
            if ( RtlEqualLuid( &ClientInfo.LogonId,
                               &LsapSystemLogonId ) &&
                 (Args->Options & SPM_NAME_OPTION_NT4_ONLY) )
            {
                Map = LsapGetNameForLocalSystem();

                Status = STATUS_SUCCESS ;

            }
            else
            {
                Status = LsapGetNameForLogonSession(
                                LogonSession,
                                Args->Options,
                                &Map,
                                FALSE );

                if (NT_SUCCESS(Status)
                     &&
                    (Args->Options & (~SPM_NAME_OPTION_MASK)) == NameDnsDomain)
                {
                    //
                    // To cruft up the NameDnsDomain format, we need
                    // the SAM username.
                    //

                    Status = LsapGetNameForLogonSession(
                                    LogonSession,
                                    NameSamCompatible,
                                    &SamMap,
                                    FALSE);

                    if (!NT_SUCCESS(Status))
                    {
                        LsapDerefDsNameMap(Map);
                    }
                }
            }

            LsapReleaseLogonSession( LogonSession );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // See what we can do.
                //

                if ( (Args->Options & SPM_NAME_OPTION_NT4_ONLY) == 0)
                {
                    if ((Args->Options & (~SPM_NAME_OPTION_MASK )) != NameDnsDomain)
                    {
                        String = Map->Name ;
                    }
                    else
                    {
                        //
                        // Build up the DnsDomainName format
                        //

                        Scan = wcschr( SamMap->Name.Buffer, L'\\' );

                        if ( Scan )
                        {
                            Scan++;
                        }
                        else
                        {
                            Scan = SamMap->Name.Buffer;
                        }

                        //
                        // SAM name is always NULL-terminated
                        //

                        DnsDomainName = (LPWSTR) LsapAllocatePrivateHeap(
                                                     Map->Name.Length + (wcslen(Scan) + 2) * sizeof(WCHAR));

                        if (DnsDomainName != NULL)
                        {
                            ULONG Index = Map->Name.Length / sizeof(WCHAR);

                            wcsncpy(DnsDomainName, Map->Name.Buffer, Index);
                            DnsDomainName[Index++] = L'\\';
                            wcscpy(DnsDomainName + Index, Scan);

                            RtlInitUnicodeString(&String, DnsDomainName);
                        }
                        else
                        {
                            String.Length = String.MaximumLength = 0;
                            String.Buffer = NULL;

                            Status = STATUS_NO_MEMORY;
                        }

                        LsapDerefDsNameMap(SamMap);
                    }
                }
                else
                {
                    Scan = wcschr( Map->Name.Buffer, L'\\' );

                    if ( Scan )
                    {
                        Scan++;
                        RtlInitUnicodeString( &String, Scan );
                    }
                    else
                    {
                        String = Map->Name ;
                    }
                }

                if (NT_SUCCESS(Status))
                {
                    if ( String.Length <= Args->Name.MaximumLength )
                    {
                        Args->Name.Length = String.Length ;

                        if ( String.Length < CBPREPACK )
                        {
                            Args->Name.Buffer = (PWSTR) ((LONG_PTR) pApiMessage->ApiMessage.bData
                                                           - (LONG_PTR) Args);

                            RtlCopyMemory(
                                pApiMessage->ApiMessage.bData,
                                String.Buffer,
                                String.Length );

                            pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( String.Length );
                            pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( String.Length );
                        }
                        else
                        {
                            Status = LsapCopyToClient(
                                        String.Buffer,
                                        Args->Name.Buffer,
                                        String.Length );
                        }
                    }
                    else
                    {
                        Args->Name.Length = String.Length ;
                        Args->Name.Buffer = NULL ;
                        Status = STATUS_BUFFER_OVERFLOW ;
                    }
                }

                LsapDerefDsNameMap( Map );
            }
            else
            {
                if ( Status == STATUS_UNSUCCESSFUL )
                {
                    pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_WIN32_ERROR ;
                    Status = GetLastError();
                }
            }
        }
        else
        {
            DebugLog(( DEB_ERROR, "No logon session found for impersonated client!\n" ));
            Status = STATUS_NO_SUCH_LOGON_SESSION ;
        }
    }

    if (DnsDomainName != NULL)
    {
        LsapFreePrivateHeap(DnsDomainName);
    }

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = Status ;

    return STATUS_SUCCESS ;
}


NTSTATUS
LpcAddCredentials(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    UNICODE_STRING  ssPrincipalName;
    UNICODE_STRING  ssPackageName;
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMAddCredentialAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.AddCredential;

    PSession        pSession ;
    PUCHAR Where = NULL;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcAddCredentials()\n", pSession->dwProcessID));

    ssPrincipalName.Buffer = NULL;
    ssPackageName.Buffer = NULL;

    if (pArgs->ssPrincipal.Buffer )
    {
        scRet = GetClientString(&pArgs->ssPrincipal,
                            &ssPrincipalName,
                            pApiMessage,
                            &Where);
        if (FAILED(scRet))
        {
            DebugLog((DEB_ERROR, "GetClientString failed to get principal name 0x%08x\n", scRet));
            pApiMessage->ApiMessage.scRet = scRet;
            return(scRet);
        }

    } else {
        ssPrincipalName.MaximumLength = 0;
        ssPrincipalName.Length = 0;
        ssPrincipalName.Buffer = NULL;
    }

    scRet = GetClientString(&pArgs->ssSecPackage,
                            &ssPackageName,
                            pApiMessage,
                            &Where);

    if (FAILED(scRet))
    {
        LsapFreePrivateHeap(ssPrincipalName.Buffer);
        DebugLog((DEB_ERROR, "GetClientString failed to get package name 0x%08x\n", scRet));
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    scApiRet = WLsaAddCredentials(
                    &pArgs->hCredentials,
                    &ssPrincipalName,
                    &ssPackageName,
                    pArgs->fCredentialUse,
                    (PVOID) pArgs->pvAuthData,
                    (PVOID) pArgs->pvGetKeyFn,
                    (PVOID) pArgs->ulGetKeyArgument,
                    &pArgs->tsExpiry );


    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    LsapFreePrivateHeap(ssPackageName.Buffer);

    LsapFreePrivateHeap(ssPrincipalName.Buffer);

    pApiMessage->ApiMessage.scRet = scApiRet;
    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }
    return(S_OK);

}

NTSTATUS
LpcEnumLogonSessions(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMEnumLogonSessionAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.EnumLogonSession ;
    PSession        pSession ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcEnumLogonSessions()\n", pSession->dwProcessID));

    scApiRet = WLsaEnumerateLogonSession(
                    &pArgs->LogonSessionCount,
                    (PLUID *) &pArgs->LogonSessionList );

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }
    return(S_OK);

}

NTSTATUS
LpcGetLogonSessionData(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMGetLogonSessionDataAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetLogonSessionData ;
    PSession        pSession ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcGetLogonSessionData()\n", pSession->dwProcessID));

    scApiRet = WLsaGetLogonSessionData(
                    &pArgs->LogonId,
                    &pArgs->LogonSessionInfo );

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }
    return(S_OK);

}

NTSTATUS
LpcLookupAccountName(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMLookupAccountNameXAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.LookupAccountNameX ;
    PSession        pSession ;
    UNICODE_STRING  Name ;
    PUCHAR          Where = NULL ;
    LSAPR_TRANSLATED_SIDS_EX2 Sids ;
    PLSAPR_REFERENCED_DOMAIN_LIST DomList ;
    LSAPR_UNICODE_STRING String ;
    ULONG MappedCount ;
    ULONG Available ;
    ULONG Size ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcLookupAccountName()\n", pSession->dwProcessID));


    scApiRet = GetClientString(
                    &pArgs->Name,
                    &Name,
                    pApiMessage,
                    &Where );

    if ( NT_SUCCESS( scApiRet ) )
    {
        MappedCount = 0 ;

        String.Length = Name.Length ;
        String.MaximumLength = Name.MaximumLength ;
        String.Buffer = Name.Buffer ;

        scApiRet = LsarLookupNames3(
                        LsapPolicyHandle,
                        1,
                        &String,
                        &DomList,
                        &Sids,
                        LsapLookupWksta,
                        &MappedCount,
                        0,
                        LSA_CLIENT_LATEST );

        if ( NT_SUCCESS( scApiRet ) )
        {

            Where = pApiMessage->ApiMessage.bData ;
            pArgs->NameUse = Sids.Sids[0].Use ;

            Size = RtlLengthSid( (PSID) Sids.Sids[0].Sid );

            pArgs->Sid = (PVOID) (Where - (PUCHAR) pApiMessage) ;
            RtlCopyMemory(
                Where,
                Sids.Sids[0].Sid,
                Size );


            Available = CBPREPACK - Size ;
            Where += Size ;

            Size = DomList->Domains[0].Name.Length ;
            if ( Available >= Size )
            {
                RtlCopyMemory(
                    Where,
                    DomList->Domains[0].Name.Buffer,
                    Size );

                pArgs->Domain.Buffer = (PWSTR) (Where - (PUCHAR) pApiMessage ) ;
                pArgs->Domain.Length = (USHORT) Size ;
                pArgs->Domain.MaximumLength = (USHORT) Size ;

            }
            else
            {
                pArgs->Domain.Buffer = NULL ;
                pArgs->Domain.Length = 0 ;
                pArgs->Domain.MaximumLength = 0 ;
            }

            MIDL_user_free( DomList );
            MIDL_user_free( Sids.Sids );
        }
                        

    }

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

NTSTATUS
LpcLookupAccountSid(
    PSPM_LPC_MESSAGE pApiMessage 
    )
{
    NTSTATUS scApiRet = STATUS_SUCCESS ;
    NTSTATUS scRet;
    SPMLookupAccountSidXAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.LookupAccountSidX ;
    PSession        pSession ;
    PUCHAR          Where = NULL ;
    PLSAPR_REFERENCED_DOMAIN_LIST DomList ;
    LSAPR_SID_ENUM_BUFFER SidBuffer ;
    LSAPR_SID_INFORMATION SidInfo ;
    LSAPR_TRANSLATED_NAMES_EX Names ;
    ULONG MappedCount ;
    SIZE_T Available ;
    ULONG Size ;
    PSID Sid = NULL ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] LpcLookupAccountSid()\n", pSession->dwProcessID));

    Where = (ULONG_PTR) pArgs->Sid + (PUCHAR) pApiMessage ;
    Available = sizeof( SPM_LPC_MESSAGE ) - (ULONG_PTR) pArgs->Sid ;

    //
    // Verify that the passed SID is at least large enough for the SID header
    //
    if ( Available < sizeof( SID ) )
    {
        scApiRet = STATUS_INVALID_PARAMETER ;
    }

    if ( NT_SUCCESS( scApiRet ) )
    {
        Sid = (PSID) ( Where );

        Size = RtlLengthSid( Sid );

        if ( Size > Available )
        {
            scApiRet = STATUS_INVALID_PARAMETER ;
        }
    }

    if ( NT_SUCCESS( scApiRet ) )
    {
        PSID DomainSid = NULL;
        MappedCount = 0 ;

        SidInfo.Sid = (PLSAPR_SID) Sid ;
        SidBuffer.Entries = 1 ;
        SidBuffer.SidInfo = &SidInfo ;

        if( LsapAccountDomainMemberSid )
        {
            ULONG SidLength = RtlLengthSid( LsapAccountDomainMemberSid );
            DomainSid = LsapAllocatePrivateHeap(
                            SidLength
                            );

            if( DomainSid != NULL )
            {
                RtlCopyMemory(DomainSid, LsapAccountDomainMemberSid, SidLength);

                *(RtlSubAuthoritySid(
                        DomainSid,
                        (*GetSidSubAuthorityCount(DomainSid) - 1)
                        )) = DOMAIN_USER_RID_GUEST;

                SidInfo.Sid = (PLSAPR_SID)DomainSid;
            }
        }



        scApiRet = LsarLookupSids2(
                        LsapPolicyHandle,
                        &SidBuffer,
                        &DomList,
                        &Names,
                        LsapLookupWksta,
                        &MappedCount,
                        0,
                        LSA_CLIENT_LATEST );


        if ( NT_SUCCESS( scApiRet ) && 
             ( MappedCount == 1 ) )
        {

            Where = pApiMessage->ApiMessage.bData ;

            pArgs->NameUse = Names.Names[0].Use ;

            Size = Names.Names[0].Name.Length ;

            pArgs->Name.Buffer = (PWSTR) (Where - (PUCHAR) pApiMessage );
            pArgs->Name.Length = (USHORT) Size ;
            pArgs->Name.MaximumLength = pArgs->Name.Length ;

            RtlCopyMemory(
                Where,
                Names.Names[0].Name.Buffer,
                Size );

            Available = CBPREPACK - Size ;
            Where += Size ;

            Size = DomList->Domains[0].Name.Length ;
            if ( Available >= Size )
            {
                RtlCopyMemory(
                    Where,
                    DomList->Domains[0].Name.Buffer,
                    Size );

                pArgs->Domain.Buffer = (PWSTR) Where ;
                pArgs->Domain.Length = (USHORT) Size ;
                pArgs->Domain.MaximumLength = (USHORT) Size ;

            }
            else
            {
                pArgs->Domain.Buffer = NULL ;
                pArgs->Domain.Length = 0 ;
                pArgs->Domain.MaximumLength = 0 ;
            }

            MIDL_user_free( DomList );
            MIDL_user_free( Names.Names );


        }

        if( DomainSid )
        {
            LsapFreePrivateHeap( DomainSid );
        }
                        

    }

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapClientCallback
//
//  Synopsis:   Client Callback.
//
//  Arguments:  [Session]   --
//              [Type]      --
//              [Function]  --
//              [Argument1] --
//              [Argument2] --
//              [Input]     --
//              [Output]    --
//
//  History:    12-09-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapClientCallback(
    PSession Session,
    ULONG   Type,
    PVOID   Function,
    PVOID   Argument1,
    PVOID   Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    )
{
    PSPM_LPC_MESSAGE    Message ;
    NTSTATUS Status ;
    SPMCallbackAPI * Args ;
    PSPM_LPC_MESSAGE    ReplyTo ;
    PVOID ClientBuffer ;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    if ( !CallInfo )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    ReplyTo = CallInfo->Message ;

    if ( !ReplyTo )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    Message = (PSPM_LPC_MESSAGE) LsapAllocatePrivateHeap(
                                        sizeof( SPM_LPC_MESSAGE ) );

    if ( !Message )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

//    DebugLog(( DEB_TRACE_LPC, "Calling back on LPC message %x\n",
//            ReplyTo->pmMessage.MessageId ));

    PREPARE_MESSAGE_EX( (*Message), Callback, SPMAPI_FLAG_CALLBACK, 0 );

    Message->pmMessage = ReplyTo->pmMessage ;
    Message->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( 0 );
    Message->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( 0 );

    Args = LPC_MESSAGE_ARGS( (*Message), Callback );

    Args->Type = Type ;
    Args->CallbackFunction = Function ;
    Args->Argument1 = Argument1 ;
    Args->Argument2 = Argument2 ;

    if ( Input->pvBuffer )
    {
        Status = LsapWriteClientBuffer( Input, &Args->Input );

        if ( !NT_SUCCESS( Status ) )
        {
            LsapFreePrivateHeap( Message );

            return Status ;
        }
    }
    else
    {
        Args->Input.BufferType = SECBUFFER_EMPTY ;
        Args->Input.cbBuffer = 0 ;
        Args->Input.pvBuffer = NULL ;
    }

    ClientBuffer = Args->Input.pvBuffer ;

    if ( CallInfo->InProcCall )
    {
        //
        // Inproc Callback!
        //

        Status = DllCallbackHandler( Message );
    }
    else
    {

        DsysAssert( Session->hPort );

        Status = NtRequestWaitReplyPort( Session->hPort,
                                         (PPORT_MESSAGE) Message,
                                         (PPORT_MESSAGE) Message );

    }
    if ( !NT_SUCCESS( Status ) )
    {
        LsapFreePrivateHeap( Message );

        return Status ;
    }

    if ( ClientBuffer )
    {
        LsapFreeClientBuffer( NULL, ClientBuffer );
    }

    *Output = Args->Output ;

    Status = Message->ApiMessage.scRet ;

    LsapFreePrivateHeap( Message );

    return Status ;
}



//+---------------------------------------------------------------------------
//
//  Function:   LsapShutdownInprocDll
//
//  Synopsis:   Shuts down the inproc secur32 DLL
//
//  History:    11-04-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapShutdownInprocDll(
    VOID
    )
{
    SPM_LPC_MESSAGE LocalMessage ;
    PSPM_LPC_MESSAGE    Message ;
    SPMCallbackAPI * Args ;

    Message = &LocalMessage;

    PREPARE_MESSAGE_EX( (*Message), Callback, SPMAPI_FLAG_CALLBACK, 0 );

    Args = LPC_MESSAGE_ARGS( (*Message), Callback );

    Args->Type = SPM_CALLBACK_INTERNAL ;
    Args->CallbackFunction = NULL ;
    Args->Argument1 = (PVOID) SPM_CALLBACK_SHUTDOWN ;
    Args->Argument2 = 0 ;

    if ( DllCallbackHandler )
    {
        (void) DllCallbackHandler( Message );
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   DispatchAPI()
//
//  Synopsis:   Dispatches API requests
//
//  Effects:
//
//  Arguments:  pApiMessage - Input message
//              pApiMessage   - Output message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
DispatchAPI(PSPM_LPC_MESSAGE  pApiMessage)
{
    NTSTATUS scRet;
    PSession        pSession ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE,"[%x] LpcDispatch: dispatching %s (%x)\n",
                    pSession->dwProcessID, ApiLabel(pApiMessage->ApiMessage.dwAPI),
                    pApiMessage->ApiMessage.dwAPI));



    scRet = 0;


    if ((pApiMessage->ApiMessage.dwAPI >= LsapAuLookupPackageApi) &&
        (pApiMessage->ApiMessage.dwAPI < SPMAPI_MaxApiNumber) &&
        (LpcDispatchTable[pApiMessage->ApiMessage.dwAPI] != NULL) )
    {
        if ( !ShutdownBegun )
        {
            scRet = LpcDispatchTable[pApiMessage->ApiMessage.dwAPI](pApiMessage);

            //
            // BUGBUG: If scRet is not STATUS_SUCCESS, the error code gets dropped
            //
        }
        else
        {
            pApiMessage->ApiMessage.scRet = STATUS_SHUTDOWN_IN_PROGRESS;
        }

        //
        // Shutdown may have been initiated prior or during a call in progress.
        // If the call failed, we always return an error code indicating that
        // shutdown was invoked.  This avoids returning random error codes
        // that can result from calls failing due to async shutdown activities.
        //

        if( ShutdownBegun && !NT_SUCCESS(pApiMessage->ApiMessage.scRet) )
        {
            scRet = STATUS_SHUTDOWN_IN_PROGRESS;
            pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
            pApiMessage->ApiMessage.scRet = scRet ;
        }

        //
        // Do some checking to see if we're getting pounded by an agressive
        // app.  NOTE:  This is not MT safe (counters are not interlocked,
        // resets are not protected).  This is merely an optimization to try
        // and service clients with dedicated threads.  The counter may not
        // be precise - them's the breaks.
        //

        pSession->CallCount++ ;

        if ( pSession->Tick + 5000 < GetTickCount() )
        {
            //
            // Ok, in a minimum five second interval, did more than, say, 50
            // requests come in.  If so, set a flag indicating that the client
            // should request a workqueue.
            //

            if ( pSession->CallCount > 50 )
            {
                if (pApiMessage->ApiMessage.dwAPI > LsapAuMaxApiNumber )
                {
                    pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_GETSTATE ;
                }
            }
            pSession->CallCount = 0;
            pSession->Tick = GetTickCount();
        }

    }
    else
    {
        DebugLog((DEB_ERROR, "[%x] Dispatch:  Unknown API code %d\n",
                        pSession->dwProcessID, pApiMessage->ApiMessage.dwAPI));

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

        pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

    DebugLog((DEB_TRACE, "[%x] LpcDispatch:  retcode = %x\n", pSession->dwProcessID, pApiMessage->ApiMessage.scRet));


    return(S_OK);
}

VOID
LsapInitializeCallInfo(
    PLSA_CALL_INFO CallInfo,
    BOOL InProcess
    )
{
    PLSA_CALL_INFO OriginalCall ;

    OriginalCall = LsapGetCurrentCall() ;

    ZeroMemory( CallInfo, sizeof( LSA_CALL_INFO ) );

    CallInfo->PreviousCall = OriginalCall ;

    CallInfo->InProcCall = InProcess ;

    CallInfo->CallInfo.ProcessId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess) ;
    CallInfo->CallInfo.ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    CallInfo->CallInfo.Attributes = 0 ;
    CallInfo->Allocs = 0 ;

    CallInfo->LogContext = NULL ;
}

NTSTATUS
LsapBuildCallInfo(
    PSPM_LPC_MESSAGE    pApiMessage,
    PLSA_CALL_INFO CallInfo,
    PHANDLE Impersonated,
    PSession * NewSession,
    PSession * OldSession
    )
{
    NTSTATUS scRet ;
    BOOL Recurse = FALSE ;
    HANDLE ImpersonatedToken ;
    PSession pOldSession ;
    PSession pSession ;
    PLSA_CALL_INFO OriginalCall ;

    OriginalCall = LsapGetCurrentCall() ;

    LsapInitializeCallInfo( CallInfo,
                            TRUE );

    //
    // Save away who we were impersonating
    //

    scRet = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                TRUE,
                &ImpersonatedToken
                );
    if (!NT_SUCCESS(scRet))
    {
        if (scRet != STATUS_NO_TOKEN)
        {
            return(scRet);
        }
        ImpersonatedToken = NULL ;

        scRet = STATUS_SUCCESS ;
    }

    *Impersonated = ImpersonatedToken ;

    CallInfo->InProcToken = ImpersonatedToken ;
    CallInfo->Message = pApiMessage ;

    //
    // Check to see if we're recursing:
    //
    if ( OriginalCall &&
         OriginalCall->InProcCall &&
         pApiMessage &&
         OriginalCall->Message )
    {
        if ( OriginalCall->Message->ApiMessage.dwAPI ==
             pApiMessage->ApiMessage.dwAPI )
        {
            //
            // Same call.  Since they're both inproc, the pointers
            // are valid.  Compare the target strings
            //
            if ( pApiMessage->ApiMessage.dwAPI == SPMAPI_InitContext )
            {
                Recurse = (RtlCompareUnicodeString(
                            &pApiMessage->ApiMessage.Args.SpmArguments.API.InitContext.ssTarget,
                            &OriginalCall->Message->ApiMessage.Args.SpmArguments.API.InitContext.ssTarget,
                            TRUE ) == 0) ;
            }
        }
    }

    if ( Recurse )
    {
        DebugLog(( DEB_ERROR, "Recursive call\n" ));
        CallInfo->CallInfo.Attributes |= SECPKG_CALL_RECURSIVE ;
    }

    pOldSession = GetCurrentSession();

    pSession = pDefaultSession ;

    CallInfo->Session = pSession ;

    SpmpReferenceSession( pSession );

    *NewSession = pSession ;
    *OldSession = pOldSession ;

    return scRet ;

}

extern "C"
NTSTATUS
InitializeDirectDispatcher(
    VOID
    )
{
    InternalApiLog = ApiLogCreate( 0 );

    if ( InternalApiLog )
    {
        return STATUS_SUCCESS ;
    }

    return STATUS_UNSUCCESSFUL ;
}

//+---------------------------------------------------------------------------
//
//  Function:   DispatchAPIDirect
//
//  Synopsis:   Dispatcher to be called from security.dll when in process.
//
//  Arguments:  [pApiMessage] --
//
//  History:    9-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
DispatchAPIDirect(
    PSPM_LPC_MESSAGE    pApiMessage)
{
    NTSTATUS scRet;
    PSession    pOldSession;
    PSession    pSession;
    PVOID   DsaState ;
    HANDLE ImpersonatedToken = NULL;
    ULONG TokenSize = sizeof(HANDLE);
    LSA_CALL_INFO CallInfo ;
    PLSA_CALL_INFO OriginalCall ;
    ULONG_PTR OriginalPackageId;
    PLSAP_API_LOG_ENTRY Entry ;

    //
    // save off the current package hints to allow recursion in process.
    //

    OriginalCall = LsapGetCurrentCall() ;
    OriginalPackageId = GetCurrentPackageId();

    pApiMessage->pmMessage.MessageId = InterlockedIncrement( &InternalMessageId );

    Entry = ApiLogAlloc( InternalApiLog );

    scRet = LsapBuildCallInfo(
                pApiMessage,
                &CallInfo,
                &ImpersonatedToken,
                &pSession,
                &pOldSession );


    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    DBG_DISPATCH_PROLOGUE_EX( Entry, pApiMessage, CallInfo );

    LsapSetCurrentCall( &CallInfo );

    SetCurrentSession( pSession );


    if ( GetDsaThreadState )
    {
        DsaState = GetDsaThreadState();
    }
    else
    {
        DsaState = NULL ;
    }

    DebugLog((DEB_TRACE,"[%x] DispatchAPIDirect: dispatching %s (%d)\n",
                    pSession->dwProcessID, ApiLabel(pApiMessage->ApiMessage.dwAPI),
                    pApiMessage->ApiMessage.dwAPI));


    scRet = 0;

    if ((pApiMessage->ApiMessage.dwAPI >= LsapAuLookupPackageApi) &&
        (pApiMessage->ApiMessage.dwAPI < SPMAPI_MaxApiNumber) &&
        (LpcDispatchTable[pApiMessage->ApiMessage.dwAPI] != NULL) )
    {

        scRet = LpcDispatchTable[pApiMessage->ApiMessage.dwAPI](pApiMessage);

    }
    else
    {
        DebugLog((DEB_ERROR, "[%x] Dispatch:  Unknown API code %x\n", pSession->dwProcessID, pApiMessage->ApiMessage.dwAPI));
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
        pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

    DebugLog((DEB_TRACE, "[%x] DispatchAPIDirect:  retcode = %x\n", pSession->dwProcessID, pApiMessage->ApiMessage.scRet));

    if ( DsaState )
    {
        RestoreDsaThreadState( DsaState );
    }

    if ( pOldSession != pSession )
    {
        SetCurrentSession( pOldSession );
    }

    DBG_DISPATCH_POSTLOGUE( ULongToPtr( pApiMessage->ApiMessage.scRet ),
                            pApiMessage->ApiMessage.dwAPI );

    SpmpDereferenceSession( pSession );

    SetCurrentPackageId( OriginalPackageId );

    LsapSetCurrentCall( OriginalCall );

    (void) NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &ImpersonatedToken,
                sizeof(HANDLE)
                );

    if ( ImpersonatedToken )
    {
        NtClose( ImpersonatedToken );
    }

    return( SEC_E_OK );

}



//+---------------------------------------------------------------------------
//
//  Function:   LpcLsaPolicyChangeNotify
//
//  Synopsis:   Lpc stub for LsaPolicyChangeNotify
//
//  Arguments:  [pApiMessage] --
//
//  History:    06-05-98   MacM     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcLsaPolicyChangeNotify(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    SPMLsaPolicyChangeNotifyAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.LsaPolicyChangeNotify;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE LocalHandle = NULL;
    PSession Session;

    Session = GetCurrentSession();

    Status = CheckCaller( Session );

    if ( !NT_SUCCESS( Status ) ) {

        DebugLog(( DEB_ERROR, "CheckCaller returned 0x%lx\n", Status ));

        return( Status );

    }

    //
    // Duplicate the handle
    //
    Status = NtDuplicateObject( Session->hProcess,
                                Args->EventHandle,
                                NtCurrentProcess(),
                                &LocalHandle,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    //
    // Now, the notify
    //
    if (NT_SUCCESS( Status )) {

        Status = LsapNotifyProcessNotificationEvent( Args->NotifyInfoClass,
                                                     LocalHandle,
                                                     Session->dwProcessID,
                                                     Args->EventHandle,
                                                     Args->Register );

        if ( NT_SUCCESS( Status )) {
            // Indicate that we've successfully registered the handle
            LocalHandle = NULL;
        }

        //
        // Since we duplicated the handle in our namespace, if we fail to register it,
        // make sure we close it
        //
        if ( LocalHandle != NULL ) {
            NtClose( LocalHandle );
        }


    }


    pApiMessage->ApiMessage.scRet = Status;

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsarpc_s_stub.c ===
#include "lsarpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsapch2.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsapch2.h

Abstract:

    LSA Subsystem - precompiled includes for C Server Side

Author:

    Mike Swift          (MikeSw)        January 14, 1997

Environment:

Revision History:

--*/

#ifndef _LSAPCH2_
#define _LSAPCH2_

#include <lsasrvp.h>
#include <ausrvp.h>
#include <spmgr.h>

#ifndef NO_DS_HEADERS
#include <lsads.h>
#endif

//
// uncomment the following to enable a lot of warnings
// 
// #include <warning.h>
// #pragma warning(3:4100)   // Unreferenced formal parameter
// #pragma warning(3:4701)   // local may be used w/o init
// #pragma warning(3:4702)   // Unreachable code
// #pragma warning(3:4705)   // Statement has no effect
// #pragma warning(3:4706)   // assignment w/i conditional expression
// #pragma warning(3:4709)   // command operator w/o index expression


#endif // _LSAPCH2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\logons.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Logons.c
//
// Contents:    Logon Session lists and so forth
//
// Functions    InitLogonSessions
//              AddLogonSession
//              LocateLogonSession
//
//
// History:     27 Oct 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include <ntrmlsa.h>
#include "sidcache.h"
#include <adtp.h>
#include <secext.h>
#include <lm.h>        // NetApiBufferFree

NTSTATUS LsapInitializeCredentials();
}

#define THIRTY_MIN  { 0x30E23400, 0x00000004 }
#define NEVER_MIN   { 0xFFFFFFFF, 0x7FFFFFFF }

RTL_CRITICAL_SECTION LogonSessionListLock ;
PVOID LogonSessionTable ;
PHANDLE_PACKAGE LogonSessionPackage ;
LIST_ENTRY LogonSessionList ;
ULONG LogonSessionCount ;
PLSAP_DS_NAME_MAP LocalSystemNameMap ;

// #define LOGON_SESSION_TRACK 1


#ifdef LOGON_SESSION_TRACK
HANDLE LogonSessionLog ;
#endif

extern "C"
VOID LogonSessionLogWrite( PCHAR Format, ... );

#ifdef LOGON_SESSION_TRACK
#define LSLog( x )  LogonSessionLogWrite x
#else
#define LSLog( x )
#endif

LARGE_INTEGER LsapNameLifespans[ LSAP_MAX_DS_NAMES ] =
{
    THIRTY_MIN,     // Unknown
    THIRTY_MIN,     // FQDN (CN=yada, DC=yada)
    NEVER_MIN,      // SAM Compatible
    THIRTY_MIN,     // Display (Fred Smith)
    THIRTY_MIN,     // unused
    THIRTY_MIN,     // unused
    NEVER_MIN,      // GUID
    THIRTY_MIN,     // Canonical
    THIRTY_MIN,     // UPN
    THIRTY_MIN,     // Canonical Ex
    THIRTY_MIN,     // SPN
    NEVER_MIN,      // unused (by GetUserNameEx)
    NEVER_MIN       // DNS domain name
};


BOOL
LsapSetSamAccountNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    );

NTSTATUS
LsapGetFormatsForLogon(
    PLSAP_LOGON_SESSION LogonSession,
    IN LPWSTR Domain,
    IN LPWSTR Name,
    IN ULONG  NameType,
    OUT PLSAP_DS_NAME_MAP * Map
    );

NTSTATUS
LsapCreateDnsNameFromCanonicalName(
    IN  PLSAP_LOGON_SESSION LogonSession,
    IN  ULONG               NameType,
    OUT PLSAP_DS_NAME_MAP   * Map
    );


#ifdef LOGON_SESSION_TRACK

VOID
LogonSessionLogWrite(
    PCHAR Format,
    ...
    )
{
    CHAR Buffer[ 256 ];
    va_list ArgList ;
    int TotalSize ;
    ULONG SizeWritten ;

    if ( LogonSessionLog == NULL )
    {
        return;
    }

    va_start( ArgList, Format );

    if ((TotalSize = _vsnprintf(Buffer,
                                sizeof(Buffer),
                                Format, ArgList)) < 0)
    {
        return;

    }

    WriteFile( LogonSessionLog, Buffer, TotalSize, &SizeWritten, NULL );

}

VOID
LsapInitLogonSessionLog(
    VOID
    )
{
    WCHAR Path[ MAX_PATH ];

    ExpandEnvironmentStrings(L"%SystemRoot%\\Debug\\logonsession.log", Path, MAX_PATH );

    LogonSessionLog = CreateFile( Path, GENERIC_WRITE, FILE_SHARE_READ,
                                  NULL, CREATE_ALWAYS, 0, NULL );


    if ( LogonSessionLog == INVALID_HANDLE_VALUE )
    {
        LogonSessionLog = NULL ;

        return ;
    }

    LogonSessionLogWrite( "New LogonSession log created\n" );

}

#endif


ULONG LogonFormats[] =
{
    NameFullyQualifiedDN,  // needed for GPO
//     NameSamCompatible,  // needed for GPO but always have locally
    NameUniqueId           // needed for GPO
};

BOOLEAN
LsapIsNameFormatUsedForLogon(
    IN ULONG NameType
    )
{
    ULONG i;

    for ( i = 0; i < (sizeof(LogonFormats)/sizeof(LogonFormats[0])); i++) {
        if ( NameType == LogonFormats[i] ) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
LsapDerefDsNameMap(
    PLSAP_DS_NAME_MAP Map
    )
{
    BOOLEAN FreeMap = FALSE;

    RtlEnterCriticalSection( &LogonSessionListLock );

    Map->RefCount-- ;

    if ( Map->RefCount == 0 )
    {
        FreeMap = TRUE;
    }

    RtlLeaveCriticalSection( &LogonSessionListLock );

    if( FreeMap )
    {
        LsapFreePrivateHeap( Map );
    }

}

PLSAP_DS_NAME_MAP
LsapCreateDsNameMap(
    PUNICODE_STRING Name,
    ULONG NameType
    )
{
    LSAP_DS_NAME_MAP * Map ;
    LARGE_INTEGER Now ;
    PLARGE_INTEGER Lifespan ;

    Map = (PLSAP_DS_NAME_MAP) LsapAllocatePrivateHeap(
                sizeof( LSAP_DS_NAME_MAP ) + Name->Length + sizeof(WCHAR) );

    if ( Map )
    {
        Lifespan = &LsapNameLifespans[ NameType ];

        if ( Lifespan->QuadPart != 0x7FFFFFFFFFFFFFFF )
        {
            GetSystemTimeAsFileTime( (LPFILETIME) &Now );

            Map->ExpirationTime.QuadPart = Now.QuadPart + Lifespan->QuadPart ;
        }
        else
        {
            Map->ExpirationTime.QuadPart = Lifespan->QuadPart ;
        }

        Map->RefCount = 1 ;

        Map->Name.Buffer = (PWSTR) ( Map + 1 );
        Map->Name.MaximumLength = (USHORT) ( Name->Length + sizeof(WCHAR) );
        Map->Name.Length = Name->Length ;
        RtlCopyMemory( Map->Name.Buffer,
                       Name->Buffer,
                       Name->Length );
        Map->Name.Buffer[ Map->Name.Length / sizeof( WCHAR )] = L'\0';
    }

    return Map ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapLogonSessionDelete
//
//  Synopsis:   Callback invoked when record is to be deleted.
//
//  Arguments:  [Handle]  --
//              [Context] --
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapLogonSessionDelete(
    PSecHandle Handle,
    PVOID Context,
    ULONG RefCount
    )
{
    PLSAP_LOGON_SESSION LogonSession ;
    ULONG i;

    LogonSession = (PLSAP_LOGON_SESSION) Context ;

    if (LsapAuditSuccessfulLogons && (LogonSession->UserSid != NULL))
    {
        LsapAdtAuditLogoff( LogonSession );
    }

    RtlEnterCriticalSection( &LogonSessionListLock );

    RemoveEntryList( &LogonSession->List );

    LogonSessionCount-- ;

    RtlLeaveCriticalSection( &LogonSessionListLock );

    LSLog(( "Deleting logon session %x:%x\n",
            LogonSession->LogonId.HighPart,
            LogonSession->LogonId.LowPart ));

    for ( i = 0 ; i < LSAP_MAX_DS_NAMES ; i++ )
    {
        if ( LogonSession->DsNames[ i ] )
        {
            LsapDerefDsNameMap( LogonSession->DsNames[ i ] );
            LogonSession->DsNames[ i ] = NULL ;
        }
    }

    LsapAuLogonTerminatedPackages( &LogonSession->LogonId );

    if ( LogonSession->Packages )
    {
        LsapFreePackageCredentialList( LogonSession->Packages );
    }

    if ( LogonSession->UserSid )
    {
        LsapDbReleaseLogonNameFromCache( LogonSession->UserSid );

        LsapFreeLsaHeap( LogonSession->UserSid );
    }

    if ( LogonSession->ProfilePath.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->ProfilePath.Buffer );
    }

    if ( LogonSession->AuthorityName.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->AuthorityName.Buffer );
    }

    if ( LogonSession->AccountName.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->AccountName.Buffer );
    }

    if( LogonSession->LogonServer.Buffer )
    {
        LsapFreePrivateHeap( LogonSession->LogonServer.Buffer );
    }

    if ( LogonSession->TokenHandle != NULL )
    {
        NtClose( LogonSession->TokenHandle );
    }

    if ( LogonSession->LicenseHandle != INVALID_HANDLE_VALUE )
    {
        LsaFreeLicenseHandle( LogonSession->LicenseHandle );
    }

    CredpDereferenceCredSets( &LogonSession->CredentialSets );

    LsapFreePrivateHeap( Context );

}



NTSTATUS
LsapCreateLsaLogonSession(
    IN PLUID Luid,
    OUT PLSAP_LOGON_SESSION * pLogonSession
    )
{
    PLSAP_LOGON_SESSION LogonSession ;
    SecHandle Handle ;

    LogonSession = (PLSAP_LOGON_SESSION) LsapAllocatePrivateHeap(
                        sizeof( LSAP_LOGON_SESSION ) );

    *pLogonSession = LogonSession ;

    if ( LogonSession )
    {
        LSLog(( "Creating logon session %x:%x\n",
                Luid->HighPart, Luid->LowPart ));

        RtlZeroMemory( LogonSession, sizeof( LSAP_LOGON_SESSION ) );

        LogonSession->LogonId = *Luid ;

        GetSystemTimeAsFileTime( (LPFILETIME) &LogonSession->LogonTime );

        LsapConvertLuidToSecHandle( Luid, &Handle );

        if ( LogonSessionPackage->AddHandle(
                                    LogonSessionTable,
                                    &Handle,
                                    LogonSession,
                                    0 ) )
        {
            RtlEnterCriticalSection( &LogonSessionListLock );

            InsertHeadList( &LogonSessionList, &LogonSession->List );

            LogonSessionCount++ ;

            RtlLeaveCriticalSection( &LogonSessionListLock );

            return STATUS_SUCCESS ;
        }
        else
        {
            LsapFreePrivateHeap( LogonSession );
        }

        return STATUS_UNSUCCESSFUL ;
    }

    return STATUS_NO_MEMORY ;

}

BOOLEAN
LsapLogonSessionInitialize(
    VOID
    )
{
    LUID LocalSystem = SYSTEM_LUID ;
    PLSAP_LOGON_SESSION LogonSession ;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PLSAP_DS_NAME_MAP NameMap = NULL;
    NTSTATUS Status ;

    HANDLE ProcessToken;

    Status = LsapInitializeCredentials();

    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    Status = RtlInitializeCriticalSection( &LogonSessionListLock );

    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    InitializeListHead( &LogonSessionList );

    if ( LsaTuningParameters.Options & TUNE_SRV_HIGH_PRIORITY )
    {
        LogonSessionPackage = &LargeHandlePackage ;
    }
    else
    {
        LogonSessionPackage = &SmallHandlePackage ;
    }

#ifdef LOGON_SESSION_TRACK

    LsapInitLogonSessionLog();

    LogonSessionPackage = &LargeHandlePackage ;

#endif

    if ( LogonSessionPackage->Initialize() )
    {
        LogonSessionTable = LogonSessionPackage->Create(
                                HANDLE_PACKAGE_CALLBACK_ON_DELETE |
                                    HANDLE_PACKAGE_REQUIRE_UNIQUE,
                                NULL,
                                LsapLogonSessionDelete );

        if ( LogonSessionTable == NULL )
        {
            return FALSE ;
        }
    }
    else
    {
        return FALSE ;
    }

    //
    // Now, create the initial logon session for local system:
    //

    Status = LsapCreateLsaLogonSession(
                    &LocalSystem,
                    &LogonSession );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Status = LsapDuplicateString(
                &LogonSession->AccountName,
                LsapDbWellKnownSidName(LsapLocalSystemSidIndex) );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Status = LsapDuplicateString(
                &LogonSession->AuthorityName,
                LsapDbWellKnownSidDescription(LsapLocalSystemSidIndex) );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Status = LsapDuplicateSid(
                &LogonSession->UserSid,
                LsapLocalSystemSid );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    LogonSession->LogonType = (SECURITY_LOGON_TYPE) 0 ;
    LogonSession->LicenseHandle = INVALID_HANDLE_VALUE ;

    //
    // Store the NT4 name away separately:
    //


    LsapSetSamAccountNameForLogonSession( LogonSession );

    if ( LogonSession->DsNames[ NameSamCompatible ] )
    {
        LocalSystemNameMap = LogonSession->DsNames[ NameSamCompatible ];

        LogonSession->DsNames[ NameSamCompatible ] = NULL ;
    }

    //
    // Add the DNS domain name for the machine account
    //

    Status = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                                               (PLSAPR_POLICY_INFORMATION *) &DnsDomainInfo);

    if (NT_SUCCESS(Status))
    {
        //
        // No other threads around -- just jam the name in the logon session directly
        //

        NameMap = LsapCreateDsNameMap( (PUNICODE_STRING) &DnsDomainInfo->DnsDomainName,
                                       NameDnsDomain );

        LogonSession->DsNames[ NameDnsDomain ] = NameMap;

        //
        // Free the primary domain info
        //

        LsaIFree_LSAPR_POLICY_INFORMATION(PolicyDnsDomainInformation,
                                          (PLSAPR_POLICY_INFORMATION) DnsDomainInfo);
    }


    //
    // Grab a token handle for the logon session
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_DUPLICATE|TOKEN_QUERY,
                 &ProcessToken );

    if (NT_SUCCESS( Status )) {

        Status = LsapSetSessionToken( ProcessToken, &LocalSystem );

        NtClose( ProcessToken );

        if ( !NT_SUCCESS( Status ) ) {
            return FALSE ;
        }
    }


    //
    // Init System Logon will update the names appropriately.
    //

    return TRUE ;
}


NTSTATUS
LsapCreateLogonSession(
    IN OUT PLUID LogonId
    )

/*++

Routine Description:

    This function adds a new logon session to the list of logon sessions.
    This service acquires the AuLock.

Arguments:

    LogonId - The ID to assign to the new logon session. If it is zero,
        a new logon ID will be created.

Return Value:

    STATUS_SUCCESS - The logon session has been successfully deleted.

    STATUS_LOGON_SESSION_COLLISION - The specified Logon ID is already in
        use by another logon session.

    STATUS_QUOTA_EXCEEDED - The request could not be fulfilled due to
        memory quota limitations.


--*/

{
    NTSTATUS Status;
    PLSAP_LOGON_SESSION NewSession;
    PLSA_CALL_INFO CallInfo ;
    SecHandle Handle ;
    //
    // Create a logon Id if it has not already been don
    //

    if (LogonId->LowPart == 0 && LogonId->HighPart == 0)
    {
        Status =  NtAllocateLocallyUniqueId(LogonId);
        ASSERT(NT_SUCCESS(Status));
    }

    Status = LsapCreateLsaLogonSession(
                    LogonId,
                    &NewSession );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    NewSession->CreatingPackage = GetCurrentPackageId();

    RtlCopyLuid( &NewSession->LogonId, LogonId );

    CallInfo = LsapGetCurrentCall();

    if (CallInfo != NULL)
    {
        NewSession->Process = CallInfo->CallInfo.ProcessId ;

        if ( CallInfo->Message->ApiMessage.dwAPI == SPMAPI_AcceptContext )
        {
            NewSession->ContextAttr = CallInfo->Message->ApiMessage.Args.SpmArguments.API.AcceptContext.fContextReq ;
        }
    }



    //
    // Tell the reference monitor about the logon session...
    //

    Status = LsapCallRm(
                 RmCreateLogonSession,
                 (PVOID)LogonId,
                 (ULONG)sizeof(LUID),
                 NULL,
                 0
                 );

    if ( !NT_SUCCESS(Status) ) {

        LsapConvertLuidToSecHandle( LogonId, &Handle );

        LogonSessionPackage->DeleteHandle(
                                    LogonSessionTable,
                                    &Handle,
                                    FALSE );
        return Status;
    }


    return STATUS_SUCCESS;
}


NTSTATUS
LsapGetLogonSessionAccountInfo (
    IN PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )

/*++

Routine Description:

    This function retrieves username and authentication domain information
    for a specified logon session.


Arguments:

    LogonId - The ID of the logon session to set.

    AccountName - points to a unicode string with no buffer.  A buffer
        containing the account name will be allocated and returned
        using the PROCESS HEAP - NOT THE LSA HEAP.

    AuthorityName - points to a unicode string with no buffer.  A buffer
        containing the authority name will be allocated and returned
        using the PROCESS HEAP - NOT THE LSA HEAP.



Return Value:

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session does
        not currently exist.

    STATUS_NO_MEMORY - Could not allocate enough process heap.



--*/

{
    NTSTATUS                Status;

    PLSAP_LOGON_SESSION     LogonSession;
    SecHandle               Handle ;



    AccountName->Length = 0;
    AccountName->Buffer = NULL;
    AccountName->MaximumLength = 0;

    AuthorityName->Length = 0;
    AuthorityName->Buffer = NULL;
    AuthorityName->MaximumLength = 0;


    LsapConvertLuidToSecHandle( LogonId, &Handle );

    LogonSession = (PLSAP_LOGON_SESSION) LogonSessionPackage->GetHandleContext(
                                            LogonSessionTable,
                                            &Handle );

    if ( !LogonSession )
    {
        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    Status = STATUS_SUCCESS ;

    if ( LogonSession->AccountName.Buffer )
    {
        Status = LsapDuplicateString( AccountName, &LogonSession->AccountName );
    }

    if ( LogonSession->AuthorityName.Buffer )
    {
        Status = LsapDuplicateString( AuthorityName, &LogonSession->AuthorityName );
    }

    LogonSessionPackage->ReleaseContext(
                            LogonSessionTable,
                            &Handle );

    return(Status);

}

BOOL
LsapSetSamAccountNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    )
{
    UNICODE_STRING CombinedName ;

    if ( LogonSession->AccountName.Buffer &&
         LogonSession->AuthorityName.Buffer )
    {
        CombinedName.Buffer = (PWSTR) LsapAllocatePrivateHeap(
                                LogonSession->AccountName.Length +
                                LogonSession->AuthorityName.Length +
                                sizeof( WCHAR ) * 2 );

        if ( CombinedName.Buffer )
        {
            CombinedName.MaximumLength = LogonSession->AccountName.Length +
                                         LogonSession->AuthorityName.Length +
                                         sizeof( WCHAR ) * 2 ;

            CombinedName.Length = CombinedName.MaximumLength - 2 ;

            RtlCopyMemory( CombinedName.Buffer,
                           LogonSession->AuthorityName.Buffer,
                           LogonSession->AuthorityName.Length );

            CombinedName.Buffer[ LogonSession->AuthorityName.Length / sizeof(WCHAR) ] = L'\\';

            RtlCopyMemory( &CombinedName.Buffer[ LogonSession->AuthorityName.Length / sizeof( WCHAR ) + 1],
                           LogonSession->AccountName.Buffer,
                           LogonSession->AccountName.Length );

            CombinedName.Buffer[ CombinedName.Length / sizeof(WCHAR) ] = L'\0';

            LogonSession->DsNames[ NameSamCompatible ] =
                            LsapCreateDsNameMap(
                                &CombinedName,
                                NameSamCompatible );

            LsapFreePrivateHeap( CombinedName.Buffer );
        }

    }

    return ( LogonSession->DsNames[ NameSamCompatible ] != NULL );

}


NTSTATUS
LsapSetLogonSessionAccountInfo (
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN OPTIONAL PUNICODE_STRING ProfilePath,
    IN PSID * pUserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials OPTIONAL
    )

/*++

Routine Description:

    This function sets username and authentication domain information
    for a specified logon session.

    The current account name and authority name, if any, will be freed.

    However, if this is the system logon session the information won't
    be set.

Arguments:

    LogonId - The ID of the logon session to set.

    AccountName - points to a unicode string containing the account name
        to be assigned to the logon session.  Both the UNICODE_STRING
        structure and the buffer pointed to by that structure are expected
        to be allocated from lsa heap, and they will eventually be freed
        to that heap when no longer needed.

    AuthorityName - points to a unicode string containing the name of the
        authenticating authority of the logon session.  Both the
        UNICODE_STRING structure and the buffer pointed to by that structure
        are expected to be allocated from lsa heap, and they will eventually
        be freed to that heap when no longer needed.

    ProfilePath - points to a unicode string containing the path to the
        user's profile. The structure & buffer need to be freed.



Return Value:

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session does
        not currently exist.



--*/

{
    NTSTATUS                Status;

    PLSAP_LOGON_SESSION     LogonSession;

    SecHandle               Handle ;
    UNICODE_STRING          NullString = { 0 };
    ULONG i ;
    UNICODE_STRING          CombinedName ;

    PWSTR                   OldAccountName = NULL;
    PWSTR                   OldProfilePath = NULL;
    PWSTR                   OldAuthorityName = NULL;
    PSID                    OldUserSid = NULL;
    PWSTR                   OldLogonServer = NULL;

    UNICODE_STRING          LogonServer;

    BOOL                    fAccountNameChanged   = TRUE;
    BOOL                    fAuthorityNameChanged = TRUE;
    BOOL                    fUserSidChanged       = TRUE;

    LogonServer.Buffer = NULL;

    Status = STATUS_NO_SUCH_LOGON_SESSION;

    ASSERT( pUserSid );

    LsapConvertLuidToSecHandle( LogonId, &Handle );

    LogonSession = (PLSAP_LOGON_SESSION) LogonSessionPackage->GetHandleContext(
                                            LogonSessionTable,
                                            &Handle );

    if ( !LogonSession )
    {
        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    //
    // Get a Credential Set for this session.
    //

    if ( ( ( LogonType == Interactive ) ||
           ( LogonType == Batch )       ||
           ( LogonType == Service )     ||
           ( LogonType == CachedInteractive )     ||
           ( LogonType == RemoteInteractive ) ) &&
         ( *pUserSid != NULL ) ) {

        Status = CredpCreateCredSets( *pUserSid,
                                      AuthorityName,
                                      &LogonSession->CredentialSets );

        if ( !NT_SUCCESS(Status) ) {
            LogonSessionPackage->ReleaseContext(
                                    LogonSessionTable,
                                    &Handle );

            return Status;
        }
    }

    Status = STATUS_SUCCESS;

    if( PrimaryCredentials != NULL )
    {
        if( PrimaryCredentials->LogonServer.Buffer )
        {
            LogonServer.Buffer = (PWSTR)LsapAllocatePrivateHeap( PrimaryCredentials->LogonServer.Length );

            if( LogonServer.Buffer != NULL )
            {
                CopyMemory( LogonServer.Buffer,
                            PrimaryCredentials->LogonServer.Buffer,
                            PrimaryCredentials->LogonServer.Length
                            );

                LogonServer.Length = PrimaryCredentials->LogonServer.Length;
                LogonServer.MaximumLength = LogonServer.Length;
            }
        }
    }


    RtlEnterCriticalSection( &LogonSessionListLock );

    for ( i = 0 ; i < LSAP_MAX_DS_NAMES ; i++ )
    {
        //
        // Save the names that were prepopulated by the auth package.
        // SAM name is restored further down.
        //

        if ( LogonSession->DsNames[ i ]
              &&
             (i != NameDisplay)
              &&
             (i != NameUserPrincipal)
              &&
             (i != NameDnsDomain))
        {
            LsapDerefDsNameMap( LogonSession->DsNames[ i ] );

            LogonSession->DsNames[ i ] = NULL ;
        }
    }

    //
    // Free current names if necessary.  Since LsapDbAddLogonNameToCache is
    // called outside the scope of the LogonSessionListLock, there's a potential
    // race condition when multiple threads call LsaLogonUser for LocalService
    // or NetworkService (since they always use the same logon session).  To
    // avoid this, don't update the parameters in the logon session unless
    // the incoming parameters are different from those already in the session.
    // Do this only for the parameters LsapDbAddLogonNameToCache uses (account
    // name, authority name, and user SID).
    //

    if (LogonSession->AccountName.Buffer != NULL)
    {
        if (RtlCompareUnicodeString(&LogonSession->AccountName,
                                    AccountName,
                                    TRUE) == 0)
        {
            fAccountNameChanged = FALSE;
            OldAccountName      = AccountName->Buffer;

            //
            // Caller will try to free the buffer again if non-NULL
            //

            AccountName->Buffer = NULL;
        }
        else
        {
            OldAccountName = LogonSession->AccountName.Buffer;
        }
    }

    if (LogonSession->AuthorityName.Buffer != NULL)
    {
        if (RtlCompareUnicodeString(&LogonSession->AuthorityName,
                                    AuthorityName,
                                    TRUE) == 0)
        {
            fAuthorityNameChanged = FALSE;
            OldAuthorityName      = AuthorityName->Buffer;

            //
            // Caller will try to free the buffer again if non-NULL
            //

            AuthorityName->Buffer = NULL;
        }
        else
        {
            OldAuthorityName = LogonSession->AuthorityName.Buffer;
        }
    }

    if (LogonSession->ProfilePath.Buffer != NULL)
    {
        OldProfilePath = LogonSession->ProfilePath.Buffer;
    }

    if (LogonSession->UserSid != NULL)
    {
        if (RtlEqualSid(LogonSession->UserSid,
                        *pUserSid))
        {
            fUserSidChanged = FALSE;
            OldUserSid      = *pUserSid;

            //
            // NULL out to make sure UserSid isn't
            // used again down below.
            //

            *pUserSid = NULL;
        }
        else
        {
            OldUserSid = LogonSession->UserSid;
        }
    }


    //
    // Assign the new names - they may be null
    //

    if (fAccountNameChanged)
    {
        if ( AccountName )
        {
            LogonSession->AccountName   = *AccountName;
        }
        else
        {
            LogonSession->AccountName = NullString ;
        }
    }

    if (fAuthorityNameChanged)
    {
        if ( AuthorityName )
        {
            LogonSession->AuthorityName = *AuthorityName;
        }
        else
        {
            LogonSession->AuthorityName = NullString ;
        }
    }

    if ( ProfilePath )
    {
        LogonSession->ProfilePath   = *ProfilePath;
    }
    else
    {
        LogonSession->ProfilePath = NullString ;
    }

    if (fUserSidChanged)
    {
        LogonSession->UserSid = *pUserSid;
        *pUserSid = NULL;
    }

    LogonSession->LogonType = LogonType;

    if( LogonServer.Buffer )
    {
        OldLogonServer = LogonSession->LogonServer.Buffer;
        LogonSession->LogonServer = LogonServer;
    }

    LsapSetSamAccountNameForLogonSession( LogonSession );

    RtlLeaveCriticalSection( &LogonSessionListLock );

    if ( LogonSession->UserSid &&
         LogonSession->AccountName.Buffer &&
         LogonSession->AuthorityName.Buffer )
    {
        LsapDbAddLogonNameToCache(
            &LogonSession->AccountName,
            &LogonSession->AuthorityName,
            LogonSession->UserSid );
    }


    LogonSessionPackage->ReleaseContext(
                            LogonSessionTable,
                            &Handle );

    if( OldAccountName )
    {
        LsapFreeLsaHeap( OldAccountName );
    }

    if( OldAuthorityName )
    {
        LsapFreeLsaHeap( OldAuthorityName );
    }

    if( OldProfilePath )
    {
        LsapFreeLsaHeap( OldProfilePath );
    }

    if( OldUserSid )
    {
        LsapFreeLsaHeap( OldUserSid );
    }

    if( OldLogonServer )
    {
        LsapFreePrivateHeap( OldLogonServer );
    }

    return(Status);
}


NTSTATUS
LsapLogonSessionDeletedWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function is called by the reference monitor (via LPC) when the
    reference count on a logon session drops to zero.  This indicates that
    the logon session is no longer needed.  This is technically when the
    user is considered (from a security standpoint) to be logged out.


Arguments:

    CommandMessage - Pointer to structure containing LSA command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (LsapComponentTestCommand).

        The command-specific portion of this parameter contains the
        LogonId (LUID) of the logon session whose reference count
        has dropped to zero.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    LUID LogonId;
    SecHandle Handle ;


    //
    // Check that command is expected type
    //

    ASSERT( CommandMessage->CommandNumber == LsapLogonSessionDeletedCommand );




    //
    // Typecast the command parameter to what we expect.
    //

    LogonId = *((LUID *) CommandMessage->CommandParams);

    LsapConvertLuidToSecHandle( &LogonId, &Handle );

    LogonSessionPackage->DeleteHandle(
                            LogonSessionTable,
                            &Handle,
                            FALSE );



    UNREFERENCED_PARAMETER(ReplyMessage); // Intentionally not referenced
    return( STATUS_SUCCESS );

}

PLSAP_LOGON_SESSION
LsapLocateLogonSession(
    PLUID LogonId
    )
{
    SecHandle Handle ;
    PLSAP_LOGON_SESSION LogonSession ;

    LsapConvertLuidToSecHandle( LogonId, &Handle );

    LogonSession = (PLSAP_LOGON_SESSION) LogonSessionPackage->GetHandleContext(
                                                                LogonSessionTable,
                                                                &Handle );

    return LogonSession ;
}

VOID
LsapReleaseLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    )
{
    SecHandle Handle ;

    LsapConvertLuidToSecHandle( &LogonSession->LogonId, &Handle );

    LogonSessionPackage->ReleaseContext(
                            LogonSessionTable,
                            &Handle );

}


NTSTATUS
LsapDeleteLogonSession (
    IN PLUID LogonId
    )

/*++

Routine Description:

    This function deletes a logon session context record.  It is expected
    that no TOKEN objects were ever created within this logon session.
    This means we must inform the Reference Monitor to clean up its
    information on the logon session.

    If TOKEN objecs were created within this logon session, then deletion
    of those tokens will cause the logon session to be deleted.

    This service acquires the AuLock.


Arguments:

    LogonId - The ID of the logon session to delete.

Return Value:

    STATUS_SUCCESS - The logon session has been successfully deleted.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session doesn't
        exist.

    STATUS_BAD_LOGON_SESSION_STATE - The logon session is not in a state
        that allows it to be deleted.  This is typically an indication
        that the logon session has had a token created within it, and it
        may no longer be explicitly deleted.

--*/

{
    PLSAP_LOGON_SESSION LogonSession ;
    SecHandle Handle;
    NTSTATUS Status ;


    Status = LsapCallRm(
                 RmDeleteLogonSession,
                 (PVOID)LogonId,
                 (ULONG)sizeof(LUID),
                 NULL,
                 0
                 );

    if ( !NT_SUCCESS(Status)) {

        DebugLog(( DEB_ERROR, "LSA/RM DeleteLogonSession failed, %x\n", Status ));
    }


    LsapConvertLuidToSecHandle( LogonId, &Handle );

    LogonSessionPackage->DeleteHandle(
                            LogonSessionTable,
                            &Handle,
                            FALSE );

    return STATUS_SUCCESS ;


}

PLSAP_DS_NAME_MAP
LsapGetNameForLocalSystem(
    VOID
    )
{
    PLSAP_DS_NAME_MAP Map ;

    RtlEnterCriticalSection( &LogonSessionListLock );

    Map = LocalSystemNameMap ;

    LocalSystemNameMap->RefCount++ ;

    RtlLeaveCriticalSection( &LogonSessionListLock );

    return Map ;

}


NTSTATUS
LsapGetNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession,
    ULONG NameType,
    PLSAP_DS_NAME_MAP * Map,
    BOOL  LocalOnly
    )
{
    NTSTATUS Status ;
    PLSAP_DS_NAME_MAP NameMap ;
    LARGE_INTEGER Now ;
    WCHAR   TranslatedNameBuffer[ MAX_PATH ];
    ULONG   TranslatedNameLength ;
    PWSTR   TranslatedName = NULL ;
    UNICODE_STRING TransName ;
    PLSAP_DS_NAME_MAP SamMap ;
    BOOL TranslateStatus;
    BOOL Flush = FALSE ;
    DWORD Options ;
    WCHAR * AuthorityName = NULL;
    WCHAR * SamMapName = NULL;
    BOOLEAN NeedToImpersonate = TRUE;
    BOOL    NeedDnsDomainName = FALSE;
    BOOL    GotComputerName = FALSE;

    *Map = NULL ;

    Options = NameType & SPM_NAME_OPTION_MASK ;
    NameType &= (~SPM_NAME_OPTION_MASK );

    if ( Options & SPM_NAME_OPTION_FLUSH )
    {
        Flush = TRUE ;
    }

    if ( NameType >= LSAP_MAX_DS_NAMES )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    //
    // Check for format/account combinations that have no chance
    // of succeeding (e.g., DS formats for local-only accounts)
    // to avoid hitting the network.  Do this outside of the
    // critical region since the LUID is a read-only field.
    //

    if (NameType == NameUniqueId)
    {
        LUID LocalServiceLuid   = LOCALSERVICE_LUID;
        LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

        if (RtlEqualLuid(&LogonSession->LogonId,
                         &LocalServiceLuid)
             ||
            RtlEqualLuid(&LogonSession->LogonId,
                         &NetworkServiceLuid))
        {
            return STATUS_NO_SUCH_DOMAIN;
        }
    }

    RtlEnterCriticalSection( &LogonSessionListLock );

    if ( LogonSession->DsNames[ NameType ] )
    {
        NameMap = LogonSession->DsNames[ NameType ];

        if ( ( NameMap->ExpirationTime.QuadPart >= Now.QuadPart ) &&
             ( !Flush ) )
        {
            //
            // Valid entry, bump the ref count and return it
            //

            NameMap->RefCount++ ;

            RtlLeaveCriticalSection( &LogonSessionListLock );

            *Map = NameMap ;

            return STATUS_SUCCESS ;
        }

        //
        // Entry has expired.  Remove it, crack the name anew
        //

        LsapDerefDsNameMap( NameMap );

        LogonSession->DsNames[ NameType ] = NULL ;
    }

    SamMap = LogonSession->DsNames[ NameSamCompatible ];

    if ( SamMap == NULL )
    {
        LsapSetSamAccountNameForLogonSession( LogonSession );

        SamMap = LogonSession->DsNames[ NameSamCompatible ] ;

        if ( SamMap == NULL )
        {
            RtlLeaveCriticalSection( &LogonSessionListLock );
            return STATUS_NO_MEMORY ;
        }
    }

    //
    // Not present, or it had expired.  Crack from the beginning:
    //

    if ( NameType == NameSamCompatible )
    {
        *Map = SamMap ;

        SamMap->RefCount++ ;

        RtlLeaveCriticalSection( &LogonSessionListLock );

        return STATUS_SUCCESS ;

    }
    else if ( NameType == NameDnsDomain )
    {
        //
        // See if we're dealing with an NT4 domain, in which case we won't
        // have a DNS domain name.  If so, return ERROR_NONE_MAPPED for
        // consistency and a way for the caller to know the DC is NT4.
        //

        if (!LocalOnly)
        {
            DWORD dwError;
            PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

            TranslatedNameLength = MAX_PATH ;
            TranslatedName = TranslatedNameBuffer ;
            GetComputerNameW( TranslatedName, &TranslatedNameLength );
            RtlInitUnicodeString( &TransName, TranslatedName );

            GotComputerName = TRUE;

            //
            // Don't hit the network for local logons.
            //

            if ( !RtlEqualUnicodeString( &LogonSession->AuthorityName,
                                         &TransName,
                                         TRUE ) )
            {
                if (LogonSession->AuthorityName.MaximumLength <= LogonSession->AuthorityName.Length ||
                    LogonSession->AuthorityName.Buffer[LogonSession->AuthorityName.Length / sizeof(WCHAR)] != L'\0')
                {
                    AuthorityName = (LPWSTR) LsapAllocatePrivateHeap(LogonSession->AuthorityName.Length + sizeof( WCHAR ));

                    if (AuthorityName == NULL)
                    {
                        RtlLeaveCriticalSection( &LogonSessionListLock );
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(AuthorityName,
                                  LogonSession->AuthorityName.Buffer,
                                  LogonSession->AuthorityName.Length);

                    AuthorityName[LogonSession->AuthorityName.Length / sizeof( WCHAR )] = L'\0';
                }
                else
                {
                    AuthorityName = LogonSession->AuthorityName.Buffer;
                }

                //
                // Note that this perf hit is negligible for the non-NT4 case as the next call
                // to DsGetDcName (in SecpTranslateName) will be satisfied from the cache.  In
                // the NT4 case, we'd otherwise drop into SecpTranslateName and make a failing
                // DsGetDcName call there instead.
                //

                RtlLeaveCriticalSection(&LogonSessionListLock);

                dwError = DsGetDcName(NULL,
                                      AuthorityName,
                                      NULL,
                                      NULL,
                                      DS_DIRECTORY_SERVICE_PREFERRED,
                                      &pDcInfo);

                RtlEnterCriticalSection(&LogonSessionListLock);

                if (AuthorityName != LogonSession->AuthorityName.Buffer)
                {
                    LsapFreePrivateHeap( AuthorityName );
                }

                AuthorityName = NULL;


                //
                // Recheck the name in case it was filled in while we
                // were hitting the network.
                //

                if ( LogonSession->DsNames[ NameType ] )
                {
                    NameMap = LogonSession->DsNames[ NameType ];

                    if ( ( NameMap->ExpirationTime.QuadPart >= Now.QuadPart ) &&
                         ( !Flush ) )
                    {
                        //
                        // Valid entry, bump the ref count and return it
                        //

                        NameMap->RefCount++ ;

                        RtlLeaveCriticalSection( &LogonSessionListLock );

                        *Map = NameMap ;

                        return STATUS_SUCCESS ;
                    }

                    //
                    // Entry has expired.  Remove it, crack the name anew
                    //

                    LsapDerefDsNameMap( NameMap );

                    LogonSession->DsNames[ NameType ] = NULL ;
                }

                if (dwError != NO_ERROR)
                {
                    RtlLeaveCriticalSection(&LogonSessionListLock);

                    //
                    // DsGetDcName doesn't set the last error.  Set it now along
                    // with the last status value (first SetLastError sets the
                    // status value via RtlNtStatusToDosError).
                    //

                    SetLastError(RtlNtStatusToDosError(STATUS_UNSUCCESSFUL));
                    SetLastError(dwError);

                    return NtCurrentTeb()->LastStatusValue;
                }

                if (!(pDcInfo->Flags & DS_DS_FLAG))
                {
                    //
                    // NT4 DC
                    //

                    RtlLeaveCriticalSection(&LogonSessionListLock);
                    NetApiBufferFree(pDcInfo);
                    return STATUS_NONE_MAPPED;
                }

                NetApiBufferFree(pDcInfo);
            }
        }


        //
        // Since NameDnsDomain is a GetUserNameEx construct, calling
        // the DS for it will directly will fail.  Ask the DS for the
        // canonical name and on success, extract the DNS name below.
        //

        NeedDnsDomainName = TRUE;

        NameType = NameCanonical;

        //
        // If the canonical name is already there, we don't
        // need to hit the DS below.
        //

        if (LogonSession->DsNames[NameType])
        {
            Status = LsapCreateDnsNameFromCanonicalName(LogonSession, NameType, Map);

            RtlLeaveCriticalSection(&LogonSessionListLock);
            return Status;
        }

        //
        // We may have the CanonicalEx name and not Canonical -- try that one too.
        //

        NameType = NameCanonicalEx;

        if (LogonSession->DsNames[NameType])
        {
            Status = LsapCreateDnsNameFromCanonicalName(LogonSession, NameType, Map);

            RtlLeaveCriticalSection(&LogonSessionListLock);
            return Status;
        }

        //
        // Otherwise fall through and hit the DS for the canonical name if allowed
        //

        if (LocalOnly)
        {
            RtlLeaveCriticalSection( &LogonSessionListLock );
            return STATUS_NONE_MAPPED;
        }
    }

    RtlLeaveCriticalSection( &LogonSessionListLock );

    if (LocalOnly)
    {
        //
        // We got this far and the name's not yet mapped.  Since we
        // can't hit the network, fail.
        //

        return STATUS_NONE_MAPPED;
    }

    if (!GotComputerName)
    {
        TranslatedNameLength = MAX_PATH ;
        TranslatedName = TranslatedNameBuffer ;
        GetComputerNameW( TranslatedName, &TranslatedNameLength );
        RtlInitUnicodeString( &TransName, TranslatedName );
    }

    if ( RtlEqualUnicodeString( &LogonSession->AuthorityName,
                                &TransName,
                                TRUE ) )
    {
        //
        // Local Logons don't get mapped names.
        //

        return STATUS_NONE_MAPPED ;
    }

    //
    // Make sure AuthorityName and SamMapName are NULL-terminated.
    // Create dynamically allocated copies if necessary.
    //

    if ( LogonSession->AuthorityName.MaximumLength <= LogonSession->AuthorityName.Length ||
         LogonSession->AuthorityName.Buffer[LogonSession->AuthorityName.Length / sizeof(WCHAR)] != L'\0' ) {

        AuthorityName = ( WCHAR * )LsapAllocatePrivateHeap( LogonSession->AuthorityName.Length + sizeof( WCHAR ));

        if ( AuthorityName == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory( AuthorityName, LogonSession->AuthorityName.Buffer, LogonSession->AuthorityName.Length );
        AuthorityName[LogonSession->AuthorityName.Length / sizeof( WCHAR )] = L'\0';

    } else {

        AuthorityName = LogonSession->AuthorityName.Buffer;
    }

    if ( SamMap->Name.MaximumLength <= SamMap->Name.Length ||
         SamMap->Name.Buffer[SamMap->Name.Length / sizeof(WCHAR)] != L'\0' ) {

        SamMapName = ( WCHAR * )LsapAllocatePrivateHeap( SamMap->Name.Length + sizeof( WCHAR ));

        if ( SamMapName == NULL ) {

            if ( AuthorityName != LogonSession->AuthorityName.Buffer ) {

                LsapFreePrivateHeap( AuthorityName );
            }

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory( SamMapName, SamMap->Name.Buffer, SamMap->Name.Length );
        SamMapName[SamMap->Name.Length / sizeof( WCHAR )] = L'\0';

    } else {

        SamMapName = SamMap->Name.Buffer;
    }

    //
    // We are going to be hitting the wire; if this is a special
    // known format, then optimize by calling DsCrackName to return
    // the other popular formats.  The cache will be seeded with
    // the results and hence avoid calls in the future.  This is
    // done to improve logon performance.
    //
    if ( LsapIsNameFormatUsedForLogon( NameType ) ) {

        Status = LsapGetFormatsForLogon( LogonSession,
                                         AuthorityName,
                                         SamMapName,
                                         NameType,
                                         Map );

        if ( NT_SUCCESS( Status ) ) {

            // we are done!
            goto Exit;

        } else {

            // Ok -- go the slow way
            Status = STATUS_SUCCESS;
        }

    }

Retry:

    //
    // Translate the name, in the caller's context
    //

    if ( NeedToImpersonate ) {

        Status = LsapImpersonateClient();

        if ( !NT_SUCCESS(Status) ) {
            goto Exit;
        }
    }

    TranslatedNameLength = MAX_PATH ;

    TranslatedName = TranslatedNameBuffer ;

    TranslateStatus = SecpTranslateName(
            AuthorityName,
            SamMapName,
            NameSamCompatible,
            (EXTENDED_NAME_FORMAT) NameType,
            TranslatedName,
            &TranslatedNameLength );

    if ( !TranslateStatus )
    {
        Status = NtCurrentTeb()->LastStatusValue ;

        if ( Status == STATUS_BUFFER_TOO_SMALL )
        {
            TranslatedName = (PWSTR) LsapAllocatePrivateHeap( TranslatedNameLength * sizeof( WCHAR ) );

            if ( TranslatedName )
            {
                TranslateStatus = SecpTranslateName(
                        AuthorityName,
                        SamMapName,
                        NameSamCompatible,
                        (EXTENDED_NAME_FORMAT) NameType,
                        TranslatedName,
                        &TranslatedNameLength );

            }

        } else if ( NeedToImpersonate &&
                    NtCurrentTeb()->LastErrorValue == ERROR_ACCESS_DENIED ) {

            //
            // Fall back to machine creds and try again
            //

            RevertToSelf();
            NeedToImpersonate = FALSE;
            goto Retry;
        }
    }

    if ( NeedToImpersonate ) {

        RevertToSelf();
    }

    if ( TranslateStatus )
    {
        RtlEnterCriticalSection( &LogonSessionListLock );

        if ( LogonSession->DsNames[ NameType ] )
        {
            //
            // Someone else filled it in while we were out cracking
            // it as well.  Use theirs, discard ours:
            //


            NameMap = LogonSession->DsNames[ NameType ];

            NameMap->RefCount++ ;

            RtlLeaveCriticalSection( &LogonSessionListLock );

            *Map = NameMap ;

            if ( TranslatedName != TranslatedNameBuffer )
            {
                LsapFreePrivateHeap( TranslatedName );
            }

            Status = STATUS_SUCCESS;

            goto Exit;
        }

        //
        // SecpTranslateName returns length including the terminating NULL,
        // so correct for that here
        //

        TransName.Buffer = TranslatedName ;
        TransName.Length = (USHORT) (( TranslatedNameLength - 1 ) * sizeof(WCHAR));
        TransName.MaximumLength = TransName.Length + sizeof( WCHAR );

        NameMap = LsapCreateDsNameMap(
                        &TransName,
                        NameType );

        if ( NameMap )
        {
            LogonSession->DsNames[ NameType ] = NameMap ;

            NameMap->RefCount++ ;

            RtlLeaveCriticalSection( &LogonSessionListLock );

            *Map = NameMap ;

            if ( TranslatedName != TranslatedNameBuffer )
            {
                LsapFreePrivateHeap( TranslatedName );
            }

            Status = STATUS_SUCCESS;

            goto Exit;
        }
        else
        {
            RtlLeaveCriticalSection( &LogonSessionListLock );

            Status = STATUS_NO_MEMORY ;
        }
    }
    else
    {
        Status = NtCurrentTeb()->LastStatusValue ;
    }

    //
    // If the DS couldn't map the UPN (e.g., the account has a default UPN), we can
    // still potentially cruft up a UPN using <SAM account name>@<DNS domain name>
    //

    if (Status == STATUS_NONE_MAPPED && NameType == NameUserPrincipal)
    {
        RtlEnterCriticalSection( &LogonSessionListLock );

        PLSAP_DS_NAME_MAP UsernameMap = LogonSession->DsNames[NameSamCompatible];
        PLSAP_DS_NAME_MAP DnsNameMap  = LogonSession->DsNames[NameDnsDomain];

        if (UsernameMap != NULL && DnsNameMap != NULL)
        {
            UsernameMap->RefCount++;
            DnsNameMap->RefCount++;

            RtlLeaveCriticalSection( &LogonSessionListLock );

            LPWSTR Upn;
            LPWSTR Scan = wcschr(UsernameMap->Name.Buffer, L'\\');
            ULONG  Index;

            if (Scan != NULL)
            {
                Scan++;
            }
            else
            {
                Scan = UsernameMap->Name.Buffer;
            }

            //
            // SAM name is always NULL-terminated
            //

            Index = wcslen(Scan);

            Upn = (LPWSTR) LsapAllocatePrivateHeap(Index * sizeof(WCHAR)
                                                    + DnsNameMap->Name.Length
                                                    + 2 * sizeof(WCHAR));

            if (Upn != NULL)
            {
                UNICODE_STRING  String;

                wcsncpy(Upn, Scan, Index);
                Upn[Index++] = L'@';
                RtlCopyMemory(Upn + Index, DnsNameMap->Name.Buffer, DnsNameMap->Name.Length);

                LsapDerefDsNameMap(UsernameMap);
                LsapDerefDsNameMap(DnsNameMap);

                RtlInitUnicodeString(&String, Upn);

                *Map = LsapCreateDsNameMap(&String, NameType);

                Status = (*Map == NULL ? STATUS_NO_MEMORY : STATUS_SUCCESS);

                LsapFreePrivateHeap(Upn);
            }
            else
            {
                LsapDerefDsNameMap(UsernameMap);
                LsapDerefDsNameMap(DnsNameMap);
                Status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            RtlLeaveCriticalSection( &LogonSessionListLock );
        }
    }

    if ( TranslatedName != TranslatedNameBuffer )
    {
        LsapFreePrivateHeap( TranslatedName );
    }

Exit:

    if (NeedDnsDomainName && NT_SUCCESS(Status))
    {
        //
        // We successfully retrieved the canonical name but what we really
        // want is the DnsDomainName -- extract it and add it to the session.
        //

        RtlEnterCriticalSection( &LogonSessionListLock );

        //
        // Another thread may have cracked the name before we got here.
        //

        NameMap = LogonSession->DsNames[ NameDnsDomain ];

        if ( NameMap )
        {
            if ( ( NameMap->ExpirationTime.QuadPart >= Now.QuadPart ) &&
                 ( !Flush ) )
            {
                //
                // Valid entry, bump the ref count and return it
                //

                NameMap->RefCount++ ;
                *Map = NameMap ;

                NeedDnsDomainName = FALSE ;
                Status = STATUS_SUCCESS;
            }
            else
            {
                //
                // Entry has expired.  Remove it, crack the name anew
                //

                LsapDerefDsNameMap( NameMap );

                LogonSession->DsNames[ NameDnsDomain ] = NULL ;
            }
        }

        if (NeedDnsDomainName)
        {
            Status = LsapCreateDnsNameFromCanonicalName(LogonSession, NameType, Map);

            //
            // Since we just successfully created the canonical name map, its refcount
            // has been bumped up.  Undo that since we're really after the DnsDomainName
            // (whose refcount was bumped up in LsapCreateDnsNameFromCanonicalName).
            //

            LogonSession->DsNames[NameType]->RefCount--;
        }

        RtlLeaveCriticalSection( &LogonSessionListLock );

        NameType = NameDnsDomain;
    }

    if ( AuthorityName != LogonSession->AuthorityName.Buffer )
    {
        LsapFreePrivateHeap( AuthorityName );
    }

    if ( SamMap != NULL &&
         SamMapName != SamMap->Name.Buffer )
    {
        LsapFreePrivateHeap( SamMapName );
    }

    return Status ;

}

NTSTATUS
WLsaEnumerateLogonSession(
    PULONG Count,
    PLUID * Sessions
    )
{
    PLUID Logons ;
    PVOID LocalCopy ;
    PLIST_ENTRY Scan ;
    PLSAP_LOGON_SESSION LogonSession ;
    PVOID ClientMemory ;
    NTSTATUS Status ;

    RtlEnterCriticalSection( &LogonSessionListLock );

    Logons = (PLUID) LsapAllocatePrivateHeap( LogonSessionCount * sizeof( LUID ) );

    if ( !Logons )
    {
        RtlLeaveCriticalSection( &LogonSessionListLock );

        return STATUS_NO_MEMORY ;
    }

    *Count = LogonSessionCount ;

    LocalCopy = Logons ;

    Scan = LogonSessionList.Flink ;

    while ( Scan != &LogonSessionList )
    {
        LogonSession = CONTAINING_RECORD( Scan, LSAP_LOGON_SESSION, List );

        *Logons++ = LogonSession->LogonId ;

        Scan = Scan->Flink ;
    }

    RtlLeaveCriticalSection( &LogonSessionListLock );

    ClientMemory = LsapClientAllocate( *Count * sizeof( LUID ) );

    if ( ClientMemory )
    {
        Status = LsapCopyToClient( LocalCopy,
                                   ClientMemory,
                                   *Count * sizeof( LUID ) );

        *Sessions = (PLUID) ClientMemory ;
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    LsapFreePrivateHeap( LocalCopy );

    return Status ;

}


NTSTATUS
LsaIGetNbAndDnsDomainNames(
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING NetbiosDomainName
    )

/*++

Routine Description:

    Get both the Netbios name and DNS name of a domain.  DomainName must correspond to
    the account domain of some user that is currently logged onto the system.

Arguments:

    DomainName - Name of the Netbios or DNS domain to query.

    DnsDomainName - Returns the DnsDomainName of the domain if DomainName is trusted.
        DnsDomainName->Buffer will be zero terminated.
        DnsDomainName->Buffer must be freed using LsaIFreeHeap.

    NetbiosDomainName - Returns the Netbios domain name of the domain if DomainName is trusted.
        NetbiosDomainName->Buffer will be zero terminated.
        NetbiosDomainName->Buffer must be freed using LsaIFreeHeap.

Return Value:

    STATUS_SUCCESS: The routine functioned properly.
        DnsDomainName->Buffer and NetbiosDomainName->Buffer will return null if
        the mapping isn't known.

--*/
{
    PLUID Logons ;
    PVOID LocalCopy ;
    PLIST_ENTRY Scan ;
    PLSAP_LOGON_SESSION LogonSession ;
    PVOID ClientMemory ;
    NTSTATUS Status ;

    PUNICODE_STRING LocalDnsDomainName;

    //
    // Initialization
    //

    RtlInitUnicodeString( DnsDomainName, NULL );
    RtlInitUnicodeString( NetbiosDomainName, NULL );


    //
    // Loop through the logon session list trying to find a match
    //

    Status = STATUS_SUCCESS;

    RtlEnterCriticalSection( &LogonSessionListLock );
    for ( Scan = LogonSessionList.Flink; Scan != &LogonSessionList; Scan = Scan->Flink ) {

        LogonSession = CONTAINING_RECORD( Scan, LSAP_LOGON_SESSION, List );

        //
        // Ignore this entry unless both names are known
        //

        if (LogonSession->DsNames[NameDnsDomain] == NULL)
        {
            continue;
        }

        LocalDnsDomainName = &LogonSession->DsNames[NameDnsDomain]->Name;

        if ( LocalDnsDomainName->Length == 0 ||
             LogonSession->AuthorityName.Length == 0 )
        {
            continue;
        }


        //
        // Compare the passed in name with the Netbios and DNS name on the entry
        //

        if ( (DomainName->Length == LogonSession->AuthorityName.Length &&
              RtlEqualUnicodeString( DomainName,
                                     &LogonSession->AuthorityName,
                                     TRUE ) ) ||
             (DomainName->Length == LocalDnsDomainName->Length &&
              RtlEqualUnicodeString( DomainName,
                                     LocalDnsDomainName,
                                     TRUE ) ) ) {


            //
            // Grab the Dns domain name
            //

            DnsDomainName->Buffer = (LPWSTR) LsapAllocatePrivateHeapNoZero(
                                            LocalDnsDomainName->Length +
                                            sizeof(WCHAR) );

            if ( DnsDomainName->Buffer == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlCopyMemory( DnsDomainName->Buffer,
                           LocalDnsDomainName->Buffer,
                           LocalDnsDomainName->Length );

            DnsDomainName->Buffer[LocalDnsDomainName->Length/sizeof(WCHAR)] = L'\0';
            DnsDomainName->Length = LocalDnsDomainName->Length;
            DnsDomainName->MaximumLength = LocalDnsDomainName->Length + sizeof(WCHAR);


            //
            // Grab the netbios domain name
            //

            NetbiosDomainName->Buffer = (LPWSTR) LsapAllocatePrivateHeapNoZero(
                                            LogonSession->AuthorityName.Length +
                                            sizeof(WCHAR) );

            if ( NetbiosDomainName->Buffer == NULL ) {
                LsapFreePrivateHeap( DnsDomainName->Buffer );
                DnsDomainName->Buffer = NULL;

                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlCopyMemory( NetbiosDomainName->Buffer,
                           LogonSession->AuthorityName.Buffer,
                           LogonSession->AuthorityName.Length );
            NetbiosDomainName->Buffer[LogonSession->AuthorityName.Length/sizeof(WCHAR)] = L'\0';
            NetbiosDomainName->Length = LogonSession->AuthorityName.Length;
            NetbiosDomainName->MaximumLength = LogonSession->AuthorityName.Length + sizeof(WCHAR);

            Status = STATUS_SUCCESS;
            break;

        }
    }

    RtlLeaveCriticalSection( &LogonSessionListLock );

    return Status;

}

NTSTATUS
WLsaGetLogonSessionData(
    PLUID LogonId,
    PVOID * LogonData
    )
{
    PLSAP_LOGON_SESSION LogonSession;
    ULONG Size ;
    PVOID ClientBuffer ;
    PUCHAR Offset ;
    PUCHAR LocalOffset ;
    NTSTATUS Status ;
    PSECURITY_LOGON_SESSION_DATA Data = NULL;
    PLSAP_SECURITY_PACKAGE Package ;
    HANDLE Token ;
    BOOL OkayToQuery = FALSE ;
    PLSAP_DS_NAME_MAP DnsMap = NULL;
    PLSAP_DS_NAME_MAP UpnMap = NULL;

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( !LogonSession )
    {
        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    Status = LsapImpersonateClient();

    if ( NT_SUCCESS( Status ) )
    {
        if ( LogonSession->UserSid == NULL ||
             !CheckTokenMembership( NULL,
                                    LogonSession->UserSid,
                                    &OkayToQuery ) )
        {
            OkayToQuery = FALSE ;
        }

        if ( !OkayToQuery )
        {
            if ( !CheckTokenMembership( NULL,
                                        LsapAliasAdminsSid,
                                        &OkayToQuery ) )
            {
                OkayToQuery = FALSE ;
            }
        }

        RevertToSelf();
    }

    if ( !OkayToQuery )
    {
        Status = STATUS_ACCESS_DENIED ;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        LsapReleaseLogonSession( LogonSession );

        return Status ;
    }

    Package = SpmpLocatePackage( LogonSession->CreatingPackage );

    if ( !Package )
    {
        LsapReleaseLogonSession( LogonSession );

        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    RtlEnterCriticalSection( &LogonSessionListLock );

    UpnMap = LogonSession->DsNames[NameUserPrincipal];

    if (UpnMap != NULL)
    {
        UpnMap->RefCount++;
    }

    DnsMap = LogonSession->DsNames[NameDnsDomain];

    if (DnsMap != NULL)
    {
        DnsMap->RefCount++;
    }

    RtlLeaveCriticalSection( &LogonSessionListLock );

    Size = sizeof( SECURITY_LOGON_SESSION_DATA ) +
            LogonSession->AccountName.Length + sizeof( WCHAR ) +
            LogonSession->AuthorityName.Length + sizeof( WCHAR ) +
            Package->Name.Length + sizeof( WCHAR ) +
            LogonSession->LogonServer.Length + sizeof(WCHAR) +
            sizeof(WCHAR) + // DnsMap
            sizeof(WCHAR) ; // UpnMap

    if( DnsMap != NULL )
    {
        Size += DnsMap->Name.Length;
    }

    if( UpnMap != NULL )
    {
        Size += UpnMap->Name.Length;
    }

    if ( LogonSession->UserSid )
    {
        Size += RtlLengthSid( LogonSession->UserSid );
    }

    Data = (PSECURITY_LOGON_SESSION_DATA) LsapAllocatePrivateHeap( Size );

    if ( !Data )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    ClientBuffer = LsapClientAllocate( Size );

    if ( !ClientBuffer )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    Offset = (PUCHAR) ClientBuffer + sizeof( SECURITY_LOGON_SESSION_DATA );
    LocalOffset = (PUCHAR) ( Data + 1 );

    Data->Size = sizeof( SECURITY_LOGON_SESSION_DATA );
    Data->LogonId = LogonSession->LogonId ;
    Data->LogonType = (ULONG) LogonSession->LogonType ;
    Data->Session = LogonSession->Session ;
    Data->LogonTime = LogonSession->LogonTime ;

    //
    // do the UserSid first since it needs to be 4-byte aligned
    //

    if ( LogonSession->UserSid )
    {
        ULONG  ulSidLength = RtlLengthSid( LogonSession->UserSid );

        Data->Sid = (PSID) Offset ;

        RtlCopyMemory(  LocalOffset,
                        LogonSession->UserSid,
                        ulSidLength );

        Offset += ulSidLength;
        LocalOffset += ulSidLength;
    }
    else
    {
        Data->Sid = (PSID) NULL ;
    }


    Data->UserName.Length = LogonSession->AccountName.Length ;
    Data->UserName.MaximumLength = Data->UserName.Length + sizeof( WCHAR );
    Data->UserName.Buffer = (PWSTR) Offset ;

    RtlCopyMemory(  LocalOffset,
                    LogonSession->AccountName.Buffer,
                    LogonSession->AccountName.Length );

    LocalOffset += LogonSession->AccountName.Length ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->UserName.MaximumLength ;

    Data->LogonDomain.Length = LogonSession->AuthorityName.Length ;
    Data->LogonDomain.MaximumLength = Data->LogonDomain.Length + sizeof( WCHAR );
    Data->LogonDomain.Buffer = (PWSTR) Offset ;

    RtlCopyMemory( LocalOffset,
                   LogonSession->AuthorityName.Buffer,
                   LogonSession->AuthorityName.Length );

    LocalOffset += LogonSession->AuthorityName.Length ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->LogonDomain.MaximumLength ;

    Data->AuthenticationPackage.Length = Package->Name.Length ;
    Data->AuthenticationPackage.MaximumLength = Data->AuthenticationPackage.Length + sizeof( WCHAR );
    Data->AuthenticationPackage.Buffer = (PWSTR) Offset ;

    RtlCopyMemory(  LocalOffset,
                    Package->Name.Buffer,
                    Package->Name.Length );

    LocalOffset += Package->Name.Length ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->AuthenticationPackage.MaximumLength ;

    //
    // do the LogonServer
    //

    Data->LogonServer.Length = LogonSession->LogonServer.Length ;
    Data->LogonServer.MaximumLength = Data->LogonServer.Length + sizeof( WCHAR );
    Data->LogonServer.Buffer = (PWSTR) Offset ;

    RtlCopyMemory(  LocalOffset,
                    LogonSession->LogonServer.Buffer,
                    LogonSession->LogonServer.Length );

    LocalOffset += LogonSession->LogonServer.Length ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->LogonServer.MaximumLength ;


    //
    // do the DnsDomainName
    //

    if (DnsMap != NULL)
    {
        Data->DnsDomainName.Length = DnsMap->Name.Length;
        Data->DnsDomainName.MaximumLength = Data->DnsDomainName.Length + sizeof( WCHAR );
        Data->DnsDomainName.Buffer = (PWSTR) Offset ;

        RtlCopyMemory(  LocalOffset,
                        DnsMap->Name.Buffer,
                        DnsMap->Name.Length );

        LocalOffset += DnsMap->Name.Length ;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';

        Offset += Data->DnsDomainName.MaximumLength ;
    }
    else
    {
        Data->DnsDomainName.Length = Data->DnsDomainName.MaximumLength = 0;
        Data->DnsDomainName.Buffer = (PWSTR) Offset;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';
    }


    //
    // do the Upn
    //

    if (UpnMap != NULL)
    {
        Data->Upn.Length = UpnMap->Name.Length ;
        Data->Upn.MaximumLength = Data->Upn.Length + sizeof( WCHAR );
        Data->Upn.Buffer = (PWSTR) Offset ;

        RtlCopyMemory(  LocalOffset,
                        UpnMap->Name.Buffer,
                        UpnMap->Name.Length );

        LocalOffset += UpnMap->Name.Length ;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';

        Offset += Data->Upn.MaximumLength ;
    }
    else
    {
        Data->Upn.Length = Data->Upn.MaximumLength = 0;
        Data->Upn.Buffer = (PWSTR) Offset;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';

    }

    Status = LsapCopyToClient( Data,
                               ClientBuffer,
                               Size );

    *LogonData = ClientBuffer ;

Cleanup:

    if (DnsMap != NULL)
    {
        LsapDerefDsNameMap(DnsMap);
    }

    if (UpnMap != NULL)
    {
        LsapDerefDsNameMap(UpnMap);
    }

    LsapReleaseLogonSession( LogonSession );

    if( Data != NULL )
    {
        LsapFreePrivateHeap( Data );
    }

    return Status ;
}


NTSTATUS
LsapGetFormatsForLogon(
    IN PLSAP_LOGON_SESSION LogonSession,
    IN LPWSTR Domain,
    IN LPWSTR Name,
    IN ULONG  DesiredNameType,
    OUT PLSAP_DS_NAME_MAP * Map
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR   *TranslatedNames = NULL;
    BOOL TranslateStatus;
    PLSAP_DS_NAME_MAP NameMap;
    UNICODE_STRING TransName;
    ULONG i;
    BOOLEAN NeedToImpersonate = TRUE;

Retry:

    if ( NeedToImpersonate ) {

        Status = LsapImpersonateClient();

        if ( !NT_SUCCESS(Status) &&
             ( Status != STATUS_BAD_IMPERSONATION_LEVEL ) ) {

            return Status;
        }
    }

    //
    // If the client thread is using an identify or anonymous level token,
    // do the translation in system context.
    //

    TranslateStatus = SecpTranslateNameEx( Domain,
                                           Name,
                                           NameSamCompatible,
                                           (EXTENDED_NAME_FORMAT*) LogonFormats,
                                           sizeof(LogonFormats)/sizeof(LogonFormats[0]),
                                          &TranslatedNames );

    //
    // If we successfully impersonated above, revert now.
    //

    if ( NT_SUCCESS( Status ) && NeedToImpersonate )
    {
        RevertToSelf();
    }

    if ( !TranslateStatus ) {

        if ( NeedToImpersonate &&
             NtCurrentTeb()->LastErrorValue == ERROR_ACCESS_DENIED ) {

            //
            // Fall back to machine creds and try again
            //

            NeedToImpersonate = FALSE;
            goto Retry;
        }

        Status = STATUS_UNSUCCESSFUL;

    } else {

        ULONG i;

        RtlEnterCriticalSection( &LogonSessionListLock );

        for (i = 0; i < sizeof(LogonFormats)/sizeof(LogonFormats[0]); i++ ) {

            ULONG NameFormat = LogonFormats[i];

            if ( LogonSession->DsNames[ NameFormat ] ) {

                //
                // Someone else filled it in while we were out cracking
                // it as well.  Use theirs, discard ours:
                //
                NameMap = LogonSession->DsNames[ NameFormat ];

            } else {

                //
                // Still no entry -- create one
                //
                TransName.Buffer = TranslatedNames[i] ;
                TransName.Length = (USHORT) (wcslen(TranslatedNames[i]) * sizeof(WCHAR));
                TransName.MaximumLength = TransName.Length + sizeof( WCHAR );

                NameMap = LsapCreateDsNameMap(
                                &TransName,
                                NameFormat );

                if ( NameMap )
                {
                    LogonSession->DsNames[ NameFormat ] = NameMap ;
                }
                else
                {
                    RtlLeaveCriticalSection( &LogonSessionListLock );

                    Status = STATUS_NO_MEMORY ;

                    goto Exit;
                }
            }

            if ( NameFormat == DesiredNameType ) {

                NameMap->RefCount++ ;

                *Map = NameMap ;
            }
        }

        //
        // Should have found a match
        //
        ASSERT( *Map );

        RtlLeaveCriticalSection( &LogonSessionListLock );

    }

Exit:

    if ( TranslatedNames ) {

        for ( i = 0; i < sizeof(LogonFormats)/sizeof(LogonFormats[0]); i++ ) {
            if ( TranslatedNames[i] ) {

                SecpFreeMemory( TranslatedNames[i] );
            }
        }
        SecpFreeMemory( TranslatedNames );
    }

    return Status;
}

NTSTATUS
LsapSetSessionToken(
    IN HANDLE InputTokenHandle,
    IN PLUID LogonId
    )
/*++

Routine Description:

    This routine duplicates the InputTokenHandle and sets that duplicated handle on the
    LogonSession identified by the LogonId.

    The duplicated handle is available for subsequent callers of LsapOpenTokenByLogonId.

Arguments:

    InputTokenHandle - A handle to a token for the logon session

    LogonId - The logon id of the session

Return Values:

    Status of the operation.


--*/
{
    NTSTATUS Status;

    OBJECT_ATTRIBUTES ObjAttrs;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;

    HANDLE TokenHandle = NULL;
    ULONG TokenIsReferenced;
    ULONG StatsSize ;
    TOKEN_STATISTICS TokenStats ;

    PLSAP_LOGON_SESSION LogonSession = NULL;

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        ASSERT( LogonSession != NULL );
        // This isn't fatal.
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Ensure there isn't already a token for this session.
    //

    if ( LogonSession->TokenHandle != NULL ) {
        // This can happen for "local service" and "network service"
        // This isn't fatal.
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Duplicate the token
    //

    Status = NtQueryInformationToken(
                   InputTokenHandle,
                   TokenStatistics,
                   &TokenStats,
                   sizeof( TokenStats ),
                   &StatsSize );

    if ( !NT_SUCCESS( Status ) ) {
        // This isn't fatal.
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }


    //
    // if primary token handed in (eg: system process), over-ride to SecurityImpersonation from SecurityAnonymous
    //
    if(TokenStats.TokenType == TokenPrimary)
    {
        TokenStats.ImpersonationLevel = SecurityImpersonation;
    }


    InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
    SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    SecurityQofS.ImpersonationLevel = min( SecurityImpersonation, TokenStats.ImpersonationLevel );
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;
    ObjAttrs.SecurityQualityOfService = &SecurityQofS;

    Status = NtDuplicateToken( InputTokenHandle,
                               TOKEN_ALL_ACCESS,
                               &ObjAttrs,
                               FALSE,
                               TokenImpersonation,
                               &TokenHandle );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Make this token not reference the logon session.
    //  (Otherwise, the existence of this token reference would prevent the reference monitor
    //  from detecting the last reference to the logon session.)
    //

    TokenIsReferenced = FALSE;

    Status = NtSetInformationToken( TokenHandle,
                                    TokenSessionReference,
                                    &TokenIsReferenced,
                                    sizeof(TokenIsReferenced) );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if( InterlockedCompareExchangePointer(
                        &LogonSession->TokenHandle,
                        TokenHandle,
                        NULL
                        ) == NULL)
    {
        //
        // if the value was NULL initially, then we updated it with the new token
        // set the new token NULL so we don't free it.
        //

        TokenHandle = NULL;
    }

    Status = STATUS_SUCCESS;


Cleanup:
    if ( TokenHandle != NULL ) {
        NtClose( TokenHandle );
    }
    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return Status;
}

NTSTATUS
LsapOpenTokenByLogonId(
    IN PLUID LogonId,
    OUT HANDLE *RetTokenHandle
    )
/*++

Routine Description:

    This routine open a token by LogonId.  It is only valid for LogonIds where all of the
    following are true:

    * A logon session has been create via LsapCreateLogonSession, AND
    * A token has been created via LsapCreateToken or by the LSA after an authentication package
    returns successfully from LsaApLogonUser(Ex)(2).

Arguments:

    LogonId - The logon id of the session

    RetTokenHandle - Returns a handle to the token.  The token is an impersonation token,
        is granted TOKEN_ALL_ACCESS, and should be closed via NtClose.


Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

    STATUS_NO_TOKEN - There is no token for this logon session.


--*/
{
    NTSTATUS Status;

    OBJECT_ATTRIBUTES ObjAttrs;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;

    HANDLE TokenHandle = NULL;

    PLSAP_LOGON_SESSION LogonSession = NULL;

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        // ASSERT( LogonSession != NULL );

        //
        // If this is the anonymous logon id,
        //  create a token.
        //

        if ( RtlEqualLuid( LogonId,
                           &LsapAnonymousLogonId ) ) {

            LSA_TOKEN_INFORMATION_NULL VNull;
            TOKEN_SOURCE NullTokenSource = {"*LAnon*", 0};
            HANDLE ImpersonatedToken = NULL;

            VNull.Groups = NULL;

            VNull.ExpirationTime.HighPart = 0x7FFFFFFF;
            VNull.ExpirationTime.LowPart = 0xFFFFFFFF;

            //
            // insure we aren't impersonating a client when we try to create the token
            // this is relevant for inproc security package consumers.
            // BLACKCOMBE: Duplicate a cached anonymous token instead.
            //

            Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                            TRUE,
                            &ImpersonatedToken
                            );
            if (!NT_SUCCESS(Status))
            {
                if (Status != STATUS_NO_TOKEN)
                {
                    goto Cleanup;
                }
                
                ImpersonatedToken = NULL ;
            }

            Status = LsapCreateNullToken( LogonId,
                                          &NullTokenSource,
                                          &VNull,
                                          RetTokenHandle );

            if( ImpersonatedToken )
            {
                NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                &ImpersonatedToken,
                                sizeof(HANDLE)
                                );
            }

            goto Cleanup;
        }

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Ensure there is a token for this session.
    //

    RtlEnterCriticalSection( &LogonSessionListLock );
    if ( LogonSession->TokenHandle == NULL ) {
        RtlLeaveCriticalSection( &LogonSessionListLock );
        Status = STATUS_NO_TOKEN;
        goto Cleanup;
    }

    //
    // Duplicate the token
    //

    InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
    SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;
    ObjAttrs.SecurityQualityOfService = &SecurityQofS;

    Status = NtDuplicateToken( LogonSession->TokenHandle,
                               TOKEN_ALL_ACCESS,
                               &ObjAttrs,
                               FALSE,
                               TokenImpersonation,
                               &TokenHandle );

    if ( !NT_SUCCESS(Status) ) {
        RtlLeaveCriticalSection( &LogonSessionListLock );
        goto Cleanup;
    }


    *RetTokenHandle = TokenHandle;
    TokenHandle = NULL;
    RtlLeaveCriticalSection( &LogonSessionListLock );

    Status = STATUS_SUCCESS;


Cleanup:
    if ( TokenHandle != NULL ) {
        NtClose( TokenHandle );
    }
    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return Status;
}

NTSTATUS
LsapDomainRenameHandlerForLogonSessions(
    IN PUNICODE_STRING OldNetbiosName,
    IN PUNICODE_STRING OldDnsName,
    IN PUNICODE_STRING NewNetbiosName,
    IN PUNICODE_STRING NewDnsName
    )
/*++

Routine Description:

    Walks the logon sessions list and renames the logon sessions with the given
    new netbios and DNS domain names

Arguments:

    OldNetbiosName      old netbios name of the domain
    OldDnsName          old DNS name of the domain
    NewNetbiosName      new netbios name of the domain
    NewDnsName          new DNS name of the domain

Returns:

    STATUS_ error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT( OldNetbiosName );
    ASSERT( OldDnsName );
    ASSERT( NewNetbiosName );
    ASSERT( NewDnsName );

    RtlEnterCriticalSection( &LogonSessionListLock );

    for ( PLIST_ENTRY Scan = LogonSessionList.Flink;
          Scan != &LogonSessionList;
          Scan = Scan->Flink ) {

        UNICODE_STRING NetbiosName = {0};
        UNICODE_STRING DnsName = {0};
        PLSAP_LOGON_SESSION LogonSession = CONTAINING_RECORD( Scan, LSAP_LOGON_SESSION, List );
        PLSAP_DS_NAME_MAP SamMap = LogonSession->DsNames[ NameSamCompatible ];
        PLSAP_DS_NAME_MAP DnsMap = LogonSession->DsNames[ NameDnsDomain ];

        Status = STATUS_SUCCESS;

        if ( NT_SUCCESS( Status ) &&
             RtlEqualUnicodeString(
                 OldNetbiosName,
                 &LogonSession->AuthorityName,
                 TRUE )) {

            Status = LsapDuplicateString( // Use LsapAllocateLsaHeap
                         &NetbiosName,
                         NewNetbiosName
                         );
        }

        if ( NT_SUCCESS( Status ) &&
             DnsMap &&
             RtlEqualUnicodeString(
                 OldDnsName,
                 &DnsMap->Name,
                 TRUE )) {

            Status = LsapDuplicateString2( // Use LsapAllocatePrivateHeap
                         &DnsName,
                         NewDnsName
                         );
        }

        if ( !NT_SUCCESS( Status )) {

            LsapFreeLsaHeap( NetbiosName.Buffer );
            LsapFreePrivateHeap( DnsName.Buffer );
            break;
        }

        if ( NetbiosName.Buffer ) {

            LsapFreeLsaHeap( LogonSession->AuthorityName.Buffer );
            LogonSession->AuthorityName = NetbiosName;
        }

        if ( DnsMap && DnsName.Buffer )
        {
            LsapDerefDsNameMap(DnsMap);
            LogonSession->DsNames[NameDnsDomain] = LsapCreateDsNameMap(&DnsName, NameDnsDomain);
        }

        if ( SamMap &&
             SamMap->Name.Length > OldNetbiosName->Length &&
             0 == _wcsnicmp(
                      SamMap->Name.Buffer,
                      OldNetbiosName->Buffer,
                      OldNetbiosName->Length / sizeof( WCHAR )) &&
             SamMap->Name.Buffer[ OldNetbiosName->Length / sizeof( WCHAR )] == L'\\' ) {

            LsapDerefDsNameMap( SamMap );

            if ( FALSE == LsapSetSamAccountNameForLogonSession( LogonSession )) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }
    }

    RtlLeaveCriticalSection( &LogonSessionListLock );

    return Status;
}


NTSTATUS
LsapCreateDnsNameFromCanonicalName(
    IN  PLSAP_LOGON_SESSION LogonSession,
    IN  ULONG               NameType,
    OUT PLSAP_DS_NAME_MAP   * Map
    )
/*++

Routine Description:

    Internal routine used to extract the DnsDomainName given the canonical name

Arguments:

    LogonSession - The logon session in question

    Map - Pointer that receives the allocated/refcounted name map on success

Return Values:

    Status of the operation.

Notes:

    The LogonSessionListLock MUST be held when this routine is called

--*/
{
    PLSAP_DS_NAME_MAP CanonicalNameMap = LogonSession->DsNames[NameType];
    UNICODE_STRING    DnsDomainName;
    LPWSTR            lpSlash;
    USHORT            i;

    ASSERT(CanonicalNameMap != NULL);
    ASSERT(LogonSession->DsNames[NameDnsDomain] == NULL);

    //
    // Find the first forward slash in the canonical name.  No guarantees on
    // NULL-termination in a UNICODE_STRING.
    //

    lpSlash = NULL;

    for (i = 0; i < CanonicalNameMap->Name.Length; i++)
    {
        if (CanonicalNameMap->Name.Buffer[i] == L'/')
        {
            lpSlash = &CanonicalNameMap->Name.Buffer[i];
            break;
        }
    }

    if (lpSlash == NULL)
    {
        //
        // The canonical name is bad -- bail.
        //

        ASSERT(lpSlash != NULL);
        return STATUS_NONE_MAPPED;
    }

    RtlInitUnicodeString(&DnsDomainName, CanonicalNameMap->Name.Buffer);
    DnsDomainName.Length = (USHORT) (lpSlash - CanonicalNameMap->Name.Buffer) * sizeof(WCHAR);

    *Map = LsapCreateDsNameMap(&DnsDomainName, NameDnsDomain);

    if (*Map == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    LogonSession->DsNames[NameDnsDomain] = *Map;
    (*Map)->RefCount++;

    return STATUS_SUCCESS;
}


NTSTATUS
LsaIAddNameToLogonSession(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    )
/*++

Routine Description:

    Internal routine for the auth packages to call to add names to the cache in the
    logon session

Arguments:

    LogonId - The logon id of the session

    NameFormat - The EXTENDED_NAME_FORMAT for the name in question (from secext.h)

    Name - The name itself

Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

--*/
{
    PLSAP_LOGON_SESSION  LogonSession;
    PLSAP_DS_NAME_MAP    NameMap;
    BOOL                 fDeleteMap = FALSE;

    //
    // We trust the auth package to be passing in valid parameters
    // session so assert on all invalid parameter errors.
    //

    if (Name == NULL)
    {
        //
        // Package doesn't have this info -- ignore it
        //

        return STATUS_SUCCESS;
    }

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        ASSERT(LogonSession != NULL);
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    ASSERT(NameFormat < LSAP_MAX_DS_NAMES && NameFormat != NameSamCompatible);

    NameMap = LsapCreateDsNameMap(Name, NameFormat);

    if (NameMap == NULL)
    {
        LsapReleaseLogonSession(LogonSession);
        return STATUS_NO_MEMORY;
    }

    //
    // Update the logon session.
    //

    RtlEnterCriticalSection(&LogonSessionListLock);

    if (LogonSession->DsNames[NameFormat] == NULL)
    {
        LogonSession->DsNames[NameFormat] = NameMap;
    }
    else
    {
        //
        // Another thread beat us to it -- keep the name in the session
        //

        fDeleteMap = TRUE;
    }

    RtlLeaveCriticalSection(&LogonSessionListLock);

    if (fDeleteMap)
    {
        LsapDerefDsNameMap(NameMap);
    }

    LsapReleaseLogonSession(LogonSession);
    return STATUS_SUCCESS;
}

NTSTATUS
LsaISetLogonGuidInLogonSession(
    IN  PLUID  LogonId,
    IN  LPGUID LogonGuid
    )
/*++

Routine Description:

    Internal routine for the auth packages (currently only kerberos) 
    to set the logon GUID in the logon session

Arguments:

    LogonId   - The logon id of the session

    LogonGuid - The logon GUID of the session

Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

--*/
{
    PLSAP_LOGON_SESSION  LogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    GUID ZeroGuid = { 0 };
    
    //
    // We trust the auth package to be passing in valid parameters
    // session so assert on all invalid parameter errors.
    //

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Update the logon session.
    //

    Status = RtlEnterCriticalSection(&LogonSessionListLock);

    if ( NT_SUCCESS(Status) )
    {
        if ( LogonGuid )
        {
            RtlCopyMemory( &LogonSession->LogonGuid, LogonGuid, sizeof(GUID) );
        }
        else
        {
            RtlCopyMemory( &LogonSession->LogonGuid, &ZeroGuid, sizeof(GUID) );
        }
    
        RtlLeaveCriticalSection(&LogonSessionListLock);
    }
    

Cleanup:
    if ( LogonSession )
    {
        LsapReleaseLogonSession(LogonSession);
    }
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsasrvmm.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsasrvmm.h

Abstract:

    Local Security Authority - Main Include File for Lsa Server Memory
                               Management Routines.

Author:

    Scott Birrell       (ScottBi)      February 29, 1992

Environment:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Free List Routines and Definitions                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define LSAP_MM_MIDL                      ((ULONG)     0x00000001L)
#define LSAP_MM_HEAP                      ((ULONG)     0x00000002L)

//
// Options from LsapMmCleanupFreeList
//

#define LSAP_MM_FREE_BUFFERS              ((ULONG)     0x00000001L)

typedef struct _LSAP_MM_FREE_LIST_ENTRY {

    PVOID Buffer;
    ULONG Options;

} LSAP_MM_FREE_LIST_ENTRY, *PLSAP_MM_FREE_LIST_ENTRY;

typedef struct _LSAP_MM_FREE_LIST {

    ULONG UsedCount;
    ULONG MaxCount;
    PLSAP_MM_FREE_LIST_ENTRY Buffers;

} LSAP_MM_FREE_LIST, *PLSAP_MM_FREE_LIST;

#define LsapMmInitializeFreeListStatic( _list_, _buffer_ )                  \
(_list_)->UsedCount = 0;                                                    \
(_list_)->MaxCount = sizeof( _buffer_ ) / sizeof( LSAP_MM_FREE_LIST_ENTRY );\
(_list_)->Buffers = _buffer_;

NTSTATUS
LsapMmCreateFreeList(
    OUT PLSAP_MM_FREE_LIST FreeList,
    IN ULONG MaxEntries
    );

NTSTATUS
LsapMmAllocateMidl(
    IN PLSAP_MM_FREE_LIST FreeList,
    OUT PVOID *OutputBuffer,
    IN ULONG BufferLength
    );

VOID
LsapMmFreeLastEntry(
    IN PLSAP_MM_FREE_LIST FreeList
    );

VOID
LsapMmCleanupFreeList(
    IN PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Options
    );

NTSTATUS
LsapRpcCopyUnicodeString(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    );

NTSTATUS
LsapRpcCopyUnicodeStrings(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Count,
    OUT PUNICODE_STRING *DestinationStrings,
    IN PUNICODE_STRING SourceStrings
    );

NTSTATUS
LsapRpcCopySid(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PSID *DestinationSid,
    IN PSID SourceSid
    );

NTSTATUS
LsapRpcCopyTrustInformation(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUST_INFORMATION OutputTrustInformation,
    IN PLSAPR_TRUST_INFORMATION InputTrustInformation
    );

NTSTATUS
LsapRpcCopyTrustInformationEx(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX OutputTrustInformation,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX InputTrustInformation
    );

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Heap Routines                                                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOLEAN
LsapHeapInitialize(
    IN BOOLEAN Server
    );

PVOID
LsapAllocateLsaHeap (
    IN ULONG Length
    );

VOID
LsapFreeLsaHeap (
    IN PVOID Base
    );

PVOID
NTAPI
LsapAllocatePrivateHeap (
    IN SIZE_T Length
    );

PVOID
NTAPI
LsapAllocatePrivateHeapNoZero(
    IN SIZE_T cbMemory
    );

VOID
NTAPI
LsapFreePrivateHeap (
    IN PVOID Base
    );

#define LsapGetCurrentHeap()    ((HANDLE) TlsGetValue( dwThreadHeap ))
#define LsapSetCurrentHeap(x)   TlsSetValue( dwThreadHeap, x )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsastr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lsastr.c

Abstract:

    Common string operations.

Author:

    24-March-1999 kumarp

--*/

#include <lsapch2.h>

VOID
LsapTruncateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT TruncateToNumChars)
/*++

Routine Description:

    If a string is longer than TruncateToNumChars then truncate it
    to TruncateToNumChars.

Arguments:

    String - pointer to string

    TruncateToNumChars - number of chars to truncate to

Return Value:

    None

Notes:

    No memory (de)allocations are involved.

--*/
{
    USHORT TruncateToLength = TruncateToNumChars*sizeof(WCHAR);

    if (String->Length > TruncateToLength) {

        String->Length = TruncateToLength;
        String->Buffer[TruncateToNumChars] = UNICODE_NULL;
    }
}

BOOLEAN
LsapRemoveTrailingDot(
    IN OUT PUNICODE_STRING String,
    IN BOOLEAN AdjustLengthOnly)
/*++

Routine Description:

    If there is a '.' at the end of a string, remove it.

Arguments:

    String - pointer to unicode string

    AdjustLengthOnly - If TRUE only decrements the Length member of
        String otherwise replaces dot with UNICODE_NULL as well.

Return Value:

    TRUE if trailing dot was present, FALSE otherwise.

Notes:

--*/
{
    USHORT NumCharsInString;

    NumCharsInString = String->Length / sizeof(WCHAR);

    if (NumCharsInString &&
        (String->Buffer[NumCharsInString-1] == L'.')) {

        String->Length -= sizeof(WCHAR);
        if (!AdjustLengthOnly) {

            String->Buffer[NumCharsInString-1] = UNICODE_NULL;
        }

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsastr.h ===
#ifndef _LSASTR_H
#define _LSASTR_H

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lsastr.h

Abstract:

    Common string operations.

Author:

    24-March-1999 kumarp

--*/

#ifdef __cplusplus
extern "C" {
#endif

VOID
LsapTruncateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT TruncateToNumChars);

BOOLEAN
LsapRemoveTrailingDot(
    IN OUT PUNICODE_STRING String,
    IN BOOLEAN AdjustLengthOnly);

#ifdef __cplusplus
}
#endif

#endif // _LSASTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsasrvp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsasrvp.h

Abstract:

    LSA Subsystem - Private Includes for Server Side

    This file contains includes that are global to the Lsa Server Side

Author:

    Scott Birrell       (ScottBi)       January 22, 1992

Environment:

Revision History:

--*/

#ifndef _LSASRVP_
#define _LSASRVP_


//
// The LSA Server Is UNICODE Based.  Define UNICODE before global includes
// so that it is defined before the TEXT macro.
//

#ifndef UNICODE

#define UNICODE

#endif // UNICODE

//
// Set the EXTERN macro so only one file allocates all the globals.
//

#ifdef ALLOC_EXTERN
#define EXTERN
#else
#define EXTERN extern
#endif // ALLOC_EXTERN

#include <lsacomp.h>
#include <wincred.h>
#include <alloca.h>
#include <malloc.h>


//
// The following come from \nt\private\inc
#include <align.h>
#include <samrpc.h>
#include <samsrv.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <nlrepl.h>
#include <seposix.h>

//
// The following all come from \nt\private\lsa\server
//

#include "lsasrvmm.h"
#include "au.h"
#include "db.h"
#include "adt.h"
#include "dblookup.h"
#include "lsads.h"
#include "lsads.h"
#include "lsastr.h"
#include "lsawow.h"


//////////////////////////////////////////////////////////////////////
//                                                                  //
// The following define controls the diagnostic capabilities that   //
// are built into LSA.                                              //
//                                                                  //
//////////////////////////////////////////////////////////////////////

#if DBG
#define LSAP_DIAGNOSTICS 1
#endif // DBG


//
// These definitions are useful diagnostics aids
//

#if LSAP_DIAGNOSTICS

//
// Diagnostics included in build
//

//
// Test for diagnostics enabled
//

#define IF_LSAP_GLOBAL( FlagName ) \
    if (LsapGlobalFlag & (LSAP_DIAG_##FlagName))

//
// Diagnostics print statement
//

#define LsapDiagPrint( FlagName, _Text_ )                               \
    IF_LSAP_GLOBAL( FlagName )                                          \
        DbgPrint _Text_


//
// Make sure no thread leaves with any open state
//

#define LSAP_TRACK_DBLOCK

#ifdef LSAP_TRACK_DBLOCK
#define LsarpReturnCheckSetup()  \
ULONG   __lsarpthreadusecountstart; \
{\
  PLSADS_PER_THREAD_INFO __lsarpCurrentThreadInfo = (PLSADS_PER_THREAD_INFO) LsapQueryThreadInfo() ;\
  if (__lsarpCurrentThreadInfo!=NULL)\
        __lsarpthreadusecountstart = __lsarpCurrentThreadInfo->UseCount;\
  else \
        __lsarpthreadusecountstart =0;\
}

#define LsarpReturnPrologue()    \
{\
    PLSADS_PER_THREAD_INFO __lsarpCurrentThreadInfoEnd =   (PLSADS_PER_THREAD_INFO)LsapQueryThreadInfo() ;\
    ULONG __lsarpthreadusecountend ; \
    if (__lsarpCurrentThreadInfoEnd!=NULL)\
            __lsarpthreadusecountend = __lsarpCurrentThreadInfoEnd->UseCount;\
    else\
        __lsarpthreadusecountend = 0;\
    ASSERT (__lsarpthreadusecountstart==__lsarpthreadusecountend);\
}

#else

#define LsarpReturnPrologue()
#define LsarpReturnCheckSetup()

#endif



#else

//
// No diagnostics included in build
//

//
// Test for diagnostics enabled
//

#define IF_LSAP_GLOBAL( FlagName ) if (FALSE)


//
// Diagnostics print statement (nothing)
//

#define LsapDiagPrint( FlagName, Text )     ;

#define LsarpReturnPrologue()
#define LsarpReturnCheckSetup()

#endif // LSAP_DIAGNOSTICS


//
// The following flags enable or disable various diagnostic
// capabilities within LSA.  These flags are set in
// LsapGlobalFlag
//
//      DB_LOOKUP_WORK_LIST - Display activities related to sid/name lookups.
//
//      AU_TRACK_THREADS - Display dynamic AU thread creation / deletion
//          information.
//
//      AU_MESSAGES - Display information related to the processing of
//          Authentication messages.
//
//      AU_LOGON_SESSIONS - Display information about the creation/deletion
//          of logon sessions within LSA.
//
//      DB_INIT - Display information about the initialization of LSA.
//

#define LSAP_DIAG_DB_LOOKUP_WORK_LIST       ((ULONG) 0x00000001L)
#define LSAP_DIAG_AU_TRACK_THREADS          ((ULONG) 0x00000002L)
#define LSAP_DIAG_AU_MESSAGES               ((ULONG) 0x00000004L)
#define LSAP_DIAG_AU_LOGON_SESSIONS         ((ULONG) 0x00000008L)
#define LSAP_DIAG_DB_INIT                   ((ULONG) 0x00000010L)





//////////////////////////////////////////////////////////////////////
//                                                                  //
// Other defines                                                    //
//                                                                  //
//////////////////////////////////////////////////////////////////////


//
// Heap available for general use throughout LSA
//

EXTERN PVOID LsapHeap;

//
// LSA Private Global State Data Structure
//

typedef struct _LSAP_STATE {

    HANDLE LsaCommandPortHandle;
    HANDLE RmCommandPortHandle;
    HANDLE AuditLogFileHandle;
    HANDLE AuditLogSectionHandle;
    PVOID  AuditLogBaseAddress;
    ULONG  AuditLogViewSize;
    LARGE_INTEGER AuditLogInitSize;
    LARGE_INTEGER AuditLogMaximumSizeOfSection;
    OBJECT_ATTRIBUTES  AuditLogObjectAttributes;
    STRING AuditLogNameString;
    GENERIC_MAPPING GenericMapping;
    UNICODE_STRING SubsystemName;
    PRIVILEGE_SET Privileges;
    BOOLEAN GenerateOnClose;
    BOOLEAN SystemShutdownPending;

} LSAP_STATE, *PLSAP_STATE;

extern LSAP_STATE LsapState;

extern BOOLEAN LsapInitialized;

//
// Global handle to LSA's policy object.
// This handle is opened for trusted client.
//

extern LSAPR_HANDLE LsapPolicyHandle;

//
// LSA Server Command Dispatch Table Entry
//

typedef NTSTATUS (*PLSA_COMMAND_WORKER)(PLSA_COMMAND_MESSAGE, PLSA_REPLY_MESSAGE);

//
// LSA Client Control Block
//
// This structure contains context information relevant to a successful
// LsaOpenLsa call.
//

typedef struct _LSAP_CLIENT_CONTROL_BLOCK {
    HANDLE KeyHandle;           // Configuration Registry Key
    ACCESS_MASK GrantedAccess;  // Accesses granted to LSA Database Object
} LSAP_CLIENT_CONTROL_BLOCK, *PLSAP_CLIENT_CONTROL_BLOCK;


//
// LSA Privilege Pseudo-Object Types and Flags
//

// *********************** IMPORTANT NOTE ************************
//
// Privilege objects (privileges containing a list of users who have that
// privilge) are pseudo-objects that use the account objects as a backing
// stored.  There are currently no public interfaces to open a privilege
// object, so there need not be public access flags.
//

#define PRIVILEGE_VIEW      0x00000001L
#define PRIVILEGE_ADJUST    0x00000002L
#define PRIVILEGE_ALL       (STANDARD_RIGHTS_REQUIRED | \
                             PRIVILEGE_VIEW | \
                             PRIVILEGE_ADJUST)



//
// LSA API Error Handling Cleanup Flags
//
// These flags specify cleanup operations to be performed after an LSA
// API call has hit a fatal error.  They are passed in the ErrorCleanupFlags
// variable of the API or worker's error handling routine.
//

#define LSAP_CLEANUP_REVERT_TO_SELF        (0x00000001L)
#define LSAP_CLEANUP_CLOSE_LSA_HANDLE      (0x00000002L)
#define LSAP_CLEANUP_FREE_USTRING          (0x00000004L)
#define LSAP_CLEANUP_CLOSE_REG_KEY         (0x00000008L)
#define LSAP_CLEANUP_DELETE_REG_KEY        (0x00000010L)
#define LSAP_CLEANUP_DB_UNLOCK             (0x00000020L)

BOOLEAN
LsapRmInitializeServer(
    );

VOID
LsapRmServerThread(
    );

NTSTATUS
LsapRPCInit(
    );

BOOLEAN
LsapAuInit(       // Authentication initialization
    );

NTSTATUS
LsapDbInitializeRights(
    );

VOID
LsapDbCleanupRights(
    );

NTSTATUS
LsapCallRm(
    IN RM_COMMAND_NUMBER CommandNumber,
    IN OPTIONAL PVOID CommandParams,
    IN ULONG CommandParamsLength,
    OUT OPTIONAL PVOID ReplyBuffer,
    IN ULONG ReplyBufferLength
    );

NTSTATUS
LsapLogonSessionDeletedWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

NTSTATUS
LsapComponentTestWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

//
// Prototypes of RPC free routines used by LsaIFree.c
//

void _fgs__STRING (STRING  * _source);
void _fgs__LSAPR_SID_INFORMATION (LSAPR_SID_INFORMATION  * _source);
void _fgs__LSAPR_SID_ENUM_BUFFER (LSAPR_SID_ENUM_BUFFER  * _source);
void _fgs__LSAPR_ACCOUNT_INFORMATION (LSAPR_ACCOUNT_INFORMATION  * _source);
void _fgs__LSAPR_ACCOUNT_ENUM_BUFFER (LSAPR_ACCOUNT_ENUM_BUFFER  * _source);
void _fgs__LSAPR_UNICODE_STRING (LSAPR_UNICODE_STRING  * _source);
void _fgs__LSAPR_SECURITY_DESCRIPTOR (LSAPR_SECURITY_DESCRIPTOR  * _source);
void _fgs__LSAPR_SR_SECURITY_DESCRIPTOR (LSAPR_SR_SECURITY_DESCRIPTOR  * _source);
void _fgs__LSAPR_POLICY_PRIVILEGE_DEF (LSAPR_POLICY_PRIVILEGE_DEF  * _source);
void _fgs__LSAPR_PRIVILEGE_ENUM_BUFFER (LSAPR_PRIVILEGE_ENUM_BUFFER  * _source);
void _fgs__LSAPR_OBJECT_ATTRIBUTES (LSAPR_OBJECT_ATTRIBUTES  * _source);
void _fgs__LSAPR_CR_CIPHER_VALUE (LSAPR_CR_CIPHER_VALUE  * _source);
void _fgs__LSAPR_TRUST_INFORMATION (LSAPR_TRUST_INFORMATION  * _source);
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER (LSAPR_TRUSTED_ENUM_BUFFER  * _source);
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX (LSAPR_TRUSTED_ENUM_BUFFER_EX  * _source);
void _fgs__LSAPR_REFERENCED_DOMAIN_LIST (LSAPR_REFERENCED_DOMAIN_LIST  * _source);
void _fgs__LSAPR_TRANSLATED_SIDS (LSAPR_TRANSLATED_SIDS  * _source);
void _fgs__LSAPR_TRANSLATED_NAME (LSAPR_TRANSLATED_NAME  * _source);
void _fgs__LSAPR_TRANSLATED_NAMES (LSAPR_TRANSLATED_NAMES  * _source);
void _fgs__LSAPR_POLICY_ACCOUNT_DOM_INFO (LSAPR_POLICY_ACCOUNT_DOM_INFO  * _source);
void _fgs__LSAPR_POLICY_PRIMARY_DOM_INFO (LSAPR_POLICY_PRIMARY_DOM_INFO  * _source);
void _fgs__LSAPR_POLICY_PD_ACCOUNT_INFO (LSAPR_POLICY_PD_ACCOUNT_INFO  * _source);
void _fgs__LSAPR_POLICY_REPLICA_SRCE_INFO (LSAPR_POLICY_REPLICA_SRCE_INFO  * _source);
void _fgs__LSAPR_POLICY_AUDIT_EVENTS_INFO (LSAPR_POLICY_AUDIT_EVENTS_INFO  * _source);
void _fgs__LSAPR_TRUSTED_DOMAIN_NAME_INFO (LSAPR_TRUSTED_DOMAIN_NAME_INFO  * _source);
void _fgs__LSAPR_TRUSTED_CONTROLLERS_INFO (LSAPR_TRUSTED_CONTROLLERS_INFO  * _source);
void _fgu__LSAPR_POLICY_INFORMATION (LSAPR_POLICY_INFORMATION  * _source, POLICY_INFORMATION_CLASS _branch);
void _fgu__LSAPR_POLICY_DOMAIN_INFORMATION (LSAPR_POLICY_DOMAIN_INFORMATION  * _source,
                                            POLICY_DOMAIN_INFORMATION_CLASS _branch);
void _fgu__LSAPR_TRUSTED_DOMAIN_INFO (LSAPR_TRUSTED_DOMAIN_INFO  * _source, TRUSTED_INFORMATION_CLASS _branch);

//
// Old worker prototypes - These are temporary
//

#define LsapComponentTestCommandWrkr LsapComponentTestWrkr
#define LsapWriteAuditMessageCommandWrkr LsapAdtWriteLogWrkr

NTSTATUS
ServiceInit (
    );

NTSTATUS
LsapInitLsa(
    );

BOOLEAN
LsapSeSetWellKnownValues(
    );

VOID
RtlConvertSidToText(
    IN PSID Sid,
    OUT PUCHAR Buffer
    );

ULONG
RtlSizeANSISid(
    IN PSID Sid
    );

NTSTATUS
LsapGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    );


VOID
LsapLogError(
    IN OPTIONAL PUCHAR Message,
    IN NTSTATUS Status
    );

NTSTATUS
LsapWinerrorToNtStatus(
    IN DWORD WinError
    );

NTSTATUS
LsapNtStatusFromLastWinError( VOID );


NTSTATUS
LsapGetPrivilegesAndQuotas(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PULONG PrivilegeCount,
    OUT PLUID_AND_ATTRIBUTES *Privileges,
    OUT PQUOTA_LIMITS QuotaLimits
    );


NTSTATUS
LsapQueryClientInfo(
    PTOKEN_USER *UserSid,
    PLUID AuthenticationId
    );


NTSTATUS
LsapGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    );

NTSTATUS
LsapOpenSam( VOID );

NTSTATUS
LsapOpenSamEx(
    BOOLEAN DuringStartup
    );

NTSTATUS
LsapNotifyProcessNotificationEvent(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE EventHandle,
    IN ULONG OwnerProcess,
    IN HANDLE OwnerEventHandle,
    IN BOOLEAN Register
    );



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Shared Global Variables                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Handles used to talk to SAM directly.
// Also, a flag to indicate whether or not the handles are valid.
//


extern BOOLEAN LsapSamOpened;

extern SAMPR_HANDLE LsapAccountDomainHandle;
extern SAMPR_HANDLE LsapBuiltinDomainHandle;



//
// These variables are used to control the number of
// threads used for processing Logon Process calls.
// See auloop.c for a description of these variables.
//

extern RTL_RESOURCE LsapAuThreadCountLock;
extern LONG LsapAuActiveThreads;
extern LONG LsapAuFreeThreads;
extern LONG LsapAuFreeThreadsGoal;
extern LONG LsapAuMinimumThreads;
extern LONG LsapAuMaximumThreads;
extern LONG LsapAuCallsToProcess;


#if DBG

//
// Used to extend the resource timeout for lsass.exe to
// prevent it from hitting deadlock warnings in stress tests.
//

extern IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used;
#endif \\DBG


#if LSAP_DIAGNOSTICS

//
// Used as a global diagnostics control flag within lsass.exe
//

extern ULONG LsapGlobalFlag;
#endif // LSAP_DIAGNOSTICS

//
// Fast version of NtQuerySystemTime
//

#define LsapQuerySystemTime( _Time ) GetSystemTimeAsFileTime( (LPFILETIME)(_Time) )


#endif // _LSASRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsads.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lsads.h

Abstract:

    Private macros/definitions/prototypes for implementing portions of the LSA store
    in the DS and in the registry, simultaneously

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/

#ifndef __LSADS_H__
#define __LSADS_H__

#include <ntdsa.h>
#include <dsysdbg.h>
#include <safelock.h>

#if DBG == 1

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT  DsysAssert

    #define DEB_UPGRADE     0x10
    #define DEB_POLICY      0x20
    #define DEB_REPL        0x40
    #define DEB_FIXUP       0x80
    #define DEB_NOTIFY      0x100
    #define DEB_DSNOTIFY    0x200
    #define DEB_FTRACE      0x400
    #define DEB_LOOKUP      0x800
    #define DEB_HANDLE      0x1000
    #define DEB_FTINFO      0x2000

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    DECLARE_DEBUG2( LsaDs )

#ifdef __cplusplus
}
#endif // __cplusplus

    #define LsapDsDebugOut( args ) LsaDsDebugPrint args

    #define LsapEnterFunc( x )                                              \
    LsaDsDebugPrint( DEB_FTRACE, "0x%lx: Entering %s\n", GetCurrentThreadId(), x );

    #define LsapExitFunc( x, y )                                            \
    LsaDsDebugPrint( DEB_FTRACE, "0x%lx: Leaving %s: 0x%lx\n", GetCurrentThreadId(), x, y );

    #define LsapDsDebugDumpGuid( level, tag, pg )                           \
    pg == NULL ? LsapDsDebugOut(( level, "%s: (NULL)\n", tag))    :         \
        LsapDsDebugOut((level,                                              \
        "%s: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",            \
        tag,(pg)->Data1,(pg)->Data2,(pg)->Data3,(pg)->Data4[0],             \
        (pg)->Data4[1],(pg)->Data4[2],(pg)->Data4[3],(pg)->Data4[4],        \
        (pg)->Data4[5],(pg)->Data4[6],(pg)->Data4[7]))

    #define LSAP_TRACK_LOCK

#else

    #define LsapDsDebugOut(args)
    #define LsapDsDebugDumpGuid(level, tag, pguid)
    #define LsapEnterFunc( x )
    #define LsapExitFunc( x, y )

#endif  // DBG


//
// These function prototypes control how the Ds transactioning is done.  In
// the Ds case, the pointers are initialized to routines that actually do
// transactioning.  In the non-Ds case, they point to dummy rountines that
// do nothing.
//

typedef NTSTATUS ( *pfDsOpenTransaction ) ( ULONG );
typedef NTSTATUS ( *pfDsApplyTransaction ) ( ULONG );
typedef NTSTATUS ( *pfDsAbortTransaction ) ( ULONG );

//
// Ds functions that behave differently for the Ds and non-Ds case exist
// in this function table.
//
typedef struct _LSADS_DS_FUNC_TABLE {

    pfDsOpenTransaction     pOpenTransaction;
    pfDsApplyTransaction    pApplyTransaction;
    pfDsAbortTransaction    pAbortTransaction;

} LSADS_DS_FUNC_TABLE, *PLSADS_DS_FUNC_TABLE;

typedef struct _LSADS_DS_SYSTEM_CONTAINER_ITEMS {

    BOOLEAN NamesInitialized;
    PDSNAME TrustedDomainObject;
    PDSNAME SecretObject;

} LSADS_DS_SYSTEM_CONTAINER_ITEMS, *PLSADS_DS_SYSTEM_CONTAINER_ITEMS;

//
// Basic LsaDs information structure
//
typedef struct _LSADS_DS_STATE_INFO {

    PDSNAME DsRoot;                 // DSNAME of the root of the Ds
    PDSNAME DsPartitionsContainer;  // DSNAME of the partitions container
    PDSNAME DsSystemContainer;      // DSNAME of the system container
    PDSNAME DsConfigurationContainer;   // DSNAME of the configuration container

    ULONG   DsDomainHandle;         // DS Handle of the domain
    LSADS_DS_FUNC_TABLE DsFuncTable;    // Function table for Ds specific
                                        // functions
    LSADS_DS_SYSTEM_CONTAINER_ITEMS SystemContainerItems;
    PVOID   SavedThreadState;       // Results from THSave
    BOOLEAN DsTransactionSave;
    BOOLEAN DsTHStateSave;
    BOOLEAN DsOperationSave;
    BOOLEAN WriteLocal;             // Can we write to the registry?
    BOOLEAN UseDs;                  // Is the Ds active?
    BOOLEAN FunctionTableInitialized;   // Is the function table initialized
    BOOLEAN DsInitializedAndRunning;    // Has the Ds started
    BOOLEAN Nt4UpgradeInProgress;       // Is this the case of an upgrade from NT4


} LSADS_DS_STATE_INFO, *PLSADS_DS_STATE_INFO;


typedef struct _LSADS_PER_THREAD_INFO {

    BOOLEAN SavedTransactionValid;
    ULONG UseCount;
    ULONG DsThreadStateUseCount;
    ULONG DsTransUseCount;
    ULONG DsOperationCount;
    PVOID SavedThreadState;
    PVOID InitialThreadState;
    ULONG OldTrustDirection;
    ULONG OldTrustType;

} LSADS_PER_THREAD_INFO, *PLSADS_PER_THREAD_INFO;

#if DBG
typedef struct _LSADS_THREAD_INFO_NODE {
    PLSADS_PER_THREAD_INFO ThreadInfo;
    ULONG ThreadId;
} LSADS_THREAD_INFO_NODE, *PLSADS_THREAD_INFO_NODE;

#define LSAP_THREAD_INFO_LIST_MAX    15
extern LSADS_THREAD_INFO_NODE LsapDsThreadInfoList[ LSAP_THREAD_INFO_LIST_MAX ];
extern SAFE_RESOURCE LsapDsThreadInfoListResource;
#endif

//
// Extern definitions
//
extern LSADS_DS_STATE_INFO LsaDsStateInfo;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DWORD LsapDsThreadState;

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Implemented as a macro for performance reasons
//
// PLSADS_PER_THREAD_INFO
// LsapQueryThreadInfo(
//    VOID
//    );
#define LsapQueryThreadInfo( )  TlsGetValue( LsapDsThreadState )

VOID
LsapDsDebugInitialize(
    VOID
    );

//
// Registry specific functions
//
NTSTATUS
LsapRegReadObjectSD(
    IN  LSAPR_HANDLE            ObjectHandle,
    OUT PSECURITY_DESCRIPTOR   *ppSD
    );

NTSTATUS
LsapRegGetPhysicalObjectName(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN PUNICODE_STRING  LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU
    );

NTSTATUS
LsapRegOpenObject(
    IN LSAP_DB_HANDLE  ObjectHandle,
    IN ULONG  OpenMode,
    OUT PVOID  *pvKey
    );

NTSTATUS
LsapRegOpenTransaction(
    );

NTSTATUS
LsapRegApplyTransaction(
    );

NTSTATUS
LsapRegAbortTransaction(
    );

NTSTATUS
LsapRegCreateObject(
    IN PUNICODE_STRING  ObjectPath,
    IN LSAP_DB_OBJECT_TYPE_ID   ObjectType
    );

NTSTATUS
LsapRegDeleteObject(
    IN PUNICODE_STRING  ObjectPath
    );

NTSTATUS
LsapRegWriteAttribute(
    IN PUNICODE_STRING  AttributePath,
    IN PVOID            pvAttribute,
    IN ULONG            AttributeLength
    );

NTSTATUS
LsapRegDeleteAttribute(
    IN PUNICODE_STRING  AttributePath,
    IN BOOLEAN DeleteSecurely,
    IN ULONG AttributeLength
    );

NTSTATUS
LsapRegReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeName,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength
    );

//
// Counterpart Ds functions
//
NTSTATUS
LsapDsReadObjectSD(
    IN  LSAPR_HANDLE            ObjectHandle,
    OUT PSECURITY_DESCRIPTOR   *ppSD
    );

NTSTATUS
LsapDsGetPhysicalObjectName(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN BOOLEAN DefaultName,
    IN PUNICODE_STRING  LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU
    );

NTSTATUS
LsapDsOpenObject(
    IN LSAP_DB_HANDLE  ObjectHandle,
    IN ULONG  OpenMode,
    OUT PVOID  *pvKey
    );

NTSTATUS
LsapDsVerifyObjectExistenceByDsName(
    IN PDSNAME  DsName
    );

NTSTATUS
LsapDsOpenTransaction(
    IN ULONG Options
    );

//
// Assert that there is a DS transaction open
//
#define LsapAssertDsTransactionOpen() \
{ \
    PLSADS_PER_THREAD_INFO CurrentThreadInfo; \
    CurrentThreadInfo = LsapQueryThreadInfo(); \
                                               \
    ASSERT( CurrentThreadInfo != NULL );       \
    if ( CurrentThreadInfo != NULL ) {         \
        ASSERT( CurrentThreadInfo->DsTransUseCount > 0 ); \
    } \
}

NTSTATUS
LsapDsOpenTransactionDummy(
    IN ULONG Options
    );

NTSTATUS
LsapDsApplyTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDsApplyTransactionDummy(
    IN ULONG Options
    );

NTSTATUS
LsapDsAbortTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDsAbortTransactionDummy(
    IN ULONG Options
    );

NTSTATUS
LsapDsCreateObject(
    IN PUNICODE_STRING  ObjectPath,
    IN ULONG Flags,
    IN LSAP_DB_OBJECT_TYPE_ID   ObjectType
    );

NTSTATUS
LsapDsDeleteObject(
    IN PUNICODE_STRING  ObjectPath
    );

NTSTATUS
LsapDsWriteAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount,
    IN ULONG Options
    );

NTSTATUS
LsapDsWriteAttributesByDsName(
    IN PDSNAME  ObjectPath,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount,
    IN ULONG Options
    );

NTSTATUS
LsapDsReadAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDsReadAttributesByDsName(
    IN PDSNAME  ObjectPath,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDsRenameObject(
    IN PDSNAME OldObject,
    IN PDSNAME NewParent,
    IN ULONG AttrType,
    IN PUNICODE_STRING NewObject
    );

NTSTATUS
LsapDsDeleteAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

//
// Interesting or global functions
//
PVOID
LsapDsAlloc(
    IN  DWORD   dwLen
    );

VOID
LsapDsFree(
    IN  PVOID   pvMemory
    );

NTSTATUS
LsapDsPostDsInstallSetup(
    VOID
    );

NTSTATUS
LsapDsInitializePromoteInterface(
    VOID
    );

BOOLEAN
LsapDsIsValidSid(
    IN PSID Sid,
    IN BOOLEAN DsSid
    );

NTSTATUS
LsapDsTruncateNameToFitCN(
    IN PUNICODE_STRING OriginalName,
    OUT PUNICODE_STRING TruncatedName
    );

BOOLEAN
LsapDsIsNtStatusResourceError(
    NTSTATUS NtStatus
    );

//
// Exported for the DsSetup functions
//
NTSTATUS
LsapDsRemoveDuplicateTrustObjects(
    IN LSAPR_HANDLE PolicyHandle
   );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\msvlayer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msvlayer.c
//
//  Contents:   Support for the fake MSV layer
//
//  Classes:
//
//  Functions:
//
//  History:    5-31-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "sesmgr.h"
#include "spdebug.h"
#include <ntmsv1_0.h>
}





NTSTATUS
LsapAllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )
{
    DebugLog((DEB_TRACE_LSA_AU, "package called LsapAllocateClientBuffer\n"));
    *ClientBaseAddress = LsapClientAllocate(LengthRequired);
    if (*ClientBaseAddress == NULL)
    {
        return(STATUS_NO_MEMORY);
    }
    else
    {
        return(STATUS_SUCCESS);
    }
}

NTSTATUS
LsapFreeClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    )
{
    DebugLog((DEB_TRACE_LSA_AU, "package called LsapFreeClientBuffer\n"));
    LsapClientFree(ClientBaseAddress);
    return(STATUS_SUCCESS);
}

NTSTATUS
LsapCopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )
{
    return(LsapCopyToClient(BufferToCopy, ClientBaseAddress, Length));
}

NTSTATUS
LsapCopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    )
{
    return(LsapCopyFromClient(ClientBaseAddress, BufferToCopy, Length));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsawow.h ===
/*++

copyright (c) 2000 Microsoft Corporation

Module Name:

    lsawow.h

Abstract:

    WOW64 structure/function definitions for the LSA server

Author:

    8-Nov-2000     JSchwart

Revision History:


--*/

#ifndef _LSAWOW_H
#define _LSAWOW_H

#if _WIN64

//
// WOW64 versions of public data structures.  These MUST be kept
// in sync with their public equivalents.
//

typedef struct _SecPkgInfoWOW64
{
    unsigned long  fCapabilities;        // Capability bitmask
    unsigned short wVersion;             // Version of driver
    unsigned short wRPCID;               // ID for RPC Runtime
    unsigned long  cbMaxToken;           // Size of authentication token (max)
    ULONG    Name;                       // Text name
    ULONG    Comment;                    // Comment
}
SecPkgInfoWOW64, *PSecPkgInfoWOW64;


typedef struct _SECURITY_USER_DATA_WOW64
{
    UNICODE_STRING32 UserName;
    UNICODE_STRING32 LogonDomainName;
    UNICODE_STRING32 LogonServer;
    ULONG            pSid;
}
SECURITY_USER_DATA_WOW64, *PSECURITY_USER_DATA_WOW64;


typedef struct _QUOTA_LIMITS_WOW64
{
    ULONG         PagedPoolLimit;
    ULONG         NonPagedPoolLimit;
    ULONG         MinimumWorkingSetSize;
    ULONG         MaximumWorkingSetSize;
    ULONG         PagefileLimit;
    LARGE_INTEGER TimeLimit;
}
QUOTA_LIMITS_WOW64, *PQUOTA_LIMITS_WOW64;

#endif  // _WIN64

#endif  // _LSAWOW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsawmi.h ===
#ifndef _LSAWMI_H
#define _LSAWMI_H

/*++

copyright (c) 1998 Microsoft Corporation

Module Name:

    LSAWMI.H
    
Abstract:

    Implement LSA server event trace by using WMI trace infrastructure.
    
Author:
    
    16-March-1999 kumarp
    
Revision History:

    
--*/    


#include <wmistr.h>
#include <evntrace.h>



extern ULONG        LsapEventTraceFlag;
extern TRACEHANDLE  LsapTraceRegistrationHandle;
extern TRACEHANDLE  LsapTraceLoggerHandle;


//
// The following "typedef enum" actually is the index of 
// TRACE_GUID_REGISTRATION struct entry in the array LsapTraceGuids[].
// Each enum defines an event that is to be traced using WMI tracing.
// 
// To add WMI tracing to a function Foo do the following steps:
// - add an entry (LsaTraceEvent_Foo) to LSA_TRACE_EVENT_TYPE below
// - generate a new guid using uuidgen.exe -s
// - add a DEFINE_GUID entry at the end of this file using this guid
// - add a corresponding entry (LsaTraceEventGuid_Foo) to LsapTraceGuids[]
// - add a corresponding entry to lsasrv.mof file
// - at the beginning of function Foo insert the following call:
//     LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_Foo);
// - at the end of function Foo insert the following call:
//     LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_Foo);
//
// Make sure that Foo returns only from one location, otherwise the
// LsapTraceEvent calls will not be balanced.
//
typedef enum _LSA_TRACE_EVENT_TYPE {

    LsaTraceEvent_QuerySecret=0,
    LsaTraceEvent_Close,
    LsaTraceEvent_OpenPolicy,
    LsaTraceEvent_QueryInformationPolicy,
    LsaTraceEvent_SetInformationPolicy,
    LsaTraceEvent_EnumerateTrustedDomains,
    LsaTraceEvent_LookupNames,
    LsaTraceEvent_LookupSids,
    LsaTraceEvent_OpenTrustedDomain,
    LsaTraceEvent_QueryInfoTrustedDomain,
    LsaTraceEvent_SetInformationTrustedDomain,
//     LsaTraceEvent_QueryInformationPolicy2,
//     LsaTraceEvent_SetInformationPolicy2,
    LsaTraceEvent_QueryTrustedDomainInfoByName,
    LsaTraceEvent_SetTrustedDomainInfoByName,
    LsaTraceEvent_EnumerateTrustedDomainsEx,
    LsaTraceEvent_CreateTrustedDomainEx,
    LsaTraceEvent_QueryDomainInformationPolicy,
    LsaTraceEvent_SetDomainInformationPolicy,
    LsaTraceEvent_OpenTrustedDomainByName,
    LsaTraceEvent_QueryForestTrustInformation,
    LsaTraceEvent_SetForestTrustInformation,
    LsaTraceEvent_LookupIsolatedNameInTrustedDomains,

} LSA_TRACE_EVENT_TYPE;

NTSTATUS
LsapStartWmiTraceInitThread(void);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

VOID
LsapTraceEvent(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType
    );

VOID
LsapTraceEventWithData(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType,
    IN ULONG ItemCount,
    IN PUNICODE_STRING Items  OPTIONAL
    );

LPWSTR
LsapGetClientNetworkAddress(
    VOID
    );

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Control GUID for the group of GUIDs that define LSA WMI tracing
// 
DEFINE_GUID ( /* cc85922f-db41-11d2-9244-006008269001 */
        LsapTraceControlGuid,
        0xcc85922f,
        0xdb41,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* cc85922e-db41-11d2-9244-006008269001 */
        LsapTraceEventGuid_QuerySecret,
        0xcc85922e,
        0xdb41,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe3b-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_Close,
        0x2306fe3b,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe3a-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_OpenPolicy,
        0x2306fe3a,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe39-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryInformationPolicy,
        0x2306fe39,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe38-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetInformationPolicy,
        0x2306fe38,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe37-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_EnumerateTrustedDomains,
        0x2306fe37,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe36-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_LookupNames,
        0x2306fe36,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe35-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_LookupSids,
        0x2306fe35,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe34-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_OpenTrustedDomain,
        0x2306fe34,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe33-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryInfoTrustedDomain,
        0x2306fe33,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe32-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetInformationTrustedDomain,
        0x2306fe32,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

// DEFINE_GUID ( /* 2306fe31-dbf6-11d2-9244-006008269001 */
//         LsaTraceEventGuid_QueryInformationPolicy2,
//         0x2306fe31,
//         0xdbf6,
//         0x11d2,
//         0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
//         );

// DEFINE_GUID ( /* 2306fe30-dbf6-11d2-9244-006008269001 */
//         LsaTraceEventGuid_SetInformationPolicy2,
//         0x2306fe30,
//         0xdbf6,
//         0x11d2,
//         0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
//         );

DEFINE_GUID ( /* 2306fe2f-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryTrustedDomainInfoByName,
        0x2306fe2f,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2e-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetTrustedDomainInfoByName,
        0x2306fe2e,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2d-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_EnumerateTrustedDomainsEx,
        0x2306fe2d,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2c-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_CreateTrustedDomainEx,
        0x2306fe2c,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2b-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryDomainInformationPolicy,
        0x2306fe2b,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2a-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetDomainInformationPolicy,
        0x2306fe2a,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe29-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_OpenTrustedDomainByName,
        0x2306fe29,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* e28ee0eb-6181-49df-b859-2f3fd289a2d1 */
        LsaTraceEventGuid_QueryForestTrustInformation,
        0xe28ee0eb,
        0x6181,
        0x49df,
        0xb8, 0x59, 0x2f, 0x3f, 0xd2, 0x89, 0xa2, 0xd1
        );

DEFINE_GUID ( /* 3d2c9e3e-bb19-4617-8489-cabb9787de7d */
        LsaTraceEventGuid_SetForestTrustInformation,
        0x3d2c9e3e,
        0xbb19,
        0x4617,
        0x84, 0x89, 0xca, 0xbb, 0x97, 0x87, 0xde, 0x7d
        );

DEFINE_GUID ( /* 2484dc26-49d3-4085-a6e4-4972115cb3c0 */
        LsaTraceEventGuid_LookupIsolatedNameInTrustedDomains,
        0x2484dc26,
        0x49d3,
        0x4085,
        0xa6, 0xe4, 0x49, 0x72, 0x11, 0x5c, 0xb3, 0xc0
      );

#endif /* _LSAWMI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\lsawmi.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    LSAWMI.C
    
Abstract:

    Implement LSA Server event tracing by using WMI trace infrastructure. 
    
Author:

    16-March-1999 kumarp
    
Revision History:


--*/

#include <lsapch2.h>
#include <wmistr.h>
#define INITGUID
#include <lsawmi.h>



//
// Globals
//
ULONG       LsapEventTraceFlag = FALSE;
TRACEHANDLE LsapTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE LsapTraceLoggerHandle = (TRACEHANDLE) 0;



//
// Forward declaration
// 

ULONG
LsapTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    );

LPWSTR
LsapMakeNullTerminatedString(
    IN PUNICODE_STRING u
    );

//
// before you change the elements of the following structure,
// read notes in lsawmi.h file
//
TRACE_GUID_REGISTRATION LsapTraceGuids[] =
{
    {&LsapTraceEventGuid_QuerySecret,                 NULL},
    {&LsaTraceEventGuid_Close,                        NULL},
    {&LsaTraceEventGuid_OpenPolicy,                   NULL},
    {&LsaTraceEventGuid_QueryInformationPolicy,       NULL},
    {&LsaTraceEventGuid_SetInformationPolicy,         NULL},
    {&LsaTraceEventGuid_EnumerateTrustedDomains,      NULL},
    {&LsaTraceEventGuid_LookupNames,                  NULL},
    {&LsaTraceEventGuid_LookupSids,                   NULL},
    {&LsaTraceEventGuid_OpenTrustedDomain,            NULL},
    {&LsaTraceEventGuid_QueryInfoTrustedDomain,       NULL},
    {&LsaTraceEventGuid_SetInformationTrustedDomain,  NULL},
    {&LsaTraceEventGuid_QueryTrustedDomainInfoByName, NULL},
    {&LsaTraceEventGuid_SetTrustedDomainInfoByName,   NULL},
    {&LsaTraceEventGuid_EnumerateTrustedDomainsEx,    NULL},
    {&LsaTraceEventGuid_CreateTrustedDomainEx,        NULL},
    {&LsaTraceEventGuid_QueryDomainInformationPolicy, NULL},
    {&LsaTraceEventGuid_SetDomainInformationPolicy,   NULL},
    {&LsaTraceEventGuid_OpenTrustedDomainByName,      NULL},
    {&LsaTraceEventGuid_QueryForestTrustInformation,  NULL},
    {&LsaTraceEventGuid_SetForestTrustInformation,    NULL},
    {&LsaTraceEventGuid_LookupIsolatedNameInTrustedDomains, NULL},
};


#define LsapTraceGuidCount (sizeof(LsapTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

    

ULONG
_stdcall
LsapInitializeWmiTrace( LPVOID ThreadParams )
/*++    
Routine Description:

    Register WMI Trace Guids.
    This routine is called during LSA initialization. LSA gets initialized
    before WMI therefore we call this from a seaprate thread. This
    thread can then wait on WMI.
    
Parameters:

    ThreadParams - Currently ignored.
    
Reture Values:
    
    NTSTATUS - Standard Nt Result Code
    
--*/
{
    ULONG   Status = ERROR_SUCCESS;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

#define RESOURCE_NAME TEXT("LsaMofResource")
#define IMAGE_PATH    TEXT("lsass.exe")

    LsapEnterFunc("LsapInitializeWmiTrace");
    
    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }
    
    //
    // Register Trace GUIDs
    // 
    Status = RegisterTraceGuids(
                    LsapTraceControlCallBack, 
                    NULL, 
                    &LsapTraceControlGuid, 
                    LsapTraceGuidCount, 
                    LsapTraceGuids, 
                    FileName, 
                    RESOURCE_NAME, 
                    &LsapTraceRegistrationHandle);
                    
#if DBG
    if (Status != ERROR_SUCCESS)
    {
        DebugLog(( DEB_ERROR, "LsapInitializeWmiTrace failed: 0x%x\n", Status));
    }
#endif // DBG
    
    return Status;
}


ULONG
LsapTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    )
/*++

Routine Description:

    Call back function called by the WMI module to enable or
    disable LSA tracing.

Arguments:

    RequestCode - WMI_ENABLE_EVENTS or WMI_DISABLE_EVENTS

    RequestContext - currently ignored

    InOutBufferSize - size of data returned by this call back.
        Currently always set to 0.

    Buffer - pointer to data received. In case of WMI_ENABLE_EVENTS,
        this is a pointer to the trace handle.

Return Value:

    Win32 error code.

Notes:

--*/
{
    ULONG   Status = ERROR_SUCCESS;
    
    LsapEnterFunc("LsapTraceControlCallBack");

    switch (RequestCode) 
    {
        case WMI_ENABLE_EVENTS:
        {
            LsapTraceLoggerHandle = GetTraceLoggerHandle(Buffer);
            LsapEventTraceFlag = TRUE;     // enable flag
            break; 
        }
    
        case WMI_DISABLE_EVENTS:
        {
            LsapTraceLoggerHandle = (TRACEHANDLE) 0;
            LsapEventTraceFlag = FALSE;     // disable flag
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    } 
    
    *InOutBufferSize = 0;
    
    return Status;
} 

NTSTATUS
LsapStartWmiTraceInitThread(void)
/*++

Routine Description:

    Start the thread that registers WMI trace guids.

Parameters:

    None

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status=STATUS_SUCCESS;
    HANDLE   ThreadHandle;
    ULONG    ThreadId = 0;
    ULONG    WinError;
    
    ThreadHandle = CreateThread(NULL,
                                0, 
                                LsapInitializeWmiTrace,
                                NULL,
                                0,
                                &ThreadId);
                                    
    if (NULL == ThreadHandle) 
    {
        Status = STATUS_UNSUCCESSFUL;
        WinError = GetLastError();
        DebugLog((DEB_ERROR, "Failed to create thread for LsapInitializeWmiTrace: 0x%x", WinError));
    }
    else
    {
        CloseHandle(ThreadHandle);
    }

    return Status;
}


VOID
LsapTraceEvent(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType
    )

/*++

Routine Description:

    This routine will do a WMI event trace. 

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END
                   
    TraceGuid - Index in LsapTraceGuids[]                   
    
Return Values:

    None.

--*/
{
    LsapTraceEventWithData(WmiEventType,
                           LsaTraceEventType,
                           0,
                           NULL);

}

VOID
LsapTraceEventWithData(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType,
    IN ULONG ItemCount,
    IN PUNICODE_STRING Items  OPTIONAL
    )

/*++

Routine Description:

    This routine will do a WMI event trace. 

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END
                   EVENT_TRACE_TYPE_INFO
                   
    TraceGuid - Index in LsapTraceGuids[]                   
    
    ItemCount - the number of elements in Items
    
    Items - an array of information.  The unicode strings don't have
            to represent strings -- can be binary data whose length
            is denoted by the Length field.

Return Values:

    None.

--*/

{
#if DBG
    ULONG WinError;
#endif    

    WCHAR       NullChar = UNICODE_NULL;
    PVOID       BuffersToFree[10];
    ULONG       BuffersToFreeCount = 0;
    ULONG       i;

    struct
    {
        EVENT_TRACE_HEADER  EventTrace;
        MOF_FIELD           EventInfo[2];
    } Event;
    
    //
    // Theoretically, only test LsapEventTraceFlag would be enough, since
    // LsapEventTraceFlag will remain FALSE in Registry Mode, because 
    // LsapInitializeTrace() will never been called in Registry Mode.
    // Thus nobody will change the value of LsapEventTraceFlag 
    // 
    if (!LsapEventTraceFlag) {
        return;
    }

    // 
    // Fill the event information. 
    // 
    ZeroMemory(&Event, sizeof(Event));
    Event.EventTrace.GuidPtr = (ULONGLONG) LsapTraceGuids[LsaTraceEventType].Guid; 
    Event.EventTrace.Class.Type = (UCHAR) WmiEventType;
    Event.EventTrace.Flags |= (WNODE_FLAG_USE_GUID_PTR |  // GUID is actually a pointer 
                         WNODE_FLAG_TRACED_GUID);         // denotes a trace 
    Event.EventTrace.Size = sizeof(Event.EventTrace);     // no other parameters/information


    if ( (LsaTraceEventType == LsaTraceEvent_LookupIsolatedNameInTrustedDomains)  ) {

        //
        // Add the flag that indicates that there is more data
        //
        Event.EventTrace.Flags |= WNODE_FLAG_USE_MOF_PTR;

        //
        // Make sure enough space has been allocated on the stack for us
        //
        ASSERT(sizeof(Event.EventInfo) >= (sizeof(MOF_FIELD) * 2));
        ASSERT( (ItemCount == 2) && (Items != NULL) );

        //
        // Fill in the data requested
        //
        for (i = 0; i < ItemCount; i++) {

            LPWSTR String = NULL;
            ULONG  Length;

            //
            // Re'alloc to get a NULL terminated string
            //
            String = LsapMakeNullTerminatedString(&Items[i]);
            if (NULL == String) {
                String = &NullChar;
                Length = sizeof(NullChar);
            } else {
                Length = Items[i].Length + sizeof(WCHAR);
            }
            Event.EventInfo[i].Length = Length;
            Event.EventInfo[i].DataPtr = (ULONGLONG)String;
            Event.EventTrace.Size += sizeof(Event.EventInfo[i]);

            if (&NullChar != String) {
                ASSERT(BuffersToFreeCount < sizeof(BuffersToFree)/sizeof(BuffersToFree[0]));
                BuffersToFree[BuffersToFreeCount++] = String;
            }
        }
    }

#if DBG        
    WinError =
#endif
        TraceEvent(LsapTraceLoggerHandle, (PEVENT_TRACE_HEADER) &Event); 

#if DBG        
    if (WinError != ERROR_SUCCESS)
    {
        DebugLog(( DEB_ERROR, "WMI TraceEvent failed, status %x\n", WinError));
    }
#endif        

    for (i = 0; i < BuffersToFreeCount; i++) {
        LsapFreeLsaHeap(BuffersToFree[i]);
    }

}

LPWSTR
LsapGetClientNetworkAddress(
    VOID
    )
/*++

Routine Description:

    This routine returns a NULL terminated string that represents the network
    address of the client.  If the address cannot be obtained, NULL is returned.
    If the return value is non-NULL, the string must be freed with
    RpcStringFreeW.
    

Parameters:

    None.

Return Values:

    See description.

--*/
{
    ULONG              RpcStatus;
    RPC_BINDING_HANDLE ServerBinding = NULL;
    PWSTR              StringBinding = NULL;
    LPWSTR             NetworkAddr   = NULL;

    RpcStatus = RpcBindingServerFromClient(NULL, &ServerBinding); 

    if (RPC_S_OK == RpcStatus) {

        RpcStatus = RpcBindingToStringBindingW(ServerBinding, &StringBinding);
        
        if (RPC_S_OK == RpcStatus) {

            RpcStatus = RpcStringBindingParseW(StringBinding, 
                                           NULL,
                                           NULL,
                                           &NetworkAddr,
                                           NULL,
                                           NULL
                                           );

            RpcStringFreeW(&StringBinding);
        }

        RpcBindingFree(&ServerBinding);

    }

    return NetworkAddr;
}


LPWSTR
LsapMakeNullTerminatedString(
    IN PUNICODE_STRING u
    )
/*++

Routine Description:

    This routine returns a NULL terminated string composed of the data in 
    u. The string must be freed with LsapFreeLsaHeap().
    
    If u->Length is 0, a non-NULL string with the NULL character as the first
    character is returned.

Parameters:

    u -- a unicode string

Return Values:

    See description.

--*/
{
    LPWSTR String = NULL;
    ULONG  Length;
    if (u) {
        Length = u->Length + sizeof(WCHAR);
        String = LsapAllocateLsaHeap(Length);
        if (String != NULL) {
            RtlCopyMemory(String, u->Buffer, u->Length);
            String[u->Length / sizeof(WCHAR)] = UNICODE_NULL;
        }
    }
    return String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\param.cxx ===
//+-----------------------------------------------------------------------
//
// File:        PARAM.C
//
// Contents:    Parameter code
//
//
// History:     28 Feb 92   RichardW    Created
//
//------------------------------------------------------------------------


#include <lsapch.hxx>
extern "C"
{
extern PWSTR    pszPreferred;
}

#define MACHINERIDKEY L"MACHINERID"

WCHAR   szLsaPath[]       = L"System\\CurrentControlSet\\Control\\Lsa";
WCHAR   szOthersValue[]   = L"Security Packages";
WCHAR   szOldValue[]      = L"Authentication Packages";
WCHAR   szNonceLagValue[] = L"Clock Skew";
WCHAR   szHowMuchValue[]  = L"How Much";
WCHAR   szDisableSupPopups[] = L"DisablePopups";
WCHAR   szPreferredPackage[] = L"Preferred";
WCHAR   szGeneralThreadLifespan[] = L"GeneralThreadLifespan";
WCHAR   szDedicatedThreadLifespan[] = L"DedicatedThreadLifespan";

HKEY    hDSKey;
HANDLE  hRegNotifyEvent;
PVOID   pvParamScav;


PWSTR   ppszDefault[] = {L"Kerberos", L"NTLM", NULL};

// Will build an argv style array of DLLs to load as packages here:
extern PWSTR *  ppszPackages;
extern PWSTR *  ppszOldPkgs;
extern PWSTR    pszPreferred;

#if DBG
extern DWORD    BreakFlags;
extern DWORD    NoUnload;
#endif


SECURITY_STRING ssMachineRid;



//+-------------------------------------------------------------------------
//
//  Function:   GetRegistryString
//
//  Synopsis:   Gets a string from the registry
//
//  Effects:    If type is REG_EXPAND_SZ, string is expanded.
//              If type is REG_MULTI_SZ, string is (left alone?)
//
//  Arguments:  hRootKey    -- HKEY to start at
//              pszSubKey   -- Key to look at
//              pszValue    -- Value to look at
//              pszData     -- Buffer to place string
//              pcbData     -- Size (in/out) of buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
GetRegistryString(  HKEY        hRootKey,
                    PWSTR       pszSubkey,
                    PWSTR       pszValue,
                    PWSTR       pszData,
                    PDWORD      pcbData)
{
    HKEY        hKey;
    int         Status;
    ULONG       type;
    DWORD       dwSize = *pcbData;


    Status = RegOpenKey(hRootKey, pszSubkey, &hKey);
    if (Status != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR, "Open of %ws failed, %d\n", pszSubkey, Status));

        return(STATUS_OBJECT_NAME_NOT_FOUND);
    }


    // First, call query value and make sure this is a correct type


    Status = RegQueryValueEx(   hKey,
                                pszValue,
                                NULL,
                                &type,
                                NULL,
                                &dwSize);

    if ((Status != ERROR_SUCCESS) && (Status != ERROR_MORE_DATA))
    {
        DebugLog((DEB_TRACE, "QueryValueEx of %ws failed, %d\n", pszValue, Status));
        (void) RegCloseKey(hKey);
        if (Status == ERROR_FILE_NOT_FOUND)
        {
            return(STATUS_OBJECT_NAME_NOT_FOUND);
        }
        return(STATUS_UNSUCCESSFUL);
    }

    if ((type != REG_SZ) && (type != REG_MULTI_SZ) && (type != REG_EXPAND_SZ) )
    {
        DebugLog((DEB_ERROR, "Type = %d, returning now\n", type));

        (void) RegCloseKey(hKey);

        return(STATUS_UNSUCCESSFUL);   
    }


    Status = RegQueryValueEx(   hKey,
                                pszValue,
                                NULL,
                                &type,
                                (PBYTE) pszData,
                                pcbData);


    (void) RegCloseKey(hKey);

    if (Status != ERROR_SUCCESS)
    {
        if (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            return(STATUS_BUFFER_TOO_SMALL);
        }

        DebugLog((DEB_ERROR, "QueryValueEx of %ws returned %d\n", pszValue, Status));
        return(STATUS_UNSUCCESSFUL);
    }

    if (type == REG_EXPAND_SZ)
    {
        *pcbData = ExpandEnvironmentStrings(pszData, pszData, dwSize);
    }

    return(STATUS_SUCCESS);

}

//+---------------------------------------------------------------------------
//
//  Function:   GetRegistryDword
//
//  Synopsis:   Gets a DWORD from the registry
//
//  Effects:
//
//  Arguments:  [hPrimaryKey] --    Key to start from
//              [pszKey] --         Name of the subkey
//              [pszValue] --       Name of the value
//              [pdwValue] --       returned DWORD
//
//  Returns:    S_OK, or SEC_E_INVALID_HANDLE
//
//  History:    3-31-93   RichardW   Created
//
//----------------------------------------------------------------------------

HRESULT
GetRegistryDword(HKEY       hPrimaryKey,
                 PWSTR      pszKey,
                 PWSTR      pszValue,
                 DWORD *    pdwValue)
{
    HKEY    hKey;
    DWORD   cbDword = sizeof(DWORD);
    DWORD   dwType;
    int     err;


    err = RegOpenKey(hPrimaryKey, pszKey, &hKey);

    if (err) {
        return(SEC_E_INVALID_HANDLE);
    }


    err = RegQueryValueEx(  hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            (PBYTE) pdwValue,
                            &cbDword);

    (void) RegCloseKey(hKey);

    if (err || (dwType != REG_DWORD))
    {
            return(SEC_E_INVALID_HANDLE);
    }

    return(S_OK);

}


HRESULT
SpmGetMachineName(void)
{

    HRESULT     hr = S_OK;
    WCHAR       wszMachName [MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD       dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    if (!GetComputerName(
            wszMachName,
            &dwSize))
    {
        return(STATUS_UNSUCCESSFUL);
    }
    MachineName.Buffer = (LPWSTR) LsapAllocateLsaHeap((wcslen(wszMachName)+1) * sizeof(WCHAR));
    if (MachineName.Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    wcscpy(MachineName.Buffer, wszMachName);
    RtlInitUnicodeString(
        &MachineName,
        MachineName.Buffer
        );
    return(STATUS_SUCCESS);
}


//+---------------------------------------------------------------------------
//
//  Function:   ParameterNotify
//
//  Synopsis:   Function called when the registry key for DS is changed
//
//  Arguments:  [pvEntry] -- ignored
//
//  History:    6-08-93   RichardW   Created
//
//----------------------------------------------------------------------------


DWORD
ParameterNotify(PVOID   pvEntry)
{
    ULONG               NewState;
    HANDLE              hThread = 0;
    DWORD               tid;
    int                 err;


    err = RegNotifyChangeKeyValue(  hDSKey, FALSE,
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    hRegNotifyEvent,
                                    TRUE);

    if (err)
    {
        DebugLog((DEB_WARN, "Got %d from trying to start RegNotifyChangeKeyValue again\n",
                    err));
    }


    return(0);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadParameters
//
//  Synopsis:   Loads operating parameters from the registry
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-31-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
LoadParameters(
    VOID
    )
{
    int             lcPackages = 0;
    int             cOldPkgs = 0;
    int             iPackage = 0;
    PWSTR           pszAlternate;
    PWSTR           pszOldPkgs;
    PWSTR           pszScan;
    DWORD           dwBuffer = 64;
    HRESULT scRet;

    //
    // Get the parameters that can change during a boot.
    //



    //
    // Get the machine name
    //

    scRet = SpmGetMachineName();

    if (!NT_SUCCESS(scRet)) {
        return(scRet);
    }

    //
    // Get the preferred package
    //

    dwBuffer = 128 ;

    pszPreferred = (PWSTR) LsapAllocateLsaHeap( dwBuffer );

    if ( !pszPreferred )
    {
        dwBuffer = 0 ;
    }

    scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                szLsaPath,
                                szPreferredPackage,
                                pszPreferred,
                                &dwBuffer);

    if (scRet == STATUS_BUFFER_TOO_SMALL)
    {
        LsapFreeLsaHeap(pszPreferred);

        pszPreferred = (PWSTR)LsapAllocateLsaHeap(dwBuffer);

        if ( pszPreferred )
        {
            scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                        szLsaPath,
                                        szPreferredPackage,
                                        pszPreferred,
                                        &dwBuffer);
        }

    }
    else
    {
        if ( pszPreferred )
        {
            LsapFreeLsaHeap( pszPreferred );

            pszPreferred = NULL ;
        }
    }



    //
    // Set the default packages
    //

    ppszPackages = ppszDefault;


    //
    // Now, find out all the other ones.  First, NT5 packages:
    //

    dwBuffer = 128;

    pszAlternate = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
    if (!pszAlternate)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    *pszAlternate = L'\0';


    scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                szLsaPath,
                                szOthersValue,
                                pszAlternate,
                                &dwBuffer);

    if (scRet == STATUS_BUFFER_TOO_SMALL)
    {
        LsapFreeLsaHeap(pszAlternate);

        pszAlternate = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
        if (!pszAlternate)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        *pszAlternate = L'\0';

        scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                    szLsaPath,
                                    szOthersValue,
                                    pszAlternate,
                                    &dwBuffer);

        if (FAILED(scRet)) {
            return(scRet);
        }

    }
    if (NT_SUCCESS(scRet))
    {

        pszScan = pszAlternate;

        while (*pszScan)
        {
            while (*pszScan) {
                pszScan++;
            }

            lcPackages++;
            pszScan++;
        }

    } else if (scRet != STATUS_OBJECT_NAME_NOT_FOUND) {
        LsapFreeLsaHeap(pszAlternate);
        pszAlternate = NULL;
        return(scRet);
    } else {
        LsapFreeLsaHeap(pszAlternate);
        pszAlternate = NULL;
    }

    dwBuffer = 128;
    pszOldPkgs = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
    if (!pszOldPkgs)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    *pszOldPkgs = L'\0';


    scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                szLsaPath,
                                szOldValue,
                                pszOldPkgs,
                                &dwBuffer);

    if (scRet == STATUS_BUFFER_TOO_SMALL)
    {
        LsapFreeLsaHeap(pszOldPkgs);

        pszOldPkgs = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
        if (!pszOldPkgs)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        *pszOldPkgs = L'\0';
        scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                    szLsaPath,
                                    szOldValue,
                                    pszOldPkgs,
                                    &dwBuffer);

        if (!NT_SUCCESS(scRet)) {
            return(scRet);
        }

    }

    if (NT_SUCCESS(scRet))
    {
        pszScan = pszOldPkgs;

        while (*pszScan)
        {
            while (*pszScan) {
                pszScan++;
            }

            cOldPkgs++;
            pszScan++;
        }
    } else if (scRet != STATUS_OBJECT_NAME_NOT_FOUND) {
        LsapFreeLsaHeap(pszOldPkgs);
        pszOldPkgs = NULL;
        return(scRet);
    } else {
        LsapFreeLsaHeap(pszOldPkgs);
        pszOldPkgs = NULL;
    }

    ppszPackages = (PWSTR *)LsapAllocateLsaHeap((lcPackages + 1) * sizeof(PWSTR));
    if (!ppszPackages)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // Add any alternate packages
    //

    if (pszAlternate != NULL)
    {
        pszScan = pszAlternate;

        while (*pszScan)
        {
            ppszPackages[iPackage++] = pszScan;
            while (*pszScan++);
        }
    }

    ppszPackages[iPackage] = NULL;

    //
    // Note:  we don't allocate one extra, since we don't actually include
    // the MSV package name here (we simulate the package in msvlayer.c)
    //

    ppszOldPkgs = (PWSTR *)LsapAllocateLsaHeap((cOldPkgs+1) * sizeof(PWSTR));
    if (!ppszOldPkgs)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    iPackage = 0;
    if (pszOldPkgs != NULL)
    {
        pszScan = pszOldPkgs;


        while (*pszScan)
        {
            ppszOldPkgs[iPackage++] = pszScan;
            while (*pszScan++);
        }
    }

    cOldPkgs = iPackage;
    ppszOldPkgs[iPackage] = NULL;

    return(S_OK);

}

BOOL
AddPackageToRegistry(
    PSECURITY_STRING    Package
    )
{
    PWSTR   Buffer;
    DWORD   Length;
    DWORD   Type;
    int     err;
    HKEY    hKey;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        szLsaPath,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey );

    if ( err )
    {
        return( FALSE );
    }

    Length = 0;

    err = RegQueryValueEx(  hKey,
                            szOthersValue,
                            0,
                            &Type,
                            NULL,
                            &Length );

    Buffer = (PWSTR) LsapAllocateLsaHeap( Length + Package->Length + 2 );

    if ( !Buffer )
    {
        RegCloseKey( hKey );

        return FALSE ;
    }

    RegQueryValueEx(    hKey,
                        szOthersValue,
                        0,
                        &Type,
                        (PUCHAR) Buffer,
                        &Length );

    CopyMemory( &Buffer[Length + 1],
                Package->Buffer,
                Package->Length + 2 );

    Length = Length + Package->Length + 2;

    RegSetValueEx(  hKey,
                    szOthersValue,
                    0,
                    REG_MULTI_SZ,
                    (PUCHAR) Buffer,
                    Length );

    RegCloseKey( hKey );

    return( TRUE );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\neglsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       neglsa.cxx
//
//  Contents:   General (both win9x and nt) functions
//
//  Classes:
//
//  Functions:
//
//  History:    02-09-00   RichardW     Created - split from negotiat.cxx
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#endif // WIN32_CHICAGO

extern "C"
{
#include <align.h>
#include <lm.h>
#include <dsgetdc.h>
#include <cryptdll.h>
#include <netlib.h>
#include <spmgr.h>
#include "sesmgr.h"
#include "spinit.h"
}

#include "negotiat.hxx"

#include <stdio.h>


GUID         GUID_NULL = {0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
TOKEN_SOURCE LsapTokenSource = {"LSA", 0};

//
// Hardcoded english strings for LocalService and NetworkService
// since the account names may come from the registry (which isn't
// localized).
//

#define  LOCALSERVICE_NAME    L"LocalService"
#define  NETWORKSERVICE_NAME  L"NetworkService"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

UNICODE_STRING  LocalServiceName = { sizeof(LOCALSERVICE_NAME) - 2,
                                     sizeof(LOCALSERVICE_NAME),
                                     LOCALSERVICE_NAME };

UNICODE_STRING  NetworkServiceName = { sizeof(NETWORKSERVICE_NAME) - 2,
                                       sizeof(NETWORKSERVICE_NAME),
                                       NETWORKSERVICE_NAME };

UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - 2,
                                    sizeof(NTAUTHORITY_NAME),
                                    NTAUTHORITY_NAME };
HANDLE NegEventLogHandle = NULL ;
ULONG NegEventLogLevel = 3 ;

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }

#define MAX_EVENT_STRINGS   8


extern SECPKG_PRIMARY_CRED       NegPrimarySystemCredentials;

//
// Local function prototypes
//
NTSTATUS
NegpMakeServiceToken(
    IN ULONG ulAccountId,
    OUT PLUID pLogonId,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    );

BOOL
NegpIsLocalOrNetworkService(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PULONG pulAccountId
    );


VOID
NegpReportEvent(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN NTSTATUS Status,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    BOOLEAN Allocated[ MAX_EVENT_STRINGS ] = { 0 };
    WCHAR StatusString[ MAX_PATH ];
    WCHAR FinalStatus[ MAX_PATH ];
    HANDLE Dll ;
    BOOL FreeDll = FALSE ;
    DWORD rv;

    if (NegEventLogHandle == NULL )
    {
        //
        // only log identical event once per hour.
        // note that LSA doesn't cleanup this 'handle' during shutdown,
        // to avoid preventing log failures during shutdown.
        //

        NegEventLogHandle = NetpEventlogOpen( L"LSASRV", 60000*60 );

        if ( NegEventLogHandle == NULL )
        {
            return ;
        }

    }


    //
    // We're not supposed to be logging this, so nuke it
    //
    if ((NegEventLogLevel & (1 << EventType)) == 0)
    {
        return ;
    }

    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) {

        PUNICODE_STRING String = va_arg( arglist, PUNICODE_STRING );

        //
        // Make sure strings are NULL-terminated.  Do it in place for
        // those strings whose buffers can accomodate an additional character,
        // and allocate memory for the rest.
        //

        if ( String->MaximumLength > String->Length ) {

            Strings[i] = String->Buffer;

        } else {

            Strings[i] = ( PWSTR )LsapAllocatePrivateHeap( String->Length + sizeof( WCHAR ));

            if ( Strings[i] == NULL ) {

                goto Cleanup;
            }

            Allocated[i] = TRUE;

            RtlCopyMemory( Strings[i], String->Buffer, String->Length );
        }

        Strings[i][String->Length / sizeof( WCHAR )] = L'\0';

    }

    if ( Status != 0 )
    {
        static HMODULE NtDll;
        static HMODULE Kernel32;

        //
        // Map the status code:
        //

        //
        // The value "type" is not known.  Try and figure out what it
        // is.
        //

        if ( (Status & 0xC0000000) == 0xC0000000 )
        {
            //
            // Easy:  NTSTATUS failure case
            //

            if( NtDll == NULL )
            {
                NtDll = GetModuleHandleW( L"NTDLL.DLL" );
            }

            Dll = NtDll;

        }
        else if ( ( Status & 0xF0000000 ) == 0xD0000000 )
        {
            //
            // HRESULT from NTSTATUS
            //

            if( NtDll == NULL )
            {
                NtDll = GetModuleHandleW( L"NTDLL.DLL" );
            }

            Dll = NtDll;

            Status &= 0xCFFFFFFF ;


        }
        else if ( ( Status & 0x80000000 ) == 0x80000000 )
        {
            //
            // Note, this can overlap with NTSTATUS warning area.  In that
            // case, force the NTSTATUS.
            //


            if( Kernel32 == NULL )
            {
                Kernel32 = GetModuleHandleW( L"KERNEL32.DLL" );
            }

            Dll = Kernel32;


        }
        else
        {
            //
            // Sign bit is off.  Explore some known ranges:
            //

            if ( (Status >= WSABASEERR) && (Status <= WSABASEERR + 1000 ))
            {
                Dll = LoadLibraryW( L"ws2_32.dll" );

                FreeDll = TRUE ;

            }
            else if ( ( Status >= NERR_BASE ) && ( Status <= MAX_NERR ) )
            {
                Dll = LoadLibraryW( L"netmsg.dll" );

                FreeDll = TRUE ;

            }
            else
            {
                if( Kernel32 == NULL )
                {
                    Kernel32 = GetModuleHandleW( L"KERNEL32.DLL" );
                }

                Dll = Kernel32;

            }

        }

        if (!FormatMessage(  
                        FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_HMODULE,
                        Dll,
                        Status,
                        0,
                        StatusString,
                        MAX_PATH,
                        NULL ) )
        {
            StatusString[0] = L' ';
            StatusString[1] = L'\0';
        }

        if ( Status < 0 )
        {
            _snwprintf( FinalStatus, MAX_PATH, L"\"%ws (%#x)\"", StatusString, Status );
        }
        else
        {
            _snwprintf( FinalStatus, MAX_PATH, L"\"%ws (%#x, %d)\"", StatusString, Status, Status );
        }

        if ( NumberOfStrings < MAX_EVENT_STRINGS )
        {
            Strings[ NumberOfStrings++ ] = FinalStatus ;
        }

    }


    //
    // Report the event to the eventlog service
    //

    NetpEventlogWriteEx(
                    NegEventLogHandle,
                    EventType,
                    Category,
                    EventId,
                    NumberOfStrings,
                    0,
                    Strings,
                    NULL
                    );

Cleanup:

    for ( i = 0 ; i < NumberOfStrings ; i++ ) {

        if ( Allocated[i] ) {

            LsapFreePrivateHeap( Strings[i] );
        }
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   NegLsaPolicyChangeCallback
//
//  Synopsis:   Called by the policy engine in the LSA when local policy changes,
//              allowing us to update our state about the machine account, etc.
//
//  Arguments:  ChangedInfoClass    - Class of policy that changed
//
//  History:    2-9-00   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NTAPI
NegLsaPolicyChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    PLSAPR_POLICY_INFORMATION Policy = NULL ;
    NTSTATUS Status ;
    GUID GuidNull = GUID_NULL ;
    PLSAP_LOGON_SESSION LogonSession = NULL ;
    BOOL Uplevel ;

    //
    // Right now, only domain information is interesting
    //

    if ( ChangedInfoClass != PolicyNotifyDnsDomainInformation )
    {
        return ;
    }

    DebugLog(( DEB_TRACE_NEG, "Domain change, updating state\n" ));

    //
    // Reset the trust list.  The next time someone asks for the trust
    // list, it will have expired and they will get a fresh one.
    //

    NegTrustTime.QuadPart = 0 ;


    //
    // Obtain the new policy settings
    //

    Status = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // If the domain has a GUID, then it is an uplevel domain
        //

        if ( Policy->PolicyDnsDomainInfo.DomainGuid == GuidNull )
        {
            Uplevel = FALSE ;
        }
        else
        {
            Uplevel = TRUE ;

        }

        //
        // Done with the policy info
        //

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );


        NegUplevelDomain = Uplevel ;

        //
        // Update the package ID for the local system logon session
        // Note, any additional special logon sessions will need to be
        // updated as well.
        //

        LogonSession = LsapLocateLogonSession( &SystemLogonId );

        if ( LogonSession )
        {
            if ( Uplevel )
            {
                LogonSession->CreatingPackage = NegPackageId ;
            }
            else
            {
                LogonSession->CreatingPackage = NtlmPackageId ;
            }
            LsapReleaseLogonSession( LogonSession );
        }

    }

    {
    ULONG Size;

    static WCHAR NegNetbiosComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    static WCHAR NegDnsComputerName[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];

    //
    // refresh the computer names.
    // note we could avoid taking the lock around these calls if we dyna-alloc'd
    // and freed the existing buffers.  We don't expect this path to be hit often,
    // so avoid the hassle.
    //

    NegWriteLockComputerNames();

    Size = sizeof(NegDnsComputerName) / sizeof(WCHAR);

    //
    // Note, if this fails, it's ok.  We just won't be able to make
    // some optimizations later.
    //

    if(!GetComputerNameExW(
                    ComputerNamePhysicalDnsFullyQualified,
                    NegDnsComputerName,
                    &Size
                    ))
    {
        NegDnsComputerName[ 0 ] = L'\0';
    }

    RtlInitUnicodeString( &NegDnsComputerName_U, NegDnsComputerName );


    Size = sizeof(NegNetbiosComputerName) / sizeof(WCHAR);

    if(!GetComputerNameExW(
                    ComputerNamePhysicalNetBIOS,
                    NegNetbiosComputerName,
                    &Size
                    ))
    {
        NegNetbiosComputerName[ 0 ] = L'\0';
    }


    RtlInitUnicodeString( &NegNetbiosComputerName_U, NegNetbiosComputerName );

    NegUnlockComputerNames();

    }


}

//+---------------------------------------------------------------------------
//
//  Function:   NegParamChange
//
//  Synopsis:   Called by LSA whenever the LSA registry key changes
//
//  Arguments:  [p] --
//
//  History:    5-11-00   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
NegParamChange(
    PVOID   p
    )
{
    NTSTATUS Status ;
    PSECPKG_EVENT_NOTIFY Notify;
    HKEY LsaKey ;


    Notify = (PSECPKG_EVENT_NOTIFY) p;

    if ( Notify->EventClass != NOTIFY_CLASS_REGISTRY_CHANGE )
    {
        return( 0 );
    }

    if ( RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                0,
                KEY_READ,
                &LsaKey ) == 0 )
    {
        NegpReadRegistryParameters( LsaKey );

        RegCloseKey( LsaKey );
    }

    return 0 ;

}

//+---------------------------------------------------------------------------
//
//  Function:   NegEnumPackagePrefixesCall
//
//  Synopsis:   LsaCallPackage routine to identify the prefxes (or OIDs) for
//              all the packages, for SASL support.
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NegEnumPackagePrefixesCall(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    UCHAR PrefixBuffer[ NEGOTIATE_MAX_PREFIX ];
    NTSTATUS Status ;
    PNEGOTIATE_PACKAGE_PREFIXES Prefixes ;
    PNEGOTIATE_PACKAGE_PREFIX Prefix ;
    PNEGOTIATE_PACKAGE_PREFIX_WOW PrefixWow ;
    ULONG PackageCount ;
    BOOL WowClient = FALSE ;
    PNEG_PACKAGE    Package ;
    PLIST_ENTRY Scan ;
    SECPKG_CALL_INFO CallInfo ;
    ULONG Size ;

    LsapGetCallInfo( &CallInfo );

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        WowClient = TRUE;
    }

    NegReadLockList();

    Size = sizeof( NEGOTIATE_PACKAGE_PREFIXES ) +
           sizeof( NEGOTIATE_PACKAGE_PREFIX ) * ( NegPackageCount + 1 );

    Prefixes = (PNEGOTIATE_PACKAGE_PREFIXES) LsapAllocatePrivateHeap( Size );

    if ( !Prefixes )
    {
        NegUnlockList();

        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Prefixes->MessageType = NegEnumPackagePrefixes ;
    Prefixes->Offset = sizeof( NEGOTIATE_PACKAGE_PREFIXES );

    //
    // We're going to do one or the other, but initializing them both
    // makes the compiler happier.
    //

    Prefix = (PNEGOTIATE_PACKAGE_PREFIX) ( Prefixes + 1 );

    PrefixWow = (PNEGOTIATE_PACKAGE_PREFIX_WOW) ( Prefixes + 1);

    if ( WowClient )
    {
        PrefixWow->PackageId = (ULONG) NegPackageId ;
        PrefixWow->PrefixLen = sizeof( NegSpnegoMechEncodedOid );
        PrefixWow->PackageDataA = NULL ;
        PrefixWow->PackageDataW = NULL ;
        RtlCopyMemory( PrefixWow->Prefix,
                       NegSpnegoMechEncodedOid,
                       sizeof( NegSpnegoMechEncodedOid ) );

        PrefixWow++ ;

    }
    else
    {
        Prefix->PackageId = NegPackageId ;
        Prefix->PrefixLen = sizeof( NegSpnegoMechEncodedOid );
        Prefix->PackageDataA = NULL ;
        Prefix->PackageDataW = NULL ;
        RtlCopyMemory( Prefix->Prefix,
                       NegSpnegoMechEncodedOid,
                       sizeof( NegSpnegoMechEncodedOid ) );

        Prefix++ ;

    }

    PackageCount = 1 ;
    Scan = NegPackageList.Flink ;

    while ( Scan != &NegPackageList )
    {
        Package = CONTAINING_RECORD( Scan, NEG_PACKAGE, List );

        if ( !WowClient )
        {
            Prefix->PackageId = Package->LsaPackage->dwPackageID ;
            Prefix->PrefixLen = Package->PrefixLen ;
            Prefix->PackageDataA = NULL ;
            Prefix->PackageDataW = NULL ;
            RtlCopyMemory( Prefix->Prefix,
                           Package->Prefix,
                           Package->PrefixLen );

            Prefix++ ;
            PackageCount++ ;
        }
        else
        {
            if ( Package->LsaPackage->fPackage & SP_WOW_SUPPORT )
            {
                PrefixWow->PackageId = (ULONG) Package->LsaPackage->dwPackageID ;
                PrefixWow->PrefixLen = Package->PrefixLen ;
                PrefixWow->PackageDataA = NULL ;
                PrefixWow->PackageDataW = NULL ;
                RtlCopyMemory( PrefixWow->Prefix,
                               Package->Prefix,
                               Package->PrefixLen );

                PrefixWow++ ;
                PackageCount++ ;

            }
        }

        Scan = Scan->Flink ;
    }


    NegUnlockList();

    //
    // Set the final count of packages:
    //

    Prefixes->PrefixCount = PackageCount ;

    Status = LsapAllocateClientBuffer(
                NULL,
                Size,
                ProtocolReturnBuffer );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsapCopyToClient(
                    Prefixes,
                    *ProtocolReturnBuffer,
                    Size );

        *ReturnBufferLength = Size ;
    }

    LsapFreePrivateHeap( Prefixes );

    return Status ;
}

NTSTATUS
NegGetCallerNameCall(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PNEGOTIATE_CALLER_NAME_REQUEST Request ;
    PNEGOTIATE_CALLER_NAME_RESPONSE Response ;
    PNEGOTIATE_CALLER_NAME_RESPONSE_WOW ResponseWow ;
    SECPKG_CLIENT_INFO ClientInfo ;
    SECPKG_CALL_INFO CallInfo ;
    NTSTATUS Status ;
    PNEG_LOGON_SESSION LogonSession ;
    ULONG ClientSize ;
    PUCHAR Where ;
    PVOID ClientBuffer ;
    BOOL ReCheckAccess = FALSE ;

    *ProtocolReturnBuffer = NULL ;
    *ReturnBufferLength = 0 ;
    *ProtocolStatus = 0 ;

    if ( SubmitBufferLength != sizeof( NEGOTIATE_CALLER_NAME_REQUEST ) )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    Request = (PNEGOTIATE_CALLER_NAME_REQUEST) ProtocolSubmitBuffer ;

    Status = LsapGetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    LsapGetCallInfo( &CallInfo );

    if ( RtlIsZeroLuid( &Request->LogonId ) )
    {
        Request->LogonId = ClientInfo.LogonId ;
    }
    else
    {
        if ( !RtlEqualLuid( &ClientInfo.LogonId, &Request->LogonId ) )
        {
            ReCheckAccess = TRUE ;
        }
    }

    LogonSession = NegpLocateLogonSession( &Request->LogonId );

    if ( LogonSession )
    {

        if ( ReCheckAccess )
        {
            if ( !RtlEqualLuid( &ClientInfo.LogonId, &LogonSession->ParentLogonId ) )
            {
                Status = STATUS_ACCESS_DENIED ;

                goto AccessDeniedError ;
            }
        }

        if ( LogonSession->AlternateName.Buffer == NULL )
        {
            //
            // No alternate ID
            //

            Status = STATUS_NO_SUCH_LOGON_SESSION ;

            goto AccessDeniedError ;
        }

        ClientSize = sizeof( NEGOTIATE_CALLER_NAME_RESPONSE ) +
                      LogonSession->AlternateName.Length + sizeof( WCHAR );

        Response = (PNEGOTIATE_CALLER_NAME_RESPONSE) LsapAllocatePrivateHeap( ClientSize );

        if ( Response )
        {
            ClientBuffer = LsapClientAllocate( ClientSize );

            if ( ClientBuffer )
            {
                Where = (PUCHAR) ClientBuffer + sizeof( NEGOTIATE_CALLER_NAME_RESPONSE ) ;

                //
                // If a WOW client, copy these to the 32bit locations.  Note
                // that this will leave a "hole," but that's ok.
                //

                if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
                {
                    ResponseWow = (PNEGOTIATE_CALLER_NAME_RESPONSE_WOW) Response ;
                    ResponseWow->MessageType = NegGetCallerName ;
                    ResponseWow->CallerName = PtrToUlong(Where) ;
                }
                else
                {
                    Response->MessageType = NegGetCallerName ;
                    Response->CallerName = (PWSTR) Where ;
                }
                RtlCopyMemory( (Response + 1),
                               LogonSession->AlternateName.Buffer,
                               LogonSession->AlternateName.Length );

                *ProtocolReturnBuffer = ClientBuffer ;
                *ReturnBufferLength = ClientSize ;
                *ProtocolStatus = 0 ;
                Status = LsapCopyToClient( Response,
                                           ClientBuffer,
                                           ClientSize ) ;
            }
            else
            {
                Status = STATUS_NO_MEMORY ;
            }

            LsapFreePrivateHeap( Response );

        }

AccessDeniedError:

        NegpDerefLogonSession( LogonSession );

    }
    else
    {

        Status = STATUS_NO_SUCH_LOGON_SESSION ;
    }


    *ProtocolStatus = Status ;

    return STATUS_SUCCESS ;
}



PNEG_LOGON_SESSION
NegpBuildLogonSession(
    PLUID LogonId,
    ULONG_PTR LogonPackage,
    ULONG_PTR DefaultPackage
    )
{
    PNEG_LOGON_SESSION LogonSession ;

    LogonSession = (PNEG_LOGON_SESSION) LsapAllocatePrivateHeap( sizeof( NEG_LOGON_SESSION ) );

    if ( LogonSession )
    {
        LogonSession->LogonId = *LogonId ;
        LogonSession->CreatingPackage = LogonPackage ;
        LogonSession->DefaultPackage = DefaultPackage ;
        LogonSession->RefCount = 2 ;

        RtlEnterCriticalSection( &NegLogonSessionListLock );

        InsertHeadList( &NegLogonSessionList, &LogonSession->List );

        RtlLeaveCriticalSection( &NegLogonSessionListLock );

    }

    return LogonSession ;
}

VOID
NegpDerefLogonSession(
    PNEG_LOGON_SESSION LogonSession
    )
{
    BOOL FreeIt = FALSE ;

    RtlEnterCriticalSection( &NegLogonSessionListLock );

    LogonSession->RefCount-- ;

    if ( LogonSession->RefCount == 0 )
    {
        RemoveEntryList( &LogonSession->List );

        FreeIt = TRUE ;
    }

    RtlLeaveCriticalSection( &NegLogonSessionListLock );

    if ( FreeIt )
    {
        if ( LogonSession->AlternateName.Buffer )
        {
            LsapFreePrivateHeap( LogonSession->AlternateName.Buffer );
        }

        LsapFreePrivateHeap( LogonSession );
    }

}

VOID
NegpDerefLogonSessionById(
    PLUID LogonId
    )
{
    BOOL FreeIt = FALSE ;
    PLIST_ENTRY Scan ;
    PNEG_LOGON_SESSION LogonSession = NULL;

    RtlEnterCriticalSection( &NegLogonSessionListLock );

    Scan = NegLogonSessionList.Flink ;

    while ( Scan != &NegLogonSessionList )
    {
        LogonSession = CONTAINING_RECORD( Scan, NEG_LOGON_SESSION, List );

        if ( RtlEqualLuid( LogonId, &LogonSession->LogonId ) )
        {
            LogonSession->RefCount -- ;

            if ( LogonSession->RefCount == 0 )
            {
                RemoveEntryList( &LogonSession->List );

                FreeIt = TRUE ;

            }

            break;
        }

        LogonSession = NULL ;

        Scan = Scan->Flink ;
    }

    RtlLeaveCriticalSection( &NegLogonSessionListLock );


    if ( FreeIt )
    {
        DsysAssert( LogonSession != NULL );

        if ( LogonSession->AlternateName.Buffer )
        {
            LsapFreePrivateHeap( LogonSession->AlternateName.Buffer );
        }

        LsapFreePrivateHeap( LogonSession );
    }

}

PNEG_LOGON_SESSION
NegpLocateLogonSession(
    PLUID LogonId
    )
{
    PLIST_ENTRY Scan ;
    PNEG_LOGON_SESSION LogonSession = NULL;

    RtlEnterCriticalSection( &NegLogonSessionListLock );

    Scan = NegLogonSessionList.Flink ;

    while ( Scan != &NegLogonSessionList )
    {
        LogonSession = CONTAINING_RECORD( Scan, NEG_LOGON_SESSION, List );

        if ( RtlEqualLuid( LogonId, &LogonSession->LogonId ) )
        {
            break;
        }

        LogonSession = NULL ;

        Scan = Scan->Flink ;
    }

    if ( LogonSession )
    {
        LogonSession->RefCount++ ;
    }

    RtlLeaveCriticalSection( &NegLogonSessionListLock );

    return LogonSession ;
}





NTSTATUS
NTAPI
NegpMapLogonRequest(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PMSV1_0_INTERACTIVE_LOGON * LogonInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PMSV1_0_INTERACTIVE_LOGON Authentication = NULL;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;


    //
    // Ensure this is really an interactive logon.
    //

    Authentication =
        (PMSV1_0_INTERACTIVE_LOGON) ProtocolSubmitBuffer;

    if ( Authentication->MessageType != MsV1_0InteractiveLogon ) {
        DebugLog(( DEB_ERROR, "Neg:  Bad Validation Class %d\n",
                   Authentication->MessageType));
        Status = STATUS_BAD_VALIDATION_CLASS;
        goto Cleanup;
    }



    //
    // If the password length is greater than 255 (i.e., the
    // upper byte of the length is non-zero) then the password
    // has been run-encoded for privacy reasons.  Get the
    // run-encode seed out of the upper-byte of the length
    // for later use.
    //
    //



    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)
                    &Authentication->Password.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    //
    // Enforce length restrictions on username and password.
    //

    if ( Authentication->UserName.Length > UNLEN ||
        Authentication->Password.Length > PWLEN ) {
        DebugLog(( DEB_ERROR, "Neg: Name or password too long\n"));
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }


    //
    // Relocate any pointers to be relative to 'Authentication'
    //

    NULL_RELOCATE_ONE( &Authentication->LogonDomainName );

    RELOCATE_ONE( &Authentication->UserName );

    NULL_RELOCATE_ONE( &Authentication->Password );

    //
    // Now decode the password, if necessary
    //

    if (Seed != 0 ) {
        __try {
            RtlRunDecodeUnicodeString( Seed, &Authentication->Password);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    *LogonInfo = Authentication ;

Cleanup:

    return Status ;

}

VOID
NegpDerefTrustList(
    PNEG_TRUST_LIST TrustList
    )
{
    RtlEnterCriticalSection( &NegTrustListLock );

    TrustList->RefCount-- ;

    if ( TrustList->RefCount == 0 )
    {
        if( NegTrustList == TrustList )
        {
            NegTrustList = NULL;
        }

        RtlLeaveCriticalSection( &NegTrustListLock );

        NetApiBufferFree( TrustList->Trusts );

        LsapFreePrivateHeap( TrustList );

        return;
    }

    RtlLeaveCriticalSection( &NegTrustListLock );

}

PNEG_TRUST_LIST
NegpGetTrustList(
    VOID
    )
{
    PDS_DOMAIN_TRUSTS Trusts = NULL;
    DWORD TrustCount ;
    PNEG_TRUST_LIST TrustList = NULL ;
    DWORD NetStatus ;
    LARGE_INTEGER Now ;

    BOOLEAN TrustListLocked = TRUE;

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );


    RtlEnterCriticalSection( &NegTrustListLock );

    if ( Now.QuadPart > NegTrustTime.QuadPart + FIFTEEN_MINUTES )
    {
        if( NegTrustList != NULL && NegTrustList->RefCount == 1 )
        {
            NegpDerefTrustList( NegTrustList );
            NegTrustList = NULL;
        }
    }



    if( NegTrustList != NULL )
    {
        TrustList = NegTrustList ;
        TrustList->RefCount++ ;
        goto Cleanup;
    }


    RtlLeaveCriticalSection( &NegTrustListLock );
    TrustListLocked = FALSE;


    NetStatus = DsEnumerateDomainTrustsW( NULL,
                                          DS_DOMAIN_IN_FOREST |
                                            DS_DOMAIN_PRIMARY,
                                          &Trusts,
                                          &TrustCount );

    if ( NetStatus != 0 )
    {
        goto Cleanup;
    }



    TrustList = (PNEG_TRUST_LIST) LsapAllocatePrivateHeap( sizeof( NEG_TRUST_LIST ) );

    if( TrustList == NULL )
    {
        goto Cleanup;
    }

    TrustList->RefCount = 2 ;
    TrustList->TrustCount = TrustCount ;
    TrustList->Trusts = Trusts ;



    RtlEnterCriticalSection( &NegTrustListLock );
    TrustListLocked = TRUE;

    if( NegTrustList != NULL )
    {
        PNEG_TRUST_LIST FreeTrustList = TrustList;

        TrustList = NegTrustList ;
        TrustList->RefCount++ ;

        RtlLeaveCriticalSection( &NegTrustListLock );
        TrustListLocked = FALSE;

        LsapFreePrivateHeap( FreeTrustList );
        goto Cleanup;
    }

    Trusts = NULL;

    NegTrustList = TrustList ;
    NegTrustTime = Now ;

Cleanup:

    if( TrustListLocked )
    {
        RtlLeaveCriticalSection( &NegTrustListLock );
    }

    if( Trusts != NULL )
    {
        NetApiBufferFree( Trusts );
    }

    return TrustList ;
}


NEG_DOMAIN_TYPES
NegpIsUplevelDomain(
    PLUID LogonId,
    SECURITY_LOGON_TYPE LogonType,
    PUNICODE_STRING Domain
    )
{
    PNEG_TRUST_LIST TrustList ;
    UNICODE_STRING String ;
    ULONG i ;
    BOOL IsUplevel = FALSE ;
    LONG Error ;
    PDOMAIN_CONTROLLER_INFOW Info ;

    UNREFERENCED_PARAMETER(LogonId);


    //
    // Case #1.  Local logons are not uplevel, and should be allowed to
    // use NTLM right off the bat.  Therefore, return false
    //

    if ( RtlEqualUnicodeString(
            Domain,
            &MachineName,
            TRUE ) )
    {
        return NegLocalDomain;
    }

    if ( LogonType == CachedInteractive )
    {
        return NegUpLevelDomain;
    }



    //
    // Case #2.  We logged on to a domain, but we need to check if it is
    // an uplevel domain in our forest.  If it is, then return true, otherwise
    // it's not an uplevel domain and NTLM is acceptable.  If we can't obtain the
    // trust list, assume downlevel.
    //

    TrustList = NegpGetTrustList();

    if ( TrustList )
    {
        for ( i = 0 ; i < TrustList->TrustCount ; i++ )
        {
            RtlInitUnicodeString( &String, TrustList->Trusts[i].NetbiosDomainName );

            if ( RtlEqualUnicodeString( Domain,
                                        &String,
                                        TRUE ) )
            {
                //
                // Hit, check it
                //

                if ( ( TrustList->Trusts[i].DnsDomainName != NULL ) &&
                     ( TrustList->Trusts[i].Flags & DS_DOMAIN_IN_FOREST ) )
                {
                    IsUplevel = TRUE ;
                    break;
                }

            }
        }

        NegpDerefTrustList( TrustList );

    }

    if ( IsUplevel )
    {
        return NegUpLevelDomain ;
    }

    //
    // Case #3 - if this is an uplevel domain we live in, then the answer returned
    // by netlogon is authoritative:
    //
    if ( NegUplevelDomain )
    {
        return NegDownLevelDomain ;
    }

    //
    // Case #4 - if we are living in a downlevel domain, netlogon won't know if the domain
    // we just talked to is uplevel or downlevel.  So, we need to figure out directly.
    //

    Error = DsGetDcNameW(
                NULL,
                Domain->Buffer,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED,
                &Info );

    if ( Error == 0 )
    {
        IsUplevel = TRUE ;
        NetApiBufferFree( Info );
    }
    else
    {
        IsUplevel = FALSE ;
    }

    return ( IsUplevel ? NegUpLevelTrustedDomain : NegDownLevelDomain );

}



//+-------------------------------------------------------------------------
//
//  Function:   NegpCloneLogonSession
//
//  Synopsis:   Handles a NewCredentials type of logon.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
NegpCloneLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID NewLogonId,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status ;
    HANDLE hToken ;
    UCHAR   SmallBuffer[ 128 ];
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL ;
    PTOKEN_USER User = NULL ;
    PTOKEN_GROUPS Groups = NULL ;
    PTOKEN_GROUPS FinalGroups = NULL ;
    PTOKEN_PRIMARY_GROUP PrimaryGroup = NULL  ;
    TOKEN_STATISTICS TokenStats ;
    PLSAP_LOGON_SESSION LogonSession ;
    PNEG_LOGON_SESSION NegLogonSession ;
    LUID LogonId ;
    LUID LocalServiceLuid = LOCALSERVICE_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;
    LUID LocalSystemLuid = SYSTEM_LUID;
    BOOL fFilterGroups;
    PMSV1_0_INTERACTIVE_LOGON Authentication = NULL;
    DWORD Size ;
    ULONG i ;
    ULONG j ;
    PWSTR AltName, AltNameScan ;

    Status = LsapImpersonateClient();

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // Open the token for the lifetime of this call.  This makes sure that the
    // client doesn't die on us, taking out the logon session (potentially).
    //

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hToken );

    RevertToSelf();

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // Grovel the token, and build up a list of groups that we will use for
    // the new token.  Only non-builtin groups will be used.
    //

    TokenInfo = (PLSA_TOKEN_INFORMATION_V1) LsapAllocateLsaHeap(
                                    sizeof( LSA_TOKEN_INFORMATION_V1) );

    if ( !TokenInfo )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    Status = NtQueryInformationToken(
                hToken,
                TokenStatistics,
                &TokenStats,
                sizeof( TokenStats ),
                &Size );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    TokenInfo->ExpirationTime = TokenStats.ExpirationTime ;

    User = (PTOKEN_USER) SmallBuffer ;
    Size = sizeof( SmallBuffer );

    Status = NtQueryInformationToken(
                hToken,
                TokenUser,
                User,
                Size,
                &Size );

    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        User = (PTOKEN_USER) LsapAllocatePrivateHeap( Size );

        if ( User )
        {
            Status = NtQueryInformationToken(
                        hToken,
                        TokenUser,
                        User,
                        Size,
                        &Size );
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }

    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }


    TokenInfo->User.User.Attributes = 0 ;
    TokenInfo->User.User.Sid = LsapAllocateLsaHeap( RtlLengthSid( User->User.Sid ) );

    if ( TokenInfo->User.User.Sid )
    {
        RtlCopyMemory( TokenInfo->User.User.Sid,
                       User->User.Sid,
                       RtlLengthSid( User->User.Sid ) );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    if ( User != (PTOKEN_USER) SmallBuffer )
    {
        LsapFreePrivateHeap( User );
    }

    User = NULL ;

    Status = NtQueryInformationToken(
                    hToken,
                    TokenGroups,
                    NULL,
                    0,
                    &Size );

    if ( ( Status != STATUS_BUFFER_OVERFLOW ) &&
         ( Status != STATUS_BUFFER_TOO_SMALL ) )
    {
        goto Clone_Exit ;
    }

    Groups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( Size );

    if ( !Groups )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    Status = NtQueryInformationToken(
                    hToken,
                    TokenGroups,
                    Groups,
                    Size,
                    &Size );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // Grovel through the group list, and ditch those we don't care about.
    // i always travels ahead of j.  Skip groups that have one or two RIDs,
    // because those are the builtin ones.
    //

    FinalGroups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( sizeof( TOKEN_GROUPS ) +
                                                       Groups->GroupCount * sizeof( SID_AND_ATTRIBUTES ) );

    if ( !FinalGroups )
    {
        goto Clone_Exit ;
    }

    //
    // Don't filter out groups for tokens where the LSA has hardcoded info on
    // how to build the token.  If we filter in those cases, we strip out SIDs
    // that won't be replaced by the LSA policy/filter routines later on.
    //

    fFilterGroups = !RtlEqualLuid(&TokenStats.AuthenticationId, &LocalSystemLuid) &&
                    !RtlEqualLuid(&TokenStats.AuthenticationId, &LocalServiceLuid) &&
                    !RtlEqualLuid(&TokenStats.AuthenticationId, &NetworkServiceLuid);

    for ( i = 0, j = 0  ; i < Groups->GroupCount ; i++ )
    {
        if ( !fFilterGroups || *RtlSubAuthorityCountSid( Groups->Groups[ i ].Sid ) > 2 )
        {
            FinalGroups->Groups[ j ].Attributes = Groups->Groups[ i ].Attributes ;
            Status = LsapDuplicateSid2( &FinalGroups->Groups[ j ].Sid,
                                       Groups->Groups[ i ].Sid );
            j++ ;

            if( !NT_SUCCESS(Status) )
            {
                break;
            }
        }

    }

    FinalGroups->GroupCount = j ;

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }


    //
    // whew.  Set this in the token info, and null out the other pointer
    // so we don't free it inadvertantly.
    //

    TokenInfo->Groups = FinalGroups ;

    FinalGroups = NULL ;

    //
    // Determine the primary group:
    //


    PrimaryGroup = (PTOKEN_PRIMARY_GROUP) SmallBuffer ;
    Size = sizeof( SmallBuffer );

    Status = NtQueryInformationToken(
                hToken,
                TokenPrimaryGroup,
                PrimaryGroup,
                Size,
                &Size );

    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        PrimaryGroup = (PTOKEN_PRIMARY_GROUP) LsapAllocatePrivateHeap( Size );

        Status = NtQueryInformationToken(
                    hToken,
                    TokenPrimaryGroup,
                    PrimaryGroup,
                    Size,
                    &Size );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    TokenInfo->PrimaryGroup.PrimaryGroup = LsapAllocateLsaHeap( RtlLengthSid( PrimaryGroup->PrimaryGroup ) );

    if ( TokenInfo->PrimaryGroup.PrimaryGroup )
    {
        RtlCopyMemory( TokenInfo->PrimaryGroup.PrimaryGroup,
                       PrimaryGroup->PrimaryGroup,
                       RtlLengthSid( PrimaryGroup->PrimaryGroup ) );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    if ( PrimaryGroup != (PTOKEN_PRIMARY_GROUP) SmallBuffer )
    {
        LsapFreePrivateHeap( PrimaryGroup );
    }

    PrimaryGroup = NULL ;

    //
    // Almost there -- now dupe the privileges
    //

    TokenInfo->Privileges = NULL ;

    Size = 0;

    Status = NtQueryInformationToken(
                hToken,
                TokenPrivileges,
                TokenInfo->Privileges,
                Size,
                &Size );

    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        TokenInfo->Privileges = (PTOKEN_PRIVILEGES) LsapAllocateLsaHeap(Size);

        if (TokenInfo->Privileges == NULL)
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            Status = NtQueryInformationToken(
                        hToken,
                        TokenPrivileges,
                        TokenInfo->Privileges,
                        Size,
                        &Size);
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit;
    }


    //
    // Ok, we have completed the Token Information.  Now, we need to parse
    // the supplied buffer to come up with creds for the other packages, since
    // that's what this is all about
    //

    Status = NegpMapLogonRequest(
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferSize,
                    &Authentication );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // Stuff the names:
    //

    *AccountName = (PUNICODE_STRING) LsapAllocateLsaHeap( sizeof( UNICODE_STRING ) );

    if ( ! ( *AccountName ) )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    *AuthenticatingAuthority = (PUNICODE_STRING) LsapAllocateLsaHeap( sizeof( UNICODE_STRING ) );

    if ( ! ( *AuthenticatingAuthority ) )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    *MachineName = (PUNICODE_STRING) LsapAllocateLsaHeap( sizeof( UNICODE_STRING ) );

    if ( ! ( *MachineName ) )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    //
    // Tokens that the LSA normally constructs (SYSTEM, LocalService, NetworkService)
    // have special names for returned as part of SID --> name lookups that don't
    // necessarily match what's in the token as the account/authority names.  Cruft
    // up the new token with these special names instead of the standard ones.
    //

    if (fFilterGroups)
    {
        Status = LsapGetLogonSessionAccountInfo(
                    &TokenStats.AuthenticationId,
                    (*AccountName),
                    (*AuthenticatingAuthority) );
    }
    else
    {
        LSAP_WELL_KNOWN_SID_INDEX dwIndex = LsapLocalSystemSidIndex;

        if (RtlEqualLuid(&TokenStats.AuthenticationId, &LocalServiceLuid))
        {
            dwIndex = LsapLocalServiceSidIndex;
        }
        else if (RtlEqualLuid(&TokenStats.AuthenticationId, &NetworkServiceLuid))
        {
            dwIndex = LsapNetworkServiceSidIndex;
        }

        Status = LsapDuplicateString(*AccountName,
                                     LsapDbWellKnownSidName(dwIndex));

        if ( !NT_SUCCESS( Status ) )
        {
            goto Clone_Exit ;
        }

        Status = LsapDuplicateString(*AuthenticatingAuthority,
                                     LsapDbWellKnownSidDescription(dwIndex));
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // Construct the credential data to pass on to the other packages:
    //

    Status = LsapDuplicateString( &PrimaryCredentials->DomainName,
                                  &Authentication->LogonDomainName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateString( &PrimaryCredentials->DownlevelName,
                                  &Authentication->UserName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateString( &PrimaryCredentials->Password,
                                  &Authentication->Password );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateSid( &PrimaryCredentials->UserSid,
                               TokenInfo->User.User.Sid );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    PrimaryCredentials->Flags = PRIMARY_CRED_CLEAR_PASSWORD ;


    //
    // Let the LSA do the rest:
    //

    NtAllocateLocallyUniqueId( &LogonId );

    Status = LsapCreateLogonSession( &LogonId );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    NegLogonSession = NegpBuildLogonSession( &LogonId,
                                             NegPackageId,
                                             NegPackageId );

    if ( !NegLogonSession )
    {
        Status = STATUS_NO_MEMORY ;
        goto Clone_Exit;
    }

    AltName = (PWSTR) LsapAllocatePrivateHeap( Authentication->UserName.Length +
                                       Authentication->LogonDomainName.Length +
                                       2 * sizeof( WCHAR ) );

    if ( AltName )
    {
        AltNameScan = AltName ;
        RtlCopyMemory( AltNameScan,
                       Authentication->LogonDomainName.Buffer,
                       Authentication->LogonDomainName.Length );

        AltNameScan += Authentication->LogonDomainName.Length / sizeof(WCHAR) ;

        *AltNameScan++ = L'\\';

        RtlCopyMemory( AltNameScan,
                       Authentication->UserName.Buffer,
                       Authentication->UserName.Length );

        AltNameScan += Authentication->UserName.Length / sizeof( WCHAR ) ;

        *AltNameScan++ = L'\0';

        RtlInitUnicodeString( &NegLogonSession->AlternateName, AltName );
    }

    NegLogonSession->ParentLogonId = TokenStats.AuthenticationId ;

    NegpDerefLogonSession( NegLogonSession );

    PrimaryCredentials->LogonId = LogonId ;


    *ProfileBuffer = NULL ;

    *ProfileBufferLength = 0 ;

    *NewLogonId = LogonId ;

    *ApiSubStatus = STATUS_SUCCESS ;

    *TokenInformationType = LsaTokenInformationV1 ;

    *TokenInformation = TokenInfo ;

    TokenInfo = NULL ;

    *CachedCredentials = NULL ;


Clone_Exit:

    if ( Groups )
    {
        LsapFreePrivateHeap( Groups );
    }

    if ( FinalGroups )
    {
        LsapFreeTokenGroups( FinalGroups );
    }

    if ( TokenInfo )
    {
        if ( TokenInfo->User.User.Sid )
        {
            LsapFreeLsaHeap( TokenInfo->User.User.Sid );
        }

        if ( TokenInfo->Groups )
        {
            LsapFreeTokenGroups( TokenInfo->Groups );
        }

        if ( TokenInfo->Privileges )
        {
            LsapFreeLsaHeap( TokenInfo->Privileges );
        }

        LsapFreeLsaHeap( TokenInfo );
    }

    if ( (User != NULL) &&
         (User != (PTOKEN_USER) SmallBuffer ) )
    {
        LsapFreePrivateHeap( User );
    }

    if ( hToken != NULL )
    {
        NtClose( hToken );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( *AuthenticatingAuthority )
        {
            if ( (*AuthenticatingAuthority)->Buffer )
            {
                LsapFreeLsaHeap( (*AuthenticatingAuthority)->Buffer );
            }

            LsapFreeLsaHeap( *AuthenticatingAuthority );
            *AuthenticatingAuthority = NULL;
        }

        if ( *AccountName )
        {
            if ( (*AccountName)->Buffer )
            {
                LsapFreeLsaHeap( (*AccountName)->Buffer );
            }

            LsapFreeLsaHeap( *AccountName );
            *AccountName = NULL;
        }

        if ( *MachineName )
        {
            if ( (*MachineName)->Buffer )
            {
                LsapFreeLsaHeap( (*MachineName)->Buffer );
            }

            LsapFreeLsaHeap( *MachineName );
            *MachineName = NULL;
        }
    }

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   NegLogonUserEx2
//
//  Synopsis:   Handles service, batch, and interactive logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
NegLogonUserEx2(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID NewLogonId,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status = STATUS_NO_LOGON_SERVERS;
    PNEG_PACKAGE Package;
    PVOID LocalSubmitBuffer = NULL;
    ULONG_PTR CurrentPackageId = GetCurrentPackageId();
    PLSAP_SECURITY_PACKAGE * LogonPackages = NULL;
    PNEG_LOGON_SESSION LogonSession ;
    PWSTR AltName, AltNameScan ;
    NEG_DOMAIN_TYPES DomainType ;

    ULONG LogonPackageCount = 0;
    ULONG Index;

    if ( LogonType == NewCredentials )
    {
        return NegpCloneLogonSession(
            ProtocolSubmitBuffer,
            ClientBufferBase,
            SubmitBufferSize,
            ProfileBuffer,
            ProfileBufferLength,
            NewLogonId,
            ApiSubStatus,
            TokenInformationType,
            TokenInformation,
            AccountName,
            AuthenticatingAuthority,
            MachineName,
            PrimaryCredentials,
            CachedCredentials
            );
    }


    //
    // Allocate a local copy of the submit buffer so each package can
    // mark it up.
    //

    LocalSubmitBuffer = LsapAllocateLsaHeap(SubmitBufferSize);
    if (LocalSubmitBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }



    if ( LogonType == Service )
    {
        ULONG  ulAccountId;

        //
        // Copy the submit buffer for the package to mark up
        //

        RtlCopyMemory(
            LocalSubmitBuffer,
            ProtocolSubmitBuffer,
            SubmitBufferSize
            );

        if (NegpIsLocalOrNetworkService(
                LocalSubmitBuffer,
                ClientBufferBase,
                SubmitBufferSize,
                AccountName,
                AuthenticatingAuthority,
                MachineName,
                &ulAccountId))
        {
            Status = NegpMakeServiceToken(
                        ulAccountId,
                        NewLogonId,
                        ProfileBuffer,
                        ProfileBufferLength,
                        ApiSubStatus,
                        TokenInformationType,
                        TokenInformation,
                        AccountName,
                        AuthenticatingAuthority,
                        MachineName,
                        PrimaryCredentials,
                        CachedCredentials
                        );

            goto Cleanup;
        }
    }



    LogonPackages = (PLSAP_SECURITY_PACKAGE *) LsapAllocateLsaHeap( NegPackageCount * sizeof(PLSAP_SECURITY_PACKAGE));
    if (LogonPackages == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    NegReadLockList();

    Package = (PNEG_PACKAGE) NegPackageList.Flink ;
    while ( (PVOID) Package != (PVOID) &NegPackageList )
    {
        if (((Package->LsaPackage->fCapabilities & SECPKG_FLAG_LOGON) != 0) &&
            ((Package->Flags & NEG_PACKAGE_EXTRA_OID ) == 0 ) &&
            (Package->LsaPackage->FunctionTable.LogonUserEx2 != NULL))
        {
            LogonPackages[LogonPackageCount++] = Package->LsaPackage;
        }
        Package = (PNEG_PACKAGE) Package->List.Flink ;
    }
    NegUnlockList();

    for (Index = 0; Index < LogonPackageCount; Index++)
    {

        //
        // Cleanup the old audit strings so they don't get leaked
        // when the package re-allocates them.
        //

        if ((*MachineName) != NULL) {
            if ((*MachineName)->Buffer != NULL) {
                LsapFreeLsaHeap( (*MachineName)->Buffer );
            }
            LsapFreeLsaHeap( (*MachineName) );
            (*MachineName) = NULL;
        }
        if ((*AccountName) != NULL) {
            if ((*AccountName)->Buffer != NULL) {
                LsapFreeLsaHeap( (*AccountName)->Buffer );
            }
            LsapFreeLsaHeap( (*AccountName) );
            (*AccountName) = NULL ;
        }

        if ((*AuthenticatingAuthority) != NULL) {
            if ((*AuthenticatingAuthority)->Buffer != NULL) {
                LsapFreeLsaHeap( (*AuthenticatingAuthority)->Buffer );
            }
            LsapFreeLsaHeap( (*AuthenticatingAuthority) );
            (*AuthenticatingAuthority) = NULL ;
        }

        //
        // Copy the submit buffer for the package to mark up
        //

        RtlCopyMemory(
            LocalSubmitBuffer,
            ProtocolSubmitBuffer,
            SubmitBufferSize
            );


        SetCurrentPackageId(LogonPackages[Index]->dwPackageID);

        Status = LogonPackages[Index]->FunctionTable.LogonUserEx2(
                                    ClientRequest,
                                    LogonType,
                                    LocalSubmitBuffer,
                                    ClientBufferBase,
                                    SubmitBufferSize,
                                    ProfileBuffer,
                                    ProfileBufferLength,
                                    NewLogonId,
                                    ApiSubStatus,
                                    TokenInformationType,
                                    TokenInformation,
                                    AccountName,
                                    AuthenticatingAuthority,
                                    MachineName,
                                    PrimaryCredentials,
                                    CachedCredentials
                                    );
        SetCurrentPackageId(CurrentPackageId);

        //
        // Bug 226401 If the local machine secret is different from the
        // machine account password, kerberos can't decrpyt the workstation
        // ticket and returns STATUS_TRUSTED_RELATIONSHIP_FAILURE (used to
        // return STATUS_TRUST_FAILURE). If this is a DC, we
        // should fall back to NTLM.
        //

        if (Status == STATUS_TRUST_FAILURE ||
            Status == STATUS_TRUSTED_RELATIONSHIP_FAILURE)
        {
            if (NegMachineState & SECPKG_STATE_DOMAIN_CONTROLLER)
            {
                Status = STATUS_NO_LOGON_SERVERS;
            }
        }


        if ((Status != STATUS_NO_LOGON_SERVERS) &&
            (Status != STATUS_NETLOGON_NOT_STARTED) &&
            (Status != SEC_E_NO_AUTHENTICATING_AUTHORITY) &&
            (Status != SEC_E_ETYPE_NOT_SUPP) &&
            (Status != STATUS_KDC_UNKNOWN_ETYPE) &&
            (Status != STATUS_NO_TRUST_SAM_ACCOUNT) &&
            (Status != STATUS_INVALID_PARAMETER) &&
            (Status != STATUS_INVALID_LOGON_TYPE) &&
            (Status != STATUS_INVALID_INFO_CLASS ) &&
            (Status != STATUS_NETWORK_UNREACHABLE) &&
            (Status != STATUS_BAD_VALIDATION_CLASS) )
        {
            break;
        }

    }

    if ( NT_SUCCESS( Status ) )
    {
        LogonSession = NegpBuildLogonSession(
                            NewLogonId,
                            LogonPackages[ Index ]->dwPackageID,
                            LogonPackages[ Index ]->dwPackageID );

        if ( LogonSession )
        {
            if ( LogonPackages[ Index ]->dwRPCID == NTLMSP_RPCID )
            {
                DebugLog(( DEB_TRACE_NEG, "NTLM Logon\n" ));

                //
                // Check if this is an uplevel or downlevel domain
                //

                DomainType =  NegpIsUplevelDomain( NewLogonId, LogonType, *AuthenticatingAuthority );

                if( DomainType == NegLocalDomain )
                {
                    //
                    // change from Win2k:
                    // allow full negotiation range by default for local logons.
                    // Kerberos now quickly fails local account originated operations.
                    //

                    LogonSession->DefaultPackage = NegPackageId ;
                }

                if ( DomainType == NegUpLevelDomain )
                {
                    if( (LogonType == CachedInteractive) &&
                       ((PrimaryCredentials->Flags >> PRIMARY_CRED_LOGON_PACKAGE_SHIFT) == NTLMSP_RPCID)
                        )
                    {
                        //
                        // leave the package as NTLM.
                        //

                    } else {
                        LogonSession->DefaultPackage = NEG_INVALID_PACKAGE ;
                    }
                }
                else if ( DomainType == NegUpLevelTrustedDomain )
                {
                    LogonSession->DefaultPackage = NegPackageId ;
                }
                else
                {
                    //
                    // leave the DefaultPackage as NTLM.
                    //

                    NOTHING;
                }

            }

            //
            // Create the name:
            //


            AltName = (PWSTR) LsapAllocatePrivateHeap(
                                                (*AccountName)->Length +
                                                (*AuthenticatingAuthority)->Length +
                                                2 * sizeof( WCHAR ) );

            if ( AltName )
            {
                AltNameScan = AltName ;
                RtlCopyMemory( AltNameScan,
                               (*AuthenticatingAuthority)->Buffer,
                               (*AuthenticatingAuthority)->Length );

                AltNameScan += (*AuthenticatingAuthority)->Length / sizeof(WCHAR) ;

                *AltNameScan++ = L'\\';

                RtlCopyMemory( AltNameScan,
                               (*AccountName)->Buffer,
                               (*AccountName)->Length );

                AltNameScan += (*AccountName)->Length / sizeof( WCHAR ) ;

                *AltNameScan++ = L'\0';

                RtlInitUnicodeString( &LogonSession->AlternateName, AltName );
            }

            NegpDerefLogonSession( LogonSession );
        }

    }


Cleanup:

    if( LogonPackages )
    {
        LsapFreeLsaHeap(LogonPackages);
    }

    if( LocalSubmitBuffer )
    {
        ZeroMemory(LocalSubmitBuffer, SubmitBufferSize);
        LsapFreeLsaHeap(LocalSubmitBuffer);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NegpMakeServiceToken
//
//  Synopsis:   Handles the logon for LocalService and NetworkService
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      On error, this routine frees the buffers allocated by
//              the prior call to NegpIsLocalOrNetworkService
//
//--------------------------------------------------------------------------

NTSTATUS
NegpMakeServiceToken(
    IN ULONG ulAccountId,
    OUT PLUID pLogonId,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status;
    LPBYTE   pBuffer;
    ULONG    ulTokenLength;
    PSID     Owner;
    PSID     UserSid;
    ULONG    DaclLength;
    PACL     pDacl;
    DWORD    dwSidLen;
    HMODULE  hStringsResource;
    LUID     SystemId = SYSTEM_LUID;

    PTOKEN_GROUPS              pGroups;
    PSID_AND_ATTRIBUTES        pSidAndAttrs;
    ULONG                      NormalGroupAttributes;
    TIME_FIELDS                TimeFields;
    SECPKG_CLIENT_INFO         ClientInfo;
    SID_IDENTIFIER_AUTHORITY   IdentifierAuthority = SECURITY_NT_AUTHORITY;
    PLSA_TOKEN_INFORMATION_V2  pTokenInfo = NULL;
    PLSAP_LOGON_SESSION        pLogonSession = NULL;

    //
    // Don't allow untrusted clients to call this API.
    //

    Status = LsapGetClientInfo(&ClientInfo);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    if (!RtlEqualLuid(&ClientInfo.LogonId, &SystemId))
    {
        Status = STATUS_ACCESS_DENIED;
        goto ErrorExit;
    }

    if (ulAccountId == LSAP_SID_NAME_LOCALSERVICE)
    {
        LUID LocalServiceId = LOCALSERVICE_LUID;
        UNICODE_STRING EmptyString = {0, 0, NULL};

        UserSid = LsapLocalServiceSid;
        PrimaryCredentials->LogonId = LocalServiceId;
        *pLogonId = LocalServiceId;

        Status = LsapDuplicateSid(&PrimaryCredentials->UserSid,
                                  UserSid);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredentials->DomainName,
                                     &EmptyString);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredentials->DownlevelName,
                                     &EmptyString);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredentials->Password,
                                     &EmptyString);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }
    }
    else
    {
        LUID NetworkServiceId = NETWORKSERVICE_LUID;

        ASSERT( ulAccountId == LSAP_SID_NAME_NETWORKSERVICE );

        UserSid = LsapNetworkServiceSid;

        Status = NegpCopyCredsToBuffer(&NegPrimarySystemCredentials,
                                       NULL,
                                       PrimaryCredentials,
                                       NULL);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        PrimaryCredentials->LogonId = NetworkServiceId;
        *pLogonId = NetworkServiceId;

        Status = LsapDuplicateSid(&PrimaryCredentials->UserSid,
                                  UserSid);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }
    }

    *CachedCredentials = NULL;

    ASSERT(UserSid != NULL);

    //
    // Make sure there's a logon session for this account
    //

    pLogonSession = LsapLocateLogonSession(pLogonId);

    if (pLogonSession == NULL)
    {
        Status = LsapCreateLogonSession(pLogonId);

        pLogonSession = LsapLocateLogonSession(pLogonId);

        if( pLogonSession == NULL )
        {
            if (!NT_SUCCESS(Status))
            {
                goto ErrorExit;
            }

            ASSERT(pLogonSession != NULL);
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto ErrorExit;
        }

        Status = STATUS_SUCCESS;
    }


    //
    // Compute the length of the default DACL for the token
    //

    DaclLength = (ULONG) sizeof(ACL)
                     + 2 * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))
                     + RtlLengthSid( LsapLocalSystemSid )
                     + RtlLengthSid( UserSid );

#define NUM_TOKEN_GROUPS   4

    //
    // The SIDs are 4-byte aligned so this shouldn't cause problems
    // with unaligned accesses (as long as the DACL stays at the
    // end of the buffer).
    //

    ulTokenLength = sizeof(LSA_TOKEN_INFORMATION_V2)
                         + RtlLengthSid( UserSid )            // User
                         + sizeof(TOKEN_GROUPS)
                         + (NUM_TOKEN_GROUPS - 1) * sizeof(SID_AND_ATTRIBUTES)
                         + RtlLengthSid( UserSid )            // Primary group
                         + RtlLengthSid( LsapWorldSid )       // Groups
                         + RtlLengthSid( LsapAuthenticatedUserSid )
                         + RtlLengthSid( LsapLocalSid )
                         + RtlLengthSid( LsapAliasUsersSid )
                         + RtlLengthSid( UserSid )            // Owner
                         + DaclLength;                        // DefaultDacl


    pTokenInfo = (PLSA_TOKEN_INFORMATION_V2) LsapAllocateLsaHeap(ulTokenLength);

    if (pTokenInfo == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    //
    // Set up expiration time
    //

    TimeFields.Year = 3000;
    TimeFields.Month = 1;
    TimeFields.Day = 1;
    TimeFields.Hour = 1;
    TimeFields.Minute = 1;
    TimeFields.Second = 1;
    TimeFields.Milliseconds = 1;
    TimeFields.Weekday = 1;

    RtlTimeFieldsToTime( &TimeFields, &pTokenInfo->ExpirationTime );

    //
    // Set up the groups -- do this first so the nested pointers
    // don't cause 64-bit alignment faults
    //

    pGroups      = (PTOKEN_GROUPS) (pTokenInfo + 1);
    pSidAndAttrs = pGroups->Groups;
    pBuffer      = (LPBYTE) (pSidAndAttrs + NUM_TOKEN_GROUPS);

    pGroups->GroupCount = NUM_TOKEN_GROUPS;

#undef NUM_TOKEN_GROUPS

    //
    // Set up the attributes to be assigned to groups
    //

    NormalGroupAttributes = (SE_GROUP_MANDATORY          |
                             SE_GROUP_ENABLED_BY_DEFAULT |
                             SE_GROUP_ENABLED);

    dwSidLen = RtlLengthSid(LsapWorldSid);
    RtlCopySid(dwSidLen, pBuffer, LsapWorldSid);
    pSidAndAttrs[0].Sid = (PSID) pBuffer;
    pBuffer += dwSidLen;

    dwSidLen = RtlLengthSid(LsapAuthenticatedUserSid);
    RtlCopySid(dwSidLen, pBuffer, LsapAuthenticatedUserSid);
    pSidAndAttrs[1].Sid = (PSID) pBuffer;
    pBuffer += dwSidLen;

    dwSidLen = RtlLengthSid(LsapLocalSid);
    RtlCopySid(dwSidLen, pBuffer, LsapLocalSid);
    pSidAndAttrs[2].Sid = (PSID) pBuffer;
    pBuffer += dwSidLen;

    dwSidLen = RtlLengthSid(LsapAliasUsersSid);
    RtlCopySid(dwSidLen, pBuffer, LsapAliasUsersSid);
    pSidAndAttrs[3].Sid = (PSID) pBuffer;
    pBuffer += dwSidLen;

    pSidAndAttrs[0].Attributes = NormalGroupAttributes;
    pSidAndAttrs[1].Attributes = NormalGroupAttributes;
    pSidAndAttrs[2].Attributes = NormalGroupAttributes;
    pSidAndAttrs[3].Attributes = NormalGroupAttributes;

    pTokenInfo->Groups = pGroups;


    //
    // Set up the user ID
    //

    dwSidLen = RtlLengthSid(UserSid);
    RtlCopySid(dwSidLen, (PSID) pBuffer, UserSid);
    pTokenInfo->User.User.Sid        = (PSID) pBuffer;
    pTokenInfo->User.User.Attributes = 0;
    pBuffer += dwSidLen;


    //
    // Establish the primary group
    //

    dwSidLen = RtlLengthSid(UserSid);
    RtlCopySid(dwSidLen, (PSID) pBuffer, UserSid);
    pTokenInfo->PrimaryGroup.PrimaryGroup = (PSID) pBuffer;
    pBuffer += dwSidLen;

    //
    // Set the default owner
    //

    dwSidLen = RtlLengthSid(UserSid);
    RtlCopySid(dwSidLen, (PSID) pBuffer, UserSid);
    pTokenInfo->Owner.Owner = (PSID) pBuffer;
    pBuffer += dwSidLen;


    //
    // Privileges -- none by default (set by policy)
    //

    pTokenInfo->Privileges = NULL;

    //
    // Set up the default DACL for token.  Give system full reign of terror.
    //

    pDacl = (PACL) pBuffer;

    Status = RtlCreateAcl(pDacl, DaclLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce(pDacl,
                                    ACL_REVISION2,
                                    GENERIC_ALL,
                                    LsapLocalSystemSid);

    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce(pDacl,
                                    ACL_REVISION2,
                                    GENERIC_ALL,
                                    UserSid);

    ASSERT( NT_SUCCESS(Status) );

    RtlCopyMemory(pBuffer, pDacl, DaclLength);

    pTokenInfo->DefaultDacl.DefaultDacl = (PACL) pBuffer;

    pBuffer += DaclLength;

    ASSERT( (ULONG)(ULONG_PTR)(pBuffer - (LPBYTE) pTokenInfo) == ulTokenLength );

    //
    // Now fill in the out parameters
    //

    //
    // LocalService/NetworkService have no profile
    //

    *ProfileBuffer        = NULL;
    *ProfileBufferLength  = 0;
    *TokenInformationType = LsaTokenInformationV2;
    *TokenInformation     = pTokenInfo;

    LsapReleaseLogonSession(pLogonSession);

    *ApiSubStatus = STATUS_SUCCESS;
    return STATUS_SUCCESS;

ErrorExit:

    if (*AuthenticatingAuthority)
    {
        LsapFreeLsaHeap((*AuthenticatingAuthority)->Buffer);
        LsapFreeLsaHeap(*AuthenticatingAuthority);
        *AuthenticatingAuthority = NULL;
    }

    if (*AccountName)
    {
        LsapFreeLsaHeap((*AccountName)->Buffer);
        LsapFreeLsaHeap(*AccountName);
        *AccountName = NULL;
    }

    if (*MachineName)
    {
        LsapFreeLsaHeap((*MachineName)->Buffer);
        LsapFreeLsaHeap(*MachineName);
        *MachineName = NULL;
    }

    LsapFreeLsaHeap(PrimaryCredentials->UserSid);
    PrimaryCredentials->UserSid = NULL;

    LsapFreeLsaHeap(PrimaryCredentials->DomainName.Buffer);
    RtlZeroMemory(&PrimaryCredentials->DomainName, sizeof(UNICODE_STRING));

    LsapFreeLsaHeap(PrimaryCredentials->DownlevelName.Buffer);
    RtlZeroMemory(&PrimaryCredentials->DownlevelName, sizeof(UNICODE_STRING));

    LsapFreeLsaHeap(PrimaryCredentials->Password.Buffer);
    RtlZeroMemory(&PrimaryCredentials->Password, sizeof(UNICODE_STRING));

    if (pLogonSession)
    {
        LsapReleaseLogonSession(pLogonSession);
    }

    LsapFreeLsaHeap(pTokenInfo);

    *ApiSubStatus = Status;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpIsLocalOrNetworkService
//
//  Synopsis:   Allocates memory for the account name, machine name,
//              and authenticating authority for LocalService and
//              NetworkService logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The caller is responsible for freeing the allocated
//              buffers if this routine succeeds
//
//--------------------------------------------------------------------------

BOOL
NegpIsLocalOrNetworkService(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PULONG pulAccountId
    )
{
    NTSTATUS  Status;

    PUNICODE_STRING  pTempAccount;
    PUNICODE_STRING  pTempAuthority;

    PMSV1_0_INTERACTIVE_LOGON  Authentication = NULL;


    *AccountName = NULL;
    *AuthenticatingAuthority = NULL;
    *MachineName = NULL;

    //
    // Parse the supplied buffer to come up with creds
    //

    Status = NegpMapLogonRequest(
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferSize,
                    &Authentication);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit ;
    }


    //
    // Get the info to compare for LocalService first.  Check both the
    // localized version and the non-localized version (which could come
    // from the registry).
    //

    pTempAuthority = &WellKnownSids[LsapLocalServiceSidIndex].DomainName;
    pTempAccount   = &WellKnownSids[LsapLocalServiceSidIndex].Name;

    if (RtlCompareUnicodeString(&NTAuthorityName,
                                &Authentication->LogonDomainName,
                                TRUE) == 0)
    {
        //
        // Hardcoded "NT AUTHORITY" -- check hardcoded
        // "LocalService" and "NetworkService" and
        // localize it here on a match.
        //

        if (RtlCompareUnicodeString(&LocalServiceName,
                                    &Authentication->UserName,
                                    TRUE) == 0)
        {
            pTempAccount = &WellKnownSids[LsapLocalServiceSidIndex].Name;
            *pulAccountId = LSAP_SID_NAME_LOCALSERVICE;
            Status = STATUS_SUCCESS;
        }
        else if (RtlCompareUnicodeString(&NetworkServiceName,
                                         &Authentication->UserName,
                                         TRUE) == 0)
        {
            pTempAccount = &WellKnownSids[LsapNetworkServiceSidIndex].Name;
            *pulAccountId = LSAP_SID_NAME_NETWORKSERVICE;
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_NO_SUCH_USER;
        }
    }
    else
    {
        Status = STATUS_NO_SUCH_USER;
    }


    //
    // Hardcoded comparison failed -- try localized versions.  Note that
    // we have to check again (rather than using an "else" with the "if"
    // above) since "NT AUTHORITY" may be both the hardcoded and the
    // localized name (e.g., in English).  Since Status is already a
    // failure code, let the failure cases trickle through.
    //

    if (!NT_SUCCESS(Status))
    {
        if (RtlCompareUnicodeString(pTempAuthority,
                                    &Authentication->LogonDomainName,
                                    TRUE) == 0)
        {
            //
            // Localized "NT AUTHORITY" -- check localized
            // "LocalService" and "NetworkService"
            //

            pTempAccount = &WellKnownSids[LsapLocalServiceSidIndex].Name;

            if (RtlCompareUnicodeString(pTempAccount,
                                        &Authentication->UserName,
                                        TRUE) == 0)
            {
                *pulAccountId = LSAP_SID_NAME_LOCALSERVICE;
                Status = STATUS_SUCCESS;
            }
            else
            {
                pTempAccount = &WellKnownSids[LsapNetworkServiceSidIndex].Name;

                if (RtlCompareUnicodeString(pTempAccount,
                                            &Authentication->UserName,
                                            TRUE) == 0)
                {
                    *pulAccountId = LSAP_SID_NAME_NETWORKSERVICE;
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    Status = STATUS_NO_SUCH_USER;
                }
            }
        }
        else
        {
            Status = STATUS_NO_SUCH_USER;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }


    //
    // Stuff the names:
    //

    *AccountName = (PUNICODE_STRING) LsapAllocateLsaHeap(sizeof(UNICODE_STRING));

    if (!(*AccountName))
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    Status = LsapDuplicateString(*AccountName,
                                 pTempAccount);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    *AuthenticatingAuthority = (PUNICODE_STRING) LsapAllocateLsaHeap(sizeof(UNICODE_STRING));

    if (!(*AuthenticatingAuthority))
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    Status = LsapDuplicateString(*AuthenticatingAuthority,
                                 pTempAuthority);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    *MachineName = (PUNICODE_STRING) LsapAllocateLsaHeap(sizeof(UNICODE_STRING));

    if (!(*MachineName))
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit ;
    }

    return TRUE;


ErrorExit:

    if (*AuthenticatingAuthority)
    {
        LsapFreeLsaHeap((*AuthenticatingAuthority)->Buffer);
        LsapFreeLsaHeap(*AuthenticatingAuthority);
        *AuthenticatingAuthority = NULL;
    }

    if (*AccountName)
    {
        LsapFreeLsaHeap((*AccountName)->Buffer);
        LsapFreeLsaHeap(*AccountName);
        *AccountName = NULL;
    }

    if (*MachineName)
    {
        LsapFreeLsaHeap((*MachineName)->Buffer);
        LsapFreeLsaHeap(*MachineName);
        *MachineName = NULL;
    }

    return FALSE;
}

BOOL
NegpRearrangeMechsIfNeccessary(
    struct MechTypeList ** RealMechList,
    PSECURITY_STRING    Target,
    PBOOL               DirectPacket
    )
{
    PWSTR FirstSlash ;
    PWSTR SecondSlash = NULL;
    PNEG_TRUST_LIST TrustList = NULL ;
    UNICODE_STRING TargetHost ;
    UNICODE_STRING SpnPrefix;
    UNICODE_STRING HttpPrefix;
    struct MechTypeList * MechList ;
    struct MechTypeList * Reorder = NULL ;
    struct MechTypeList * Trailer ;
    BOOL Rearranged = FALSE ;
    BOOL HttpSpn = FALSE;

    if ( Target == NULL )
    {
        DebugLog(( DEB_TRACE_NEG, "Loopback detected for local target (no targetname)\n"));
        goto loopback;
    }

    if ( Target->Length == 0 )
    {
        DebugLog(( DEB_TRACE_NEG, "Loopback detected for local target (no targetname)\n"));
        goto loopback;
    }

    //
    // Now, examine the target and determine if it is referring to us
    //

    FirstSlash = wcschr( Target->Buffer, L'/' );

    if ( !FirstSlash )
    {
        //
        // Not an SPN, we're out of here
        //

        return FALSE ;
    } else {

       *FirstSlash = L'\0';

    }

    //
    // HACK HACK HACK:  We've got to call NTLM directly in 
    // the loopback case, or Wininet can't handle our "extra" nego trips....
    //
    RtlInitUnicodeString(
       &SpnPrefix,
       Target->Buffer
       );

    RtlInitUnicodeString(
       &HttpPrefix,
       L"HTTP"
       );

    if (RtlEqualUnicodeString(
                  &SpnPrefix,
                  &HttpPrefix,
                  TRUE
                  ))
    {
       HttpSpn = TRUE;
       DebugLog((DEB_TRACE_NEG, "Found HTTP SPN, about to force NTLM directly\n"));
    } 
    
    *FirstSlash = L'/';
    // END HACK END HACK

    FirstSlash++ ;

    //
    // if this is a svc/instance/domain style SPN, ignore the trailer
    // portion
    //

    SecondSlash = wcschr( Target->Buffer, L'/' );

    if ( SecondSlash )
    {
        *SecondSlash = L'\0';
    }

    RtlInitUnicodeString( &TargetHost, FirstSlash );

    NegReadLockComputerNames();

    if (!RtlEqualUnicodeString( &TargetHost, &NegDnsComputerName_U, TRUE ) &&
        !RtlEqualUnicodeString( &TargetHost, &NegNetbiosComputerName_U, TRUE ) &&
        !RtlEqualUnicodeString( &TargetHost, &NegLocalHostName_U, TRUE ) )
    {
        NegUnlockComputerNames();
        goto Cleanup ;
    }

    NegUnlockComputerNames();
    
    //
    // We have a loopback condition.  The target we are going to is our own host
    // name.  So, scan through the mech list, and find the NTLM mech (if present)
    // and bump it up.
    //
#if DBG
    if ( SecondSlash )
    {
        //
        // for debug builds, reset the string now for the dump message, so that
        // we can make sure the right targets are being caught.  Free builds will
        // reset this at the cleanup stage.
        //
        *SecondSlash = L'/';
        SecondSlash = NULL ;
    }
#endif 

    DebugLog(( DEB_TRACE_NEG, "Loopback detected for target %ws\n", Target->Buffer ));

loopback:

    MechList = *RealMechList ;
    Trailer = NULL ;

    while ( MechList )
    {
        if ( (MechList->value != NULL) &&
             (NegpCompareOid( MechList->value, NegNtlmMechOid ) == 0)
            )
        {
            //
            // Found NTLM.  Unlink it and put it at the head of the new list
            //

            Reorder = MechList ;
            if ( Trailer )
            {
                Trailer->next = MechList->next ;
            }
            else 
            {
                // update original pointer
                *RealMechList = MechList->next ;
            }
            MechList = MechList->next ;
            Reorder->next = NULL ;
        }
        else 
        {
            Trailer = MechList ;
            MechList = MechList->next ;
        }

    }

    //
    // Reorder points to the NTLM element, if there are NTLM creds.  If not, this is NULL.
    // Now, append the rest of the list
    //
    if ( Reorder )
    {
        Reorder->next = *RealMechList ;
        *RealMechList = Reorder ;
        Rearranged = TRUE ;
    }

    // Only set this if everything else went well
    // HACK PART 2
    *DirectPacket = HttpSpn;

Cleanup:

    if ( SecondSlash )
    {
        *SecondSlash = L'/';
    }

    return Rearranged ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\negsupp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negsupp.cxx
//
//  Contents:   General (both win9x and nt) functions
//
//  Classes:
//
//  Functions:
//
//  History:    02-09-00   RichardW     Created - split from negotiat.cxx
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#endif // WIN32_CHICAGO

extern "C"
{
#include <align.h>
#include <lm.h>
#include <dsgetdc.h>
#include <cryptdll.h>
#ifndef WIN32_CHICAGO
#include <spmgr.h>
#endif
#include "sesmgr.h"
#include "spinit.h"
}

#include "negotiat.hxx"
#ifdef WIN32_CHICAGO
#include <debug.h>
#include <rpc.h> // fpr SEC_WINNT_AUTH_IDENTITY_ANSI
#define LsapChangeBuffer( o, n )    0 ; CopyMemory( (n), (o),sizeof(SecBuffer) )
#endif // WIN32_CHICAGO

#include <stdio.h>


BOOL            fSPNEGOModuleStarted = FALSE;



int
SpnegoInitAsn(
    IN OUT ASN1encoding_t * pEnc,
    IN OUT ASN1decoding_t * pDec
    )
{
    int Result = 0;
    ASN1error_e Asn1Err;

        if (!fSPNEGOModuleStarted)
    {
        fSPNEGOModuleStarted = TRUE;
        SPNEGO_Module_Startup();
    }

        if (pEnc != NULL)
        {
                Asn1Err = ASN1_CreateEncoder(
                                         SPNEGO_Module,
                                         pEnc,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }
        else
        {
                Asn1Err = ASN1_CreateDecoder(
                                         SPNEGO_Module,
                                         pDec,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }

        if (ASN1_SUCCESS != Asn1Err)
        {
                DebugLog((DEB_ERROR, "Failed to init ASN1: 0x%x\n",Asn1Err));
                Result = 1;
                goto Cleanup;
        }

Cleanup:

    return(Result);
}


VOID
SpnegoTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
        {
                ASN1_CloseEncoder(pEnc);
        }
        else if (pDec != NULL)
        {
                ASN1_CloseDecoder(pDec);
        }

        //SPNEGO_Module_Cleanup();
}

int NTAPI
SpnegoUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    int Result = 0;
    ULONG OldPduValue;
    ASN1decoding_t pDec = NULL;
        ASN1error_e Asn1Err;

    if ((DataSize == 0) || (Data == NULL))
    {
        DebugLog((DEB_ERROR,"Trying to unpack NULL data\n"));
        return(1);
    }


    Result = SpnegoInitAsn(
                NULL,
                &pDec           // we are decoding
                );
    if (Result != 0)
    {
        return(Result);
    }


        *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                                pDec,
                                DecodedData,
                                PduValue,
                                ASN1DECODE_SETBUFFER,
                                (BYTE *) Data,
                                DataSize
                                );

        if (!ASN1_SUCCEEDED(Asn1Err))
        {
                if ((ASN1_ERR_BADARGS == Asn1Err) ||
                        (ASN1_ERR_EOD == Asn1Err))
                {
                        DebugLog((DEB_TRACE,"More input required to decode data %d.\n",PduValue));
                        Result = 1;
                }
                else
                {
                        DebugLog((DEB_WARN,"Failed to decode data: %d\n", Asn1Err ));
                        Result = 1;
                }
                *DecodedData = NULL;
        }

    SpnegoTermAsn(NULL, pDec);

    return(Result);

}


int NTAPI
SpnegoPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    int Result = 0;
    PUCHAR Buffer = NULL;
    ASN1encoding_t pEnc = NULL;
        ASN1error_e Asn1Err;

    Result = SpnegoInitAsn(
                &pEnc,          // we are encoding
                NULL
                );
    if (Result != 0)
    {
        goto Cleanup;
    }

    //
    // Encode the data type.
    //
        Asn1Err = ASN1_Encode(
                                pEnc,
                                Data,
                                PduValue,
                                ASN1ENCODE_ALLOCATEBUFFER,
                                NULL,                       // pbBuf
                                0                           // cbBufSize
                                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        DebugLog((DEB_ERROR,"Failed to encode data: %d\n",Asn1Err));
        Result = 1;
        goto Cleanup;
    }
        else
        {
                //
                // when the oss compiler was used the allocation routines were configurable.
                // therefore, the encoded data could just be free'd using our
                // deallocator.  in the new model we cannot configure the allocation routines
                // for encoding.

                // so we do not have to go and change every place where a free
                // of an encoded buffer is done, use our allocator to allocate a new buffer,
                // then copy the encoded data to it, and free the buffer that was allocated by
                // the encoding engine.
                //

                *MarshalledData = (PUCHAR)LsapAllocateLsaHeap(pEnc->len);
                if (*MarshalledData == NULL)
                {
                        Result = 1;
                        *DataSize = 0;
                }
                else
                {
                        RtlCopyMemory(*MarshalledData, pEnc->buf, pEnc->len);
                        *DataSize = pEnc->len;

                        //DebugLog((DEB_ERROR,"encoded pdu size: %d\n",pEnc->len));
                        //PrintBytes(pEnc->buf, pEnc->len);
                }

                ASN1_FreeEncoded(pEnc, pEnc->buf);
        }

Cleanup:
    SpnegoTermAsn(pEnc, NULL);

    return(Result);
}


VOID
SpnegoFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    )
{
    ASN1decoding_t pDec = NULL;

    if (ARGUMENT_PRESENT(Data))
    {
        int Result;
        Result = SpnegoInitAsn(
                    NULL,
                    &pDec       // this is a decoded structure
                    );

        if (Result == 0)
        {
            ASN1_FreeDecoded(pDec, Data, PduValue);

            SpnegoTermAsn(NULL, pDec);
        }
    }

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpFreeObjectId
//
//  Synopsis:   Frees an object ID structure created by us
//
//  Arguments:  [Id] -- Id to free
//
//  History:    8-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpFreeObjectId(
    ObjectID    Id)
{
    ObjectID    Next;

    while (Id) {

        Next = Id->next;

        LsapFreeLsaHeap( Id );

        Id = Next ;

    } ;

}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFreeMechList
//
//  Synopsis:   Frees a Mechlist created by NecpCopyMechList
//
//  Arguments:  [Id] -- Id to free
//
//  History:    8-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpFreeMechList(
    struct MechTypeList *MechList)
{
    struct MechTypeList *Next;

    Next = MechList;
    while (Next != NULL)
    {

        NegpFreeObjectId(Next->value);

        Next = Next->next ;

    } while ( Next );

    LsapFreeLsaHeap(MechList);

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpDecodeObjectId
//
//  Synopsis:   Create an Object ID struct from a BER encoded Object ID
//
//  Arguments:  [Id]  --
//              [Len] --
//
//  History:    8-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ObjectID
NegpDecodeObjectId(
    PUCHAR  Id,
    DWORD   Len)
{
    ObjectID    Root;
    ObjectID    Tail;
    ObjectID    Current;
    DWORD       i, j;
    DWORD       value;

    if ( Len < 3 )
    {
        return( NULL );
    }

    //
    // Check for BER type OBJECT_ID
    //

    if ( Id[ 0 ] != 0x06 )
    {
        return( NULL );
    }

    if ( Id[ 1 ] > 127 )
    {
        return( NULL );
    }

    Root = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap( sizeof( struct ASN1objectidentifier_s ) );

    Tail = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap( sizeof( struct ASN1objectidentifier_s ) );

    if ( !Root || !Tail )
    {
        if ( Root )
        {
            LsapFreeLsaHeap( Root );
        }

        if ( Tail )
        {
            LsapFreeLsaHeap( Tail );
        }

        return( NULL );
    }

    Root->value = (WORD) Id[2] / 40 ;

    Tail->value = (WORD) Id[2] % 40 ;

    Root->next = Tail ;

    i = 3 ;

    while ( i < Len )
    {
        j = 0;

        value = Id[ i ] & 0x7F ;

        while ( Id[i] & 0x80 )
        {
            value <<= 7;

            i++;

            j++;

            if ( (i >= Len) || ( j > sizeof( ULONG ) ) )
            {
                NegpFreeObjectId( Root );

                return( NULL );
            }

            value |= Id[ i ] & 0x7F ;
        }

        i++;

        Current = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap( sizeof( struct ASN1objectidentifier_s ) );

        if ( Current )
        {
            Current->value = value ;
            Current->next = NULL ;

            Tail->next = Current ;

            Tail = Current ;

        }
        else
        {
            NegpFreeObjectId( Root );

            return( NULL );
        }

    }

    return( Root );

}

//+---------------------------------------------------------------------------
//
//  Function:   NegpCompareOid
//
//  Synopsis:   Standard compare function for OIDs:
//
//  Arguments:  [A] --
//              [B] --
//
//  Returns:    < 0 if A is "less than" B
//              > 0 if A is "greater than" B
//              0 if A equals B
//
//  History:    8-22-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
NegpCompareOid(
    ObjectID    A,
    ObjectID    B)
{
    while ( A )
    {
        if ( A->value < B->value )
        {
            return( -1 );
        }
        if ( A->value > B->value )
        {
            return( 1 );
        }

        A = A->next ;

        B = B->next ;

        if ( ( A == NULL ) && ( B == NULL ) )
        {
            return( 0 );
        }

        if ( !B )
        {
            return( 1 );
        }

        if ( !A )
        {
            return( -1 );
        }
    }

    //
    // Never reached
    //
    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpDumpOid
//
//  Synopsis:   Debug-only dumper
//
//  Arguments:  [Banner] --
//              [Id]     --
//
//  History:    9-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpDumpOid(
    PSTR        Banner,
    ObjectID    Id
    )
{
    CHAR    Oid[128];
    PSTR    Next;
    int     Count;

    Next = Oid;

    while ( Id )
    {
        Count = sprintf(Next, "%d.", Id->value );

        Next += Count;

        Id = Id->next;
    }

    DebugLog(( DEB_TRACE_NEG, "%s: %s\n", Banner, Oid ));

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpBuildMechListFromCreds
//
//  Synopsis:   Builds a MechList from a credential struct
//
//  Arguments:  [Creds] -- Creds
//              [fPackageReq]
//              [MechList] -- Constructed mechlist
//
//  History:    9-27-96   RichardW   Created
//
//  Notes:      Returned MechList should be freed in a single call to LsapFreeHeap
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegpBuildMechListFromCreds(
    PNEG_CREDS  Creds,
    ULONG       fPackageReq,
    ULONG       MechAttributes,
    struct MechTypeList ** MechList)
{
    struct MechTypeList *pMechs = NULL;
    ULONG iCred, iMech = 0 ;
    SECURITY_STATUS Status = STATUS_SUCCESS;
    PNEG_PACKAGE Package ;

    NegReadLockCreds( Creds );

    if ( Creds->Count != 0 )
    {

        pMechs = (struct MechTypeList *) LsapAllocateLsaHeap(
                                    sizeof( struct MechTypeList ) * ( Creds->Count) );

        if ( pMechs )
        {
            for ( iCred = 0 ; iCred < Creds->Count ; iCred++ )
            {
                Package = Creds->Creds[ iCred ].Package ;

                if ( (Package->PackageFlags & fPackageReq) != fPackageReq)
                {
                    continue;
                }
                pMechs[ iMech ].next = &pMechs[ iMech + 1 ];

                pMechs[ iMech ].value = Package->ObjectId ;

                iMech++ ;

            }

            if ( iMech != 0 )
            {
                pMechs[ iMech - 1 ].next = NULL ;
            }

        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
        }
    }

    NegUnlockCreds( Creds );

    *MechList = pMechs;
    return( Status );

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpCopyObjectId
//
//  Synopsis:   Duplicates an ObjectId
//
//  Arguments:  [ObjectId] = Object Id to copy
//
//  History:    9-27-96   RichardW   Created
//
//  Notes:      Returned ObjectId should be freed with NegpFreeObjectId
//
//----------------------------------------------------------------------------
ObjectID
NegpCopyObjectId(
    IN ObjectID Id
    )
{
    ObjectID RootId = NULL;
    ObjectID NewId = NULL;
    ObjectID LastId = NULL;
    ObjectID NextId = NULL;

    NextId = Id;
    while (NextId != NULL)
    {
        NewId = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap(sizeof(struct ASN1objectidentifier_s));
        if (NewId == NULL)
        {
            goto Cleanup;
        }
        NewId->next = NULL;
        NewId->value = NextId->value;

        if (RootId == NULL)
        {
            RootId = NewId;
        }

        if (LastId != NULL)
        {
            LastId->next = NewId;
        }
        LastId = NewId;
        NextId= NextId->next;
    }
    return(RootId);

Cleanup:
    if (RootId != NULL)
    {
        NegpFreeObjectId(RootId);
    }
    return(NULL);

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpCopyMechList
//
//  Synopsis:   Duplicates a MechList
//
//  Arguments:  [Creds] -- Creds
//
//  History:    9-27-96   RichardW   Created
//
//  Notes:      Returned MechList should be freed with NegpFreeMechList
//
//----------------------------------------------------------------------------
struct MechTypeList *
NegpCopyMechList(
    struct MechTypeList *MechList)
{
    struct MechTypeList *pMechs;
    struct MechTypeList *NextMech;
    ULONG i, Count;

    Count = 0;
    NextMech = MechList;
    while (NextMech != NULL)
    {
        Count++;
        NextMech = NextMech->next;
    }

    if (Count == 0)
    {
        return(NULL);
    }

    pMechs = (struct MechTypeList *) LsapAllocateLsaHeap(
                                sizeof( struct MechTypeList ) * Count );

    if ( pMechs == NULL )
    {
        goto Cleanup;
    }

    RtlZeroMemory(
        pMechs,
        sizeof(struct MechTypeList) * Count
        );

    i = 0;

    NextMech = MechList;
    while (NextMech != NULL)
    {
        pMechs[i].value = NegpCopyObjectId(NextMech->value);
        if (pMechs[i].value == NULL)
        {
            goto Cleanup;
        }
        pMechs[i].next = NULL;
        if (i != 0)
        {
            pMechs[i-1].next = &pMechs[i];
        }
        NextMech = NextMech->next;
        i++;
    }

    return( pMechs );
Cleanup:
    if (pMechs != NULL)
    {
        NegpFreeMechList (pMechs);
    }
    return(NULL);

}


//+-------------------------------------------------------------------------
//
//  Function:   NegpMapNegFlagsToContextFlags
//
//  Synopsis:   maps negotatie context flags to ASC_REQ_xxx flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
ULONG
NegoMapNegFlagsToPackageFlags(
    IN int NegFlags
    )
{
    ULONG ContextFlags = 0;
    if ((NegFlags & delegFlag) != 0)
    {
        ContextFlags |= ASC_REQ_DELEGATE;
    }
    if ((NegFlags & mutualFlag) != 0)
    {
        ContextFlags |= ASC_REQ_MUTUAL_AUTH;
    }
    if ((NegFlags & replayFlag) != 0)
    {
        ContextFlags |= ASC_REQ_REPLAY_DETECT;
    }
    if ((NegFlags & sequenceFlag) != 0)
    {
        ContextFlags |= ASC_REQ_SEQUENCE_DETECT;
    }
    if ((NegFlags & confFlag) != 0)
    {
        ContextFlags |= ASC_REQ_CONFIDENTIALITY;
    }
    if ((NegFlags & integFlag) != 0)
    {
        ContextFlags |= ASC_REQ_INTEGRITY;
    }
    return(ContextFlags);

}

//+-------------------------------------------------------------------------
//
//  Function:   NegpMapContextFlagsToNegFlags
//
//  Synopsis:   maps ISC_REQ_xxx flags to negotiate flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
int
NegoMapNegFlasgToContextFlags(
    IN ULONG ContextFlags
    )
{
    int NegFlags = 0;

    if ((ContextFlags & ISC_REQ_DELEGATE) != 0)
    {
        NegFlags |= delegFlag;
    }
    if ((ContextFlags & ISC_REQ_MUTUAL_AUTH) != 0)
    {
        NegFlags |= mutualFlag;
    }
    if ((ContextFlags & ISC_REQ_REPLAY_DETECT) != 0)
    {
        NegFlags |= replayFlag;
    }
    if ((ContextFlags & ISC_REQ_SEQUENCE_DETECT) != 0)
    {
        NegFlags |= sequenceFlag;
    }
    if ((ContextFlags & ISC_REQ_CONFIDENTIALITY) != 0)
    {
        NegFlags |= confFlag;
    }
    if ((ContextFlags & ISC_REQ_INTEGRITY) != 0)
    {
        NegFlags |= integFlag;
    }
    return(NegFlags);

}


int
Neg_der_read_length(
     unsigned char **buf,
     LONG *bufsize,
     LONG * headersize
     )
{
   unsigned char sf;
   LONG ret;

   if (*bufsize < 1)
      return(-1);
   *headersize = 0;
   sf = *(*buf)++;
   (*bufsize)--;
   (*headersize)++;
   if (sf & 0x80) {
      if ((sf &= 0x7f) > ((*bufsize)-1))
         return(-1);
      if (sf > sizeof(LONG))
          return (-1);
      ret = 0;
      for (; sf; sf--) {
         ret = (ret<<8) + (*(*buf)++);
         (*bufsize)--;
         (*headersize)++;
      }
   } else {
      ret = sf;
   }

   return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\negotiat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negotiat.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-15-95   RichardW     Created for Cairo
//              07-25-96   RichardW     Added SNEGO support
//              06-24-97   MikeSw       Modified for SPNEGO
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#endif // WIN32_CHICAGO

extern "C"
{
#include <align.h>
#include <lm.h>
#include <dsgetdc.h>
#include <cryptdll.h>
#ifndef WIN32_CHICAGO
#include <spmgr.h>
#endif
#include "sesmgr.h"
#include "spinit.h"
}

#include "negotiat.hxx"
#ifdef WIN32_CHICAGO
#include <debug.h>
#include <rpc.h> // fpr SEC_WINNT_AUTH_IDENTITY_ANSI
#define LsapChangeBuffer( o, n )    0 ; CopyMemory( (n), (o),sizeof(SecBuffer) )
#endif // WIN32_CHICAGO

#include <stdio.h>


//
// Possible states for the Accept and Init calls.
//

#define FIRST_CALL_NO_INPUT     0
#define FIRST_CALL_WITH_INPUT   1
#define LATER_CALL_NO_INPUT     2
#define LATER_CALL_WITH_INPUT   3

#define LATER_CALL_BIT      2
#define BUFFER_PRESENT_BIT  1


//
// This define controls the proposed MA behavior v. the existing MA
// behavior
//

#define NEW_MUTUAL_AUTH


//
// This defines the minimum buffer that spnego can use, when
// fragment-to-fit is requested.  This is 5 bytes, enough in
// BER to encode the start of a 64K buffer.  The five bytes,
// for the curious, are:
//
//      0x60 0x8x 0xLL 0xLL 0xLL
//
// or application[0], and four bytes of length specifier.
//
#define SPNEGO_MINIMUM_BUFFER   5


ULONG NegpUseSpnego = 1;
ULONG NegpUseSnegoServer = 0;
ULONG SyncTest = 0;

SECPKG_FUNCTION_TABLE   NegTable = {
            NULL,
            NULL,
            NegCallPackage,
            NegLogoffNotify,
            NegCallPackage,         // UNTRUSTED Is the same!
            NegCallPackagePassthrough,
            NULL,
#ifndef WIN32_CHICAGO
            NegLogonUserEx2,
#else
            NULL,
#endif
            NegInitialize,
            NegShutdown,
            NegGetInfo,
            NegAcceptCredentials,
            NegAcquireCredentialsHandle,
            NegQueryCredentialsAttributes,
            NegFreeCredentialsHandle,
            NegSaveCredentials,
            NegGetCredentials,
            NegDeleteCredentials,
            NegInitLsaModeContext,
            NegAcceptLsaModeContext,
            NegDeleteLsaModeContext,
            NegApplyControlToken,
            NegGetUserInfo,
            NegGetExtendedInformation,
            NegQueryContextAttributes,
#ifndef WIN32_CHICAGO
            NegAddCredentials
#endif
            };


//
// Microsoft Security Mechanisms OID Branch:
//
// iso(1) org(3) dod(6) internet(1) private(4) enterprise(1) microsoft(311)
//   security(2)
//     mechanisms(2)
//
//          Loopback Detect (9)
//          <RPCID> - The RPC Id is stuck here, e.g.
//          NTLM (10)
//          SSL (12)
//

UCHAR           NegSpnegoMechEncodedOid[] =
                                       { 0x06, 0x7,
                                         0x2b, 0x6,0x1,0x5,0x5,0x2};
ObjectID        NegSpnegoMechOid;
UCHAR           NegMSMechanismsOid[] = { 0x06, 0x0a,                // DER prefix
                                         0x2b, 0x06, 0x01, 0x04, 0x01,
                                         0x82, 0x37, 0x02, 0x02, 0x00 };

const UCHAR     NegKerberosOid[]     = { 0x06, 0x09,                // DER prefix
                                         0x2a, 0x86, 0x48, 0x86, 0xf7,
                                         0x12, 0x01, 0x02, 0x02 };

const UCHAR     NegKerberosLegacyOid[] = { 0x06, 0x09,              // DER prefix
                                         0x2a, 0x86, 0x48, 0x82, 0xf7,
                                         0x12, 0x01, 0x02, 0x02 };



UNICODE_STRING  NegLocalHostName_U ;
WCHAR           NegLocalHostName[] = L"localhost";
DWORD_PTR       NegPackageId;
DWORD_PTR       NtlmPackageId = NEG_INVALID_PACKAGE;
ObjectID        NegNtlmMechOid ;

#ifndef WIN32_CHICAGO
WCHAR           NegPackageName[] = NEGOSSP_NAME ;
WCHAR           NegPackageComment[] = TEXT("Microsoft Package Negotiator");
NT_PRODUCT_TYPE NegProductType;

// computer names (protected by NegComputerNamesLock)
UNICODE_STRING  NegNetbiosComputerName_U;
UNICODE_STRING  NegDnsComputerName_U;
#else
TCHAR           NegPackageName[] = NEGOSSP_NAME ;
TCHAR           NegPackageComment[] = TEXT("Microsoft Package Negotiator");
#endif // WIN32_CHICAGO
LIST_ENTRY      NegPackageList;
LIST_ENTRY      NegCredList;
#ifndef WIN32_CHICAGO
LIST_ENTRY      NegDefaultCredList ;
RTL_RESOURCE    NegLock;
PLSAP_SECURITY_PACKAGE NegLsaPackage ;
LIST_ENTRY      NegLoopbackList ;
LIST_ENTRY      NegLogonSessionList ;
RTL_CRITICAL_SECTION NegLogonSessionListLock ;
RTL_CRITICAL_SECTION NegTrustListLock ;
PNEG_TRUST_LIST NegTrustList ;
LARGE_INTEGER   NegTrustTime ;
RTL_CRITICAL_SECTION    NegComputerNamesLock;
RTL_RESOURCE         NegCredListLock;
#else
RTL_CRITICAL_SECTION NegLock;
RTL_CRITICAL_SECTION NegCredListLock;
#endif // WIN32_CHICAGO
PVOID           NegNotifyHandle;
DWORD           NegPackageCount;
PUCHAR          NegBlob;
DWORD           NegBlobSize;
DWORD           NegOptions;
ULONG           NegMachineState;
BOOL            NegUplevelDomain ;
ULONG           NegNegotiationControl = 1 ;
HANDLE          NegRegistryWatchEvent ;
WCHAR           NegComputerName[ DNS_MAX_NAME_LENGTH ];

typedef struct _NEG_CONTEXT_REQ_MAP {
#define NEG_CONFIG_REQUIRED     0x00000001
#define NEG_CONFIG_OPTIONAL     0x00000002

    ULONG   Level ;
    ULONG   ConfigFlags ;
    ULONG   ContextReq ;
    ULONG   PackageFlag ;
} NEG_CONTEXT_REQ_MAP, * PNEG_CONTEXT_REQ_MAP ;


NEG_CONTEXT_REQ_MAP
NegContextReqMap[] = {
    { 0, NEG_CONFIG_REQUIRED, (ISC_REQ_REPLAY_DETECT | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_INTEGRITY), SECPKG_FLAG_INTEGRITY },
    { 0, NEG_CONFIG_REQUIRED, (ISC_REQ_CONFIDENTIALITY) , SECPKG_FLAG_PRIVACY },
    { 2, NEG_CONFIG_OPTIONAL, (ISC_REQ_MUTUAL_AUTH), SECPKG_FLAG_MUTUAL_AUTH },
    { 0, 0, 0, 0 }
};


#ifndef WIN32_CHICAGO

typedef DWORD (APIENTRY LOGON_NOTIFY)(
    LPCWSTR, PLUID, LPCWSTR, LPVOID,
    LPCWSTR, LPVOID, LPWSTR, LPVOID,
    LPWSTR * );

typedef LOGON_NOTIFY * PLOGON_NOTIFY;

VOID
NegpNotifyNetworkProviders(
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred
    );

#endif  // WIN32_CHICAGO


//
// Primary and secondary credentials used for LocalSystem
//

SECPKG_PRIMARY_CRED       NegPrimarySystemCredentials;



extern "C"
SECURITY_STATUS
SEC_ENTRY
NegpValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    )
{
    UCHAR Test ;
    ULONG ClaimedLength ;
    ULONG ByteCount ;
    ULONG i ;

    if ( Length == 0 )
    {
        return STATUS_SUCCESS ;
    }
    //
    // This does a poor man's validation of the BER encoded SNEGO buffer
    //

    //
    // First, make sure the first byte is a BER value for Context Specific
    //

    Test = Buffer[0] & 0xC0 ;


    if ( (Test != 0x80 ) &&
         (Test != 0x40 ) )
    {
        DebugLog(( DEB_ERROR, "Neg:  Buffer does not lead off with 'Context' or 'Application' specific\n"));
        goto Bad_Buffer ;
    }

    //
    // Now, check the claimed size in the header with the size we were passed:
    //

    Buffer++ ;
    ClaimedLength = 0 ;

    if (*Buffer & 0x80)
    {
        ByteCount = *Buffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            ClaimedLength <<= 8;
            ClaimedLength += *Buffer++;
        }
    }
    else
    {
        ByteCount = 0;
        ClaimedLength = *Buffer++;
    }

    if ( (ClaimedLength + 2 + ByteCount) != Length )
    {
        DebugLog(( DEB_ERROR, "Neg: Packet claimed length %x, actual length is %x\n",
                    ClaimedLength + 2 + ByteCount, Length ));

        goto Bad_Buffer ;
    }

    return STATUS_SUCCESS ;

Bad_Buffer:

    return STATUS_DATA_ERROR ;


}





//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackage
//
//  Synopsis:   Scans the list of negotiable packages for a package id
//
//  Arguments:  [PackageId] --
//
//  History:    8-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_PACKAGE
NegpFindPackage(
    ULONG_PTR PackageId )
{
    PNEG_PACKAGE    Scan;

    NegReadLockList();

    Scan = (PNEG_PACKAGE) NegPackageList.Flink ;

    while ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        if ( Scan->LsaPackage->dwPackageID == PackageId )
        {
            break;
        }

        Scan = (PNEG_PACKAGE) Scan->List.Flink ;

    }

    NegUnlockList();

    if ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        return( Scan );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackageByName
//
//  Synopsis:   Scans the list of negotiable packages for a package name
//
//  Arguments:  [PackageId] --
//
//  History:    8-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_PACKAGE
NegpFindPackageByName(
    PUNICODE_STRING PackageName )
{
    PNEG_PACKAGE    Scan;

    NegReadLockList();

    Scan = (PNEG_PACKAGE) NegPackageList.Flink ;

    while ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        if ( RtlEqualUnicodeString(
                &Scan->LsaPackage->Name,
                PackageName,
                TRUE            // case insensitive
                ))
        {
            break;
        }

        Scan = (PNEG_PACKAGE) Scan->List.Flink ;

    }

    NegUnlockList();

    if ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        return( Scan );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackageByOid
//
//  Synopsis:   Locates a security package by OID.
//
//  Arguments:  [Id] --
//
//  History:    4-23-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_PACKAGE
NegpFindPackageByOid(
    ObjectID    Id
    )
{
    PNEG_PACKAGE    Scan ;
    PLIST_ENTRY List ;
    ULONG i ;

    NegReadLockList();

    List = NegPackageList.Flink ;
    Scan = NULL ;

    while ( List != &NegPackageList )
    {
        Scan = CONTAINING_RECORD( List, NEG_PACKAGE, List );

        if ( NegpCompareOid( Id, Scan->ObjectId ) == 0 )
        {
            break;
        }

        List = List->Flink ;
        Scan = NULL ;
    }

    NegUnlockList();

    return Scan ;
}




ULONG
NegGetPackageCaps(
    ULONG ContextReq
    )
{
    ULONG PackageCap = 0;
    PNEG_CONTEXT_REQ_MAP Scan ;

    Scan = NegContextReqMap ;

    while ( Scan->ContextReq )
    {
        if ( Scan->ConfigFlags & NEG_CONFIG_REQUIRED )
        {
            if ( (Scan->ContextReq & ContextReq ) != 0 )
            {
                PackageCap |= Scan->PackageFlag ;
            }
        }
        else if ( Scan->ConfigFlags & NEG_CONFIG_OPTIONAL )
        {
            if ( NegNegotiationControl >= Scan->Level )
            {
                if ( ( Scan->ContextReq & ContextReq ) != 0 )
                {
                    PackageCap |= Scan->PackageFlag ;
                }
            }
            else
            {
                PackageCap |= 0 ;
            }
        }

        Scan++ ;
    }

    return PackageCap ;

}


#ifndef WIN32_CHICAGO
//+---------------------------------------------------------------------------
//
//  Function:   NegPackageLoad
//
//  Synopsis:   Called by LSA whenever a package is loaded
//
//  Arguments:  [p] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
NegPackageLoad(
    PVOID   p)
{
    NTSTATUS Status ;
    PSECPKG_EVENT_NOTIFY Notify;
    PSECPKG_EVENT_PACKAGE_CHANGE Load;
    PNEG_PACKAGE Package;
    PNEG_PACKAGE ExtraPackage ;
    PLSAP_SECURITY_PACKAGE LsaPackage;
    PSECPKG_EXTENDED_INFORMATION Info ;
    SECPKG_EXTENDED_INFORMATION LocalInfo ;
    ObjectID ClaimedOid = NULL;
    UCHAR Prefix[ NEGOTIATE_MAX_PREFIX ] = { 0 };
    ULONG PrefixLength = 0 ;
    ULONG ExtraOidsCount = 0 ;
    ULONG i ;
    BOOLEAN fKerberosPackage = FALSE;

    Notify = (PSECPKG_EVENT_NOTIFY) p;

    if ( Notify->EventClass != NOTIFY_CLASS_PACKAGE_CHANGE )
    {
        return( 0 );
    }


    Load = ( PSECPKG_EVENT_PACKAGE_CHANGE ) Notify->EventData ;

    DebugLog((DEB_TRACE_NEG, "Package Change Event %d:  %ws (%p) \n",
            Load->ChangeType, Load->PackageName.Buffer, Load->PackageId ));

    if ( Load->PackageId == NegPackageId )
    {
        DebugLog((DEB_TRACE_NEG, "Skipping own load notification\n"));

        NegLsaPackage = SpmpLocatePackage( NegPackageId );

        return( 0 );
    }

    //
    // If this is a package load, add the package to our list:
    //

    if ( Load->ChangeType == SECPKG_PACKAGE_CHANGE_LOAD )
    {
        Info = NULL ;

        LsaPackage = SpmpLookupPackage( &Load->PackageName );

        if (LsaPackage == NULL)
        {
            return( 0 );
        }

        if ( !( LsaPackage->fCapabilities & SECPKG_FLAG_NEGOTIABLE ) )
        {
            return( 0 );
        }

        //
        // If the package supports SP_INFO, query it to see if it has an
        // OID to use in negotiation.
        //

        if ( LsaPackage->fPackage & SP_INFO )
        {
            Status = LsapGetExtendedPackageInfo( LsaPackage,
                                                 SecpkgGssInfo,
                                                 &Info );

            if ( !NT_SUCCESS( Status ) )
            {
                Info = NULL ;
            }

            //
            // Make sure that the claimed OID doesn't conflict with
            // someone already loaded.
            //

            if ( Info )
            {
                ClaimedOid = NegpDecodeObjectId( Info->Info.GssInfo.EncodedId,
                                                 Info->Info.GssInfo.EncodedIdLength );

                RtlCopyMemory( Prefix,
                               Info->Info.GssInfo.EncodedId,
                               Info->Info.GssInfo.EncodedIdLength );

                PrefixLength = Info->Info.GssInfo.EncodedIdLength ;

                //
                // note whether the primary GSS Oid is the kerberos Oid.
                // This allows us to swap the order of the Primary Oid with the legacy Oid
                // later on.
                //

                if ( (Info->Info.GssInfo.EncodedIdLength == sizeof(NegKerberosOid)) &&
                     (memcmp(Info->Info.GssInfo.EncodedId, NegKerberosOid, sizeof(NegKerberosOid)) == 0 )
                    )
                {
                    fKerberosPackage = TRUE;
                }

                LsapFreeLsaHeap( Info );
                if (ClaimedOid == NULL)
                {
                     Info = NULL;
                }
                else if ( NegpFindPackageByOid( ClaimedOid ) )
                {
                    NegpFreeObjectId( ClaimedOid );

                    return 0 ;
                }
            }

            //
            // Check if the package has any additional OIDs to support, or to compensate
            // for a spnego encoding problem.
            //

            Status = LsapGetExtendedPackageInfo( LsaPackage,
                                                 SecpkgExtraOids,
                                                 &Info );

            if ( !NT_SUCCESS( Status ) )
            {
                Info = NULL ;
            }

            LocalInfo.Class = SecpkgMutualAuthLevel ;
            LocalInfo.Info.MutualAuthLevel.MutualAuthLevel = NegNegotiationControl ;

            LsapSetExtendedPackageInfo(
                LsaPackage,
                SecpkgMutualAuthLevel,
                &LocalInfo );


        }

        //
        // If no ID, and Info is NULL, skip it.
        //

        if ( (LsaPackage->dwRPCID == SECPKG_ID_NONE) &&
             (ClaimedOid == NULL ) )
        {
            return( 0 );
        }

        if ( ( Info != NULL ) &&
             ( Info->Class == SecpkgExtraOids ) )
        {
            ExtraOidsCount = Info->Info.ExtraOids.OidCount ;

        }


        Package = (PNEG_PACKAGE) LsapAllocateLsaHeap( sizeof( NEG_PACKAGE ) );

        if ( Package )
        {
            Package->LsaPackage = LsaPackage ;
            Package->Flags = NEG_PACKAGE_INBOUND | NEG_PACKAGE_OUTBOUND ;

            if ( LsaPackage->fPackage & SP_PREFERRED )
            {
                Package->Flags |= NEG_PREFERRED ;
            }

            if ( LsaPackage->dwRPCID == RPC_C_AUTHN_WINNT )
            {
                Package->Flags |= NEG_NT4_COMPAT ;

                NtlmPackageId = Load->PackageId;

                //
                // Cheap and sleazy way of loading the necessary information
                // into the logon session, once we have all the packages loaded.
                //

                NegLsaPolicyChangeCallback( PolicyNotifyDnsDomainInformation );

            }

            Package->TokenSize = LsaPackage->TokenSize ;
            Package->PackageFlags = LsaPackage->fCapabilities ;
            Package->PrefixLen = PrefixLength ;
            RtlCopyMemory( Package->Prefix,
                           Prefix,
                           PrefixLength );

            //
            // add slack space for negotiate header.
            //

            NegLsaPackage->TokenSize = max( (LsaPackage->TokenSize+128),
                                            NegLsaPackage->TokenSize );


            DebugLog(( DEB_TRACE_NEG, "Loaded package %ws\n",
                                Load->PackageName.Buffer ));

            NegWriteLockList();

            if ( ClaimedOid )
            {
                Package->ObjectId = ClaimedOid ;

                NegDumpOid( "Package claimed OID", Package->ObjectId );
            }
            else
            {

                NegMSMechanismsOid[ 0xb ] = (UCHAR) LsaPackage->dwRPCID ;

                Package->ObjectId = NegpDecodeObjectId( NegMSMechanismsOid,
                                                sizeof( NegMSMechanismsOid ) );

                NegDumpOid( "Assigned package OID", Package->ObjectId );

                if ( Package->Flags & NEG_NT4_COMPAT )
                {
                    NegNtlmMechOid = NegpDecodeObjectId( NegMSMechanismsOid,
                                                sizeof( NegMSMechanismsOid ) );
                }

            }

            InsertTailList( &NegPackageList,
                            &Package->List );

            NegPackageCount ++;

            if ( ExtraOidsCount )
            {
                Package->Flags |= NEG_PACKAGE_HAS_EXTRAS ;

                DebugLog(( DEB_TRACE_NEG, "Creating extra packages for %ws\n",
                           Load->PackageName.Buffer ));

                for ( i = 0 ; i < ExtraOidsCount ; i++ )
                {
                    ClaimedOid = NegpDecodeObjectId( Info->Info.ExtraOids.Oids[ i ].OidValue,
                                                     Info->Info.ExtraOids.Oids[ i ].OidLength );


                    if ( !NegpFindPackageByOid( ClaimedOid ))
                    {
                        //
                        // If no one else has used this OID, allow it.
                        //


                        NegDumpOid( "Package claimed extra OID", ClaimedOid );

                        ExtraPackage = (PNEG_PACKAGE) LsapAllocateLsaHeap( sizeof( NEG_PACKAGE ) );

                        if ( ExtraPackage )
                        {
                            ExtraPackage->LsaPackage = Package->LsaPackage ;
                            ExtraPackage->ObjectId = ClaimedOid ;
                            ExtraPackage->RealPackage = Package ;
                            ExtraPackage->Flags = NEG_PACKAGE_EXTRA_OID ;

                            if ( Info->Info.ExtraOids.Oids[ i ].OidAttributes & SECPKG_CRED_INBOUND )
                            {
                                ExtraPackage->Flags |= NEG_PACKAGE_INBOUND ;
                            }

                            if ( Info->Info.ExtraOids.Oids[ i ].OidAttributes & SECPKG_CRED_OUTBOUND )
                            {
                                ExtraPackage->Flags |= NEG_PACKAGE_OUTBOUND ;
                            }

                            ExtraPackage->TokenSize = Package->TokenSize ;
                            ExtraPackage->PackageFlags = Package->PackageFlags ;

                            RtlCopyMemory(
                                ExtraPackage->Prefix,
                                Info->Info.ExtraOids.Oids[ i ].OidValue,
                                Info->Info.ExtraOids.Oids[ i ].OidLength );

                            ExtraPackage->PrefixLen = Info->Info.ExtraOids.Oids[ i ].OidLength ;

                            //
                            // **** NOTE: ****
                            // For legacy compatibility reasons,
                            // the broken Kerberos package Oid is re-ordered ahead
                            // of the correct Oid value.  The was done in order
                            // to avoid an extra round-trip when communicating with
                            // Win2000 machines.  The negotiate protocol itself
                            // recovers with additional round-trips; however,
                            // Wininet is unable to reliably handle such a
                            // circumstance.
                            //

                            if( fKerberosPackage &&
                                (Info->Info.ExtraOids.Oids[ i ].OidLength == sizeof(NegKerberosLegacyOid)) &&
                                (memcmp(Info->Info.ExtraOids.Oids[ i ].OidValue, NegKerberosLegacyOid, sizeof(NegKerberosLegacyOid)) == 0)
                                )
                            {
                                ObjectID SwapOid;

                                DebugLog((DEB_TRACE_NEG, "Re-ordering legacy Kerberos Oid\n"));

                                SwapOid = Package->ObjectId;

                                Package->ObjectId = ExtraPackage->ObjectId;
                                ExtraPackage->ObjectId = SwapOid;
                            }

                            InsertTailList( &NegPackageList,
                                            &ExtraPackage->List );

                            NegPackageCount ++;

                        }
                        else
                        {
                            //
                            // Free the OID, skip this extra package
                            //

                            NegpFreeObjectId( ClaimedOid );
                        }
                    }
                    else
                    {
                        //
                        // Free it
                        //

                        NegpFreeObjectId( ClaimedOid );
                    }


                }


            }
            NegUnlockList();

        }
    }
    else
    {
        //
        // It's either a select or an unload:
        //



        Package = NegpFindPackage( Load->PackageId );

        //
        // if we don't have this package (it may not have been negotiable)
        // return now.
        //

        if (Package == NULL)
        {
            return(0);
        }

        if ( Load->ChangeType == SECPKG_PACKAGE_CHANGE_SELECT )
        {
            Package->Flags |= NEG_PREFERRED ;
        }
        else
        {
            NegWriteLockList();

            RemoveEntryList( &Package->List );

            NegUnlockList();

            NegpFreeObjectId( Package->ObjectId );

            LsapFreeLsaHeap( Package );

        }
    }

    return( 0 );

}
#else // WIN32_CHICAGO
//+---------------------------------------------------------------------------
//
//  Function:   NegPackageLoad
//
//  Synopsis:   Called by Negotiate package load only once
//
//  Arguments:  [p] --
//
//  History:    10-02-97   ChandanS Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
NegPackageLoad(
    BOOLEAN fLoad,
    DWORD   dwPackageID,
    LPTSTR  Name,
    DWORD   fCapabilities,
    DWORD   fPackage,
    DWORD   dwRPCID,
    DWORD   TokenSize
    )
{
    NTSTATUS Status  = STATUS_SUCCESS;
    PNEG_PACKAGE Package;
    PLSAP_SECURITY_PACKAGE LsaPackage;

    //
    // If this is a package load, add the package to our list:
    //

    DebugLog(( DEB_TRACE_NEG, "NegPackageLoad called for fLoad %d, dwPackageID %d, Name %d, fCapabilities 0x%x, dwRPCID %d, TokenSize %d\n", fLoad, dwPackageID, Name, fCapabilities, dwRPCID, TokenSize));
    if ( fLoad )
    {
        DebugLog(( DEB_TRACE_NEG, "package %s is being loaded\n", Name));
        Package = (PNEG_PACKAGE) LsapAllocateLsaHeap( sizeof( NEG_PACKAGE ) );

        if ( Package )
        {
            LsaPackage = (PLSAP_SECURITY_PACKAGE) LsapAllocateLsaHeap( sizeof( LSAP_SECURITY_PACKAGE ) );

            if ( !LsaPackage )
            {
                LsapFreeLsaHeap( Package );
                DebugLog(( DEB_TRACE_NEG, "package %s was not loaded\n", Name));
                return SEC_E_INSUFFICIENT_MEMORY;
            }
            DebugLog(( DEB_TRACE_NEG, "package %s is NOW loaded\n", Name));
            LsaPackage->dwPackageID = dwPackageID;
            LsaPackage->fCapabilities = fCapabilities;
            LsaPackage->fPackage = fPackage;
            LsaPackage->dwRPCID = dwRPCID;
            LsaPackage->TokenSize = TokenSize;

            Status = RtlCreateUnicodeStringFromAsciiz(
                    &LsaPackage->Name,
                    Name
                    );

            Package->LsaPackage = LsaPackage ;

            Package->TokenSize = LsaPackage->TokenSize ;

            DebugLog(( DEB_TRACE_NEG, "Loaded package %ws\n",
                                LsaPackage->Name.Buffer ));

            NegWriteLockList();

            NegMSMechanismsOid[ 0xb ] = (UCHAR) LsaPackage->dwRPCID ;

            Package->ObjectId = NegpDecodeObjectId( NegMSMechanismsOid,
                                            sizeof( NegMSMechanismsOid ) );

            NegDumpOid( "Assigned package OID", Package->ObjectId );

            InsertTailList( &NegPackageList,
                            &Package->List );

            NegPackageCount ++;

            NegUnlockList();

        }
        else
        {
            DebugLog(( DEB_TRACE_NEG, "package %s was never loaded\n", Name));
            Status = SEC_E_INSUFFICIENT_MEMORY;
        }
    }
    else
    {
        DebugLog(( DEB_TRACE_NEG, "package %s is being unloaded\n", Name));
        //
        // It's either a select or an unload:
        //


        Package = NegpFindPackage( dwPackageID );

        //
        // if we don't have this package (it may not have been negotiable)
        // return now.
        //

        if (Package == NULL)
        {
            return(0);
        }

        NegWriteLockList();

        RemoveEntryList( &Package->List );

        NegUnlockList();

        NegpFreeObjectId( Package->ObjectId );

        LsapFreeLsaHeap( Package );

    }

    return( Status );

}
#endif // WIN32_CHICAGO


//+---------------------------------------------------------------------------
//
//  Function:   NegpParseBuffers
//
//  Synopsis:   Parse out juicy bits
//
//  Arguments:  [pMessage] --
//              [pToken]   --
//              [pEmpty]   --
//
//  History:    8-19-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegpParseBuffers(
    PSecBufferDesc  pMessage,
    BOOL            Map,
    PSecBuffer *    pToken,
    PSecBuffer *    pEmpty)
{
    ULONG       i;
    SECURITY_STATUS scRet ;
    PSecBuffer  pFirstBlank = NULL;
    PSecBuffer  pWholeMessage = NULL;
    PSecBuffer  pFirstToken = NULL;

    scRet = SEC_E_OK ;

    for (i = 0 ; i < pMessage->cBuffers ; i++ )
    {
        if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN )
        {
            pWholeMessage = &pMessage->pBuffers[i];

            if ( pFirstToken == NULL )
            {
                pFirstToken = pWholeMessage;
            }

            if ( Map )
            {
                scRet = LsapMapClientBuffer( pWholeMessage, pWholeMessage );
            }

            if (pFirstBlank)
            {
                break;
            }
        }
        else if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_EMPTY )
        {
            pFirstBlank = &pMessage->pBuffers[i];
            if (pWholeMessage)
            {
                break;
            }
        }
    }

    if (pToken)
    {
//        *pToken = pWholeMessage;

        //
        // NTBUG: 405976
        // down-level RDR supplies 2 SECBUFFER_TOKEN buffers, the second
        // one containing creds.  Insure we return the first one.
        //

        *pToken = pFirstToken;
    }

    if (pEmpty)
    {
        *pEmpty = pFirstBlank;
    }

    return( scRet );

}




//+---------------------------------------------------------------------------
//
//  Function:   NegInitialize
//
//  Synopsis:   Initialize the built in negotiate package
//
//  Arguments:  [dwProtocol]    --
//              [dwPackageID]   --
//              [pParameters]   --
//              [pPkgFunctions] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:      This package must be the last package, since it must query
//              the others to find out their capabilities.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
NegInitialize(
                ULONG_PTR           dwPackageID,
                PSECPKG_PARAMETERS  pParameters,
                PLSA_SECPKG_FUNCTION_TABLE  Table)
{


    HKEY LsaKey ;
    int err ;
    DWORD size ;
    DWORD type ;
    NTSTATUS Status ;


    NegPackageId = dwPackageID;

#ifndef WIN32_CHICAGO
    Status = RtlInitializeCriticalSection( &NegComputerNamesLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    NegNotifyHandle = LsaIRegisterNotification( NegPackageLoad,
                                                0,
                                                NOTIFIER_TYPE_NOTIFY_EVENT,
                                                NOTIFY_CLASS_PACKAGE_CHANGE,
                                                0,
                                                0,
                                                0 );

    InitializeListHead( &NegDefaultCredList );

    InitializeListHead( &NegLoopbackList );

    InitializeListHead( &NegLogonSessionList );


    Status = RtlInitializeCriticalSection( &NegLogonSessionListLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Status = RtlInitializeCriticalSection( &NegTrustListLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }


#endif // WIN32_CHICAGO

    RtlInitUnicodeString( &NegLocalHostName_U, NegLocalHostName );

    __try
    {

        RtlInitializeResource( &NegLock );
        Status = STATUS_SUCCESS ;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }
    InitializeListHead( &NegPackageList );

#ifndef WIN32_CHICAGO
    __try
    {
        RtlInitializeResource( &NegCredListLock );
        Status = STATUS_SUCCESS ;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

#else
    Status = RtlInitializeCriticalSection( &NegCredListLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }
#endif

    InitializeListHead( &NegCredList );

    NegPackageCount = 0;

    NegSpnegoMechOid = NegpDecodeObjectId(NegSpnegoMechEncodedOid, sizeof(NegSpnegoMechEncodedOid));
    if (NegSpnegoMechOid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NegMachineState = pParameters->MachineState;

    if ( ( pParameters->DomainSid != NULL ) &&
         ( pParameters->DnsDomainName.Length != 0 ) )
    {
        NegUplevelDomain = TRUE ;
    }

#ifndef WIN32_CHICAGO
    //
    // Ignore the status - if we don't get a callback, then we can't support
    // dynamic domain change.  If it succeeds, then great.
    //

    LsaIRegisterPolicyChangeNotificationCallback(
                NegLsaPolicyChangeCallback,
                PolicyNotifyDnsDomainInformation );

    LsaIRegisterNotification( NegParamChange,
                              0,
                              NOTIFIER_TYPE_NOTIFY_EVENT,
                              NOTIFY_CLASS_REGISTRY_CHANGE,
                              0,
                              0,
                              0 );
    //
    // get the product type for loopback logic.
    //

    if (!RtlGetNtProductType( &NegProductType ) )
    {
        NegProductType = NtProductWinNt;
    }

#endif

#ifdef WIN32_CHICAGO

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\Negotiate"),
                0,
                KEY_READ,
                &LsaKey );

#else

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                0,
                KEY_READ,
                &LsaKey );


#endif

    if ( err == 0 )
    {
        NegpReadRegistryParameters( LsaKey );

        RegCloseKey( LsaKey );
    }


    return(S_OK);
}



VOID
NegpReadRegistryParameters(
    HKEY LsaKey
    )
{
    DWORD size ;
    DWORD type ;
    int err ;

    //
    // These values are not MP sensitive, so we just blast the new value
    // into them.
    //

    size = sizeof( DWORD );

    err = RegQueryValueEx(
            LsaKey,
            TEXT("NegotiationLevel"),
            NULL,
            &type,
            (LPBYTE) &NegNegotiationControl,
            &size );

    if ( err != 0 )
    {
        NegNegotiationControl = NEG_NEGLEVEL_COMPATIBILITY ;
    }
#ifndef WIN32_CHICAGO

    size = sizeof( DWORD );

    err = RegQueryValueEx(
            LsaKey,
            TEXT("NegotiationLogLevel"),
            NULL,
            &type,
            (LPBYTE) &NegEventLogLevel,
            &size );

    if ( err )
    {
        NegEventLogLevel = (1 << EVENTLOG_ERROR_TYPE ) |
                           (1 << EVENTLOG_WARNING_TYPE ) ;
    }
#endif

}


//+---------------------------------------------------------------------------
//
//  Function:   NegGetInfo
//
//  Synopsis:   Negotiate Package GetInfo call
//
//  Arguments:  [pInfo] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
NegGetInfo(PSecPkgInfo pInfo)
{
    pInfo->wVersion         = 1;
    pInfo->wRPCID           = NEGOSSP_RPCID ;
    pInfo->fCapabilities    = SECPKG_FLAG_INTEGRITY |
                              SECPKG_FLAG_PRIVACY |
                              SECPKG_FLAG_CONNECTION |
                              SECPKG_FLAG_MULTI_REQUIRED |
                              SECPKG_FLAG_EXTENDED_ERROR |
                              SECPKG_FLAG_IMPERSONATION |
                              SECPKG_FLAG_ACCEPT_WIN32_NAME |
                              SECPKG_FLAG_NEGOTIABLE |
                              SECPKG_FLAG_GSS_COMPATIBLE |
                              SECPKG_FLAG_LOGON;

    pInfo->cbMaxToken       = 500;
    pInfo->Name             = NEGOSSP_NAME;
    pInfo->Comment          = NegPackageComment;

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   NegAcceptCredentials
//
//  Synopsis:   Notification of a logon
//
//  Arguments:  [LogonType]         --
//              [UserName]          --
//              [PrimaryCred]       --
//              [SupplementalCreds] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCreds)
{

#ifndef WIN32_CHICAGO

    LUID     SystemId = SYSTEM_LUID;
    NTSTATUS Status;

    if (RtlEqualLuid(&PrimaryCred->LogonId, &SystemId))
    {
        //
        // Stash away the LocalSystem credentials to use
        // for NetworkService logons later on.
        //

        Status = NegpCopyCredsToBuffer(PrimaryCred,
                                       NULL,
                                       &NegPrimarySystemCredentials,
                                       NULL);

        return Status;
    }
    else if (LogonType == Service)
    {
        LUID  LocalServiceId   = LOCALSERVICE_LUID;
        LUID  NetworkServiceId = NETWORKSERVICE_LUID;

        //
        // Notify the network providers of the logon.  Don't notify
        // for SYSTEM, LocalService, or NetworkService.
        //

        if (!RtlEqualLuid(&PrimaryCred->LogonId, &LocalServiceId)
             &&
            !RtlEqualLuid(&PrimaryCred->LogonId, &NetworkServiceId))
        {
            NegpNotifyNetworkProviders(UserName, PrimaryCred);
        }
    }

#endif  // WIN32_CHICAGO

    return SEC_E_OK;
}


#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   NegpNotifyNetworkProviders
//
//  Synopsis:   Notifies network providers of a logon
//
//  Effects:
//
//  Arguments:  [UserName]    --
//              [PrimaryCred] --
//
//  Requires:
//
//  Returns:  Nothing since this is an advisory service to
//            other network providers.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
NegpNotifyNetworkProviders(
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    MSV1_0_INTERACTIVE_LOGON    NewLogon;
    static HMODULE              s_hMprDll = NULL;
    PLOGON_NOTIFY               pfLogonNotify = NULL;
    LPWSTR                      lpLogonScripts = NULL;
    DWORD                       dwStatus;

    if (s_hMprDll == NULL)
    {
        s_hMprDll = LoadLibrary(L"mpr.dll");
    }

    if (s_hMprDll != NULL)
    {
        pfLogonNotify = (PLOGON_NOTIFY) GetProcAddress(s_hMprDll,
                                                       "WNetLogonNotify");

        if (pfLogonNotify != NULL)
        {
            NewLogon.MessageType     = MsV1_0InteractiveLogon;
            NewLogon.LogonDomainName = PrimaryCred->DomainName;
            NewLogon.UserName        = *UserName;
            NewLogon.Password        = PrimaryCred->Password;

            RtlCopyMemory(&OldLogon, &NewLogon, sizeof(NewLogon));

            dwStatus = pfLogonNotify(L"Windows NT Network Provider",
                                     &PrimaryCred->LogonId,
                                     L"MSV1_0:Interactive",
                                     &NewLogon,
                                     L"MSV1_0:Interactive",
                                     &OldLogon,
                                     L"SvcCtl",            // StationName
                                     NULL,                 // StationHandle
                                     &lpLogonScripts);     // LogonScripts

            if (dwStatus == NO_ERROR)
            {
                LocalFree(lpLogonScripts);
            }
        }
    }
}

#endif  // WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   NegpCopyCredsToBuffer
//
//  Synopsis:   Copies primary and supplemental creds into the supplied
//              buffers
//
//  Effects:
//
//  Arguments:  [PrimaryCred]          --
//              [SupplementalCred]     --
//              [PrimaryCredCopy]      --
//              [SupplementalCredCopy] --
//
//  Requires:
//
//  Returns:
//
//  Notes:      Leaves the SID and LUID blank.  It is the caller's
//              responsibility to fill these fields in.
//
//--------------------------------------------------------------------------

NTSTATUS
NegpCopyCredsToBuffer(
    IN  PSECPKG_PRIMARY_CRED      PrimaryCred,
    IN  PSECPKG_SUPPLEMENTAL_CRED SupplementalCred,
    OUT PSECPKG_PRIMARY_CRED      PrimaryCredCopy OPTIONAL,
    OUT PSECPKG_SUPPLEMENTAL_CRED SupplementalCredCopy OPTIONAL
    )
{
    NTSTATUS  Status;

    if (PrimaryCredCopy)
    {
        Status = LsapDuplicateString(&PrimaryCredCopy->DomainName,
                                     &PrimaryCred->DomainName);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredCopy->DownlevelName,
                                     &PrimaryCred->DownlevelName);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredCopy->Password,
                                     &PrimaryCred->Password);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        PrimaryCredCopy->Flags = PRIMARY_CRED_CLEAR_PASSWORD;
    }

    if (SupplementalCredCopy)
    {
        Status = LsapDuplicateString(&SupplementalCredCopy->PackageName,
                                     &SupplementalCred->PackageName);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        SupplementalCredCopy->Credentials = (PUCHAR) (SupplementalCredCopy + 1);

        RtlCopyMemory(SupplementalCredCopy,
                      SupplementalCred->Credentials,
                      SupplementalCred->CredentialSize);

    }

    return( SEC_E_OK );

ErrorExit:

    if (PrimaryCredCopy)
    {
        LsapFreeLsaHeap(PrimaryCredCopy->DomainName.Buffer);
        LsapFreeLsaHeap(PrimaryCredCopy->DownlevelName.Buffer);
        LsapFreeLsaHeap(PrimaryCredCopy->Password.Buffer);
    }

    return( STATUS_NO_MEMORY );
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpCaptureSuppliedCreds
//
//  Synopsis:   Captures a SEC_WINNT_AUTH_IDENTITY_EX structure from
//              the client
//
//  Effects:
//
//  Arguments:  AuthorizationData - Client address of auth data
//              PackageList - List of packages from the auth data.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NegpCaptureSuppliedCreds(
    IN PVOID AuthorizationData,
    OUT PNEG_PACKAGE ** ReturnedPackageList,
    OUT PULONG ReturnedPackageCount,
    OUT PBOOL ExplicitCreds,
    OUT PBOOL DomainExplicitCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SEC_WINNT_AUTH_IDENTITY_EXW IdentityEx = {0};
    SEC_WINNT_AUTH_IDENTITY_W * Identity;
    PSTR PackageList = NULL;
    UNICODE_STRING PackageString = {0};
    ULONG PackageListLength;
    ULONG CharSize = sizeof(WCHAR);
    ULONG Index;
    ULONG PackageCount;
    ULONG PackageIndex;
    ULONG ExclusionIndex ;
    ULONG FinalIndex ;
    ULONG PossiblePackageCount ;
    ULONG i, j;
    PNEG_PACKAGE * LocalPackageList = NULL;
    PNEG_PACKAGE * ExclusionList = NULL ;
    PNEG_PACKAGE * FinalList = NULL ;
    PNEG_PACKAGE Package ;
    PLIST_ENTRY List ;
    PNEG_PACKAGE PackageScan ;
    UNICODE_STRING TempString;
    PWSTR Scan, EndPoint, Comma ;



    *ReturnedPackageList = NULL;
    *ReturnedPackageCount = 0;

    *ExplicitCreds = FALSE ;
    *DomainExplicitCreds = FALSE ;


    //
    // First capture the base structure
    //

    Status =  LsapCopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_W),
                    &IdentityEx,
                    AuthorizationData
                    );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to copy auth data from %p client address: 0x%x\n",
            AuthorizationData, Status ));
        *ExplicitCreds = TRUE ;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Check if this is the right structure
    //

    if (IdentityEx.Version != SEC_WINNT_AUTH_IDENTITY_VERSION)
    {
        Identity = (PSEC_WINNT_AUTH_IDENTITY_W) &IdentityEx ;

        if ( (Identity->UserLength > 0 ) ||
             (Identity->DomainLength > 0 ) ||
             (Identity->PasswordLength > 0 ||
              Identity->Password != NULL) )
        {
            *ExplicitCreds = TRUE ;

            if( Identity->DomainLength )
            {
                *DomainExplicitCreds = TRUE;
            }
        }
        goto Cleanup;
    }

    //
    // Copy the whole data structure now
    //

    Status =  LsapCopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                    &IdentityEx,
                    AuthorizationData
                    );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to copy auth data from %p client address: 0x%x\n",
            AuthorizationData, Status ));
        *ExplicitCreds = TRUE ;
        //
        // Mask this error, as it may have been data for another package.
        //
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Check to see if this contains a list of packages
    //
    //


    if (IdentityEx.Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
    {
        CharSize = sizeof(CHAR);
    }


    //
    // If there was no packge list in the data, return now.
    //

    if ( ( IdentityEx.UserLength > 0 ) ||
         ( IdentityEx.DomainLength > 0 ) ||
         ( IdentityEx.PasswordLength > 0 ||
           IdentityEx.Password != NULL ) )
    {
        *ExplicitCreds = TRUE ;

        if( IdentityEx.DomainLength )
        {
            *DomainExplicitCreds = TRUE;
        }
    }

    if ((IdentityEx.Length < sizeof(SEC_WINNT_AUTH_IDENTITY_EXW)) ||
        (IdentityEx.PackageList == NULL) ||
        (IdentityEx.PackageListLength == 0))
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    if ( (IdentityEx.PackageListLength + 1) * CharSize < IdentityEx.PackageListLength )
    {
        //
        // Passed size is too large (we rolled over)
        //

        Status = STATUS_INVALID_PARAMETER ;
        goto Cleanup ;
    }

    //
    // Capture the package list itself
    //

    PackageList = (PSTR) LsapAllocateLsaHeap(CharSize * (IdentityEx.PackageListLength + 1));
    if (PackageList == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    Status = LsapCopyFromClientBuffer(
                NULL,
                CharSize * IdentityEx.PackageListLength,
                PackageList,
                IdentityEx.PackageList
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to copy package list\n"));
        goto Cleanup;
    }


    //
    // Conver the package list into a useable form, including changing
    // character sets.
    //

    if (CharSize == sizeof(CHAR))
    {
        ((LPSTR)PackageList)[IdentityEx.PackageListLength] = '\0';
        if ( !RtlCreateUnicodeStringFromAsciiz(
                    &PackageString,
                    PackageList
                    ) )
        {
            goto Cleanup;
        }
    }
    else
    {
        ((LPWSTR)PackageList)[IdentityEx.PackageListLength] = L'\0';
        RtlInitUnicodeString(
            &PackageString,
            (LPWSTR) PackageList
            );
        PackageList = NULL;
    }

    //
    // Scan through counting for ',' separators to get a count of packages.
    //

    PackageCount = 1;
    for (Index = 0; Index < PackageString.Length / sizeof(WCHAR) ; Index++ )
    {
        if (PackageString.Buffer[Index] == L',')
        {
            PackageCount++;
        }
    }

    //
    // If there was nothing in the list, continue as if it wasn't there
    //

    if (PackageCount == 0)
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Allocate the package list
    //


    LocalPackageList = (PNEG_PACKAGE *) LsapAllocateLsaHeap( PackageCount * sizeof( PNEG_PACKAGE ) );
    if (LocalPackageList == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    ExclusionList = (PNEG_PACKAGE *) LsapAllocateLsaHeap( PackageCount * sizeof( PNEG_PACKAGE ) );

    if ( ExclusionList ==  NULL )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
        goto Cleanup ;
    }


    //
    // Now go through the string of packages and build the list
    //

    PackageIndex = 0;
    ExclusionIndex = 0;
    TempString.Buffer = PackageString.Buffer;
    TempString.Length = 0;
    TempString.MaximumLength = PackageString.MaximumLength;

    Index = 0;
    Scan = PackageString.Buffer ;
    EndPoint = Scan + (PackageString.Length / sizeof( WCHAR ));

    while ( Scan < EndPoint )
    {
        Comma = wcschr( Scan, L',' );

        if ( Comma )
        {
            *Comma = L'\0' ;
        }
        if ( *Scan == L'!' )
        {
            //
            // This entry is an exclusion.  Skip past the ! char,
            // and try to find a package
            //

            Scan++ ;

            if ( Scan != Comma )
            {
                RtlInitUnicodeString( &TempString, Scan );

                ExclusionList[ ExclusionIndex ] = NegpFindPackageByName( &TempString );

                if ( ExclusionList[ ExclusionIndex ] != NULL )
                {
                    ExclusionIndex++ ;
                }
            }
        }
        else
        {
            //
            // This entry is a request.  Try to find the package
            //

            RtlInitUnicodeString( &TempString, Scan );

            LocalPackageList[ PackageIndex ] = NegpFindPackageByName( &TempString );

            if ( LocalPackageList[ PackageIndex ] != NULL )
            {
                PackageIndex++ ;
            }

        }

        if ( Comma )
        {
            *Comma = L',';
            Scan = Comma + 1 ;
        }
        else
        {
            Scan = EndPoint ;
        }
    }

    //
    // Now, we have two lists.  We have an ExclusionList, of packages that the caller
    // does not want, and a package list, a list of things that the caller does want.
    // Merge the list according to the requests
    //

    PossiblePackageCount = NegPackageCount ;
    FinalIndex = 0 ;
    FinalList = (PNEG_PACKAGE *) LsapAllocateLsaHeap( PossiblePackageCount * sizeof( PNEG_PACKAGE ) );

    if ( FinalList == NULL )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
        goto Cleanup ;
    }

    for ( i = 0 ; i < PackageIndex ; i++ )
    {
        //
        // Pick a package off the request list
        //

        Package = LocalPackageList[ i ];

        //
        // Scan through the exclusion list, see if we need to skip it.
        //

        for ( j = 0 ; j < ExclusionIndex ; j++ )
        {
            if ( Package == ExclusionList[ j ] )
            {
                break;
            }
        }

        if ( j < ExclusionIndex )
        {
            //
            // if we broke out of the loop, we found this on the exclusion list.
            // skip it by continuing the for-i loop.
            //

            continue;
        }

        //
        // Ok, this package is not excluded.  So add it to the final list
        //

        FinalList[ FinalIndex ] = Package;
        FinalIndex++ ;

        //
        // See if this package has "extra" packages by the same name with
        // other OIDs associated with it
        //

        if ( (Package->Flags & NEG_PACKAGE_HAS_EXTRAS) != 0 )
        {
            //
            // Ok, there are a set of packages associated with this package.  Walk the
            // package list, and stick the extras into this one.
            //

            NegReadLockList();

            List = NegPackageList.Flink ;

            while ( List != &NegPackageList )
            {
                PackageScan = CONTAINING_RECORD( List, NEG_PACKAGE, List );

                if ( PackageScan->RealPackage == Package )
                {
                    FinalList[ FinalIndex ] = PackageScan ;
                    FinalIndex++ ;
                }

                List = List->Flink ;
            }

            NegUnlockList();

        }

    }

    if ( (PackageIndex == 0) &&
         (ExclusionIndex != 0 ) )
    {
        //
        // Only an exclusion list was provided.  Walk all the packages,
        // and add those that are not excluded.
        //

        NegReadLockList();

        List = NegPackageList.Flink ;

        while ( List != &NegPackageList )
        {
            PackageScan = CONTAINING_RECORD( List, NEG_PACKAGE, List );

            if ( ( PackageScan->Flags & NEG_PACKAGE_EXTRA_OID ) != 0 )
            {
                Package = PackageScan->RealPackage ;
            }
            else
            {
                Package = PackageScan ;
            }

            for ( i = 0 ; i < ExclusionIndex ; i++ )
            {
                if ( Package == ExclusionList[ i ] )
                {
                    break;
                }
            }

            if ( i < ExclusionIndex )
            {
                continue;
            }

            FinalList[ FinalIndex ] = PackageScan ;
            FinalIndex++ ;

        }

        NegUnlockList();
    }

    //
    // If no packages succeeded, return an error
    //

    if (PackageIndex == 0)
    {
        Status = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }
    *ReturnedPackageCount = FinalIndex;
    *ReturnedPackageList = FinalList;
    FinalList = NULL;

Cleanup:


    if (PackageList != NULL)
    {
        LsapFreeLsaHeap(PackageList);
        if (PackageString.Buffer != NULL)
        {
            RtlFreeUnicodeString( &PackageString );
        }
    }
    else
    {
        if (PackageString.Buffer != NULL)
        {
            LsapFreeLsaHeap(PackageString.Buffer);
        }
    }

    if (LocalPackageList != NULL)
    {
        LsapFreeLsaHeap(LocalPackageList);
    }

    if ( ExclusionList != NULL )
    {
        LsapFreeLsaHeap( ExclusionList );
    }

    if ( FinalList != NULL )
    {
        LsapFreeLsaHeap( FinalList );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpBuildPackageList
//
//  Synopsis:   Builds the list of packages for the caller
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NegpBuildPackageList(
    IN ULONG_PTR LogonPackageId,
    IN ULONG fCredentials,
    OUT PNEG_PACKAGE ** ReturnedPackageList,
    OUT PULONG ReturnedPackageCount
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNEG_PACKAGE Package;
    PNEG_PACKAGE ClientNegPackage = NULL;
    PNEG_PACKAGE *PackageList = NULL;
    PLIST_ENTRY Scan ;
    ULONG PackageIndex = 0;
    ULONG PackageMask ;

    *ReturnedPackageList = NULL;
    *ReturnedPackageCount = 0;

    PackageList = (PNEG_PACKAGE *) LsapAllocateLsaHeap(NegPackageCount * sizeof(PNEG_PACKAGE));
    if (PackageList == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Find the client's logon package
    //

    Scan = NegPackageList.Flink ;

    Package = (PNEG_PACKAGE) NegPackageList.Flink ;

    while ( Scan != &NegPackageList )
    {
        Package = CONTAINING_RECORD( Scan, NEG_PACKAGE, List );

        if (Package->LsaPackage->dwPackageID == LogonPackageId)
        {
            ClientNegPackage = Package;
            break;
        }
        Scan = Scan->Flink ;

    }

    //
    // Compute a mask of package flags to use as part of the selection
    // process.  This is currently based on the credential use flags passed in
    //

    PackageMask = 0 ;

    if ( fCredentials & SECPKG_CRED_INBOUND )
    {
        PackageMask |= NEG_PACKAGE_INBOUND ;
    }

    if ( fCredentials & SECPKG_CRED_OUTBOUND )
    {
        PackageMask |= NEG_PACKAGE_OUTBOUND ;
    }

    //
    // Build the list of packages, with the logon package first
    //


    if ( ClientNegPackage )
    {
        PackageList[ PackageIndex ] = ClientNegPackage ;
        PackageIndex = 1;
    }

    Scan = NegPackageList.Flink ;

    while ( Scan != &NegPackageList )
    {
        Package = CONTAINING_RECORD( Scan, NEG_PACKAGE, List );

        //
        // ClientNegPackage has already been processed, skip it
        //

        if ( Package != ClientNegPackage )
        {
            //
            // Make sure that the package flags support the request.
            //

            if ( (Package->Flags & PackageMask ) == PackageMask )
            {
                PackageList[PackageIndex] = Package;
                PackageIndex++;
            }

        }

        Scan = Scan->Flink ;
    }

    *ReturnedPackageList = PackageList;
    PackageList = NULL;
    *ReturnedPackageCount = PackageIndex;
Cleanup:
    if (PackageList != NULL)
    {
        LsapFreeLsaHeap(PackageList);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NegpCheckForDuplicateCreds
//
//  Synopsis:   Check to see if this is a duplicate of another
//              credential
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
NegpCheckForDuplicateCreds(
    IN PNEG_CREDS * Credential
    )
{
    PLIST_ENTRY Next;
    PNEG_CREDS MatchCred;
    PNEG_CREDS LocalCred = *Credential;

    NegReadLockCredList();

    for (Next = NegCredList.Flink; Next != &NegCredList; Next = Next->Flink )
    {
        MatchCred = CONTAINING_RECORD(
                        Next,
                        NEG_CREDS,
                        List
                        );

        if(!( MatchCred->ClientProcessId == LocalCred->ClientProcessId ) )
        {
            continue;
        }

        if(!RtlEqualLuid( &MatchCred->ClientLogonId, &LocalCred->ClientLogonId ) )
        {
            continue;
        }

        //
        // Check if this credential has the same credentials
        // as the one we just created.  Make sure they are both
        // from user or kernel mode (don't mix'n'match)
        //

        if ( ( MatchCred->Count == LocalCred->Count ) &&
             ( MatchCred->Flags == LocalCred->Flags ) &&
             ( (MatchCred->Flags & NEGCRED_DUP_MASK ) == (LocalCred->Flags & NEGCRED_DUP_MASK ) ) )
        {
            if ( !RtlEqualMemory(
                        MatchCred->Creds,
                        LocalCred->Creds,
                        LocalCred->Count * sizeof( NEG_CRED_HANDLE ) ) )
            {
                ULONG i ;

                DebugLog(( DEB_TRACE_NEG, "Same Process, same count, differing handles?\n" ));
                for ( i = 0 ; i < LocalCred->Count ; i++ )
                {
                    DebugLog(( DEB_TRACE_NEG, "  %d: new <%p : %p> existing (%p : %p)\n",
                               i,
                               LocalCred->Creds[i].Handle.dwLower,
                               LocalCred->Creds[i].Handle.dwUpper,
                               MatchCred->Creds[i].Handle.dwLower,
                               MatchCred->Creds[i].Handle.dwUpper ));

                }
            }
            else
            {
                ULONG_PTR PackageId;
                ULONG i ;

                NegWriteLockCreds( MatchCred );

                if( MatchCred->RefCount == 0 )
                {
                    NegUnlockCreds( MatchCred );
                    continue;
                }

                MatchCred->RefCount++ ;

                NegUnlockCreds( MatchCred );
                NegUnlockCredList();

                //
                // blot out the handle so the refcount is kept in sync
                // with what the underlying packages believe.
                //

                PackageId = GetCurrentPackageId();

                for ( i = 0 ; i < LocalCred->Count ; i++ )
                {
#ifndef WIN32_CHICAGO
                    if( (LocalCred->Creds[i].Flags & NEG_CREDHANDLE_EXTRA_OID) == 0 )
                    {
                        WLsaFreeCredHandle( &LocalCred->Creds[i].Handle );
                    }
#else
                    FreeCredentialsHandle( &LocalCred->Creds[i].Handle );
#endif // WIN32_CHICAGO

                    LocalCred->Creds[i].Handle.dwLower = NEG_INVALID_PACKAGE;
                    LocalCred->Creds[i].Handle.dwUpper = NEG_INVALID_PACKAGE;
                }

                SetCurrentPackageId( PackageId );

                NegpReleaseCreds( LocalCred, FALSE );

                *Credential = MatchCred ;

                return TRUE;
            }
        }
    }

    NegUnlockCredList( );

    return FALSE;

}



SECURITY_STATUS
NegpAcquireCredHandle(
    PSECURITY_STRING    psPrincipal,
    ULONG               fCredentials,
    PLUID               pLogonID,
    PVOID               pvAuthData,
    PVOID               pvGetKeyFn,
    PVOID               pvGetKeyArgument,
    PULONG_PTR          pdwHandle,
    PTimeStamp          ptsExpiry)
{

    NEG_CRED_HANDLE Creds[ NEG_MECH_LIMIT ];
    PNEG_CRED_HANDLE pCreds = NULL;
    DWORD i = 0;
    ULONG Index;
    BOOL        FreeCreds = FALSE;
    PNEG_PACKAGE Package;
    PNEG_PACKAGE ClientNegPackage = NULL;
    PNEG_PACKAGE * AuthPackageList = NULL;
    ULONG AuthPackageCount = 0;
    SECURITY_STATUS scRet = STATUS_SUCCESS;
    TimeStamp   Expiry = { 0 };

    PNEG_CREDS  pNegCreds = NULL ;
    ULONG_PTR PackageId;
    SECPKG_CLIENT_INFO ClientInfo;
#ifndef WIN32_CHICAGO
    PLSA_CALL_INFO CallInfo ;
    PLSAP_LOGON_SESSION LogonSession = NULL;
    PNEG_LOGON_SESSION NegLogonSession = NULL ;
    PSession pSession ;
    TimeStamp MinExpiry = { 0xFFFFFFFF, 0x7FFFFFFF };
#else
    TimeStamp   MinExpiry = 0x7FFFFFFFFFFFFFFF ;
#endif // WIN32_CHICAGO
    PLUID ClientLogonId;
    ULONG_PTR ClientPackage = -1;
    ULONG_PTR ClientDefaultPackage = -1;
    BOOL ExplicitCreds = FALSE ;
    BOOL DomainExplicitCreds = FALSE ;
    LUID LocalSystem = SYSTEM_LUID ;
    BOOLEAN EnableLoopback = TRUE;


    DebugLog(( DEB_TRACE_NEG, "NegAcquireCredentialsHandle: Get a Negotiate CredHandle:\n"));

    //
    // Determine caller info
    //

    scRet = LsapGetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(scRet))
    {
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    CallInfo = LsapGetCurrentCall();

    pSession = GetCurrentSession();

#endif

    //
    // Get the callers Logon ID so we can determine what package to try first
    //

    if (ARGUMENT_PRESENT(pLogonID) && ((pLogonID->LowPart != 0) || (pLogonID->HighPart != 0)))
    {
        ClientLogonId = pLogonID;
    }
    else
    {
        ClientLogonId = &ClientInfo.LogonId;
    }

#ifndef WIN32_CHICAGO
    //
    // Now find out what package logged this user on
    //

    NegLogonSession = NegpLocateLogonSession( ClientLogonId );

    if ( NegLogonSession == NULL )
    {
        LogonSession = LsapLocateLogonSession( ClientLogonId );
        if (LogonSession != NULL)
        {
            PLSAP_SECURITY_PACKAGE LsaPackage ;

            ClientPackage = LogonSession->CreatingPackage;
            LsapReleaseLogonSession( LogonSession );

            //
            // If this was done by an old style package, that is,
            // an NT4 style auth pkg, *or* some one calling MSV in
            // the old fashioned way, reset the value to the negotiate
            // ID to allow full negotiation range.
            //

            LsaPackage = SpmpLocatePackage( ClientPackage );

            if ( LsaPackage )
            {
                if ( ( LsaPackage->fPackage & SPM_AUTH_PKG_FLAG ) != 0 )
                {
                    ClientPackage = NegPackageId ;
                }
            }

        }
    }
    else
    {
        ClientPackage = NegLogonSession->DefaultPackage ;

        NegpDerefLogonSession( NegLogonSession );

        NegLogonSession = NULL ;
    }


#endif // WIN32_CHICAGO

    ClientDefaultPackage = ClientPackage;


    NegReadLockList();

    //
    // If authentication data was passed in, capture it now to see
    // if it includes a subset of the packages to use.
    //

    if (ARGUMENT_PRESENT(pvAuthData))
    {
        ClientPackage = (ULONG_PTR) -1 ;

        scRet = NegpCaptureSuppliedCreds(
                    pvAuthData,
                    &AuthPackageList,
                    &AuthPackageCount,
                    &ExplicitCreds,
                    &DomainExplicitCreds
                    );
        if (!NT_SUCCESS(scRet))
        {
            NegUnlockList();
            goto Cleanup;
        }
    }


    //
    // turn off loopback detection when:
    // 1. explicit credentials were supplied.
    // 2. Product is domain controller, and client is local system account
    //    (this will cause system->system to auth using machine account.)
    //

    if( ExplicitCreds )
    {
        EnableLoopback = FALSE;
    }

    if (!RtlEqualLuid( ClientLogonId, &LocalSystem ))
    {
        if( ClientPackage == NegPackageId )
        {
            ExplicitCreds = TRUE ;
        }
    } else {
#ifndef WIN32_CHICAGO
        if( NegProductType == NtProductLanManNt )
        {
            EnableLoopback = FALSE;
        }
#endif // !WIN32_CHICAGO
    }

    //
    // Build the list of packages that we'll call to get credentials
    //

    if (AuthPackageCount == 0)
    {
        scRet = NegpBuildPackageList(
                    ClientPackage,
                    fCredentials,
                    &AuthPackageList,
                    &AuthPackageCount
                    );

        if (!NT_SUCCESS(scRet))
        {
            NegUnlockList();
            goto Cleanup;
        }
    }

    if ( AuthPackageCount < NEG_MECH_LIMIT )
    {
        pCreds = Creds;
        ZeroMemory( Creds, sizeof(Creds) );
    }
    else
    {
        pCreds = (PNEG_CRED_HANDLE) LsapAllocatePrivateHeap( NegPackageCount *
                                    sizeof( NEG_CRED_HANDLE ) );
        if ( !pCreds )
        {
            NegUnlockList();

            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }

    }


    i = 0;

    for (Index = 0; Index < AuthPackageCount ; Index++ )
    {
        BOOLEAN SkipAcquire = FALSE;

        PackageId = GetCurrentPackageId();


#ifdef WIN32_CHICAGO
        ANSI_STRING AnsiString1 = { 0 }, AnsiString2 = { 0 };

        scRet = RtlUnicodeStringToAnsiString( &AnsiString1,
                                              &AuthPackageList[Index]->LsaPackage->Name,
                                              TRUE);

        if ( NT_SUCCESS( scRet ) )
        {
            scRet = RtlUnicodeStringToAnsiString( &AnsiString2,
                                                  psPrincipal,
                                                  TRUE);
        }

        if ( NT_SUCCESS( scRet ) )
        {
            scRet = AcquireCredentialsHandle(  AnsiString2.Buffer,
                                            AnsiString1.Buffer,
                                            fCredentials,
                                            pLogonID,
                                            pvAuthData,
                                            (SEC_GET_KEY_FN) pvGetKeyFn,
                                            pvGetKeyArgument,
                                            &pCreds[i].Handle,
                                            &Expiry );
        }

#else
        ULONG_PTR ThisPackageId = (ULONG_PTR)AuthPackageList[Index]->LsaPackage->dwPackageID;
        DWORD j;

        //
        // mask off the DEFAULT flag, since only we understand it
        //

        //
        // skip calling the package if there are multiple aliases (oids)
        // that point to the same underlying package.
        // note: NegpReleaseCreds() duplicate handle values are ignored
        // during credential release.
        //

        for( j = 0 ; j < i ; j ++ )
        {
            if( pCreds[j].Handle.dwLower == ThisPackageId )
            {
                CopyMemory( &pCreds[i].Handle, &pCreds[j].Handle, sizeof(pCreds[i].Handle) );

                SkipAcquire = TRUE;
                break;
            }
        }

        if( !SkipAcquire )
        {
            scRet = WLsaAcquireCredHandle(  psPrincipal,
                                            &AuthPackageList[Index]->LsaPackage->Name,
                                            fCredentials & ( SECPKG_CRED_BOTH),
                                            pLogonID,
                                            pvAuthData,
                                            pvGetKeyFn,
                                            pvGetKeyArgument,
                                            &pCreds[i].Handle,
                                            &Expiry );

            pCreds[i].Flags = 0;

        } else {

            //
            // no need to AddCredHandle(), as, that would put us out of sync with
            // the underlying package ref count.
            //

            pCreds[i].Flags = NEG_CREDHANDLE_EXTRA_OID;

            scRet = SEC_E_OK;
        }

#endif // WIN32_CHICAGO


        SetCurrentPackageId( PackageId );

        if ( NT_SUCCESS( scRet ) )
        {
            if( !SkipAcquire )
            {
                DebugLog((DEB_TRACE_NEG, "   Added %p:%p, %ws\n",
                        pCreds[i].Handle.dwUpper, pCreds[i].Handle.dwLower,
                        AuthPackageList[Index]->LsaPackage->Name.Buffer ));
            } else {
                DebugLog((DEB_TRACE_NEG, " Skipped %p:%p, %ws (duplicate)\n",
                            pCreds[i].Handle.dwUpper, pCreds[i].Handle.dwLower,
                            AuthPackageList[Index]->LsaPackage->Name.Buffer ));
            }

#ifdef WIN32_CHICAGO
            if ( Expiry < MinExpiry )
            {
                MinExpiry = Expiry ;
            }
#else
            if ( Expiry.QuadPart < MinExpiry.QuadPart )
            {
                MinExpiry.QuadPart = Expiry.QuadPart ;
            }
#endif

            pCreds[i].Package = AuthPackageList[Index];

            i++;

        }
        else
        {
            DebugLog((DEB_TRACE_NEG, "Failed %x to get a cred handle for %ws\n",
                        scRet, AuthPackageList[Index]->LsaPackage->Name.Buffer ));
        }

    }

    NegUnlockList();

    if ( i == 0 )
    {
        //
        // Did not get any subordinate credentials, return an error now
        //
        scRet = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Now, allocate our cred structure, and copy all the found cred handles
    // into it.
    //

    pNegCreds = (PNEG_CREDS) LsapAllocateLsaHeap( sizeof( NEG_CREDS ) +
                                        sizeof( NEG_CRED_HANDLE ) * ( i - ANYSIZE_ARRAY ) );

    if ( pNegCreds == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    FreeCreds = TRUE ;

    pNegCreds->Count = i;
    pNegCreds->Flags = 0 ;
    pNegCreds->Tag = NEGCRED_TAG ;
    pNegCreds->DefaultPackage = ClientDefaultPackage;

    if ( fCredentials & NEGOTIATE_ALLOW_NTLM )
    {
        pNegCreds->Flags |= NEGCRED_ALLOW_NTLM ;
    }

    if ( fCredentials & NEGOTIATE_NEG_NTLM )
    {
        pNegCreds->Flags |= NEGCRED_NEG_NTLM ;
    }

#ifndef WIN32_CHICAGO


    //
    // WARNING:  Change to w2k behavior.  Enabling loopback detection
    // to switch to NTLM
    //

    if ( EnableLoopback )
    {
        pNegCreds->Flags |= NEGCRED_NTLM_LOOPBACK ;
    }

    pNegCreds->ClientLogonId = *ClientLogonId ;


#endif

    InitializeListHead( &pNegCreds->AdditionalCreds );

    pNegCreds->ClientProcessId = ClientInfo.ProcessID;

    pNegCreds->Expiry = MinExpiry ;

    RtlCopyMemory(
        pNegCreds->Creds,
        pCreds,
        i * sizeof( NEG_CRED_HANDLE ) );

#ifndef WIN32_CHICAGO
    if ( ( CallInfo->CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) != 0 )
    {
        pNegCreds->Flags |= NEGCRED_KERNEL_CALLER ;
    }
#endif

    if ( ExplicitCreds )
    {
        pNegCreds->Flags |= NEGCRED_EXPLICIT_CREDS ;

        if( DomainExplicitCreds )
        {
            pNegCreds->Flags |= NEGCRED_DOMAIN_EXPLICIT_CREDS ;
        }
    }

    //
    // If this isn't a duplicate, return
    // a new credential
    //

    if (!NegpCheckForDuplicateCreds(
            &pNegCreds
            ))
    {

        //
        // Finish creating the credential
        //

        scRet = RtlInitializeCriticalSection( &pNegCreds->CredLock );

        if ( !NT_SUCCESS( scRet ) )
        {
            goto Cleanup ;
        }

        pNegCreds->RefCount = 1;

        if ( ( fCredentials & NEG_CRED_DONT_LINK ) == 0 )
        {
            NegWriteLockCredList();

            InsertTailList( &NegCredList,
                            &pNegCreds->List );

            NegUnlockCredList();
        }
    }

    *pdwHandle = (ULONG_PTR) pNegCreds ;

    *ptsExpiry = pNegCreds->Expiry;

    scRet = SEC_E_OK;

    FreeCreds = FALSE ;


Cleanup:

    if (!NT_SUCCESS(scRet))
    {
        //
        // Free all the handles. Because the WLsa calls set the package
        // ID make sure we always reset it.
        //

        PackageId = GetCurrentPackageId();

        while ( i-- )
        {
#ifndef WIN32_CHICAGO
            if( (pCreds[i].Flags & NEG_CREDHANDLE_EXTRA_OID) == 0 )
            {
                WLsaFreeCredHandle( &pCreds[i].Handle );
            }
#else
            FreeCredentialsHandle( &pCreds[i].Handle );
#endif // WIN32_CHICAGO

            SetCurrentPackageId( PackageId );
        }

    }
    if ( FreeCreds )
    {
        if ( pNegCreds )
        {
            LsapFreeLsaHeap( pNegCreds );
        }
    }
    if ( (pCreds != NULL ) &&
         (pCreds != Creds ) )
    {
        LsapFreePrivateHeap( pCreds );
    }
    if (AuthPackageList != NULL)
    {
        LsapFreeLsaHeap(AuthPackageList);
    }

    DsysAssert( NegLogonSession == NULL );

    DebugLog(( DEB_TRACE_NEG, "NegAcquireCredentialsHandle: returned 0x%x\n", scRet));
    return(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   NegAcquireCredentialsHandle
//
//  Synopsis:   Acquire a Negotiate credential handle
//
//  Arguments:  [psPrincipal]      --
//              [fCredentials]     --
//              [pLogonID]         --
//              [pvAuthData]       --
//              [pvGetKeyFn]       --
//              [pvGetKeyArgument] --
//              [pdwHandle]        --
//              [ptsExpiry]        --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegAcquireCredentialsHandle(
            PSECURITY_STRING    psPrincipal,
            ULONG               fCredentials,
            PLUID               pLogonID,
            PVOID               pvAuthData,
            PVOID               pvGetKeyFn,
            PVOID               pvGetKeyArgument,
            PULONG_PTR          pdwHandle,
            PTimeStamp          ptsExpiry)
{


    return  NegpAcquireCredHandle(
                psPrincipal,
                fCredentials,
                pLogonID,
                pvAuthData,
                pvGetKeyFn,
                pvGetKeyArgument,
                pdwHandle,
                ptsExpiry );



}


//+---------------------------------------------------------------------------
//
//  Function:   SpQueryCredentialsAttributes
//
//  Synopsis:   Implements QueryCredentialsAttributes by passing off to the
//              first package that we got a cred handle from.
//
//  Arguments:  [dwCredHandle] --
//              [dwAttribute]  --
//              [Buffer]       --
//
//  History:    9-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegQueryCredentialsAttributes(
    LSA_SEC_HANDLE dwCredHandle,
    ULONG   dwAttribute,
    PVOID   Buffer)
{
    PNEG_CREDS  Creds;
    SECURITY_STATUS Status;
    ULONG_PTR PackageId ;
    CredHandle TempCredHandle;

    Creds = (PNEG_CREDS) dwCredHandle ;

    NegReadLockCreds( Creds );
    TempCredHandle = Creds->Creds[0].Handle;
    NegUnlockCreds( Creds );

    PackageId = GetCurrentPackageId();

#ifndef WIN32_CHICAGO
    Status = WLsaQueryCredAttributes(
                &TempCredHandle,
                dwAttribute,
                Buffer );
#else // WIN32_CHICAGO
    Status = QueryCredentialsAttributes(
                &TempCredHandle,
                dwAttribute,
                Buffer );
#endif // WIN32_CHICAGO

    SetCurrentPackageId( PackageId );

    return( Status );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpReleaseCreds
//
//  Synopsis:   Releases credential storage when ref count goes to zero
//
//  Arguments:  [pCreds] --
//
//  History:    8-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpReleaseCreds(
    PNEG_CREDS  pCreds,
    BOOLEAN     CleanupCall
    )
{
    BOOL NoLock = FALSE ;

    //
    // Remove it from the list:
    //


    if ( pCreds->List.Flink )
    {
        RemoveEntryList( &pCreds->List );
        DebugLog(( DEB_TRACE_NEG, "Releasing credentials %p\n", pCreds ));
    }
    else
    {
        NoLock = TRUE ;
        DebugLog(( DEB_TRACE_NEG, "Releasing credentials %p (dups or lockless)\n", pCreds ));
    }

#ifndef WIN32_CHICAGO
    if ( pCreds->Flags & NEGCRED_MULTI )
    {
        while ( !IsListEmpty( &pCreds->AdditionalCreds ) )
        {
            PLIST_ENTRY Scan ;
            PNEG_CREDS AltCreds ;

            Scan = RemoveHeadList( &pCreds->AdditionalCreds );

            AltCreds = CONTAINING_RECORD( Scan, NEG_CREDS, List );

            NegFreeCredentialsHandle((ULONG_PTR) AltCreds);
        }

    }
#endif // WIN32_CHICAGO


    if ( !NoLock )
    {
        NegUnlockCreds( pCreds );

        RtlDeleteCriticalSection( &pCreds->CredLock );
    }


    //
    // free the embedded package creds.
    //

    if( !CleanupCall )
    {
        ULONG_PTR PackageId;
        DWORD   i;

        //
        // Free all associated handles:
        //

        i = pCreds->Count;

        PackageId = GetCurrentPackageId();

        while ( i-- )
        {
            if (((pCreds->Creds[i].Flags & NEG_CREDHANDLE_EXTRA_OID) == 0) &&
                 (pCreds->Creds[i].Handle.dwLower != 0) &&
                 (pCreds->Creds[i].Handle.dwLower != SPMGR_PKG_ID ) )
            {
#ifndef WIN32_CHICAGO

                NTSTATUS scRet;

                scRet = WLsaFreeCredHandle( &pCreds->Creds[i].Handle );

                if( !NT_SUCCESS(scRet) )
                {
                    DebugLog(( DEB_ERROR, "Failed freeing credential %p:%p %x\n",
                                    pCreds->Creds[i].Handle.dwUpper,
                                    pCreds->Creds[i].Handle.dwLower,
                                    scRet ));

                    //DsysAssert( NT_SUCCESS(scRet) );
                }

#else // WIN32_CHICAGO

                FreeCredentialsHandle( &pCreds->Creds[i].Handle );

#endif // WIN32_CHICAGO
            }

            SetCurrentPackageId( PackageId );
        }

    }


    LsapFreeLsaHeap( pCreds );

}

//+---------------------------------------------------------------------------
//
//  Function:   NegFreeCredentialsHandle
//
//  Synopsis:   Release a negotiate cred handle
//
//  Arguments:  [dwHandle] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
NegFreeCredentialsHandle(
    LSA_SEC_HANDLE dwHandle
    )
{
    PNEG_CREDS  pCreds;
    ULONG DereferenceCount = 1;
    BOOLEAN CleanupCall = FALSE;

#ifndef WIN32_CHICAGO
    SECPKG_CALL_INFO CallInfo;

    if(LsapGetCallInfo(&CallInfo))
    {
        //
        // nego internally calls NegFreeCredentialsHandle, so, insure
        // the refcount is always non-zero.
        // realistically speaking, the callcount is only > 1 on cleanup
        // disposition, but there is no reason to potentially destabilize
        // this already tenuous issue.
        //

        if( CallInfo.CallCount )
        {
            DereferenceCount = CallInfo.CallCount;
        }

        CleanupCall = ( (CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0 );
    }
#endif

    pCreds = (PNEG_CREDS) dwHandle ;

    NegWriteLockCreds( pCreds );

    ASSERT( pCreds->RefCount >= DereferenceCount );

    pCreds->RefCount -= DereferenceCount;

    if ( pCreds->RefCount == 0 )
    {
        NegUnlockCreds( pCreds );

        NegWriteLockCredList();
        NegWriteLockCreds( pCreds );

        if( pCreds->RefCount == 0 )
        {
            NegpReleaseCreds( pCreds, CleanupCall );
        } else {
            NegUnlockCreds( pCreds );
        }

        NegUnlockCredList();

    }
    else
    {
        NegUnlockCreds( pCreds );
    }

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpCreateContext
//
//  Synopsis:   Creates and zeroes a context
//
//  Arguments:  (none)
//
//  History:    10-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_CONTEXT
NegpCreateContext(
    VOID
    )
{
    PNEG_CONTEXT    Context ;

    Context = (PNEG_CONTEXT) LsapAllocatePrivateHeap( sizeof( NEG_CONTEXT ) );

    if ( Context )
    {
        ZeroMemory( Context, sizeof( NEG_CONTEXT ) );

        Context->CheckMark = NEGCONTEXT_CHECK ;

        Context->Flags |= NEG_CONTEXT_UPLEVEL ;
    }

    return( Context );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpDeleteContext
//
//  Synopsis:   Free the data behind a context
//
//  Arguments:  [Context] --
//
//  History:    10-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpDeleteContext(
    PNEG_CONTEXT    Context
    )
{
    ULONG_PTR PackageId;

    if ( !Context )
    {
        return ;
    }

    DsysAssert( Context->CheckMark == NEGCONTEXT_CHECK );

    if (Context->CheckMark != NEGCONTEXT_CHECK )
    {
        return;
    }

    if ( Context->Target.Buffer )
    {
        LsapFreePrivateHeap( Context->Target.Buffer );
    }

    if ( Context->Check && Context->Buffer )
    {
        Context->Check->Finish( & Context->Buffer );
    }

    if ( Context->MappedBuffer.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(
            Context->MappedBuffer.pvBuffer
            );
    }

    if ( Context->Message )
    {
        LsapFreeLsaHeap( Context->Message );
    }

    if ( ( Context->Handle.dwLower != 0 ) &&
         ( Context->Handle.dwLower != SPMGR_PKG_ID ) )
    {
        PackageId = GetCurrentPackageId();

#ifdef WIN32_CHICAGO
        DeleteSecurityContext( &Context->Handle );
#else
        WLsaDeleteContext( &Context->Handle );
#endif
        SetCurrentPackageId(PackageId);
    }

    //
    // If we referenced the credential, free it now.
    //

    if (Context->Creds != NULL)
    {
        NegFreeCredentialsHandle((ULONG_PTR) Context->Creds);
    }
    if (Context->SupportedMechs != NULL)
    {
        if ((Context->Flags & NEG_CONTEXT_FREE_EACH_MECH))
        {
            NegpFreeMechList(Context->SupportedMechs);
        }
        else
        {
            LsapFreeLsaHeap(Context->SupportedMechs);
        }
    }

    DebugLog(( DEB_TRACE_NEG, "Deleting context %x\n", Context ));

    LsapFreePrivateHeap( Context );

}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackageForOid
//
//  Synopsis:   Returns index for a package matching the OID passed in
//
//  Arguments:  [Creds] --
//              [Oid]   --
//
//  History:    9-25-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG_PTR
NegpFindPackageForOid(
    PNEG_CREDS  Creds,
    ObjectID    Oid)
{
    ULONG i;

    NegDumpOid( "Compare Mechanism", Oid );

    for ( i = 0 ; i < Creds->Count ; i++ )
    {
        if ( NegpCompareOid( Oid,
                             Creds->Creds[i].Package->ObjectId ) == 0 )
        {
            return( i );
        }

    }

    return( NEG_INVALID_PACKAGE );
}








//+---------------------------------------------------------------------------
//
//  Function:   NegBuildRequestToken
//
//  Synopsis:   Generates a NegotiateRequest token, for either client or server
//              side inits.  Generates a NEG_CONTEXT and the token to be sent
//              to the other side.
//
//  Effects:    Lots of work
//
//  Arguments:  [ServerSideInit] --
//              [Creds]          --
//              [pszTargetName]  --
//              [fContextReq]    --
//              [TargetDataRep]  --
//              [ServerMechs]    --
//              [pContext]       --
//              [pOutput]        --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegBuildRequestToken(
    IN BOOL                ServerSideInit,
    IN PNEG_CREDS          Creds,
    IN PSECURITY_STRING    pszTargetName,
    IN ULONG               fContextReq,
    IN ULONG               TargetDataRep,
    IN struct MechTypeList *ServerMechs,
    IN PSECURITY_STRING    NegotiateHint,
    OUT PNEG_CONTEXT *     pContext,
    OUT PSecBufferDesc     pOutput,
    PTimeStamp             ptsExpiry)
{
    InitialNegToken    Request ;
    SECURITY_STATUS     scRet ;
    SECURITY_STATUS     scRetPrior = STATUS_SUCCESS;
    struct MechTypeList CommonMechs[ NEG_MECH_LIMIT ];
    struct MechTypeList *MechList = CommonMechs;
    ULONG               MatchingPackages[ NEG_MECH_LIMIT ];
    struct MechTypeList *pMechs ;
    struct MechTypeList *SourceMechs  = NULL;
    PVOID               SourceMechsToFree = NULL ;
    ULONG               MechCount ;
    ULONG               i ;
    ULONG_PTR           CredIndex ;
    PNEG_CONTEXT        Context = NULL ;
    PSession            pSession ;
    SecPkgCredentials_NamesW Names ;
    DWORD               NameLength ;
    ANSI_STRING         NarrowName  = {0};
    PSession            pClientClone ;
    ULONG_PTR           PackageId ;
    PNEG_PACKAGE        Package ;
    SecBuffer           DesiredToken = { 0 } ;
    SecBuffer           InputBuffer ;
    SecBufferDesc       DTDescription ;
    SecBufferDesc       DTInput ;
    SecBufferDesc       NullInput = { 0 };
    PSecBuffer          pToken ;
    CtxtHandle          InitialHandle ;
    ASN1octetstring_t   EncodedData = {0};
    int                 Result ;
    ULONG               PackageReq = 0 ;
    BOOL                DirectSecurityPacket = FALSE ;
    BOOL                UseHint = FALSE ;
    BOOL                HintPresent = FALSE ;
    ULONG               PackageReqFlags ;
    BOOL                BufferSizeReset = FALSE ;
    BOOL                OrderByMech = FALSE ;
    BOOL                MechListReordered = FALSE ;
    CredHandle          TempCredHandle;
    PNEG_PACKAGE        LastPackage = NULL ;
#ifndef WIN32_CHICAGO
    PLSA_CALL_INFO      CallInfo ;
#endif


    //
    // Make sure there is an output buffer
    //

    scRet = NegpParseBuffers( pOutput, TRUE, &pToken, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "Failed to map buffers, %x\n", scRet ));

        goto Cleanup ;
    }

    //
    // If there is no output buffer, fail now
    //

    if (pToken == NULL)
    {
        DebugLog((DEB_TRACE_NEG,"No output token for NegBuildRequestToken\n"));
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


#ifndef WIN32_CHICAGO
    CallInfo = LsapGetCurrentCall();


    if ( !ServerSideInit )
    {

        if ( CallInfo->CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE )
        {
            //
            // Mask off the mutual bit for now
            //

            PackageReq = NegGetPackageCaps( fContextReq & (~(ISC_REQ_MUTUAL_AUTH)) );
        }
        else
        {
            PackageReq = NegGetPackageCaps( fContextReq );
        }
    }
    else
    {
        PackageReq = 0xFFFFFFFF ;
    }

#else

    PackageReq = NegGetPackageCaps( fContextReq );

#endif

    //
    // First, gather up the mechanisms that the other guys supports.  If
    // we don't know, assume all of ours:
    //

    if ( ServerMechs )
    {
        SourceMechs = ServerMechs ;
    }
    else
    {
        scRet = NegpBuildMechListFromCreds(
                        Creds,
                        PackageReq,
                        (ServerSideInit ? SECPKG_CRED_INBOUND : SECPKG_CRED_OUTBOUND ),
                        &SourceMechs );

        if ( !NT_SUCCESS(scRet) )
        {
            return( scRet );
        }
        //
        // Save a copy of this pointer.  The list may be rearranged later, but
        // we need to free this "original" pointer.
        //

        SourceMechsToFree = SourceMechs ;
    }


    //
    // Initialize some pointers so we know if we need to free anything.
    //

    DesiredToken.pvBuffer = NULL ;
    Context = NULL ;

    //
    // if we're honoring server hints, then go by the mech list
    //

    OrderByMech = ( ( NegOptions & NEGOPT_HONOR_SERVER_PREF ) != 0 );

#ifndef WIN32_CHICAGO
    //
    // Special case the local loopback to use NTLM.  Analyze the target name.  If it
    // is an SPN, and it is our hostname in there, rearrange the mech list to put
    // NTLM first (note, for local case, NTLM will essentially dup the token).  This
    // function cannot fail.
    //

    if ( ((Creds->Flags & NEGCRED_NTLM_LOOPBACK) != 0)
#if 0
         && ((Creds->Flags & NEGCRED_EXPLICIT_CREDS) == 0)
#endif
         )
    {
        if ( NegpRearrangeMechsIfNeccessary( &SourceMechs, pszTargetName, &DirectSecurityPacket ) )
        {
            OrderByMech = TRUE ;
            MechListReordered = TRUE ;
        }
    }

#endif


    //
    // Scan through the list, building up the list of common mechanisms.
    // Also, maintain a count, and determine the first matching package to
    // generate our desired token.  Depending on local configuration, we
    // will either honor the server's preferences, or our own.
    //

    pMechs = SourceMechs ;

    MechCount = 0;

    NegReadLockCreds( Creds );

    //
    // BUGUG: check for supported options for the context requirements.
    //

    if ( OrderByMech )
    {
        //
        // Walk the server list first.
        //

        while ( pMechs )
        {
            CredIndex = NegpFindPackageForOid( Creds, pMechs->value );

            if ( CredIndex != NEG_INVALID_PACKAGE )
            {
                CommonMechs[ MechCount ].value =
                                Creds->Creds[ CredIndex ].Package->ObjectId ;

                CommonMechs[ MechCount ].next = &CommonMechs[ MechCount + 1 ];

                MatchingPackages[ MechCount] = (ULONG) CredIndex;
                MechCount ++ ;

                if (MechCount == NEG_MECH_LIMIT)
                {
                    break;
                }
            }

            pMechs = pMechs->next ;
        }
    }
    else
    {
        //
        // Walk the local cred list first:
        //

        for ( i = 0 ; i < Creds->Count ; i++ )
        {
            pMechs = SourceMechs ;

            while ( pMechs )
            {
                if ( NegpCompareOid( pMechs->value,
                                    Creds->Creds[ i ].Package->ObjectId ) == 0 )
                {
                    CommonMechs[ MechCount ].value =
                                     Creds->Creds[ i ].Package->ObjectId ;

                    CommonMechs[ MechCount ].next = &CommonMechs[ MechCount + 1 ];

                    MatchingPackages[ MechCount] = i;

                    MechCount++;

                    break;
                }


                //
                // Note:  Right now, the limit on protocols is 16.  We may need to
                // increase that.
                //

                if (MechCount == NEG_MECH_LIMIT)
                {
                    break;
                }


                pMechs = pMechs->next ;
            }
        }
    }

    //
    // Ok, at this point, we have the desired security package (cred handle)
    // in MatchingPackage, MechCount contains the number of mechs in common.
    //
    // Note:  These can be zero, that is that we have no mechs in common.
    //

    NegUnlockCreds( Creds );

    if ( MechCount == 0 )
    {
        //
        // No common packages:
        //

        DebugLog(( DEB_TRACE_NEG, "No common packages\n"));

        scRet = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    //
    // Patch up list:
    //

    CommonMechs[ MechCount - 1 ].next = NULL ;



    //
    // Start assembling request token:
    //

    ZeroMemory( &Request, sizeof( Request ) );


    //
    // Create the negotiate context
    //

    Context = NegpCreateContext() ;

    if ( !Context )
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY ;

        goto Cleanup ;

    }

    if ( !ServerSideInit )
    {

        //
        // Store target name away
        //

        scRet = LsapDuplicateString2( &Context->Target, pszTargetName );

        if ( !NT_SUCCESS( scRet ) )
        {
            goto Cleanup ;
        }

        //
        // Use the supplied mechs. If these were passed from the server,
        // make sure we don't free them before using them.
        //


        if ( Context->SupportedMechs )
        {
            DebugLog((DEB_TRACE_NEG, "Context %p already has MechList ?\n", Context ));
        }

        if ( ( SourceMechs == ServerMechs ) ||
             ( MechListReordered ) )
        {
            Context->SupportedMechs = NegpCopyMechList(MechList);
            if (Context->SupportedMechs == NULL)
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            Context->Flags |= NEG_CONTEXT_FREE_EACH_MECH;
        }
        else
        {

            Context->SupportedMechs = SourceMechs;
            SourceMechs = NULL;
        }

        if ( fContextReq & ISC_REQ_MUTUAL_AUTH )
        {
            Context->Flags |= NEG_CONTEXT_MUTUAL_AUTH ;
        }
    }



    if (Context->Creds == NULL)
    {
        Context->Creds = Creds ;

        //
        // Reference the credentials so they don't go away unexpectedly
        //

        NegWriteLockCreds(Creds);

        Creds->RefCount++;

        NegUnlockCreds(Creds);
    }

    PackageReqFlags = fContextReq | ISC_REQ_MUTUAL_AUTH ;
    PackageReqFlags &= (~(ISC_REQ_ALLOCATE_MEMORY ));

    i = 0;
    do
    {
        UseHint = FALSE ;
        HintPresent = FALSE  ;

        Context->CredIndex = MatchingPackages[i] ;

        NegReadLockCreds( Creds );

        Package = Creds->Creds[ MatchingPackages[i] ].Package ;

#ifndef WIN32_CHICAGO
        if ( NegNegotiationControl < NEG_NEGLEVEL_NO_DOWNGRADE )
        {
            //
            // If we're allowing downgrade, if the next package is
            // the NT4 compatibility package, and we are not
            // responding to a server list of mechs, and we haven't
            // reordered the list specifically to use NTLM for loopback,
            // go direct
            //

            if ( ( (Package->Flags & NEG_NT4_COMPAT ) != 0 ) &&
                 ( ServerMechs == NULL )  &&
                 ( (Creds->Flags & NEGCRED_NEG_NTLM ) == 0 ) &&
                 ( !MechListReordered ) )
            {
                DebugLog(( DEB_TRACE_NEG, "Dropping back to pure NTLM\n" ));
                DirectSecurityPacket = TRUE ;
            }
        }
#endif // WIN32_CHICAGO

        //
        // Now, divergent behavior.  For a server side request token, we need to
        // grab some hint data.  On a client side request, we ping the desired
        // mechanism to generate a "hopeful" blob for the server.
        //

        if ( ServerSideInit )
        {
            NTSTATUS TempStatus;

            if ( Creds->ServerBufferLength == 0 )
            {


                DebugLog(( DEB_TRACE_NEG, "Gathering up server name for hint\n" ));

                //
                // We need to query credential handle 0 to find out
                // what the name of the person is, so that we can send it
                // back in the hints.  However, just calling querycredattributes
                // would make the package write the data to the client process,
                // when we need it here.  So, we swap out our session, and substitute
                // a clone of the client session, with the INPROC flag set.  The
                // helpers will check for this flag, and do a little dance to
                // keep the memory local.
                //

#ifndef WIN32_CHICAGO
                pSession = GetCurrentSession();

                TempStatus = CloneSession( pSession, &pClientClone, SESFLAG_INPROC );

                //
                // WARNING:  This code block has the braces only in NT builds, not
                // in Win9x builds.  Balance them carefully if you modify this portion.
                //

                if ( NT_SUCCESS( TempStatus ) )
                {
                    SpmpReferenceSession( pClientClone );

                    SetCurrentSession( pClientClone );

                    PackageId = GetCurrentPackageId();
#endif // WIN32_CHICAGO

                    //
                    // Make a copy of the handle because we can't hold a lock
                    // while calling outside the Negotiate package.
                    //

                    TempCredHandle = Creds->Creds[0].Handle;

                    NegUnlockCreds(Creds);

#ifndef WIN32_CHICAGO
                    TempStatus = WLsaQueryCredAttributes(
                                    &TempCredHandle,
                                    SECPKG_CRED_ATTR_NAMES,
                                    &Names );
#else
                    TempStatus = QueryCredentialsAttributes(
                                    &TempCredHandle,
                                    SECPKG_CRED_ATTR_NAMES,
                                    &Names );
#endif // WIN32_CHICAGO

                    SetCurrentPackageId( PackageId );
                    NegReadLockCreds( Creds);

                    if ( NT_SUCCESS( TempStatus ) )
                    {
                        UNICODE_STRING TempString;

                        RtlInitUnicodeString(
                            &TempString,
                            Names.sUserName
                            );

                        TempStatus = RtlUnicodeStringToAnsiString(
                                        &NarrowName,
                                        &TempString,
                                        TRUE            // allocate destination
                                        );
                        if (NT_SUCCESS(TempStatus))
                        {

                            Request.negToken.u.negTokenInit.bit_mask |= NegTokenInit_negHints_present ;

                            Request.negToken.u.negTokenInit.negHints.hintName = NarrowName.Buffer ;

                            Request.negToken.u.negTokenInit.negHints.bit_mask |= hintName_present;

                        }

                        LsapFreeLsaHeap( Names.sUserName );
                    }

                    //
                    // Ignore failures from above because it was really only a hint.
                    //

                    scRet = STATUS_SUCCESS;

#ifndef WIN32_CHICAGO
                    SetCurrentSession( pSession );

                    //
                    // Deref and clean up clone session
                    //

                    SpmpDereferenceSession( pClientClone );

                }
#endif // WIN32_CHICAGO


            }

            NegUnlockCreds( Creds );


        }
        else
        {
            CredHandle TempCredHandle;


            //
            // Make a copy of the handle because we can't hold a lock
            // while calling outside the Negotiate package.
            //

            TempCredHandle = Creds->Creds[0].Handle;

            NegUnlockCreds(Creds);


            //
            // Client side call.  Here, we call down to the desired package,
            // and have it generate a blob to be encoded and sent over to the
            // server.
            //

            if ( DesiredToken.pvBuffer )
            {
                //
                // If we're coming through this loop again, free the current buffer
                // and allocate one of appropriate size for the current package.
                //

                LsapFreeLsaHeap( DesiredToken.pvBuffer );
            }

            DesiredToken.pvBuffer = LsapAllocateLsaHeap( Package->TokenSize );
            if (DesiredToken.pvBuffer == NULL)
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            DesiredToken.cbBuffer = Package->TokenSize ;
            DesiredToken.BufferType = SECBUFFER_TOKEN ;

            DTDescription.ulVersion = SECBUFFER_VERSION ;
            DTDescription.cBuffers = 1;
            DTDescription.pBuffers = &DesiredToken ;

            DTInput.ulVersion = SECBUFFER_VERSION;

            //
            // If negotiation information was provided, use it
            //

            if (ARGUMENT_PRESENT(NegotiateHint) &&
                (NegotiateHint->Length != 0)
#ifndef WIN32_CHICAGO
                 && ( NegNegotiationControl < NEG_NEGLEVEL_COMPATIBILITY )
#endif
                )
            {
                DTInput.cBuffers = 1;
                DTInput.pBuffers = &InputBuffer;
                InputBuffer.pvBuffer = NegotiateHint->Buffer;
                InputBuffer.cbBuffer = NegotiateHint->Length;
                InputBuffer.BufferType = SECBUFFER_NEGOTIATION_INFO;
                HintPresent = TRUE ;
            }
            else
            {
                DTInput.cBuffers = 0;
                DTInput.pBuffers = 0;
                HintPresent = FALSE ;

            }

            InitialHandle.dwUpper = 0;
            InitialHandle.dwLower = 0;

            DebugLog(( DEB_TRACE_NEG, "Getting initial token from preferred package '%ws'\n",
                        Package->LsaPackage->Name.Buffer ));

            PackageId = GetCurrentPackageId();


RetryWithHintPoint:
            //
            // This goto label is used for retry with hint in low security setting, and
            // retry with a larger buffer in the case where kerberos exceeds its max token
            // value.
            //

            //
            //  Move this into a local.  The WLsaInit code will blot out the cred handle
            // for the secur32.dll if the context changes.
            //

            TempCredHandle = Creds->Creds[ MatchingPackages[i] ].Handle ;
            LastPackage = Creds->Creds[ MatchingPackages[ i ] ].Package ;

            if( NT_SUCCESS( scRetPrior ) ||
                (TempCredHandle.dwLower != Creds->Creds[ MatchingPackages[i-1] ].Handle.dwLower)
                )
            {

#ifndef WIN32_CHICAGO
                scRet = WLsaInitContext(&TempCredHandle,
                                        &InitialHandle,
                                        pszTargetName,
                                        PackageReqFlags,
                                        0,
                                        TargetDataRep,
                                        (UseHint ? &DTInput : &NullInput ),
                                        0,
                                        &Context->Handle,
                                        &DTDescription,
                                        &Context->Attributes,
                                        ptsExpiry,
                                        &Context->Mapped,
                                        &Context->MappedBuffer
                                        );

#else
                ANSI_STRING TempAnsiString;
                NTSTATUS TempStatus = RtlUnicodeStringToAnsiString(
                                        &TempAnsiString,
                                        pszTargetName,
                                        TRUE            // allocate destination
                                        );
                scRet = InitializeSecurityContext(
                                        &TempCredHandle,
                                        &InitialHandle,
                                        TempAnsiString.Buffer,
                                        PackageReqFlags,
                                        0,
                                        TargetDataRep,
                                        (UseHint ? &DTInput : &NullInput),
                                        0,
                                        &Context->Handle,
                                        &DTDescription,
                                        &Context->Attributes,
                                        ptsExpiry
                                        );
#endif

                scRetPrior = scRet;
            }

            SetCurrentPackageId( PackageId );

            DebugLog(( DEB_TRACE_NEG, "WLsaInitContext( %ws, %ws ) returned %x\n",
                            pszTargetName->Buffer,
                            Creds->Creds[ MatchingPackages[i] ].Package->LsaPackage->Name.Buffer,
                            scRet ));

            Context->CallCount++ ;


            if ( !NT_SUCCESS( scRet ) )
            {
                DebugLog(( DEB_TRACE_NEG, "Failed %x getting token from preferred package '%ws'\n",
                            scRet, Package->LsaPackage->Name.Buffer ));

                if ( ( scRet == STATUS_BUFFER_TOO_SMALL ) &&
                     ( BufferSizeReset == FALSE ) )
                {
                    LsapFreeLsaHeap( DesiredToken.pvBuffer );

                    //
                    // This is technically not multi thread safe, but this is a comparatively
                    // rare event.    The buffer size will never be set less than the original
                    // claimed size from the package, so at worst, we'll get stuck in this realloc
                    // loop twice.
                    //

                    if ( DesiredToken.cbBuffer > Package->TokenSize )
                    {
                        Package->TokenSize = DesiredToken.cbBuffer ;
                    }

                    DesiredToken.pvBuffer = LsapAllocateLsaHeap( DesiredToken.cbBuffer );

                    if ( DesiredToken.pvBuffer == NULL )
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                    else
                    {
                        BufferSizeReset = TRUE ;

                        scRetPrior = STATUS_SUCCESS;
                        goto RetryWithHintPoint ;
                    }


                }
#ifndef WIN32_CHICAGO
                if ( (HintPresent)  &&
                     (!(UseHint)) &&
                     ( ( scRet == SEC_E_TARGET_UNKNOWN ) ||
                       ( scRet == STATUS_NO_TRUST_SAM_ACCOUNT ) ||
                       ( scRet == STATUS_NO_LOGON_SERVERS ) ) &&
                     (NegNegotiationControl < NEG_NEGLEVEL_COMPATIBILITY ) )
                {
                    DebugLog(( DEB_TRACE_NEG, "Retrying with hint name %ws\n",
                              NegotiateHint->Buffer ));
                    UseHint = TRUE ;

                    scRetPrior = STATUS_SUCCESS;
                    goto RetryWithHintPoint ;
                }
#endif
                if ( DesiredToken.pvBuffer )
                {
                    LsapFreeLsaHeap( DesiredToken.pvBuffer );

                    DesiredToken.pvBuffer = NULL ;
                }

            }
            else
            {
                //
                // On success, check for a null session indication.  If we got a "null
                // session" from the security package, then we need to make sure that it
                // is not uplevel, if NTLM is enabled on the machine.
                //

                if ( ( Context->Attributes & ISC_RET_NULL_SESSION ) != 0 )
                {
                    if ( NtlmPackageId != NEG_INVALID_PACKAGE )
                    {
                        //
                        // NTLM is enabled.  If this is not NTLM, blow away the context
                        // until we get to NTLM.  First, override the returned status with
                        // a "special" status code that will get us through the retry logic
                        // below.  Then, delete the existing context.
                        //

                        if ( (Creds->Creds[ MatchingPackages[ i ] ].Package->Flags & NEG_NT4_COMPAT) == 0 )
                        {
                            scRet = SEC_E_BAD_PKGID ;

#ifdef WIN32_CHICAGO
                            DeleteSecurityContext( &Context->Handle );
#else
                            WLsaDeleteContext( &Context->Handle );
#endif
                            Context->Attributes = 0 ;
                        }

                    }
                }



            }

            Context->LastStatus = scRet ;
            Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;

        }

        //
        // If the packages failed, take it out of the list
        //

        if (!NT_SUCCESS(scRet))
        {
            MechList = CommonMechs[i].next;
            MechCount--;

            //
            // kerberos can authoritatively return STATUS_WRONG_PASSWORD
            // if the creds were not valid.  No reason to continue at that point.
            //

            if((scRet == STATUS_WRONG_PASSWORD || scRet == STATUS_LOGON_FAILURE) &&
               ((Creds->Flags & NEGCRED_DOMAIN_EXPLICIT_CREDS) != 0))
            {
                DebugLog(( DEB_TRACE_NEG, "Status code %x from Initialize causing us to break out\n",
                            scRet ));
                goto Cleanup;
            }


            if (( NegNegotiationControl > NEG_NEGLEVEL_NO_SECURITY ) &&
                ( ( Creds->Flags & NEGCRED_EXPLICIT_CREDS ) == 0 ) &&
                ( ( Creds->Flags & NEGCRED_ALLOW_NTLM ) == 0 ) )
            {
                BOOL BreakOut ;
                BOOL Downgrade = TRUE;

                //
                // Ok, we need to do some advance filtering on the
                // return status, to see if we should progress or not.
                //

                switch ( scRet )
                {
                    //
                    // Special case for null session going to NTLM:
                    //

                    case SEC_E_BAD_PKGID:
                        BreakOut = FALSE ;
                        break;

                    case SEC_E_TARGET_UNKNOWN:
                    case STATUS_NO_TRUST_SAM_ACCOUNT:
                    case STATUS_KDC_UNKNOWN_ETYPE:
                    case STATUS_NETWORK_UNREACHABLE:
                    case SEC_E_NO_CREDENTIALS:          // eg, Kerberos has no creds for local account case

                        BreakOut = FALSE ;
                        break;
                    case STATUS_WRONG_PASSWORD:
                    case STATUS_LOGON_FAILURE:
                    case STATUS_NO_SUCH_USER:
                    case STATUS_TIME_DIFFERENCE_AT_DC:
                    case SEC_E_TIME_SKEW:
                    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
                    case STATUS_SMARTCARD_WRONG_PIN:
                    case STATUS_SMARTCARD_NO_CARD:
                    case STATUS_PASSWORD_MUST_CHANGE:
                    case STATUS_PASSWORD_EXPIRED:
                    {
                        BreakOut = TRUE;
                        Downgrade = FALSE;
                        break;
                    }

                    case STATUS_NO_LOGON_SERVERS:
                    {
                        //
                        // If we truly logged on with NTLM, keep going
                        //
                        if (Creds->DefaultPackage == NtlmPackageId)
                        {
                            BreakOut = FALSE;
                        } else {
                            BreakOut = TRUE;
                        }
                        break;
                    }

                    default:
                        BreakOut = TRUE ;
                        break;
                }

                DebugLog(( DEB_TRACE_NEG, "Status code %x causing us to %s\n",
                           scRet, (BreakOut ? "break out" : "continue") ));

                if ( BreakOut )
                {
                    if( Downgrade )
                    {
#ifndef WIN32_CHICAGO
                        NegpReportEvent(
                            EVENTLOG_WARNING_TYPE,
                            NEGOTIATE_DOWNGRADE_DETECTED,
                            CATEGORY_NEGOTIATE,
                            scRet,
                            2,
                            pszTargetName,
                            &LastPackage->LsaPackage->Name
                            );
#endif
                        //
                        // Tell the caller the explicit reason for the failure since
                        //  NTLM might very well have suceeded.
                        //
                        scRet = STATUS_DOWNGRADE_DETECTED;
                    }

                    break;
                }

            }
        }

        i++;

    } while (!NT_SUCCESS(scRet) && (MechCount != 0));

    if (!NT_SUCCESS(scRet))
    {
#ifndef WIN32_CHICAGO
        NegpReportEvent(
            EVENTLOG_WARNING_TYPE,
            NEGOTIATE_INVALID_SERVER,
            CATEGORY_NEGOTIATE,
            scRet,
            1,
            pszTargetName
            );
#endif
        DebugLog((DEB_ERROR,"No packages could initialize\n"));
        goto Cleanup;
    }

    if ( MechCount == 0 )
    {
#ifndef WIN32_CHICAGO
        NegpReportEvent(
            EVENTLOG_WARNING_TYPE,
            NEGOTIATE_INVALID_SERVER,
            CATEGORY_NEGOTIATE,
            0,
            1,
            pszTargetName
            );
#endif
        scRet = SEC_E_INVALID_TOKEN ;

        //
        // No common packages:
        //

        DebugLog(( DEB_TRACE_NEG, "No common packages\n"));

        goto Cleanup ;
    }

#ifndef WIN32_CHICAGO
    if ( LastPackage )
    {
        NegpReportEvent(
            EVENTLOG_INFORMATION_TYPE,
            NEGOTIATE_PACKAGE_SELECTED,
            CATEGORY_NEGOTIATE,
            0,
            2,
            pszTargetName,
            &LastPackage->LsaPackage->Name
            );
    }
#endif

    if ( !DirectSecurityPacket )
    {
        Request.negToken.choice = negTokenInit_chosen ;

        Request.negToken.u.negTokenInit.mechTypes = MechList ;
        Request.negToken.u.negTokenInit.bit_mask |= NegTokenInit_mechTypes_present ;

        //
        // Okay, now we have all the pieces.  Assemble the token:
        //

        if ( DesiredToken.pvBuffer )
        {
            Request.negToken.u.negTokenInit.mechToken.length = DesiredToken.cbBuffer ;
            Request.negToken.u.negTokenInit.mechToken.value = (PUCHAR) DesiredToken.pvBuffer ;

            Request.negToken.u.negTokenInit.bit_mask |= NegTokenInit_mechToken_present ;

        }

        //
        // Add in the SPNEGO mechanism id
        //

        Request.spnegoMech = NegSpnegoMechOid;


        Result = SpnegoPackData(
                    &Request,
                    InitialNegToken_PDU,
                    &(EncodedData.length),
                    &(EncodedData.value));


        if ( Result )
        {
            DebugLog((DEB_ERROR, "Failed to encode data: %d\n", Result ));

            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;

        }
    }
    else
    {
        EncodedData.length = DesiredToken.cbBuffer ;
        EncodedData.value = (PUCHAR) DesiredToken.pvBuffer ;

        DesiredToken.pvBuffer = NULL ;
    }


    //
    // Okay, got the token into a contiguous mass.  Package it up for the caller
    //


    if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
    {
        //
        // Easy:  The caller asked for us to allocate memory for them, so
        // let the LSA do it.
        //

        pToken->pvBuffer = EncodedData.value ;
        pToken->cbBuffer = EncodedData.length ;
        EncodedData.value = NULL;

    }
    else
    {
        //
        // The caller has a buffer that we're supposed to use.  Make sure we
        // can fit.
        //

        if ( (ULONG) EncodedData.length < pToken->cbBuffer  )
        {
            RtlCopyMemory(  pToken->pvBuffer,
                            EncodedData.value,
                            EncodedData.length );

            pToken->cbBuffer = EncodedData.length ;

        }
        else if ( ( ( fContextReq & ISC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                  ( pToken->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
        {
            //
            // Ok, we need to whack the context to indicate that we are
            // fragmenting, and return only what the caller can handle.
            //

            Context->Message = EncodedData.value ;
            Context->TotalSize = EncodedData.length ;
            Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

            //
            // set this to NULL so it doesn't get freed later
            //

            EncodedData.value = NULL ;
            RtlCopyMemory(
                pToken->pvBuffer,
                Context->Message,
                pToken->cbBuffer );

            Context->CurrentSize = pToken->cbBuffer ;
        }
        else
        {
            DebugLog(( DEB_TRACE_NEG, "Supplied buffer is too small\n" ));

            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;
        }
    }


    //
    // We have created the token, encoded it, and stuck it in a return buffer.
    // We have created the context record, and it is ready.  We're done!
    //


    if ( !DirectSecurityPacket )
    {
        *pContext = Context ;
        Context = NULL;

        scRet =  SEC_I_CONTINUE_NEEDED ;
    }
#ifndef WIN32_CHICAGO
    else
    {
        DebugLog(( DEB_TRACE_NEG, "Replacing handle, current status is %x\n", scRet ));

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        *pContext = NULL ;

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        //
        // Context will be freed during cleanup.
        //
    }

#endif



Cleanup:

    if ( !ServerMechs )
    {
        //
        // No server mechs means we allocated and used one based on our
        // cred handle.  Free it.
        //

        if (SourceMechs != NULL)
        {
            if ( MechListReordered )
            {
                LsapFreeLsaHeap( SourceMechsToFree );
            }
            else
            {
                LsapFreeLsaHeap( SourceMechs );
            }
        }
    }

    if (EncodedData.value != NULL)
    {
        LsapFreeLsaHeap(EncodedData.value);
    }

    if ( DesiredToken.pvBuffer )
    {
        LsapFreeLsaHeap( DesiredToken.pvBuffer );
    }

    if ( Context )
    {
        NegpDeleteContext( Context );
    }

    if (NarrowName.Buffer != NULL)
    {
        RtlFreeAnsiString(&NarrowName);
    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegGenerateInitialToken
//
//  Synopsis:   Client side init
//
//  Arguments:  [dwCreds]       --
//              [Target]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegGenerateInitialToken(
    ULONG_PTR dwCreds,
    PSECURITY_STRING Target,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    PSecBuffer  Buffer;
    PNEG_CREDS  Creds;
    PNEG_CONTEXT Context;

    //
    // Initialize stuff:
    //

    Creds = (PNEG_CREDS) dwCreds ;

    //
    // Fall through to common code with normal initial token:
    //

    scRet = NegBuildRequestToken(   FALSE,
                                    Creds,
                                    Target,
                                    fContextReq,
                                    TargetDataRep,
                                    NULL,
                                    NULL,
                                    &Context,
                                    pOutput,
                                    ptsExpiry );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        // Successfully built token.  Set flags:
        //

        *pfContextAttr = ( ISC_RET_INTERMEDIATE_RETURN ) |
                         ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ?
                                ISC_RET_ALLOCATED_MEMORY : 0 ) ;

        *pfMapContext = FALSE ;

        if ( Context )
        {
            *pdwNewContext = (DWORD_PTR) Context ;
        }

    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegGenerateServerRequest
//
//  Synopsis:   Server side init
//
//  Arguments:  [dwCreds]       --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegGenerateServerRequest(
    ULONG_PTR dwCreds,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    PSecBuffer  Buffer;
    PNEG_CREDS  Creds;
    PNEG_CONTEXT Context;

    //
    // Initialize stuff:
    //

    Creds = (PNEG_CREDS) dwCreds ;

    //
    // Fall through to common code with normal initial token:
    //

    scRet = NegBuildRequestToken(   TRUE,
                                    Creds,
                                    NULL,
                                    fContextReq,
                                    TargetDataRep,
                                    NULL,
                                    NULL,
                                    &Context,
                                    pOutput,
                                    ptsExpiry );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        // Successfully built token.  Set flags:
        //

        *pfContextAttr = ( fContextReq & ASC_REQ_ALLOCATE_MEMORY ?
                                ASC_RET_ALLOCATED_MEMORY : 0 ) ;

        *pfMapContext = FALSE ;

        *pdwNewContext = (DWORD_PTR) Context ;
    }

    return( scRet );
}



//+---------------------------------------------------------------------------
//
//  Function:   NegCrackServerRequestAndReply
//
//  Synopsis:   Client side Init with Neg token from the server
//
//  Arguments:  [dwCreds]       --
//              [Target]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegCrackServerRequestAndReply(
    ULONG_PTR dwCreds,
    PSECURITY_STRING Target,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    struct InitialNegToken * Request = NULL ;
    ASN1octetstring_t EncodedData;
    int Result;
    ULONG Pdu = InitialNegToken_PDU;
    PSecBuffer  Buffer;
    struct MechTypeList *pMechs = NULL;
    PNEG_CREDS Creds ;
    PNEG_CONTEXT Context = NULL ;
    UNICODE_STRING NegotiateHint = {0};
    ANSI_STRING AnsiHint = {0};

    RtlInitUnicodeString(
        &NegotiateHint,
        NULL
        );


    //
    // Initialize stuff:
    //

    //
    // First, verify the input buffer contains a Request token, and crack it.
    //

    scRet = NegpParseBuffers( pInput, TRUE, &Buffer, NULL );

    if ( !Buffer )
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        goto Cleanup;
    }

    Creds = (PNEG_CREDS) dwCreds ;

    EncodedData.value = (PUCHAR) Buffer->pvBuffer ;
    EncodedData.length = Buffer->cbBuffer ;
    Request = NULL ;

    Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&Request);

    if ( Result != 0 )
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // This function only handles Request tokens.  If we ended up with a reply,
    // then the server is in trouble, or we are...
    //

    if ( (Pdu != InitialNegToken_PDU) ||
         (Request->negToken.choice == negTokenTarg_chosen) ||
          NegpCompareOid(
            Request->spnegoMech,
            NegSpnegoMechOid)
            )
    {
        scRet =  SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


    //
    // Okay, the server has sent us a list of the packages that he supports,
    // possibly some hints as well.  We need to go through the list, and figure
    // our common subset.  At the same time, we need to select the one that we
    // want to use, preferably the same as the first one from the server.
    //

    if ((Request->negToken.u.negTokenInit.bit_mask & NegTokenInit_mechTypes_present) != 0)
    {
        pMechs = Request->negToken.u.negTokenInit.mechTypes ;
    }


    //
    // Get the negotation hint out.
    //

    if ((Request->negToken.u.negTokenInit.bit_mask & NegTokenInit_negHints_present) != 0)
    {
        if ((Request->negToken.u.negTokenInit.negHints.bit_mask & hintName_present) != 0)
        {
            RtlInitString(
                &AnsiHint,
                Request->negToken.u.negTokenInit.negHints.hintName
                );
            scRet = RtlAnsiStringToUnicodeString(
                        &NegotiateHint,
                        &AnsiHint,
                        TRUE                // allocate destination
                        );
            if (!NT_SUCCESS(scRet))
            {
                scRet= SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
        }
    }

    //
    // Fall through to common code with normal initial token:
    //


    scRet = NegBuildRequestToken(
                FALSE,                      // not server side
                Creds,
                Target,
                fContextReq,
                TargetDataRep,
                pMechs,
                &NegotiateHint,
                &Context,
                pOutput,
                ptsExpiry );





Cleanup:

    if ( Request )
    {
        SpnegoFreeData( Pdu, Request );
    }
    if (NegotiateHint.Buffer != NULL)
    {
        RtlFreeUnicodeString(&NegotiateHint);
    }

    if ( NT_SUCCESS( scRet ) )
    {
        //
        // Successfully built token.  Set flags:
        //

        *pfContextAttr = ( ISC_RET_INTERMEDIATE_RETURN ) |
                         ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ?
                                ISC_RET_ALLOCATED_MEMORY : 0 ) ;

        *pfMapContext = FALSE ;

        *pdwNewContext = (DWORD_PTR) Context ;
    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpCrackRequest
//
//  Synopsis:   Crack a Request package, and, based on the creds, determine
//              what is supported.
//
//  Arguments:  [Creds]          -- Creds to compare against
//              [Request]        -- Request to crack
//              [MechIndex]      -- selected package
//              [MechList]       -- Receives mech list from request
//              [pPackage]       -- Package pointer
//
//  History:    9-25-96   RichardW   Created
//
//  Notes:      Creds must be locked
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegpCrackRequest(
    IN PNEG_CREDS  Creds,
    IN NegotiationToken * Request,
    OUT PULONG_PTR MechIndex,
    OUT struct MechTypeList ** MechList,
    OUT PNEG_PACKAGE * pPackage,
    OUT NEG_MATCH * pDesiredMatch)
{
    DWORD i;
    DWORD j;
    ULONG MatchingPackage = (ULONG) -1;
    struct MechTypeList *pMechs;
    PNEG_PACKAGE Package;
    NEG_MATCH DesiredMatch;
    ULONG MechCount ;

    pMechs = Request->u.negTokenInit.mechTypes ;

    //
    // First, support the "standard" by going through the whole list,
    // and determining which ones we support.
    //


    Package = NULL ;

    DesiredMatch = MatchUnknown ;


    //
    // For each mechanism, see if we have it in the creds.  If we have it,
    // mark it as acceptible.  If this is the first acceptible mech, capture
    // it as the now preferred mechanism.
    //


    while ( pMechs )
    {
        NegDumpOid( "Incoming Mechanism", pMechs->value );

        for ( i = 0 ; i < Creds->Count ; i++ )
        {
            NegDumpOid( "Comparing to Mechanism", Creds->Creds[i].Package->ObjectId );

            if ( NegpCompareOid( pMechs->value,
                                 Creds->Creds[i].Package->ObjectId ) == 0 )
            {
                if ( !Package )
                {
                    Package = Creds->Creds[i].Package ;

                    if ( DesiredMatch == MatchUnknown )
                    {
                        DesiredMatch = PreferredSucceed ;
                    }
                    else
                    {
                        DesiredMatch = MatchSucceed ;
                    }

                    MatchingPackage = i;
                    break;

                }
            }

        }


        pMechs = pMechs->next ;

        if ( DesiredMatch == MatchUnknown )
        {
            DesiredMatch = MatchFailed ;
        }

    }


    *MechIndex = MatchingPackage ;

    *pPackage = Package ;

    *MechList = Request->u.negTokenInit.mechTypes ;

    *pDesiredMatch = DesiredMatch ;


    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegHandleSubsequentClientRequest
//
//  Synopsis:   Handles a client request after the initial NegTokenInit
//
//  Arguments:
//
//  History:    5-26-97         MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
NegHandleSubsequentClientRequest(
    ULONG_PTR dwCreds,
    PNEG_CONTEXT Context,
    ULONG fContextReq,
    ULONG TargetDataRep,
    ULONG Pdu,
    NegotiationToken * Request,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc pOutput,
    PULONG  pfContextAttr,
    PTimeStamp ptsExpiry,
    PBYTE pfMapContext,
    PSecBuffer  pContextData )
{
    SECURITY_STATUS scRet = SEC_E_OK;
#ifndef WIN32_CHICAGO
    PNEG_CREDS  Creds ;
    NegotiationToken Reply;
    CredHandle TempCredHandle;
    CtxtHandle TempHandle;
    SecBufferDesc AcceptBufferDesc;
    SecBuffer AcceptBuffer;
    SecBufferDesc ResponseBufferDesc;
    SecBuffer ResponseBuffer;
    SecBuffer MappedBuffer;
    PSecBuffer pToken;
    BOOLEAN MappedContext;
    ULONG_PTR PackageId;
    ASN1octetstring_t EncodedData;
    int Result;
    PNEG_PACKAGE Package ;


    EncodedData.value = NULL;
    EncodedData.length = 0;

    RtlZeroMemory(
        &ResponseBuffer,
        sizeof(SecBuffer)
        );

    RtlZeroMemory(
        &MappedBuffer,
        sizeof(SecBuffer)
        );

    //
    // The negotiation context should have been created during the first call
    // to AcceptSecurityContext, so if it isn't present this is an
    // error.
    //


    if (Context == NULL)
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }



    //
    // Verify that there is an output token to return something in.
    //

    scRet = NegpParseBuffers( pOutput, TRUE, &pToken, NULL );

    if ( !NT_SUCCESS( scRet ) || (pToken == NULL) )
    {
        DebugLog((DEB_TRACE_NEG, "No output token supplied to NegHandleSubs.ClientReq\n"));
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Verify the creds passed in
    //

    Creds = (PNEG_CREDS) dwCreds ;

    if (Creds == NULL)
    {
        Creds = Context->Creds;
    }
    else if (Creds != Context->Creds)
    {
        //
        // Could be a multi:
        //

        if ( ( Creds->Flags & NEGCRED_MULTI ) == 0 )
        {
            DebugLog((DEB_TRACE_NEG, "Bad context handle passed to Accept: 0x%p instead of 0x%p\n",
                Creds, Context->Creds ));
            scRet = SEC_E_INVALID_HANDLE;
            goto Cleanup;

        }

        //
        // Walk the multi credential and verify the cred ptr?
        //

        Creds = Context->Creds ;
    }

    //
    // if the security token area is empty, but the mechListMIC is
    // present, then the client has completed (and we should have,
    // also), and we should verify the mechListMIC.
    //

    if ( ( ( Request->u.negTokenTarg.responseToken.length == 0 ) &&
           ( ( Context->Flags & NEG_CONTEXT_UPLEVEL ) != 0 ) ) ||
         ( Request->u.negTokenTarg.bit_mask == 0 ) )
    {
        //
        // Check the MIC:
        //

        SpnegoFreeData( Pdu, Request );
        Request = NULL;

        if ( Context->LastStatus != STATUS_SUCCESS )
        {
            return SEC_E_INVALID_TOKEN ;
        }

        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;
            RtlZeroMemory(
                &Context->MappedBuffer,
                sizeof(SecBuffer)
                );
        }

        //
        // Whack the output handle with the one returned from the
        // package.
        //

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        pToken->cbBuffer = 0 ;

        *ptsExpiry = Context->Expiry ;

        Context = NULL ;

        return STATUS_SUCCESS ;

    }

    //
    // Get the locked information out of the credentials
    //

    NegReadLockCreds(Creds);

    TempCredHandle = Creds->Creds[ Context->CredIndex ].Handle;
    Package = Creds->Creds[Context->CredIndex].Package;

    NegUnlockCreds(Creds);


    //
    // Build the input to AcceptSecurityContext
    //

    if ( Request->u.negTokenTarg.responseToken.length != 0 )
    {
        AcceptBuffer.pvBuffer = Request->u.negTokenTarg.responseToken.value;
        AcceptBuffer.cbBuffer = Request->u.negTokenTarg.responseToken.length;
        Context->Flags |= NEG_CONTEXT_UPLEVEL ;
    }
    else if ( Request->u.negTokenTarg.mechListMIC.length != 0 )
    {
        AcceptBuffer.pvBuffer = Request->u.negTokenTarg.mechListMIC.value ;
        AcceptBuffer.cbBuffer = Request->u.negTokenTarg.mechListMIC.length ;
    }

    AcceptBuffer.BufferType = SECBUFFER_READONLY | SECBUFFER_TOKEN ;

    AcceptBufferDesc.ulVersion = SECBUFFER_VERSION ;
    AcceptBufferDesc.cBuffers = 1;
    AcceptBufferDesc.pBuffers = &AcceptBuffer ;

    ResponseBuffer.cbBuffer = Package->LsaPackage->TokenSize ;
    ResponseBuffer.BufferType = SECBUFFER_TOKEN ;

    ResponseBuffer.pvBuffer = LsapAllocateLsaHeap(
                                    ResponseBuffer.cbBuffer );

    if ( ResponseBuffer.pvBuffer == NULL )
    {

        scRet = SEC_E_INSUFFICIENT_MEMORY ;

        goto Cleanup ;
    }

    ResponseBufferDesc.ulVersion = SECBUFFER_VERSION ;
    ResponseBufferDesc.cBuffers = 1;
    ResponseBufferDesc.pBuffers = &ResponseBuffer ;

    if ((Context->Flags & NEG_CONTEXT_PACKAGE_CALLED) != 0)
    {
        TempHandle = Context->Handle ;
    }
    else
    {
        TempHandle.dwUpper = TempHandle.dwLower = 0;
    }


    PackageId = GetCurrentPackageId();

    //
    // Call the package. Note that if the package has already mapped the
    // context we don't want it overwriting the existing mapping. Hence,
    // don't pass in the real value.
    //

#ifndef WIN32_CHICAGO
    scRet = WLsaAcceptContext(
                &TempCredHandle,
                &TempHandle,
                &AcceptBufferDesc,
                (fContextReq & (~(ASC_REQ_ALLOCATE_MEMORY))),
                TargetDataRep,
                &Context->Handle,
                &ResponseBufferDesc,
                &Context->Attributes,
                &Context->Expiry,
                &MappedContext,
                &MappedBuffer );
#else
    scRet = AcceptSecurityContext(
                &TempCredHandle,
                &TempHandle,
                &AcceptBufferDesc,
                (fContextReq & (~(ASC_REQ_ALLOCATE_MEMORY))),
                TargetDataRep,
                &Context->Handle,
                &ResponseBufferDesc,
                &Context->Attributes,
                &Context->Expiry
                );
#endif // WIN32_CHICAGO

#if DBG
    NegReadLockCreds( Creds );

    DebugLog(( DEB_TRACE_NEG, "WLsaAcceptContext( %ws ) returned %x\n",
                    Creds->Creds[ Context->CredIndex ].Package->LsaPackage->Name.Buffer,
                    scRet ));

    NegUnlockCreds(Creds);
#endif

    Context->CallCount++ ;

    SetCurrentPackageId( PackageId );

    //
    // Done with request data
    //


    SpnegoFreeData( Pdu, Request );
    Request = NULL;

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog((DEB_TRACE, "Neg Failure from package %d, %#x\n",
            Context->CredIndex, scRet ));

        DsysAssert( scRet != SEC_E_INVALID_HANDLE )

        goto Cleanup;

    }

    Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;

    Context->LastStatus = scRet ;

    //
    // Build the output token, another NegTokenTarg.
    //

    Reply.choice = negTokenTarg_chosen;
    Reply.u.negTokenTarg.bit_mask = negResult_present;
    if (ResponseBuffer.cbBuffer != 0)
    {
        Reply.u.negTokenTarg.bit_mask |= responseToken_present;
    }

    Reply.u.negTokenTarg.responseToken.value = (PUCHAR) ResponseBuffer.pvBuffer;
    Reply.u.negTokenTarg.responseToken.length = (int) ResponseBuffer.cbBuffer;

    //
    // Fill in the negotation result field. In addition, fill in any
    // context mapping data.
    //

    if ( MappedContext )
    {
        DsysAssert( !Context->Mapped );

        Context->Mapped = TRUE ;
        Context->MappedBuffer = MappedBuffer ;

        RtlZeroMemory(
            &MappedBuffer,
            sizeof(SecBuffer)
            );
    }

    //
    // generate the MIC on the last blob
    //
    if ( scRet == SEC_E_OK )
    {
        //
        // Once the mic is generated, the
        // list of mechs is no longer needed.
        //

        if ( Context->SupportedMechs )
        {
            DebugLog(( DEB_TRACE_NEG, "Freeing mech list for %p\n", Context ));

            if ((Context->Flags & NEG_CONTEXT_FREE_EACH_MECH))
            {
                NegpFreeMechList(Context->SupportedMechs);
            }
            else
            {
                LsapFreeLsaHeap(Context->SupportedMechs);
            }

            Context->SupportedMechs = NULL ;
        }
    }

    if ( Context->LastStatus == SEC_E_OK )
    {
        Reply.u.negTokenTarg.negResult = accept_completed;
    }
    else
    {
        Reply.u.negTokenTarg.negResult = accept_incomplete;
    }

    if (scRet == SEC_E_OK)
    {
        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;
            RtlZeroMemory(
                &Context->MappedBuffer,
                sizeof(SecBuffer)
                );
        }
        else if (MappedContext)
        {
            *pfMapContext = TRUE;
            *pContextData = MappedBuffer;
            RtlZeroMemory(
                &MappedBuffer,
                sizeof(SecBuffer)
                );
        }
    }


    *ptsExpiry = Context->Expiry;
    *pfContextAttr = Context->Attributes;

    //
    // Encode reply token:
    //


    Result = SpnegoPackData(
                                &Reply,
                                NegotiationToken_PDU,
                                &(EncodedData.length),
                                &(EncodedData.value));

    if (Result != 0)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    DsysAssert( NT_SUCCESS(NegpValidateBuffer( EncodedData.value, EncodedData.length ) ) );

    if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
    {
        pToken->pvBuffer = EncodedData.value ;

        *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY ;

        EncodedData.value = NULL ;

        pToken->cbBuffer = EncodedData.length ;

    }
    else
    {
        if ( pToken->cbBuffer >= (ULONG) EncodedData.length )
        {
            RtlCopyMemory(  pToken->pvBuffer,
                            EncodedData.value,
                            EncodedData.length );

            pToken->cbBuffer = EncodedData.length ;


        }
        else if ( ( ( fContextReq & ASC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                  ( pToken->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
        {
            //
            // Ok, we need to whack the context to indicate that we are
            // fragmenting, and return only what the caller can handle.
            //

            Context->Message = EncodedData.value ;
            Context->TotalSize = EncodedData.length ;
            Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

            //
            // set this to NULL so it doesn't get freed later
            //

            EncodedData.value = NULL ;
            RtlCopyMemory(
                pToken->pvBuffer,
                Context->Message,
                pToken->cbBuffer );

            Context->CurrentSize = pToken->cbBuffer ;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;
        }
    }


    if (scRet == SEC_E_OK)
    {
        //
        // Whack the output handle with the one returned from the
        // package.
        //

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        Context = NULL ;

    }
    else
    {
        //
        // Make sure we never say that we mapped when we are in the
        // intermediate state.
        //

        DsysAssert( !(*pfMapContext) );
    }

Cleanup:
    if (EncodedData.value != NULL)
    {
        LsapFreeLsaHeap(EncodedData.value);
    }
    if (ResponseBuffer.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(ResponseBuffer.pvBuffer);
    }
    if (MappedBuffer.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(MappedBuffer.pvBuffer);
    }
#endif // WIN32_CHICAGO
    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegHandleClientRequest
//
//  Synopsis:   Handles a call to AcceptSecurityContext other than an
//              initial one with no input. This routine either figures our
//              what package to call or calls a package already selected to
//              do the Accept.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
NegHandleClientRequest(
    ULONG_PTR dwCreds,
    PNEG_CONTEXT pContext,
    ULONG   fContextReq,
    ULONG   TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp  ptsExpiry,
    PBYTE   pfMapContext,
    PSecBuffer  pContextData )
{
    PNEG_CREDS          Creds ;
    PNEG_CONTEXT        Context ;
    SECURITY_STATUS     scRet ;
    SECURITY_STATUS     MapStatus ;
    NegotiationToken *  Request = NULL ;
    InitialNegToken *   InitialRequest = NULL;
    NegotiationToken    Response = {0};
    ASN1octetstring_t   EncodedData ;
    int                 Result ;
    ULONG               Pdu = InitialNegToken_PDU;
    PSecBuffer          Buffer ;
    PSecBuffer          pToken ;
    PNEG_PACKAGE        Package;
    NEG_MATCH           DesiredMatch;
    SecBufferDesc       AcceptBufferDesc;
    SecBuffer           AcceptBuffer;
    SecBufferDesc       ResponseBufferDesc;
    SecBuffer           ResponseBuffer;
    SecBuffer           UserResponseBuffer; // use user buffer for in-place operations if large enough

    struct MechTypeList *MechList = NULL;
    CtxtHandle          TempHandle;
    struct _enum1 * Results;
    ULONG_PTR           PackageId;
    BOOLEAN             CredentialReferenced = FALSE;


    //
    // Initialize stuff:
    //

    ResponseBuffer.pvBuffer = NULL;

    Creds = (PNEG_CREDS) dwCreds ;
    Context = pContext ;

    if ( ( Creds == NULL ) &&
         ( Context != NULL ) )
    {
        Creds = Context->Creds ;
    }

    //
    // First, verify the input buffer contains a Request token, and crack it.
    //

    scRet = NegpParseBuffers( pInput, TRUE, &Buffer, NULL );

    if ( !Buffer )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        return( scRet );
    }

    //
    // Verify that we have an output buffer
    //


    scRet = NegpParseBuffers( pOutput, TRUE, &pToken, NULL );

    if ( !NT_SUCCESS( scRet ) ||
         ( pToken == NULL ) )
    {
        goto Cleanup ;

    }

    //
    // We need a return token
    //

    if (pToken == NULL)
    {
        DebugLog((DEB_TRACE_NEG,"No output token for NegHandleClientRequest\n"));
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Compatibility:
    //
    // If we get a zero length blob, and the context has completed,
    // it means we're dealing with old clients
    //

    if ( ( Buffer->cbBuffer == 0 ) &&
         ( Context ) )
    {
        pToken->cbBuffer = 0 ;

        if ( Context->LastStatus != STATUS_SUCCESS )
        {
            return SEC_E_INVALID_TOKEN ;
        }

#ifndef WIN32_CHICAGO
        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;
            RtlZeroMemory(
                &Context->MappedBuffer,
                sizeof(SecBuffer)
                );
        }

        //
        // Whack the output handle with the one returned from the
        // package.
        //

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        *ptsExpiry = Context->Expiry ;

        pToken->cbBuffer = 0 ;

        Context = NULL ;

        return STATUS_SUCCESS ;
#endif

    }



    EncodedData.value = (PUCHAR) Buffer->pvBuffer ;
    EncodedData.length = Buffer->cbBuffer ;
    Request = NULL ;

    Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&InitialRequest);

    //
    // If unable, try it as a second-pass.
    //

    if ( Result != 0 )
    {
        Pdu = NegotiationToken_PDU;
        Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&Request);

        //
        // if the token didn't match either, give up now.
        //

        if (Result != 0)
        {
#ifndef WIN32_CHICAGO
            NegpReportEvent(
                EVENTLOG_WARNING_TYPE,
                NEGOTIATE_UNKNOWN_PACKET,
                CATEGORY_NEGOTIATE,
                0,
                0 );
#endif

            return(SEC_E_INVALID_TOKEN);
        }
    }
    else
    {
        Request = &InitialRequest->negToken;
    }

    //
    // This function only handles Negotiation tokens.  If we ended up with
    // anything else, something is wrong.
    //

    if ( (Pdu != NegotiationToken_PDU) &&
         (Pdu != InitialNegToken_PDU) )
    {
        scRet = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    //
    // If this is an initial request, verify the OID
    //

    if (InitialRequest != NULL)
    {
        if (NegpCompareOid(
                NegSpnegoMechOid,
                InitialRequest->spnegoMech
                ))
        {
            scRet = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
    }

    //
    // Check to see if we already called Accept once on a package. If so,
    // we want to use the existing context handle.
    //


    if ( Request->choice == negTokenTarg_chosen )
    {
        return(NegHandleSubsequentClientRequest(
                    dwCreds,
                    pContext,
                    fContextReq,
                    TargetDataRep,
                    Pdu,
                    Request,
                    pdwNewContext,
                    pOutput,
                    pfContextAttr,
                    ptsExpiry,
                    pfMapContext,
                    pContextData ) );
    }


    //
    // Ok, we have a request blob.  Figure out what they want,
    //

    NegReadLockCreds( Creds );

    scRet = NegpCrackRequest(   Creds,
                                Request,
                                & PackageId,
                                & MechList,
                                & Package,
                                & DesiredMatch );

    if ( !NT_SUCCESS( scRet ) )
    {

        NegUnlockCreds( Creds );

        goto Cleanup ;
    }



    if (DesiredMatch == MatchFailed)
    {
        //
        // There were no common packages, so return an error.
        //

        NegUnlockCreds( Creds );

#ifndef WIN32_CHICAGO
        NegpReportEvent(
            EVENTLOG_WARNING_TYPE,
            NEGOTIATE_UNKNOWN_PACKAGE,
            CATEGORY_NEGOTIATE,
            0,
            0 );
#endif

        DebugLog(( DEB_TRACE, "No common packages for negotiator\n"));

        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


    DsysAssert( Package != NULL );

    //
    // Found a common package.  Was it the first one in the request
    // list?  If so, then check for a desired token and pass it down
    // to the other package
    //

    DebugLog(( DEB_TRACE_NEG, "Common Package is %ws\n",
                Package->LsaPackage->Name.Buffer ));

    Response.choice = negTokenTarg_chosen ;
    Response.u.negTokenTarg.supportedMech = Package->ObjectId ;
    Response.u.negTokenTarg.bit_mask |= supportedMech_present | negResult_present;

    if ( !Context )
    {
        Context = NegpCreateContext();

        if ( !Context )
        {
            NegUnlockCreds( Creds );

            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;
        }
    }


    //
    // Save away the mechlist for the mic at the end
    //

    if ( Context->SupportedMechs )
    {
        if ((Context->Flags & NEG_CONTEXT_FREE_EACH_MECH))
        {
            NegpFreeMechList(Context->SupportedMechs);
        }
        else
        {
            LsapFreeLsaHeap(Context->SupportedMechs);
        }

    }

    Context->SupportedMechs = NegpCopyMechList(MechList);
    if (Context->SupportedMechs == NULL)
    {
        NegUnlockCreds(Creds);
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup ;
    }
    Context->Flags |= NEG_CONTEXT_FREE_EACH_MECH;
    DebugLog(( DEB_TRACE_NEG, "Adding mech list for %p\n", Context));



    //
    // Reference the credentials so they don't go away before we
    // finish with the context.
    //

    if (Context->Creds == NULL)
    {
        Context->Creds = Creds ;

        NegUnlockCreds(Creds);
        NegWriteLockCreds(Creds);

        Creds->RefCount++;

        NegUnlockCreds(Creds);
        NegReadLockCreds(Creds);
    }

    Context->CredIndex = PackageId ;

    if ( ( DesiredMatch == PreferredSucceed ) &&
         ( Request->u.negTokenInit.bit_mask & NegTokenInit_mechToken_present ) )
    {
        CredHandle TempCredHandle;

#ifndef WIN32_CHICAGO
        NegpReportEvent(
            EVENTLOG_INFORMATION_TYPE,
            NEGOTIATE_MESSAGE_DECODED,
            CATEGORY_NEGOTIATE,
            0,
            1,
            &Package->LsaPackage->Name
            );
#endif

        DebugLog(( DEB_TRACE_NEG, "Desired Package match with token!\n"));

        TempHandle = Context->Handle ;

        PackageId = GetCurrentPackageId();

        TempCredHandle = Creds->Creds[ Context->CredIndex ].Handle;

        //
        // Unlock the credentials while we make the call
        //

        NegUnlockCreds(Creds);



        //
        // Build up a buffer for accept
        //

        AcceptBuffer.pvBuffer = Request->u.negTokenInit.mechToken.value;
        AcceptBuffer.cbBuffer = Request->u.negTokenInit.mechToken.length;
        AcceptBuffer.BufferType = SECBUFFER_READONLY | SECBUFFER_TOKEN ;

        AcceptBufferDesc.ulVersion = SECBUFFER_VERSION ;
        AcceptBufferDesc.cBuffers = 1;
        AcceptBufferDesc.pBuffers = &AcceptBuffer ;

        ResponseBufferDesc.ulVersion = SECBUFFER_VERSION ;
        ResponseBufferDesc.cBuffers = 1;

        if( pToken->cbBuffer >= Package->LsaPackage->TokenSize )
        {
            UserResponseBuffer.cbBuffer = pToken->cbBuffer;
            UserResponseBuffer.BufferType = SECBUFFER_TOKEN ;

            UserResponseBuffer.pvBuffer = pToken->pvBuffer;

            ResponseBufferDesc.pBuffers = &UserResponseBuffer ;
        } else {
            ResponseBuffer.cbBuffer = Package->LsaPackage->TokenSize ;
            ResponseBuffer.BufferType = SECBUFFER_TOKEN ;

            ResponseBuffer.pvBuffer = LsapAllocateLsaHeap(
                                                ResponseBuffer.cbBuffer );

            if ( ResponseBuffer.pvBuffer == NULL )
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;

                goto Cleanup ;
            }

            ResponseBufferDesc.pBuffers = &ResponseBuffer ;
        }


#ifndef WIN32_CHICAGO
        scRet = WLsaAcceptContext(
                        &TempCredHandle,
                        &TempHandle,
                        &AcceptBufferDesc,
                        (fContextReq & (~(ASC_REQ_ALLOCATE_MEMORY))),
                        SECURITY_NATIVE_DREP,
                        &Context->Handle,
                        &ResponseBufferDesc,
                        &Context->Attributes,
                        &Context->Expiry,
                        &Context->Mapped,
                        &Context->MappedBuffer );
#else
        scRet = AcceptSecurityContext(
                        &TempCredHandle,
                        &TempHandle,
                        &AcceptBufferDesc,
                        (fContextReq & (~(ASC_REQ_ALLOCATE_MEMORY))),
                        SECURITY_NATIVE_DREP,
                        &Context->Handle,
                        &ResponseBufferDesc,
                        &Context->Attributes,
                        &Context->Expiry
                        );
#endif // WIN32_CHICAGO

        SetCurrentPackageId( PackageId );

        Context->CallCount++ ;

        DebugLog(( DEB_TRACE_NEG, "WLsaAcceptContext( %ws ) returned %x\n",
                    Creds->Creds[ Context->CredIndex ].Package->LsaPackage->Name.Buffer,
                    scRet ));

        if ( !NT_SUCCESS( scRet ) )
        {
            DebugLog((DEB_TRACE, "Neg Failure from package %ws, %#x\n",
                        Package->LsaPackage->Name.Buffer, scRet ));

            if( ResponseBuffer.pvBuffer )
            {
                LsapFreeLsaHeap( ResponseBuffer.pvBuffer );
            }

            goto Cleanup ;

        }

        NegReadLockCreds(Creds);


        if ( NT_SUCCESS( scRet ) &&
             (Context->Attributes & ASC_RET_EXTENDED_ERROR ) )
        {
            if ( (Creds->Flags & (NEGCRED_MULTI | NEGCRED_MULTI_PART)) != 0 )
            {
                scRet = SEC_E_LOGON_DENIED ;

                DebugLog(( DEB_TRACE, "Multi-cred failure, no return message\n" ));

                NegUnlockCreds( Creds );

                if( ResponseBuffer.pvBuffer )
                {
                    LsapFreeLsaHeap( ResponseBuffer.pvBuffer );
                }

                goto Cleanup ;

            }
        }

        //
        // Now:  push that info back out to our caller,
        //

        Context->LastStatus = scRet ;


        //
        // Mark the context to indicate that we already called
        // AcceptSecurityContext once.
        //

        Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;

        //
        // Set the response pointers up so they get folded in to the
        // response packet
        //

        Response.u.negTokenTarg.responseToken.length = ResponseBufferDesc.pBuffers[0].cbBuffer ;
        Response.u.negTokenTarg.responseToken.value = (PUCHAR) ResponseBufferDesc.pBuffers[0].pvBuffer ;

        Response.u.negTokenTarg.bit_mask |= responseToken_present ;


        *ptsExpiry = Context->Expiry;
        *pfContextAttr = Context->Attributes;

        if (scRet == STATUS_SUCCESS)
        {
            Response.u.negTokenTarg.negResult = accept_completed;

            //
            // Generate a MIC here
            //

            //
            // Get rid of the mech list now, since
            // it has been mic'd.  As it were.
            //

            if ( Context->SupportedMechs )
            {
                DebugLog(( DEB_TRACE_NEG, "Freeing mech list for %p\n", Context ));

                NegpFreeMechList( Context->SupportedMechs );

                Context->SupportedMechs = NULL ;
            }

            // scRet = SEC_I_CONTINUE_NEEDED ;
        }
        else
        {
            DsysAssert((scRet == SEC_I_CONTINUE_NEEDED) ||
                       (scRet == SEC_I_COMPLETE_NEEDED) ||
                       (scRet == SEC_I_COMPLETE_AND_CONTINUE))
            Response.u.negTokenTarg.negResult = accept_incomplete;
        }

        //
        // Fall through to rest of handling
        //

    }
    else
    {
        //
        // We have a common package, but either there is no desired token
        // present, or the common package was not the desired one.  The
        // selected package is in the structure already, so we don't have
        // to do anything here.
        //

#ifndef WIN32_CHICAGO
        NegpReportEvent(
            EVENTLOG_INFORMATION_TYPE,
            NEGOTIATE_MESSAGE_DECODED_NO_TOKEN,
            CATEGORY_NEGOTIATE,
            0,
            1,
            &Package->LsaPackage->Name
            );
#endif

        scRet = SEC_I_CONTINUE_NEEDED;

        DebugLog(( DEB_TRACE_NEG, "Common package has no token\n"));
        Response.u.negTokenTarg.negResult = accept_incomplete;
    }

    NegUnlockCreds( Creds );

    //
    // Assemble reply token:
    //

    EncodedData.value = 0 ;
    EncodedData.length = 0 ;

    Result = SpnegoPackData(
                            &Response,
                            NegotiationToken_PDU,
                            &(EncodedData.length),
                            &(EncodedData.value));


    //
    // Clean up:
    //

    if ( ResponseBuffer.pvBuffer )
    {
        LsapFreeLsaHeap( ResponseBuffer.pvBuffer );

        ResponseBuffer.pvBuffer = NULL ;
    }

    if (InitialRequest != NULL)
    {
        SpnegoFreeData( Pdu, InitialRequest );
        InitialRequest = NULL;
        Request = NULL;
    }
    else if ( Request )
    {
        SpnegoFreeData( Pdu, Request );
        Request = NULL;
    }


    if ( Result )
    {
        DebugLog((DEB_ERROR, "Failed to encode data: %d\n", Result ));

        scRet = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;


    }
    else
    {
        if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
        {
            pToken->pvBuffer = EncodedData.value ;

            *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY ;

            EncodedData.value = NULL ;
            pToken->cbBuffer = EncodedData.length ;

        }
        else
        {
            if ( pToken->cbBuffer >= (ULONG) EncodedData.length )
            {
                RtlCopyMemory(  pToken->pvBuffer,
                                EncodedData.value,
                                EncodedData.length );

                pToken->cbBuffer = EncodedData.length ;
            }
            else if ( ( ( fContextReq & ASC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                      ( pToken->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
            {
                //
                // Ok, we need to whack the context to indicate that we are
                // fragmenting, and return only what the caller can handle.
                //

                Context->Message = EncodedData.value ;
                Context->TotalSize = EncodedData.length ;
                Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

                //
                // set this to NULL so it doesn't get freed later
                //

                EncodedData.value = NULL ;
                RtlCopyMemory(
                    pToken->pvBuffer,
                    Context->Message,
                    pToken->cbBuffer );

                Context->CurrentSize = pToken->cbBuffer ;
            }
            else
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;

                goto Cleanup ;
            }
        }



        //
        // If the context has been mapped by the underlying package,
        // get out of the way:
        //

#ifndef WIN32_CHICAGO

        if ( scRet == SEC_E_OK )
        {
            if ( Context->Mapped )
            {
                *pfContextAttr = Context->Attributes ;

                if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
                {

                    *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY ;

                }
                *ptsExpiry = Context->Expiry ;
                *pfMapContext = Context->Mapped ;
                *pContextData = Context->MappedBuffer ;

                //
                // Set this to NULL so we don't later try
                // to free it.
                //

                Context->MappedBuffer.pvBuffer = NULL ;

            }

            LsapChangeHandle(   HandleReplace,
                                NULL,
                                &Context->Handle );

            Context->Handle.dwLower = 0 ;
            Context->Handle.dwUpper = 0 ;


            if ( !pContext )
            {
                //
                // If we created this context during this call, get
                // rid of it now
                //

                NegpDeleteContext( Context );
            }
            Context = NULL ;
        }
        else
#endif // WIN32_CHICAGO
        {
            *pdwNewContext = (DWORD_PTR) Context ;
        }

    }

    if ( EncodedData.value )
    {
        LsapFreeLsaHeap( EncodedData.value );
    }

    return( scRet );

Cleanup:

    if (InitialRequest != NULL)
    {
        SpnegoFreeData( Pdu, InitialRequest );
    }
    else if ( Request )
    {
        SpnegoFreeData( Pdu, Request );
    }

    if ( Context )
    {
        if ( Context->Handle.dwLower )
        {

#ifndef WIN32_CHICAGO
            WLsaDeleteContext( &Context->Handle );
#else
            DeleteSecurityContext( &Context->Handle );
#endif // WIN32_CHICAGO
            Context->Handle.dwLower = 0;
        }

        if ( pContext == NULL )
        {
            NegpDeleteContext( Context );
        }

    }

    return( scRet );

}



//+-------------------------------------------------------------------------
//
//  Function:   NegHandleServerReply
//
//  Synopsis:   Handles a subsequent call to InitializeSecurityContext
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
NegHandleServerReply(
    ULONG_PTR dwCreds,
    PNEG_CONTEXT pContext,
    PSECURITY_STRING Target,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    NegotiationToken * Reply = NULL ;
    NegotiationToken Request;
    ASN1octetstring_t EncodedData = {0};
    int Result;
    ULONG Pdu = NegotiationToken_PDU;
    PSecBuffer  Buffer;
    struct MechTypeList *pMechs;
    PNEG_CREDS Creds;
    PNEG_CONTEXT Context ;
    ULONG_PTR PackageIndex ;
    PNEG_PACKAGE Package ;
    SecBuffer       InitBuffer ;
    SecBufferDesc   InitBufferDesc ;
    ULONG_PTR PackageId ;
    PCtxtHandle pInitHandle ;
    CtxtHandle TempHandle = { 0, 0 };
    ULONG LocalContextReq = fContextReq;
    ULONG LocalContextAttr = 0 ;
    BOOLEAN ClientFinished = FALSE;
    BOOLEAN ServerFinished = FALSE;
    SecBuffer           OutputToken = {0};
    SecBufferDesc       OutputDescription ;
    PSecBuffer OutputBuffer = NULL;
    CredHandle TempCredHandle ;

    RtlZeroMemory(
        &Request,
        sizeof(NegotiationToken)
        );
    RtlZeroMemory(
        &OutputToken,
        sizeof(SecBuffer)
        );

    //
    // Find the token buffer:
    //

    scRet = NegpParseBuffers( pInput, TRUE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        return( scRet );
    }

    if ( !Buffer )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    scRet = NegpParseBuffers( pOutput, TRUE, &OutputBuffer, NULL );
    if (!NT_SUCCESS(scRet))
    {
        goto HSR_ErrorReturn;
    }

    //
    // Get the credential handle. If it wasn't passed in, use the one from
    // the context.
    //

    if (dwCreds != 0)
    {
        Creds = (PNEG_CREDS) dwCreds ;
    }
    else
    {
        Creds = pContext->Creds;
    }

    Context = pContext ;

    NegpValidContext( Context );

    //
    // Decode the reply token:
    //

    EncodedData.value = (PUCHAR) Buffer->pvBuffer ;
    EncodedData.length = Buffer->cbBuffer ;
    Reply = NULL ;

    Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&Reply);

    //
    // Reset the encoded data value so we don't free it accidentally
    //

    EncodedData.value = NULL;

    if ( Result != 0 )
    {
        DebugLog(( DEB_TRACE_NEG, "Unknown token from server: %d\n", Result ));

        scRet = SEC_E_INVALID_TOKEN ;

        goto HSR_ErrorReturn ;
    }

    if ( Reply->choice != negTokenTarg_chosen )
    {
        DebugLog(( DEB_TRACE_NEG, "Found Request token, expecting Reply token\n" ));

        scRet = SEC_E_INVALID_TOKEN ;

        goto HSR_ErrorReturn ;
    }

    if ((Reply->u.negTokenTarg.bit_mask & negResult_present) != 0)
    {
        if (Reply->u.negTokenTarg.negResult == reject)
        {
            DebugLog((DEB_TRACE_NEG,"Server rejected\n"));
            scRet = SEC_E_LOGON_DENIED;
            goto HSR_ErrorReturn;
        }
        if (Reply->u.negTokenTarg.negResult == accept_completed)
        {
            ServerFinished = TRUE;
        }
    }

    //
    // Ok, see what the server sent us.  In an ideal world, the server will send
    // us a preferred, chosen token.
    //

    InitBuffer.pvBuffer = NULL ;
    InitBuffer.cbBuffer = 0 ;
    InitBuffer.BufferType = SECBUFFER_TOKEN ;

    InitBufferDesc.ulVersion = SECBUFFER_VERSION ;
    InitBufferDesc.cBuffers = 1 ;
    InitBufferDesc.pBuffers = &InitBuffer ;

    if ( Reply->u.negTokenTarg.bit_mask & supportedMech_present )
    {
        NegReadLockCreds( Creds );

        PackageIndex = NegpFindPackageForOid( Creds,
                                            Reply->u.negTokenTarg.supportedMech );


        if ( PackageIndex == NEG_INVALID_PACKAGE )
        {
            NegUnlockCreds( Creds );

            NegDumpOid( "Invalid OID returned by server",
                        Reply->u.negTokenTarg.supportedMech );

            scRet = SEC_E_INVALID_TOKEN ;

            goto HSR_ErrorReturn ;
        }

        Package = Creds->Creds[ PackageIndex ].Package ;
        NegUnlockCreds( Creds );

        DebugLog(( DEB_TRACE_NEG, "Server supports %ws!\n",
                                Package->LsaPackage->Name.Buffer ));

        if ( Reply->u.negTokenTarg.bit_mask & responseToken_present )
        {
            //
            // Oh boy!  A Token too!
            //

            InitBuffer.pvBuffer = Reply->u.negTokenTarg.responseToken.value ;
            InitBuffer.cbBuffer = (ULONG) Reply->u.negTokenTarg.responseToken.length ;

            Context->Flags |= NEG_CONTEXT_UPLEVEL ;

        }
        else if ( Reply->u.negTokenTarg.bit_mask & NegTokenTarg_mechListMIC_present )
        {
            InitBuffer.pvBuffer = Reply->u.negTokenTarg.mechListMIC.value ;
            InitBuffer.cbBuffer = Reply->u.negTokenTarg.mechListMIC.length ;
        }

    }
    else
    {
        //
        // If we haven't settled on a package yet, we need a mechanism.
        //

        if ((Context->Flags & NEG_CONTEXT_PACKAGE_CALLED ) == 0)
        {
            //
            // No token specified, nor preferred mechanism.  Find the first
            // acceptible package in the returned list
            //

            DebugLog((DEB_TRACE_NEG, "No preferred mech from the server?\n"));

            DebugLog(( DEB_TRACE_NEG, "We must drop into GSS only mode for this to work\n"));

            DebugLog(( DEB_ERROR, "No preferred mech from server, not handled yet\n"));

            return( SEC_E_INVALID_TOKEN );
        }

        NegReadLockCreds( Creds );

        Package = Creds->Creds[ Context->CredIndex ].Package ;
        PackageIndex = Context->CredIndex;
        NegUnlockCreds( Creds );

        if ( Reply->u.negTokenTarg.bit_mask & responseToken_present )
        {
            //
            // Oh boy!  A Token too!
            //

            InitBuffer.pvBuffer = Reply->u.negTokenTarg.responseToken.value ;
            InitBuffer.cbBuffer = (ULONG) Reply->u.negTokenTarg.responseToken.length ;

            Context->Flags |= NEG_CONTEXT_UPLEVEL ;

        }
        else if ( Reply->u.negTokenTarg.bit_mask & NegTokenTarg_mechListMIC_present )
        {
            InitBuffer.pvBuffer = Reply->u.negTokenTarg.mechListMIC.value ;
            InitBuffer.cbBuffer = Reply->u.negTokenTarg.mechListMIC.length ;
        }

    }

    DebugLog(( DEB_TRACE_NEG, "Calling package %ws\n",
                        Package->LsaPackage->Name.Buffer ));

    //
    // Call into the package, possibly again, possibly the first time, and
    // let the package have at it.
    //

    if ( (Context->CredIndex != PackageIndex) &&
         ((Context->Flags & NEG_CONTEXT_PACKAGE_CALLED) != 0) )
    {
        DebugLog(( DEB_TRACE_NEG, "Switched packages, package %ws not selected anymore\n",
                    Creds->Creds[Context->CredIndex].Package->LsaPackage->Name.Buffer ));

        //
        // Got to delete the context:
        //

        PackageId = GetCurrentPackageId();

#ifndef WIN32_CHICAGO
        WLsaDeleteContext( &Context->Handle );
#else
        DeleteSecurityContext( &Context->Handle );
#endif // WIN32_CHICAGO

        SetCurrentPackageId( PackageId );
        Context->Flags &= ~NEG_CONTEXT_PACKAGE_CALLED;


        //
        // Clean up the context information in the handle
        //

        if ( Context->MappedBuffer.pvBuffer != NULL)
        {
            LsapFreeLsaHeap(
                Context->MappedBuffer.pvBuffer
                );

            Context->MappedBuffer.pvBuffer = NULL;
            Context->MappedBuffer.cbBuffer = 0;
        }
        Context->Mapped = FALSE;


        //
        // Reset the last status to make sure we call Initailize again.
        //

        Context->LastStatus = SEC_I_CONTINUE_NEEDED;

        //
        // Don't modify TempHandle which is already set to 0,0
        //

    }
    else
    {
        TempHandle = Context->Handle ;
    }

    if ( Context->LastStatus == SEC_I_CONTINUE_NEEDED )
    {
        BOOLEAN LocalContextMapped = FALSE;
        SecBuffer LocalContextData = {0,0,NULL};

        PackageId = GetCurrentPackageId();

        //
        // Client side call.  Here, we call down to the desired package,
        // and have it generate a blob to be encoded and sent over to the
        // server.
        //


#ifndef WIN32_CHICAGO
        OutputToken.pvBuffer = NULL;
        OutputToken.cbBuffer = 0;
        OutputToken.BufferType = SECBUFFER_TOKEN ;

        OutputDescription.ulVersion = SECBUFFER_VERSION ;
        OutputDescription.cBuffers = 1;
        OutputDescription.pBuffers = &OutputToken ;
        LocalContextReq |= ISC_REQ_ALLOCATE_MEMORY ;
        LocalContextAttr = 0;
#else
        OutputToken.pvBuffer = LocalAlloc(0, Creds->Creds[PackageIndex].Package->LsaPackage->TokenSize);
        OutputToken.cbBuffer = Creds->Creds[PackageIndex].Package->LsaPackage->TokenSize;
        OutputToken.BufferType = SECBUFFER_TOKEN ;

        OutputDescription.ulVersion = SECBUFFER_VERSION ;
        OutputDescription.cBuffers = 1;
        OutputDescription.pBuffers = &OutputToken ;
        LocalContextAttr = 0;
#endif

        TempCredHandle = Creds->Creds[ PackageIndex ].Handle ;

#ifndef WIN32_CHICAGO
        scRet = WLsaInitContext(&TempCredHandle,
                                &TempHandle,
                                &Context->Target,
                                LocalContextReq,
                                0,
                                TargetDataRep,
                                &InitBufferDesc,
                                0,
                                &Context->Handle,
                                &OutputDescription,
                                &LocalContextAttr,
                                ptsExpiry,
                                &LocalContextMapped,
                                &LocalContextData );
#else
        ANSI_STRING TempAnsiString;
        NTSTATUS TempStatus = RtlUnicodeStringToAnsiString(
                                &TempAnsiString,
                                &Context->Target,
                                TRUE            // allocate destination
                                );
        scRet = InitializeSecurityContext(
                                &TempCredHandle,
                                &TempHandle,
                                TempAnsiString.Buffer,
                                LocalContextReq,
                                0,
                                TargetDataRep,
                                &InitBufferDesc,
                                0,
                                &Context->Handle,
                                &OutputDescription,
                                &LocalContextAttr,
                                ptsExpiry
                                );
#endif // WIN32_CHICAGO

        DebugLog(( DEB_TRACE_NEG, "Subsequent call to WLsaInitContext( %ws ) returned %x\n",
                Creds->Creds[ PackageIndex ].Package->LsaPackage->Name.Buffer,
                scRet ));

        SetCurrentPackageId( PackageId );

        Context->CallCount++ ;
        Context->LastStatus = scRet;

        if (!NT_SUCCESS(scRet))
        {
            goto HSR_ErrorReturn;
        }

        Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;


        if (NT_SUCCESS(scRet) && LocalContextMapped)
        {
            if (Context->Mapped)
            {
                DebugLog((DEB_ERROR,"Package tried to map a context twice!\n"));
                scRet = SEC_E_INTERNAL_ERROR;
                LsapFreeLsaHeap(LocalContextData.pvBuffer);
                goto HSR_ErrorReturn;

            }
            Context->Mapped = LocalContextMapped;
            Context->MappedBuffer = LocalContextData;
            Context->Expiry = *ptsExpiry ;
        }

    }
    else
    {

        DebugLog(( DEB_TRACE_NEG, "Package did not need to be called again.\n"));


        if (OutputBuffer != NULL )
        {
            OutputBuffer->cbBuffer = 0;
        }

        scRet = STATUS_SUCCESS;
    }

    if ( Reply != NULL )
    {
        SpnegoFreeData( Pdu, Reply );

        Reply = NULL ;
    }

    //
    // Build reply buffer:
    //


    Request.choice = negTokenTarg_chosen;
    Request.u.negTokenTarg.bit_mask = 0 ;

    //
    // If there was an output buffer, package it up to ship back to the server.
    //

    if ((OutputToken.cbBuffer != 0) && (OutputToken.pvBuffer != NULL))
    {
        if (ServerFinished)
        {

#ifndef WIN32_CHICAGO
            NegpReportEvent(
                EVENTLOG_WARNING_TYPE,
                NEGOTIATE_UNBALANCED_EXCHANGE,
                CATEGORY_NEGOTIATE,
                0,
                2,
                Target,
                &Creds->Creds[PackageIndex].Package->LsaPackage->Name
                );
#endif
            DebugLog((DEB_ERROR,"Server finished but client sending back data\n"));
            scRet = SEC_E_INTERNAL_ERROR;
            goto HSR_ErrorReturn;
        }

        //
        //
        // mechSpecInfo is evil, try to take it out.
        //

        Request.u.negTokenTarg.bit_mask = responseToken_present;
        Request.u.negTokenTarg.responseToken.value = (PUCHAR) OutputToken.pvBuffer;
        Request.u.negTokenTarg.responseToken.length = (int) OutputToken.cbBuffer;


    }


    //
    // Compute the MIC of the mechList, so that the other
    // guy knows we weren't tampered on the wire
    //

    if ( scRet == STATUS_SUCCESS )
    {
        //
        // not yet
        //

        NOTHING ;
    }

    if ( ( OutputToken.cbBuffer != 0 ) )
    {
        //
        // Encode request token:
        //

        EncodedData.value = 0 ;
        EncodedData.length = 0 ;

        Result = SpnegoPackData(
                    &Request,
                    NegotiationToken_PDU,
                    &(EncodedData.length),
                    &(EncodedData.value));

        if ( Result )
        {
            DebugLog((DEB_ERROR, "Failed to encode data: %d\n", Result ));

            scRet = SEC_E_INVALID_TOKEN ;

            goto HSR_ErrorReturn ;


        }
        else
        {
            if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
            {
                OutputBuffer->pvBuffer = EncodedData.value ;
                OutputBuffer->cbBuffer = EncodedData.length ;

                *pfContextAttr = LocalContextAttr;

                EncodedData.value = NULL ;

            }
            else
            {
                if ( OutputBuffer->cbBuffer >= (ULONG) EncodedData.length )
                {
                    RtlCopyMemory(  OutputBuffer->pvBuffer,
                                    EncodedData.value,
                                    EncodedData.length );

                    *pfContextAttr = LocalContextAttr & ~ISC_RET_ALLOCATED_MEMORY;
                    OutputBuffer->cbBuffer = EncodedData.length ;
                }
                else if ( ( ( fContextReq & ISC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                          ( OutputBuffer->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
                {
                    //
                    // Ok, we need to whack the context to indicate that we are
                    // fragmenting, and return only what the caller can handle.
                    //

                    Context->Message = EncodedData.value ;
                    Context->TotalSize = EncodedData.length ;
                    Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

                    //
                    // set this to NULL so it doesn't get freed later
                    //

                    EncodedData.value = NULL ;
                    RtlCopyMemory(
                        OutputBuffer->pvBuffer,
                        Context->Message,
                        OutputBuffer->cbBuffer );

                    Context->CurrentSize = OutputBuffer->cbBuffer ;
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;

                    goto HSR_ErrorReturn ;
                }
            }


        }
    }
    else
    {
        if ( OutputBuffer )
        {
            OutputBuffer->cbBuffer = 0 ;
        }


    }

    if ( scRet == STATUS_SUCCESS )
    {
        if ( ( Context->Flags & NEG_CONTEXT_FRAGMENTING ) ||
             ( ServerFinished == FALSE ) )
        {
            scRet = SEC_I_CONTINUE_NEEDED ;
        }
        else
        {
            ClientFinished = TRUE ;
        }

    }

    //
    // On success, we push the handle back to the client.  From this point on,
    // the selected package is in charge.
    //


    if ( ClientFinished )
    {
        //
        // If the data was mapped by the package the first time make sure
        // we copy it down now.
        //

        *pfContextAttr = Context->Attributes ;

        *ptsExpiry = Context->Expiry ;

#ifndef WIN32_CHICAGO
        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;

            //
            // Set these to FALSE & NULL so we don't try to
            // free them later.
            //

            Context->MappedBuffer.pvBuffer = NULL;
        }

        LsapChangeHandle( HandleReplace,
                          NULL,
                          &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        if ( pContext == NULL )
        {
            NegpDeleteContext( Context );
        }
#endif // WIN32_CHICAGO

        // NegpDeleteContext( Context );

    }





HSR_ErrorReturn:


    if ( OutputToken.pvBuffer )
    {
        LsapFreeLsaHeap( OutputToken.pvBuffer );

        OutputToken.pvBuffer = NULL ;
    }
    if ( EncodedData.value )
    {
        LsapFreeLsaHeap( EncodedData.value );
    }


    if ( Reply )
    {
        SpnegoFreeData( Pdu, Reply );
    }

    return( scRet );

}




SECURITY_STATUS
NegAddFragmentToContext(
    PNEG_CONTEXT Context,
    PSecBuffer  Fragment
    )
{
    if ( Fragment->cbBuffer <= (Context->TotalSize - Context->CurrentSize) )
    {

        RtlCopyMemory(
            Context->Message + Context->CurrentSize,
            Fragment->pvBuffer,
            Fragment->cbBuffer );

        Context->CurrentSize += Fragment->cbBuffer ;

        if ( Context->CurrentSize == Context->TotalSize )
        {
            Context->Flags &= (~(NEG_CONTEXT_FRAGMENTING));
            return STATUS_SUCCESS ;
        }

        return SEC_I_CONTINUE_NEEDED ;

    }

    return SEC_E_INSUFFICIENT_MEMORY ;
}

SECURITY_STATUS
SEC_ENTRY
NegCreateContextFromFragment(
   LSA_SEC_HANDLE  dwCredHandle,
   LSA_SEC_HANDLE  dwCtxtHandle,
   PSecBuffer      Buffer,
   ULONG           fContextReq,
   ULONG           TargetDataRep,
   PLSA_SEC_HANDLE pdwNewContext,
   PSecBufferDesc  pOutput,
   PULONG          pfContextAttr
   )
{
    NEG_CONTEXT * Context ;
    NEG_CREDS * Creds ;
    LONG ExpectedSize ;
    LONG HeaderSize ;
    PUCHAR Message ;
    LONG MessageSize ;
    SECURITY_STATUS scRet ;
    PSecBuffer OutBuf ;
    ObjectID DecodedOid = NULL;
    NTSTATUS Status;

    Creds = (NEG_CREDS *) dwCredHandle ;

    if ( Buffer->cbBuffer > MAXLONG )
    {
        return SEC_E_INVALID_TOKEN ;
    }
    if ( Buffer->cbBuffer <= 1 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Message = (PUCHAR) Buffer->pvBuffer ;

    if ( (*Message != 0xa0 ) &&
         (*Message != 0x60 ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    MessageSize = Buffer->cbBuffer ;

    Message++ ;
    MessageSize -- ;


    ExpectedSize = Neg_der_read_length(
                    &Message,
                    &MessageSize,
                    &HeaderSize );

    if ( ExpectedSize > 0 )
    {
        //
        // Header size + 1 since we already incremented above
        //
        ExpectedSize += HeaderSize + 1;
    }

    if ( ExpectedSize < 0 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    if ( (ULONG) ExpectedSize < Buffer->cbBuffer )
    {
        return SEC_E_INVALID_TOKEN ;
    }


    //
    // Get the OID from the token, if possible, to see if it is for SPNEGO
    //

    Status = NegpGetTokenOid(
                (PUCHAR) Buffer->pvBuffer,
                Buffer->cbBuffer,
                &DecodedOid
                );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // Check for spnego
    //

    if (NegpCompareOid(
            DecodedOid,
            NegSpnegoMechOid
            ) != 0)
    {
        NegpFreeObjectId(DecodedOid);
        return(SEC_E_INVALID_TOKEN);
    }
    NegpFreeObjectId(DecodedOid);

    if ( (ULONG) ExpectedSize == Buffer->cbBuffer )
    {
        *pdwNewContext = 0 ;

        return SEC_E_OK ;
    }

    Context = NegpCreateContext();

    if ( !Context )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Context->Flags = NEG_CONTEXT_FRAGMENTING ;

    Context->Message = (PUCHAR) LsapAllocateLsaHeap( ExpectedSize ) ;

    if ( !Context->Message )
    {
        NegpDeleteContext( Context );

        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Context->CurrentSize = 0 ;
    Context->TotalSize = ExpectedSize ;


    scRet = NegAddFragmentToContext(
                Context,
                Buffer );

    if ( !NT_SUCCESS( scRet ) )
    {
        NegpDeleteContext( Context );
    }
    else
    {
        *pdwNewContext = (LSA_SEC_HANDLE) Context ;

        DsysAssert( scRet != SEC_E_OK );

        NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

        if ( OutBuf )
        {
            OutBuf->cbBuffer = 0 ;
        }

        Context->Creds = Creds ;

        //
        // Reference the credentials so they don't go away unexpectedly
        //

        NegWriteLockCreds(Creds);

        Creds->RefCount++;

        NegUnlockCreds(Creds);


    }

    return scRet ;

}

//+---------------------------------------------------------------------------
//
//  Function:   NegInitLsaModeContext
//
//  Synopsis:   Initialize a client side context
//
//  Arguments:  [dwCredHandle]  --
//              [dwCtxtHandle]  --
//              [pszTargetName] --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegInitLsaModeContext(
                LSA_SEC_HANDLE      dwCredHandle,
                LSA_SEC_HANDLE      dwCtxtHandle,
                PSECURITY_STRING    pszTargetName,
                ULONG               fContextReq,
                ULONG               TargetDataRep,
                PSecBufferDesc      pInput,
                PLSA_SEC_HANDLE     pdwNewContext,
                PSecBufferDesc      pOutput,
                PULONG              pfContextAttr,
                PTimeStamp          ptsExpiry,
                PBYTE               pfMapContext,
                PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PSecBuffer Buffer  = NULL;
    SecBuffer LocalBuffer  = {0};
    PSecBuffer OutBuf = NULL;
    PNEG_CONTEXT Context  = NULL;
    ULONG PackageIndex ;
    ULONG CallState ;

    CallState = 0 ;

    if ( dwCtxtHandle )
    {
        CallState |= LATER_CALL_BIT ;
    }

    scRet = NegpParseBuffers( pInput, FALSE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegInitLsaModeContext failed to map input buffers, %x\n", scRet ));
        return scRet ;
    }

    if ( ( Buffer != NULL ) &&
         ( Buffer->cbBuffer != 0 ) )
    {
        CallState |= BUFFER_PRESENT_BIT ;
    }

    if ( fContextReq & ISC_REQ_DATAGRAM )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }


    switch ( CallState )
    {
        case FIRST_CALL_WITH_INPUT:
            //
            // Initial case:  Server initiated blob, may be
            // fragmented
            //


            scRet = NegCreateContextFromFragment(
                        dwCredHandle,
                        dwCtxtHandle,
                        Buffer,
                        fContextReq,
                        TargetDataRep,
                        pdwNewContext,
                        pOutput,
                        pfContextAttr );

            if ( scRet == SEC_E_OK )
            {
                Context = (PNEG_CONTEXT) *pdwNewContext ;

                if ( Context )
                {
                    //
                    // final
                    //
                    *pdwNewContext = 0 ;

                    LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                    LocalBuffer.cbBuffer = Context->TotalSize ;
                    LocalBuffer.pvBuffer = Context->Message ;

                    //
                    // Reset frag buffer to NULL - this will be
                    // freed when the call completes by the LSA wrappers.
                    // hence the ChangeBuffer call below:
                    //

                    Context->Message = NULL ;

                    LsapChangeBuffer( Buffer, &LocalBuffer );

                    //
                    // Get rid of the context - we have the whole
                    // message
                    //

                    NegpDeleteContext( Context );
                }
            }
            else if ( NT_SUCCESS( scRet ) )
            {
                //
                // building a context, so return now
                //

                break;
            }


            if ( !NT_SUCCESS( scRet ) )
            {
                //
                // Check the package in use. It is possible that we are being
                // sent the context token from a totally separate package and
                // are being asked to dispatch to the appropriate package.
                //

                scRet = NegpDetermineTokenPackage(
                            dwCredHandle,
                            Buffer,
                            &PackageIndex
                            );



            }
            else
            {
                PackageIndex = (ULONG) -1 ;
            }

            if ( PackageIndex != (ULONG) -1 )
            {
                CtxtHandle TempCtxtHandle = {0};
                CtxtHandle TempInputCtxtHandle = {0};
                CredHandle TempCredHandle;
                PNEG_CREDS Creds = (PNEG_CREDS) dwCredHandle;

#ifndef WIN32_CHICAGO
                NegpReportEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    NEGOTIATE_RAW_PACKET,
                    CATEGORY_NEGOTIATE,
                    0,
                    1,
                    &Creds->Creds[PackageIndex].Package->LsaPackage->Name
                    );
#endif
                //
                // Call into another package to do the accept
                //

                NegReadLockCreds(Creds);
                TempCredHandle = Creds->Creds[PackageIndex].Handle;
                NegUnlockCreds(Creds);

                DebugLog(( DEB_TRACE_NEG, "Got a blob directly for package %x\n",
                            TempCredHandle.dwLower ));


#ifndef WIN32_CHICAGO
                scRet = WLsaInitContext(
                            &TempCredHandle,
                            &TempInputCtxtHandle,
                            pszTargetName,
                            fContextReq,
                            0,
                            TargetDataRep,
                            pInput,
                            0,
                            &TempCtxtHandle,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData
                            );
#else
                {

                    ANSI_STRING TempAnsiString;
                    NTSTATUS TempStatus = RtlUnicodeStringToAnsiString(
                                        &TempAnsiString,
                                        pszTargetName,
                                        TRUE            // allocate destination
                                        );
                    scRet = InitializeSecurityContext(
                                            &TempCredHandle,
                                            &TempInputCtxtHandle,
                                            TempAnsiString.Buffer,
                                            fContextReq,
                                            0,
                                            TargetDataRep,
                                            pInput,
                                            0,
                                            &TempCtxtHandle,
                                            pOutput,
                                            pfContextAttr,
                                            ptsExpiry
                                            );
                    RtlFreeAnsiString( &TempAnsiString );

                }

                Context->CallCount++ ;

#endif // WIN32_CHICAGO
                if (NT_SUCCESS(scRet))
                {
#ifndef WIN32_CHICAGO
                    LsapChangeHandle(
                        HandleReplace,
                        NULL,
                        &TempCtxtHandle
                        );
#endif // WIN32_CHICAGO
                }
            }
            else
            {
                scRet = NegCrackServerRequestAndReply(
                                dwCredHandle,
                                pszTargetName,
                                fContextReq | ISC_REQ_MUTUAL_AUTH,
                                TargetDataRep,
                                pInput,
                                pdwNewContext,
                                pOutput,
                                pfContextAttr,
                                ptsExpiry,
                                pfMapContext,
                                pContextData );

            }

            //
            // if we couldn't parse it, try to go without the hint:
            //

            if ( scRet != SEC_E_INVALID_TOKEN )
            {
                break;
            }
            DebugLog(( DEB_TRACE_NEG, "Unidentified token, trying without it\n" ));

        case FIRST_CALL_NO_INPUT:

            //
            // First call, but server has provided some hints as to
            // what to do.
            //

            scRet = NegGenerateInitialToken(
                            dwCredHandle,
                            pszTargetName,
                            fContextReq,
                            TargetDataRep,
                            pInput,
                            pdwNewContext,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData);

            DebugLog(( DEB_TRACE_NEG, "NegGenerateInitialToken returned %x\n", scRet ));

            break;

        case LATER_CALL_WITH_INPUT:

            //
            // Subsequent call, with a context working and
            // a blob from the server.  May be fragmented
            //


            if ( NegpIsValidContext( dwCtxtHandle ) )
            {
                //
                // See if we're doing fragment reassembly:
                //

                Context = (PNEG_CONTEXT) dwCtxtHandle ;

                if ( Context->Flags & NEG_CONTEXT_FRAGMENTING )
                {
                    scRet = NegAddFragmentToContext(
                                Context,
                                Buffer );

                    //
                    // More trips needed to construct the fragments.
                    //
                    if (scRet == SEC_I_CONTINUE_NEEDED)
                    {
                        NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

                        if ( OutBuf )
                        {
                            OutBuf->cbBuffer = 0 ;
                        }
                        
                        return scRet;  
                    }
                    else if ( scRet != SEC_E_OK )
                    {
                        return scRet ;
                    }

                    //
                    // That was the final blob.  Reset the message
                    // to be the whole thing
                    //

                    LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                    LocalBuffer.cbBuffer = Context->TotalSize ;
                    LocalBuffer.pvBuffer = Context->Message ;

                    //
                    // Reset frag buffer to NULL - this will be
                    // freed when the call completes by the LSA wrappers.
                    // hence the ChangeBuffer call below:
                    //

                    Context->Message = NULL ;


                    scRet = LsapChangeBuffer( Buffer, &LocalBuffer );

                    if ( !NT_SUCCESS( scRet ) )
                    {
                        return scRet ;
                    }

                    //
                    // Fall through to the normal processing
                    //


                }

            }
            else
            {
                return SEC_E_INVALID_HANDLE;
            }

            if (NegpIsValidContext(dwCtxtHandle))
            {

                scRet = NegHandleServerReply(
                                dwCredHandle,
                                (PNEG_CONTEXT) dwCtxtHandle,
                                pszTargetName,
                                fContextReq,
                                TargetDataRep,
                                pInput,
                                pdwNewContext,
                                pOutput,
                                pfContextAttr,
                                ptsExpiry,
                                pfMapContext,
                                pContextData );

            }
            else
            {
                scRet = SEC_E_INVALID_HANDLE ;
            }

            break;

        case LATER_CALL_NO_INPUT:

            //
            // No data from the server,

            if ( NegpIsValidContext( dwCtxtHandle ) )
            {
                //
                // See if we're doing fragment reassembly:
                //

                Context = (PNEG_CONTEXT) dwCtxtHandle ;

                if ( ( Context->Flags & NEG_CONTEXT_FRAGMENTING ) &&
                     ( fContextReq & ISC_REQ_FRAGMENT_TO_FIT ) )
                {
                    //
                    // Pull the next chunk off the stored context:
                    //

                    scRet = NegpParseBuffers( pOutput, FALSE, &Buffer, NULL );

                    if ( ( Buffer != NULL ) &&
                         ( NT_SUCCESS( scRet ) ) )
                    {
                        Buffer->cbBuffer = min( Buffer->cbBuffer,
                                                (Context->TotalSize - Context->CurrentSize) );

                        RtlCopyMemory(
                            Buffer->pvBuffer,
                            Context->Message + Context->CurrentSize,
                            Buffer->cbBuffer );

                        Context->CurrentSize += Buffer->cbBuffer ;

                        if ( Context->CurrentSize == Context->TotalSize )
                        {
                            //
                            // Sent the whole thing
                            //

                            Context->Flags &= (~(NEG_CONTEXT_FRAGMENTING) );
                            Context->TotalSize = 0 ;
                            Context->CurrentSize = 0 ;
                            LsapFreeLsaHeap( Context->Message );
                            Context->Message = NULL ;

                            scRet = Context->LastStatus ;

                            if ( scRet == SEC_E_OK )
                            {
                                *pfMapContext = Context->Mapped;

                                *pContextData = Context->MappedBuffer;

                                *pfContextAttr = Context->Attributes ;

                                RtlZeroMemory(
                                    &Context->MappedBuffer,
                                    sizeof(SecBuffer)
                                    );

#ifndef WIN32_CHICAGO
                                LsapChangeHandle(   HandleReplace,
                                                    NULL,
                                                    &Context->Handle );

                                Context->Handle.dwLower = 0xFFFFFFFF ;
#endif

                            }
                        }
                        else
                        {
                            scRet = SEC_I_CONTINUE_NEEDED ;
                        }

                    }
                    else
                    {
                        DebugLog((DEB_TRACE_NEG, "NegInitLsaModeContext: No buffer found (1)\n" ));
                        scRet = SEC_E_INVALID_TOKEN ;
                    }

                }
                else
                {
                    //
                    // Last round trip for signed blobs:
                    //

                    if ( Context->LastStatus == SEC_E_OK )
                    {
                        *pfMapContext = Context->Mapped;

                        *pContextData = Context->MappedBuffer;

                        *pfContextAttr = Context->Attributes ;

                        RtlZeroMemory(
                            &Context->MappedBuffer,
                            sizeof(SecBuffer)
                            );

                        scRet = NegpParseBuffers( pOutput, FALSE, &Buffer, NULL );

                        if ( Buffer &&
                            NT_SUCCESS( scRet ) )
                        {
                            Buffer->cbBuffer = 0 ;
                        }


                        scRet = SEC_E_OK ;

#ifndef WIN32_CHICAGO
                        LsapChangeHandle(   HandleReplace,
                                            NULL,
                                            &Context->Handle );

                        Context->Handle.dwLower = 0xFFFFFFFF ;
#endif

                    }
                    else
                    {


                        DebugLog(( DEB_TRACE_NEG, "NegInitLsaModeContext:  Signed exchange not ok\n" ));
                        scRet = SEC_E_INVALID_TOKEN ;

                    }
                }

            }
            else
            {
                scRet = SEC_E_INVALID_TOKEN ;

            }
            break;

        default:
            DsysAssert( FALSE );
            scRet = SEC_E_INTERNAL_ERROR ;



    }

    return scRet ;

}



SECURITY_STATUS SEC_ENTRY
NegMoveContextToUser(
    LSA_SEC_HANDLE       dwCtxtHandle,
    PSecBuffer  pContextBuffer
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegDeleteLsaModeContext
//
//  Synopsis:   Deletes the LSA portion of the context
//
//  Arguments:  [dwCtxtHandle] --
//
//  History:    9-24-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
NegDeleteLsaModeContext( LSA_SEC_HANDLE dwCtxtHandle)
{
    SECURITY_STATUS scRet = SEC_E_INVALID_HANDLE;
    PNEG_CONTEXT    Context;
#ifndef WIN32_CHICAGO
    PSession        pSession = GetCurrentSession();
#endif

    Context = (PNEG_CONTEXT) dwCtxtHandle ;

    __try
    {
        if (NegpIsValidContext( Context ))
        {
#ifndef WIN32_CHICAGO
            //
            // If the session is being run down, don't call WLsaDeleteContext,
            // it will complicate things (that entry may already have been
            // deleted.
            //

            if ( pSession->fSession & SESFLAG_CLEANUP )
            {
                Context->Handle.dwLower = 0 ;
                Context->Handle.dwUpper = 0 ;
            }

            NegpDeleteContext( Context );
            scRet = SEC_E_OK ;
#endif
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {}

    return( scRet );
}

SECURITY_STATUS SEC_ENTRY
NegApplyControlToken( LSA_SEC_HANDLE dwCtxtHandle,
                      PSecBufferDesc  pInput)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


VOID
SEC_ENTRY
NegLogoffNotify(
    PLUID  pLogonId
    )
{
#ifndef WIN32_CHICAGO

    NegpDerefLogonSessionById( pLogonId );

#endif
}

#define TOKEN_MATCHES(_buf_,_oid_,_oidlen_) \
    (((_buf_)->cbBuffer >= (_oidlen_)) && \
      RtlEqualMemory( \
        (_buf_)->pvBuffer, \
        (_oid_), \
        (_oidlen_) \
        ))


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

NTSTATUS
NegpGetTokenOid(
     IN PUCHAR Buf,
     OUT ULONG BufSize,
     OUT ObjectID * ObjectId
     )
{
    UCHAR sf;
    ULONG TokenSize;
    ULONG OidLength;

    //
    // Check for the encoding indicator
    //

    if (BufSize < 2)
    {
        return SEC_E_INVALID_TOKEN;
    }

    if ( (*Buf == 0x60) ||
         (*Buf == 0xa0) )
    {
        Buf++;
    }
    else
    {
        return SEC_E_INVALID_TOKEN;
    }

    sf = *(Buf)++;

    (BufSize)--;

    if (sf & 0x80)
    {
        if ((sf &= 0x7f) > ((BufSize)-1))
        {
            return(SEC_E_INVALID_TOKEN);
        }
        if (sf > sizeof(ULONG))
        {
            return (SEC_E_INVALID_TOKEN);
        }
        TokenSize = 0;
        for (; sf; sf--)
        {
            TokenSize = (TokenSize<<8) + (*(Buf)++);
            (BufSize)--;
        }
   } else {
      TokenSize = sf;
   }

   if ((--BufSize == 0) || *Buf != 0x06)
   {
       return(SEC_E_INVALID_TOKEN);
   }
   if (--BufSize == 0)
   {
       return(SEC_E_INVALID_TOKEN);
   }
   OidLength = *(Buf+1) + 2; // two extra for OID tag & length field

   //
   // Now buf should point to the encoded oid
   //

   *ObjectId = NegpDecodeObjectId(Buf,OidLength);
   if (ObjectId == NULL)
   {
       return(SEC_E_INVALID_TOKEN);
   }

   return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   NegpDetermineTokenPackage
//
//  Synopsis:   Determines the package that generated an initial
//              context token
//
//  Effects:
//
//  Arguments:  CredHandle - handle to the server's credentials
//              InitialToken -Initial context token from client
//              Package - NULL if spnego, otherwise the package
//                      that generated the token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NegpDetermineTokenPackage(
    IN ULONG_PTR CredHandle,
    IN PSecBuffer InitialToken,
    OUT PULONG PackageIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;
    PNEG_CREDS Credentials = (PNEG_CREDS) CredHandle;
    ObjectID DecodedOid = NULL;
    int Length ;
    PUCHAR Buffer ;
    LONG Header ;
    LONG Size ;
    ULONG_PTR Package ;

    *PackageIndex = (ULONG) -1;



    //
    // Get the OID from the token, if possible
    //

    Status = NegpGetTokenOid(
                (PUCHAR) InitialToken->pvBuffer,
                InitialToken->cbBuffer,
                &DecodedOid
                );

    if (NT_SUCCESS(Status))
    {
        Status = SEC_E_INVALID_TOKEN;

        //
        // First check for spnego
        //

        if (NegpCompareOid(
                DecodedOid,
                NegSpnegoMechOid
                ) == 0)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // Try the oid for each mech in the credential
            //

            NegReadLockCreds(Credentials);

            Package = NegpFindPackageForOid( Credentials, DecodedOid );

            if ( Package != NEG_INVALID_PACKAGE )
            {
                *PackageIndex = (ULONG) Package ;
                Status = STATUS_SUCCESS ;
            }
            else
            {
                Status = SEC_E_SECPKG_NOT_FOUND ;
            }

            NegUnlockCreds(Credentials);
        }
        NegpFreeObjectId(DecodedOid);
    }
    else
    {
        if (TOKEN_MATCHES(InitialToken,NTLMSSP_SIGNATURE,sizeof(NTLMSSP_SIGNATURE)))
        {
            //
            // Find the NTLM package in the list of packages
            //

            NegReadLockCreds(Credentials);
            for (Index = 0; Index < Credentials->Count ; Index++ )
            {
                if (Credentials->Creds[Index].Package->LsaPackage->dwRPCID == NTLMSP_RPCID)
                {
                    *PackageIndex = Index;
                    Status = STATUS_SUCCESS;
                    break;
                }
            }

            //
            // If we didn't find ntlm, return invalid token.
            //

            NegUnlockCreds(Credentials);

            if ( NT_SUCCESS( Status ) )
            {
                return Status;
            }
        }

        Size = InitialToken->cbBuffer ;
        Buffer = (PUCHAR) InitialToken->pvBuffer ;
        Buffer ++ ;

        Length = Neg_der_read_length(
                    &Buffer,
                    &Size,
                    &Header );

        if ( Length > 0 )
        {
            //
            // Could be kerb, could be snego.  Poke a little to find out
            //

            if ( (*Buffer & 0xC0) == 0x40 )
            {
                NegReadLockCreds(Credentials);
                for (Index = 0; Index < Credentials->Count ; Index++ )
                {
                    if (Credentials->Creds[Index].Package->LsaPackage->dwRPCID == RPC_C_AUTHN_GSS_KERBEROS)
                    {
                        *PackageIndex = Index;
                        Status = STATUS_SUCCESS;
                        break;
                    }
                }

                //
                // If we didn't find kerberos, return invalid token.
                //

                NegUnlockCreds(Credentials);

            }

        }

    }

    return(Status);

}



SECURITY_STATUS
SEC_ENTRY
NegAcceptLsaModeContext(
   LSA_SEC_HANDLE  dwCredHandle,
   LSA_SEC_HANDLE  dwCtxtHandle,
   PSecBufferDesc  pInput,
   ULONG           fContextReq,
   ULONG           TargetDataRep,
   PLSA_SEC_HANDLE pdwNewContext,
   PSecBufferDesc  pOutput,
   PULONG          pfContextAttr,
   PTimeStamp      ptsExpiry,
   PBYTE           pfMapContext,
   PSecBuffer      pContextData)
{
    SECURITY_STATUS scRet = STATUS_SUCCESS;
    ULONG PackageIndex = 0;
    PSecBuffer  Buffer;
    SecBufferDesc LocalDesc ;
    SecBuffer LocalBuffer ;
    PSecBuffer OutBuf = NULL;
    PNEG_CONTEXT Context = NULL ;
    PNEG_CREDS Cred ;
    PNEG_CREDS AltCreds ;
    PLIST_ENTRY Scan ;
    BOOL LocalUseSpnego ;
    ULONG CallState ;


    CallState = 0 ;

    if ( dwCtxtHandle )
    {
        CallState |= LATER_CALL_BIT ;
    }

    scRet = NegpParseBuffers( pInput, FALSE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegAcceptLsaModeContext failed to map input buffers, %x\n", scRet ));
        return scRet ;
    }

    if ( ( Buffer != NULL ) &&
         ( Buffer->cbBuffer != 0 ) )
    {
        CallState |= BUFFER_PRESENT_BIT ;
    }

    ULONG_PTR PackageId = GetCurrentPackageId();

    DebugLog(( DEB_TRACE_NEG, "AcceptLsaModeContext( %x, %x )\n",
                dwCredHandle, dwCtxtHandle ));

#ifndef WIN32_CHICAGO
    ptsExpiry->QuadPart = (LONGLONG) MAXLONGLONG;
#else
    *ptsExpiry = (LONGLONG) MAXLONGLONG;
#endif

    switch ( CallState )
    {
        case FIRST_CALL_NO_INPUT:

            scRet = NegGenerateServerRequest(
                                                dwCredHandle,
                                                fContextReq,
                                                TargetDataRep,
                                                pInput,
                                                pdwNewContext,
                                                pOutput,
                                                pfContextAttr,
                                                ptsExpiry,
                                                pfMapContext,
                                                pContextData );
            break;

        case FIRST_CALL_WITH_INPUT:

            //
            // Determine if this is a fragment, and if so, is it the
            // last fragment:
            //

            scRet = NegCreateContextFromFragment(
                        dwCredHandle,
                        dwCtxtHandle,
                        Buffer,
                        fContextReq,
                        TargetDataRep,
                        pdwNewContext,
                        pOutput,
                        pfContextAttr );

            *pfMapContext = FALSE ;


            if ( scRet == SEC_E_OK )
            {
                Context = (PNEG_CONTEXT) *pdwNewContext ;

                if ( Context )
                {
                    //
                    // final
                    //
                    *pdwNewContext = 0 ;

                    LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                    LocalBuffer.cbBuffer = Context->TotalSize ;
                    LocalBuffer.pvBuffer = Context->Message ;

                    //
                    // Reset frag buffer to NULL - this will be
                    // freed when the call completes by the LSA wrappers.
                    // hence the ChangeBuffer call below:
                    //

                    Context->Message = NULL ;

                    LsapChangeBuffer( Buffer, &LocalBuffer );

                    //
                    // Get rid of the context - we have the whole
                    // message
                    //

                    NegpDeleteContext( Context );
                }
            }
            else if ( NT_SUCCESS( scRet ) )
            {
                //
                // building a context, so return now
                //

                return scRet ;
            }


            if ( !NT_SUCCESS( scRet ) )
            {
                //
                // Check the package in use. It is possible that we are being
                // sent the context token from a totally separate package and
                // are being asked to dispatch to the appropriate package.
                //

                scRet = NegpDetermineTokenPackage(
                            dwCredHandle,
                            Buffer,
                            &PackageIndex
                            );

            }
            else
            {
                PackageIndex = (ULONG) -1 ;
            }

            //
            // Older clients will send data that returns an error
            //

            if (!NT_SUCCESS(scRet) || (PackageIndex == (ULONG) -1))
            {

                scRet = NegHandleClientRequest(
                                            dwCredHandle,
                                            NULL,
                                            fContextReq,
                                            TargetDataRep,
                                            pInput,
                                            pdwNewContext,
                                            pOutput,
                                            pfContextAttr,
                                            ptsExpiry,
                                            pfMapContext,
                                            pContextData );

                if ( !NT_SUCCESS( scRet ) ||
                     ( NT_SUCCESS( scRet ) && (*pfContextAttr & ASC_RET_EXTENDED_ERROR) ) )
                {
                    Cred = (PNEG_CREDS) dwCredHandle ;

                    NegReadLockCreds( Cred );

                    if ( Cred->Flags & NEGCRED_MULTI )
                    {
                        //
                        // This credential has additional creds hanging off of it.
                        //

                        DebugLog(( DEB_TRACE_NEG, "Multi credential handle:\n" ));

                        Scan = Cred->AdditionalCreds.Flink ;

                        while ( Scan != &Cred->AdditionalCreds )
                        {
                            AltCreds = CONTAINING_RECORD( Scan, NEG_CREDS, List );



                            DebugLog(( DEB_TRACE_NEG, "Retrying with credential %p\n", AltCreds ));

                            scRet = NegHandleClientRequest(
                                                    (ULONG_PTR) AltCreds,
                                                    NULL,
                                                    fContextReq,
                                                    TargetDataRep,
                                                    pInput,
                                                    pdwNewContext,
                                                    pOutput,
                                                    pfContextAttr,
                                                    ptsExpiry,
                                                    pfMapContext,
                                                    pContextData );

                            if ( NT_SUCCESS( scRet ) &&
                                 ( ( *pfContextAttr & ASC_RET_EXTENDED_ERROR ) == 0 ) )
                            {
                                break;
                            }

                            Scan = Scan->Flink ;
                        }
                    }

                    NegUnlockCreds( Cred );

                }

            }
            else
            {
                CtxtHandle TempCtxtHandle = {0};
                CtxtHandle TempInputCtxtHandle = {0};
                CredHandle TempCredHandle;
                PNEG_CREDS Creds = (PNEG_CREDS) dwCredHandle;

#ifndef WIN32_CHICAGO
                NegpReportEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    NEGOTIATE_RAW_PACKET,
                    CATEGORY_NEGOTIATE,
                    0,
                    1,
                    &Creds->Creds[PackageIndex].Package->LsaPackage->Name
                    );
#endif

                //
                // Call into another package to do the accept
                //

                NegReadLockCreds(Creds);
                TempCredHandle = Creds->Creds[PackageIndex].Handle;
                NegUnlockCreds(Creds);

                DebugLog(( DEB_TRACE_NEG, "Got a blob directly for package %x\n",
                            TempCredHandle.dwLower ));


                PackageId = GetCurrentPackageId();

#ifndef WIN32_CHICAGO
                scRet = WLsaAcceptContext(
                            &TempCredHandle,
                            &TempInputCtxtHandle,
                            pInput,
                            fContextReq,
                            TargetDataRep,
                            &TempCtxtHandle,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData
                            );
#else
                scRet = AcceptSecurityContext(
                            &TempCredHandle,
                            &TempInputCtxtHandle,
                            pInput,
                            fContextReq,
                            TargetDataRep,
                            &TempCtxtHandle,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry
                            );
#endif // WIN32_CHICAGO

                SetCurrentPackageId(PackageId);

                if (Context)
                {
                    Context->CallCount++ ;
                }

                if (NT_SUCCESS(scRet))
                {
#ifndef WIN32_CHICAGO
                    LsapChangeHandle(
                        HandleReplace,
                        NULL,
                        &TempCtxtHandle
                        );
#endif // WIN32_CHICAGO
                }

            }

            break;

        case LATER_CALL_NO_INPUT:

            DebugLog(( DEB_TRACE_NEG, "Missing Input Buffer?\n"));

            scRet = SEC_E_INVALID_HANDLE ;

            break;

        case LATER_CALL_WITH_INPUT:

            Context = (PNEG_CONTEXT) dwCtxtHandle ;

            if ( !NegpIsValidContext( dwCtxtHandle ) )
            {
                return SEC_E_INVALID_HANDLE ;
            }

            if ( Context->Flags & NEG_CONTEXT_FRAGMENTING )
            {
                scRet = NegAddFragmentToContext(
                            Context,
                            Buffer );

                //
                // More trips needed to reconstruct the fragment.
                //
                if (scRet == SEC_I_CONTINUE_NEEDED)
                {
                    NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

                    if ( OutBuf )
                    {
                        OutBuf->cbBuffer = 0 ;
                    }
                    return scRet;
                }
                else if ( scRet != SEC_E_OK )
                {
                    return scRet ;
                }

                //
                // That was the final blob.  Reset the message
                // to be the whole thing
                //

                LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                LocalBuffer.cbBuffer = Context->TotalSize ;
                LocalBuffer.pvBuffer = Context->Message ;

                //
                // Reset frag buffer to NULL - this will be
                // freed when the call completes by the LSA wrappers.
                // hence the ChangeBuffer call below:
                //

                Context->Message = NULL ;


                scRet = LsapChangeBuffer( Buffer, &LocalBuffer );

                if ( !NT_SUCCESS( scRet ) )
                {
                    return scRet ;
                }

                //
                // Fall through to the normal processing
                //

            }


            scRet = NegHandleClientRequest(
                                            dwCredHandle,
                                            (PNEG_CONTEXT) dwCtxtHandle,
                                            fContextReq,
                                            TargetDataRep,
                                            pInput,
                                            pdwNewContext,
                                            pOutput,
                                            pfContextAttr,
                                            ptsExpiry,
                                            pfMapContext,
                                            pContextData );

            break;

        default:

            DsysAssert(FALSE);
            scRet = SEC_E_INTERNAL_ERROR ;
            break;
    }

    return scRet ;

}


NTSTATUS
NegCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
#ifdef WIN32_CHICAGO
    return SEC_E_UNSUPPORTED_FUNCTION ;
#else

    PULONG_PTR MessageTypePtr ;
    NEGOTIATE_MESSAGES Messages ;

    if ( SubmitBufferLength < sizeof( ULONG_PTR ) )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    MessageTypePtr = (PULONG_PTR) ProtocolSubmitBuffer ;

    if ( *MessageTypePtr >= NegCallPackageMax )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    switch ( *MessageTypePtr )
    {
        case NegEnumPackagePrefixes:
            return NegEnumPackagePrefixesCall(
                        ClientRequest,
                        ProtocolSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferLength,
                        ProtocolReturnBuffer,
                        ReturnBufferLength,
                        ProtocolStatus );
            break;
        case NegGetCallerName:
            return NegGetCallerNameCall(
                        ClientRequest,
                        ProtocolSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferLength,
                        ProtocolReturnBuffer,
                        ReturnBufferLength,
                        ProtocolStatus );
            break;
        default:
            DsysAssert( FALSE );
            return STATUS_NOT_IMPLEMENTED ;

    }

#endif
}

NTSTATUS
NegCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS
NegCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}



SECURITY_STATUS SEC_ENTRY
NegShutdown(void)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
NegSystemLogon( PSECURITY_STRING    pName,
               DWORD               cbKey,
               PBYTE               pbKey,
               DWORD *             pdwHandle,
               PTimeStamp          ptsExpiry)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
NegGetUserInfo(  PLUID                   pLogonId,
                ULONG                   fFlags,
                PSecurityUserData *     ppUserInfo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}





//+---------------------------------------------------------------------------
//
//  Function:   NegSaveCredentials
//
//  Synopsis:   Store credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegSaveCredentials( LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+---------------------------------------------------------------------------
//
//  Function:   NegGetCredentials
//
//  Synopsis:   Get Credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegGetCredentials(  LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Function:   NegDeleteCredentials
//
//  Synopsis:   Delete stored creds (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pKey]         --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegDeleteCredentials( LSA_SEC_HANDLE    dwCredHandle,
                      PSecBuffer        pKey)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


SECURITY_STATUS SEC_ENTRY
NegAddCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING Package,
    IN ULONG CredentialUseFlags,
    IN PVOID AuthorizationData,
    IN PVOID GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PTimeStamp ExpirationTime
    )
{
    PNEG_CREDS Cred ;
    PNEG_CREDS NewCred ;
    NTSTATUS Status ;
    TimeStamp Expiration ;
    PLIST_ENTRY Prev ;
    PNEG_CREDS PreviousCreds ;


    Cred = (PNEG_CREDS) CredentialHandle ;

    Status = NegpAcquireCredHandle(
                PrincipalName,
                CredentialUseFlags | NEG_CRED_DONT_LINK,
                &Cred->ClientLogonId,
                AuthorizationData,
                GetKeyFunction,
                GetKeyArgument,
                (PULONG_PTR) &NewCred,
                &Expiration );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    NegWriteLockCreds( Cred );

    Prev = Cred->AdditionalCreds.Blink ;

    if ( Prev != &Cred->AdditionalCreds )
    {
        //
        // If there are other creds, make sure they are marked
        //

        PreviousCreds = CONTAINING_RECORD( Prev, NEG_CREDS, List );

        PreviousCreds->Flags |= NEGCRED_MULTI_PART ;
    }

    InsertTailList( &Cred->AdditionalCreds, &NewCred->List );

    Cred->Flags |= NEGCRED_MULTI ;

    NegUnlockCreds( Cred );

    return Status ;


}


NTSTATUS
NegGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    PSECPKG_EXTENDED_INFORMATION Thunks ;
    NTSTATUS Status ;

    switch ( Class )
    {
        case SecpkgContextThunks:
            Thunks = (PSECPKG_EXTENDED_INFORMATION) LsapAllocateLsaHeap( sizeof( SECPKG_EXTENDED_INFORMATION ) + sizeof( DWORD ));
            if ( Thunks )
            {
                Thunks->Class = SecpkgContextThunks;
                Thunks->Info.ContextThunks.InfoLevelCount = 2 ;
                Thunks->Info.ContextThunks.Levels[0] = SECPKG_ATTR_PACKAGE_INFO;
                Thunks->Info.ContextThunks.Levels[1] = SECPKG_ATTR_SIZES ;
                Status = STATUS_SUCCESS ;
            }
            else
            {
                Status = STATUS_NO_MEMORY ;
            }
            *ppInformation = Thunks ;


            break;

        default:
            *ppInformation = NULL ;
            Status = STATUS_INVALID_INFO_CLASS ;
            break;
    }

    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   NegQueryContextAttributes
//
//  Synopsis:   
//
//  Arguments:  [ContextHandle]    -- 
//              [ContextAttribute] -- 
//              [Buffer]           -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
NegQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer)
{
    SecPkgContext_NegotiationInfoW NegInfo = {0};
    SecPkgContext_Sizes Sizes ;
    NTSTATUS Status = STATUS_SUCCESS;
    PNEG_CONTEXT Context = (PNEG_CONTEXT) ContextHandle ;
    SECPKG_CALL_INFO CallInfo ;
    SecPkgInfoW PackageInfo ;

#ifndef WIN32_CHICAGO

    LsapGetCallInfo( &CallInfo );

    switch ( ContextAttribute )
    {
        case SECPKG_ATTR_NEGOTIATION_INFO :

            if ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE )
            {
                Status = LsapCopyFromClient(
                            Buffer,
                            &NegInfo,
                            sizeof( NegInfo ) );

                
            }

            if ( (Context->Flags & NEG_CONTEXT_NEGOTIATING) != 0 )
            {
                NegInfo.NegotiationState = SECPKG_NEGOTIATION_IN_PROGRESS ;
            }
            else
            {
                NegInfo.NegotiationState = SECPKG_NEGOTIATION_OPTIMISTIC ;
            }

            if ( NegInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC )
            {
                if ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) == 0 )
                {
                    Status = WLsaQueryPackageInfo(
                                &Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->Name,
                                &NegInfo.PackageInfo
                                );

                    
                }
                else
                {

                    //
                    // For kernel mode callers, we can't return the package info
                    // this way due to VM risks.  So, we just put the package ID 
                    // into the pointer, and ksec looks it up in kernel space.
                    //

                    PackageInfo.wRPCID = (WORD) Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->dwRPCID;
                    PackageInfo.fCapabilities = Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->fCapabilities ;
                    PackageInfo.cbMaxToken = Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->TokenSize ;

                    Status = LsapCopyToClient(
                                &PackageInfo,
                                NegInfo.PackageInfo,
                                sizeof( PackageInfo ) );

                }

            }

            if (NT_SUCCESS(Status))
            {
                Status = LsapCopyToClient( &NegInfo, Buffer, sizeof( NegInfo ) );
                if (!NT_SUCCESS(Status))
                {
                    if (( NegInfo.PackageInfo != NULL ) &&
                        ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) == 0 ) )
                    {
                        LsapClientFree(NegInfo.PackageInfo);
                    }
                }
            }

            return Status ;

        case SECPKG_ATTR_SIZES:
            Sizes.cbMaxToken = NegLsaPackage->TokenSize ;
            Sizes.cbMaxSignature = 64 ;
            Sizes.cbBlockSize = 8 ;
            Sizes.cbSecurityTrailer =  64 ;

            Status = LsapCopyToClient( &Sizes, Buffer, sizeof( Sizes ) );

            return Status ;

        default:
            return SEC_E_UNSUPPORTED_FUNCTION ;

    }
#endif
    return SEC_E_UNSUPPORTED_FUNCTION ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\policy.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        policy.cxx
//
// Contents:    SpmBuildCairoToken
//
//
// History:     23-May-1994     MikeSw      Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "adtp.h"
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCreateToken
//
//  Synopsis:   Builds a token from the various pieces of information
//              generated during a logon.
//
//  Effects:
//
//  Arguments:  pUserSid - sid of user to create token for
//              pTokenGroups - groups passed in to LogonUser or from PAC to
//                  be put in token
//              pTokenPrivs - privileges from PAC to put in token
//              TokenType - type of token to create
//              pTokenSource - source of the token
//              pLogonId - Gets logon ID
//              phToken - Get handle to token
//
//  Requires:
//
//  Returns:
//
//  Notes:      TokenInformation is always freed, even on failure.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsapCreateToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN LSA_TOKEN_INFORMATION_TYPE InputTokenInformationType,
    IN PVOID InputTokenInformation,
    IN PTOKEN_GROUPS LocalGroups,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PUNICODE_STRING ProfilePath,
    OUT PHANDLE Token,
    OUT PNTSTATUS SubStatus
    )
{
    SECPKG_PRIMARY_CRED PrimaryCredential;

    ZeroMemory( &PrimaryCredential, sizeof(PrimaryCredential) );


    if( AccountName != NULL )
    {
        PrimaryCredential.DownlevelName = *AccountName;
    }

    if( AuthorityName != NULL )
    {
        PrimaryCredential.DomainName = *AuthorityName;
    }

    return LsapCreateTokenEx(
                LogonId,
                TokenSource,
                LogonType,
                ImpersonationLevel,
                InputTokenInformationType,
                InputTokenInformation,
                LocalGroups,
                WorkstationName,
                ProfilePath,
                &PrimaryCredential,
                SecSessionPrimaryCred,
                Token,
                SubStatus
                );

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapCreateTokenEx
//
//  Synopsis:   Builds a token from the various pieces of information
//              generated during a logon.
//
//  Effects:
//
//  Arguments:  pUserSid - sid of user to create token for
//              pTokenGroups - groups passed in to LogonUser or from PAC to
//                  be put in token
//              pTokenPrivs - privileges from PAC to put in token
//              TokenType - type of token to create
//              pTokenSource - source of the token
//              pLogonId - Gets logon ID
//              phToken - Get handle to token
//
//  Requires:
//
//  Returns:
//
//  Notes:      TokenInformation is always freed, even on failure.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsapCreateTokenEx(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN LSA_TOKEN_INFORMATION_TYPE InputTokenInformationType,
    IN PVOID InputTokenInformation,
    IN PTOKEN_GROUPS LocalGroups,
    IN PUNICODE_STRING WorkstationName,
    IN PUNICODE_STRING ProfilePath,
    IN PVOID SessionInformation,
    IN SECPKG_SESSIONINFO_TYPE SessionInformationType,
    OUT PHANDLE Token,
    OUT PNTSTATUS SubStatus
    )
{
    NTSTATUS Status;
    PPRIVILEGE_SET PrivilegesAssigned = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformationV2 = NULL;
    PLSA_TOKEN_INFORMATION_NULL TokenInformationNull = NULL;
    LSA_TOKEN_INFORMATION_TYPE OriginalTokenType = InputTokenInformationType;
    QUOTA_LIMITS QuotaLimits;
    PUNICODE_STRING NewAccountName = NULL;
    PUNICODE_STRING NewAuthorityName = NULL;
    PUNICODE_STRING NewProfilePath = NULL;
    UNICODE_STRING LocalAccountName = { 0 };
    UNICODE_STRING LocalAuthorityName =  { 0 };
    UNICODE_STRING LocalProfilePath = { 0 };
    PSID NewUserSid = NULL;
    LSA_TOKEN_INFORMATION_TYPE TokenInformationType = InputTokenInformationType;
    PVOID TokenInformation = InputTokenInformation;

    PSECPKG_PRIMARY_CRED PrimaryCredential;
    PUNICODE_STRING AccountName;
    PUNICODE_STRING AuthorityName;


    *Token = NULL;
    *SubStatus = STATUS_SUCCESS;

    if( SessionInformationType != SecSessionPrimaryCred )
    {
        return STATUS_INVALID_PARAMETER;
    }

    PrimaryCredential = (PSECPKG_PRIMARY_CRED)SessionInformation;

    AccountName = &PrimaryCredential->DownlevelName;
    AuthorityName = &PrimaryCredential->DomainName;

    //
    // Pass the token information through the Local Security Policy
    // Filter/Augmentor.  This may cause some or all of the token
    // information to be replaced/augmented.
    //

    Status = LsapAuUserLogonPolicyFilter(
                 LogonType,
                 &TokenInformationType,
                 &TokenInformation,
                 LocalGroups,
                 &QuotaLimits,
                 &PrivilegesAssigned
                 );




    if ( !NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Check if we only allow admins to logon.  We do allow null session
    // connections since they are severly restricted, though. Since the
    // token type may have been changed, we use the token type originally
    // returned by the package.
    //

    if (LsapAllowAdminLogonsOnly &&
        ((OriginalTokenType == LsaTokenInformationV1) ||
        (OriginalTokenType == LsaTokenInformationV2))&&
        !LsapSidPresentInGroups(
            ((PLSA_TOKEN_INFORMATION_V2) TokenInformation)->Groups,
            (SID *)LsapAliasAdminsSid)) {

        //
        // Set the status to be invalid workstation, since all accounts
        // except administrative ones are locked out for this
        // workstation.
        //

        *SubStatus = STATUS_INVALID_WORKSTATION;
        Status = STATUS_ACCOUNT_RESTRICTION;
        goto Cleanup;
    }

    //
    // Case on the token information returned (and subsequently massaged)
    // to create the correct kind of token.
    //

    switch (TokenInformationType) {

    case LsaTokenInformationNull:

        TokenInformationNull = (PLSA_TOKEN_INFORMATION_NULL) TokenInformation;

        //
        // The user hasn't logged on to any particular account.
        // An impersonation token with WORLD as owner
        // will be created.
        //


        Status = LsapCreateNullToken(
                     LogonId,
                     TokenSource,
                     TokenInformationNull,
                     Token
                     );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }


        break;




    case LsaTokenInformationV1:
    case LsaTokenInformationV2:

        TokenInformationV2 = (PLSA_TOKEN_INFORMATION_V2) TokenInformation;

        //
        // the type of token created depends upon the type of logon
        // being requested:
        //
        //        InteractiveLogon => PrimaryToken
        //        BatchLogon       => PrimaryToken
        //        NetworkLogon     => ImpersonationToken
        //

        if (LogonType != Network) {

            //
            // Primary token
            //

            Status = LsapCreateV2Token(
                         LogonId,
                         TokenSource,
                         TokenInformationV2,
                         TokenPrimary,
                         ImpersonationLevel,
                         Token
                         );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }


        } else {

            //
            // Impersonation token
            //

            Status = LsapCreateV2Token(
                         LogonId,
                         TokenSource,
                         TokenInformationV2,
                         TokenImpersonation,
                         ImpersonationLevel,
                         Token
                         );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }


        }

        //
        // Copy out the User Sid
        //

        Status = LsapDuplicateSid( &NewUserSid, TokenInformationV2->User.User.Sid );

        if ( !NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        break;

    }

    //
    // Audit special privilege assignment, if there were any
    //

    if ( PrivilegesAssigned != NULL ) {

        //
        // Examine the list of privileges being assigned, and
        // audit special privileges as appropriate.
        //

        LsapAdtAuditSpecialPrivileges( PrivilegesAssigned, *LogonId, NewUserSid );

    }


    NewAccountName = &LocalAccountName ;
    NewAuthorityName = &LocalAuthorityName ;


    //
    // If the original was a null session, set the user name & domain name
    // to be anonymous.
    //

    if (OriginalTokenType == LsaTokenInformationNull)
    {
        NewAccountName->Buffer = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength);
        if (NewAccountName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAccountName->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength;
        RtlCopyUnicodeString(
            NewAccountName,
            &WellKnownSids[LsapAnonymousSidIndex].Name
            );

        NewAuthorityName->Buffer = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength);
        if (NewAuthorityName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAuthorityName->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength;
        RtlCopyUnicodeString(
            NewAuthorityName,
            &WellKnownSids[LsapAnonymousSidIndex].DomainName
            );

    }
    else
    {
        NewAccountName->Buffer = (LPWSTR) LsapAllocateLsaHeap(AccountName->MaximumLength);
        if (NewAccountName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAccountName->MaximumLength = AccountName->MaximumLength;
        RtlCopyUnicodeString(
            NewAccountName,
            AccountName
            );

        NewAuthorityName->Buffer = (LPWSTR) LsapAllocateLsaHeap(AuthorityName->MaximumLength);
        if (NewAuthorityName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAuthorityName->MaximumLength = AuthorityName->MaximumLength;
        RtlCopyUnicodeString(
            NewAuthorityName,
            AuthorityName
            );

        if (ARGUMENT_PRESENT(ProfilePath) ) {
            NewProfilePath = &LocalProfilePath ;

            NewProfilePath->Buffer = (LPWSTR) LsapAllocateLsaHeap(ProfilePath->MaximumLength);
            if (NewProfilePath->Buffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            NewProfilePath->MaximumLength = ProfilePath->MaximumLength;
            RtlCopyUnicodeString(
                NewProfilePath,
                ProfilePath
                );

        }
    }


    Status = LsapSetLogonSessionAccountInfo(
                LogonId,
                NewAccountName,
                NewAuthorityName,
                NewProfilePath,
                &NewUserSid,
                LogonType,
                PrimaryCredential
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LocalAccountName.Buffer = NULL ;
    LocalAuthorityName.Buffer = NULL ;
    LocalProfilePath.Buffer = NULL ;

    //
    // Set the token on the session
    //

    Status = LsapSetSessionToken( *Token, LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


Cleanup:

    //
    // Clean up on failure
    //

    if ( !NT_SUCCESS(Status) ) {

        //
        // If we successfully built the token,
        //  free it.
        //

        if ( *Token != NULL ) {
            NtClose( *Token );
            *Token = NULL;
        }
    }


    //
    // Always free the token information because the policy filter
    // changes it.
    //

    switch (TokenInformationType) {

        case LsaTokenInformationNull:

            LsapFreeTokenInformationNull( (PLSA_TOKEN_INFORMATION_NULL) TokenInformation );
            break;

        case LsaTokenInformationV1:

            LsapFreeTokenInformationV1( (PLSA_TOKEN_INFORMATION_V1) TokenInformation );
            break;

        case LsaTokenInformationV2:

            LsapFreeTokenInformationV2( (PLSA_TOKEN_INFORMATION_V2) TokenInformation );
            break;

    }

    if ( LocalAccountName.Buffer != NULL )
    {
        LsapFreeLsaHeap( LocalAccountName.Buffer );
    }

    if ( LocalAuthorityName.Buffer != NULL )
    {
        LsapFreeLsaHeap( LocalAuthorityName.Buffer );
    }

    if ( LocalProfilePath.Buffer != NULL )
    {
        LsapFreeLsaHeap( LocalProfilePath.Buffer );
    }

    if (NewUserSid != NULL) {
        LsapFreeLsaHeap( NewUserSid );
    }
    if ( PrivilegesAssigned != NULL ) {

        MIDL_user_free( PrivilegesAssigned );
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\safemode.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    safeboot.h

Abstract:

    Header for module to determine what boot mode the system was boot into.

Author:

    Colin Brace         (ColinBr)    May 27, 1997.

Environment:

    User mode

Revision History:

--*/

NTSTATUS
LsapCheckBootMode(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sesmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SesMgr.c
//
// Contents:    "Session" manager implementation
//
// Functions:   InitSessionManager          -- Sets up the session manager
//              CreateSession               -- Create a session
//              DeleteSession               -- Delete a session
//              LocateSession               -- Locates a session based on CallerContext
//              GetAndSetSession            -- Sticks session in TLS
//              FreeSession                 -- Frees a session from a thread
//              AddCredHandle               -- Adds a cred handle to session
//              DelCredHandle               -- Deletes a cred handle from a session
//
// History:
//
//------------------------------------------------------------------------


#include <lsapch.hxx>
extern "C"
{
#include <adtp.h>
}

NTSTATUS
LsapCleanUpHandles(
    PSession    pSession,
    PVOID       Ignored
    );

NTSTATUS
I_DeleteSession(PSession  pSession);

RTL_CRITICAL_SECTION    csSessionMgr;

#if DBG

ULONG   SessionLock;

#define LockSessions(x)     RtlEnterCriticalSection(&csSessionMgr); SessionLock = x
#define UnlockSessions()    SessionLock = 0; RtlLeaveCriticalSection(&csSessionMgr)

#else

#define LockSessions(x)     RtlEnterCriticalSection(&csSessionMgr)
#define UnlockSessions()    RtlLeaveCriticalSection(&csSessionMgr)

#endif

#define SM_ICREATE      1
#define SM_DELETE       2
#define SM_ADDRUNDOWN   3
#define SM_DELRUNDOWN   4
#define SM_ADDHANDLE    5
#define SM_DELHANDLE    6
#define SM_VALIDHANDLE  7
#define SM_CLONE        9
#define SM_CLEANUP      10
#define SM_FINDEFS      11
#define SM_UPDATEEFS    12
#define SM_ADDCONNECT   13


PSession    pDefaultSession;
PSession    pEfsSession ;

LIST_ENTRY  SessionList ;
LIST_ENTRY  SessionConnectList ;


VOID
LsapContextRundown(
    PSecHandle phContext,
    PVOID Context,
    ULONG RefCount
    );

VOID
LsapCredentialRundown(
    PSecHandle phCreds,
    PVOID Context,
    ULONG RefCount
    );

//+-------------------------------------------------------------------------
//
//  Function:   InitSessionManager()
//
//  Synopsis:   Initializes whatever is needed to track sessions
//
//  Effects:    csSessionMgr, psSessionList;
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    TRUE if success, FALSE otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL
InitSessionManager(void)
{
    NTSTATUS    scRet = STATUS_SUCCESS;
    PSession    pSession;
    Session     sSess;

    //
    // Fake a session during init:
    //


    SetCurrentPackageId( SPMGR_ID );

    SetCurrentSession( &sSess );

    scRet = RtlInitializeCriticalSection(&csSessionMgr);

    if (FAILED(scRet))
    {
        return(FALSE);
    }

    SmallHandlePackage.Initialize();
    LargeHandlePackage.Initialize();

    InitializeListHead( &SessionList );

    InitializeListHead( &SessionConnectList );

    scRet = CreateSession(
                &NtCurrentTeb()->ClientId,
                FALSE,
                LSA_PROCESS_NAME,
                0,                      // no flags
                &pSession
                );

    if (FAILED(scRet))
    {
        return(FALSE);
    }

    pSession->fSession |= SESFLAG_DEFAULT | SESFLAG_TCB_PRIV ;

    pDefaultSession = pSession;

    SetCurrentSession( pSession );

    return(TRUE);
}

VOID
LsapFindEfsSession(
    VOID
    )
{
    PLIST_ENTRY Scan ;
    PSession pSession ;

    LockSessions( SM_FINDEFS );

    Scan = SessionList.Flink ;

    while ( Scan != &SessionList )
    {
        pSession = CONTAINING_RECORD( Scan, Session, List );

        if ( (pSession->dwProcessID == pDefaultSession->dwProcessID) &&
             ((pSession->fSession & SESFLAG_KERNEL) != 0 ) )
        {
            pEfsSession = pSession ;
            break;
        }

        Scan = Scan->Flink ;
    }

    UnlockSessions();

    if ( !pEfsSession )
    {
        DebugLog(( DEB_ERROR, "EFS Session not found\n" ));
    }

}


VOID
LsapUpdateEfsSession(
    PSession pSession
    )
{
    if ( !pEfsSession )
    {
        return ;
    }

    LockSessions( SM_UPDATEEFS );
    LockSession( pSession );
    LockSession( pEfsSession );

    pEfsSession->SharedData = pSession->SharedData ;
    pSession->SharedData->cRefs++ ;
    pEfsSession->fSession |= SESFLAG_EFS ;

    UnlockSession( pEfsSession );
    UnlockSession( pSession );
    UnlockSessions();

}

//+-------------------------------------------------------------------------
//
//  Function:   CreateSession()
//
//  Synopsis:   Creates a new session.
//
//  Effects:    Session list.
//
//  Arguments:  fOpenImmediate - TRUE indicates the process should be opened
//
//              ppSession - receives a pointer to the session.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateSession(  CLIENT_ID * pClientId,
                BOOL        fOpenImmediate,
                PWCHAR      ClientProcessName,
                ULONG       Flags,
                PSession *  ppSession)
{
    NTSTATUS     scRet = STATUS_SUCCESS;
    PSession    pSession;
    LPWSTR      ClientName;
    PLIST_ENTRY Scan ;
    PLSAP_SESSION_CONNECT Connect ;
    ULONG ConnectType = 0 ;

    DebugLog(( DEB_TRACE, "Creating session for [%x.%x]\n",
                    pClientId->UniqueProcess, pClientId->UniqueThread ));

    *ppSession = NULL;

    if ( *ClientProcessName )
    {
        ConnectType |= SESSION_CONNECT_TRUSTED ;

        ClientName = (LPWSTR) LsapAllocatePrivateHeap(
                                    (wcslen(ClientProcessName)+1) * sizeof(WCHAR));

        if (ClientName == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        wcscpy(ClientName,ClientProcessName);
    }
    else
    {
        ConnectType |= SESSION_CONNECT_UNTRUSTED ;

        ClientName = NULL;
    }


    pSession = (PSession) LsapAllocatePrivateHeap( sizeof( Session ) );
    if (!pSession)
    {
        *ppSession = NULL;
        if( ClientName != NULL )
        {
            LsapFreePrivateHeap( ClientName );
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(pSession, sizeof(Session));

    //
    // Initialize stuff:
    //

    pSession->fSession = Flags;

    //
    // we check for this much later, after some same initializing
    // steps, so we can use the common cleanup
    //

    scRet = RtlInitializeCriticalSection( &pSession->SessionLock );

    InitializeListHead( &pSession->SectionList );
    InitializeListHead( &pSession->RundownList );

    pSession->ClientProcessName = ClientName;
    pSession->dwProcessID   = HandleToUlong(pClientId->UniqueProcess);

    //
    // Store the handle cleanup as a rundown function
    //

    if ( NT_SUCCESS( scRet ) )
    {
        if ( !AddRundown( pSession,
                          LsapCleanUpHandles,
                          NULL ) )
        {
            scRet = STATUS_NO_MEMORY ;
        }
    }

    //
    // Lock the sessions now so we know that no new kernel sessions
    // will be created
    //

    LockSessions(SM_ICREATE);

    //
    // Add the session to the list
    //

    InsertTailList( &SessionList, &pSession->List );

    //
    // *Now* check if we're doing ok:
    //

    if ( !NT_SUCCESS( scRet ))
    {
        UnlockSessions();

        goto Cleanup;
    }

    //
    // If the caller is from kernel mode, look for an existing kernel
    // session to use the handle list from.
    //

    if ((Flags & SESFLAG_MAYBEKERNEL) != 0)
    {
        PSession pTrace = NULL;

        //
        // Find a kernel-mode session and use its handle list.  Make sure
        // it's not the default LSA session, although it is ok to use the
        // session tagged as the EFS one.  This will keep the EFS session
        // and the (primary) rdr session in sync.
        //

        Scan = SessionList.Flink ;

        while ( Scan != &SessionList )
        {
            pTrace = CONTAINING_RECORD( Scan, Session, List );

            if ( pTrace != pSession )
            {
                if ( ( (pTrace->fSession & SESFLAG_KERNEL) != 0 ) &&
                   ( ( (pTrace->fSession & SESFLAG_EFS) != 0 ) ||
                     ( pTrace->dwProcessID != pDefaultSession->dwProcessID ) ) )
                {
                    break;
                }
            }

            pTrace = NULL ;

            Scan = Scan->Flink ;

        }

        //
        // If we found a session, use its handle list and queue
        //

        if (pTrace != NULL)
        {
            pTrace->SharedData->cRefs++;
            pSession->SharedData = pTrace->SharedData;
            DebugLog(( DEB_TRACE, "Linking session %p to %p\n",
                       pSession, pTrace ));
        }

        //
        // ConnectType is not definite, it is a hint to others
        // watching for new sessions
        //

        ConnectType |= SESSION_CONNECT_KERNEL ;
    }

    //
    // If we don't have a handle list yet, create one and set it to NULL
    //

    if (pSession->SharedData == NULL)
    {
        if ( pSession->fSession & SESFLAG_MAYBEKERNEL )
        {
            pSession->SharedData = (PLSAP_SHARED_SESSION_DATA) LsapAllocatePrivateHeap(
                                        sizeof( LSAP_SHARED_SESSION_DATA ) );
        }
        else
        {
            pSession->SharedData = &pSession->DefaultData ;
        }

        if ( pSession->SharedData )
        {

            RtlZeroMemory(
                    pSession->SharedData,
                    sizeof( LSAP_SHARED_SESSION_DATA ) );

            //
            // Create Handle Tables:
            //

            pSession->SharedData->CredHandlePackage = &SmallHandlePackage ;
            pSession->SharedData->ContextHandlePackage = &LargeHandlePackage ;

            pSession->SharedData->CredTable = pSession->SharedData->CredHandlePackage->Create(
                                HANDLE_PACKAGE_CALLBACK_ON_DELETE,
                                NULL,
                                LsapCredentialRundown );

            pSession->SharedData->ContextTable = pSession->SharedData->ContextHandlePackage->Create(
                                HANDLE_PACKAGE_CALLBACK_ON_DELETE,
                                NULL,
                                LsapContextRundown );

            if ((pSession->SharedData->CredTable == NULL) || (pSession->SharedData->ContextTable == NULL))
            {
                scRet = STATUS_INSUFFICIENT_RESOURCES;
            }

            pSession->SharedData->cRefs = 1;
        }
        else
        {
            scRet = STATUS_INSUFFICIENT_RESOURCES ;
        }

    }

    UnlockSessions();

    //
    // Check for callbacks when a client connects.  Note, this does
    // not need to be under the session list lock, because it is
    // sufficient that no client is using the session until the
    // callbacks are complete. Since the connection attempt is
    // stalled until this returns, that requirement is met.
    //

    Scan = SessionConnectList.Flink ;
    while ( Scan != &SessionConnectList )
    {
        Connect = CONTAINING_RECORD( Scan, LSAP_SESSION_CONNECT, List );

        if ( Connect->ConnectFilter & ConnectType )
        {
            Connect->Callback( pSession, Connect->Parameter );
        }

        Scan = Scan->Flink ;
    }


    *ppSession = pSession ;

    if (fOpenImmediate & (NT_SUCCESS(scRet)))
    {
        scRet = LsapOpenCaller(pSession);
    }

    //
    // If we failed somewhere, cleanup now.
    //

Cleanup:

    if (!NT_SUCCESS(scRet))
    {
        I_DeleteSession(pSession);
        *ppSession = NULL;
    }
    return(scRet);


}



//+---------------------------------------------------------------------------
//
//  Function:   CloneSession
//
//  Synopsis:   Temporary copy of a session for scavenger threads
//
//  Arguments:  [pOriginalSession] --
//              [ppSession]        --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
CloneSession(
    PSession    pOriginalSession,
    PSession *  ppSession,
    ULONG       Flags )
{
    PSession    pSession;
    NTSTATUS    Status ;
    BOOL        LockInitialized = FALSE ;

    pSession = (PSession) LsapAllocatePrivateHeap( sizeof( Session ) );

    if ( !pSession )
    {
        *ppSession = NULL ;

        return STATUS_NO_MEMORY ;
    }

    //
    // Make sure there is no one else mucking with general session stuff
    //

    LockSessions(SM_CLONE);

    Status = STATUS_SUCCESS ;

    //
    // Copy all the interesting bits
    //

    CopyMemory(pSession, pOriginalSession, sizeof(Session));

    //
    // Make sure it has its own critical section
    //

    Status = RtlInitializeCriticalSection( &pSession->SessionLock );

    if ( NT_SUCCESS( Status ) )
    {
        LockInitialized = TRUE ;
    }

    //
    // note that it is a clone
    //

    pSession->fSession |= ( SESFLAG_CLONE | Flags );

    //
    // Initialize our own rundown list.
    //

    InitializeListHead( &pSession->RundownList );

    //
    // Use our own rundown
    //

    if ( AddRundown( pSession, LsapCleanUpHandles, NULL ) )
    {
        pOriginalSession->SharedData->cRefs++;
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    UnlockSessions();

    if ( !NT_SUCCESS( Status ) )
    {

        if ( LockInitialized )
        {
            RtlDeleteCriticalSection( &pSession->SessionLock );
        }
        LsapFreePrivateHeap( pSession );

        *ppSession = NULL ;

        return Status ;
    }

    //
    // Set the reference count of the clone to -1, so that the a single
    // ref/deref will kill it.
    //

    pSession->RefCount = -1;

    //
    // Clones do *NOT* get added to the session list.
    //

    *ppSession = pSession;

    return(STATUS_SUCCESS);
}

NTSTATUS
CreateShadowSession(
    DWORD ProcessId,
    PSession * NewSession
    )
{
    NTSTATUS Status ;
    CLIENT_ID ClientId;
    PSession Session ;


    ClientId.UniqueProcess = (HANDLE) LongToHandle(ProcessId) ;
    ClientId.UniqueThread = NULL ;

    Status = CreateSession(
                &ClientId,
                FALSE,
                L"",
                SESFLAG_SHADOW,
                &Session );

    *NewSession = Session ;

    return Status ;

}


VOID
WINAPI
LsapDeleteContextWrap(
    PSecHandle  Handle,
    PVOID Context,
    ULONG RefCount
    )
{
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    CallInfo->CallInfo.CallCount = RefCount ;

    WLsaDeleteContext( Handle );

    CallInfo->CallInfo.CallCount = 0 ;
}

VOID
WINAPI
LsapFreeCredWrap(
    PSecHandle  Handle,
    PVOID Context,
    ULONG RefCount
    )
{
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    CallInfo->CallInfo.CallCount = RefCount ;

    WLsaFreeCredHandle( Handle );

    CallInfo->CallInfo.CallCount = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCleanUpHandles
//
//  Synopsis:   Closes all context and credential handles for a session
//
//  Arguments:  [pSession] --
//              [Ignored]  --
//
//  History:    5-15-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapCleanUpHandles(
    PSession    pSession,
    PVOID       Ignored
    )
{
    NTSTATUS     scRet = STATUS_SUCCESS;
    PSession    pSave;
    ULONG HandleRefs;
    PLIST_ENTRY ListEntry;
    LSA_CALL_INFO CallInfo ;
    HANDLE hImp ;


    //
    // If this is the last user of the handle lists, cleanup
    //

    if ( pSession->SharedData == NULL )
    {
        return STATUS_SUCCESS ;
    }

    LockSessions(SM_CLEANUP);

    pSession->SharedData->cRefs--;
    HandleRefs = pSession->SharedData->cRefs;

    UnlockSessions();

    if (HandleRefs == 0)
    {

        LsapInitializeCallInfo( &CallInfo,
                                FALSE );

        CallInfo.CallInfo.Attributes |= SECPKG_CALL_CLEANUP ;

        LsapSetCurrentCall( &CallInfo );

        pSave = GetCurrentSession();

        SetCurrentSession( pSession );


        if (pSession->SharedData->ContextTable != NULL)
        {
            pSession->SharedData->ContextHandlePackage->Delete( pSession->SharedData->ContextTable,
                                                LsapDeleteContextWrap );
        }

        if (pSession->SharedData->CredTable != NULL)
        {
            pSession->SharedData->CredHandlePackage->Delete( pSession->SharedData->CredTable,
                                                LsapFreeCredWrap );
        }

        if ( pSession->fSession & SESFLAG_KERNEL )
        {
            LsapFreePrivateHeap( pSession->SharedData );
        }

        SetCurrentSession( pSave );

        LsapSetCurrentCall( NULL );
    }

    pSession->SharedData = NULL;

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   I_DeleteSession()
//
//  Synopsis:   Deletes the session indicated
//
//  Effects:    Frees memory
//
//  Arguments:  pSession    Session to delete
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
I_DeleteSession(PSession  pSession)
{
    PSession        pTrace;
    PLIST_ENTRY     List ;
    PLSAP_SESSION_RUNDOWN Rundown ;
    int             i;

    DebugLog(( DEB_TRACE, "DeleteSession( %x )\n", pSession ));

    DsysAssertMsg(pSession, "DeleteSession passed null pointer");

    pSession->fSession |= SESFLAG_CLEANUP;


    //
    // Clones aren't in the list, so don't try to unlink it
    //

    if ( ( pSession->fSession & SESFLAG_CLONE ) == 0 )
    {
        LockSessions(SM_DELETE);

        RemoveEntryList( &pSession->List );

        UnlockSessions();
    }

    //
    // Execute the rundown functions
    //

    LockSession( pSession );

    while ( !IsListEmpty( &pSession->RundownList ) )
    {
        List = RemoveHeadList( &pSession->RundownList );

        Rundown = CONTAINING_RECORD( List, LSAP_SESSION_RUNDOWN, List );

        Rundown->Rundown( pSession, Rundown->Parameter );

        LsapFreePrivateHeap( Rundown );
    }

    UnlockSession( pSession );

    RtlDeleteCriticalSection( &pSession->SessionLock );

    if (pSession->fSession & SESFLAG_CLONE)
    {
        //
        // Clones are not part of the global list, and are
        // around just for bookkeepping for scavenger threads
        //

        pSession->dwProcessID = 0xFFFFFFFF;

        LsapFreePrivateHeap( pSession );

        return(STATUS_SUCCESS);
    }

    //
    // Close our handles
    //

    if (pSession->hProcess)
        NtClose(pSession->hProcess);

    if (pSession->hPort)
    {
        NtClose(pSession->hPort);
    }

    pSession->dwProcessID = 0xFFFFFFFF;


    if( pSession->ClientProcessName )
    {
        LsapFreePrivateHeap( pSession->ClientProcessName );
    }

    LsapFreePrivateHeap( pSession );

    return(STATUS_SUCCESS);
}

HRESULT
LsapDeleteWorkQueue(
    PSession pSession,
    PVOID Parameter
    )
{
    if ( pSession->SharedData->pQueue )
    {
        DeleteSubordinateQueue( pSession->SharedData->pQueue, 0 );

        pSession->SharedData->pQueue = NULL ;
    }

    return STATUS_SUCCESS ;

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpReferenceSession
//
//  Synopsis:   Ups the ref count on a session
//
//  Arguments:  [pSession] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpReferenceSession(
    PSession    pSession)
{
    InterlockedIncrement(&pSession->RefCount);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpDereferenceSession
//
//  Synopsis:   Derefs a session.  If the session goes negative, it gets
//              deleted.
//
//  Arguments:  [pSession] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpDereferenceSession(
    PSession    pSession)
{
    LONG RefCount = InterlockedDecrement(&pSession->RefCount);

    if( RefCount < 0 )
    {
        if ( pSession == pDefaultSession )
        {
            pSession->RefCount = 1 ;
        }
        else 
        {
            DsysAssert( (pSession->RefCount == -1) && (RefCount == -1) );
            I_DeleteSession(pSession);
        }
    }
}

VOID
LsapSessionDisconnect(
    PSession    pSession
    )
{
    if ( pSession->SharedData->cRefs == 1 )
    {
        LsapDeleteWorkQueue( pSession, NULL );
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   FreeSession
//
//  Synopsis:   Frees a session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
FreeSession(PSession    pSession)
{
    if (pSession == NULL)
    {
        pSession = GetCurrentSession();
    }

    if (!pSession)
    {
        DebugLog((DEB_ERROR, "FreeSession:  No Session?\n"));
        return;
    }

    TlsSetValue(dwSession, pDefaultSession);
}


//
// Rundown Semantics:
//
// Rundowns allow other functions to be called when a session is closed.  This
// is useful if you need to keep something around as long as a client is
// connected, but need to clean up afterwards.
//
// Rules:  You cannot call back into or reference the client process.  This is
// because the process has already terminated.
//


//+---------------------------------------------------------------------------
//
//  Function:   AddRundown
//
//  Synopsis:   Adds a function to be called when the session is terminated
//
//  Arguments:  [pSession]    --
//              [RundownFn]   --
//              [pvParameter] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
AddRundown(
    PSession            pSession,
    PLSAP_SESSION_RUNDOWN_FN RundownFn,
    PVOID               pvParameter)
{
    PLSAP_SESSION_RUNDOWN Rundown ;

    Rundown = (PLSAP_SESSION_RUNDOWN) LsapAllocatePrivateHeap(
                                        sizeof( LSAP_SESSION_RUNDOWN ) );

    if ( Rundown )
    {
        Rundown->Rundown = RundownFn ;
        Rundown->Parameter = pvParameter ;

        LockSession( pSession );

        InsertTailList( &pSession->RundownList, &Rundown->List );

        UnlockSession( pSession );

        return TRUE ;
    }

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   DelRundown
//
//  Synopsis:   Removes a rundown function from a session
//
//  Arguments:  [pSession]  --
//              [RundownFn] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DelRundown(
    PSession            pSession,
    PLSAP_SESSION_RUNDOWN_FN RundownFn
    )
{
    PLIST_ENTRY Scan;
    PLSAP_SESSION_RUNDOWN Rundown ;

    LockSession( pSession );

    Scan = pSession->RundownList.Flink ;

    Rundown = NULL ;

    while ( Scan != &pSession->RundownList )
    {
        Rundown = (PLSAP_SESSION_RUNDOWN) Scan ;

        if ( Rundown->Rundown == RundownFn )
        {
            RemoveEntryList( &Rundown->List );

            break;
        }

        Rundown = NULL ;

        Scan = Scan->Flink ;
    }

    UnlockSession( pSession );

    if ( Rundown )
    {
        LsapFreePrivateHeap( Rundown );

        return TRUE ;
    }

    return FALSE ;

}

BOOL
AddConnectionHook(
    PLSAP_SESSION_CONNECT_FN ConnectFn,
    PVOID Parameter,
    ULONG Filter
    )
{
    PLSAP_SESSION_CONNECT Connect ;

    Connect = (PLSAP_SESSION_CONNECT) LsapAllocatePrivateHeap( sizeof( LSAP_SESSION_CONNECT ) );

    if ( Connect )
    {
        Connect->Callback = ConnectFn ;
        Connect->ConnectFilter = Filter ;
        Connect->Parameter = Parameter ;

        LockSessions( SM_ADDCONNECT );

        InsertTailList( &SessionConnectList, &Connect->List );

        UnlockSessions();
    }

    return (Connect != NULL) ;
}


VOID
LsapCredentialRundown(
    PSecHandle phCreds,
    PVOID Context,
    ULONG RefCount
    )
{
    PSession pSession = (PSession) Context ;
    NTSTATUS       scRet;
    PLSAP_SECURITY_PACKAGE pPackage;
    PSession Previous ;


    Previous = GetCurrentSession();

    if ( ( ( pSession->fSession & SESFLAG_KERNEL ) != 0 ) &&
         ( ( Previous->fSession & SESFLAG_KERNEL ) != 0 ) )
    {
        NOTHING ;
    }
    else
    {
        SetCurrentSession( pSession );

    }

    DebugLog((DEB_TRACE, "[%x] CredentialRundown (%p:%p) RefCount=%lu\n",
                pSession->dwProcessID, phCreds->dwUpper, phCreds->dwLower, RefCount));

    pPackage = SpmpValidRequest(phCreds->dwLower,
                                SP_ORDINAL_FREECREDHANDLE );

    if (pPackage)
    {
        PLSA_CALL_INFO CallInfo;
        ULONG OldRefCount;

        SetCurrentPackageId(phCreds->dwLower);

        StartCallToPackage( pPackage );

        ASSERT( RefCount );

        CallInfo = LsapGetCurrentCall();
        OldRefCount = CallInfo->CallInfo.CallCount;
        CallInfo->CallInfo.CallCount = RefCount;

        __try
        {
            scRet = pPackage->FunctionTable.FreeCredentialsHandle(
                                                    phCreds->dwUpper);
        }
        __except (SP_EXCEPTION)
        {
            scRet = GetExceptionCode();
            scRet = SPException(scRet, phCreds->dwLower);
        }

        CallInfo->CallInfo.CallCount = OldRefCount;

        EndCallToPackage( pPackage );

        LsapDelPackageHandle( pPackage, FALSE );
    }

    SetCurrentSession( Previous );
}


VOID
LsapContextRundown(
    PSecHandle phContext,
    PVOID Context,
    ULONG RefCount
    )
{
    PSession Session = (PSession) Context;
    PSession Previous ;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PLSA_CALL_INFO CallInfo;
    ULONG OldRefCount;

    NTSTATUS scRet ;


    Previous = GetCurrentSession();

    if ( ( ( Session->fSession & SESFLAG_KERNEL ) != 0 ) &&
         ( ( Previous->fSession & SESFLAG_KERNEL ) != 0 ) )
    {
        NOTHING ;
    }
    else
    {
        SetCurrentSession( Session );

    }


    pspPackage = SpmpValidRequest(  phContext->dwLower,
                                    SP_ORDINAL_DELETECTXT);

    if (! pspPackage )
    {
        DebugLog((DEB_ERROR,"[%x] Invalid request for DeleteContext, package: %d\n",
                    Session->dwProcessID, phContext->dwLower));
        return ;
    }

    DebugLog(( DEB_TRACE, "[%x] ContextRundown(%p:%p)\n",
                    Session->dwProcessID, phContext->dwUpper,
                    phContext->dwLower ));

    SetCurrentPackageId(phContext->dwLower);

    StartCallToPackage( pspPackage );


    //
    // RefCount should ALWAYS be 1 currently, as, the context handle code
    // assumes context handle issue count never exceeds 1.
    //

    ASSERT( RefCount == 1 );

    CallInfo = LsapGetCurrentCall();
    OldRefCount = CallInfo->CallInfo.CallCount;
    CallInfo->CallInfo.CallCount = RefCount;

    __try
    {
        scRet = pspPackage->FunctionTable.DeleteContext( phContext->dwUpper );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException( scRet, pspPackage->dwPackageID);
    }

    CallInfo->CallInfo.CallCount = OldRefCount;
    EndCallToPackage( pspPackage );

#if DBG
    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog((DEB_ERROR, "[%x] package %ws failed DeleteContext with %x\n",
                  Session->dwProcessID,
                  pspPackage->Name.Buffer,
                  scRet ));

    }
#endif

    DebugLog(( DEB_TRACE_WAPI, "[%x] return code %x\n", Session->dwProcessID,
                scRet ));


    SetCurrentPackageId( SPMGR_ID );

    SetCurrentSession( Previous );

    LsapDelPackageHandle( pspPackage, TRUE );

}


//+-------------------------------------------------------------------------
//
//  Function:   AddCredHandle
//
//  Synopsis:   Adds an obtained cred handle to the list for this session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
AddCredHandle(  PSession    pSession,
                PCredHandle phCred,
                ULONG Flags)
{

    if (pSession->fSession & SESFLAG_CLONE)
    {
        DebugLog((DEB_ERROR, "Attempt to add a credhandle to a clone session\n"));
        return FALSE;
    }

    if ( pSession->fSession & SESFLAG_KERNEL )
    {
        pSession = pEfsSession ;
    }

    DebugLog(( DEB_TRACE_HANDLES, "Adding Cred %p : %p to %p\n",
               phCred->dwUpper, phCred->dwLower, pSession ));


    if(pSession->SharedData->CredHandlePackage->AddHandle(
                            pSession->SharedData->CredTable,
                            phCred,
                            pSession,
                            Flags))
    {

        LsapAddPackageHandle( phCred->dwLower, FALSE );
        return TRUE;
    }

    return FALSE;


}

//+---------------------------------------------------------------------------
//
//  Function:   AddContextHandle
//
//  Synopsis:   Adds a context handle to this session
//
//  Arguments:  [phContext] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
AddContextHandle(   PSession    pSession,
                    PCtxtHandle phContext,
                    ULONG Flags)
{
    if (pSession->fSession & SESFLAG_CLONE)
    {
        DebugLog((DEB_ERROR, "Attempt to add a ctxthandle to a clone session\n"));
        return FALSE;
    }


    if ( pSession->fSession & SESFLAG_KERNEL )
    {
        pSession = pEfsSession ;
    }

    DebugLog(( DEB_TRACE_HANDLES, "Adding Context %p : %p to %p\n",
               phContext->dwUpper, phContext->dwLower, pSession ));


    //
    // Find out where this 0:0 handle is coming from:
    //

    DsysAssertMsg( (phContext->dwLower | phContext->dwUpper), "Null context handle added\n");

    if(pSession->SharedData->ContextHandlePackage->AddHandle(
                                        pSession->SharedData->ContextTable,
                                        phContext,
                                        pSession,
                                        Flags
                                        ))
    {
        LsapAddPackageHandle( phContext->dwLower, TRUE );
        return TRUE;
    }

    return FALSE;
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateContextHandle
//
//  Synopsis:   Validate the context handle against the session list
//
//  Arguments:  [pSession]  --
//              [phContext] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
ValidateContextHandle(
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID *     pKey
    )
{

    *pKey = pSession->SharedData->ContextHandlePackage->RefHandle(
                            pSession->SharedData->ContextTable,
                            phContext );

    DebugLog(( DEB_TRACE_HANDLES, "Validate context (%p : %p) for %p returned %p\n",
               phContext->dwUpper, phContext->dwLower,
               pSession, *pKey ));

    if ( *pKey )
    {
        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INVALID_HANDLE ;
    }
}

VOID
DerefContextHandle(
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID       Key OPTIONAL
    )
{
    if ( Key )
    {
#if DBG
        PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) Key ;

        DebugLog(( DEB_TRACE_HANDLES, "Deref context handle by key ( %p : %p ) for %p \n",
                   Entry->Handle.dwUpper, Entry->Handle.dwLower,
                   pSession ));
#endif
        pSession->SharedData->ContextHandlePackage->DerefHandleKey(
                pSession->SharedData->ContextTable,
                Key );

    }
    else
    {
        pSession->SharedData->ContextHandlePackage->DeleteHandle(
                pSession->SharedData->ContextTable,
                phContext,
                0 );

        DebugLog(( DEB_TRACE_HANDLES, "Deref context handle by handle (%p : %p) for %p\n",
                   phContext->dwUpper, phContext->dwLower,
                   pSession ));
    }

}


NTSTATUS
ValidateAndDerefContextHandle(
    PSession pSession,
    PCtxtHandle phContext
    )
{
    DebugLog(( DEB_TRACE_HANDLES, "ValidateAndDeref Context (%p : %p)\n",
                    phContext->dwUpper, phContext->dwLower ));

    if ( pSession->SharedData->ContextHandlePackage->ValidateHandle(
                            pSession->SharedData->ContextTable,
                            phContext,
                            TRUE ) )
    {
        return SEC_E_OK ;
    }

    return SEC_E_INVALID_HANDLE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateCredHandle
//
//  Synopsis:   Validate the context handle against the session list
//
//  Arguments:  [pSession]  --
//              [phCred] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
ValidateCredHandle(
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID *     pKey
    )
{

    *pKey = pSession->SharedData->CredHandlePackage->RefHandle(
                            pSession->SharedData->CredTable,
                            phCred );

    DebugLog(( DEB_TRACE_HANDLES, "Validate cred (%p : %p) for %p returned %p\n",
               phCred->dwUpper, phCred->dwLower,
               pSession, *pKey ));

    if ( *pKey )
    {
        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INVALID_HANDLE ;
    }
}

VOID
DerefCredHandle(
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID       Key OPTIONAL
    )
{
    if ( Key )
    {
#if DBG
        PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) Key ;

        DebugLog(( DEB_TRACE_HANDLES, "Deref cred ( %p : %p ) for %p \n",
                   Entry->Handle.dwUpper, Entry->Handle.dwLower,
                   pSession ));
#endif
        pSession->SharedData->CredHandlePackage->DerefHandleKey(
                pSession->SharedData->CredTable,
                Key );
    }
    else
    {
        pSession->SharedData->CredHandlePackage->DeleteHandle(
                pSession->SharedData->CredTable,
                phCred,
                0 );

        DebugLog(( DEB_TRACE_HANDLES, "Deref cred (%p : %p) for %p\n",
                   phCred->dwUpper, phCred->dwLower,
                   pSession ));
    }
}


NTSTATUS
ValidateAndDerefCredHandle(
    PSession pSession,
    PCtxtHandle phCred
    )
{
    DebugLog(( DEB_TRACE_HANDLES, "ValidateAndDeref Cred (%p : %p)\n",
                    phCred->dwUpper, phCred->dwLower ));

    if ( pSession->SharedData->CredHandlePackage->ValidateHandle(
                            pSession->SharedData->CredTable,
                            phCred,
                            TRUE ) )
    {
        return SEC_E_OK ;
    }

    return SEC_E_INVALID_HANDLE ;
}

BOOL
LsapMoveContextHandle(
    PSecHandle  Handle,
    PSession    OriginatingSession,
    PSession    DestinationSession
    )
{
    BOOL Ret ;

    if ( OriginatingSession->SharedData->ContextHandlePackage->DeleteHandle(
                OriginatingSession->SharedData->ContextTable,
                Handle,
                DELHANDLE_FORCE | DELHANDLE_NO_CALLBACK ) )
    {
        Ret = DestinationSession->SharedData->ContextHandlePackage->AddHandle(
                    DestinationSession->SharedData->ContextTable,
                    Handle,
                    DestinationSession,
                    0 );


    } else {
        Ret = FALSE ;
    }

    return Ret ;
}

BOOL
LsapMoveCredHandle(
    PSecHandle  Handle,
    PSession    OriginatingSession,
    PSession    DestinationSession
    )
{
    BOOL Ret ;

    if ( OriginatingSession->SharedData->CredHandlePackage->DeleteHandle(
                OriginatingSession->SharedData->CredTable,
                Handle,
                DELHANDLE_FORCE | DELHANDLE_NO_CALLBACK ) )
    {
        Ret = DestinationSession->SharedData->CredHandlePackage->AddHandle(
                    DestinationSession->SharedData->CredTable,
                    Handle,
                    DestinationSession,
                    0 );


    } else {
        Ret = FALSE ;
    }

    return Ret ;
}


NTSTATUS
LsapValidLogonProcess(
    IN PVOID Request,
    IN ULONG RequestSize,
    IN PCLIENT_ID ClientId,
    OUT PLUID LogonId,
    OUT PULONG Flags
    )

/*++

Routine Description:

    This function checks to see if a calling process qualifies as a logon
    process.  If so, a logon process context is created for the caller and
    returned.

    A logon process must hold the SeTcbPrivilege privilege.  Since there
    is no way to impersonate a connection requestor (that would be way
    too easy), we have to open the client thread and then open that thread's
    token.


Arguments:

    ClientId - Pointer to the client Id of the sender of the logon
        message.  This is used to locate and open the calling thread or
        process.


Return Value:

    STATUS_SUCCESS - Indicates the caller is a legitimate logon process
        and a logon process context block is being returned.

    any other value - Indicates the caller is NOT a legitimate logon
        process and a logon process context block is NOT being returned.
        The value returned indicates the reason why the client is not
        acceptable.

--*/

{

    NTSTATUS Status, TempStatus;
    BOOLEAN PrivilegeHeld;
    HANDLE ClientThread, ClientProcess, ClientToken;
    PRIVILEGE_SET Privilege;
    OBJECT_ATTRIBUTES NullAttributes;
    UNICODE_STRING Unicode;
    STRING Ansi;
    BOOLEAN Untrusted = FALSE;
    TOKEN_STATISTICS TokenStats;
    PLSAP_AU_REGISTER_CONNECT_INFO_EX ConnectionRequest = (PLSAP_AU_REGISTER_CONNECT_INFO_EX) Request;
    ULONG TokenStatsSize = sizeof(TokenStats);
    LSAP_AU_REGISTER_CONNECT_INFO NullConnectInfo;

    *Flags = 0;


    RtlZeroMemory(
        &NullConnectInfo,
        sizeof(NullConnectInfo)
        );




    //
    // If the connect message is all zeros, setup an untrusted connection.
    //

    if (RtlEqualMemory(
            &NullConnectInfo,
            ConnectionRequest,
            sizeof(NullConnectInfo))) {

        Untrusted = TRUE;
        *Flags |= SESFLAG_UNTRUSTED;
    }



    InitializeObjectAttributes( &NullAttributes, NULL, 0, NULL, NULL );


    //
    // Open the client thread and that thread's token
    //


    Status = NtOpenThread(
                 &ClientThread,
                 THREAD_QUERY_INFORMATION,
                 &NullAttributes,
                 ClientId
                 );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    Status = NtOpenThreadToken(
                 ClientThread,
                 TOKEN_QUERY,
                 TRUE,
                 &ClientToken
                 );

    TempStatus = NtClose( ClientThread );
    DsysAssert( NT_SUCCESS(TempStatus) );

    //
    // Make sure we succeeded in opening the token
    //

    if ( !NT_SUCCESS(Status) ) {
        if ( Status != STATUS_NO_TOKEN ) {
            return Status;

        } else {

            //
            // Open the client process.  This is needed to:
            //
            //         1) Access the client's virtual memory (to copy arguments),
            //         2) Duplicate token handles into the process,
            //         3) Open the process's token to see if it qualifies as
            //            a logon process.
            //

            Status = NtOpenProcess(
                         &ClientProcess,
                         PROCESS_QUERY_INFORMATION |       // To open primary token
                         PROCESS_VM_OPERATION |            // To allocate memory
                         PROCESS_VM_READ |                 // To read memory
                         PROCESS_VM_WRITE |                // To write memory
                         PROCESS_DUP_HANDLE,               // To duplicate a handle into
                         &NullAttributes,
                         ClientId
                         );
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // The thread isn't impersonating...open the process's token.
            //

            Status = NtOpenProcessToken(
                         ClientProcess,
                         TOKEN_QUERY,
                         &ClientToken
                         );


            TempStatus = NtClose( ClientProcess );
            DsysAssert( NT_SUCCESS(TempStatus) );

            //
            // Make sure we succeeded in opening the token
            //

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

        }

    } else {
        *Flags |= SESFLAG_IMPERSONATE;
    }

    //
    // If the caller has the kernel flag set in the LPC message, this is
    // probably a kernel session, but we can't be sure until the first
    // request is made and the LPC_KERNELMODE_MESSAGE flag is set.  The
    // handlers will check that, but until then, set the maybe-flag.
    //

    if (!Untrusted &&
        RequestSize == sizeof( LSAP_AU_REGISTER_CONNECT_INFO_EX) &&
        ((ConnectionRequest->ClientMode & LSAP_AU_KERNEL_CLIENT) != 0) )
    {
        *Flags |= SESFLAG_MAYBEKERNEL;
    }


    //
    // OK, we have a token open
    //

    //
    // Get the logon id.
    //

    Status = NtQueryInformationToken(
                ClientToken,
                TokenStatistics,
                (PVOID) &TokenStats,
                TokenStatsSize,
                &TokenStatsSize
                );
    if (!NT_SUCCESS(Status)) {
        TempStatus = NtClose( ClientToken );
        DsysAssert(NT_SUCCESS(TempStatus));
        return(Status);
    }

    *LogonId = TokenStats.AuthenticationId;

    Status = STATUS_SUCCESS ;

    if (((*Flags) & SESFLAG_MAYBEKERNEL) == 0) {
        //
        // Check for the privilege to execute this service.
        //

        Privilege.PrivilegeCount = 1;
        Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
        Privilege.Privilege[0].Luid = LsapTcbPrivilege;
        Privilege.Privilege[0].Attributes = 0;

        Status = NtPrivilegeCheck(
                     ClientToken,
                     &Privilege,
                     &PrivilegeHeld
                     );
        DsysAssert( NT_SUCCESS(Status) );

        //
        // For untrusted clients who didn't really need TCB anyway don't
        // bother with an audit. If they do have the privilege, by all
        // means audit it.
        //

        if (!Untrusted || PrivilegeHeld) {

            //
            // Generate any necessary audits
            //

            TempStatus = NtPrivilegedServiceAuditAlarm (
                             &LsapLsaAuName,
                             &LsapRegisterLogonServiceName,
                             ClientToken,
                             &Privilege,
                             PrivilegeHeld
                             );
            // DsysAssert( NT_SUCCESS(TempStatus) );


            if ( !PrivilegeHeld ) {

                TempStatus = NtClose( ClientToken );
                DsysAssert( NT_SUCCESS(TempStatus) );

                return STATUS_PRIVILEGE_NOT_HELD;

            }
        }
        if (PrivilegeHeld)
        {
            *Flags |= SESFLAG_TCB_PRIV;
        }
    }

    TempStatus = NtClose( ClientToken );
    DsysAssert( NT_SUCCESS(TempStatus) );

    if (!Untrusted && ((*Flags & SESFLAG_KERNEL) == 0))
    {
        LsapAdtAuditLogonProcessRegistration( ConnectionRequest );
    }
    return(STATUS_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapSetSessionOptions
//
//  Synopsis:   Allows clients to adjust session options
//
//  Arguments:  [Request]  --
//              [Response] --
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapSetSessionOptions(
    ULONG       Request,
    ULONG_PTR    Argument,
    PULONG_PTR   Response
    )
{
    PSession    pSession;
    PLSAP_TASK_QUEUE  pQueue;
    NTSTATUS    Status ;

    pSession = GetCurrentSession();

    DebugLog(( DEB_TRACE, "[%d] SetSession( %d )\n",
                pSession->dwProcessID, Request ));

    Status = STATUS_SUCCESS ;

    LockSession( pSession );

    switch ( Request )
    {
        case SETSESSION_GET_STATUS:
            *Response = 0;
            break;

        case SETSESSION_ADD_WORKQUEUE:
            if ( pSession->SharedData->pQueue == NULL )
            {
                if ( CreateSubordinateQueue( pSession, &GlobalQueue ) )
                {
                    //
                    // If they're going to be that busy, convert the cred list
                    // to be a large table
                    //

                    AddRundown( pSession, LsapDeleteWorkQueue, NULL );

                    pSession->SharedData->CredTable = LhtConvertSmallToLarge(
                                    pSession->SharedData->CredTable );

                    pSession->SharedData->CredHandlePackage = &LargeHandlePackage ;
                }
                else
                {
                    Status = STATUS_UNSUCCESSFUL ;
                }
            }
            break;

        case SETSESSION_REMOVE_WORKQUEUE:
            break;

        case SETSESSION_GET_DISPATCH:
            if ( pSession->dwProcessID == GetCurrentProcessId() )
            {
                Status = InitializeDirectDispatcher();

                if ( NT_SUCCESS( Status ) )
                {
                    DllCallbackHandler = (PLSA_DISPATCH_FN) Argument ;
                    *Response = (ULONG_PTR) DispatchAPIDirect;
                }
            }
            else
            {
                Status = STATUS_ACCESS_DENIED ;
            }
            break;
    }

    UnlockSession( pSession );

    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\scavenge.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scavenge.c
//
//  Contents:   Home of the LSA scavenger thread
//
//  Classes:
//
//  Functions:
//
//  History:    6-08-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#include "scavenge.hxx"

#define SCAV_INTERNAL_NO_TRACE  0x10000000

ULONG                   ScavNotifyCount;

LIST_ENTRY              NotifyList ;
LIST_ENTRY              NotifyEvents ;
LIST_ENTRY              ScavList ;
LIST_ENTRY              PageTouchList ;

RTL_CRITICAL_SECTION    NotifyLock ;
RTL_CRITICAL_SECTION    ScavLock ;
RTL_CRITICAL_SECTION    PageTouchLock ;

HKEY  LsaRegistryKey ;
HANDLE  LsaRegistryWatchEvent ;

#define SCAV_TABLE 8
PVOID                   DeadScavItems[ SCAV_TABLE ];
ULONG                   DeadScavIndex ;

#define SCAVENGER_WAIT_INTERVAL 60000L

//
// Internal flags:
//

#define SCAVFLAG_IN_PROGRESS    0x40000000  // Active
#define SCAVFLAG_ABOUT_TO_DIE   0x20000000  // About to be removed
#define SCAVFLAG_IMMEDIATE      0x08000000  // Immediate Execute
#define SCAVFLAG_STATE_CHANGE   0x04000000  // State Change
#define SCAVFLAG_TRIGGER_FREE   0x02000000  // Trigger will free
#define SCAVFLAG_NOTIFY_EVENT   0x01000000

#define SCAVFLAG_EXECUTE_INLINE 0x00800000  // Execute stub directly
#define SCAVFLAG_ASYNC_TIMER_DELETE 0x00400000

#define NOTIFYFLAG_CHILD_SYNC   0x80000000  // All sub funcs are synchronous
#define NOTIFYFLAG_BLOCK_CALLS  0x40000000  // Block calls

#define NOTIFY_FLAG_SYNCHRONOUS 0x00000001

#if DBG
#define SCAVFLAG_ITEM_BREAK     0x10000000
#endif

//
// Define indices for well known events.  Shutdown is triggered when
// the console handler starts a shutdown.  config is when someone adds
// another notifier.  state is when the state of the machine has changed.
//

#define SCAVENGER_SHUTDOWN_EVENT    0
#define SCAVENGER_CONFIG_EVENT      1
#define SCAVENGER_NOTIFY_EVENT      2

#define LockScavenger() RtlEnterCriticalSection( &ScavLock )
#define UnlockScavenger() RtlLeaveCriticalSection( &ScavLock )

#define LockNotify()    RtlEnterCriticalSection( &NotifyLock )
#define UnlockNotify()  RtlLeaveCriticalSection( &NotifyLock )


//
// Define locking macros for the scav list
//

#define LsapRefScavItem( Item )     \
        {                           \
            RtlEnterCriticalSection( &ScavLock ); \
            ((PLSAP_SCAVENGER_ITEM) Item)->RefCount++ ; \
            RtlLeaveCriticalSection( &ScavLock ); \
        }

#define LsapRefScavItemUnsafe( Item )   \
        {                               \
            ((PLSAP_SCAVENGER_ITEM) Item)->RefCount++ ; \
        }



DWORD
WINAPI
LsapScavengerThread(
    PVOID   Ignored
    );


BOOLEAN         LsapBreakEveryMinute = FALSE;
BOOLEAN         LsapDebuggerOk = FALSE ;

VOID
LsapInternalBreak(
    VOID
    )
{
    PLIST_ENTRY Scan ;
    PLSAP_PAGE_TOUCH Touch ;
    ULONG Sum = 0 ;
    PULONG Address ;
    SIZE_T i ;

    if ( !LsapDebuggerOk )
    {
        return;
        
    }

    RtlEnterCriticalSection( &PageTouchLock );

    Scan = PageTouchList.Flink ;

    while ( Scan != &PageTouchList )
    {
        Touch = CONTAINING_RECORD( Scan, LSAP_PAGE_TOUCH, List );

        Address = (PULONG) Touch->Address ;

        for ( i = 0 ; i < Touch->Range / sizeof( ULONG ) ; i++ )
        {
            Sum += *Address++ ;
        }

        Scan = Scan->Flink ;

    }

    DbgBreakPoint();

    RtlLeaveCriticalSection( &PageTouchLock );
}

VOID
LsaIAddTouchAddress(
    PVOID Address,
    SIZE_T Range
    )
{
    PLSAP_PAGE_TOUCH Touch ;
    PLIST_ENTRY Scan ;
    PLSAP_PAGE_TOUCH Touch2 = NULL ;

    Touch = (PLSAP_PAGE_TOUCH) LsapAllocatePrivateHeap(
                                sizeof( LSAP_PAGE_TOUCH ) );

    if ( !Touch )
    {
        return;
    }

    Touch->Address = Address ;
    Touch->Range = Range ;

    RtlEnterCriticalSection( &PageTouchLock );

    Scan = PageTouchList.Flink ;

    while ( Scan != &PageTouchList )
    {
        Touch2 = CONTAINING_RECORD( Scan, LSAP_PAGE_TOUCH, List );

        if ( Touch2->Address == Touch->Address )
        {
            break;
        }

        Scan = Scan->Flink ;

        Touch2 = NULL ;
    }

    if ( !Touch2 )
    {
        InsertTailList( &PageTouchList, &Touch->List );
    }
    else
    {
        LsapFreePrivateHeap( Touch );
    }

    RtlLeaveCriticalSection( &PageTouchLock );

}

VOID
LsaIRemoveTouchAddress(
    PVOID Address
    )
{
    PLSAP_PAGE_TOUCH Touch = NULL ;
    PLIST_ENTRY Scan ;

    RtlEnterCriticalSection( &PageTouchLock );

    Scan = PageTouchList.Flink ;

    while ( Scan != &PageTouchList )
    {
        Touch = CONTAINING_RECORD( Scan, LSAP_PAGE_TOUCH, List );

        if ( Touch->Address == Address )
        {
            break;
        }

        Scan = Scan->Flink ;

        Touch = NULL ;
    }

    if ( Touch )
    {
        RemoveEntryList( &Touch->List );
    }

    RtlLeaveCriticalSection( &PageTouchLock );

}

ULONG
NTAPI
LsapScavengerBreak(
    PVOID Param
    )
{
    if (LsapBreakEveryMinute)
    {
        LsapInternalBreak();
    }

    HANDLE hToken;
    DWORD ReturnLength;

    TOKEN_STATISTICS TokenStats;

    NTSTATUS Status;

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &hToken
                 );

    if (NT_SUCCESS( Status )) {

        Status = NtQueryInformationToken (
                     hToken,
                     TokenStatistics,
                     &TokenStats,
                     sizeof( TOKEN_STATISTICS ),
                     &ReturnLength
                     );

        if (NT_SUCCESS( Status )) {

            if (TokenStats.ExpirationTime.QuadPart == 0i64) {

                LsapInternalBreak();
            }
        }

        NtClose( hToken );
    }

    return(0);
}



//+---------------------------------------------------------------------------
//
//  Function:   LsapRegistryWatch
//
//  Synopsis:   Callback that handles registry changes in the LSA key
//
//  Arguments:  [Ignored] 
//
//  History:    05-10-00    RichardW
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
LsapRegistryWatch(
    PVOID Ignored
    )
{
    RegNotifyChangeKeyValue(
            LsaRegistryKey,
            TRUE,
            REG_NOTIFY_CHANGE_NAME |
                REG_NOTIFY_CHANGE_LAST_SET,
            LsaRegistryWatchEvent,
            TRUE );

    LsapEventNotify(
        NOTIFY_CLASS_REGISTRY_CHANGE,
        0,
        0,
        NULL );

    return 0 ;

}


//+---------------------------------------------------------------------------
//
//  Function:   LsapDerefScavItem
//
//  Synopsis:   Dereference, optionally freeing a scavenger item
//
//  Arguments:  [Item] --
//
//  History:    6-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapDerefScavItem(
    PLSAP_SCAVENGER_ITEM Item
    )
{
    HANDLE TimerDeleteHandle ;

    LockScavenger();

    Item->RefCount-- ;

    if ( Item->RefCount == 0 )
    {
        DebugLog(( DEB_TRACE_SCAV, "Removing item %x\n", Item ));

        if ( Item->List.Flink )
        {
            RemoveEntryList( &Item->List );

            Item->List.Flink = NULL ;
        }

        if ( Item->PackageList.Flink )
        {
            RemoveEntryList( &Item->PackageList );

            Item->PackageList.Flink = NULL ;
        }

        //
        // Because the rtl thread pool is asynchronous to this one,
        // we need to keep track of recently deceased scavenger items
        // to prevent them from being used in an RTL thread.  The add
        // function will scan the table to remove any potential duplicates.
        //

        DeadScavItems[ DeadScavIndex ] = Item ;
        DeadScavIndex ++ ;
        DeadScavIndex &= (SCAV_TABLE - 1);

        UnlockScavenger();

        if ( Item->Type == NOTIFIER_TYPE_INTERVAL )
        {
            //
            // Kill the timerq handle:
            //

            if ( (Item->Flags & SCAVFLAG_ASYNC_TIMER_DELETE) != 0 )
            {
                TimerDeleteHandle = 0 ;
                
            }
            else
            {

                TimerDeleteHandle = INVALID_HANDLE_VALUE ;
            }

            DeleteTimerQueueTimer( NULL,
                                   Item->TimerHandle,
                                   TimerDeleteHandle );
        }
        else if ( Item->Type == NOTIFIER_TYPE_HANDLE_WAIT )
        {
            UnregisterWaitEx( Item->TimerHandle,
                              INVALID_HANDLE_VALUE );
        }

        if ( ( Item->Type != NOTIFIER_TYPE_NOTIFY_EVENT ) &&
             ( Item->Type != NOTIFIER_TYPE_IMMEDIATE ) )
        {
            //
            // Yield to let the other thread remove the item
            //

            Sleep( 100 );
        }

        Item->ScavCheck = SCAVMAGIC_FREE ;

        LsapFreePrivateHeap( Item );
    }
    else
    {
        UnlockScavenger();
    }


}

//+---------------------------------------------------------------------------
//
//  Function:   LsapScavengerTrigger
//
//  Synopsis:   Actual Trigger
//
//  Arguments:  [Parameter] -- Item to call
//
//  History:    5-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
LsapScavengerTrigger(
    PVOID   Parameter
    )
{
    PLSAP_SCAVENGER_ITEM Item ;
#ifdef LSAP_VERIFY_PACKAGE_ID
    ULONG_PTR dwPackageID, dwCurId;
#endif
    
    if ( ShutdownBegun )
    {
        return 0;
    }

    SetCurrentSession( pDefaultSession );

    Item = (PLSAP_SCAVENGER_ITEM) Parameter ;

    DsysAssert( Item->ScavCheck == SCAVMAGIC_ACTIVE );

    __try
    {
#ifdef LSAP_VERIFY_PACKAGE_ID
        dwPackageID = Item->PackageId;
        dwCurId = GetCurrentPackageId();

        if ((dwCurId != SPMGR_ID) || (dwPackageID != SPMGR_ID))
#endif
        {
            SetCurrentPackageId( Item->PackageId );
        }

        (VOID) Item->Function( Item->Parameter );

#ifdef LSAP_VERIFY_PACKAGE_ID
        if (dwPackageID != SPMGR_ID)
#endif
        {
            SetCurrentPackageId( SPMGR_ID );
        }
    }
    __except( SP_EXCEPTION )
    {
        SPException( GetExceptionCode(), Item->PackageId );
    }

    LsapDerefScavItem( Item );

    return 0 ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapTimerCallback
//
//  Synopsis:   Callback from thread pool for scavenger items
//
//  Arguments:  [Context] --
//              [Timeout] --
//
//  History:    7-01-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapTimerCallback(
    PVOID Context,
    BOOLEAN Timeout
    )
{
    PLSAP_SCAVENGER_ITEM Item ;
    ULONG i ;
    BOOL OneShot ;

    SetCurrentSession( pDefaultSession );

    Item = (PLSAP_SCAVENGER_ITEM) Context ;

    //
    // We only scan for handle and timer events.  Things executed
    // by QueueUserWorkItem don't end up in this list, but that's
    // okay, since those items go directly to LsapScavengerTrigger
    //

    LockScavenger();

    for ( i = 0 ; i < SCAV_TABLE ; i++ )
    {
        if ( DeadScavItems[ i ] == Item )
        {
            break;
        }
    }

    if ( i != SCAV_TABLE )
    {
        //
        // uh oh, a dead one that was still in the queue in this
        // rtl worker thread.  Ignore it.
        //

        UnlockScavenger();

        return ;
    }

    if ( Item->Flags & SCAVFLAG_ASYNC_TIMER_DELETE )
    {
        //
        // This is a bad condition.  An item that should have
        // been fired once has shown up again.  Ignore it.
        //

        UnlockScavenger();

        return;
        
    }

    LsapRefScavItemUnsafe( Item );

    OneShot = ( Item->Flags & NOTIFIER_FLAG_ONE_SHOT ) != 0 ;

    if ( OneShot )
    {
        //
        // This flag has the side effect of preventing further
        // callbacks.  That lets us delete is asynchronously later.
        //

        Item->Flags |= SCAVFLAG_ASYNC_TIMER_DELETE ;
        
    }

    UnlockScavenger();

    if ( (Item->Flags & SCAV_INTERNAL_NO_TRACE ) == 0 )
    {
        DebugLog(( DEB_TRACE_SCAV, "Triggering item %x, type %d\n",
                    Item, Item->Type ));
    }

    LsapScavengerTrigger( Item );

    //
    // If this is a one-shot item that's in the list, then it was
    // a delayed or otherwise "real" one-shot.  Deref it again to 
    // kill it.
    //
    if ( OneShot )
    {
        LsapDerefScavItem( Item );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapScavengerHandleNotify
//
//  Synopsis:   Called whenever a notification event goes off.
//
//  Arguments:  [Ignored] --
//
//  History:    5-23-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
LsapScavengerHandleNotify(
    PVOID Ignored
    )
{
    PLIST_ENTRY NotifyScan ;
    PLIST_ENTRY EventScan ;
    PLSAP_NOTIFY_EVENT Event ;
    PLSAP_SCAVENGER_ITEM Item ;


    do
    {

        LockNotify();

        if ( !IsListEmpty( &NotifyEvents ) )
        {
            EventScan = RemoveHeadList( &NotifyEvents );
        }
        else
        {
            EventScan = NULL ;
        }

        UnlockNotify();

        if ( EventScan )
        {
            Event = CONTAINING_RECORD( EventScan, LSAP_NOTIFY_EVENT, List );

            LockScavenger();

            NotifyScan = NotifyList.Flink ;

            while ( NotifyScan != &NotifyList )
            {
                Item = CONTAINING_RECORD( NotifyScan, LSAP_SCAVENGER_ITEM, List );

                if ( Item->Class == Event->Notify.EventClass )
                {
                    Event->Notify.PackageParameter = Item->Parameter ;

                    Item->Function( &Event->Notify );
                }

                NotifyScan = NotifyScan->Flink ;
            }

            UnlockScavenger();

            if ( Event->Flags & NOTIFY_FLAG_SYNCHRONOUS )
            {
                SetEvent( Event->hSync );
            }

            LsapFreeLsaHeap( Event );
        }

    } while ( EventScan );

    return 0 ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaIRegisterNotification
//
//  Synopsis:   Registers a callback, to be called on either a handle signalled,
//              or an time based interval, or special async events
//
//  Arguments:  [pFunction]   -- Callback function
//              [pvParameter] -- Parameter to pass
//              [Type]        -- Type of callback
//              [Class]       -- Event class
//              [fItem]       -- Flags
//              [Interval]    -- Interval to call
//              [hEvent]      -- Handle to wait on
//
//  History:    6-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
NTAPI
LsaIRegisterNotification(
    IN LPTHREAD_START_ROUTINE pFunction,
    IN PVOID pvParameter,
    IN ULONG Type,
    IN ULONG Class,
    IN ULONG fItem,
    IN ULONG Interval,
    IN HANDLE hEvent)
{
    PLSAP_SCAVENGER_ITEM Item ;
    PLIST_ENTRY List = NULL ;
    BOOL Success ;
    DWORD DueTime ;
    ULONG i;

    Item = (PLSAP_SCAVENGER_ITEM) LsapAllocatePrivateHeap(
                                    sizeof( LSAP_SCAVENGER_ITEM ) );

    if ( !Item )
    {
        return NULL ;
    }

    Item->List.Flink = NULL ;
    Item->PackageList.Flink = NULL ;

    Item->Type = Type ;
    Item->Function = pFunction ;
    Item->Parameter = pvParameter ;
    Item->RefCount = 1 ;
    Item->PackageId = GetCurrentPackageId();
    Item->ScavCheck = SCAVMAGIC_ACTIVE;
    Item->Flags = fItem ;

    switch ( Type )
    {
        case NOTIFIER_TYPE_IMMEDIATE:

            Item->Flags |= NOTIFIER_FLAG_ONE_SHOT ;

            Success = QueueUserWorkItem( LsapScavengerTrigger,
                                         Item,
                                         FALSE );

            //
            // And that's all.  the item may in fact be freed by now, since the
            // worker thread could have completed.  So, return success now,
            //

            return (Item);

            break;

        case NOTIFIER_TYPE_INTERVAL:

            if ( fItem & NOTIFIER_FLAG_SECONDS )
            {
                Interval *= 60 ;
            }

            Interval *= 1000 ;

            Success = CreateTimerQueueTimer(
                                    &Item->TimerHandle,
                                    NULL,
                                    LsapTimerCallback,
                                    Item,
                                    Interval,
                                    (fItem & NOTIFIER_FLAG_ONE_SHOT ?
                                        0 : Interval ),
                                    0 );
            

            break;

        case NOTIFIER_TYPE_HANDLE_WAIT:

            Item->TimerHandle = RegisterWaitForSingleObjectEx(
                                        hEvent,
                                        LsapTimerCallback,
                                        Item,
                                        INFINITE,
                                        (fItem & NOTIFIER_FLAG_NEW_THREAD ?
                                            0 : WT_EXECUTEINWAITTHREAD ) );

            Success = (Item->TimerHandle != NULL);

            break;


        case NOTIFIER_TYPE_NOTIFY_EVENT:

            Item->Class = Class ;
            Item->Flags |= SCAVFLAG_NOTIFY_EVENT ;

            LockScavenger();

            InsertTailList( &NotifyList, &Item->List );

            UnlockScavenger();

            Success = TRUE ;

            break;

        default:

            Success = FALSE ;

            break;

    }

    if ( !Success )
    {
        LsapFreePrivateHeap( Item );

        return NULL ;
    }

    //
    // Okay, we have set up the item, more or less.  Now, insert it
    // into the list we have selected for it.
    //

    DebugLog(( DEB_TRACE_SCAV, "Created scavenger item %x, type %d\n",
                    Item, Item->Type ));

    if ( (Item->Type != NOTIFIER_TYPE_NOTIFY_EVENT) &&
         (Item->Type != NOTIFIER_TYPE_IMMEDIATE ) )
    {
        LockScavenger();

        InsertTailList( &ScavList, &Item->List );

        //
        // Make sure this pointer doesn't show up in the list of dead ones.
        // this can happen due to heap reuse.
        //

        for ( i = 0 ; i < SCAV_TABLE ; i++ )
        {
            if ( DeadScavItems[ i ] == Item )
            {
                DeadScavItems[ i ] = NULL ;
            }
        }

        UnlockScavenger();
    }

    return Item ;

}


//+---------------------------------------------------------------------------
//
//  Function:   LsaICancelNotification
//
//  Arguments:  [pvScavHandle] --
//
//  History:    5-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaICancelNotification(
    PVOID       pvScavHandle
    )
{
    PLSAP_SCAVENGER_ITEM Item ;

    Item = (PLSAP_SCAVENGER_ITEM) pvScavHandle ;

    if ( Item->ScavCheck != SCAVMAGIC_ACTIVE )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    LsapDerefScavItem( Item );

    return STATUS_SUCCESS ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapEventNotify
//
//  Synopsis:   Notify waiters of a security package event
//
//  Arguments:  [Class]     -- Event Class
//              [Flags]     -- Flags
//              [EventSize] -- Size of event data
//              [EventData] -- ptr to event data
//
//  History:    5-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
NTAPI
LsapEventNotify(
    ULONG       Class,
    ULONG       Flags,
    ULONG       EventSize,
    PVOID       EventData)
{
    PLSAP_NOTIFY_EVENT Event ;
    HANDLE        hEvent = NULL;

    Event = (PLSAP_NOTIFY_EVENT) LsapAllocateLsaHeap( sizeof( LSAP_NOTIFY_EVENT ) + EventSize );
    if (Event)
    {
        Event->Notify.EventClass = Class;
        Event->Notify.EventDataSize = EventSize;
        Event->Notify.EventData = (PUCHAR) ( Event + 1 );

        RtlCopyMemory(  Event->Notify.EventData,
                        EventData,
                        EventSize );

        Event->Flags = Flags;

        if (Flags & NOTIFY_FLAG_SYNCHRONOUS)
        {
            hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

            Event->hSync = hEvent ;

            if (!Event->hSync)
            {
                LsapFreeLsaHeap( Event );
                return(FALSE);
            }

        }
        else
        {
            Event->hSync = NULL ;
        }


        //
        // Insert event into list
        //

        LockNotify();

        InsertTailList( &NotifyEvents, &Event->List );

        UnlockNotify();


        DebugLog((DEB_TRACE_SCAV, "EventNotify( %d ) - Data at %x\n",
                    Class, Event->Notify.EventData ));

        //
        // Wake up the scavenger thread
        //

        SetEvent( hStateChangeEvent );

        //
        // If told to wait, block until scav thread signals the event
        //

        if (Flags & NOTIFY_FLAG_SYNCHRONOUS)
        {
            WaitForSingleObjectEx(  hEvent,
                                    INFINITE,
                                    FALSE );

            CloseHandle( hEvent );

        }

        return( TRUE );

    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapInitializeScavenger
//
//  Synopsis:   Initialize Scavenger,
//
//  Arguments:  (none)
//
//  History:    5-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LsapInitializeScavenger(
    VOID
    )
{
    ULONG i ;
    PVOID hNotify ;
    HANDLE hThread ;
    DWORD tid ;
    DWORD Debugger ;
    DWORD dwSize ;
    DWORD dwType ;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo ;

    //
    // Initialize the lists
    //

    InitializeListHead( &NotifyList );

    InitializeListHead( &NotifyEvents );

    InitializeListHead( &ScavList );

    InitializeListHead( &PageTouchList );


    RtlInitializeCriticalSection( &ScavLock );

    RtlInitializeCriticalSection( &NotifyLock );

    RtlInitializeCriticalSection( &PageTouchLock );

    //
    // Event set whenever there is a notification.
    //

    hStateChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // Create basic entries
    //

    hNotify = LsaIRegisterNotification( LsapScavengerHandleNotify,
                                        0,
                                        NOTIFIER_TYPE_HANDLE_WAIT,
                                        0,
                                        NOTIFIER_FLAG_NEW_THREAD,
                                        0,
                                        hStateChangeEvent );


    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                        0,
                        KEY_READ,
                        &LsaRegistryKey ) == 0 )
    {
        LsaRegistryWatchEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        if ( LsaRegistryWatchEvent )
        {
            hNotify = LsaIRegisterNotification(
                                LsapRegistryWatch,
                                NULL,
                                NOTIFIER_TYPE_HANDLE_WAIT,
                                0,
                                NOTIFIER_FLAG_NEW_THREAD,
                                0,
                                LsaRegistryWatchEvent );

            if ( hNotify )
            {
                //
                // Call it once to start the registry watch
                //
                LsapRegistryWatch( NULL );
            }
            else 
            {
                CloseHandle( LsaRegistryWatchEvent );
            }
        }
        else 
        {
            RegCloseKey( LsaRegistryKey );
        }

    }

    //
    // If we are under a debugger, or a kernel debugger is attached, or the
    // flag is in the registry, turn on the watch thread
    //

    Debugger = 0 ;
    dwSize = sizeof( Debugger );

    RegQueryValueEx( LsaRegistryKey,
                     TEXT("EnableDebugCheck"),
                     0,
                     &dwType,
                     (PBYTE) &Debugger,
                     &dwSize );

    NtQuerySystemInformation(
        SystemKernelDebuggerInformation,
        &KdInfo,
        sizeof( KdInfo ),
        NULL );


    if ( (KdInfo.KernelDebuggerEnabled) || 
         (NtCurrentPeb()->BeingDebugged) ||
         (Debugger != 0 ) )
    {

        LsapDebuggerOk = TRUE ;

        (void) LsaIRegisterNotification(
                        LsapScavengerBreak,
                        NULL,
                        NOTIFIER_TYPE_INTERVAL,
                        0,          // no class
                        SCAV_INTERNAL_NO_TRACE,          // no flags
                        60,         // every minute
                        NULL        // no handle
                        );

    }


    return TRUE ;

}


BOOLEAN
NTAPI
LsaIEventNotify(
    ULONG       Class,
    ULONG       Flags,
    ULONG       EventSize,
    PVOID       EventData)
{
    return LsapEventNotify( Class, Flags, EventSize, EventData );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __PROTOS_H__
#define __PROTOS_H__

BOOL
AddPackageToRegistry(
    PSECURITY_STRING    Package
    );

NTSTATUS
LoadParameters(
    VOID
    );

NTSTATUS
LoadPackage(
    PUNICODE_STRING pName,
    ULONG_PTR dwPackageID,
    PSECPKG_PARAMETERS pParameters
    );

NTSTATUS
LoadOldPackage(
    PUNICODE_STRING pName,
    ULONG_PTR dwPackageID
    );

void
UnloadPackages(
    void
    );


VOID
LsapShutdownInprocDll(
    VOID
    );

BOOL
SpConsoleHandler(
    ULONG dwCtrlType
    );

NTSTATUS
ServerStop(
    void
    );

NTSTATUS
StopRPC(
    void
    );

void
TimeStampToString(
    PTimeStamp,
    PUNICODE_STRING
    );


//
// Control constants for LsapBuildSD
//
#define BUILD_KSEC_SD    0
#define BUILD_LPC_SD     1

NTSTATUS
LsapBuildSD(
    IN ULONG dwType,
    OUT PSECURITY_DESCRIPTOR *ppSD  OPTIONAL
    );

NTSTATUS
StartLpcThread(
    void
    );

NTSTATUS
StopLpcThread(
    void
    );

HANDLE
SpmCreateEvent(
    LPSECURITY_ATTRIBUTES lpsa,
    BOOL fManualReset,
    BOOL fInitialState,
    LPWSTR pszEventName
    );

HANDLE
SpmOpenEvent(
    ACCESS_MASK DesiredAccess,
    BOOL fInherit,
    LPWSTR pszEventName
    );

BOOLEAN
SpmpIsSetupPass( VOID );

BOOLEAN
SpmpIsMiniSetupPass( VOID );


NTSTATUS
SPException(
    NTSTATUS Status,
    ULONG_PTR PackageId
    );


void
ScavengerThread();

BOOL
LsapInitializeScavenger(
    VOID
    );


BOOLEAN
NTAPI
LsapEventNotify(
    ULONG       Class,
    ULONG       Flags,
    ULONG       EventSize,
    PVOID       Event);


BOOL
SpmpInitializePackageControl(
    VOID
    );

BOOL
SpmpLoadDll(
    PWSTR               pszDll,
    PSECPKG_PARAMETERS  pParameters);

BOOL
SpmpLoadAuthPkgDll(
    PWSTR   pszDll);

BOOL
SpmpLoadBuiltinAuthPkg(
    PSECPKG_FUNCTION_TABLE  pTable);

PLSAP_SECURITY_PACKAGE
SpmpValidRequest(
    ULONG_PTR PackageHandle,
    ULONG   ApiCode);

PLSAP_SECURITY_PACKAGE
SpmpValidateHandle(
    ULONG_PTR PackageHandle);

PLSAP_SECURITY_PACKAGE
SpmpLocatePackage(
    ULONG_PTR   PackageId);

PLSAP_SECURITY_PACKAGE
SpmpLookupPackage(
    PUNICODE_STRING    pszPackageName);

PLSAP_SECURITY_PACKAGE
SpmpLookupPackageByRpcId(
    ULONG RpcId);


PLSAP_SECURITY_PACKAGE
SpmpLookupPackageAndRequest(
    PUNICODE_STRING    pszPackageName,
    ULONG               ApiCode);

PLSAP_SECURITY_PACKAGE
SpmpIteratePackages(
    PLSAP_SECURITY_PACKAGE pInitialPackage);

PLSAP_SECURITY_PACKAGE
SpmpIteratePackagesByRequest(
    PLSAP_SECURITY_PACKAGE pInitialPackage,
    ULONG       ApiCode);

ULONG
SpmpCurrentPackageCount(
    VOID);

NTSTATUS
SpmpBootAuthPackage(
    PLSAP_SECURITY_PACKAGE     pPackage);

BOOL
SpmpLoadBuiltin(
    ULONG   Flags,
    PSECPKG_FUNCTION_TABLE  pTable,
    PSECPKG_PARAMETERS  pParameters);

VOID
LsapAddPackageHandle(
    ULONG_PTR PackageId,
    BOOL IsContext
    );

VOID
LsapDelPackageHandle(
    PLSAP_SECURITY_PACKAGE Package,
    BOOL IsContext
    );

BOOL
IsValidApi(ULONG    ApiNum, ULONG_PTR dwPackageId);

BOOL
UnloadPackage(ULONG_PTR dwPackageId);

NTSTATUS
CreateMsvEntry();

NTSTATUS
SpmpInitPolicyFiltering();

void
SpmpCleanupPolicyFiltering();

void
SpmpPurgeEntriesByPackage(ULONG_PTR dwPackageId);

void
InitFastMem(void);

ULONG
RegisterFastMem(ULONG   cBytes);

void *
AllocFastMem(ULONG  FastMemKey);

void
FreeFastMem(ULONG Key, PVOID    pMem);

PVOID
WaitAllocFastMem(ULONG  Key, ULONG Retry);

ULONG
FastMemScavenger(PVOID pvIgnored);


//
// NOTE:  NOT FOR EXPORT TO SECURITY PACKAGES!
//

PVOID
LsapAssignThread(LPTHREAD_START_ROUTINE pFunction,
                PVOID                   pvParameter,
                PSession                pSession,
                BOOLEAN                 fUrgent);

BOOL
CreateSubordinateQueue(
    PSession    pSession,
    PLSAP_TASK_QUEUE  pOriginalQueue);

BOOL
DeleteSubordinateQueue(
    PLSAP_TASK_QUEUE  pQueue,
    ULONG       Flags
    );

#define DELETEQ_SYNC_DRAIN  0x00000001


PKSEC_LSA_MEMORY_HEADER
LsapCreateKsecBuffer(
    SIZE_T InitialSize
    );

PVOID
LsapAllocateFromKsecBuffer(
    PKSEC_LSA_MEMORY_HEADER Header,
    ULONG Size
    );

BOOL
LsapChangeHandle(
    SECHANDLE_OPS   HandleOp,
    PSecHandle  OldHandle,
    PSecHandle  NewHandle
    );

NTSTATUS
LsapChangeBuffer(
    PSecBuffer Old,
    PSecBuffer New
    );

// Worker functions:
NTSTATUS
WLsaEstablishCreds(PUNICODE_STRING, PUNICODE_STRING, ULONG, PBYTE, PCredHandle, PTimeStamp);
NTSTATUS
WLsaLogonUser(PUNICODE_STRING, ULONG, PBYTE, ULONG, ULONG *, PBYTE, NTSTATUS *);
NTSTATUS
WLsaAcquireCredHandle(PUNICODE_STRING, PUNICODE_STRING, ULONG, PLUID, PVOID, PVOID, PVOID, PCredHandle, PTimeStamp);
NTSTATUS
WLsaInitContext(PCredHandle, PCtxtHandle, PUNICODE_STRING, ULONG, ULONG, ULONG, PSecBufferDesc, ULONG, PCtxtHandle, PSecBufferDesc, ULONG *, PTimeStamp, PBOOLEAN, PSecBuffer);
NTSTATUS
WLsaAcceptContext(PCredHandle, PCtxtHandle, PSecBufferDesc, ULONG, ULONG, PCtxtHandle, PSecBufferDesc, ULONG *, PTimeStamp, PBOOLEAN, PSecBuffer);
NTSTATUS
WLsaControlFunction(PUNICODE_STRING, ULONG, PSecBuffer, PSecBuffer);
NTSTATUS
WLsaFreeCredHandle(PCredHandle phCred);
NTSTATUS
WLsaDeleteContext(PCtxtHandle phContext );

NTSTATUS
WLsaGetSecurityUserInfo(PLUID pLogonId, ULONG fFlags, PSecurityUserData * pUserInfo);
NTSTATUS
WLsaSaveSupplementalCredentials(PCredHandle phCred, PSecBuffer pCredentials);
NTSTATUS
WLsaGetSupplementalCredentials(PCredHandle phCred, PSecBuffer pCredentials);
NTSTATUS
WLsaDeleteSupplementalCredentials(PCredHandle phCred, PSecBuffer pKey);

NTSTATUS
WLsaGetBinding( ULONG_PTR            dwPackageID,
                PSEC_PACKAGE_BINDING_INFO   BindingInfo,
                PULONG              TotalSize,
                PWSTR *             Base);

NTSTATUS
WLsaFindPackage(PUNICODE_STRING pssName, PULONG_PTR pulPackageId);
NTSTATUS
WLsaEnumeratePackages(PULONG pcPackages, PSecPkgInfo * ppPackageInfo);
NTSTATUS
WLsaApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput);
NTSTATUS
WLsaQueryPackageInfo(PUNICODE_STRING pssPackageName, PSecPkgInfo  * ppPackageInfo);
NTSTATUS
WLsaDeletePackage(
    PSECURITY_STRING PackageName);

NTSTATUS
WLsaAddPackage(
    PSECURITY_STRING PackageName,
    PSECURITY_PACKAGE_OPTIONS Options);

NTSTATUS
WLsaQueryContextAttributes( PCtxtHandle, ULONG, PVOID );

NTSTATUS
WLsaSetContextAttributes(
    PCtxtHandle phContext,
    ULONG       ulAttribute,
    PVOID       pvBuffer,
    ULONG       cbBuffer
    );

NTSTATUS
WLsaLogonUser2(
    IN PSTRING              pOriginName,
    IN ULONG                AuthPkg,
    IN SECURITY_LOGON_TYPE  LogonType,
    IN PVOID                AuthInfo,
    IN ULONG                AuthInfoLength,
    IN PTOKEN_GROUPS        pTokenGroups,
    IN PTOKEN_SOURCE        pSourceContext,
    IN BOOLEAN              CallLicenseServer,
    OUT PVOID *             ProfileBuffer,
    OUT PULONG              ProfileBufferLength,
    OUT PLUID               LogonId,
    OUT PNTSTATUS           SubStatus,
    OUT PHANDLE             phToken,
    OUT PQUOTA_LIMITS       pQuota
    );



NTSTATUS   WLsaQueryCredAttributes( PCredHandle phCredentials, ULONG ulAttribute, PVOID pBuffer);


NTSTATUS
WLsaAddCredentials(
    PCredHandle     phCredential,
    PSECURITY_STRING    pPrincipal,
    PSECURITY_STRING    pSecPackage,
    DWORD               fCredentialUse,
    PVOID               pvAuthData,
    PVOID               pvGetKeyFn,
    PVOID               pvGetKeyArgument,
    PTimeStamp          ptsExpiry);

NTSTATUS
WLsaEnumerateLogonSession(
    PULONG Count,
    PLUID * Sessions
    );

NTSTATUS
WLsaGetLogonSessionData(
    PLUID LogonId,
    PVOID * LogonData
    );

NTSTATUS
LsapSetSessionOptions(
    ULONG       Request,
    ULONG_PTR    Argument,
    PULONG_PTR   Resonse
    );


LSA_DISPATCH_FN DispatchAPIDirect;
extern PLSA_DISPATCH_FN DllCallbackHandler ;

NTSTATUS
GetRegistryString(HKEY hKey,
                  PWSTR pwszSubKey,
                  PWSTR pwszValue,
                  PWSTR pwszData,
                  PULONG pdwCount);


BOOL
InitializeThreadPool(
    void
    );


NTSTATUS
SpmBuildNtToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID TokenInformation,
    IN PTOKEN_GROUPS LocalGroups,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    OUT PHANDLE Token,
    OUT PSID * UserSid,
    OUT PNTSTATUS SubStatus
    );



BOOLEAN
LsapIsEncryptionPermitted(
    VOID
    );


NTSTATUS
LsapGetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION * Info
    );

NTSTATUS
LsapSetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION Info
    );

#ifdef __cplusplus
extern "C"
#endif
NTSTATUS
LsapDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

#ifdef __cplusplus
extern "C"
#endif
NTSTATUS
LsapDuplicateSid2(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

#ifdef __cplusplus
extern "C"
#endif
PSID
LsapMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

#ifdef __cplusplus
extern "C"
#endif
PSID
LsapMakeDomainRelativeSid2(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

//
// Debug helpers to track down bogus handle use
//

#if DBG > 0
#define SpmSetEvent(hHandle)     ASSERT(SetEvent(hHandle))
#define SpmCloseHandle(hHandle)  ASSERT(CloseHandle(hHandle))
#else
#define SpmSetEvent(hHandle)       SetEvent(hHandle)
#define SpmCloseHandle(hHandle)    CloseHandle(hHandle)
#endif

VOID
InitScavengerControl(VOID);


ULONG
SpmpReportEvent(
    IN BOOL Unicode,
    IN WORD EventType,
    IN ULONG EventId,
    IN ULONG Category,
    IN ULONG SizeOfRawData,
    IN PVOID RawData,
    IN ULONG NumberOfStrings,
    ...
    );

ULONG
SpmpReportEventU(
    IN WORD EventType,
    IN ULONG EventId,
    IN ULONG Category,
    IN ULONG SizeOfRawData,
    IN PVOID RawData,
    IN ULONG NumberOfStrings,
    ...
    );

#endif // __PROTOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\samhooks.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       samhooks.cxx
//
//  Contents:   SAM Hooks for security packages
//
//  Classes:
//
//  Functions:
//
//  History:    3-10-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <lsapch.hxx>

#include <lmcons.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <ntmsv1_0.h>
#include <pac.hxx>
#include "samhooks.hxx"




//+---------------------------------------------------------------------------
//
//  Function:   LsapMakeDomainRelativeSid
//
//  Synopsis:   Build a new SID based on a domain SID and a RID
//
//  Arguments:  [DomainId]   --
//              [RelativeId] --
//
//  History:    3-11-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSID
LsapMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    if ( !DomainId ) {

        return( NULL );
    }

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = LsapAllocateLsaHeap( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        LsapFreeLsaHeap( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}

PSID
LsapMakeDomainRelativeSid2(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    if ( !DomainId ) {

        return( NULL );
    }

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = LsapAllocatePrivateHeap( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        LsapFreePrivateHeap( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) LsapAllocateLsaHeap( SidSize );

    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );

    return(STATUS_SUCCESS);
}

NTSTATUS
LsapDuplicateSid2(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) LsapAllocatePrivateHeap( SidSize );

    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );

    return(STATUS_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCaptureSamInfo
//
//  Synopsis:   Capture current SAM info for building a PAC
//
//  Arguments:  [DomainSid]   -- Returns domain SID
//              [DomainName]  -- returns domain name
//              [MachineName] -- returns current machine name
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapCaptureSamInfo(
    PSID *  DomainSid,
    PUNICODE_STRING DomainName,
    PUNICODE_STRING MachineName
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation = NULL;
    UNICODE_STRING String;
    WCHAR LocalMachineName[ CNLEN + 1 ];
    DWORD Size ;
    PSID Sid ;

    Size = CNLEN + 1;

    if ( GetComputerName( LocalMachineName, &Size ) )
    {
        RtlInitUnicodeString( &String, LocalMachineName );

        Status = LsapDuplicateString( MachineName, &String );
    }
    else
    {
        MachineName->Buffer = (PWSTR) LsapAllocateLsaHeap( Size *
                                            sizeof(WCHAR) + 2 );

        if ( MachineName->Buffer )
        {
            MachineName->MaximumLength = (USHORT) (Size * sizeof(WCHAR) + 2);

            GetComputerName( MachineName->Buffer, &Size );

            MachineName->Length = (USHORT) (Size * sizeof( WCHAR ) );;

            Status = STATUS_SUCCESS ;
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "Failed to get computer name, %x\n", Status ));
        goto Cleanup;
    }

    Status = LsarQueryInformationPolicy(
                LsapPolicyHandle,
                PolicyAccountDomainInformation,
                &PolicyInformation
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to query information policy: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = LsapDuplicateString(
                DomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyAccountDomainInfo.DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Sid = (PSID) LocalAlloc(0, RtlLengthSid(
                        PolicyInformation->PolicyAccountDomainInfo.DomainSid)
                       );

    if ( Sid == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlCopyMemory(
        Sid,
        PolicyInformation->PolicyAccountDomainInfo.DomainSid,
        RtlLengthSid(PolicyInformation->PolicyAccountDomainInfo.DomainSid)
        );

    *DomainSid = Sid ;

Cleanup:
    if (PolicyInformation != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyPrimaryDomainInformation,
                PolicyInformation
                );
    }

    return( Status );

}


//+---------------------------------------------------------------------------
//
//  Function:   LsaOpenSamUser
//
//  Synopsis:   Opens a handle to the SAM user as specified by Name and NameType
//
//  Arguments:  [Name]       -- Name of user to find
//              [NameType]   -- SAM or AlternateId
//              [Prefix]     -- Prefix for AlternateId lookup
//              [AllowGuest] -- Open guest if user not found
//              [Reserved]   --
//              [UserHandle] -- Returned user handle
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaOpenSamUser(
    PSECURITY_STRING Name,
    SECPKG_NAME_TYPE NameType,
    PSECURITY_STRING Prefix,
    BOOLEAN AllowGuest,
    ULONG Reserved,
    PVOID * UserHandle
    )
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED ;
    SECURITY_STRING CombinedName ;
    PSECURITY_STRING EffectiveName ;
    SAMPR_ULONG_ARRAY RelativeIdArray;
    SAMPR_ULONG_ARRAY UseArray;
    UNICODE_STRING TempString;

    RelativeIdArray.Element = NULL;
    UseArray.Element = NULL;



    if ( NameType == SecNameAlternateId )
    {
        if ( !Prefix )
        {
            return STATUS_INVALID_PARAMETER ;
        }

        CombinedName.MaximumLength = Name->Length + Prefix->Length +
                                        2 * sizeof( WCHAR );

        CombinedName.Length = CombinedName.MaximumLength - sizeof( WCHAR );

        CombinedName.Buffer = (PWSTR) LsapAllocateLsaHeap( CombinedName.MaximumLength );


        if ( CombinedName.Buffer )
        {
            CopyMemory( CombinedName.Buffer, Prefix->Buffer, Prefix->Length );

            CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) ] = L':';

            CopyMemory( &CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) + 1],
                        Name->Buffer,
                        Name->Length + sizeof( WCHAR ) );

            EffectiveName = &CombinedName ;

        }
        else
        {
            return SEC_E_INSUFFICIENT_MEMORY ;
        }

    }
    else
    {
        EffectiveName = Name ;
    }

    if ( NameType == SecNameSamCompatible )
    {
        Status = SamrLookupNamesInDomain(
                    LsapAccountDomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) Name,
                    &RelativeIdArray,
                    &UseArray
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to lookup name %wZ in domain: 0x%x\n",
                Name, Status));

            goto CheckGuest ;
        }

        if (UseArray.Element[0] != SidTypeUser)
        {
            Status = STATUS_NO_SUCH_USER;

            goto CheckGuest ;
        }


        Status = SamrOpenUser(
                    LsapAccountDomainHandle,
                    USER_ALL_ACCESS,
                    RelativeIdArray.Element[0],
                    UserHandle
                    );

        SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );
        SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

        RelativeIdArray.Element = NULL;
        UseArray.Element = NULL;


        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to open user by relative ID: 0x%x\n",Status));

            goto CheckGuest ;
        }

    }
    else if ( NameType == SecNameAlternateId )
    {

        Status = SamIOpenUserByAlternateId(
                        LsapAccountDomainHandle,
                        USER_ALL_ACCESS,
                        EffectiveName,
                        UserHandle );

        if ( !NT_SUCCESS( Status ) )
        {
            DebugLog(( DEB_TRACE_SAM, "Failed to find user by alternate id, %x\n", Status ));

            goto CheckGuest ;
        }
    }
    else
    {
        Status = STATUS_NOT_IMPLEMENTED ;

        AllowGuest = FALSE ;
    }

    if ( RelativeIdArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );

        RelativeIdArray.Element = NULL;
    }
    if ( UseArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

        UseArray.Element = NULL;
    }

    if ( EffectiveName == &CombinedName )
    {
        LsapFreeLsaHeap( EffectiveName->Buffer );
    }

    return Status ;

CheckGuest:

    if ( RelativeIdArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );

        RelativeIdArray.Element = NULL;
    }
    if ( UseArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

        UseArray.Element = NULL;
    }

    if ( AllowGuest )
    {
        Status = SamrOpenUser(
                        LsapAccountDomainHandle,
                        USER_ALL_ACCESS,
                        DOMAIN_USER_RID_GUEST,
                        UserHandle );
    }

    if ( EffectiveName == &CombinedName )
    {
        LsapFreeLsaHeap( EffectiveName->Buffer );
    }


    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaCloseSamUser
//
//  Synopsis:   Close a SAM user opened by LsaOpenSamUser
//
//  Arguments:  [UserHandle] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaCloseSamUser(
    PVOID UserHandle
    )
{
     return SamrCloseHandle( &((SAMPR_HANDLE) UserHandle) );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaGetUserCredentials
//
//  Synopsis:   Pull the creds for the user
//
//  Arguments:  [UserHandle]            --
//              [PrimaryCreds]          --
//              [PrimaryCredsSize]      --
//              [SupplementalCreds]     --
//              [SupplementalCredsSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaGetUserCredentials(
    PVOID UserHandle,
    PVOID * PrimaryCreds,
    PULONG PrimaryCredsSize,
    PVOID * SupplementalCreds,
    PULONG SupplementalCredsSize
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS
NTAPI
LsaGetUserAuthData(
    PVOID UserHandle,
    PUCHAR * UserAuthData,
    PULONG UserAuthDataSize
    )
{
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL ;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL ;
    NTSTATUS Status ;
    PPACTYPE pNewPac = NULL ;
    PSAMPR_GET_GROUPS_BUFFER GroupsBuffer = NULL ;
    PPACTYPE Pac ;
    UNICODE_STRING Domain ;
    UNICODE_STRING Machine ;
    PSID Sid ;

    Sid = NULL ;
    Machine.Buffer = NULL ;
    Domain.Buffer = NULL ;

    *UserAuthData = NULL ;

    Status = SamrQueryInformationUser(
                    (SAMPR_HANDLE) UserHandle,
                    UserAllInformation,
                    &UserAllInfo );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

    UserAll = &UserAllInfo->All ;

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED )
    {
        Status = STATUS_ACCOUNT_DISABLED ;

        goto GetPac_Cleanup;
    }

    Status = SamrGetGroupsForUser(
                    (SAMPR_HANDLE) UserHandle,
                    &GroupsBuffer );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = LsapCaptureSamInfo( &Sid, &Domain, &Machine );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = PAC_Init( UserAll,
                       GroupsBuffer,
                       NULL,            // no extra groups
                       Sid,
                       &Domain,
                       &Machine,
                       0,               // no signature
                       0,               // no additional data
                       NULL,            // no additional data
                       &Pac );


    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    *UserAuthDataSize = PAC_GetSize( Pac );

    *UserAuthData = (PUCHAR) LsapAllocateLsaHeap( *UserAuthDataSize );

    if ( *UserAuthData )
    {
       PAC_Marshal( Pac, *UserAuthDataSize, *UserAuthData );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    MIDL_user_free( Pac );

GetPac_Cleanup:

    if ( UserAllInfo )
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if ( GroupsBuffer )
    {
        SamIFree_SAMPR_GET_GROUPS_BUFFER( GroupsBuffer );
    }
    if ( Sid )
    {
        LsapFreeLsaHeap( Sid );
    }

    if ( Domain.Buffer )
    {
        LsapFreeLsaHeap( Domain.Buffer );
    }

    if ( Machine.Buffer )
    {
        LsapFreeLsaHeap( Machine.Buffer );
    }

    return( Status );

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapMakeTokenInformationV1
//
//  Synopsis:   This routine makes copies of all the pertinent
//              information from the UserInfo and generates a
//              LSA_TOKEN_INFORMATION_V1 data structure.
//
//  Effects:
//
//  Arguments:
//
//    UserInfo - Contains the validation information which is
//        to be copied into the TokenInformation.
//
//    TokenInformation - Returns a pointer to a properly Version 1 token
//        information structures.  The structure and individual fields are
//        allocated properly as described in ntlsa.h.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates the service completed successfully.
//
//              STATUS_INSUFFICIENT_RESOURCES -  This error indicates that
//                      the logon could not be completed because the client
//                      does not have sufficient quota to allocate the return
//                      buffer.
//
//  Notes:      stolen from kerberos\client2\krbtoken.cxx, where it was
//              stolen from msv1_0\nlp.c:NlpMakeTokenInformationV1
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapMakeTokenInformationV1(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    OUT PLSA_TOKEN_INFORMATION_V1 *TokenInformation
    )
{
    NTSTATUS Status;
    PLSA_TOKEN_INFORMATION_V1 V1;
    ULONG Size, i;



    //
    // Allocate the structure itself
    //

    Size = (ULONG)sizeof(LSA_TOKEN_INFORMATION_V1);
    V1 = (PLSA_TOKEN_INFORMATION_V1) LsapAllocateLsaHeap( Size );
    if ( V1 == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        V1,
        Size
        );

    V1->User.User.Sid = NULL;
    V1->Groups = NULL;
    V1->PrimaryGroup.PrimaryGroup = NULL;
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime, V1->ExpirationTime );


    //
    // Make a copy of the user SID (a required field)
    //

    V1->User.User.Attributes = 0;

    //
    // Allocate an array to hold the groups
    //

    Size = ( (ULONG)sizeof(TOKEN_GROUPS)
       + (UserInfo->GroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES))
       - (ANYSIZE_ARRAY * (ULONG)sizeof(SID_AND_ATTRIBUTES))
           );

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        Size += UserInfo->SidCount * (ULONG)sizeof(SID_AND_ATTRIBUTES);
    }

    //
    // If there are resource groups, add space for them
    //
    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {
        Size += UserInfo->ResourceGroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES);

        if ((UserInfo->ResourceGroupCount != 0) &&
            ((UserInfo->ResourceGroupIds == NULL) ||
             (UserInfo->ResourceGroupDomainSid == NULL)))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }



    V1->Groups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( Size );

    if ( V1->Groups == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        V1->Groups,
        Size
        );

    V1->Groups->GroupCount = 0;

    //
    // Start copying SIDs into the structure
    //



    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {
        V1->User.User.Sid =
                LsapMakeDomainRelativeSid( UserInfo->LogonDomainId,
                                          UserInfo->UserId );

        if( V1->User.User.Sid == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

    }

    //
    // Make a copy of the primary group (a required field).
    //


    V1->PrimaryGroup.PrimaryGroup = LsapMakeDomainRelativeSid(
                                            UserInfo->LogonDomainId,
                                            UserInfo->PrimaryGroupId );

    if ( V1->PrimaryGroup.PrimaryGroup == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }





    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        V1->Groups->Groups[V1->Groups->GroupCount].Attributes = UserInfo->GroupIds[i].Attributes;

        V1->Groups->Groups[V1->Groups->GroupCount].Sid = LsapMakeDomainRelativeSid2(
                                         UserInfo->LogonDomainId,
                                         UserInfo->GroupIds[i].RelativeId );

        if( V1->Groups->Groups[V1->Groups->GroupCount].Sid == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        V1->Groups->GroupCount++;
    }


    //
    // Add in the extra SIDs
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        ULONG index = 0;
        //
        // If the user SID wasn't passed as a RID, it is the first
        // SID.
        //

        if ( !V1->User.User.Sid ) {
            if ( UserInfo->SidCount <= index ) {

                Status = STATUS_INSUFFICIENT_LOGON_INFO;
                goto Cleanup;
            }
            Status = LsapDuplicateSid(
                        &V1->User.User.Sid,
                        UserInfo->ExtraSids[index].Sid
                        );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            index++;
        }

        //
        // Copy over all additional SIDs as groups.
        //

        for ( ; index < UserInfo->SidCount; index++ ) {

            V1->Groups->Groups[V1->Groups->GroupCount].Attributes =
                UserInfo->ExtraSids[index].Attributes;

            Status = LsapDuplicateSid2(
                        &V1->Groups->Groups[V1->Groups->GroupCount].Sid,
                        UserInfo->ExtraSids[index].Sid
                        );
            if (!NT_SUCCESS(Status) ) {
                goto Cleanup;
            }


            V1->Groups->GroupCount++;
        }
    }

    //
    // Check to see if any resouce groups exist
    //

    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {


        for ( i=0; i < UserInfo->ResourceGroupCount; i++ ) {

            V1->Groups->Groups[V1->Groups->GroupCount].Attributes = UserInfo->ResourceGroupIds[i].Attributes;

            V1->Groups->Groups[V1->Groups->GroupCount].Sid = LsapMakeDomainRelativeSid2(
                                             UserInfo->ResourceGroupDomainSid,
                                             UserInfo->ResourceGroupIds[i].RelativeId );

            if( V1->Groups->Groups[V1->Groups->GroupCount].Sid == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            V1->Groups->GroupCount++;
        }
    }

    if (!V1->User.User.Sid) {

        Status = STATUS_INSUFFICIENT_LOGON_INFO;
        goto Cleanup;
    }

    //
    // There are no default privileges supplied.
    // We don't have an explicit owner SID.
    // There is no default DACL.
    //

    V1->Privileges = NULL;
    V1->Owner.Owner = NULL;
    V1->DefaultDacl.DefaultDacl = NULL;

    //
    // Return the Validation Information to the caller.
    //

    *TokenInformation = V1;
    return STATUS_SUCCESS;

    //
    // Deallocate any memory we've allocated
    //

Cleanup:
    if ( V1->User.User.Sid != NULL ) {
        LsapFreeLsaHeap( V1->User.User.Sid );
    }

    if ( V1->Groups != NULL ) {
        LsapFreeTokenGroups( V1->Groups );
    }

    if ( V1->PrimaryGroup.PrimaryGroup != NULL ) {
        LsapFreeLsaHeap( V1->PrimaryGroup.PrimaryGroup );
    }

    LsapFreeLsaHeap( V1 );

    return Status;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaFreeTokenInfo
//
//  Synopsis:   Frees a TokenInformation structure that was allocated by
//              the LSA
//
//  Arguments:  [TokenInfoType]    --
//              [TokenInformation] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaFreeTokenInfo(
    LSA_TOKEN_INFORMATION_TYPE TokenInfoType,
    PVOID TokenInformation
    )
{

    switch (TokenInfoType) {

        case LsaTokenInformationNull:

            LsapFreeTokenInformationNull( (PLSA_TOKEN_INFORMATION_NULL) TokenInformation );
            break;

        case LsaTokenInformationV1:

            LsapFreeTokenInformationV1( (PLSA_TOKEN_INFORMATION_V1) TokenInformation );
            break;

        case LsaTokenInformationV2:

            LsapFreeTokenInformationV2( (PLSA_TOKEN_INFORMATION_V2) TokenInformation );
            break;

    }
    return STATUS_SUCCESS ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaConvertAuthDataToToken
//
//  Synopsis:   Convert an opaque PAC structure into a token.
//
//  Arguments:  [UserAuthData]         --
//              [UserAuthDataSize]     --
//              [TokenInformation]     --
//              [TokenInformationType] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaConvertAuthDataToToken(
    IN PVOID UserAuthData,
    IN ULONG UserAuthDataSize,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AuthorityName,
    OUT PHANDLE TokenHandle,
    OUT PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PNTSTATUS SubStatus
    )
{
    NTSTATUS Status ;
    PPACTYPE Pac = NULL ;
    PPAC_INFO_BUFFER LogonInfo = NULL ;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL ;
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL ;


    LogonId->HighPart = LogonId->LowPart = 0;
    *TokenHandle = NULL;
    RtlInitUnicodeString(
        AccountName,
        NULL
        );
    *SubStatus = STATUS_SUCCESS;

    Pac = (PPACTYPE) UserAuthData ;

    if ( PAC_UnMarshal( Pac, UserAuthDataSize ) == 0 )
    {
        DebugLog(( DEB_ERROR, "Failed to unmarshall pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto CreateToken_Cleanup ;
    }

    LogonInfo = PAC_Find( Pac, PAC_LOGON_INFO, NULL );

    if ( !LogonInfo )
    {
        DebugLog(( DEB_ERROR, "Failed to find logon info in pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto CreateToken_Cleanup ;
    }


    Status = PAC_UnmarshallValidationInfo(
                &ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x\n",
            Status));

        goto CreateToken_Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V1 from the validation
    // information
    //

    Status = LsapMakeTokenInformationV1(
                ValidationInfo,
                &TokenInfo
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to make token informatin v1: 0x%x\n",
            Status));
        goto CreateToken_Cleanup;
    }

    //
    // Now, copy the user name.
    //

    Status = LsapDuplicateString( AccountName, &ValidationInfo->EffectiveName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreateToken_Cleanup ;
    }

    //
    // Now create a logon session
    //

    Status = LsapCreateLogonSession( LogonId );
    if (!NT_SUCCESS(Status))
    {
        goto CreateToken_Cleanup;
    }

    //
    // Now create the token
    //

    Status = LsapCreateToken(
                LogonId,
                TokenSource,
                LogonType,
                ImpersonationLevel,
                LsaTokenInformationV1,
                TokenInfo,
                NULL,                   // no token groups
                AccountName,
                AuthorityName,
                NULL,
                &ValidationInfo->ProfilePath,
                TokenHandle,
                SubStatus
                );

    //
    // NULL out the TokenInfo pointer.  LsapCreateToken will
    // free the memory under all conditions
    //

    TokenInfo = NULL ;

    if (!NT_SUCCESS(Status))
    {
        goto CreateToken_Cleanup;
    }

    //
    // We don't need to free the token information because CreateToken does
    // that for us.
    //


    MIDL_user_free(ValidationInfo);
    return Status ;

CreateToken_Cleanup:

    if ( TokenInfo )
    {
        LsaFreeTokenInfo( LsaTokenInformationV1, TokenInfo );
    }
    if ((LogonId->LowPart != 0) || (LogonId->HighPart != 0))
    {
        LsapDeleteLogonSession(LogonId);
    }

    LsapFreeString(
        AccountName
        );

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);

    }
    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaGetAuthDataForUser
//
//  Synopsis:   Helper function - retrieves all auth data for a user
//              based on Name, NameType, and prefix
//
//  Arguments:  [Name]             -- Name to search for
//              [NameType]         -- Type of name supplied
//              [Prefix]           -- String prefix for name
//              [UserAuthData]     --
//              [UserAuthDataSize] --
//
//  History:    6-08-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsaGetAuthDataForUser(
    PSECURITY_STRING Name,
    SECPKG_NAME_TYPE NameType,
    PSECURITY_STRING Prefix OPTIONAL,
    PUCHAR * UserAuthData,
    PULONG UserAuthDataSize,
    PUNICODE_STRING UserFlatName OPTIONAL
    )
{
    NTSTATUS Status ;
    ULONG SamFlags ;
    PUNICODE_STRING AccountName ;
    UNICODE_STRING CombinedName = { 0 };
    SID_AND_ATTRIBUTES_LIST ReverseMembership ;
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL ;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL ;
    PPACTYPE pNewPac = NULL ;
    PPACTYPE Pac ;
    UNICODE_STRING Domain ;
    UNICODE_STRING Machine ;
    PSID Sid ;

    Sid = NULL ;
    Machine.Buffer = NULL ;
    Domain.Buffer = NULL ;

    ReverseMembership.Count = 0 ;

    *UserAuthData = NULL ;

    if ( UserFlatName )
    {
        ZeroMemory( UserFlatName, sizeof( UNICODE_STRING ) );
    }


    SamFlags = 0 ;
    switch ( NameType )
    {
        case SecNameSamCompatible:
            AccountName = Name ;
            break;

        case SecNameAlternateId:
            SamFlags |= SAM_OPEN_BY_ALTERNATE_ID ;
            if ( !Prefix )
            {
                return STATUS_INVALID_PARAMETER ;
            }

            CombinedName.MaximumLength = Name->Length + Prefix->Length +
                                            2 * sizeof( WCHAR );

            CombinedName.Length = CombinedName.MaximumLength - sizeof( WCHAR );

            CombinedName.Buffer = (PWSTR) LsapAllocateLsaHeap( CombinedName.MaximumLength );


            if ( CombinedName.Buffer )
            {
                CopyMemory( CombinedName.Buffer, Prefix->Buffer, Prefix->Length );

                CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) ] = L':';

                CopyMemory( &CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) + 1],
                            Name->Buffer,
                            Name->Length + sizeof( WCHAR ) );

                AccountName = &CombinedName ;

            }
            else
            {
                return SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;

        case SecNameFlat:
            SamFlags |= SAM_OPEN_BY_UPN ;
            AccountName = Name ;
            break;

        default:
            return STATUS_INVALID_PARAMETER ;
    }

    Status = SamIGetUserLogonInformation(
                    LsapAccountDomainHandle,
                    SamFlags,
                    AccountName,
                    &UserAllInfo,
                    &ReverseMembership,
                    NULL );


    //
    // Free the combined name (if appropriate)
    //

    if ( CombinedName.Buffer )
    {
        LsapFreeLsaHeap( CombinedName.Buffer );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

    UserAll = &UserAllInfo->All ;

    if ( UserFlatName )
    {
        Status = LsapDuplicateString(
                        UserFlatName,
                        (PUNICODE_STRING) &UserAll->UserName );

        if ( !NT_SUCCESS( Status ) )
        {
            goto GetPac_Cleanup;
        }
    }

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED )
    {
        Status = STATUS_ACCOUNT_DISABLED ;

        goto GetPac_Cleanup;
    }

    if ( UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED )
    {
        Status = STATUS_ACCOUNT_LOCKED_OUT ;

        goto GetPac_Cleanup ;
    }

    Status = LsapCaptureSamInfo( &Sid, &Domain, &Machine );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = PAC_Init( UserAll,
                       NULL,
                       &ReverseMembership,            // no extra groups
                       Sid,
                       &Domain,
                       &Machine,
                       0,               // no signature
                       0,               // no additional data
                       NULL,            // no additional data
                       &Pac );


    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    *UserAuthDataSize = PAC_GetSize( Pac );

    *UserAuthData = (PUCHAR) LsapAllocateLsaHeap( *UserAuthDataSize );

    if ( *UserAuthData )
    {
       PAC_Marshal( Pac, *UserAuthDataSize, *UserAuthData );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    MIDL_user_free( Pac );

GetPac_Cleanup:

    if ( UserAllInfo )
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if ( ReverseMembership.Count )
    {
        SamIFreeSidAndAttributesList( &ReverseMembership );
    }

    if ( Sid )
    {
        LsapFreeLsaHeap( Sid );
    }

    if ( Domain.Buffer )
    {
        LsapFreeLsaHeap( Domain.Buffer );
    }

    if ( Machine.Buffer )
    {
        LsapFreeLsaHeap( Machine.Buffer );
    }

    return( Status );

}

NTSTATUS
NTAPI
LsaCrackSingleName(
    ULONG FormatOffered,
    BOOLEAN PerformAtGC,
    PUNICODE_STRING NameInput,
    PUNICODE_STRING Prefix OPTIONAL,
    ULONG RequestedFormat,
    PUNICODE_STRING CrackedName,
    PUNICODE_STRING DnsDomainName,
    PULONG SubStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    UNICODE_STRING DnsDomain ;
    UNICODE_STRING Name ;
    DWORD Ret ;
    DWORD DnsDomainLength ;
    DWORD NameLength ;
    UNICODE_STRING CombinedName = { 0 };
    PUNICODE_STRING AccountName ;

    if ( !SampUsingDsData() )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    //
    // Cruft up the call to the DS
    //


    Name.Buffer = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * sizeof(WCHAR) * 2 );
    DnsDomain.Buffer = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * sizeof(WCHAR) );

    if ( Name.Buffer && DnsDomain.Buffer )
    {
        Name.MaximumLength = MAX_PATH * sizeof(WCHAR) * 2 ;
        Name.Length = 0 ;

        DnsDomain.MaximumLength = MAX_PATH * sizeof(WCHAR) ;
        DnsDomain.Length = 0 ;

        NameLength = MAX_PATH * 2 ;
        DnsDomainLength = MAX_PATH ;

        Name.Buffer[ 0 ] = L'\0';
        DnsDomain.Buffer[ 0 ] = L'\0';

        if ( Prefix )
        {
            CombinedName.MaximumLength = NameInput->Length + Prefix->Length +
                                            2 * sizeof( WCHAR );

            CombinedName.Length = CombinedName.MaximumLength - sizeof( WCHAR );

            CombinedName.Buffer = (PWSTR) LsapAllocatePrivateHeap( CombinedName.MaximumLength );


            if ( CombinedName.Buffer )
            {
                CopyMemory( CombinedName.Buffer, Prefix->Buffer, Prefix->Length );

                CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) ] = L':';

                CopyMemory( &CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) + 1],
                            NameInput->Buffer,
                            NameInput->Length + sizeof( WCHAR ) );

                AccountName = &CombinedName ;

            }
            else
            {
                AccountName = NULL ;
            }

        }
        else
        {
            AccountName = NameInput ;
        }

        if ( AccountName )
        {
            __try
            {
                Ret = CrackSingleName(
                            FormatOffered,
                            PerformAtGC ?
                                DS_NAME_FLAG_GCVERIFY : 0,
                            AccountName->Buffer,
                            RequestedFormat,
                            &DnsDomainLength,
                            DnsDomain.Buffer,
                            &NameLength,
                            Name.Buffer,
                            SubStatus );

                if ( Ret != 0 )
                {
                    Status = STATUS_UNSUCCESSFUL ;
                }
                else
                {
                    Status = STATUS_SUCCESS ;

                    RtlInitUnicodeString( &DnsDomain, DnsDomain.Buffer );
                    RtlInitUnicodeString( &Name, Name.Buffer );

                    *CrackedName = Name ;
                    *DnsDomainName = DnsDomain ;


                }


            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                Status = STATUS_UNSUCCESSFUL ;
            }

            if ( CombinedName.Buffer )
            {
                LsapFreePrivateHeap( CombinedName.Buffer );
            }

        }

    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;

    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( Name.Buffer )
        {
            LsapFreeLsaHeap( Name.Buffer );
        }

        if ( DnsDomain.Buffer )
        {
            LsapFreeLsaHeap( DnsDomain.Buffer );
        }
    }

    return Status ;

}

NTSTATUS
LsapBuildPacSidList(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    OUT PSAMPR_PSID_ARRAY Sids
    )
{
    ULONG Size = 0, i;
    NTSTATUS Status = STATUS_SUCCESS ;

    Sids->Count = 0;
    Sids->Sids = NULL;


    if (UserInfo->UserId != 0)
    {
        Size += sizeof( SAMPR_SID_INFORMATION );
    }

    Size += UserInfo->GroupCount * (ULONG)sizeof( SAMPR_SID_INFORMATION );


    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS)
    {
        Size += UserInfo->SidCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);
    }

    Sids->Sids = (PSAMPR_SID_INFORMATION) MIDL_user_allocate( Size );

    if ( Sids->Sids == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    RtlZeroMemory(
        Sids->Sids,
        Size
        );


    //
    // Start copying SIDs into the structure
    //

    i = 0;

    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId )
    {
        Sids->Sids[0].SidPointer = (PRPC_SID)
                LsapMakeDomainRelativeSid( UserInfo->LogonDomainId,
                                            UserInfo->UserId );

        if( Sids->Sids[0].SidPointer == NULL )
        {
            Status = STATUS_NO_MEMORY ;
            goto Cleanup;
        }
        Sids->Count++;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ )
    {

        Sids->Sids[Sids->Count].SidPointer = (PRPC_SID)
                                    LsapMakeDomainRelativeSid(
                                         UserInfo->LogonDomainId,
                                         UserInfo->GroupIds[i].RelativeId );

        if( Sids->Sids[Sids->Count].SidPointer == NULL )
        {
            Status = STATUS_NO_MEMORY ;
            goto Cleanup;
        }

        Sids->Count++;
    }


    //
    // Add in the extra SIDs
    //

    //
    // No need to allocate these, but...
    //
    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS)
    {

        for ( i = 0; i < UserInfo->SidCount; i++ )
        {

            Status = LsapDuplicateSid(
                                (PSID *) &Sids->Sids[Sids->Count].SidPointer,
                                UserInfo->ExtraSids[i].Sid );

            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup ;
            }
            Sids->Count++;
        }
    }


    //
    // Deallocate any memory we've allocated
    //

Cleanup:
    if (!NT_SUCCESS( Status ))
    {
        if (Sids->Sids != NULL)
        {
            for (i = 0; i < Sids->Count ;i++ )
            {
                if (Sids->Sids[i].SidPointer != NULL)
                {
                    MIDL_user_free(Sids->Sids[i].SidPointer);
                }
            }
            MIDL_user_free(Sids->Sids);
            Sids->Sids = NULL;
            Sids->Count = 0;
        }
    }
    return Status ;

}



NTSTATUS
NTAPI
LsaExpandAuthDataForDomain(
    IN PUCHAR UserAuthData,
    IN ULONG UserAuthDataSize,
    IN PVOID Reserved,
    OUT PUCHAR * ExpandedAuthData,
    OUT PULONG ExpandedAuthDataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PPACTYPE Pac = NULL ;
    PPAC_INFO_BUFFER LogonInfo = NULL ;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL ;
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL ;
    SAMPR_PSID_ARRAY SidList = {0};
    PSAMPR_PSID_ARRAY ResourceGroups = NULL;
    PPACTYPE NewPac = NULL ;
    ULONG Index ;


    Pac = (PPACTYPE) UserAuthData ;

    if ( PAC_UnMarshal( Pac, UserAuthDataSize ) == 0 )
    {
        DebugLog(( DEB_ERROR, "Failed to unmarshall pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto Expand_Cleanup ;
    }

    LogonInfo = PAC_Find( Pac, PAC_LOGON_INFO, NULL );

    if ( !LogonInfo )
    {
        DebugLog(( DEB_ERROR, "Failed to find logon info in pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto Expand_Cleanup ;
    }


    Status = PAC_UnmarshallValidationInfo(
                &ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x\n",
            Status));

        goto Expand_Cleanup;
    }

    Status = LsapBuildPacSidList(
                ValidationInfo,
                &SidList );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Expand_Cleanup ;
    }


    //
    // Call SAM to get the sids
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                LsapAccountDomainHandle,
                &SidList,
                0,              // no flags
                &ResourceGroups
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get resource groups: 0x%x\n",Status));
        goto Expand_Cleanup;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                ValidationInfo,
                ResourceGroups,
                Pac,
                &NewPac
                );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Expand_Cleanup ;
    }

    *ExpandedAuthDataSize = PAC_GetSize( NewPac );

    *ExpandedAuthData = (PUCHAR) LsapAllocateLsaHeap( *ExpandedAuthDataSize );

    if ( *ExpandedAuthData )
    {
       PAC_Marshal( NewPac, *ExpandedAuthDataSize, *ExpandedAuthData );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    MIDL_user_free( NewPac );


Expand_Cleanup:

    if ( ValidationInfo )
    {
        MIDL_user_free( ValidationInfo );
    }

    if (SidList.Sids != NULL)
    {
        for (Index = 0; Index < SidList.Count ;Index++ )
        {
            if (SidList.Sids[Index].SidPointer != NULL)
            {
                MIDL_user_free(SidList.Sids[Index].SidPointer);
            }
        }
        MIDL_user_free(SidList.Sids);
    }

    SamIFreeSidArray(
        ResourceGroups
        );

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sesmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SesMgr.h
//
// Contents:    "Session" manager structures.
//
//
// History:     27 May 92   RichardW    Created from ether
//
//------------------------------------------------------------------------

#ifndef __SESMGR_H__
#define __SESMGR_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "handle.h"

//
// Forward definition so that we can reference it
//

struct _Session;


//
// Shared Section structure.  This allows packages to create shared
// sections with client processes.
//

typedef struct _LSAP_SHARED_SECTION {
    LIST_ENTRY  List;                       // List of sections for a session
    PVOID       Base;                       // Base pointer
    HANDLE      Heap;                       // Heap handle
    struct _Session * Session;              // Session pointer
    HANDLE      Section;                    // Handle to section object
} LSAP_SHARED_SECTION, * PLSAP_SHARED_SECTION ;



typedef struct _LSAP_THREAD_TASK {
    LIST_ENTRY              Next;
    struct _Session *       pSession;
    LPTHREAD_START_ROUTINE  pFunction;
    PVOID                   pvParameter;
} LSAP_THREAD_TASK, * PLSAP_THREAD_TASK;

typedef enum _LSAP_TASK_QUEUE_TYPE {
    QueueShared,                            // Queue shared by many threads
    QueueSingle,                            // Queue owned/run by single thread
    QueueShareRead,                         // Queue with dedicated thread, but
                                            // linked to other queue
    QueueZombie                             // Queue pending deletion
} LSAP_TASK_QUEUE_TYPE;

typedef struct _LSAP_TASK_QUEUE {
    LSAP_TASK_QUEUE_TYPE        Type;           // Type of Queue
    HANDLE                      hSemaphore;     // Semaphore to gate access
    CRITICAL_SECTION            Lock;           // Per-q lock
    LONG                        Tasks;          // Number of Tasks
    LIST_ENTRY                  pTasks;         // List of tasks
    struct _LSAP_TASK_QUEUE *   pNext;          // Next Queue
    struct _LSAP_TASK_QUEUE *   pShared;        // Shared Queue
    LONG                        TotalThreads;   // Total Threads (for Shared)
    LONG                        IdleThreads;    // Idle Threads (for Shared)
    struct _LSAP_TASK_QUEUE *   pOriginal;      // "Parent" queue for shareread
    struct _Session *           OwnerSession;   // Owning session record
    LONGLONG                    TaskCounter;    // Total number of tasks
    LONGLONG                    QueuedCounter;  // Total number queued
    HANDLE                      StartSync;      // Event for start syncing
    LONG                        MissedTasks;    // Number of tasks grabbed by other threads
    LONG                        ReqThread ;     // Number of times had to start another thd
    LONG                        MaxThreads ;    // Max # threads
    LONG                        TaskHighWater ; // Max # tasks
} LSAP_TASK_QUEUE, * PLSAP_TASK_QUEUE;

typedef 
NTSTATUS (LSAP_SESSION_CONNECT_FN)(
    struct _Session *   Session,
    PVOID               Parameter
    );

typedef LSAP_SESSION_CONNECT_FN * PLSAP_SESSION_CONNECT_FN ;

typedef struct _LSAP_SESSION_CONNECT {
    LIST_ENTRY  List ;
    PLSAP_SESSION_CONNECT_FN    Callback ;
    ULONG   ConnectFilter ;
    PVOID Parameter ;
} LSAP_SESSION_CONNECT, * PLSAP_SESSION_CONNECT ;

#define SESSION_CONNECT_TRUSTED     0x00000001
#define SESSION_CONNECT_UNTRUSTED   0x00000002
#define SESSION_CONNECT_KERNEL      0x00000004

typedef HRESULT (LSAP_SESSION_RUNDOWN_FN)(
    struct _Session *   Session,
    PVOID               Parameter
    );


typedef LSAP_SESSION_RUNDOWN_FN * PLSAP_SESSION_RUNDOWN_FN ;

typedef struct _LSAP_SESSION_RUNDOWN {
    LIST_ENTRY List ;
    PLSAP_SESSION_RUNDOWN_FN Rundown ;
    PVOID Parameter ;
} LSAP_SESSION_RUNDOWN, * PLSAP_SESSION_RUNDOWN ;

typedef struct _LSAP_SHARED_SESSION_DATA {
    PVOID            CredTable ;
    PVOID            ContextTable ;
    PLSAP_TASK_QUEUE pQueue ;
    PHANDLE_PACKAGE CredHandlePackage ;
    PHANDLE_PACKAGE ContextHandlePackage ;
    ULONG       cRefs ;
} LSAP_SHARED_SESSION_DATA, * PLSAP_SHARED_SESSION_DATA ;

typedef struct _Session {
    LIST_ENTRY          List ;
    DWORD               dwProcessID;            // ID of the calling process
    PLSAP_SHARED_SESSION_DATA SharedData ;      // Shared data for kernel sessions
    HANDLE              hPort;                  // Comm port used by this ses
    DWORD               fSession;               // Flags
    HANDLE              hProcess;               // Handle to the process
    CRITICAL_SECTION    SessionLock;            // Session Lock
    LONG                RefCount;               // Reference Count
    PVOID               pvStats;                // Statistics
    PVOID               NegotiateData;          // Reserved for negotiate support
    DWORD               ThreadId;               // Dedicated Thread (possible)
    LPWSTR              ClientProcessName;      // name of the registering process
    ULONG               SessionId;              // Hydra Session Id
    LIST_ENTRY          SectionList;            // List of sharedsections
    LIST_ENTRY          RundownList ;           // List of rundown hooks
    LONGLONG            CallCount ;             // Calls processed
    ULONG               Tick ;                  // Tick Count last snap
    LSAP_SHARED_SESSION_DATA DefaultData ;
} Session, * PSession;

#define SESFLAG_TASK_QUEUE  0x00000001      // Session has thread and queue
#define SESFLAG_TCB_PRIV    0x00000002      // Client has TCB privilege
#define SESFLAG_CLONE       0x00000004      // Assumed identity
#define SESFLAG_IMPERSONATE 0x00000008      // Session is an impersonation
#define SESFLAG_DESKTOP     0x00000010      // Session is using user's desktop
#define SESFLAG_UNTRUSTED   0x00000020      // Session didn't require TCB priv
#define SESFLAG_INPROC      0x00000040      // Session is an inprocess clone
#define SESFLAG_AUTONOMOUS  0x00000080      // Autonomous thread
#define SESFLAG_DEFAULT     0x00000100      // Default session for inactive
#define SESFLAG_UNLOADING   0x00000200      // Session called SpmUnload
#define SESFLAG_SCAVENGER   0x00000400      // Scavenger thread
#define SESFLAG_CLEANUP     0x00000800      // Session is being deleted
#define SESFLAG_KERNEL      0x00001000      // Handle list is shared kernel-mode list
#define SESFLAG_RESTRICTED  0x00002000      // caller has a restricted token
#define SESFLAG_MAYBEKERNEL 0x00004000      // might be kernel (see sesmgr.cxx)
#define SESFLAG_EFS         0x00008000      // EFS session
#define SESFLAG_SHADOW      0x00010000      // Shadow session until the real connection
#define SESFLAG_WOW_PROCESS 0x00020000      // WOW64 Process

extern  PSession    pDefaultSession;
extern  PSession    pEfsSession ;
extern  LSAP_TASK_QUEUE   GlobalQueue;

BOOL
InitSessionManager( void);

VOID
LsapFindEfsSession(
    VOID
    );

VOID
LsapUpdateEfsSession(
    PSession pSession
    );

HRESULT
CreateSession(  CLIENT_ID * pCid,
                BOOL        fOpenImmediate,
                PWCHAR      ClientProcessName,
                ULONG       Flags,
                PSession *  ppSession);

HRESULT
CloneSession(   PSession    pOriginalSession,
                PSession *  ppSession,
                ULONG       Flags );


NTSTATUS
CreateShadowSession(
    DWORD ProcessId,
    PSession * NewSession 
    );

void
FreeSession(PSession    pSession);


VOID
SpmpReferenceSession(
    PSession    pSession);

VOID
SpmpDereferenceSession(
    PSession    pSession);

VOID
LsapSessionDisconnect(
    PSession    pSession
    );

BOOL
AddRundown( PSession            pSession,
            PLSAP_SESSION_RUNDOWN_FN RundownFn,
            PVOID               pvParameter);

BOOL
DelRundown( PSession            pSession,
            PLSAP_SESSION_RUNDOWN_FN RundownFn
            );

BOOL
AddConnectionHook(
    PLSAP_SESSION_CONNECT_FN ConnectFn,
    PVOID Parameter,
    ULONG Filter
    );

BOOLEAN
AddCredHandle(  PSession    pSession,
                PCredHandle phCred,
                ULONG Flags );

BOOLEAN
AddContextHandle(   PSession    pSession,
                    PCtxtHandle phContext,
                    ULONG Flags);


NTSTATUS
ValidateContextHandle(  
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID *     pKey
    );

VOID
DerefContextHandle(
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID       Key OPTIONAL
    );

NTSTATUS
ValidateAndDerefContextHandle(
    PSession pSession,
    PCtxtHandle phContext
    );

NTSTATUS
ValidateCredHandle(  
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID *     pKey
    );

VOID
DerefCredHandle(
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID       Key OPTIONAL
    );

NTSTATUS
ValidateAndDerefCredHandle(
    PSession pSession,
    PCtxtHandle phCred
    );                

BOOL
LsapMoveContextHandle(
    PSecHandle  Handle,
    PSession    OriginatingSession,
    PSession    DestinationSession
    );

BOOL
LsapMoveCredHandle(
    PSecHandle  Handle,
    PSession    OriginatingSession,
    PSession    DestinationSession
    );


BOOL
GetMeClientDesktop(void);

void
DoneWithClientDesktop(void);

//
// PSession
// GetCurrentSession( VOID );
//
#define GetCurrentSession() ((PSession) TlsGetValue( dwSession ))

//
// VOID
// SetCurrentSession( PSession pSession );
//
#define SetCurrentSession( p ) TlsSetValue( dwSession, (PVOID) p )


//
// VOID
// LockSession( PSession pSession );
//
#define LockSession( p )    RtlEnterCriticalSection( &(((PSession) p)->SessionLock) )

//
// VOID
// UnlockSession( PSession pSession );
//
#define UnlockSession( p )  RtlLeaveCriticalSection( &(((PSession) p)->SessionLock) )


#ifndef WIN32_CHICAGO
#define GetCurrentPackageId()   ((ULONG_PTR) TlsGetValue(dwThreadPackage))

#ifdef LSAP_VERIFY_PACKAGE_ID
extern BOOL RefSetCurrentPackageId(DWORD dwPackageId);
#define SetCurrentPackageId(p)  RefSetCurrentPackageId((DWORD) p)
#else
#define SetCurrentPackageId(p)  TlsSetValue(dwThreadPackage, (PVOID)p)
#endif // LSAP_VERIFY_PACKAGE_ID

#else
#define GetCurrentPackageId()  1
#define SetCurrentPackageId(p)
#endif // WIN32_CHICAGO

VOID
SesEnumPerfData(VOID);


#ifdef __cplusplus
} // extern C
#endif

#endif // __SESMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\snego.c ===
#include <windows.h>
#include "snego.h"

ASN1module_t SNEGO_Module = NULL;

static int ASN1CALL ASN1Enc_MechTypeList2(ASN1encoding_t enc, ASN1uint32_t tag, PMechTypeList2 *val);
static int ASN1CALL ASN1Enc_NegHints2(ASN1encoding_t enc, ASN1uint32_t tag, NegHints2 *val);
static int ASN1CALL ASN1Enc_NegTokenReq2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenReq2 *val);
static int ASN1CALL ASN1Enc_NegResultList2(ASN1encoding_t enc, ASN1uint32_t tag, PNegResultList2 *val);
static int ASN1CALL ASN1Enc_NegTokenRep2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenRep2 *val);
static int ASN1CALL ASN1Enc_NegotiationToken2(ASN1encoding_t enc, ASN1uint32_t tag, NegotiationToken2 *val);
static int ASN1CALL ASN1Dec_MechTypeList2(ASN1decoding_t dec, ASN1uint32_t tag, PMechTypeList2 *val);
static int ASN1CALL ASN1Dec_NegHints2(ASN1decoding_t dec, ASN1uint32_t tag, NegHints2 *val);
static int ASN1CALL ASN1Dec_NegTokenReq2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenReq2 *val);
static int ASN1CALL ASN1Dec_NegResultList2(ASN1decoding_t dec, ASN1uint32_t tag, PNegResultList2 *val);
static int ASN1CALL ASN1Dec_NegTokenRep2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenRep2 *val);
static int ASN1CALL ASN1Dec_NegotiationToken2(ASN1decoding_t dec, ASN1uint32_t tag, NegotiationToken2 *val);
static void ASN1CALL ASN1Free_MechTypeList2(PMechTypeList2 *val);
static void ASN1CALL ASN1Free_NegHints2(NegHints2 *val);
static void ASN1CALL ASN1Free_NegTokenReq2(NegTokenReq2 *val);
static void ASN1CALL ASN1Free_NegResultList2(PNegResultList2 *val);
static void ASN1CALL ASN1Free_NegTokenRep2(NegTokenRep2 *val);
static void ASN1CALL ASN1Free_NegotiationToken2(NegotiationToken2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_NegotiationToken2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_NegotiationToken2,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_NegotiationToken2,
};
static const ULONG sizetab[1] = {
    SIZE_SNEGO_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL SNEGO_Module_Startup(void)
{
    SNEGO_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x67656e73);
}

void ASN1CALL SNEGO_Module_Cleanup(void)
{
    ASN1_CloseModule(SNEGO_Module);
    SNEGO_Module = NULL;
}

static int ASN1CALL ASN1Enc_MechTypeList2(ASN1encoding_t enc, ASN1uint32_t tag, PMechTypeList2 *val)
{
    PMechTypeList2 f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncObjectIdentifier(enc, 0x6, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MechTypeList2(ASN1decoding_t dec, ASN1uint32_t tag, PMechTypeList2 *val)
{
    PMechTypeList2 *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PMechTypeList2)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MechTypeList2(PMechTypeList2 *val)
{
    PMechTypeList2 f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1objectidentifier_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_NegHints2(ASN1encoding_t enc, ASN1uint32_t tag, NegHints2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->hintName);
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->hintName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->hintAddress).length, ((val)->hintAddress).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegHints2(ASN1decoding_t dec, ASN1uint32_t tag, NegHints2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->hintName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->hintAddress))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegHints2(NegHints2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->hintName);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->hintAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenReq2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenReq2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_MechTypeList2(enc, 0, &(val)->mechTypes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->desiredToken).length, ((val)->desiredToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegHints2(enc, 0, &(val)->negHints2))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenReq2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenReq2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_MechTypeList2(dd0, 0, &(val)->mechTypes))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->desiredToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegHints2(dd0, 0, &(val)->negHints2))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenReq2(NegTokenReq2 *val)
{
    if (val) {
	ASN1Free_MechTypeList2(&(val)->mechTypes);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->desiredToken);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_NegHints2(&(val)->negHints2);
	}
    }
}

static int ASN1CALL ASN1Enc_NegResultList2(ASN1encoding_t enc, ASN1uint32_t tag, PNegResultList2 *val)
{
    PNegResultList2 f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncU32(enc, 0xa, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegResultList2(ASN1decoding_t dec, ASN1uint32_t tag, PNegResultList2 *val)
{
    PNegResultList2 *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PNegResultList2)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *)&(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegResultList2(PNegResultList2 *val)
{
    PNegResultList2 f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenRep2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenRep2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_NegResultList2(enc, 0, &(val)->negResultList))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->supportedMech2))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechSpecInfo2).length, ((val)->mechSpecInfo2).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenRep2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenRep2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_NegResultList2(dd0, 0, &(val)->negResultList))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecObjectIdentifier(dd0, 0x6, &(val)->supportedMech2))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechSpecInfo2))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenRep2(NegTokenRep2 *val)
{
    if (val) {
	ASN1Free_NegResultList2(&(val)->negResultList);
	if ((val)->o[0] & 0x80) {
	    ASN1objectidentifier_free(&(val)->supportedMech2);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->mechSpecInfo2);
	}
    }
}

static int ASN1CALL ASN1Enc_NegotiationToken2(ASN1encoding_t enc, ASN1uint32_t tag, NegotiationToken2 *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenReq2(enc, 0, &(val)->u.negTokenReq))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenRep2(enc, 0, &(val)->u.negTokenRep))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NegotiationToken2(ASN1decoding_t dec, ASN1uint32_t tag, NegotiationToken2 *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenReq2(dd0, 0, &(val)->u.negTokenReq))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenRep2(dd0, 0, &(val)->u.negTokenRep))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NegotiationToken2(NegotiationToken2 *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NegTokenReq2(&(val)->u.negTokenReq);
	    break;
	case 2:
	    ASN1Free_NegTokenRep2(&(val)->u.negTokenRep);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sht.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       sht.cxx
//
//  Contents:   Small Handle table implementation
//
//  Classes:
//
//  Functions:
//
//  History:    2-03-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <lsapch.hxx>

#include "sht.hxx"

#if DBG
#define DBG_SHT 1
#else
#define DBG_SHT 0
#endif


#define SHT_ACTION_ADDREF       0
#define SHT_ACTION_DELREF       1
#define SHT_ACTION_FORCEDEL     2
#define SHT_ACTION_VALIDATE     3
#define SHT_ACTION_ADDHANDLE    4
#define SHT_ACTION_DELHANDLE    5

#define SHT_ACTION_MASK     0x0000FFFF
#define SHT_ACTION_LOCKED   0x00010000
#define SHTP_HANDLE_CHECKED 0x20000000

#define ShtLockTable( t ) \
            if ( (((PSMALL_HANDLE_TABLE) t)->Flags & SHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlEnterCriticalSection( &((PSMALL_HANDLE_TABLE)t)->Lock ); \
            }

#define ShtUnlockTable( t ) \
            if ( (((PSMALL_HANDLE_TABLE) t)->Flags & SHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlLeaveCriticalSection( &((PSMALL_HANDLE_TABLE)t)->Lock ); \
            }


HP_INITIALIZE_FN    ShtInitialize ;
HP_CREATE_FN        ShtCreate ;
HP_DELETE_FN        ShtDelete ;
HP_ADD_HANDLE_FN    ShtAddHandle ;
HP_DELETE_HANDLE_FN ShtDeleteHandle ;
HP_VALIDATE_HANDLE_FN ShtValidateHandle ;
HP_REF_HANDLE_FN    ShtRefHandle ;
HP_DEREF_HANDLE_KEY_FN ShtDerefHandleKey ;
HP_GET_HANDLE_CONTEXT_FN ShtGetHandleContext ;
HP_RELEASE_CONTEXT_FN ShtReleaseContext ;

HANDLE_PACKAGE  SmallHandlePackage = {
                    sizeof( SMALL_HANDLE_TABLE),
                    ShtInitialize,
                    ShtCreate,
                    ShtDelete,
                    ShtAddHandle,
                    ShtDeleteHandle,
                    ShtValidateHandle,
                    ShtRefHandle,
                    ShtDerefHandleKey,
                    ShtGetHandleContext,
                    ShtReleaseContext
                    };


//+---------------------------------------------------------------------------
//
//  Function:   ShtInitialize
//
//  Synopsis:   Initialize the small handle table package
//
//  Arguments:  (none)
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtInitialize(
    VOID
    )
{
    return TRUE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ShtCreate
//
//  Synopsis:   Create a small handle table
//
//  Arguments:  [Flags]         -- Options
//              [HandleTable]   -- Space to fill
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
ShtCreate(
    IN ULONG Flags,
    IN PVOID HandleTable OPTIONAL,
    IN PHP_ENUM_CALLBACK_FN Callback OPTIONAL
    )
{
    PSMALL_HANDLE_TABLE Table ;

    if ( HandleTable )
    {
        Table = (PSMALL_HANDLE_TABLE) HandleTable ;
    }
    else
    {
        Table = (PSMALL_HANDLE_TABLE) LsapAllocatePrivateHeap( sizeof( SMALL_HANDLE_TABLE ) );
    }

    if ( Table )
    {
        Table->Tag = SHT_TAG ;
        Table->Count = 0 ;
        Table->Flags = 0 ;

        InitializeListHead( &Table->List );

        //
        // Turn on general flags:
        //

        Table->Flags = (Flags & HANDLE_PACKAGE_GENERAL_FLAGS);

        if ( Flags & HANDLE_PACKAGE_NO_SERIALIZE )
        {
            Table->Flags |= SHT_NO_SERIALIZE ;
        }
        else
        {
            NTSTATUS Status = RtlInitializeCriticalSection( &Table->Lock );

            if (!NT_SUCCESS(Status))
            {
                if ( !HandleTable )
                {
                    LsapFreePrivateHeap( Table );
                }

                Table = NULL ;
            }
        }

        if ( Table )
        {

            if ( Flags & HANDLE_PACKAGE_CALLBACK_ON_DELETE )
            {
                Table->DeleteCallback = Callback ;
            }

            if ( HandleTable )
            {
                Table->Flags |= SHT_NO_FREE ;
            }
        }

    }

    return Table ;
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtDelete
//
//  Synopsis:   Deletes a handle table.  Callback is called for every handle in
//              the table.
//
//  Arguments:  [HandleTable] --
//              [Callback]    --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtDelete(
    PVOID   HandleTable,
    PHP_ENUM_CALLBACK_FN Callback
    )
{
    PSMALL_HANDLE_TABLE Table ;
    PSEC_HANDLE_ENTRY Entry ;
    PLIST_ENTRY Scan ;
    ULONG RefCount ;

    Table = (PSMALL_HANDLE_TABLE) HandleTable ;

    ShtLockTable( Table );

    Table->Flags |= SHT_DELETE_PENDING ;

    while ( !IsListEmpty( &Table->List ) )
    {
        Scan = RemoveHeadList( &Table->List );

        Table->Count--;

        Entry = (PSEC_HANDLE_ENTRY) Scan ;

        Table->PendingHandle = Entry ;

        Entry->Flags |= SEC_HANDLE_FLAG_DELETE_PENDING ;

        RefCount = Entry->HandleCount ;
        Entry->HandleCount = 1;
        Entry->RefCount = 1 ;

        if ( ( Callback ) &&
             ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
        {
            Callback( &Entry->Handle, Entry->Context, RefCount );
        }

        LsapFreePrivateHeap( Entry );

    }

    DsysAssert( Table->Count == 0 );

    if ( ( Table->Flags & SHT_NO_SERIALIZE ) == 0 )
    {
        RtlDeleteCriticalSection( &Table->Lock );
    }

    if ( (Table->Flags & SHT_NO_FREE) == 0 )
    {
        LsapFreePrivateHeap( Table );
    }

    return TRUE ;
}



#if DBG_SHT
//+---------------------------------------------------------------------------
//
//  Function:   ShtpValidateList
//
//  Synopsis:   Debug only - validates a handle table
//
//  Arguments:  [Table] --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
ShtpValidateList(
    PSMALL_HANDLE_TABLE Table,
    BOOL Locked
    )
{
    PLIST_ENTRY List ;
    PSEC_HANDLE_ENTRY Entry ;
    PSEC_HANDLE_ENTRY Back ;
    ULONG Count ;

    if ( !Locked )
    {
        ShtLockTable( Table );
    }

    List = Table->List.Flink ;
    Count = 0 ;

    while ( List && (List != &Table->List) )
    {
        Entry = (PSEC_HANDLE_ENTRY) List ;

        if ( List->Blink != &Table->List )
        {
            Back = (PSEC_HANDLE_ENTRY) List->Blink ;

            DsysAssertMsg( Back->Handle.dwUpper <= Entry->Handle.dwUpper, "Handle Table Corrupt (1)" );
        }

        List = List->Flink ;
        Count++ ;
    }

    DsysAssertMsg( List, "Handle Table Corrupt (2)" );
    DsysAssertMsg( Count == Table->Count, "Handle Table Corrupt (3)" );

    if ( !Locked )
    {
        ShtUnlockTable( Table );
    }
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   ShtpFindHandle
//
//  Synopsis:   General worker function for locating handles in the table
//
//  Arguments:  [Table]   -- Table to search
//              [Handle]  -- Handle to find
//              [Action]  -- Action to take
//              [Removed] -- Flag if it was removed or just deref'd
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSEC_HANDLE_ENTRY
ShtpFindHandle(
    PSMALL_HANDLE_TABLE Table,
    PSecHandle  Handle,
    ULONG   Action,
    PBOOL  Removed OPTIONAL
    )
{
    PLIST_ENTRY Scan ;
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete = FALSE ;
    Entry = NULL ;
    BOOL Locked ;
    BOOL Checked ;


    Locked = (Action & SHT_ACTION_LOCKED) == SHT_ACTION_LOCKED ;
    Checked = (Action & SHTP_HANDLE_CHECKED) == SHTP_HANDLE_CHECKED ;
    Action = Action & SHT_ACTION_MASK ;


#if DBG_SHT
    ShtpValidateList( Table, Locked );
#endif

    if ( !Locked )
    {
        ShtLockTable( Table );
    }

    if ( ( Table->Flags & SHT_DELETE_PENDING ) &&
         ( Table->PendingHandle ) )
    {
        if ( (Handle->dwUpper == Table->PendingHandle->Handle.dwUpper) &&
             (Handle->dwLower == Table->PendingHandle->Handle.dwLower) )
        {
            Entry = Table->PendingHandle ;

            DsysAssert( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING );

            goto FoundEntry ;
        }
    }


    Scan = Table->List.Flink ;

    while ( Scan != &Table->List )
    {
        Entry = (PSEC_HANDLE_ENTRY) Scan ;

        if ( Entry->Handle.dwUpper == Handle->dwUpper )
        {
            if ( Entry->Handle.dwLower == Handle->dwLower )
            {
                break;
            }
        }

        if ( Entry->Handle.dwUpper > Handle->dwUpper )
        {
            Entry = NULL ;
            break;
        }

        Scan = Entry->List.Flink ;

        Entry = NULL ;
    }

    if ( Entry && 
         ((Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING) != 0 ) ) 
    {
        DebugLog(( DEB_WARN, "Entry %p on list but marked delete pending\n", Entry ));
        Entry = NULL ;
    }

    if ( Entry &&
         ( Entry->HandleCount == 0 ) &&
         ( !Checked ) )
    {
        DebugLog(( DEB_TRACE_HANDLES, "Entry %p has handle count 0, no ref for %p:%p \n", 
                   Entry,
                   Entry->Handle.dwUpper,
                   Entry->Handle.dwLower ));

        Entry = NULL ;
    }

FoundEntry :

    if ( Entry )
    {
        switch ( Action )
        {
            case SHT_ACTION_ADDHANDLE:

                Entry->HandleIssuedCount++;
                Entry->HandleCount++ ;

                //
                // Fall through to the ADDREF behavior:
                //

            case SHT_ACTION_ADDREF:

                Entry->RefCount++;

                break;

            case SHT_ACTION_DELHANDLE:

                if ( Entry->HandleCount )
                {
                    Entry->HandleCount-- ;
                }
                else 
                {
                    break;
                }

                //
                // Fall through to the DELREF behavior
                //

            case SHT_ACTION_DELREF:
            case SHT_ACTION_FORCEDEL:

                Entry->RefCount -- ;

                DsysAssert( Entry->RefCount >= Entry->HandleCount );

                if ( ( Entry->RefCount == 0 ) ||
                       ( Action == SHT_ACTION_FORCEDEL ) )
                {
                    if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
                    {
                        RemoveEntryList( &Entry->List );

                        Table->Count-- ;
                    }

                    Delete = TRUE ;
                }


                break;

            case SHT_ACTION_VALIDATE:
            default:
                break;

        }
    }

    if ( !Locked )
    {
        ShtUnlockTable( Table );
    }

    if ( Removed )
    {
        *Removed = Delete ;
    }


#if DBG_SHT
    ShtpValidateList( Table, Locked );
#endif

    return Entry ;

}

//+---------------------------------------------------------------------------
//
//  Function:   ShtpPopHandle
//
//  Synopsis:   Private function for the large package.  Pops a handle out of
//              the table for redistribution.
//
//  Arguments:  [Table] --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSEC_HANDLE_ENTRY
ShtpPopHandle(
    PSMALL_HANDLE_TABLE Table
    )
{
    PLIST_ENTRY List ;

    ShtLockTable( Table );

    if ( !IsListEmpty( &Table->List ) )
    {
        List = RemoveHeadList( &Table->List );

        Table->Count-- ;
    }
    else
    {
        List = NULL ;
    }

    ShtUnlockTable( Table );

#if DBG_SHT
    ShtpValidateList( Table, FALSE );
#endif

    return ((PSEC_HANDLE_ENTRY) List );
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtpInsertHandle
//
//  Synopsis:   Worker function for lht.  Inserts an existing entry into a table
//
//  Arguments:  [Table] --
//              [Entry] --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
ShtpInsertHandle(
    PSMALL_HANDLE_TABLE Table,
    PSEC_HANDLE_ENTRY Entry
    )
{
    PLIST_ENTRY Scan ;
    PSEC_HANDLE_ENTRY Compare ;

    ShtLockTable( Table );

    Scan = Table->List.Flink ;

    while ( Scan != &Table->List )
    {
        Compare = (PSEC_HANDLE_ENTRY) Scan ;

        if ( Compare->Handle.dwUpper >= Entry->Handle.dwUpper )
        {
            break;
        }

        Scan = Compare->List.Flink ;

        Compare = NULL ;

    }

    InsertTailList( Scan, &Entry->List );

    Table->Count++;

    ShtUnlockTable( Table );

#if DBG_SHT
    ShtpValidateList( Table, FALSE );
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtAddHandle
//
//  Synopsis:   Add a handle to the table.
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtAddHandle(
    PVOID   HandleTable,
    PSecHandle  Handle,
    PVOID Context,
    ULONG Flags
    )
{
    PSMALL_HANDLE_TABLE Table ;
    PSEC_HANDLE_ENTRY Entry ;
    PSEC_HANDLE_ENTRY Compare ;
    PLIST_ENTRY Scan ;

    Table = (PSMALL_HANDLE_TABLE) HandleTable ;

    //
    // Need to make whole add operation atomic
    //

    ShtLockTable( Table );

    if ( ShtpFindHandle( Table,
                         Handle,
                         SHT_ACTION_ADDHANDLE | SHT_ACTION_LOCKED,
                         NULL ) )
    {
        ShtUnlockTable( Table );

        if ( Table->Flags & HANDLE_PACKAGE_REQUIRE_UNIQUE )
        {
            return FALSE ;
        }

        return TRUE ;
    }

    Entry = (PSEC_HANDLE_ENTRY) LsapAllocatePrivateHeap(
                                    sizeof( SEC_HANDLE_ENTRY ) );

    if ( Entry )
    {
        Entry->RefCount = 1;
        Entry->HandleCount = 1;
        Entry->Handle = *Handle ;
        Entry->Context = Context ;
        Entry->HandleIssuedCount = 1;

        Scan = Table->List.Flink ;

        while ( Scan != &Table->List )
        {
            Compare = (PSEC_HANDLE_ENTRY) Scan ;

            if ( Compare->Handle.dwUpper >= Handle->dwUpper )
            {
                break;
            }

            Scan = Compare->List.Flink ;

            Compare = NULL ;

        }

        Entry->Flags = Flags ;

        InsertTailList( Scan, &Entry->List );

        Table->Count++;

        ShtUnlockTable( Table );

#if DBG_SHT
    ShtpValidateList( Table, FALSE );
#endif
        return TRUE ;
    }

    ShtUnlockTable( Table );

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   ShtDeleteHandle
//
//  Synopsis:   Deletes a handle from the table
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//              [Force]       --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtDeleteHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    ULONG       Options
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                           Handle,
                           (Options & DELHANDLE_FORCE) ? 
                                SHT_ACTION_FORCEDEL : SHT_ACTION_DELHANDLE,
                           &Delete );

    if ( Entry )
    {
        if ( Delete )
        {
            PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;

            if ( ( Table->DeleteCallback ) &&
                 ( ( Options & DELHANDLE_NO_CALLBACK ) == 0 ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback(
                                &Entry->Handle,
                                Entry->Context,
                                Entry->HandleIssuedCount    // Entry->RefCount
                                );
            }

            if ( (Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }

        }

        return TRUE ;
    }

    return FALSE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtValidateHandle
//
//  Synopsis:   Validates a handle is listed in the table.
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtValidateHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    BOOL        Deref
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete = FALSE ;
    PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;

    Entry = ShtpFindHandle( Table,
                            Handle,
                            (Deref ? SHT_ACTION_DELHANDLE : SHT_ACTION_VALIDATE),
                            &Delete );

    if ( Entry )
    {
        if ( Delete )
        {
            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback(
                                &Entry->Handle,
                                Entry->Context,
                                Entry->HandleIssuedCount    // Entry->HandleCount
                                );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }
        return TRUE ;
    }
    else
    {
        return FALSE ;
    }
}

PVOID
ShtRefHandle(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                            Handle,
                            SHT_ACTION_ADDREF,
                            NULL );

    return Entry ;

}

VOID
ShtDerefHandleKey(
    PVOID HandleTable,
    PVOID HandleKey
    )
{
    PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;
    PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) HandleKey ;
    BOOL Delete = FALSE ;

    ShtLockTable( Table );

    Entry->RefCount -- ;

    DsysAssert( Entry->RefCount >= Entry->HandleCount );

    if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
    {
        if ( Entry->RefCount == 0 )
        {
            RemoveEntryList( &Entry->List );

            Delete = TRUE ;

            Table->Count-- ;
        }
    }

    ShtUnlockTable( Table );

    if ( Delete )
    {
        if ( ( Table->DeleteCallback ) &&
             ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
        {
            Table->DeleteCallback( &Entry->Handle, Entry->Context, Entry->HandleCount );
        }

        if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
        {
            LsapFreePrivateHeap( Entry );
        }
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   ShtGetHandleContext
//
//  Synopsis:   Returns the context pointer associated with the handle
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:      Adds a reference so it can't be deleted while in use.
//
//----------------------------------------------------------------------------
PVOID
ShtGetHandleContext(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                            Handle,
                            SHT_ACTION_ADDREF,
                            NULL );

    if ( Entry )
    {
        return Entry->Context ;
    }

    return NULL ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ShtReleaseContext
//
//  Synopsis:   Deref's a handle entry
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtReleaseContext(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                           Handle,
                           SHT_ACTION_DELREF,
                           &Delete );

    if ( Entry )
    {
        if ( Delete )
        {
            PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;

            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback( &Entry->Handle, Entry->Context, Entry->RefCount );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=lsa
MINORCOMP=server

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\lsasrv.def

INCLUDES=..;..\..\inc;..\..\..\inc;  \
         ..\..\idl;                  \
         ..\..\idl\$(O);             \
         $(DS_GLOBAL_INC);           \
         $(NTDS_INC);                \
         $(SECURITY_INC);            \
         $(BASE_INC_PATH);           \
         $(COM_INC_PATH);            \
         $(DS_INC_PATH);             \
         $(DS_INC_PATH)\crypto;      \
         $(DRIVERS_INC_PATH);        \
         $(ENDUSER_INC_PATH);        \
         $(WINDOWS_INC_PATH);        \
         $(NET_INC_PATH);

NTLEGO=1

# Strict warning, can be used to detect uninitialized vars. Picks up random
# stuff too

COMPILER_WARNINGS=$(COMPILER_WARNINGS) -FI$(SECURITY_INC)\secwarn.h
C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -DLSA_SERVER_COMPILED

!IF "$(WIN64)" == "1"
NO_SSPI_SIGNATURES=1
!ENDIF

!IF "$(NO_SSPI_SIGNATURES)" != ""
LSA_IGNORE_SIGNATURE=1
!ENDIF

!IF "$(LSA_IGNORE_SIGNATURE)" != ""
C_DEFINES=$(C_DEFINES) -DLSA_IGNORE_SIGNATURE
!ENDIF

SOURCES= \
         ..\bndcache.cxx \
         ..\credapi.cxx \
         ..\credmgr.cxx \
         ..\ctxtapi.cxx \
         ..\debug.cxx \
         ..\efssrv.cxx   \
         ..\efsapi.cxx   \
         ..\efsinit.cxx   \
         ..\efscert.cxx  \
         ..\efssrv.cxx   \
         ..\encrypt.cxx \
         ..\klpc.cxx    \
         ..\klpcstub.cxx \
         ..\lht.cxx \
         ..\lsawmi.c \
         ..\lsastr.c \
         ..\msvlayer.cxx \
         ..\negotiat.cxx \
         ..\negsupp.cxx \
         ..\neglsa.cxx \
         ..\param.cxx \
         ..\policy.cxx \
         ..\shmem.cxx \
         ..\samhooks.cxx \
         ..\scavenge.cxx \
         ..\sesmgr.cxx  \
         ..\sht.cxx \
         ..\sphelp.cxx \
         ..\spinit.cxx \
         ..\spmgr.cxx \
         ..\sputil.cxx \
         ..\thdpool.cxx \
         ..\userkey.cxx \
         ..\util.cxx \
         ..\logons.cxx \
         ..\efsrpc_s_stub.c \
         ..\lsa_rev.rc  \
         ..\lsarpc_s_stub.c  \
         ..\snego.c \
         ..\spnego.c

UMTYPE=windows
UMRES=$(O)\lsa_rev.res
UMLIBS=$(SDK_LIB_PATH)\lsasrv.lib                        \
       $(SDK_LIB_PATH)\rpcrt4.lib                        \
       $(SDK_LIB_PATH)\samlib.lib                        \
       $(SDK_LIB_PATH)\samsrv.lib                        \
       $(SDK_LIB_PATH)\ntdll.lib


LINKLIBS=                                                            \
       ..\cfiles\$(O)\lsalib.lib                                     \
       ..\dspolicy\$(O)\lpolicy.lib                          \
       $(SDK_LIB_PATH)\ntdsa.lib                                     \
       $(SECURITY_LIB_PATH)\dsrolsrv.lib                                \
       $(SECURITY_LIB_PATH)\dpapisvc.lib


TARGETLIBS= \
       ..\..\common\$(O)\lsacomm.lib                     \
       $(SECURITY_LIB_PATH)\dsysdbg.lib                  \
       $(SECURITY_LIB_PATH)\secmisc.lib                  \
       $(SDK_LIB_PATH)\rpcutil.lib                       \
       $(SDK_LIB_PATH)\rpcrt4.lib                        \
       $(SDK_LIB_PATH)\rpcndr.lib                        \
       $(SDK_LIB_PATH)\kernel32.lib                      \
       ..\..\security\dll\$(O)\secur32p.lib              \
       $(SDK_LIB_PATH)\user32.lib                        \
       $(SDK_LIB_PATH)\advapip.lib                       \
       $(SDK_LIB_PATH)\samsrv.lib                        \
       $(SDK_LIB_PATH)\msasn1.lib                        \
       $(DS_GLOBAL_LIB_PATH)\nlrepl.lib                  \
       $(DS_LIB_PATH)\rsa32.lib                          \
       $(SDK_LIB_PATH)\ntdsa.lib                         \
       $(SDK_LIB_PATH)\netlib.lib                        \
       $(DS_LIB_PATH)\netapi32p.lib                      \
       $(SDK_LIB_PATH)\wldap32.lib                       \
       $(SDK_LIB_PATH)\dnsapi.lib                        \
       $(SDK_LIB_PATH)\samlib.lib                        \
       $(SDK_LIB_PATH)\ntdsetup.lib                      \
       $(SDK_LIB_PATH)\mpr.lib                           \
       $(SDK_LIB_PATH)\crypt32.lib                       \
       $(SDK_LIB_PATH)\cryptui.lib                       \
       $(SDK_LIB_PATH)\userenv.lib                       \
       $(SDK_LIB_PATH)\ntdsapi.lib                       \
       $(DS_LIB_PATH)\certclip.lib                       \
       $(SDK_LIB_PATH)\shlwapi.lib                       \
       $(DS_GLOBAL_LIB_PATH)\wxapicli.lib                \
       $(DS_LIB_PATH)\alloca.lib                         \
       $(PROJECT_LIB_PATH)\pautoenr.lib


#
# This line makes the lsasrv.dll use crtdll.dll instead of libc.lib
#

USE_CRTDLL=1

PRECOMPILED_INCLUDE=..\lsapch.hxx
PRECOMPILED_OBJ=lsapch.obj
PRECOMPILED_PCH=lsapch.pch

DELAYLOAD=dnsapi.dll;crypt32.dll;wldap32.dll;ntdsetup.dll;cryptui.dll;userenv.dll;certcli.dll;ntdsa.dll;shlwapi.dll;pautoenr.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\shmem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:      shmem.cxx
//
//  Contents:
//
//  History:
//             RichardW   12/17/1996    Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#define LSA_SHARED_HEAP_FLAGS   (HEAP_NO_SERIALIZE | \
                                HEAP_GENERATE_EXCEPTIONS | \
                                HEAP_ZERO_MEMORY | \
                                HEAP_REALLOC_IN_PLACE_ONLY | \
                                HEAP_TAIL_CHECKING_ENABLED | \
                                HEAP_FREE_CHECKING_ENABLED | \
                                HEAP_DISABLE_COALESCE_ON_FREE | \
                                HEAP_CREATE_ALIGN_16 | \
                                HEAP_CREATE_ENABLE_TRACING )

#if DBG

#define LSA_DEFAULT_HEAP_FLAGS  (HEAP_ZERO_MEMORY | \
                                HEAP_TAIL_CHECKING_ENABLED | \
                                HEAP_FREE_CHECKING_ENABLED )

#else

#define LSA_DEFAULT_HEAP_FLAGS  (HEAP_ZERO_MEMORY)

#endif

//+---------------------------------------------------------------------------
//
//  Function:   LsapCreateSharedSection
//
//  Synopsis:   Internal worker that creates a section mapped into the process
//              indicated by pSession
//
//  Effects:
//
//  Arguments:  [pSession]    -- Session where section should be mapped
//              [HeapFlags]   -- Heap flags for section
//              [InitialSize] -- Initial size
//              [MaxSize]     -- Maximum size
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SHARED_SECTION
LsapCreateSharedSection(
    PSession pSession,
    ULONG   HeapFlags,
    ULONG   InitialSize,
    ULONG   MaxSize
    )
{
    HANDLE  Section ;
    PLSAP_SHARED_SECTION SharedSection ;
    LARGE_INTEGER SectionOffset ;
    NTSTATUS Status ;
    PVOID ClientBase ;
    SIZE_T ViewSize ;

    //
    // Create the section.  The security descriptor is defaulted to
    // local system for now, although this will fixed.
    //

    Section = CreateFileMapping( INVALID_HANDLE_VALUE,
                                 NULL,  
                                 PAGE_READWRITE |
                                    SEC_RESERVE,
                                 0,
                                 MaxSize,
                                 NULL );

    if ( Section == NULL )
    {
        return NULL ;
    }

    SharedSection = (PLSAP_SHARED_SECTION ) LsapAllocateLsaHeap( sizeof( LSAP_SHARED_SECTION ) );

    if ( !SharedSection )
    {
        CloseHandle( Section );

        return NULL ;
    }

    SharedSection->Section = Section ;


    //
    // Map the shared section into our address space:
    //

    SharedSection->Base = MapViewOfFileEx( Section,
                                           FILE_MAP_READ | FILE_MAP_WRITE,
                                           0,
                                           0,
                                           0,
                                           NULL );

    if ( !SharedSection->Base )
    {
        CloseHandle( Section );
        LsapFreeLsaHeap( SharedSection );
        return NULL ;
    }

    //
    // Map it into the client's address space
    //

    SectionOffset.QuadPart = 0;

    ClientBase = SharedSection->Base ;
    ViewSize = 0 ;

    Status = NtMapViewOfSection( Section,
                                 pSession->hProcess,
                                 &ClientBase,
                                 0L,
                                 0L,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0L,
                                 PAGE_READWRITE );

    if ( !NT_SUCCESS( Status ) )
    {
        UnmapViewOfFile( SharedSection->Base );

        CloseHandle( SharedSection->Section );

        LsapFreeLsaHeap( SharedSection );

        return NULL ;
    }

    //
    // Okay, now commit the initial size, and start the heap on it.
    //

    VirtualAllocEx( GetCurrentProcess(),
                    SharedSection->Base,
                    InitialSize,
                    MEM_COMMIT,
                    PAGE_READWRITE );

    HeapFlags &= LSA_SHARED_HEAP_FLAGS ;

    SharedSection->Heap = RtlCreateHeap( HeapFlags,
                                         SharedSection->Base,
                                         MaxSize,
                                         InitialSize,
                                         NULL,
                                         NULL );

    if ( !SharedSection->Heap )
    {
        UnmapViewOfFile( SharedSection->Base );

        CloseHandle( SharedSection->Section );

        LsapFreeLsaHeap( SharedSection );

        return NULL ;
    }

    return SharedSection ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapDeleteSharedSection
//
//  Synopsis:   Internal worker that deletes a shared section
//
//  Arguments:  [SharedSection] -- section to delete
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LsapDeleteSharedSection(
    PLSAP_SHARED_SECTION SharedSection
    )
{
    RtlDestroyHeap( SharedSection->Heap );

    NtUnmapViewOfSection(   SharedSection->Session->hProcess,
                            SharedSection->Base );

    NtUnmapViewOfSection(   NtCurrentProcess(),
                            SharedSection->Base );

    CloseHandle( SharedSection->Section );

    LsapFreeLsaHeap( SharedSection );

    return TRUE;

}

HRESULT
LsapSharedSectionRundown(
    PSession    Session,
    PVOID       Ignored
    )
{
    PLIST_ENTRY List ;
    PLSAP_SHARED_SECTION Section ;

    while ( !IsListEmpty( &Session->SectionList ) )
    {
        List = RemoveHeadList( &Session->SectionList );

        Section = (PLSAP_SHARED_SECTION) List ;

        LsapDeleteSharedSection( Section );
    }

    return SEC_E_OK ;
}


//////////////////////////////////////////////////////////////////////////////
//
//   Functions exported to security packages for shared memory
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   LsaCreateSharedMemory
//
//  Synopsis:   "Public" function to create the shared memory segment
//
//  Arguments:  [MaxSize]     --
//              [InitialSize] --
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
NTAPI
LsaCreateSharedMemory(
    ULONG   InitialSize,
    ULONG   MaxSize
    )
{
    PSession    pSession ;
    PLSAP_SHARED_SECTION SharedSection ;

    pSession = GetCurrentSession();

    //
    // Validate that we are running in a real call with a real client
    //

    if (pSession->dwProcessID == GetCurrentProcessId())
    {
        return NULL ;
    }

    //
    // Try to create the shared section
    //

    SharedSection = LsapCreateSharedSection(    pSession,
                                                LSA_DEFAULT_HEAP_FLAGS,
                                                InitialSize,
                                                MaxSize
                                           );

    if ( SharedSection )
    {

        SharedSection->Session = pSession ;

        LockSession( pSession );

        if ( IsListEmpty( &pSession->SectionList ) )
        {
            AddRundown( pSession, LsapSharedSectionRundown, NULL );
        }

        InsertTailList( &pSession->SectionList,
                        &SharedSection->List );

        UnlockSession( pSession );
    }

    return SharedSection ;


}

//+---------------------------------------------------------------------------
//
//  Function:   LsaAllocateSharedMemory
//
//  Synopsis:   Allocates memory out of a shared section.
//
//  Arguments:  [Shared] -- Handle to shared section
//              [Size]   -- Size of allocation.
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
NTAPI
LsaAllocateSharedMemory(
    PVOID   Shared,
    ULONG   Size
    )
{
    PLSAP_SHARED_SECTION SharedSection ;
    PVOID Memory ;

    SharedSection = (PLSAP_SHARED_SECTION) Shared ;

    __try
    {
        Memory = RtlAllocateHeap( SharedSection->Heap, 0, Size );

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Memory = NULL ;
    }

    return Memory ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaFreeSharedMemory
//
//  Synopsis:   Frees memory allocated out of a section
//
//  Arguments:  [Shared] --
//              [Memory] --
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NTAPI
LsaFreeSharedMemory(
    PVOID   Shared,
    PVOID   Memory
    )
{
    PLSAP_SHARED_SECTION SharedSection ;

    SharedSection = (PLSAP_SHARED_SECTION) Shared ;

    __try
    {
        HeapFree( SharedSection->Heap, 0, Memory );

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NOTHING ;
    }

}


//+---------------------------------------------------------------------------
//
//  Function:   LsaDeleteSharedMemory
//
//  Synopsis:   Public wrapper to delete the shared section
//
//  Arguments:  [Shared] -- handle to shared section
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
NTAPI
LsaDeleteSharedMemory(
    PVOID   Shared
    )
{
    PLSAP_SHARED_SECTION SharedSection ;
    PSession pSession ;
    BOOL Success ;

    pSession = GetCurrentSession();

    SharedSection = (PLSAP_SHARED_SECTION) Shared ;

    if ( pSession != SharedSection->Session )
    {
        DebugLog(( DEB_WARN, "Package tried to delete shared memory for a different process\n" ));

        return FALSE ;
    }

    Success = FALSE ;

    __try
    {
        LockSession( pSession );

        RemoveEntryList( &SharedSection->List );

        Success = LsapDeleteSharedSection( SharedSection );

        if ( IsListEmpty( &pSession->SectionList ) )
        {
            DelRundown( pSession, LsapSharedSectionRundown );
        }
    }
    __finally
    {
        UnlockSession( pSession );
    }

    return ( Success != 0 ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sidcache.h ===
//+-----------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        sidcache.h
//
// Contents:    types and prototypes for sid cache management
//
//
// History:     15-May-1997     MikeSw          Created
//
//------------------------------------------------------------------------------

#ifndef __SIDCACHE_H__
#define __SIDCACHE_H__


////////////////////////////////////////////////////////////////////////////////
//
// Sid Cache Data types exported for lsaexts
//
////////////////////////////////////////////////////////////////////////////////

typedef struct _LSAP_DB_SID_CACHE_ENTRY {

    struct _LSAP_DB_SID_CACHE_ENTRY * Next;

    //
    // Cache data
    //
    PSID Sid;
    UNICODE_STRING AccountName;
    SID_NAME_USE SidType;
    PSID DomainSid;
    UNICODE_STRING DomainName;

    //
    // These time values are only used for SID cache 
    // entries that aren't associated with an actual logon session.
    //
    LARGE_INTEGER ExpirationTime;
    LARGE_INTEGER RefreshTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER LastUse;
    ULONG         Flags;

    //
    // InUseCount is only used for SID cache entries that are
    // currently associated with an actual logon session.  As long as
    // InUseCount is nonzero, ExpirationTime will not be checked.
    // Once InUseCount is zero, ExpirationTime will be set.
    //
    LONG          InUseCount;

} LSAP_DB_SID_CACHE_ENTRY, *PLSAP_DB_SID_CACHE_ENTRY;


//
// Flags to describe the cache entry
//

//
// The name in the AccountName and DomainName fields represents
// a SAM account name
//
#define LSAP_SID_CACHE_SAM_ACCOUNT_NAME 0x00000001

//
// The AccountName is a UPN
//
#define LSAP_SID_CACHE_UPN              0x00000002


////////////////////////////////////////////////////////////////////////////////
//
// Exported Sid Cache functions
//
////////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapDbInitSidCache(
    VOID
    );
VOID
LsapSidCacheReadParameters(
    HKEY hKey
    );

VOID
LsapDbUpdateCacheWithSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames
    );

VOID
LsapDbUpdateCacheWithNames(
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids
    );

NTSTATUS
LsapDbMapCachedSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    OUT PULONG MappedCount
    );

NTSTATUS
LsapDbMapCachedNames(
    IN ULONG           LookupOptions,
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    OUT PULONG MappedCount
    );

VOID
LsapDbAddLogonNameToCache(
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN PSID AccountSid
    );

VOID
LsapDbReleaseLogonNameFromCache(
    IN PSID Sid
    );

#endif // __SIDCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\snego.h ===
#ifndef _SNEGO_Module_H_
#define _SNEGO_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct MechTypeList2 * PMechTypeList2;

typedef struct NegResultList2 * PNegResultList2;

typedef ASN1objectidentifier_t MechType2;

typedef enum NegResult2 {
    accept2 = 0,
    reject2 = 1,
} NegResult2;

typedef ASN1octetstring_t MechSpecInfo2;

typedef struct MechTypeList2 {
    PMechTypeList2 next;
    MechType2 value;
} MechTypeList2_Element;

typedef struct NegHints2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define hintName_present 0x80
    ASN1ztcharstring_t hintName;
#   define hintAddress_present 0x40
    ASN1octetstring_t hintAddress;
} NegHints2;

typedef struct NegTokenReq2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PMechTypeList2 mechTypes;
#   define desiredToken_present 0x80
    ASN1octetstring_t desiredToken;
#   define negHints2_present 0x40
    NegHints2 negHints2;
} NegTokenReq2;

typedef struct NegResultList2 {
    PNegResultList2 next;
    NegResult2 value;
} NegResultList2_Element;

typedef struct NegTokenRep2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PNegResultList2 negResultList;
#   define supportedMech2_present 0x80
    MechType2 supportedMech2;
#   define mechSpecInfo2_present 0x40
    MechSpecInfo2 mechSpecInfo2;
} NegTokenRep2;

typedef struct NegotiationToken2 {
    ASN1choice_t choice;
    union {
#	define negTokenReq_chosen 1
	NegTokenReq2 negTokenReq;
#	define negTokenRep_chosen 2
	NegTokenRep2 negTokenRep;
    } u;
} NegotiationToken2;
#define NegotiationToken2_PDU 0
#define SIZE_SNEGO_Module_PDU_0 sizeof(NegotiationToken2)


extern ASN1module_t SNEGO_Module;
extern void ASN1CALL SNEGO_Module_Startup(void);
extern void ASN1CALL SNEGO_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _SNEGO_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spdebug.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPDebug.h
//
// Contents:    Debug functions
//
//
// History:     10 Sep 92   RichardW    Created
//
//------------------------------------------------------------------------

#if DBG

#define SPM_DBG_GETDEBUGLEVEL   1
#define SPM_DBG_SETDEBUGLEVEL   2
#define SPM_DBG_MEMORYUSE       3
#define SPM_DBG_BREAK           4
#define SPM_DBG_TRACEMEM        5
#define SPM_DBG_FAILMEM         6


typedef struct _SpmDbg_Memory_Detail {
    unsigned long   PackageID;
    unsigned long   HeapUse;
    unsigned long   HeapHW;
} SpmDbg_Memory_Detail;

typedef struct _SpmDbg_MemoryUse {
    unsigned long           DetailCount;
    SpmDbg_Memory_Detail    Details[1];
} SpmDbg_MemoryUse, *PSpmDbg_MemoryUse;

typedef struct _SpmDbg_MemoryFailure {
    ULONG FailureInterval;
    ULONG FailureDelay;
    ULONG FailureLength;
    BOOLEAN fSimulateFailure;
} SpmDbg_MemoryFailure, *PSpmDbg_MemoryFailure;

#endif

#define SPM_SET_PERFORMANCE_FILE    10

#define SPM_GET_GLUON_INFO          11

#define SPM_SNAPSHOT_SESSIONS       12

#define SPM_GET_API_PERFORMANCE     13
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sphelp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPHELP.H
//
// Contents:    Headers and prototypes for the sp helper functions
//
//
// History:     21 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __SPHELP_H__
#define __SPHELP_H__

#if defined(TRACK_MEM_LEAK)

void
MarkPermanent(void *p);

void
UnmarkPermanent(void *p);

void
TraceMemory(DWORD fOptions);

HRESULT
CheckSecMemory(void);

#else

#define MarkPermanent(p)
#define UnmarkPermanent(p)
#define TraceMemory(f)

#ifndef DBGMEM
#define CheckSecMemory()
#endif

#endif

#define SpmAllocate(x) LsapAllocateLsaHeap(x)
#define SpmFree(x) LsapFreeLsaHeap(x)

extern LSA_SECPKG_FUNCTION_TABLE LsapSecpkgFunctionTable;

#pragma warning(4:4276) // Disable warning

LSA_IMPERSONATE_CLIENT LsapImpersonateClient;
LSA_UNLOAD_PACKAGE LsapUnloadPackage;
LSA_DUPLICATE_HANDLE LsapDuplicateHandle;
LSA_SAVE_SUPPLEMENTAL_CREDENTIALS LsapSaveSupplementalCredentials;
LSA_CREATE_THREAD LsapCreateThread;
LSA_GET_CLIENT_INFO LsapGetClientInfo;
LSA_MAP_BUFFER LsapMapClientBuffer;
LSA_CREATE_TOKEN LsapCreateToken;
LSA_CREATE_TOKEN_EX LsapCreateTokenEx;
LSA_AUDIT_LOGON LsapAuditLogon;

LSA_GET_CALL_INFO LsapGetCallInfo;
LSA_CREATE_SHARED_MEMORY LsaCreateSharedMemory;
LSA_ALLOCATE_SHARED_MEMORY LsaAllocateSharedMemory;
LSA_FREE_SHARED_MEMORY LsaFreeSharedMemory;
LSA_DELETE_SHARED_MEMORY LsaDeleteSharedMemory;
LSA_OPEN_SAM_USER LsaOpenSamUser ;
LSA_GET_USER_CREDENTIALS LsaGetUserCredentials ;
LSA_GET_USER_AUTH_DATA LsaGetUserAuthData ;
LSA_CLOSE_SAM_USER LsaCloseSamUser ;
LSA_CONVERT_AUTH_DATA_TO_TOKEN LsaConvertAuthDataToToken ;
LSA_CLIENT_CALLBACK LsaClientCallback ;
LSA_GET_AUTH_DATA_FOR_USER LsaGetAuthDataForUser ;
LSA_CRACK_SINGLE_NAME LsaCrackSingleName ;
LSA_EXPAND_AUTH_DATA_FOR_DOMAIN LsaExpandAuthDataForDomain;

PVOID NTAPI
LsapClientAllocate(
    IN ULONG cbMemory
    );

NTSTATUS NTAPI
LsapCopyToClient(
    IN PVOID pLocalMemory,
    OUT PVOID pClientMemory,
    IN ULONG cbMemory
    );

NTSTATUS NTAPI
LsapCopyFromClient(
    IN PVOID pClientMemory,
    OUT PVOID pLocalMemory,
    IN ULONG cbMemory
    );

NTSTATUS NTAPI
LsapClientFree(
    IN PVOID pClientMemory
    );


NTSTATUS
LsapOpenCaller(
    IN OUT PSession pSession
    );

NTSTATUS
CheckCaller(
    IN PSession pSession
    );

NTSTATUS
LsapDuplicateString(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    );

NTSTATUS
LsapDuplicateString2(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    );

VOID
LsapFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

NTSTATUS
LsapUpdateCredentials(
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    );

NTSTATUS
LsapUpdateCredentialsWorker(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spinit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPINIT.H
//
// Contents:    Common structures and functions for the SPINIT
//
//
// History:     20 May 92   RichardW    Documented existing stuff
//
//------------------------------------------------------------------------



#ifndef __SPINIT_H__
#define __SPINIT_H__


HRESULT   LoadPackages( PWSTR * ppszPackageList,
                        PWSTR * ppszOldPkgs,
                        PWSTR pszPreferred );

void    InitThreadData(void);
void    InitSystemLogon(void);
BOOLEAN LsapEnableCreateTokenPrivilege(void);

extern
SECPKG_FUNCTION_TABLE   NegTable ;


#endif  __SPINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sphelp.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        sphelp.c
//
// Contents:    Security Package Helper functions (see isecpkg.doc)
//
// Functions    LsapUnloadPackage
//              LsapAllocate
//              LsapFree
//              LsapClientAllocate
//              LsapCopyToClient
//              LsapCopyFromClient
//              LsapClientFree
//              LsapOpenClientProcess
//              LsapOpenClientThread
//              LsapDuplicateHandle
//              LsapSaveSupplementalCredentials
//              LsapGetWindow
//              LsapCreateThread
//              LsapMapClientBuffer
//
//
// Notes:       By defining TRACK_MEM, we will track all use of memory
//              allocated through the LsapAllocate.  DBG_MEM will track
//              memory leaks.
//
// History:     20 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include "sesmgr.h"
#include "spdebug.h"
#include "klpcstub.h"

}


typedef struct _LSAP_THREAD_START {
    LPTHREAD_START_ROUTINE  lpStart;
    LPVOID                  lpParm;
    ULONG_PTR               dwPackageID;
} LSAP_THREAD_START, *PLSAP_THREAD_START;

extern LSA_CALL_INFO LsapDefaultCallInfo ;


ULONG_PTR   LsapUserModeLimit ;

//
// private heaps defines.
//

// HEAP_HEADER should always be size even multiple of heap allocation granularity
//
typedef struct {
    HANDLE      hHeap;
    SIZE_T      Magic;
} HEAP_HEADER_LSA, *PHEAP_HEADER_LSA;

#define HEAP_COUNT_MAX  32
#define HEAP_MAGIC_TAG  0x66677766

HANDLE gHeaps[ HEAP_COUNT_MAX ];
DWORD gcHeaps;



#if DBG
//
// Failure simulation parameters
//

ULONG TotalAllocations;
ULONG_PTR PackageToFail = SPMGR_ID;
SpmDbg_MemoryFailure MemFail;

#endif // DBG



void
CacheMachineInReg(GUID *);



#define MEM_MAGIC   0x0feedbed
#define MEM_FREED   0x0b00b00b
#define MEM_MASK    0x0FFFFFFF
#define MEM_NEVER   0x10000000

LSA_SECPKG_FUNCTION_TABLE LsapSecpkgFunctionTable = {
    LsapCreateLogonSession,
    LsapDeleteLogonSession,
    LsapAddCredential,
    LsapGetCredentials,
    LsapDeleteCredential,
    LsapAllocateLsaHeap,
    LsapFreeLsaHeap,
    LsapAllocateClientBuffer,
    LsapFreeClientBuffer,
    LsapCopyToClientBuffer,
    LsapCopyFromClientBuffer,
    LsapImpersonateClient,
    LsapUnloadPackage,
    LsapDuplicateHandle,
    NULL,                       // LsapSaveSupplementalCredentials,
    LsapCreateThread,
    LsapGetClientInfo,
    LsaIRegisterNotification,
    LsaICancelNotification,
    LsapMapClientBuffer,
    LsapCreateToken,
    LsapAuditLogon,
    LsaICallPackage,
    LsaIFreeReturnBuffer,
    LsapGetCallInfo,
    LsaICallPackageEx,
    LsaCreateSharedMemory,
    LsaAllocateSharedMemory,
    LsaFreeSharedMemory,
    LsaDeleteSharedMemory,
    LsaOpenSamUser,
    LsaGetUserCredentials,
    LsaGetUserAuthData,
    LsaCloseSamUser,
    LsaConvertAuthDataToToken,
    LsaClientCallback,
    LsapUpdateCredentials,
    LsaGetAuthDataForUser,
    LsaCrackSingleName,
    LsaIAuditAccountLogon,
    LsaICallPackagePassthrough,
    CrediRead,
    CrediReadDomainCredentials,
    CrediFreeCredentials,
    LsaProtectMemory,
    LsaUnprotectMemory,
    LsapOpenTokenByLogonId,
    LsaExpandAuthDataForDomain,
    LsapAllocatePrivateHeap,
    LsapFreePrivateHeap,
    LsapCreateTokenEx
    };



//+-------------------------------------------------------------------------
//
//  Function:   LsapOpenCaller
//
//  Synopsis:   Opens the calling process
//
//  Effects:
//
//  Arguments:  phProcess   -- receives handle to process
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LsapOpenCaller(
    IN OUT PSession pSession
    )
{
    HANDLE hProcess;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CLIENT_ID ClientId;
    PVOID Ignored ;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = (HANDLE) LongToHandle(pSession->dwProcessID);

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
                &hProcess,
                PROCESS_DUP_HANDLE |        // Duplicate Handles
                    PROCESS_QUERY_INFORMATION | // Get token
                    PROCESS_VM_OPERATION |      // Allocate
                    PROCESS_VM_READ |           // Read memory
                    PROCESS_VM_WRITE,           // Write memory
                &ObjectAttributes,
                &ClientId
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Did not open process %08x, error %08x\n",
            pSession->dwProcessID, Status));

        return( Status );
    }

    pSession->hProcess = hProcess;

    Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessSessionInformation,
                    &pSession->SessionId,
                    sizeof( ULONG ),
                    NULL );

#if _WIN64
    Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessWow64Information,
                    &Ignored,
                    sizeof( Ignored ),
                    NULL );

    if ( NT_SUCCESS( Status ) )
    {
        if ( Ignored != 0 )
        {
            pSession->fSession |= SESFLAG_WOW_PROCESS ;
        }
    }
#endif

    return( STATUS_SUCCESS );

}


//+-------------------------------------------------------------------------
//
//  Function:   CheckCaller
//
//  Synopsis:   Checks if calling process has been opened, opens if it
//              hasn't.
//
//  Effects:
//
//  Arguments:  pSession -  Current session
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CheckCaller(
    IN PSession pSession
    )
{
    NTSTATUS       Status;

    if (!pSession->hProcess)
    {
        Status = LsapOpenCaller(pSession);
        if (FAILED(Status))
        {
            DebugLog((DEB_ERROR, "Could not open client (%x)\n", Status));
            return(Status);
        }

    }
    return(STATUS_SUCCESS);

}




//+-------------------------------------------------------------------------
//
//  Function:   LsapUnloadPackage
//
//  Synopsis:   Unloads the calling package in case of catastrophic problems
//
//  Effects:    Unloads the DLL that generated this call.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Calling thread is terminated through a special exception.
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
LsapUnloadPackage(
    VOID
    )
{
    ULONG_PTR PackageId;
    PSession    pSession = GetCurrentSession();

    PackageId = GetCurrentPackageId();


    //
    // If this is an autonomous thread, we should interrupt any other threads
    // that are currently executing in the DLL.  At this time, I do not know
    // what will happen if the virtual address space of a thread suddenly
    // becomes invalid, or even if that will happen.  We'll find out...
    //

    if (pSession->fSession & SESFLAG_AUTONOMOUS)
    {
        DebugLog((DEB_WARN, "Autonomous thread executed LsapUnloadPackage\n"));
    }

    pSession->fSession |= SESFLAG_UNLOADING;

    RaiseException((ULONG) SEC_E_BAD_PKGID, 0, 0, NULL);

    return(STATUS_SUCCESS);
}



BOOLEAN
LsapHeapInitialize(
    IN BOOLEAN Server
    )
{

    if( !Server )
    {
        NT_PRODUCT_TYPE ProductType;

        if ( RtlGetNtProductType( &ProductType ) &&
             (ProductType == NtProductServer || ProductType == NtProductLanManNt)
             )
        {
            Server = TRUE;
        }
    }

    if ( Server )
    {
        SYSTEM_INFO si;
        DWORD Heaps;
        DWORD i, cHeapsCreated;
        RTL_HEAP_PARAMETERS HeapParameters;

        GetSystemInfo( &si );

        if( si.dwNumberOfProcessors == 0 ) {
            Heaps = 1;
        } else if( si.dwNumberOfProcessors > HEAP_COUNT_MAX )
        {
            Heaps = HEAP_COUNT_MAX;
        } else {
            Heaps = si.dwNumberOfProcessors;
        }

        ZeroMemory( &HeapParameters, sizeof(HeapParameters) );
        HeapParameters.Length = sizeof(HeapParameters);
        HeapParameters.DeCommitTotalFreeThreshold = 8 * LsapPageSize ;

        cHeapsCreated = 0;

        for( i = 0 ; i < Heaps ; i++ )
        {
            gHeaps[ cHeapsCreated ] = RtlCreateHeap(
                                        HEAP_GROWABLE,
                                        NULL,
                                        0,
                                        0,
                                        NULL,
                                        &HeapParameters
                                        );

            if( gHeaps[ cHeapsCreated ] != NULL )
            {
                cHeapsCreated++;
            }
        }

        gcHeaps = cHeapsCreated;
    }


    if( gHeaps[ 0 ] == NULL )
    {
        gHeaps[ 0 ] = RtlProcessHeap();
        gcHeaps = 1;
    }




    return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Function:   LsapAllocateLsaHeap
//
//  Synopsis:   Allocates memory on process heap
//
//  Effects:
//
//  Arguments:  cbMemory    -- Size of block needed
//
//  Requires:
//
//  Returns:    ptr to memory
//
//  Notes:      if DBGMEM or TRACK_MEM defined, extra work is done for
//              tracking purposes.
//
//              Can raise the exception STATUS_NO_MEMORY
//
//              Per object reuse rules of C2 and above, we zero any memory
//              allocated through this function
//
//--------------------------------------------------------------------------
PVOID NTAPI
LsapAllocateLsaHeap(
    IN ULONG cbMemory
    )
{

#if DBG
    if (MemFail.fSimulateFailure)
    {
        TotalAllocations++;
        if ((TotalAllocations > MemFail.FailureDelay) &&
            (TotalAllocations < MemFail.FailureLength + MemFail.FailureDelay))
        {
            if ((TotalAllocations % MemFail.FailureInterval) == 0)
            {
                if ((PackageToFail == SPMGR_ID) ||
                    (GetCurrentPackageId() == PackageToFail))
                {
                    DebugLog((DEB_TRACE,"LsapAllocateLsaHeap: Simulating failure\n"));
                    return(NULL);
                }
            }
        }
    }
#endif // DBG


    return(RtlAllocateHeap(
                RtlProcessHeap(),
                HEAP_ZERO_MEMORY,
                cbMemory
                ));
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeLsaHeap
//
//  Synopsis:   Frees memory allocated by LsapAllocateLsaHeap
//
//  Effects:
//
//  Arguments:  pvMemory
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void NTAPI
LsapFreeLsaHeap(
    IN PVOID pvMemory
    )
{

    RtlFreeHeap(
                RtlProcessHeap(),
                0,
                pvMemory
                );

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapAllocatePrivateHeap
//
//  Synopsis:   Allocates memory on private heap(s)
//
//  Effects:
//
//  Arguments:  cbMemory    -- Size of block needed
//
//  Requires:
//
//  Returns:    ptr to memory
//
//              Per object reuse rules of C2 and above, we zero any memory
//              allocated through this function
//
//--------------------------------------------------------------------------
PVOID
NTAPI
LsapAllocatePrivateHeap(
    IN SIZE_T cbMemory
    )
{
    HANDLE hHeap;

    PHEAP_HEADER_LSA memory;


    hHeap = LsapGetCurrentHeap();

    if( hHeap == NULL )
    {
        static ULONG heapindex;
        ULONG LocalHeapIndex;

        LocalHeapIndex = (ULONG)InterlockedIncrement( (PLONG)&heapindex );
        LocalHeapIndex %= gcHeaps;

        hHeap = gHeaps[ LocalHeapIndex ];

        LsapSetCurrentHeap( hHeap );
    }

    memory = (PHEAP_HEADER_LSA)RtlAllocateHeap(
                hHeap,
                HEAP_ZERO_MEMORY,
                cbMemory+sizeof(HEAP_HEADER_LSA)
                );

    if( memory != NULL )
    {

        memory->hHeap = hHeap;
        memory->Magic = (unsigned char*)HEAP_MAGIC_TAG-(unsigned char*)hHeap;

        return ( (unsigned char*)memory+sizeof(HEAP_HEADER_LSA) );
    }

    DebugLog((DEB_ERROR,"LsapAllocatePrivateHeap: %p failed allocate %lu bytes\n", hHeap, cbMemory));

    return NULL;
}

PVOID
NTAPI
LsapAllocatePrivateHeapNoZero(
    IN SIZE_T cbMemory
    )
{
    HANDLE hHeap;

    PHEAP_HEADER_LSA memory;


    hHeap = LsapGetCurrentHeap();

    if( hHeap == NULL )
    {
        static ULONG heapindex;
        ULONG LocalHeapIndex;

        LocalHeapIndex = (ULONG)InterlockedIncrement( (PLONG)&heapindex );
        LocalHeapIndex %= gcHeaps;

        hHeap = gHeaps[ LocalHeapIndex ];

        LsapSetCurrentHeap( hHeap );
    }

    memory = (PHEAP_HEADER_LSA)RtlAllocateHeap(
                hHeap,
                0,
                cbMemory+sizeof(HEAP_HEADER_LSA)
                );

    if( memory != NULL )
    {
        memory->hHeap = hHeap;
        memory->Magic = (unsigned char*)HEAP_MAGIC_TAG-(unsigned char*)hHeap;

        return ( (unsigned char*)memory+sizeof(HEAP_HEADER_LSA) );
    }

    DebugLog((DEB_ERROR,"LsapAllocatePrivateHeapNoZero: %p failed allocate %lu bytes\n", hHeap, cbMemory));

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapFreePrivateHeap
//
//  Synopsis:   Frees memory allocated by LsapAllocatePrivateHeap
//
//  Effects:
//
//  Arguments:  pvMemory
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
NTAPI
LsapFreePrivateHeap(
    IN PVOID pvMemory
    )
{
    PHEAP_HEADER_LSA HeapEntry;

    if( pvMemory == NULL )
    {
        return ;
    }

    HeapEntry = (PHEAP_HEADER_LSA)((unsigned char*)pvMemory-sizeof(HEAP_HEADER_LSA));

    if( HeapEntry->Magic + ((unsigned char*)HeapEntry->hHeap) != (unsigned char*)HEAP_MAGIC_TAG )
    {
        DebugLog((DEB_ERROR, "LsapFreePrivateHeap tried to free %p from wrong heap\n",
            pvMemory));

        DsysAssert( pvMemory == NULL );
        return;
    }

    RtlFreeHeap(
                HeapEntry->hHeap,
                0,
                HeapEntry
                );

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapClientAllocate
//
//  Synopsis:   Allocates memory in client process
//
//  Effects:
//
//  Arguments:  cbMemory    -- Size of block to allocate
//
//  Requires:
//
//  Returns:    pointer to memory in client address space
//
//  Notes:      pointer is not valid in this process, only in client
//
//--------------------------------------------------------------------------
PVOID NTAPI
LsapClientAllocate(
    IN ULONG cbMemory
    )
{

    NTSTATUS        Status;
    PSession        pSession;
    void *          pClientMemory = NULL;
    SIZE_T          cbMem = cbMemory;
    PLSA_CALL_INFO  CallInfo ;

    CallInfo = LsapGetCurrentCall();

    pSession = GetCurrentSession() ;

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    if ( CallInfo == NULL )
    {
        CallInfo = &LsapDefaultCallInfo ;
    }

    if (FAILED(CheckCaller(pSession)))
    {
        return(NULL);
    }

    //
    // If the INPROC flag is set, allocate out of the heap.  The copy functions
    // will also honor this.
    //

    if ( pSession->fSession & SESFLAG_INPROC )
    {
        pClientMemory = LsapAllocateLsaHeap( (ULONG) cbMem );

        return( pClientMemory );
    }

    if ( CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        if ( ( CallInfo->Flags & CALL_FLAG_KMAP_USED ) != 0 )
        {

            pClientMemory = LsapAllocateFromKsecBuffer(
                                CallInfo->KMap,
                                (ULONG) cbMem );

            DebugLog((DEB_TRACE_HELPERS, "[%x] LsapClientAllocate(%d) = %p in KMap %p\n",
                        pSession->dwProcessID, cbMem,
                        pClientMemory, CallInfo->KMap ));
            
            return pClientMemory ;
        }

        
        
    }

    Status = NtAllocateVirtualMemory(pSession->hProcess,
                                    &pClientMemory,
                                    0,
                                    &cbMem,
                                    MEM_COMMIT,
                                    PAGE_READWRITE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "[%x] Could not allocate client memory (%x)\n",
                        pSession->dwProcessID, Status));

        pClientMemory = NULL;
    }


    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapClientAllocate(%d) = %p\n",
                    pSession->dwProcessID, cbMemory, pClientMemory));

    if ( pClientMemory )
    {
        // Save pointer so that FreeContextBuffer will use
        // correct 'free' function.
        if(CallInfo->Allocs < MAX_BUFFERS_IN_CALL)
        {
            CallInfo->Buffers[ CallInfo->Allocs++ ] = pClientMemory ;
        }
    }

    return(pClientMemory);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCopyToClient
//
//  Synopsis:   Copies data into client process
//
//  Effects:
//
//  Arguments:  pLocalMemory    -- pointer to data in this process
//              pClientMemory   -- pointer to destination in client process
//              cbMemory        -- how much to copy
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapCopyToClient(
    IN PVOID pLocalMemory,
    OUT PVOID pClientMemory,
    IN ULONG cbMemory
    )
{
    NTSTATUS     Status;
    PSession    pSession;
    PLSA_CALL_INFO CallInfo;
    PKSEC_LSA_MEMORY_HEADER Header ;
    ULONG i ;
    ULONG_PTR Basis ;
    ULONG_PTR Limit ;
    BOOL Tried = FALSE ;

    if (cbMemory == 0)
    {
        return(STATUS_SUCCESS);
    }

    pSession = GetCurrentSession();

    if ( !pSession )
    {
        pSession = pDefaultSession ;
    }

    CallInfo = LsapGetCurrentCall();

    if ( ( pLocalMemory == NULL ) ||
         ( pClientMemory == NULL ) )
    {
        return STATUS_ACCESS_VIOLATION ;
    }

    if (FAILED(Status = CheckCaller(pSession)))
    {
        return(Status);
    }

    //
    // Cases for a direct copy: 
    //
    //  - The current session is the default session
    //  - This is an inproc call
    //  - We're using a KMap buffer
    //

    
    if (CallInfo &&
        CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {

        Header = CallInfo->KMap ;

        if ( (ULONG_PTR) pClientMemory > LsapUserModeLimit )
        {
            //
            // Someone is trying to deal with a pool address directly.
            // we can handle this if it was copied into the KMap already
            //

            for ( i = 0 ; i < Header->MapCount ; i++ )
            {
                Limit  = (ULONG_PTR) Header->PoolMap[ i ].Pool + Header->PoolMap[ i ].Size ;

                if ( ((ULONG_PTR) pClientMemory >= (ULONG_PTR) Header->PoolMap[ i ].Pool ) &&
                    ( (ULONG_PTR) pClientMemory < Limit ) )
                {
                    //
                    // Found an overlap, this is promising.  Check the bounds:
                    //

                    Basis = (ULONG_PTR) pClientMemory - 
                                (ULONG_PTR) Header->PoolMap[ i ].Pool ;

                    if (  Basis + cbMemory <= Header->PoolMap[ i ].Size )
                    {
                        //
                        // Found it!
                        //
                        __try
                        {
                            RtlCopyMemory(
                                (PUCHAR) Header + 
                                        (Header->PoolMap[ i ].Offset +
                                         Basis),
                                pLocalMemory,
                                cbMemory );


                            Status = STATUS_SUCCESS ;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            Status = GetExceptionCode();
                        }

                        
                    }
                    Tried = TRUE ;
                    break;
                    
                }
                
            }

            if ( !Tried )
            {
                Status = STATUS_ACCESS_VIOLATION ;
                
            }
            
        }
        else if ( LsapIsBlockInKMap( CallInfo->KMap, pClientMemory ) )
        {
            __try
            {

                RtlCopyMemory( pClientMemory, pLocalMemory, cbMemory );

                Status = STATUS_SUCCESS ;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetExceptionCode();
            }
            
        }
        else
        {

            Status = NtWriteVirtualMemory(pSession->hProcess,
                                        pClientMemory,
                                        pLocalMemory,
                                        cbMemory,
                                        NULL);
        }
        
    } else if ( (pSession->dwProcessID == pDefaultSession->dwProcessID) ||
         (pSession->fSession & SESFLAG_INPROC) ||
         (CallInfo->Flags & CALL_FLAG_KMAP_USED ) )
    {
        __try
        {

            RtlCopyMemory( pClientMemory, pLocalMemory, cbMemory );

            Status = STATUS_SUCCESS ;
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            Status = GetExceptionCode();
        }
    }
    else
    {

        Status = NtWriteVirtualMemory(  pSession->hProcess,
                                        pClientMemory,
                                        pLocalMemory,
                                        cbMemory,
                                        NULL);
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapCopyToClient(%p, %p, %d) = %x\n",
                pSession->dwProcessID, pLocalMemory, pClientMemory, cbMemory,
                Status ));

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapCopyFromClient
//
//  Synopsis:   Copies memory from client to this process
//
//  Effects:
//
//  Arguments:  pClientMemory   -- Pointer to data in client space
//              pLocalMemory    -- Pointer to destination in this process
//              cbMemory        -- How much
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapCopyFromClient(
    IN PVOID pClientMemory,
    OUT PVOID pLocalMemory,
    IN ULONG cbMemory
    )
{
    NTSTATUS       Status;
    PSession    pSession;
    PLSA_CALL_INFO CallInfo ;
    PKSEC_LSA_MEMORY_HEADER Header ;
    ULONG i ;
    ULONG_PTR Basis ;
    ULONG_PTR Limit ;
    BOOL Tried = FALSE ;



    if (cbMemory == 0)
    {
        return(STATUS_SUCCESS);
    }

    if ( ( pClientMemory == NULL ) ||
         ( pLocalMemory == NULL ) )
    {
        return STATUS_ACCESS_VIOLATION ;
    }


    pSession = GetCurrentSession();

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    CallInfo = LsapGetCurrentCall();

    if (FAILED(Status = CheckCaller(pSession)))
    {
        return(Status);
    }

    if (CallInfo &&
        CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {

        Header = CallInfo->KMap ;

        if ( (ULONG_PTR) pClientMemory > LsapUserModeLimit )
        {
            //
            // Someone is trying to deal with a pool address directly.
            // we can handle this if it was copied into the KMap already
            //

            for ( i = 0 ; i < Header->MapCount ; i++ )
            {
                Limit  = (ULONG_PTR) Header->PoolMap[ i ].Pool + Header->PoolMap[ i ].Size ;

                if ( ((ULONG_PTR) pClientMemory >= (ULONG_PTR) Header->PoolMap[ i ].Pool ) &&
                    ( (ULONG_PTR) pClientMemory < Limit ) )
                {
                    //
                    // Found an overlap, this is promising.  Check the bounds:
                    //

                    Basis = (ULONG_PTR) pClientMemory - 
                                (ULONG_PTR) Header->PoolMap[ i ].Pool ;

                    if (  Basis + cbMemory <= Header->PoolMap[ i ].Size )
                    {
                        //
                        // Found it!
                        //
                        __try
                        {
                            RtlCopyMemory(
                                pLocalMemory,
                                (PUCHAR) Header + 
                                        (Header->PoolMap[ i ].Offset +
                                         Basis),
                                cbMemory );


                            Status = STATUS_SUCCESS ;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            Status = GetExceptionCode();
                        }

                        
                    }
                    Tried = TRUE ;
                    break;
                    
                }
                
            }

            if ( !Tried )
            {
                Status = STATUS_ACCESS_VIOLATION ;
                
            }
            
        }
        else if ( LsapIsBlockInKMap( CallInfo->KMap, pClientMemory ) )
        {
            __try
            {

                RtlCopyMemory( pLocalMemory, pClientMemory, cbMemory );

                Status = STATUS_SUCCESS ;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetExceptionCode();
            }
            
        }
        else
        {

            Status = NtReadVirtualMemory(pSession->hProcess,
                                        pClientMemory,
                                        pLocalMemory,
                                        cbMemory,
                                        NULL);
        }
        
    }
    else if ( (pSession->dwProcessID == pDefaultSession->dwProcessID) ||
         (pSession->fSession & SESFLAG_INPROC ) )
    {
        __try
        {

            RtlCopyMemory( pLocalMemory, pClientMemory, cbMemory );

            Status = STATUS_SUCCESS ;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetExceptionCode();
        }
    }
    else
    {

        Status = NtReadVirtualMemory(pSession->hProcess,
                                    pClientMemory,
                                    pLocalMemory,
                                    cbMemory,
                                    NULL);
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapCopyFromClient(%p, %p, %d) = %x\n",
                pSession->dwProcessID, pClientMemory, pLocalMemory, cbMemory,
                Status));


    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsapClientFree
//
//  Synopsis:   Frees memory allocated in client space
//
//  Effects:
//
//  Arguments:  pClientMemory   -- pointer to memory to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapClientFree(
    IN PVOID pClientMemory
    )
{
    NTSTATUS       Status;
    SIZE_T         cbMem = 0;
    PSession    pSession;
    PLSA_CALL_INFO  CallInfo ;

    CallInfo = LsapGetCurrentCall();
    if ( CallInfo == NULL )
    {
        CallInfo = &LsapDefaultCallInfo ;
    }

    if (!pClientMemory)
    {
        return(STATUS_SUCCESS);
    }

    pSession = GetCurrentSession();

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    if (FAILED(Status = CheckCaller(pSession)))
    {
        return(Status);
    }

    if ( pSession->fSession & SESFLAG_INPROC )
    {
        LsapFreeLsaHeap( pClientMemory );

        return( STATUS_SUCCESS );
    }

#if DBG
    if ( pSession->dwProcessID == pDefaultSession->dwProcessID )
    {
        DebugLog(( DEB_ERROR, "Freeing VM in LSA:  %x\n", pClientMemory ));
    }
#endif

    Status = NtFreeVirtualMemory(pSession->hProcess,
                                &pClientMemory,
                                &cbMem,
                                MEM_RELEASE);



    if ( pClientMemory )
    {
        ULONG i;

        // Remove this pointer from our list.
        for(i = 0; i < CallInfo->Allocs; i++)
        {
            if(CallInfo->Buffers[i] == pClientMemory)
            {
                if(i < CallInfo->Allocs - 1)
                {
                    memcpy(&CallInfo->Buffers[i],
                           &CallInfo->Buffers[i+1],
                           sizeof(PVOID) * (CallInfo->Allocs - i - 1));
                }
                CallInfo->Allocs--;
                break;
            }
        }
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapClientFree(%x) == %x\n",
            pSession->dwProcessID, pClientMemory, Status));

    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateHandle
//
//  Synopsis:   Duplicates a handle to an NT object into the calling process
//
//  Effects:    A new handle is generated, referencing the object
//
//  Arguments:  hObject     -- handle to the object
//              hNewObject  -- New handle valid in calling process
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapDuplicateHandle(
    IN HANDLE hObject,
    OUT PHANDLE phNewObject
    )

{
    NTSTATUS     Status;
    PSession    pSession;

    pSession = GetCurrentSession();

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    if (Status = CheckCaller(pSession))
    {
        DebugLog((DEB_ERROR, "CheckCaller returned %d\n", Status));
        return(Status);
    }
    Status = NtDuplicateObject(  NtCurrentProcess(),
                                hObject,
                                pSession->hProcess,
                                phNewObject,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS);


    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapDupHandle(%x, %x (@%x)) = %x\n",
            pSession->dwProcessID, hObject, *phNewObject, phNewObject, Status));

    return(Status);
}



//+---------------------------------------------------------------------------
//
//  Function:   LsapImpersonateClient
//
//  Synopsis:   Impersonate the client of the API call.
//
//  Arguments:  (none)
//
//  History:    6-05-95   RichardW   Created
//
//  Notes:      Threads should call RevertToSelf() when done.
//
//----------------------------------------------------------------------------
NTSTATUS NTAPI
LsapImpersonateClient(
    VOID
    )
{
    PSession            pSession;
    PLSA_CALL_INFO      CallInfo ;
    PSPM_LPC_MESSAGE    pApiMessage;
    NTSTATUS            Status;


    CallInfo = LsapGetCurrentCall() ;

    if ( CallInfo->InProcCall )
    {
        if ( CallInfo->InProcToken )
        {
            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID) &CallInfo->InProcToken,
                        sizeof(HANDLE)
                        );
        }
        else
        {
            Status = RtlImpersonateSelf(SecurityImpersonation);
        }
    }
    else
    {
        pSession = GetCurrentSession() ;

        if ( !pSession )
        {
            pSession = pDefaultSession ;
        }

        Status = NtImpersonateClientOfPort(
                    pSession->hPort,
                    (PPORT_MESSAGE) CallInfo->Message);
    }

    return(Status);
}






//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateString
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LsapDuplicateString(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    )

{
    pDest->Length = 0;
    if (pSrc == NULL)
    {
        pDest->Buffer = NULL;
        pDest->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    pDest->Buffer = (LPWSTR) LsapAllocateLsaHeap(pSrc->Length + sizeof(WCHAR));
    if (pDest->Buffer)
    {
        pDest->MaximumLength = pSrc->Length + sizeof(WCHAR);
        RtlCopyMemory(
            pDest->Buffer,
            pSrc->Buffer,
            pSrc->Length
            );
        pDest->Buffer[pSrc->Length/sizeof(WCHAR)] = L'\0';
        pDest->Length = pSrc->Length;
        return(STATUS_SUCCESS);

    } else
    {
        pDest->MaximumLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

}

NTSTATUS
LsapDuplicateString2(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    )
/*++

    Same as LsapDuplicateString(), but uses LsapPrivateHeap routines.

--*/
{
    pDest->Length = 0;
    if (pSrc == NULL)
    {
        pDest->Buffer = NULL;
        pDest->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    pDest->Buffer = (LPWSTR) LsapAllocatePrivateHeap(pSrc->Length + sizeof(WCHAR));
    if (pDest->Buffer)
    {
        pDest->MaximumLength = pSrc->Length + sizeof(WCHAR);
        RtlCopyMemory(
            pDest->Buffer,
            pSrc->Buffer,
            pSrc->Length
            );
        pDest->Buffer[pSrc->Length/sizeof(WCHAR)] = L'\0';
        pDest->Length = pSrc->Length;
        return(STATUS_SUCCESS);

    } else
    {
        pDest->MaximumLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeString
//
//  Synopsis:   Frees a string allocated by LsapDuplicateString
//
//  Effects:
//
//  Arguments:  String - Optionally points to a UNICODE_STRING
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapFreeString(
    IN OPTIONAL PUNICODE_STRING String
    )
{
    if (ARGUMENT_PRESENT(String) && String->Buffer != NULL)
    {
        LsapFreeLsaHeap(String->Buffer);
        String->Buffer = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapThreadBase
//
//  Synopsis:   Thread start routine
//
//  Effects:    Sets up all the TLS data for a thread, then executes
//              the "real" base function.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

void
LsapThreadBase(
    PLSAP_THREAD_START pThread)
{
    NTSTATUS Status;
    PSession        pSession;
    LSAP_THREAD_START tStart = *pThread;

    LsapFreePrivateHeap(pThread);

    SetCurrentSession( pDefaultSession );

    SpmpReferenceSession( pDefaultSession );

    // Initialize Session information:

    SetCurrentPackageId(tStart.dwPackageID);


    DebugLog((DEB_TRACE, "Thread start @%x\n", tStart.lpStart));

    // If this is a debug build, all threads are started in a protective
    // try-except block.  For retail, only threads started by packages
    // will be run this way.  Retail builds, we assume that the SPM is
    // debugged and running correctly, and threads started this way can
    // be trusted.

#if DBG == 0
    if (tStart.dwPackageID != SPMGR_ID)
#endif
    {
        __try
        {
            tStart.lpStart(tStart.lpParm);
        }
        __except (SP_EXCEPTION)
        {
            Status = GetExceptionCode();
            Status = SPException(Status, tStart.dwPackageID);
        }
    }
#if DBG == 0
    else
    {
        tStart.lpStart(tStart.lpParm);
    }
#endif

    pSession = GetCurrentSession();

    SpmpDereferenceSession( pSession );

    if ( pSession != pDefaultSession )
    {
        DebugLog(( DEB_ERROR, "Thread completing in session other than default!\n" ));
    }

    DebugLog((DEB_TRACE, "Thread exit\n" ));

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCreateThread
//
//  Synopsis:   Creates a thread with all the proper Tls stuff
//
//  Effects:
//
//  Arguments:  same as CreateThread
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
HANDLE NTAPI
LsapCreateThread(
    IN LPSECURITY_ATTRIBUTES lpSA,
    IN ULONG cbStack,
    IN LPTHREAD_START_ROUTINE lpStart,
    IN LPVOID lpvThreadParm,
    IN ULONG fCreate,
    OUT PULONG lpTID
    )
{
    PLSAP_THREAD_START pThread;
    HANDLE hThread;

    pThread = (PLSAP_THREAD_START) LsapAllocatePrivateHeap(sizeof(LSAP_THREAD_START));
    if (pThread == NULL)
    {
        DebugLog((DEB_ERROR, "LsapCreateThread, memory allocation failed.\n"));
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    pThread->lpStart = lpStart;
    pThread->lpParm = lpvThreadParm;
    pThread->dwPackageID = GetCurrentPackageId();

    hThread = CreateThread(
                        lpSA,
                        cbStack,
                        (LPTHREAD_START_ROUTINE) LsapThreadBase,
                        pThread,
                        fCreate,
                        lpTID
                        );

    if( hThread == NULL )
    {
        DebugLog((DEB_ERROR, "LsapCreateThread, failed thread creation (%lu)\n", GetLastError()));

        LsapFreePrivateHeap( pThread );
    }

    return hThread;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapGetClientInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapGetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    )
{
    PSession pSession = GetCurrentSession();
    PPORT_MESSAGE pMessage;
    HANDLE ClientToken;
    NTSTATUS Status;
    NTSTATUS ExtraStatus ;
    TOKEN_STATISTICS TokenStats;
    ULONG TokenStatsSize = sizeof(TOKEN_STATISTICS);
    PLSA_CALL_INFO CallInfo ;
    HANDLE Thread = NULL ;
    OBJECT_ATTRIBUTES NullAttributes = { 0 };
    KERNEL_USER_TIMES Times ;


    RtlZeroMemory(
        ClientInfo,
        sizeof(SECPKG_CLIENT_INFO)
        );

    if ( !pSession )
    {
        pSession = pDefaultSession ;
    }

    //
    // First, fill in the easy stuff from the session record. If we are
    // running with the LSA session then we want to ignore the LPC message
    // because it may be referring to somebody elses message (we may be
    // being called on behalf of someone doing authenticated RPC in response
    // to an LPC request)
    //

    CallInfo = LsapGetCurrentCall();

    if ( CallInfo )
    {
        ClientInfo->ProcessID  = CallInfo->CallInfo.ProcessId ;
        ClientInfo->ThreadID = CallInfo->CallInfo.ThreadId ;

        if (((pSession->fSession & SESFLAG_TCB_PRIV) != 0) ||
            ((pSession->fSession & SESFLAG_KERNEL) != 0))
        {
            ClientInfo->HasTcbPrivilege = TRUE;
        }
        else
        {
            ClientInfo->HasTcbPrivilege = FALSE;
        }

        if(CallInfo->CachedTokenInfo)
        {
            ClientInfo->LogonId = CallInfo->LogonId;
            ClientInfo->Restricted = CallInfo->Restricted;
            ClientInfo->Impersonating = CallInfo->Impersonating;
            ClientInfo->ImpersonationLevel = CallInfo->ImpersonationLevel;
        
            return STATUS_SUCCESS;
        }

        Status = LsapImpersonateClient();


        if ( !NT_SUCCESS( Status ) )
        {
            if ( Status == STATUS_BAD_IMPERSONATION_LEVEL )
            {
                Status = NtOpenThread(
                            &Thread,
                            THREAD_QUERY_INFORMATION,
                            &NullAttributes,
                            &CallInfo->Message->pmMessage.ClientId );
            }
            else if ( ( Status == STATUS_REPLY_MESSAGE_MISMATCH ) ||
                      ( Status == STATUS_INVALID_CID ) ||
                      ( Status == STATUS_PORT_DISCONNECTED ) )
            {
                //
                // This is a special status returned by the LPC layer to indicate
                // that the client thread has disappeared, or the process is 
                // terminating.  Set a flag to indicate this:
                //
                
                ClientInfo->ClientFlags |= SECPKG_CLIENT_THREAD_TERMINATED ;

                CallInfo->CallInfo.Attributes |= SECPKG_CALL_THREAD_TERM ;
                //
                // Check the process.  If the process has started to exit, set that
                // flag as well.
                //

                ExtraStatus = NtQueryInformationProcess(
                                pSession->hProcess,
                                ProcessTimes,
                                &Times,
                                sizeof( Times ),
                                NULL );

                if ( NT_SUCCESS( ExtraStatus ) )
                {
                    if ( Times.ExitTime.QuadPart != 0 )
                    {
                        ClientInfo->ClientFlags |= SECPKG_CLIENT_PROCESS_TERMINATED ;
                        CallInfo->CallInfo.Attributes |= SECPKG_CALL_PROCESS_TERM ;
                    }
                }

                DebugLog(( DEB_TRACE, "Client %x.%x has terminated\n",
                           ClientInfo->ProcessID, ClientInfo->ThreadID ));

                return STATUS_SUCCESS ;
            }

        }
        else
        {
            Thread = NtCurrentThread();
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to impersonate client: 0x%x\n",Status));
            return(Status);
        }

        Status = NtOpenThreadToken(
                    Thread,
                    TOKEN_QUERY,
                    TRUE,               // use LSA security context
                    &ClientToken
                    );
        if (NT_SUCCESS(Status))
        {
            ClientInfo->Restricted = ( IsTokenRestricted(ClientToken) != 0 );

            Status = NtQueryInformationToken(
                        ClientToken,
                        TokenStatistics,
                        (PVOID) &TokenStats,
                        TokenStatsSize,
                        &TokenStatsSize
                        );
            NtClose(ClientToken);
            if (NT_SUCCESS(Status))
            {
                ClientInfo->LogonId = TokenStats.AuthenticationId;
                ClientInfo->Impersonating = (TokenStats.TokenType == TokenPrimary) ? FALSE : TRUE;
                if( ClientInfo->Impersonating )
                {
                    ClientInfo->ImpersonationLevel = TokenStats.ImpersonationLevel;
                } else {
                    ClientInfo->ImpersonationLevel = SecurityImpersonation;
                }
            }
        }
        RevertToSelf();
        if ( Thread != NtCurrentThread() )
        {
            NtClose( Thread );
        }
        

        if(NT_SUCCESS(Status))
        {
            CallInfo->LogonId = ClientInfo->LogonId;
            CallInfo->Restricted = ClientInfo->Restricted;
            CallInfo->Impersonating = ClientInfo->Impersonating;
            CallInfo->ImpersonationLevel = ClientInfo->ImpersonationLevel;
            CallInfo->CachedTokenInfo = TRUE;
        }

        return(Status);

    }
    else
    {
        ClientInfo->ProcessID = GetCurrentProcessId();
        ClientInfo->ThreadID = GetCurrentThreadId();
        ClientInfo->HasTcbPrivilege = TRUE;
        ClientInfo->Impersonating = FALSE;
        ClientInfo->ImpersonationLevel = SecurityImpersonation;
        ClientInfo->LogonId = SystemLogonId;
        return(STATUS_SUCCESS);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapGetCallInfo
//
//  Synopsis:   Gets call information
//
//  Arguments:  [Info] --
//
//  History:    10-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
LsapGetCallInfo(
    PSECPKG_CALL_INFO   Info
    )
{
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall() ;

    if ( CallInfo )
    {
        *Info = CallInfo->CallInfo ;
        if ( CallInfo->InProcCall )
        {
            Info->Attributes |= SECPKG_CALL_IN_PROC ;
        }

        return TRUE ;
    } else {
        Info->ProcessId = GetCurrentProcessId();
        Info->ThreadId = GetCurrentThreadId();
        Info->Attributes = SECPKG_CALL_IN_PROC |
                                SECPKG_CALL_IS_TCB ;
        Info->CallCount = 0;

        return TRUE;
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapMapClientBuffer
//
//  Synopsis:   Maps a client's SecBuffer into the caller's address space
//
//  Effects:    Clears the SECBUFFER_UNMAPPED field of the BufferType of
//              the return SecBuffer
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Doesn't modify pOutput until the end, so it is o.k. to pass
//              the same thing for pInput and pOutput.
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapMapClientBuffer(
    IN PSecBuffer pInput,
    OUT PSecBuffer pOutput
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    SecBuffer Output ;
    Output = *pInput ;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // If the buffer is already mapped or it doesn't exist (is NULL) we
    // are done.
    //

    if (!(pInput->BufferType & SECBUFFER_UNMAPPED) ||
        !pInput->pvBuffer)
    {
        return( STATUS_SUCCESS );
    }
    else
    {
        Output.BufferType &= ~SECBUFFER_UNMAPPED;
    }

    if ( pInput->BufferType & SECBUFFER_KERNEL_MAP )
    {
        //
        // This one is already in process space
        //

        if ( ( CallInfo->CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) == 0 )
        {
            //
            // If this call did not come from kernel mode with
            // the kernel-pool flag set, then this is an attempted
            // hack on the LSA.  Reject it.
            //

            Status = STATUS_ACCESS_VIOLATION ;
            
        }
        else
        {
            //
            // The buffer is already in memory.  Mark the call as 
            // using kernel-pool memory, so we allocate correctly
            // on the return.
            //

            CallInfo->Flags |= CALL_FLAG_KERNEL_POOL ;
            DebugLog((DEB_TRACE_SPECIAL, "Kernel Pool Map at %p [%x,%x]\n", 
                        Output.pvBuffer, Output.BufferType, Output.cbBuffer ));
        }
            
        
    }
    else
    {
        Output.pvBuffer = LsapAllocateLsaHeap( Output.cbBuffer );

        if ( Output.pvBuffer != NULL )
        {
            Status = LsapCopyFromClient(
                pInput->pvBuffer,
                Output.pvBuffer,
                Output.cbBuffer );

            if ( !NT_SUCCESS( Status ) )
            {
                LsapFreeLsaHeap(Output.pvBuffer);
            }
            
        }
        else
        {

            Status = STATUS_NO_MEMORY ;
        }
        

    }

    if ( NT_SUCCESS( Status ) )
    {
        *pOutput = Output ;
        
    }

    return( Status );
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaICallPackage
//
//  Synopsis:   Function to call another security package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{

    return LsaICallPackageEx( AuthenticationPackage,
                              ProtocolSubmitBuffer,   // client buffer base is same as local buffer
                              ProtocolSubmitBuffer,
                              SubmitBufferLength,
                              ProtocolReturnBuffer,
                              ReturnBufferLength,
                              ProtocolStatus );

}

//+-------------------------------------------------------------------------
//
//  Function:   LsaICallPackageEx
//
//  Synopsis:   Function to call another security package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LsaICallPackageEx(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_SECURITY_PACKAGE Package;
    PSession OldSession;

    Package = SpmpLookupPackageAndRequ