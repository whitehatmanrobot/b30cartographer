(((sp)+50)/100-dm)<15&&(((sp)+50)/100-dm)>-15)
#define DM_PAPER_WL         (DM_PAPERWIDTH | DM_PAPERLENGTH)

#define JOB_CANCEL_CHECK_INTERVAL   2000    // 2 seconds
#define MAX_RETRY_INVALID_HANDLE    2       // 2 retries

LONG
CallCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )
/*++

Routine Description:

    This function dymically load the compstui.dll and call its entry


Arguments:

    pfnPropSheetUI  - Pointer to callback function

    lParam          - lParam for the pfnPropSheetUI

    pResult         - pResult for the CommonPropertySheetUI


Return Value:

    LONG    - as describe in compstui.h


Author:

    01-Nov-1995 Wed 13:11:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HINSTANCE           hInstCPSUI;
    FARPROC             pProc;
    LONG                Result = ERR_CPSUI_GETLASTERROR;

    //
    // ONLY need to call the ANSI version of LoadLibrary
    //

    if ((hInstCPSUI = LoadLibraryA(szCompstuiDll)) &&
        (pProc = GetProcAddress(hInstCPSUI, szCommonPropertySheetUIW))) {

        RpcTryExcept {

            Result = (LONG)((*pProc)(hWndOwner, pfnPropSheetUI, lParam, pResult));

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            Result = ERR_CPSUI_GETLASTERROR;

        } RpcEndExcept

    }

    if (hInstCPSUI) {

        FreeLibrary(hInstCPSUI);
    }

    return(Result);
}


// Simple for Now !!!

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
)
{
    switch (ExceptionCode) {

    case EXCEPTION_ACCESS_VIOLATION:
    case EXCEPTION_DATATYPE_MISALIGNMENT:
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
    case EXCEPTION_INT_OVERFLOW:
    case EXCEPTION_PRIV_INSTRUCTION:
    case ERROR_NOACCESS:
    case RPC_S_INVALID_BOUND:

        return ERROR_INVALID_PARAMETER;
        break;
    default:
        return ExceptionCode;
    }
}

BOOL
EnumPrintersW(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pPrinterEnum)
            memset(pPrinterEnum, 0, cbBuf);

        if (ReturnValue = RpcEnumPrinters(Flags, Name, Level, pPrinterEnum, cbBuf,
                                          pcbNeeded, pcReturned)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPrinterEnum) {

                ReturnValue = MarshallUpStructuresArray(pPrinterEnum, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
ResetPrinterW(
    HANDLE   hPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    BOOL  ReturnValue = FALSE;
    DEVMODE_CONTAINER    DevModeContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwFlags = 0;
    LPWSTR pDatatype = NULL;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    if( !UpdatePrinterDefaults( pSpool, NULL, pDefault )){
        goto Done;
    }

    if (pDefault && pDefault->pDatatype) {
        if (pDefault->pDatatype == (LPWSTR)-1) {
            pDatatype = NULL;
            dwFlags |=  RESET_PRINTER_DATATYPE;
        } else {
            pDatatype = pDefault->pDatatype;
        }
    } else {
        pDatatype = NULL;
    }

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    if( pDefault ){

        if (pDefault->pDevMode == (LPDEVMODE)-1) {

            dwFlags |= RESET_PRINTER_DEVMODE;

        } else if( bValidDevModeW( pDefault->pDevMode )){

            DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                     pDefault->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
        }
    }


    do {

        RpcTryExcept {

            if (ReturnValue = RpcResetPrinterEx(pSpool->hPrinter,
                                             pDatatype, &DevModeContainer,
                                             dwFlags
                                             )) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:

    vUnprotectHandle( hPrinter );

    return ReturnValue;
}

BOOL
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL  ReturnValue = FALSE;
    GENERIC_CONTAINER   GenericContainer;
    GENERIC_CONTAINER *pGenericContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    switch (Level) {

    case 0:
        break;

    case 1:
    case 2:
    case 3:
        if (!pJob) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        RpcTryExcept {

            if (pJob) {

                GenericContainer.Level = Level;
                GenericContainer.pData = pJob;
                pGenericContainer = &GenericContainer;

            } else

                pGenericContainer = NULL;

            if (bLoadedBySpooler && fpYSetJob && pSpool->hSplPrinter) {
                ReturnValue = (*fpYSetJob)(pSpool->hSplPrinter, 
                                           JobId,
                                           (JOB_CONTAINER *)pGenericContainer,
                                           Command,
                                           NATIVE_CALL);
            }
            else {
                ReturnValue = RpcSetJob(pSpool->hPrinter, 
                                        JobId,
                                        (JOB_CONTAINER *)pGenericContainer,
                                        Command);
            }

            if (ReturnValue != ERROR_SUCCESS) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;
            } else {
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    SIZE_T  cbStruct;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if (ReturnValue = RpcGetJob(pSpool->hPrinter, JobId, Level, pJob, cbBuf,
                                        pcbNeeded)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = MarshallUpStructure(pJob, pFieldInfo, cbStruct, RPC_CALL);
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


BOOL
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if (ReturnValue = RpcEnumJobs(pSpool->hPrinter, FirstJob, NoJobs, Level, pJob,
                                          cbBuf, pcbNeeded, pcReturned)) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = MarshallUpStructuresArray(pJob, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

Done:
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

HANDLE
AddPrinterW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
)
{
    DWORD  ReturnValue;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    HANDLE  hPrinter;
    PSPOOL  pSpool = NULL;
    PVOID   pNewSecurityDescriptor = NULL;
    SECURITY_DESCRIPTOR_CONTROL SecurityDescriptorControl = 0;
    PPRINTER_INFO_2             pPrinterInfo = (PPRINTER_INFO_2)pPrinter;

    switch (Level) {

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return NULL;
    }

    if ( !pPrinter ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SecurityContainer.cbBuf = 0;
    SecurityContainer.pSecurity = NULL;

    if (Level == 2) {

        //
        // If valid (non-NULL and properly formatted), then update the
        // global DevMode (not per-user).
        //
        if( bValidDevModeW( pPrinterInfo->pDevMode )){

            DevModeContainer.cbBuf = pPrinterInfo->pDevMode->dmSize +
                                     pPrinterInfo->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo->pDevMode;

        }

        if (pPrinterInfo->pSecurityDescriptor) {

            DWORD   sedlen = 0;

            //
            // We must construct a self relative security descriptor from
            // whatever we get as input: If we get an Absolute SD we should
            // convert it to a self-relative one. (this is a given) and we
            // should also convert any self -relative input SD into a a new
            // self relative security descriptor; this will take care of
            // any holes in the Dacl or the Sacl in the self-relative sd
            //
            pNewSecurityDescriptor = BuildInputSD(
                                         pPrinterInfo->pSecurityDescriptor,
                                         &sedlen);

            if (pNewSecurityDescriptor) {
                SecurityContainer.cbBuf = sedlen;
                SecurityContainer.pSecurity = pNewSecurityDescriptor;

            }
        }
    }

    RpcTryExcept {

        if (ReturnValue = RpcAddPrinter(pName,
                                    (PPRINTER_CONTAINER)&PrinterContainer,
                                    (PDEVMODE_CONTAINER)&DevModeContainer,
                                    (PSECURITY_CONTAINER)&SecurityContainer,
                                    &hPrinter)) {
            SetLastError(ReturnValue);
            hPrinter = FALSE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        hPrinter = FALSE;

    } RpcEndExcept

    if (hPrinter) {

        WCHAR szFullPrinterName[MAX_UNC_PRINTER_NAME];
        szFullPrinterName[0] = 0;

        pSpool = AllocSpool();

        if( pPrinterInfo->pServerName ){
            wcscpy( szFullPrinterName, pPrinterInfo->pServerName );
            wcscat( szFullPrinterName, L"\\" );
        }

        wcscat( szFullPrinterName, pPrinterInfo->pPrinterName );

        if ( pSpool &&
             UpdatePrinterDefaults( pSpool, szFullPrinterName, NULL ) &&
             ( !DevModeContainer.pDevMode ||
               WriteCurDevModeToRegistry(pPrinterInfo->pPrinterName,
                                         (LPDEVMODEW)DevModeContainer.pDevMode)) ) {

            pSpool->hPrinter = hPrinter;

            //
            // Update the access.
            //
            pSpool->Default.DesiredAccess = PRINTER_ALL_ACCESS;

        } else {

            RpcDeletePrinter(hPrinter);
            RpcClosePrinter(&hPrinter);
            FreeSpool(pSpool);
            pSpool = NULL;
        }
    }

    //
    // Free Memory allocated for the SecurityDescriptor
    //

    if (pNewSecurityDescriptor) {
        LocalFree(pNewSecurityDescriptor);
    }

    //
    // Some apps check for last error instead of return value
    // and report failures even if the return handle is not NULL.
    // For success case, set last error to ERROR_SUCCESS.
    //
    if (pSpool) {
        SetLastError(ERROR_SUCCESS);
    }
   return pSpool;
}

BOOL
DeletePrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    do {
        RpcTryExcept {

            if (ReturnValue = RpcDeletePrinter(pSpool->hPrinter)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                DeleteCurDevModeFromRegistry(pSpool->pszPrinter);
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}



BOOL
SpoolerPrinterEventNative(
    LPWSTR  pName,
    INT     PrinterEvent,
    DWORD   Flags,
    LPARAM  lParam
)
/*++

    //
    //  Some printer drivers, like the FAX driver want to do per client
    //  initialization at the time a connection is established
    //  For example in the FAX case they want to push up UI to get all
    //  the client info - Name, Number etc.
    //  Or they might want to run Setup, in initialize some other components
    //  Thus on a successful conenction we call into the Printer Drivers UI
    //  DLL to give them this oportunity
    //
    //                                                      mattfe may 1 96
--*/
{
    BOOL    ReturnValue = FALSE;
    HANDLE  hPrinter;
    HANDLE  hModule;
    INT_FARPROC pfn;

    if (OpenPrinter((LPWSTR)pName, &hPrinter, NULL)) {

        if (hModule = LoadPrinterDriver(hPrinter)) {

            if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DrvPrinterEvent")) {

                try {

                    ReturnValue = (*pfn)( pName, PrinterEvent, Flags, lParam );

                } except(1) {

                    SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                }
            }

            RefCntUnloadDriver(hModule, TRUE);
        }

        ClosePrinter(hPrinter);
    }

    return  ReturnValue;
}


BOOL
SpoolerPrinterEventThunk(
    LPWSTR  pName,
    INT     PrinterEvent,
    DWORD   Flags,
    LPARAM  lParam
)
/*++

    //
    //  Some printer drivers, like the FAX driver want to do per client
    //  initialization at the time a connection is established
    //  For example in the FAX case they want to push up UI to get all
    //  the client info - Name, Number etc.
    //  Or they might want to run Setup, in initialize some other components
    //  Thus on a successful conenction we call into the Printer Drivers UI
    //  DLL to give them this oportunity
--*/
{
    BOOL        ReturnValue = FALSE;
    HANDLE      hPrinter;
    HANDLE      hModule;
    DWORD       dwRet = ERROR_SUCCESS;
    INT_FARPROC pfn;


    RpcTryExcept
    {
         if((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS)
         {
             if((ReturnValue = RPCSplWOW64SpoolerPrinterEvent(pName,
                                                              PrinterEvent,
                                                              Flags,
                                                              lParam,
                                                              &dwRet))==FALSE)
             {
                 SetLastError(dwRet);
             }
         }
         else
         {
             SetLastError(dwRet);
         }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
         SetLastError(TranslateExceptionCode(RpcExceptionCode()));
    }
    RpcEndExcept

    return  ReturnValue;
}


BOOL
SpoolerPrinterEvent(
    LPWSTR  pName,
    INT     PrinterEvent,
    DWORD   Flags,
    LPARAM  lParam
)
{
     if(RunInWOW64())
     {
          return(SpoolerPrinterEventThunk(pName,
                                          PrinterEvent,
                                          Flags,
                                          lParam));
     }
     else
     {
          return(SpoolerPrinterEventNative(pName,
                                           PrinterEvent,
                                           Flags,
                                           lParam));
     }
}


VOID
CopyFileEventForAKey(
    HANDLE  hPrinter,
    LPWSTR  pszPrinterName,
    LPWSTR  pszModule,
    LPWSTR  pszKey,
    DWORD   dwEvent
    )
{
    DWORD               dwNeeded, dwVersion = 0;
    HMODULE             hModule = NULL;
    LPDRIVER_INFO_5     pDriverInfo5 = NULL;
    WCHAR               szPath[MAX_PATH];
    LPWSTR              psz;
    BOOL                (*pfn)(LPWSTR, LPWSTR, DWORD);
    BOOL                bAllocBuffer = FALSE, bLoadedDriver = FALSE;
    BYTE                btBuffer[MAX_STATIC_ALLOC];

    pDriverInfo5 = (LPDRIVER_INFO_5) btBuffer;

    if (!pszModule || !*pszModule) {
        goto CleanUp;
    }

    // Get the Driver config file name
    if (!GetPrinterDriverW(hPrinter, NULL, 5, (LPBYTE) pDriverInfo5,
                           MAX_STATIC_ALLOC, &dwNeeded)) {

        if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
            (pDriverInfo5 = (LPDRIVER_INFO_5)LocalAlloc(LMEM_FIXED, dwNeeded))) {

             bAllocBuffer = TRUE;

             if (!GetPrinterDriverW(hPrinter, NULL, 5,
                                    (LPBYTE)pDriverInfo5, dwNeeded, &dwNeeded)) {

                 goto CleanUp;
             }

        } else goto CleanUp;
    }

    // If module name is the same as the config file, use reference counting
    wcscpy(szPath, pDriverInfo5->pConfigFile);

    // Get the pointer to just the file name
    psz = wcsrchr(szPath, L'\\');

    if (psz && !_wcsicmp(pszModule, (psz+1))) {

        if (hModule = RefCntLoadDriver(szPath,
                                       LOAD_WITH_ALTERED_SEARCH_PATH,
                                       pDriverInfo5->dwConfigVersion,
                                       TRUE)) {
            bLoadedDriver = TRUE;
        }
    }

    if (!hModule) {
        hModule = LoadLibraryEx(pszModule, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }

    if (!hModule) {
        if (GetLastError() != ERROR_MOD_NOT_FOUND) {
            // Fail the call
            goto CleanUp;
        }

        // The module could not be found in users path check if it is there
        // in the printer driver directory
        dwNeeded = (DWORD) (psz - szPath + wcslen(pszModule) + 1);
        if (dwNeeded  > MAX_PATH) {
            // Sanity check for file name size
            goto CleanUp;
        }
        wcscpy(psz, pszModule);
        hModule = LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }

    // Call the SpoolerCopyFileEvent export
    if (hModule &&
        ((FARPROC)pfn = GetProcAddress(hModule, "SpoolerCopyFileEvent"))) {

         pfn(pszPrinterName, pszKey, dwEvent);
    }

CleanUp:

    if (bAllocBuffer) {
        LocalFree(pDriverInfo5);
    }

    // Use reference counting for config file and FreeLibrary for others
    if (hModule) {
        if (bLoadedDriver) {
            RefCntUnloadDriver(hModule, TRUE);
        } else {
            FreeLibrary(hModule);
        }
    }
}


VOID
DoCopyFileEventForAllKeys(
    LPWSTR  pszPrinterName,
    DWORD   dwEvent
    )
{
    DWORD       dwLastError, dwNeeded, dwType;
    LPWSTR      pszBuf = NULL, psz, pszSubKey, pszModule;
    HANDLE      hPrinter;
    WCHAR       szKey[MAX_PATH];
    BOOL        bAllocBufferEnum = FALSE, bAllocBufferGPD = FALSE;
    BYTE        btBuffer[MAX_STATIC_ALLOC], btBufferGPD[MAX_STATIC_ALLOC];

    pszBuf = (LPTSTR) btBuffer;
    ZeroMemory(pszBuf, MAX_STATIC_ALLOC);

    if ( !OpenPrinter(pszPrinterName, &hPrinter, NULL) )
        return;

    dwLastError = EnumPrinterKeyW(hPrinter,
                                  L"CopyFiles",
                                  pszBuf,
                                  MAX_STATIC_ALLOC,
                                  &dwNeeded);

    //
    // If CopyFiles key is not found there is nothing to do
    //
    if ( dwLastError != ERROR_SUCCESS )
        goto Cleanup;

    if (dwNeeded > MAX_STATIC_ALLOC) {

        if (pszBuf = (LPWSTR) LocalAlloc(LPTR, dwNeeded)) {

            bAllocBufferEnum = TRUE;
            if (EnumPrinterKeyW(hPrinter,
                                L"CopyFiles",
                                pszBuf,
                                dwNeeded,
                                &dwNeeded) != ERROR_SUCCESS) {
                goto Cleanup;
            }

        } else goto Cleanup;
    }

    for ( psz = (LPWSTR) pszBuf ; *psz ; psz += wcslen(psz) + 1 ) {

        if ( wcslen(psz) + wcslen(L"CopyFiles") + 2
                            > sizeof(szKey)/sizeof(szKey[0]) )
            continue;

        wcscpy(szKey, L"CopyFiles\\");
        wcscat(szKey, psz);

        bAllocBufferGPD = FALSE;
        pszModule = (LPTSTR) btBufferGPD;
        ZeroMemory(pszModule, MAX_STATIC_ALLOC);

        dwLastError = GetPrinterDataExW(hPrinter,
                                        szKey,
                                        L"Module",
                                        &dwType,
                                        (LPBYTE) pszModule,
                                        MAX_STATIC_ALLOC,
                                        &dwNeeded);

        if (dwLastError != ERROR_SUCCESS) {
            continue;
        }

        if (dwNeeded > MAX_STATIC_ALLOC) {

            if (pszModule = (LPWSTR) LocalAlloc(LPTR, dwNeeded)) {

                bAllocBufferGPD = TRUE;
                dwLastError = GetPrinterDataExW(hPrinter,
                                                szKey,
                                                L"Module",
                                                &dwType,
                                                (LPBYTE) pszModule,
                                                MAX_STATIC_ALLOC,
                                                &dwNeeded);

                if (dwLastError != ERROR_SUCCESS) {
                    LocalFree((LPBYTE)pszModule);
                    continue;
                }

            } else continue;
        }

        CopyFileEventForAKey(hPrinter, pszPrinterName, pszModule,
                             szKey, dwEvent);

        if (bAllocBufferGPD) {
            LocalFree((LPBYTE)pszModule);
        }
    }

Cleanup:

    ClosePrinter(hPrinter);

    if (bAllocBufferEnum) {
        LocalFree((LPBYTE)pszBuf);
    }
    return;
}



BOOL
AddPrinterConnectionW(
    LPWSTR   pName
)
{
    BOOL    ReturnValue;
    HANDLE  hPrinter, hModule;
    FARPROC pfn;

    RpcTryExcept {

        if (ReturnValue = RpcAddPrinterConnection(pName)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else
            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue=FALSE;

    } RpcEndExcept

    if ( ReturnValue ) {

        SpoolerPrinterEvent( pName, PRINTER_EVENT_ADD_CONNECTION, 0, (LPARAM)NULL );
        DoCopyFileEventForAllKeys(pName, COPYFILE_EVENT_ADD_PRINTER_CONNECTION);
    }

   return ReturnValue;
}

BOOL
DeletePrinterConnectionW(
    LPWSTR   pName
)
{
    BOOL    ReturnValue;
    DWORD   LastError;

    SpoolerPrinterEvent( pName, PRINTER_EVENT_DELETE_CONNECTION, 0, (LPARAM)NULL );
    DoCopyFileEventForAllKeys(pName, COPYFILE_EVENT_DELETE_PRINTER_CONNECTION);

    RpcTryExcept {

        if (LastError = RpcDeletePrinterConnection(pName)) {
            SetLastError(LastError);
            ReturnValue = FALSE;
        } else
            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue=FALSE;

    } RpcEndExcept

   return ReturnValue;
}

BOOL
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    BOOL  ReturnValue = FALSE;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    PPRINTER_INFO_2     pPrinterInfo2;
    PPRINTER_INFO_3     pPrinterInfo3;
    PRINTER_INFO_6      PrinterInfo6;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    PVOID               pNewSecurityDescriptor = NULL;
    DWORD               sedlen = 0;
    PDEVMODE pDevModeWow = NULL;
    DWORD dwSize = 0;
    UINT  cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SecurityContainer.cbBuf = 0;
    SecurityContainer.pSecurity = NULL;

    switch (Level) {

    case STRESSINFOLEVEL:

        //
        // Internally we treat the Level 0, Command PRINTER_CONTROL_SET_STATUS
        // as Level 6 since level 0 could be STRESS_INFO (for rpc)
        //
        if ( Command == PRINTER_CONTROL_SET_STATUS ) {

            PrinterInfo6.dwStatus = (DWORD)(ULONG_PTR)pPrinter;
            pPrinter = (LPBYTE)&PrinterInfo6;
            Command = 0;
            Level   = 6;
        }
        break;

    case 2:

        pPrinterInfo2 = (PPRINTER_INFO_2)pPrinter;

        if (pPrinterInfo2 == NULL) {

            DBGMSG(DBG_TRACE, ("Error: SetPrinter pPrinterInfo2 is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }

        //
        // If valid (non-NULL and properly formatted), then update the
        // per-user DevMode.  Note that we don't remove the per-user DevMode
        // if this is NULL--client should user INFO_LEVEL_9 instead.
        //
        if( bValidDevModeW( pPrinterInfo2->pDevMode )){

            //
            // We won't setup the container, since setting a DevMode
            // with INFO_2 doesn't change the global default.
            // Use INFO_8 instead.
            //
            pDevModeWow = pPrinterInfo2->pDevMode;

            DevModeContainer.cbBuf = pPrinterInfo2->pDevMode->dmSize +
                                     pPrinterInfo2->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo2->pDevMode;

        }

        if (pPrinterInfo2->pSecurityDescriptor) {

            //
            // We must construct a self relative security descriptor from
            // whatever we get as input: If we get an Absolute SD we should
            // convert it to a self-relative one. (this is a given) and we
            // should also convert any self -relative input SD into a a new
            // self relative security descriptor; this will take care of
            // any holes in the Dacl or the Sacl in the self-relative sd
            //

            pNewSecurityDescriptor = BuildInputSD(pPrinterInfo2->pSecurityDescriptor,
                                                    &sedlen);
            if (pNewSecurityDescriptor) {
                SecurityContainer.cbBuf = sedlen;
                SecurityContainer.pSecurity = pNewSecurityDescriptor;
            }

        }
        break;

    case 3:

        pPrinterInfo3 = (PPRINTER_INFO_3)pPrinter;

        if (pPrinterInfo3 == NULL) {

            DBGMSG(DBG_TRACE, ("Error: SetPrinter pPrinterInfo3 is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }

        if (pPrinterInfo3->pSecurityDescriptor) {

            //
            // We must construct a self relative security descriptor from
            // whatever we get as input: If we get an Absolute SD we should
            // convert it to a self-relative one. (this is a given) and we
            // should also convert any self -relative input SD into a a new
            // self relative security descriptor; this will take care of
            // any holes in the Dacl or the Sacl in the self-relative sd
            //

            pNewSecurityDescriptor = BuildInputSD(pPrinterInfo3->pSecurityDescriptor,
                                                    &sedlen);
            if (pNewSecurityDescriptor) {
                SecurityContainer.cbBuf = sedlen;
                SecurityContainer.pSecurity = pNewSecurityDescriptor;
            }
        }
        break;

    case 4:
    case 5:
        if ( pPrinter == NULL ) {

            DBGMSG(DBG_TRACE,("Error SetPrinter pPrinter is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
        break;

    case 6:
        if ( pPrinter == NULL ) {

            DBGMSG(DBG_TRACE,("Error SetPrinter pPrinter is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
        break;

    case 7:
        if ( pPrinter == NULL ) {

            DBGMSG(DBG_TRACE,("Error SetPrinter pPrinter is NULL\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }

        break;

    case 8:
    {
        PPRINTER_INFO_8 pPrinterInfo8;

        //
        // Global DevMode
        //
        pPrinterInfo8 = (PPRINTER_INFO_8)pPrinter;

        if( !pPrinterInfo8 || !bValidDevModeW( pPrinterInfo8->pDevMode )){

            DBGMSG(DBG_TRACE,("Error SetPrinter 8 pPrinter\n"));
            SetLastError( ERROR_INVALID_PARAMETER );
            goto Done;
        }

        pDevModeWow = pPrinterInfo8->pDevMode;

        DevModeContainer.cbBuf = pPrinterInfo8->pDevMode->dmSize +
                                 pPrinterInfo8->pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo8->pDevMode;

        break;
    }
    case 9:
    {
        PPRINTER_INFO_9 pPrinterInfo9;

        //
        // Per-user DevMode
        //
        pPrinterInfo9 = (PPRINTER_INFO_9)pPrinter;

        //
        // Update the per-user DevMode if it's a valid DevMode,
        // or it is NULL, which indicates that the per-user DevMode
        // should be removed.
        //
        if( !pPrinterInfo9 ||
            (  pPrinterInfo9->pDevMode &&
               !bValidDevModeW( pPrinterInfo9->pDevMode ))){

            DBGMSG(DBG_TRACE,("Error SetPrinter 9 pPrinter\n"));
            SetLastError( ERROR_INVALID_PARAMETER );
            goto Done;
        }

        if( pPrinterInfo9->pDevMode ){

            pDevModeWow = pPrinterInfo9->pDevMode;

            DevModeContainer.cbBuf = pPrinterInfo9->pDevMode->dmSize +
                                     pPrinterInfo9->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo9->pDevMode;
        }

        break;
    }
    default:

        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    do {

        RpcTryExcept {

            if (ReturnValue = RpcSetPrinter(
                                  pSpool->hPrinter,
                                  (PPRINTER_CONTAINER)&PrinterContainer,
                                  (PDEVMODE_CONTAINER)&DevModeContainer,
                                  (PSECURITY_CONTAINER)&SecurityContainer,
                                  Command)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    //
    // Need to write DevMode to registry so that dos apps doing
    // ExtDeviceMode can pick up the new devmode
    //
    if( ReturnValue && pDevModeWow ){

        if( !WriteCurDevModeToRegistry( pSpool->pszPrinter,
                                        pDevModeWow )){
            DBGMSG( DBG_WARN,
                    ( "Write wow DevMode failed: %d\n", GetLastError( )));
        }

        //
        // Per-user DevMode is handled in the client's spoolsv process.
        //
    }


    //
    // Did we allocate memory for a new self-relative SD?
    // If we did, let's free it.
    //
    if (pNewSecurityDescriptor) {
        LocalFree(pNewSecurityDescriptor);
    }

Done:
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    SIZE_T  cbStruct;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 3:
        pFieldInfo = PrinterInfo3Fields;
        cbStruct = sizeof(PRINTER_INFO_3);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    case 6:
        pFieldInfo = PrinterInfo6Fields;
        cbStruct = sizeof(PRINTER_INFO_6);
        break;

    case 7:
        pFieldInfo = PrinterInfo7Fields;
        cbStruct = sizeof(PRINTER_INFO_7);
        break;

    case 8:
        pFieldInfo = PrinterInfo8Fields;
        cbStruct = sizeof(PRINTER_INFO_8);
        break;

    case 9:
        pFieldInfo = PrinterInfo9Fields;
        cbStruct = sizeof(PRINTER_INFO_9);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    if (pPrinter)
        memset(pPrinter, 0, cbBuf);

    do {

        RpcTryExcept {

            if (ReturnValue = RpcGetPrinter(pSpool->hPrinter, Level, pPrinter, cbBuf, pcbNeeded)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pPrinter) {
                    ReturnValue = MarshallUpStructure(pPrinter, pFieldInfo, cbStruct, RPC_CALL);
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));
Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetOSVersion(
    IN     LPCTSTR          pszServerName,     OPTIONAL
    OUT    OSVERSIONINFO    *pOSVer
    )
{
    DWORD dwStatus  = ERROR_SUCCESS;

    dwStatus = pOSVer ? S_OK : ERROR_INVALID_PARAMETER;
        
    if (ERROR_SUCCESS == dwStatus)
    { 
        ZeroMemory(pOSVer, sizeof(OSVERSIONINFO));       
        pOSVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if(!pszServerName || !*pszServerName)  // allow string to be empty?
        {
            dwStatus = GetVersionEx((POSVERSIONINFO) pOSVer) ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            HANDLE           hPrinter  = NULL;
            DWORD            dwNeeded  = 0;
            DWORD            dwType    = REG_BINARY;
            PRINTER_DEFAULTS Defaults  = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            dwStatus = OpenPrinter((LPTSTR) pszServerName, &hPrinter, &Defaults) ? ERROR_SUCCESS : GetLastError();
            
            //
            // Get the os version from the remote spooler.
            //
            if (ERROR_SUCCESS == dwStatus) 
            {
                dwStatus = GetPrinterData(hPrinter,
                                          SPLREG_OS_VERSION,
                                          &dwType,
                                          (PBYTE)pOSVer,
                                          sizeof(OSVERSIONINFO),
                                          &dwNeeded);
            }
             
            if (ERROR_INVALID_PARAMETER == dwStatus)
            {
                //
                // Assume that we're on NT4 as it doesn't support SPLREG_OS_VERSION
                // at it's the only OS that doesn't that could land up in this remote code path.
                //
                dwStatus = ERROR_SUCCESS;
                pOSVer->dwMajorVersion = 4;
                pOSVer->dwMinorVersion = 0;
            }
            
            if (NULL != hPrinter )
            {
                ClosePrinter(hPrinter);
            } 
        }       
    }

    SetLastError(dwStatus);
    return ERROR_SUCCESS == dwStatus ? TRUE : FALSE ;
}

BOOL
AddPrinterDriverExW(
    LPWSTR   pName,
    DWORD    Level,
    PBYTE    lpbDriverInfo,
    DWORD    dwFileCopyFlags
)
{
    BOOL  ReturnValue;
    DRIVER_CONTAINER   DriverContainer;
    BOOL bDefaultEnvironmentUsed = FALSE;
    LPRPC_DRIVER_INFO_4W    pRpcDriverInfo4 = NULL;
    DRIVER_INFO_4          *pDriverInfo4    = NULL;
    LPRPC_DRIVER_INFO_6W    pRpcDriverInfo6 = NULL;
    DRIVER_INFO_6          *pDriverInfo6    = NULL;
    BOOL                    bShowUI         = FALSE;     
    BOOL                    bMapUnknownPrinterDriverToBlockedDriver = FALSE;
    OSVERSIONINFO           OsVer;
    LPWSTR                  pStr;

    //
    // Validate Input Parameters
    //
    if (!lpbDriverInfo) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    DriverContainer.Level = Level;

    switch (Level) {

    case 2:

        if ( (((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment == NULL ) ||
            (*((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment == L'\0') ) {

            bDefaultEnvironmentUsed = TRUE;
            ((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment = szEnvironment;
        }

        DriverContainer.DriverInfo.Level2 = (DRIVER_INFO_2 *)lpbDriverInfo;

        break;

    case 3:
    case 4:

        //
        // DRIVER_INFO_4 is 3 + pszzPreviousNames field
        // We will use RPC_DRIVER_INFO_4 for both cases
        //
        DriverContainer.Level = Level;

        if ( (((LPDRIVER_INFO_4)lpbDriverInfo)->pEnvironment == NULL ) ||
            (*((LPDRIVER_INFO_4)lpbDriverInfo)->pEnvironment == L'\0') ) {

            bDefaultEnvironmentUsed = TRUE;
            ((LPDRIVER_INFO_4)lpbDriverInfo)->pEnvironment = szEnvironment;
        }

        if ( !(pRpcDriverInfo4=AllocSplMem(sizeof(RPC_DRIVER_INFO_4W))) ) {

            return FALSE;
        }

        pDriverInfo4                        = (DRIVER_INFO_4 *)lpbDriverInfo;
        pRpcDriverInfo4->cVersion           = pDriverInfo4->cVersion;
        pRpcDriverInfo4->pName              = pDriverInfo4->pName;
        pRpcDriverInfo4->pEnvironment       = pDriverInfo4->pEnvironment;
        pRpcDriverInfo4->pDriverPath        = pDriverInfo4->pDriverPath;
        pRpcDriverInfo4->pDataFile          = pDriverInfo4->pDataFile;
        pRpcDriverInfo4->pConfigFile        = pDriverInfo4->pConfigFile;
        pRpcDriverInfo4->pHelpFile          = pDriverInfo4->pHelpFile;
        pRpcDriverInfo4->pDependentFiles    = pDriverInfo4->pDependentFiles;
        pRpcDriverInfo4->pMonitorName       = pDriverInfo4->pMonitorName;
        pRpcDriverInfo4->pDefaultDataType   = pDriverInfo4->pDefaultDataType;

        //
        // Set the char count of the mz string.
        // NULL   --- 0
        // szNULL --- 1
        // string --- number of characters in the string including the last '\0'
        //
        if ( pStr = pDriverInfo4->pDependentFiles ) {

            while ( *pStr )
               pStr += wcslen(pStr) + 1;
            pRpcDriverInfo4->cchDependentFiles
                                = (DWORD) (pStr - pDriverInfo4->pDependentFiles + 1);
        } else {

            pRpcDriverInfo4->cchDependentFiles = 0;
        }

        pRpcDriverInfo4->cchPreviousNames = 0;
        if ( Level == 4                                 &&
             (pStr = pDriverInfo4->pszzPreviousNames)   &&
             *pStr ) {

            pRpcDriverInfo4->pszzPreviousNames = pStr;

            while ( *pStr )
                pStr += wcslen(pStr) + 1;

            pRpcDriverInfo4->cchPreviousNames
                                = (DWORD) (pStr - pDriverInfo4->pszzPreviousNames + 1);
        }

        DriverContainer.DriverInfo.Level4 = pRpcDriverInfo4;
        break;

    case 6:

        DriverContainer.Level = Level;

        if ( (((LPDRIVER_INFO_6)lpbDriverInfo)->pEnvironment == NULL ) ||
            (*((LPDRIVER_INFO_6)lpbDriverInfo)->pEnvironment == L'\0') ) {

            bDefaultEnvironmentUsed = TRUE;
            ((LPDRIVER_INFO_6)lpbDriverInfo)->pEnvironment = szEnvironment;
        }

        if ( !(pRpcDriverInfo6=AllocSplMem(sizeof(RPC_DRIVER_INFO_6W))) ) {

            return FALSE;
        }

        pDriverInfo6                        = (DRIVER_INFO_6 *)lpbDriverInfo;
        pRpcDriverInfo6->cVersion           = pDriverInfo6->cVersion;
        pRpcDriverInfo6->pName              = pDriverInfo6->pName;
        pRpcDriverInfo6->pEnvironment       = pDriverInfo6->pEnvironment;
        pRpcDriverInfo6->pDriverPath        = pDriverInfo6->pDriverPath;
        pRpcDriverInfo6->pDataFile          = pDriverInfo6->pDataFile;
        pRpcDriverInfo6->pConfigFile        = pDriverInfo6->pConfigFile;
        pRpcDriverInfo6->pHelpFile          = pDriverInfo6->pHelpFile;
        pRpcDriverInfo6->pDependentFiles    = pDriverInfo6->pDependentFiles;
        pRpcDriverInfo6->pMonitorName       = pDriverInfo6->pMonitorName;
        pRpcDriverInfo6->pDefaultDataType   = pDriverInfo6->pDefaultDataType;
        pRpcDriverInfo6->ftDriverDate       = pDriverInfo6->ftDriverDate;
        pRpcDriverInfo6->dwlDriverVersion   = pDriverInfo6->dwlDriverVersion;
        pRpcDriverInfo6->pMfgName           = pDriverInfo6->pszMfgName;
        pRpcDriverInfo6->pOEMUrl            = pDriverInfo6->pszOEMUrl;
        pRpcDriverInfo6->pHardwareID        = pDriverInfo6->pszHardwareID;
        pRpcDriverInfo6->pProvider          = pDriverInfo6->pszProvider;


        //
        // Set the char count of the mz string.
        // NULL   --- 0
        // szNULL --- 1
        // string --- number of characters in the string including the last '\0'
        //
        if ( pStr = pDriverInfo6->pDependentFiles ) {

            while ( *pStr )
               pStr += wcslen(pStr) + 1;
            pRpcDriverInfo6->cchDependentFiles = (DWORD) (pStr - pDriverInfo6->pDependentFiles + 1);
        } else {

            pRpcDriverInfo6->cchDependentFiles = 0;
        }

        pRpcDriverInfo6->cchPreviousNames = 0;
        if ( Level == 6                                 &&
             (pStr = pDriverInfo6->pszzPreviousNames)   &&
             *pStr ) {

            pRpcDriverInfo6->pszzPreviousNames = pStr;

            while ( *pStr )
                pStr += wcslen(pStr) + 1;

            pRpcDriverInfo6->cchPreviousNames
                                = (DWORD) (pStr - pDriverInfo6->pszzPreviousNames + 1);
        }

        DriverContainer.DriverInfo.Level6 = pRpcDriverInfo6;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // The driver path is at the same location in all of the DRIVER_INFO_X
    // structures, as is the driver name. If this changes, the
    // CheckForBlockedDrivers() call will have to do different things
    // depending on the level.
    //
    SPLASSERT(Level >= 2 && Level <= 6);

    //
    // APD_NO_UI has no meaning at the server side, so clear it before the 
    // RPC call.
    //
    bShowUI = !(dwFileCopyFlags & APD_NO_UI); 
    dwFileCopyFlags &= ~APD_NO_UI;
    
    //
    // GetOSVersionEx has set last error correctly.
    //
    ReturnValue = GetOSVersion(pName, &OsVer);
    if (!ReturnValue) {
        goto Cleanup;
    }
    
    //
    // If the server is Whistler or later, instruct the spooler to 
    // return the actual blocking code ERROR_PRINTER_DRIVER_BLOCKED or
    // ERROR_PRINTER_DRIVER_WARNED. 
    //
    // A win2k server returns ERROR_UNKNOWN_PRINTER_DRIVER for blocked 
    // driver, so we need to re-map this code to the correct blocking 
    // code.
    //
    if (OsVer.dwMajorVersion >= 5 && OsVer.dwMinorVersion > 0) 
    {
        dwFileCopyFlags |= APD_RETURN_BLOCKING_STATUS_CODE;
    }
    else 
    {
        //
        // APD_DONT_SET_CHECKPOINT has no meaning at the server side, so clear it 
        // before the RPC call.
        //
        dwFileCopyFlags &= ~APD_DONT_SET_CHECKPOINT;

        dwFileCopyFlags &= ~APD_INSTALL_WARNED_DRIVER;

        if (OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion == 0) 
        {
            bMapUnknownPrinterDriverToBlockedDriver = TRUE;
        }
    }
    
    RpcTryExcept {
        ReturnValue = RpcAddPrinterDriverEx(pName,
                                            &DriverContainer,
                                            dwFileCopyFlags);  
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        ReturnValue = TranslateExceptionCode(RpcExceptionCode());
    } RpcEndExcept
    
    if (bMapUnknownPrinterDriverToBlockedDriver && (ERROR_UNKNOWN_PRINTER_DRIVER == ReturnValue))
    {
        ReturnValue = ERROR_PRINTER_DRIVER_BLOCKED;
    }

    //
    // Popup UI but do not offer replacement for all cases.
    //     
    if (bShowUI && ((ERROR_PRINTER_DRIVER_BLOCKED == ReturnValue) || (ERROR_PRINTER_DRIVER_WARNED == ReturnValue))) {             
        ReturnValue = ShowPrintUpgUI(ReturnValue);
        
        //
        // For warned driver and the user instructs to install it, retry it
        // with APD_INSTALL_WARNED_DRIVER.
        //                
        if ((ERROR_SUCCESS == ReturnValue)) {
             dwFileCopyFlags |= APD_INSTALL_WARNED_DRIVER;            
             RpcTryExcept {
                 ReturnValue = RpcAddPrinterDriverEx(pName,
                                                     &DriverContainer,
                                                     dwFileCopyFlags);
            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {        
                ReturnValue = TranslateExceptionCode(RpcExceptionCode());        
            } RpcEndExcept
        }
    }    
     
    if (ERROR_SUCCESS != ReturnValue) {
        SetLastError(ReturnValue);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
         
    if (bDefaultEnvironmentUsed) {
        if ( Level == 2 )
            ((LPDRIVER_INFO_2)lpbDriverInfo)->pEnvironment = NULL;
        else //Level == 3
            ((LPDRIVER_INFO_3)lpbDriverInfo)->pEnvironment = NULL;
    }

Cleanup:

    FreeSplMem(pRpcDriverInfo4);

    FreeSplMem(pRpcDriverInfo6);

    return ReturnValue;
}

BOOL
AddDriverCatalog(
    HANDLE   hPrinter,
    DWORD    dwLevel,
    VOID     *pvDriverInfCatInfo,
    DWORD    dwCatalogCopyFlags
    )
{
    HRESULT hRetval = E_FAIL;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    DRIVER_INFCAT_CONTAINER DriverInfCatContainer;

    hRetval = pvDriverInfCatInfo && hPrinter ? S_OK : E_INVALIDARG; 
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = eProtectHandle(hPrinter, FALSE) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        switch (dwLevel) 
        {    
        case 1:
                    
            DriverInfCatContainer.dwLevel = dwLevel;
            DriverInfCatContainer.DriverInfCatInfo.pDriverInfCatInfo1 = (LPRPC_DRIVER_INFCAT_INFO_1) pvDriverInfCatInfo;
    
            break;

        case 2:

            DriverInfCatContainer.dwLevel = dwLevel;
            DriverInfCatContainer.DriverInfCatInfo.pDriverInfCatInfo2 = (LPRPC_DRIVER_INFCAT_INFO_2) pvDriverInfCatInfo;
        
            break;
    
        default:
            
            hRetval = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);
            
            break;
        }

        if (SUCCEEDED(hRetval)) 
        {    
            do 
            {        
                RpcTryExcept 
                {
                    hRetval = HResultFromWin32(RpcAddDriverCatalog(pSpool->hPrinter,
                                                                   &DriverInfCatContainer,
                                                                   dwCatalogCopyFlags)); 
                } 
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) 
                {
                    hRetval = HResultFromWin32(TranslateExceptionCode(RpcExceptionCode()));
                } 
                RpcEndExcept
    
            } while (FAILED(hRetval) && (HRESULT_CODE(hRetval) == ERROR_INVALID_HANDLE) &&
                     (cRetry++ < MAX_RETRY_INVALID_HANDLE) &&
                     RevalidateHandle( pSpool ));
        }
        
        vUnprotectHandle(hPrinter);
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}

BOOL
AddPrinterDriverW(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   lpbDriverInfo
)
{
    return AddPrinterDriverExW(pName, Level, lpbDriverInfo, APD_COPY_NEW_FILES);
}


BOOL
EnumPrinterDriversW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcEnumPrinterDrivers(pName, pEnvironment, Level,
                                                pDriverInfo, cbBuf,
                                                pcbNeeded, pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pDriverInfo) {

                ReturnValue = MarshallUpStructuresArray(pDriverInfo, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    SIZE_T  cbStruct;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwMajorVersionNeeded = (DWORD)-1, dwMinorVersionNeeded = (DWORD)-1;
    DWORD dwServerMajorVersion;
    DWORD dwServerMinorVersion;
    UINT cRetry = 0;
    CALL_ROUTE Route;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    do {
        RpcTryExcept {

            if (pDriverInfo)
                memset(pDriverInfo, 0, cbBuf);

            if (!pEnvironment || !*pEnvironment)
                pEnvironment = RunInWOW64() ? szIA64Environment : szEnvironment;
            else if ( !lstrcmp(pEnvironment, cszWin95Environment) )
                dwMajorVersionNeeded = dwMinorVersionNeeded = 0;

            if (bLoadedBySpooler && fpYGetPrinterDriver2 && pSpool->hSplPrinter) {

                  ReturnValue = (*fpYGetPrinterDriver2)(pSpool->hSplPrinter,
                                                        pEnvironment,
                                                        Level, pDriverInfo, cbBuf,
                                                        pcbNeeded,
                                                        dwMajorVersionNeeded,
                                                        dwMinorVersionNeeded,
                                                        &dwServerMajorVersion,
                                                        &dwServerMinorVersion,
                                                        NATIVE_CALL
                                                        );
                 Route = NATIVE_CALL;
            } else {

                  ReturnValue = RpcGetPrinterDriver2(pSpool->hPrinter,
                                                     pEnvironment,
                                                     Level, pDriverInfo, cbBuf,
                                                     pcbNeeded,
                                                     dwMajorVersionNeeded,
                                                     dwMinorVersionNeeded,
                                                     &dwServerMajorVersion,
                                                     &dwServerMinorVersion
                                                     );

                  Route = RPC_CALL;
            }

            if (ReturnValue) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pDriverInfo) {
                    if (!MarshallUpStructure(pDriverInfo, pFieldInfo, cbStruct, Route))
                    {
                        ReturnValue = FALSE;
                        break;
                    }
                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));
Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetPrinterDriverDirectoryW(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = pEnvironment = RunInWOW64() ? szIA64Environment : szEnvironment;

        if (bLoadedBySpooler && fpYGetPrinterDriverDirectory) {

            ReturnValue = (*fpYGetPrinterDriverDirectory)(pName, pEnvironment,
                                                          Level,
                                                          pDriverDirectory,
                                                          cbBuf, pcbNeeded,
                                                          FALSE);
        } else {

            ReturnValue = RpcGetPrinterDriverDirectory(pName,
                                                       pEnvironment,
                                                       Level,
                                                       pDriverDirectory,
                                                       cbBuf, pcbNeeded);
        }

        if (ReturnValue) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        DWORD Error;
          
        Error = TranslateExceptionCode(RpcExceptionCode());

        if (Error == RPC_S_SERVER_UNAVAILABLE)
        {
            ReturnValue = BuildSpoolerObjectPath(gszPrinterDriversPath, 
                                                 pName, 
                                                 pEnvironment, 
                                                 Level, 
                                                 pDriverDirectory, 
                                                 cbBuf, 
                                                 pcbNeeded); 
        }
        else
        {
            SetLastError(Error);
            ReturnValue = FALSE;
        }

    } RpcEndExcept

    return ReturnValue;
}


BOOL
DeletePrinterDriverExW(
   LPWSTR     pName,
   LPWSTR     pEnvironment,
   LPWSTR     pDriverName,
   DWORD      dwDeleteFlag,
   DWORD      dwVersionNum
)
{
    BOOL  ReturnValue;

    if (!pDriverName || !*pDriverName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrinterDriverEx(pName,
                                                   pEnvironment,
                                                   pDriverName,
                                                   dwDeleteFlag,
                                                   dwVersionNum)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
DeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
)
{
    BOOL  ReturnValue;

    if (!pDriverName || !*pDriverName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrinterDriver(pName,
                                                 pEnvironment,
                                                 pDriverName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
AddPerMachineConnectionW(
   LPCWSTR     pServer,
   LPCWSTR     pPrinterName,
   LPCWSTR     pPrintServer,
   LPCWSTR     pProvider
)
{
    BOOL  ReturnValue;
    WCHAR DummyStr[] = L"";

    if (!pPrinterName || !*pPrinterName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pPrintServer || !*pPrintServer) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    // pProvider is an optional parameter and can be NULL. Since RPC does not
    // accept NULL pointers we have to pass some dummy pointer to szNULL.

    if (!pProvider) {
       pProvider = (LPCWSTR) DummyStr;
    }


    RpcTryExcept {

        if (ReturnValue = RpcAddPerMachineConnection((LPWSTR) pServer,
                                                     pPrinterName,
                                                     pPrintServer,
                                                     pProvider)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePerMachineConnectionW(
   LPCWSTR     pServer,
   LPCWSTR     pPrinterName
)
{
    BOOL  ReturnValue;

    if (!pPrinterName || !*pPrinterName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (ReturnValue = RpcDeletePerMachineConnection((LPWSTR) pServer,
                                                        pPrinterName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPerMachineConnectionsW(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct, index;
    FieldInfo *pFieldInfo;

    pFieldInfo = PrinterInfo4Fields;
    cbStruct = sizeof(PRINTER_INFO_4);


    RpcTryExcept {

        if (pPrinterEnum)
            memset(pPrinterEnum, 0, cbBuf);

        if (ReturnValue = RpcEnumPerMachineConnections((LPWSTR) pServer,
                                                       pPrinterEnum,
                                                       cbBuf,
                                                       pcbNeeded,
                                                       pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {
            ReturnValue = TRUE;
            if (pPrinterEnum) {

                ReturnValue = MarshallUpStructuresArray(pPrinterEnum, *pcReturned, pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
AddPrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
)
{
    BOOL ReturnValue;

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if (!pPathName || !*pPathName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcAddPrintProcessor(pName, pEnvironment, pPathName,
                                               pPrintProcessorName)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPrintProcessorsW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcEnumPrintProcessors(pName, pEnvironment, Level,
                                                pPrintProcessorInfo, cbBuf,
                                                pcbNeeded, pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPrintProcessorInfo) {

                ReturnValue = MarshallUpStructuresArray(pPrintProcessorInfo, *pcReturned,
                                                        pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
GetPrintProcessorDirectoryW(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = pEnvironment = RunInWOW64() ? szIA64Environment : szEnvironment;

        if (ReturnValue = RpcGetPrintProcessorDirectory(pName,
                                                        pEnvironment,
                                                        Level,
                                                        pPrintProcessorInfo,
                                                        cbBuf,
                                                        pcbNeeded)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        DWORD Error;
          
        Error = TranslateExceptionCode(RpcExceptionCode());

        if (Error == RPC_S_SERVER_UNAVAILABLE)
        {
            ReturnValue = BuildSpoolerObjectPath(gszPrintProcessorsPath, 
                                                 pName, 
                                                 pEnvironment, 
                                                 Level, 
                                                 pPrintProcessorInfo, 
                                                 cbBuf, 
                                                 pcbNeeded); 
        }
        else
        {
            SetLastError(Error);
            ReturnValue = FALSE;
        }

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPrintProcessorDatatypesW(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   i, cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (ReturnValue = RpcEnumPrintProcessorDatatypes(pName,
                                                         pPrintProcessorName,
                                                         Level,
                                                         pDatatypes,
                                                         cbBuf,
                                                         pcbNeeded,
                                                         pcReturned)) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pDatatypes) {

                ReturnValue = MarshallUpStructuresArray(pDatatypes, *pcReturned,
                                                        pFieldInfo, cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


DWORD
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    DWORD        ReturnValue      = 0;
    BOOL         EverythingWorked = FALSE;
    BOOL         PrintingToFile   = FALSE;
    PSPOOL       pSpool           = (PSPOOL)hPrinter;
    PDOC_INFO_1  pDocInfo1        = NULL;
    PDOC_INFO_3  pDocInfo3        = NULL;
    LPBYTE       pBuffer          = NULL;
    DWORD        cbBuffer         = MAX_STATIC_ALLOC;
    DWORD        cbNeeded;
    BOOL         bReturn; 
    
    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if ( pSpool->Status & SPOOL_STATUS_STARTDOC ) {

        SetLastError(ERROR_INVALID_PRINTER_STATE);
        goto Done;
    }

    
    DBGMSG(DBG_TRACE,("Entered StartDocPrinterW client side  hPrinter = %x\n", hPrinter));

    // level 2 is supported on win95 and not on NT
    switch (Level) {
    case 1:
        pDocInfo1 = (PDOC_INFO_1)pDocInfo;
        break;

    case 3:
        pDocInfo1 = (PDOC_INFO_1)pDocInfo;
        pDocInfo3 = (PDOC_INFO_3)pDocInfo;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        goto Done;
    }

    pBuffer = AllocSplMem(cbBuffer);

    if (!pBuffer) {
        goto Done;
    }
    
    try {

        //
        // Earlier on, if we had a non-null string, we assumed it to be
        // printing to file. Print to file will not go thru the client-side
        // optimization code. Now gdi is passing us  pOutputFile name
        // irrespective of whether it is file or not. We must determine if
        // pOutputFile is really a file name
        //

        if (pDocInfo1->pOutputFile &&
            (*(pDocInfo1->pOutputFile) != L'\0') &&
            IsaFileName(pDocInfo1->pOutputFile, (LPWSTR)pBuffer, cbBuffer / sizeof(WCHAR))){

            PrintingToFile = TRUE;
        }
        
        if (!PrintingToFile &&
            !((Level == 3) && (pDocInfo3->dwFlags & DI_MEMORYMAP_WRITE)) &&
            AddJobW(hPrinter, 1, pBuffer, cbBuffer, &cbNeeded)) {

            PADDJOB_INFO_1 pAddJob = (PADDJOB_INFO_1)pBuffer;

            pSpool->JobId = pAddJob->JobId;
            pSpool->hFile = CreateFile(pAddJob->Path,
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL);

            if (pSpool->hFile != INVALID_HANDLE_VALUE) {

                if (pSpool->JobId == (DWORD)-1) {

                    IO_STATUS_BLOCK Iosb;
                    NTSTATUS Status;
                    QUERY_PRINT_JOB_INFO JobInfo;

                    Status = NtFsControlFile(pSpool->hFile, NULL, NULL, NULL,
                                             &Iosb,
                                             FSCTL_GET_PRINT_ID,
                                             NULL, 0,
                                             &JobInfo, sizeof(JobInfo));

                    if (NT_SUCCESS(Status)) {
                        pSpool->JobId = JobInfo.JobId;
                    }
                }

                ZeroMemory(pBuffer, cbBuffer);

                if (!(bReturn = GetJob(hPrinter, pSpool->JobId, 1, pBuffer, cbBuffer, &cbNeeded))) {

                    if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
                        FreeSplMem(pBuffer) &&
                        (pBuffer = AllocSplMem(cbNeeded))) {
                    
                        //
                        // Update the new size of our work buffer
                        //
                        cbBuffer = cbNeeded;
                        
                        bReturn = GetJob(hPrinter, pSpool->JobId, 1, pBuffer, cbBuffer, &cbNeeded);
                    }
                }

                if (bReturn) {

                    PJOB_INFO_1 pJob = (PJOB_INFO_1)pBuffer;

                    pJob->pDocument = pDocInfo1->pDocName;
                    if (pDocInfo1->pDatatype) {
                        pJob->pDatatype = pDocInfo1->pDatatype;
                    }
                    pJob->Position = JOB_POSITION_UNSPECIFIED;

                    if (SetJob(hPrinter, pSpool->JobId,
                               1, (LPBYTE)pJob, 0))      {

                        EverythingWorked = TRUE;
                    }
                }                                
            }

            if (!PrintingToFile && !EverythingWorked) {

                if (pSpool->hFile != INVALID_HANDLE_VALUE) {
                    if (CloseHandle(pSpool->hFile)) {
                        pSpool->hFile = INVALID_HANDLE_VALUE;
                    }
                }

                SetJob(hPrinter,pSpool->JobId, 0, NULL, JOB_CONTROL_CANCEL);
                ScheduleJob(hPrinter, pSpool->JobId);
                pSpool->JobId = 0;
            }
        }

        if (EverythingWorked) {
            ReturnValue = pSpool->JobId;

        } else {

            UINT cRetry = 0;

            //
            // If it's invalid datatype, fail immediately instead of trying
            // StartDocPrinter.
            //
            if( GetLastError() == ERROR_INVALID_DATATYPE ){

                ReturnValue = 0;

            } else {

                GENERIC_CONTAINER DocInfoContainer;
                DWORD             JobId;

                pSpool->hFile = INVALID_HANDLE_VALUE;
                pSpool->JobId = 0;

                // Level 3 data is required only on the client
                DocInfoContainer.Level = 1;
                DocInfoContainer.pData = pDocInfo;

                do {

                    RpcTryExcept {

                        if (ReturnValue = RpcStartDocPrinter(
                                              pSpool->hPrinter,
                                              (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                              &JobId)) {

                            SetLastError(ReturnValue);
                            ReturnValue = 0;

                        } else

                            ReturnValue = JobId;

                    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                        ReturnValue = 0;

                    } RpcEndExcept

                } while( !ReturnValue &&
                         GetLastError() == ERROR_INVALID_HANDLE &&
                         cRetry++ < MAX_RETRY_INVALID_HANDLE &&
                         RevalidateHandle( pSpool ));
            }
        }

        if (ReturnValue) {
            pSpool->Status |= SPOOL_STATUS_STARTDOC;
        }

        //
        // If the tray icon has not been notified, then do so now.  Set
        // the flag so that we won't call it multiple times.
        //
        if( ReturnValue && !( pSpool->Status & SPOOL_STATUS_TRAYICON_NOTIFIED )){
            vUpdateTrayIcon( hPrinter, ReturnValue );
        }

    } except (1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = 0;
    }

Done:

    FreeSplMem(pBuffer);
    
    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
StartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    try {

        FlushBuffer(pSpool, NULL);

        RpcTryExcept {

            if (ReturnValue = RpcStartPagePrinter(pSpool->hPrinter)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } except (1) {

        SetLastError(ERROR_INVALID_HANDLE);
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
FlushBuffer(
    PSPOOL  pSpool,
    PDWORD pcbWritten
)
{
    DWORD   ReturnValue = TRUE;
    DWORD   cbWritten = 0;

    SPLASSERT (pSpool != NULL);
    SPLASSERT (pSpool->signature == SP_SIGNATURE);

    DBGMSG(DBG_TRACE, ("FlushBuffer - pSpool %x\n",pSpool));

    if (pSpool->cbBuffer) {

        SPLASSERT(pSpool->pBuffer != NULL);

        DBGMSG(DBG_TRACE, ("FlushBuffer - Number Cached WritePrinters before Flush %d\n", pSpool->cCacheWrite));
        pSpool->cCacheWrite = 0;
        pSpool->cFlushBuffers++;

        if (pSpool->hFile != INVALID_HANDLE_VALUE) {

            // FileIO
            ReturnValue = WriteFile( pSpool->hFile,
                                     pSpool->pBuffer,
                                     pSpool->cbBuffer,
                                     &cbWritten, NULL);

            DBGMSG(DBG_TRACE, ("FlushBuffer - WriteFile pSpool %x hFile %x pBuffer %x cbBuffer %d cbWritten %d\n",
                               pSpool, pSpool->hFile, pSpool->pBuffer, pSpool->cbBuffer, cbWritten));

        } else {

            // RPC IO
            RpcTryExcept {

                if (bLoadedBySpooler && fpYWritePrinter && pSpool->hSplPrinter) {

                    ReturnValue = (*fpYWritePrinter)(pSpool->hSplPrinter,
                                                     pSpool->pBuffer,
                                                     pSpool->cbBuffer,
                                                     &cbWritten,
                                                     FALSE);

                } else {

                    ReturnValue = RpcWritePrinter(pSpool->hPrinter,
                                                  pSpool->pBuffer,
                                                  pSpool->cbBuffer,
                                                  &cbWritten);
                }

                if (ReturnValue) {

                    SetLastError(ReturnValue);
                    ReturnValue = FALSE;
                    DBGMSG(DBG_WARNING, ("FlushBuffer - RpcWritePrinter Failed Error %d\n",GetLastError() ));

                } else {
                    ReturnValue = TRUE;
                    DBGMSG(DBG_TRACE, ("FlushBuffer - RpcWritePrinter Success hPrinter %x pBuffer %x cbBuffer %x cbWritten %x\n",
                                        pSpool->hPrinter, pSpool->pBuffer,
                                        pSpool->cbBuffer, cbWritten));

                }

                //
                // This routine seems messed up.
                // If it doesn't flush the entire buffer, it apparently still
                // returns TRUE.  It correctly updates the buffer pointers
                // so it doesn't send duplicate information, but it
                // doesn't send back bytes written.  When WritePrinter
                // sees success, it assumes that all bytes have been written.
                //

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                ReturnValue = FALSE;
                DBGMSG(DBG_WARNING, ("RpcWritePrinter Exception Error %d\n",GetLastError()));

            } RpcEndExcept

        }

        //
        // We have sent more data to the printer.  If we had any bytes
        // from the previous write, we have just sent part of them to the
        // printer.  Update the cbFlushPending count to reflect the
        // sent bytes.  cbWritten may be > cbFlushPending, since we
        // may have sent new bytes too.
        //
        if (pSpool->cbFlushPending < cbWritten) {
            pSpool->cbFlushPending = 0;
        } else {
            pSpool->cbFlushPending -= cbWritten;
        }

        if (pSpool->cbBuffer <= cbWritten) {

            if ( pSpool->cbBuffer < cbWritten) {


                DBGMSG( DBG_WARNING, ("FlushBuffer cbBuffer %d < cbWritten %d ReturnValue %x LastError %d\n",
                        pSpool->cbBuffer, cbWritten, ReturnValue, GetLastError() ));
            }

            // Successful IO
            // Empty the cache buffer count

            pSpool->cbBuffer = 0;

        } else if ( cbWritten != 0 ) {

            // Partial IO
            // Adjust the buffer so it contains the data that was not
            // written

            SPLASSERT(pSpool->cbBuffer <= BUFFER_SIZE);
            SPLASSERT(cbWritten <= BUFFER_SIZE);
            SPLASSERT(pSpool->cbBuffer >= cbWritten);

            DBGMSG(DBG_WARNING, ("Partial IO adjusting buffer data\n"));

            MoveMemory(pSpool->pBuffer,
                       pSpool->pBuffer + cbWritten,
                       BUFFER_SIZE - cbWritten);

            pSpool->cbBuffer -= cbWritten;

        }
    }

    DBGMSG(DBG_TRACE, ("FlushBuffer returns %d\n",ReturnValue));

    if (pcbWritten) {
        *pcbWritten = cbWritten;
    }

    if(!pSpool->cOKFlushBuffers &&
        ReturnValue             &&
        cbWritten)
    {
        pSpool->cOKFlushBuffers=1;
    }

    return ReturnValue;
}


BOOL
SeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
    )
{
    DWORD dwReturnValue;
    BOOL bReturnValue = FALSE;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    LARGE_INTEGER liUnused;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if( !pliNewPointer ){
        pliNewPointer = &liUnused;
    }

    RpcTryExcept {

        if (bLoadedBySpooler && fpYSeekPrinter && pSpool->hSplPrinter) {

            dwReturnValue = (*fpYSeekPrinter)( pSpool->hSplPrinter,
                                               liDistanceToMove,
                                               pliNewPointer,
                                               dwMoveMethod,
                                               bWritePrinter,
                                               FALSE );
        } else {

            dwReturnValue = RpcSeekPrinter( pSpool->hPrinter,
                                            liDistanceToMove,
                                            pliNewPointer,
                                            dwMoveMethod,
                                            bWritePrinter );
        }

        if( dwReturnValue == ERROR_SUCCESS ){
            bReturnValue = TRUE;
        } else {
            SetLastError( dwReturnValue );
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
    } RpcEndExcept

    vUnprotectHandle( hPrinter );
    return bReturnValue;
}

BOOL
FlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)

/*++
Function Description: FlushPrinter is typically used by the driver to send a burst of zeros
                      to the printer and introduce a delay in the i/o line to the printer.
                      The spooler does not schedule any job for cSleep milliseconds.

Parameters:  hPrinter  - printer handle
             pBuf      - buffer to be sent to the printer
             cbBuf     - size of the buffer
             pcWritten - pointer to return the number of bytes written
             cSleep    - sleep time in milliseconds.

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    DWORD   dwError, cWritten, Buffer;
    BOOL    bReturn = FALSE;

    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (eProtectHandle( hPrinter, FALSE ))
    {
        return FALSE;
    }

    //
    // In case the job was canceled or a printer failure
    // occured before priting any part of the document, we
    // just short circuit and return to prevent any unnecessary
    // delays in returning to the caller.
    //

    if (!pSpool->cOKFlushBuffers)
    {
        bReturn = TRUE;
        goto Done;
    }

    //
    //  Use temp variables since RPC does not take NULL pointers
    //
    if (!pcWritten)
    {
        pcWritten = &cWritten;
    }

    if (!pBuf)
    {
        if (cbBuf == 0)
        {
            pBuf = (LPVOID) &Buffer;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Done;
        }
    }

    //
    // Rpc to the spooler
    //
    RpcTryExcept {
        if(bLoadedBySpooler && fpYFlushPrinter && pSpool->hSplPrinter)
        {
            dwError = (*fpYFlushPrinter)(pSpool->hSplPrinter,
                                         pBuf,
                                         cbBuf,
                                         pcWritten,
                                         cSleep,
                                         FALSE);
        }
        else
        {
            dwError = RpcFlushPrinter( pSpool->hPrinter,
                                       pBuf,
                                       cbBuf,
                                       pcWritten,
                                       cSleep );
        }

        if (dwError == ERROR_SUCCESS)
        {
            bReturn = TRUE;
        }
        else
        {
            SetLastError( dwError );
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());

    } RpcEndExcept

Done:

    vUnprotectHandle( hPrinter );

    return bReturn;
}


BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    )
{
    BOOL    ReturnValue=TRUE, bAllocBuffer = FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    DWORD   cb;
    DWORD   cbWritten = 0;
    DWORD   cTotalWritten = 0;
    LPBYTE  pBuffer = pBuf;
    LPBYTE  pInitialBuf = pBuf;
    PSPOOL  pSpool  = (PSPOOL)hPrinter;
    PJOB_INFO_1  pJob;
    DWORD   cbNeeded;
    DWORD   dwTickCount, dwTickCount1;
    DWORD   FlushPendingDataSize;
    DWORD   ReqTotalDataSize;
    DWORD   ReqToWriteDataSize   = cbBuf;
    DWORD   NumOfCmpltWrts       = 0;


    DBGMSG(DBG_TRACE, ("WritePrinter - hPrinter %x pBuf %x cbBuf %d pcWritten %x\n",
                        hPrinter, pBuf, cbBuf, pcWritten));


    if( eProtectHandle( hPrinter, FALSE ))
    {
        return FALSE;
    }

    if (pSpool && pSpool->Flushed)
    {
        ReturnValue = FALSE;
        goto EndWritePrinter;
    }

    FlushPendingDataSize = pSpool->cbFlushPending;
    ReqTotalDataSize     = FlushPendingDataSize + ReqToWriteDataSize;

    *pcWritten = 0;

    if ( !(pSpool->Status & SPOOL_STATUS_STARTDOC) ) {

        SetLastError(ERROR_SPL_NO_STARTDOC);
        ReturnValue = FALSE;

        goto EndWritePrinter;
    }

    // Check if local job is cancelled every JOB_CANCEL_CHECK_INTERVAL bytes
    if (!pSpool->cWritePrinters) {
        pSpool->dwTickCount = GetTickCount();
        pSpool->dwCheckJobInterval = JOB_CANCEL_CHECK_INTERVAL;
    }

    if (pSpool->hFile != INVALID_HANDLE_VALUE &&
        pSpool->dwTickCount + pSpool->dwCheckJobInterval < (dwTickCount = GetTickCount())) {

        bAllocBuffer = FALSE;
        pJob = (PJOB_INFO_1) btBuffer;
        ZeroMemory(pJob, MAX_STATIC_ALLOC);

        ReturnValue = GetJob((HANDLE) pSpool, pSpool->JobId, 1, (LPBYTE)pJob,
                              MAX_STATIC_ALLOC, &cbNeeded);

        if (!ReturnValue &&
            (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
            (pJob = (PJOB_INFO_1) AllocSplMem(cbNeeded))) {

             bAllocBuffer = TRUE;
             ReturnValue = GetJob(hPrinter, pSpool->JobId, 1, (LPBYTE)pJob,
                                  cbNeeded, &cbNeeded);
        }

        if (ReturnValue) {

           // Don't allow GetJob calls to take more than 1% pSpool->dwCheckJobInterval
           dwTickCount1 = GetTickCount();

           if (dwTickCount1 > dwTickCount + (pSpool->dwCheckJobInterval/100)) {

               pSpool->dwCheckJobInterval *= 2;

           } else if (dwTickCount1 - dwTickCount < JOB_CANCEL_CHECK_INTERVAL/100) {

              pSpool->dwCheckJobInterval = JOB_CANCEL_CHECK_INTERVAL;
           }

           if (!pJob->pStatus && (pJob->Status & JOB_STATUS_DELETING)) {

                SetLastError(ERROR_PRINT_CANCELLED);
                if (bAllocBuffer) {
                    FreeSplMem(pJob);
                }
                ReturnValue = FALSE;

                goto EndWritePrinter;
           }
        }

        if (bAllocBuffer) {
            FreeSplMem(pJob);
        }

        pSpool->dwTickCount = GetTickCount();
    }

    pSpool->cWritePrinters++;

    
    //  WritePrinter will cache on the client side all IO's
    //  into BUFFER_SIZE writes.    This is done to minimize
    //  the number of RPC calls if the app is doing a lot of small
    //  sized IO's.

    while (cbBuf && ReturnValue) {

        // Special Case FileIO's since file system prefers large
        // writes, RPC is optimal with smaller writes.

        //
        // RPC should manage its own buffer size.  I'm not sure why we
        // only do this optimization for file writes.
        //

        if ((pSpool->hFile != INVALID_HANDLE_VALUE) &&
            (pSpool->cbBuffer == 0) &&
            (cbBuf > BUFFER_SIZE)) {

            ReturnValue = WriteFile(pSpool->hFile, pBuffer, cbBuf, &cbWritten, NULL);

            DBGMSG(DBG_TRACE, ("WritePrinter - WriteFile pSpool %x hFile %x pBuffer %x cbBuffer %d cbWritten %d\n",
                               pSpool, pSpool->hFile, pBuffer, pSpool->cbBuffer, *pcWritten));


        } else {

            // Fill cache buffer so IO is optimal size.

            SPLASSERT(pSpool->cbBuffer <= BUFFER_SIZE);

            //
            // cb is the amount of new data we want to put in the buffer.
            // It is the min of the space remaining, and the size of the
            // input buffer.
            //
            cb = min((BUFFER_SIZE - pSpool->cbBuffer), cbBuf);

            if (cb != 0) {
                if (pSpool->pBuffer == NULL) {
                    pSpool->pBuffer = VirtualAlloc(NULL, BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);
                    if (pSpool->pBuffer == NULL) {

                        DBGMSG(DBG_WARNING, ("VirtualAlloc Failed to allocate 4k buffer %d\n",GetLastError()));
                        ReturnValue = FALSE;
                        goto EndWritePrinter;
                    }
                }
                CopyMemory( pSpool->pBuffer + pSpool->cbBuffer, pBuffer, cb);
                pSpool->cbBuffer += cb;
                cbWritten = cb;
                pSpool->cCacheWrite++;
            }

            //
            // cbWritten is the amount of new data that has been put into
            // the buffer.  It may not have been written to the device, but
            // since it is in our buffer, the driver can assume it has been
            // written (e.g., the *pcbWritten out parameter to WritePrinter
            // includes this data).
            //

            if (pSpool->cbBuffer == BUFFER_SIZE)
            {
                DWORD cbPending = pSpool->cbFlushPending;
                DWORD cbFlushed = 0;
                ReturnValue = FlushBuffer(pSpool, &cbFlushed);
                if(!NumOfCmpltWrts && ReturnValue)
                {
                    NumOfCmpltWrts = 1;
                }
                if(!ReturnValue &&
                   (ERROR_PRINT_CANCELLED == GetLastError()) &&
                   pSpool->hSplPrinter &&
                   pSpool->cOKFlushBuffers)
                {
                    SJobCancelInfo JobCancelInfo;

                    JobCancelInfo.pSpool                 = pSpool;
                    JobCancelInfo.pInitialBuf            = pInitialBuf;
                    JobCancelInfo.pcbWritten             = &cbWritten;
                    JobCancelInfo.pcTotalWritten         = &cTotalWritten;
                    JobCancelInfo.NumOfCmpltWrts         = NumOfCmpltWrts;  
                    JobCancelInfo.cbFlushed              = cbFlushed;
                    JobCancelInfo.ReqTotalDataSize       = ReqTotalDataSize;
                    JobCancelInfo.ReqToWriteDataSize     = ReqToWriteDataSize;
                    JobCancelInfo.FlushPendingDataSize   = FlushPendingDataSize;
                    JobCancelInfo.ReturnValue            = ReturnValue;

                    ReturnValue = JobCanceled(&JobCancelInfo);
                }
            }
        }
        // Update Total Byte Count after the Flush or File IO
        // This is done because the IO might fail and thus
        // the correct value written might have changed.


        if(!pSpool->Flushed)
        {
            SPLASSERT(cbBuf >= cbWritten);
            cbBuf         -= cbWritten;
            pBuffer       += cbWritten;
            cTotalWritten += cbWritten;
        }
        else
            break;

    }

    // Return the number of bytes written.

    *pcWritten = cTotalWritten;

    DBGMSG(DBG_TRACE, ("WritePrinter cbWritten %d ReturnValue %d\n",*pcWritten, ReturnValue));

    //
    // Remember if there is a flush pending on this WritePrinter.  If there
    // is, then when we return, we say we've written all the bytes, but
    // we really haven't since there's some left in the buffer.  If the
    // user cancels the next job, then we need to flush out the last
    // bytes, since the driver assumes that we've written it out and
    // tracks the printer state.
    //
    if(!pSpool->Flushed)
        pSpool->cbFlushPending = pSpool->cbBuffer;

    
EndWritePrinter:

    vUnprotectHandle( hPrinter );

    return ReturnValue;
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue = TRUE;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    try {

        FlushBuffer(pSpool, NULL);

        if( pSpool->hFile == INVALID_HANDLE_VALUE ){

            RpcTryExcept {

                if (ReturnValue = RpcEndPagePrinter(pSpool->hPrinter)) {

                    SetLastError(ReturnValue);
                    ReturnValue = FALSE;

                } else

                    ReturnValue = TRUE;

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                ReturnValue = FALSE;

            } RpcEndExcept
        }

    } except (1) {

        SetLastError(ERROR_INVALID_HANDLE);
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;

}

BOOL
AbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwNumWritten = 0;
    DWORD   dwPointer = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    //
    // No longer in StartDoc mode; also resetting the tray icon notification
    // flag so that upcoming StartDocPrinter/AddJobs indicate a new job.
    //
    pSpool->Status &= ~(SPOOL_STATUS_STARTDOC|SPOOL_STATUS_TRAYICON_NOTIFIED);

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {

        if (pSpool->Status & SPOOL_STATUS_ADDJOB) {

            // Close your handle to the .SPL file, otherwise the
            // DeleteJob will fail in the Spooler

            CloseSpoolFileHandles( pSpool );

            if (!SetJob(hPrinter,pSpool->JobId, 0, NULL, JOB_CONTROL_DELETE)) {
                DBGMSG(DBG_WARNING, ("Error: SetJob cancel returned failure with %d\n", GetLastError()));
            }

            ReturnValue = ScheduleJob(hPrinter, pSpool->JobId);
            goto Done;

        } else {
            DBGMSG(DBG_WARNING, ("Error: pSpool->hFile != INVALID_HANDLE_VALUE and pSpool's status is not SPOOL_STATUS_ADDJOB\n"));
        }

    }

    RpcTryExcept {

        if (ReturnValue = RpcAbortPrinter(pSpool->hPrinter)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

Done:

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
)
{
    BOOL    bReturn = FALSE;
    DWORD   dwStatus;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FlushBuffer(pSpool, NULL);

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    RpcTryExcept {

        cbBuf = min(BUFFER_SIZE, cbBuf);

        if (bLoadedBySpooler && fpYReadPrinter && pSpool->hSplPrinter) {

            dwStatus = (*fpYReadPrinter)(pSpool->hSplPrinter, pBuf, cbBuf, pNoBytesRead, FALSE);

        } else {

            dwStatus = RpcReadPrinter(pSpool->hPrinter, pBuf, cbBuf, pNoBytesRead);
        }

        if (dwStatus) {
            SetLastError(dwStatus);
        } else {
            bReturn = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));

    } RpcEndExcept

Done:

    vUnprotectHandle( hPrinter );
    return bReturn;
}

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
    )

/*++
    Function Description:  This is an internal function used by the spooler during playback of
                           EMF jobs. It is called from gdi32.dll. SplReadPrinter is equivalent
                           to ReadPrinter in all respects except that it returns a pointer to the
                           buffer in pBuf. The spool file is memory mapped.

    Parameters:  hPrinter  --  handle to the printer
                 pBuf      --  pointer to the buffer
                 cbBuf     --  number to bytes to read

    Return Values: TRUE if sucessful (pBuf contains the required pointer)
                   FALSE otherwise
--*/
{
    BOOL bReturn = FALSE;
    DWORD   dwStatus = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    // This function is to be used only internally. Hence no RPC interface is required.
    if (!bLoadedBySpooler || !fpYSplReadPrinter || !pSpool->hSplPrinter) {
        SetLastError(ERROR_NOT_SUPPORTED);
        goto Done;
    }

    FlushBuffer(pSpool, NULL);

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    // Optimal buffer size of 4K need not be used for non RPC code paths.

    dwStatus = (*fpYSplReadPrinter)(pSpool->hSplPrinter, pBuf, cbBuf, FALSE);

    if (dwStatus) {
        SetLastError(dwStatus);
    } else {
        bReturn = TRUE;
    }

Done:

    vUnprotectHandle( hPrinter );
    return bReturn;
}

BOOL
EndDocPrinter(
    HANDLE  hPrinter
    )
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD dwRetryTimes;
    DWORD dwNeeded;
    USEROBJECTFLAGS uof;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if (GetUserObjectInformation(GetProcessWindowStation(), UOI_FLAGS, &uof, sizeof(uof), &dwNeeded) && (WSF_VISIBLE & uof.dwFlags)) {

        //
        // hack: if we are in interactive window station (i.e. not in a service)
        // we need to wait the tray code to startup, so we don't miss balloon
        // notifications. there is still possibility of missing balloon notifications
        // but very unlikely. the complete fix will come with CSR in place (i.e. in
        // Blackcomb)
        //
        dwRetryTimes = 20;
        while (dwRetryTimes--){

            if (NULL == FindWindow(cszTrayListenerClassName, NULL)){

                Sleep(100);
                continue;
            }

            Sleep(100);
            break;
        }
    }

    try {

        FlushBuffer(pSpool, NULL);

        //
        // No longer in StartDoc mode; also resetting the tray icon
        // notification flag so that upcoming StartDocPrinter/AddJobs
        // indicate a new job.
        //
        pSpool->Status &= ~(SPOOL_STATUS_STARTDOC|SPOOL_STATUS_TRAYICON_NOTIFIED);

        if (pSpool->hFile != INVALID_HANDLE_VALUE) {

            if (CloseHandle(pSpool->hFile)) {
                pSpool->hFile = INVALID_HANDLE_VALUE;
            }

            ReturnValue = ScheduleJob(hPrinter, pSpool->JobId);
            pSpool->Status &= ~SPOOL_STATUS_ADDJOB;

            DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));

        } else {

            RpcTryExcept {
                if(bLoadedBySpooler && fpYEndDocPrinter && pSpool->hSplPrinter)
                {
                    ReturnValue = (*fpYEndDocPrinter)(pSpool->hSplPrinter,FALSE);
                }
                else
                {
                    ReturnValue = RpcEndDocPrinter(pSpool->hPrinter);
                }

                if (ReturnValue)
                {

                    SetLastError(ReturnValue);
                    ReturnValue = FALSE;
                }
                else
                    ReturnValue = TRUE;

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                ReturnValue = FALSE;

            } RpcEndExcept

            DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));
        }

    } except (1) {
        SetLastError(ERROR_INVALID_HANDLE);
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    BOOL        ReturnValue = FALSE;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    UINT        cRetry = 0;
    FieldInfo   *pFieldInfo;
    DWORD       cbStruct;

    switch (Level) {

    case 1:
        pFieldInfo = AddJobFields;
        cbStruct = sizeof(ADDJOB_INFO_1W);
        break;

    case 2:
    case 3:
    {
        //
        // Level 3 is meant to be used only by RDR/SRV. The spooler needs
        // to know whether the job comes from RDR/SRV. See LocalScheduleJob
        // in localspl.dll for details
        //
        //
        // This is an internal call used by the server when it needs
        // to submit a job with a specific machine name (used for
        // netbiosless notifications, or if the user want the notification
        // to go to the computer instead of the user).
        //
        // IN: (PADDJOB_INFO_2W)pData - points to buffer that receives the
        //         path and ID.  On input, pData points to the computer name.
        //         pData->pData must not point to a string inside of the pData
        //         buffer, and it must be smaller than cbBuf -
        //         sizeof( ADDJOB_INFO_2W ).  It must not be szNull or NULL.
        //

        PADDJOB_INFO_2W pInfo2;

        pInfo2 = (PADDJOB_INFO_2W)pData;

        //
        // Check valid pointer and buffer.
        //
        if( !pInfo2 ||
            !pInfo2->pData ||
            !pInfo2->pData[0] ||
            cbBuf < sizeof( *pInfo2 ) +
                    (wcslen( pInfo2->pData ) + 1) * sizeof( WCHAR )){

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        //
        // Simple marshalling.
        //
        wcscpy( (LPWSTR)(pInfo2 + 1), pInfo2->pData );
        pInfo2->pData = (LPWSTR)sizeof( *pInfo2 );

        pFieldInfo = AddJob2Fields;
        cbStruct = sizeof(ADDJOB_INFO_2W);

        break;
    }

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    try {

        do {

            RpcTryExcept {

                if (ReturnValue = RpcAddJob(pSpool->hPrinter, Level, pData,
                                            cbBuf, pcbNeeded)) {

                    SetLastError(ReturnValue);
                    ReturnValue = FALSE;

                } else {

                    ReturnValue = MarshallUpStructure(pData, pFieldInfo, cbStruct, RPC_CALL);
                    pSpool->Status |= SPOOL_STATUS_ADDJOB;
                }

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                ReturnValue = FALSE;

            } RpcEndExcept

        } while( !ReturnValue &&
                 GetLastError() == ERROR_INVALID_HANDLE &&
                 cRetry++ < MAX_RETRY_INVALID_HANDLE &&
                 RevalidateHandle( pSpool ));

        if( ReturnValue ){

            //
            // Notify the tray icon that a new job has been sent.
            //
            vUpdateTrayIcon( hPrinter, ((PADDJOB_INFO_1)pData)->JobId );
        }

    } except (1) {
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
    )
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    BOOL bReturn;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    bReturn = ScheduleJobWorker( pSpool, JobId );

    vUnprotectHandle( hPrinter );

    return bReturn;
}

BOOL
ScheduleJobWorker(
    PSPOOL pSpool,
    DWORD  JobId
    )
{
    BOOL ReturnValue;

    try {

        //
        // The job has been scheduled, so reset the flag that indicates
        // the tray icon has been notified.  Any new AddJob/StartDocPrinter/
        // StartDoc events should send a new notification, since it's really
        // a new job.
        //
        pSpool->Status &= ~SPOOL_STATUS_TRAYICON_NOTIFIED;

        FlushBuffer(pSpool, NULL);

        RpcTryExcept {

            if (ReturnValue = RpcScheduleJob(pSpool->hPrinter, JobId)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                pSpool->Status &= ~SPOOL_STATUS_ADDJOB;
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

        return ReturnValue;
    } except (1) {
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return(FALSE);
    }
}

DWORD WINAPI
AsyncPrinterProperties(
    PVOID pData
    )
{
     PrtPropsData *ThrdData = (PrtPropsData *)pData;

     RpcTryExcept
     {
         RPCSplWOW64PrinterProperties(ThrdData->hWnd,
                                      ThrdData->PrinterName,
                                      ThrdData->Flag,
                                      ThrdData->dwRet);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}

BOOL
PrinterPropertiesNative(
    HWND    hWnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    This is main PrinterProperties entri point and will call into the
    our DevicePropertySheets() for UI pop up


Arguments:

    hWnd        - Handle to the window parent

    hPrinter    - Handle to the printer interested


Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.
    To get extended error information, call GetLastError.

Author:

    13-Jun-1996 Thu 15:22:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PRINTER_INFO_2          *pPI2 = NULL;
    DEVICEPROPERTYHEADER    DPHdr;
    LONG                    Result;
    DWORD                   cb;
    DWORD                   dwValue = 1;
    BOOL                    bAllocBuffer = FALSE, bReturn;
    BYTE                    btBuffer[MAX_STATIC_ALLOC];

    //
    // Ensure the printer handle is valid
    //
    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.hPrinter       = hPrinter;
    DPHdr.Flags          = DPS_NOPERMISSION;

    //
    // Do a GetPrinter() level2 to get the printer name.
    //

    pPI2 = (PPRINTER_INFO_2) btBuffer;

    bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, MAX_STATIC_ALLOC, &cb);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pPI2 = (PPRINTER_INFO_2)LocalAlloc(LMEM_FIXED, cb))) {

         bAllocBuffer = TRUE;
         bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, cb, &cb);
    }

    //
    // Set the printer name.
    //
    if (bReturn) {
        DPHdr.pszPrinterName = pPI2->pPrinterName;
    } else {
        DPHdr.pszPrinterName = NULL;
    }

    //
    // Attempt to set the printer data to determine access privilages.
    //
    if (SetPrinterData( hPrinter,
                        TEXT( "PrinterPropertiesPermission" ),
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof( dwValue ) ) == STATUS_SUCCESS ) {
        //
        // Indicate we have permissions.
        //
        DPHdr.Flags &= ~DPS_NOPERMISSION;
    }

    //
    // Call Common UI to call do the and call the driver.
    //
    if ( CallCommonPropertySheetUI(hWnd,
                                  (PFNPROPSHEETUI)DevicePropertySheets,
                                  (LPARAM)&DPHdr,
                                  (LPDWORD)&Result) < 0 ) {
        Result = FALSE;

    } else {

        Result = TRUE;

    }

    if (bAllocBuffer) {
        LocalFree((HLOCAL)pPI2);
    }

    vUnprotectHandle( hPrinter );
    return Result;
}


BOOL
PrinterPropertiesThunk(
    HWND    hWnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    This is main PrinterProperties entri point and will call into the
    our DevicePropertySheets() for UI pop up


Arguments:

    hWnd        - Handle to the window parent

    hPrinter    - Handle to the printer interested


Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.
    To get extended error information, call GetLastError.

--*/

{
    PRINTER_INFO_2          *pPI2 = NULL;
    DEVICEPROPERTYHEADER    DPHdr;
    LONG                    Result;
    DWORD                   cb;
    DWORD                   dwValue = 1;
    BOOL                    bAllocBuffer = FALSE, bReturn;
    BYTE                    btBuffer[MAX_STATIC_ALLOC];
    DWORD                   dwRet;

    //
    // Ensure the printer handle is valid
    //
    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.hPrinter       = hPrinter;
    DPHdr.Flags          = DPS_NOPERMISSION;

    //
    // Do a GetPrinter() level2 to get the printer name.
    //

    pPI2 = (PPRINTER_INFO_2) btBuffer;

    bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, MAX_STATIC_ALLOC, &cb);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pPI2 = (PPRINTER_INFO_2)LocalAlloc(LMEM_FIXED, cb))) {

         bAllocBuffer = TRUE;
         bReturn = GetPrinter(hPrinter, 2, (LPBYTE)pPI2, cb, &cb);
    }

    //
    // Set the printer name.
    //
    if (bReturn)
    {
        if(pPI2->pPrinterName)
        {
             //
             // Attempt to set the printer data to determine access privilages.
             //
             DWORD Flag = DPS_NOPERMISSION;

             if (SetPrinterData( hPrinter,
                                 TEXT( "PrinterPropertiesPermission" ),
                                 REG_DWORD,
                                 (LPBYTE)&dwValue,
                                 sizeof( dwValue ) ) == STATUS_SUCCESS )
             {
                 //
                 // Indicate we have permissions.
                 //
                 Flag &= ~DPS_NOPERMISSION;
             }

             RpcTryExcept
             {
                  if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
                     ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                  {
                       HANDLE hUIMsgThrd  = NULL;
                       DWORD  UIMsgThrdId = 0;
                       PrtPropsData ThrdData;

                       ThrdData.hWnd        = (ULONG_PTR)hWnd;
                       ThrdData.dwRet       = &dwRet;
                       ThrdData.PrinterName = (LPWSTR)pPI2->pPrinterName;
                       ThrdData.Flag        = Flag;

                       if(!(hUIMsgThrd = CreateThread(NULL,
                                                      INITIAL_STACK_COMMIT,
                                                      AsyncPrinterProperties,
                                                      (PVOID)&ThrdData,
                                                      0,
                                                      &UIMsgThrdId)))
                       {
                            dwRet = GetLastError();
                       }
                       //
                       // The following is the required message loop for processing messages
                       // from the UI in case we have a window handle.
                       //
                       //
                       if(hUIMsgThrd)
                       {
                           MSG msg;
                           while (GetMessage(&msg, NULL, 0, 0))
                           {
                               //
                               // In This message loop We should trap a User defined message
                               // which indicates the success or the failure of the operation
                               //
                               if(msg.message == WM_ENDPRINTERPROPERTIES)
                               {
                                    Result     = (LONG)msg.wParam;
                                    if(Result == FALSE)
                                         SetLastError((DWORD)msg.lParam);
                                    DelHandleFromList(hWnd);
                                    break;
                               }
                               else if(msg.message == WM_SURROGATEFAILURE)
                               {
                                    //
                                    // This means that the server process died and we have
                                    // break from the message loop
                                    //
                                    Result = FALSE;
                                    SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                    break;
                               }
                               TranslateMessage(&msg);
                               DispatchMessage(&msg);
                           }
                       }

                       if(hUIMsgThrd)
                       {
                           WaitForSingleObject(hUIMsgThrd,INFINITE);
                           CloseHandle(hUIMsgThrd);
                       }
                  }
                  else
                  {
                      SetLastError(dwRet);
                  }
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
             }
             RpcEndExcept
        }
        else
        {
             Result = FALSE;
        }
    }
    else
    {
         Result = FALSE;
    }

    if (bAllocBuffer) {
        LocalFree((HLOCAL)pPI2);
    }

    vUnprotectHandle( hPrinter );
    return Result;
}


BOOL
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
    )
{
     if(RunInWOW64())
     {
          return(PrinterPropertiesThunk(hWnd,
                                        hPrinter));
     }
     else
     {
          return(PrinterPropertiesNative(hWnd,
                                         hPrinter));
     }
}


DWORD
GetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    WCHAR   szEMFDatatype[] = L"PrintProcCaps_EMF";
    WCHAR   szEMFDatatypeWithVersion[] = L"PrintProcCaps_NT EMF 1.008";

    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){
        pData = (PBYTE)&ReturnValue;
    }

    if (!pType) {
        pType = (PDWORD) &ReturnType;
    }

    //
    // If pValueName is PrintProcCaps_datatype add the EMF version if necessary.
    // This hardcoded EMF version number will have to be modified whenever GDI changes
    // the version number. This change has been made for GetPrintProcessorCapabilities.
    //

    if (pValueName && !_wcsicmp(pValueName, szEMFDatatype)) {
         pValueName = (LPWSTR) szEMFDatatypeWithVersion;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcGetPrinterData(pSpool->hPrinter, pValueName, pType,
                                             pData, nSize, pcbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

DWORD
GetPrinterDataExW(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   Key = 0;
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){
        pData = (PBYTE)&ReturnValue;
    }

    if (!pType) {
        pType = (PDWORD) &ReturnType;
    }

    if (!pKeyName) {
        pKeyName = (PWSTR) &Key;
    }

    do
    {
        RpcTryExcept {

            ReturnValue =  RpcGetPrinterDataEx( pSpool->hPrinter,
                                                pKeyName,
                                                pValueName,
                                                pType,
                                                pData,
                                                nSize,
                                                pcbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while (ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle(pSpool));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

HANDLE
GetSpoolFileHandle(
    HANDLE   hPrinter
)

/*++
Function Description: Gets spool file handle which is used by GDI in recording EMF
                      data.

Parameters: hPrinter - Printer handle

Return Values: Handle to the spool file if successful
               INVALID_HANDLE_VALUE otherwise
--*/

{
    HANDLE hReturn = INVALID_HANDLE_VALUE;
    DWORD  dwAppProcessId, cbBuf, dwNeeded, dwRpcReturn;

    FILE_INFO_CONTAINER FileInfoContainer;
    SPOOL_FILE_INFO_1 SpoolFileInfo;

    PSPOOL pSpool = (PSPOOL) hPrinter;

    if (eProtectHandle(hPrinter, FALSE)) {
        return hReturn;
    }

    if (pSpool->hSpoolFile != INVALID_HANDLE_VALUE) {
        // GetSpoolFileHandle has already been called; return old handles
        hReturn = pSpool->hSpoolFile;
        goto CleanUp;
    }

    dwAppProcessId = GetCurrentProcessId();

    FileInfoContainer.Level = 1;
    FileInfoContainer.FileInfo.Level1 = &SpoolFileInfo;

    RpcTryExcept {

        dwRpcReturn = RpcGetSpoolFileInfo2(pSpool->hPrinter,
                                          dwAppProcessId,
                                          1,
                                          &FileInfoContainer);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwRpcReturn = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    if (dwRpcReturn) {
        SetLastError(dwRpcReturn);
    } else {

        pSpool->hSpoolFile = FileInfoContainer.FileInfo.Level1->hSpoolFile;
        pSpool->dwSpoolFileAttributes = FileInfoContainer.FileInfo.Level1->dwAttributes;
        hReturn = pSpool->hSpoolFile;
    }

CleanUp:

    vUnprotectHandle(hPrinter);

    return hReturn;
}


HANDLE
CommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile,
    DWORD   cbCommit
)

/*++
Function Description: Commits cbCommit bytes in the spool file. For temporary files, a new
                      spool file handle is returned.

Parameters: hPrinter   -- printer handle
            hSpoolFile -- spool file handle (from GetSpoolFileHandle)
            cbCommit   -- number of bytes to commit (incremental count)

Return Values: New spool file handle for temporary spool files and
               old handle for persistent files
--*/

{
    HANDLE  hReturn = INVALID_HANDLE_VALUE;
    DWORD   dwAppProcessId, dwRpcReturn;
    DWORD   dwNeeded, cbBuf;
    HANDLE  hNewSpoolFile;

    FILE_INFO_CONTAINER FileInfoContainer;
    SPOOL_FILE_INFO_1 SpoolFileInfo;

    PSPOOL pSpool = (PSPOOL) hPrinter;

    if (eProtectHandle(hPrinter, FALSE)) {
        return hReturn;
    }

    if ((pSpool->hSpoolFile == INVALID_HANDLE_VALUE) ||
        (pSpool->hSpoolFile != hSpoolFile)) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto CleanUp;
    }

    dwAppProcessId = GetCurrentProcessId();

    FileInfoContainer.Level = 1;
    FileInfoContainer.FileInfo.Level1 = &SpoolFileInfo;


    RpcTryExcept {

        dwRpcReturn = RpcCommitSpoolData2(pSpool->hPrinter,
                                         dwAppProcessId,
                                         cbCommit,
                                         1,
                                         &FileInfoContainer);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwRpcReturn = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    if (dwRpcReturn) {

        SetLastError(dwRpcReturn);

    } else {

        hNewSpoolFile = FileInfoContainer.FileInfo.Level1->hSpoolFile;

        if (hNewSpoolFile != SPOOL_INVALID_HANDLE_VALUE_32BIT &&
            hNewSpoolFile != INVALID_HANDLE_VALUE) {
            CloseHandle(pSpool->hSpoolFile);
            pSpool->hSpoolFile = hNewSpoolFile;
        }

        hReturn = pSpool->hSpoolFile;
    }

CleanUp:

    vUnprotectHandle(hPrinter);

    return hReturn;
}



BOOL
CloseSpoolFileHandle(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile
)

/*++
Function Description:  Closes the client and server handles for the spool file.

Parameters: hPrinter    - printer handle
            hSpoolFile  - spool file handle (used for consistency across APIs)

Return Values: TRUE if sucessfule; FALSE otherwise
--*/

{
    BOOL   bReturn = FALSE;
    DWORD  dwLastError = ERROR_SUCCESS;
    PSPOOL pSpool = (PSPOOL) hPrinter;

    if (eProtectHandle(hPrinter, FALSE)) {
        return FALSE;
    }

    if (pSpool->hSpoolFile != hSpoolFile) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    if (pSpool->hSpoolFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pSpool->hSpoolFile);
        pSpool->hSpoolFile = INVALID_HANDLE_VALUE;
    }

    RpcTryExcept {

       dwLastError = RpcCloseSpoolFileHandle(pSpool->hPrinter);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

       dwLastError = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    if (dwLastError != ERROR_SUCCESS) {
        SetLastError(dwLastError);
    } else {
        bReturn = TRUE;
    }

Done:

    vUnprotectHandle(hPrinter);
    return bReturn;
}

DWORD
EnumPrinterDataW(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of pValueName
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of pData
    LPDWORD pcbData         // address for size of data buffer
    )
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pValueName && !cbValueName)
        pValueName = (LPWSTR) &ReturnValue;

    if( !pData && !cbData )
        pData = (PBYTE)&ReturnValue;

    if (!pType)
        pType = (PDWORD) &ReturnType;

    do {

        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterData(  pSpool->hPrinter,
                                                dwIndex,
                                                pValueName,
                                                cbValueName,
                                                pcbValueName,
                                                pType,
                                                pData,
                                                cbData,
                                                pcbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

DWORD
EnumPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
    )
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   i;
    PPRINTER_ENUM_VALUES pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pEnumValues && !cbEnumValues)
        pEnumValues = (LPBYTE) &ReturnValue;


    do {

        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterDataEx(pSpool->hPrinter,
                                                pKeyName,
                                                pEnumValues,
                                                cbEnumValues,
                                                pcbEnumValues,
                                                pnEnumValues);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

        if (ReturnValue == ERROR_SUCCESS) {

            if (pEnumValues) {

                if (!MarshallUpStructuresArray((LPBYTE)pEnumValue, *pnEnumValues,PrinterEnumValuesFields,
                                                sizeof(PRINTER_ENUM_VALUES), RPC_CALL) ) {

                    ReturnValue = GetLastError();
                }
            }
        }
    } while ( ReturnValue == ERROR_INVALID_HANDLE &&
              cRetry++ < MAX_RETRY_INVALID_HANDLE &&
              RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
EnumPrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of pValueName
    LPDWORD pcbSubkey       // address for size of value buffer
    )
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pSubkey && !cbSubkey)
        pSubkey = (LPWSTR) &ReturnValue;

    do {
        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterKey(pSpool->hPrinter,
                                             pKeyName,
                                             pSubkey,
                                             cbSubkey,
                                             pcbSubkey);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while ( ReturnValue == ERROR_INVALID_HANDLE &&
              cRetry++ < MAX_RETRY_INVALID_HANDLE &&
              RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
DeletePrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName
    )
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterData(pSpool->hPrinter, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
DeletePrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
    )
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterDataEx(pSpool->hPrinter, pKeyName, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

DWORD
DeletePrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
    )
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterKey(pSpool->hPrinter, pKeyName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    do {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterData(pSpool->hPrinter, pValueName, Type,
                                            pData, cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}


DWORD
SetPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT    cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return ERROR_INVALID_HANDLE;
    }

    if (!pKeyName)
        pKeyName = L"";

    do {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterDataEx(  pSpool->hPrinter,
                                                pKeyName,
                                                pValueName,
                                                Type,
                                                pData,
                                                cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = TranslateExceptionCode(RpcExceptionCode());

        } RpcEndExcept

    } while( ReturnValue == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

VOID
SplDriverUnloadComplete(
    LPWSTR      pDriverFile
)
/*++
Function Description: The information on the driver unload is set to the spooler
                      so that it may continue any pending upgrades.

Parameters:  pDriverFile       --  driver file name which was unloaded

Return Value: NONE
--*/
{
    if (bLoadedBySpooler && fpYDriverUnloadComplete) {
        (*fpYDriverUnloadComplete)(pDriverFile);
    }
}


HANDLE
LoadNewCopy(
    LPWSTR      pConfigFile,
    DWORD       dwFlags,
    DWORD       dwVersion
)
/*++
Function Description: This function loads the driver file and creates a node to
                      maintain its reference count. It is called inside ListAccessSem.

Parameters:  pConfigFile       --  driver config file path
             dwFlags           --  flags for loading
             dwVersion         --  version number of the driver since reboot

Return Value: handle to the library
--*/
{
    HANDLE          hReturn = NULL;
    PDRVLIBNODE     pTmpDrvLib, pNewDrvLib = NULL;
    ULONG_PTR       lActCtx         = 0;
    BOOL            bDidActivate    = FALSE;

    //
    // Activate the empty context
    //
    bDidActivate = ActivateActCtx( ACTCTX_EMPTY, &lActCtx );

    // Inside ListAccessSem

    hReturn = LoadLibraryEx(pConfigFile, NULL, dwFlags);

    if (hReturn) {

       // Create a new DRVLIBNODE
       if (pNewDrvLib = (PDRVLIBNODE) AllocSplMem(sizeof(DRVLIBNODE))) {

           pNewDrvLib->hLib = hReturn;
           pNewDrvLib->dwVersion = dwVersion;

           // Initialize ref cnt to 2. This ensures that the library remains loaded
           // in the normal course.
           pNewDrvLib->dwNumHandles = 2;
           pNewDrvLib->bArtificialIncrement = TRUE;

           if (!(pNewDrvLib->pConfigFile = AllocSplStr(pConfigFile)))
           {
               FreeSplMem(pNewDrvLib);
               pNewDrvLib = NULL;
           }

       }

       if (!pNewDrvLib) {
           // Free the library
           FreeLibrary(hReturn);
           hReturn = NULL;
       } else {
           // Add the node to the list
           pNewDrvLib->pNext = pStartDrvLib;
           pStartDrvLib = pNewDrvLib;
       }
    }

    //
    // Deactivate the context
    //
    if( bDidActivate ){
        DeactivateActCtx( 0, lActCtx );
    }

    return hReturn;
}

PDRVLIBNODE
FindDriverNode(
    LPWSTR    pConfigFile,
    DWORD     dwVersion,
    BOOL      bUseVersion
)
/*++
Function Description: Searches thru the list of driver nodes to get the
                      required driver information. In case of version mismatch the
                      artificial increment on the old driver is removed.

                      This function is called inside the ListAccessSem

Parameters:  pConfigFile       --  driver config file name
             dwVersion         --  version number of the driver since reboot
             bUseVersion       --  flag to use the version number

Return Values: pDrvLibNode for the required driver, if present
--*/
{
    PDRVLIBNODE pTmpDrvLib;

    for (pTmpDrvLib = pStartDrvLib; pTmpDrvLib; pTmpDrvLib = pTmpDrvLib->pNext) {
        if (!_wcsicmp(pConfigFile, pTmpDrvLib->pConfigFile)) {
            break;
        }
    }

    if (pTmpDrvLib && bUseVersion && (pTmpDrvLib->dwVersion != dwVersion)) {
        if (pTmpDrvLib->bArtificialIncrement) {
            pTmpDrvLib->bArtificialIncrement = FALSE;
            if (RefCntUnloadDriver(pTmpDrvLib->hLib, FALSE)) {
                pTmpDrvLib = NULL;
            }
        }
    }

    return pTmpDrvLib;
}

HANDLE
RefCntLoadDriver(
    LPWSTR  pConfigFile,
    DWORD   dwFlags,
    DWORD   dwVersion,
    BOOL    bUseVersion
)
/*++
Function Description: This function loads the driver config file. It reuses existing handles
                      to avoid expensive Loads and Frees. In case of a version mismatch the
                      original handle is freed and we load the driver again.

Parameters:  pConfigFile       --  driver config file name
             dwFlags           --  flags for loading (ignored if existing handle is returned)
             dwVersion         --  version of the driver file since reboot
             bUseVersion       --  flag to use the version number check

Return Value: handle to the library
--*/
{
    HANDLE      hReturn = NULL;
    PDRVLIBNODE pTmpDrvLib;

    if (!pConfigFile || !*pConfigFile) {
        // nothing to load
        return hReturn;
    }

    EnterCriticalSection( &ListAccessSem );

    pTmpDrvLib = FindDriverNode(pConfigFile, dwVersion, bUseVersion);

    // Use existing handle, if any.
    if (pTmpDrvLib) {

        // Increment the ref cnt for library usage;
        pTmpDrvLib->dwNumHandles += 1;
        hReturn = pTmpDrvLib->hLib;

    } else {

        // Reload the library
        hReturn = LoadNewCopy(pConfigFile, dwFlags, dwVersion);
    }

    LeaveCriticalSection( &ListAccessSem );

    return hReturn;
}

BOOL
RefCntUnloadDriver(
    HANDLE  hLib,
    BOOL    bNotifySpooler
)
/*++
Function Description: This function decrements the reference count for the library usage.
                      It also frees the library if the reference count falls to zero.

Parameters: hLib           -- handle of the library to free
            bNotifySpooler -- flag to notify the spooler of the unload

Return Value: TRUE if the driver library was freed
              FALSE otherwise
--*/
{
    BOOL        bReturn = FALSE;
    PDRVLIBNODE *ppTmpDrvLib, pTmpDrvLib;
    LPWSTR      pConfigFile = NULL;

    EnterCriticalSection( &ListAccessSem );

    for (ppTmpDrvLib = &pStartDrvLib;
         pTmpDrvLib = *ppTmpDrvLib;
         ppTmpDrvLib = &(pTmpDrvLib->pNext)) {

         if (pTmpDrvLib->hLib == hLib) {

            // Reduce the ref cnt
            SPLASSERT(pTmpDrvLib->dwNumHandles > 0);
            pTmpDrvLib->dwNumHandles -= 1;

            // Free the library and the node if ref cnt is zero
            if (pTmpDrvLib->dwNumHandles == 0) {

                FreeLibrary(hLib);
                *ppTmpDrvLib = pTmpDrvLib->pNext;
                pConfigFile = AllocSplStr(pTmpDrvLib->pConfigFile);
                FreeSplStr(pTmpDrvLib->pConfigFile);
                FreeSplMem(pTmpDrvLib);

                bReturn = TRUE;
            }

            break;
        }
    }

    LeaveCriticalSection( &ListAccessSem );

    if (bNotifySpooler && bReturn) {
        SplDriverUnloadComplete(pConfigFile);

    }

    FreeSplStr(pConfigFile);

    return bReturn;
}

BOOL
ForceUnloadDriver(
    LPWSTR  pConfigFile
)
/*++
Function Description: This function will remove any artificial increment on the
                      config file.

Parameters:  pConfigFile   --  driver config file name

Return Values: TRUE if the config file no longer loaded;
               FALSE otherwise
--*/
{
    BOOL        bReturn = TRUE;
    PDRVLIBNODE *ppTmpDrvLib, pTmpDrvLib;

    if (!pConfigFile || !*pConfigFile) {
       // nothing to unload
       return bReturn;
    }

    EnterCriticalSection( &ListAccessSem );

    pTmpDrvLib = FindDriverNode(pConfigFile, 0, FALSE);

    if (pTmpDrvLib) {
        if (pTmpDrvLib->bArtificialIncrement) {
            pTmpDrvLib->bArtificialIncrement = FALSE;
            bReturn = RefCntUnloadDriver(pTmpDrvLib->hLib, FALSE);
        } else {
            bReturn = FALSE;
        }
    } else {
        bReturn = TRUE;
    }

    LeaveCriticalSection( &ListAccessSem );

    return bReturn;
}


HANDLE
LoadPrinterDriver(
    HANDLE  hPrinter
)
{
    PDRIVER_INFO_5  pDriverInfo;
    DWORD   cbNeeded, dwVersion;
    HANDLE  hModule=FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    BOOL    bAllocBuffer = FALSE, bReturn;

    pDriverInfo = (PDRIVER_INFO_5) btBuffer;

    bReturn = GetPrinterDriverW(hPrinter, NULL, 5, (LPBYTE)pDriverInfo,
                                MAX_STATIC_ALLOC, &cbNeeded);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pDriverInfo = (PDRIVER_INFO_5)LocalAlloc(LMEM_FIXED, cbNeeded))) {

         bAllocBuffer = TRUE;
         bReturn = GetPrinterDriverW(hPrinter, NULL, 5, (LPBYTE)pDriverInfo,
                                     cbNeeded, &cbNeeded);
    }

    if (bReturn) {

        hModule = RefCntLoadDriver(pDriverInfo->pConfigFile,
                                   LOAD_WITH_ALTERED_SEARCH_PATH,
                                   pDriverInfo->dwConfigVersion,
                                   TRUE);
    }

    if (bAllocBuffer) {
        LocalFree(pDriverInfo);
    }

    return hModule;
}


DWORD WINAPI
AsyncDocumentPropertiesW(
    PVOID pData
    )
{
     PumpThrdData *ThrdData = (PumpThrdData *)pData;

     RpcTryExcept
     {
         *ThrdData->Result = RPCSplWOW64DocumentProperties(ThrdData->hWnd,
                                                           ThrdData->PrinterName,
                                                           ThrdData->TouchedDevModeSize,
                                                           ThrdData->ClonedDevModeOutSize,
                                                           ThrdData->ClonedDevModeOut,
                                                           ThrdData->DevModeInSize,
                                                           ThrdData->pDevModeInput,
                                                           ThrdData->ClonedDevModeFill,
                                                           ThrdData->fMode,
                                                           ThrdData->dwRet);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}



LONG
DocumentPropertiesWNative(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput,
    DWORD       fMode
    )

/*++

Routine Description:

    DocumentProperties entry point to call DocumentPropertySheets() depends on
    the DM_PROMPT

Arguments:


Return Value:


Author:

    13-Jun-1996 Thu 15:35:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DOCUMENTPROPERTYHEADER  DPHdr;
    PDEVMODE                pDM;
    LONG                    Result = -1;
    HANDLE                  hTmpPrinter = NULL;

    //
    //  Compatibility with Win95
    //  Win95 allows for hPrinter to be NULL
    //
    if (hPrinter == NULL) {

        //
        // Open the printer for default access.
        //
        if (!OpenPrinter( pDeviceName, &hTmpPrinter, NULL )) {

            hTmpPrinter = NULL;
        }

    } else {

        hTmpPrinter = hPrinter;
    }

    //
    // Ensure the printer handle is valid
    //
    if( !eProtectHandle( hTmpPrinter, FALSE )){

        //
        // If fMode doesn't specify DM_IN_BUFFER, then zero out
        // pDevModeInput.
        //
        // Old 3.51 (version 1-0) drivers used to ignore the absence of
        // DM_IN_BUFFER and use pDevModeInput if it was not NULL.  It
        // probably did this because Printman.exe was broken.
        //
        // If the devmode is invalid, then don't pass one in.
        // This fixes MS Imager32 (which passes dmSize == 0) and
        // Milestones etc. 4.5.
        //
        // Note: this assumes that pDevModeOutput is still the
        // correct size!
        //
        if( !(fMode & DM_IN_BUFFER) || !bValidDevModeW( pDevModeInput )){

            //
            // If either are not set, make sure both are not set.
            //
            pDevModeInput = NULL;
            fMode &= ~DM_IN_BUFFER;
        }

        DPHdr.cbSize         = sizeof(DPHdr);
        DPHdr.Reserved       = 0;
        DPHdr.hPrinter       = hTmpPrinter;
        DPHdr.pszPrinterName = pDeviceName;

        if (pDevModeOutput) {

            //
            // Get the driver devmode size at here
            //

            DPHdr.pdmIn  = NULL;
            DPHdr.pdmOut = NULL;
            DPHdr.fMode  = 0;

            DPHdr.cbOut = (LONG)DocumentPropertySheets(NULL, (LPARAM)&DPHdr);

        } else {

            DPHdr.cbOut = 0;
        }

        DPHdr.pdmIn  = (PDEVMODE)pDevModeInput;
        DPHdr.pdmOut = (PDEVMODE)pDevModeOutput;
        DPHdr.fMode  = fMode;

        if (fMode & DM_PROMPT) {

            Result = CPSUI_CANCEL;

            if ((CallCommonPropertySheetUI(hWnd,
                                           (PFNPROPSHEETUI)DocumentPropertySheets,
                                           (LPARAM)&DPHdr,
                                           (LPDWORD)&Result)) < 0) {

                Result = -1;

            } else {

                Result = (Result == CPSUI_OK) ? IDOK : IDCANCEL;
            }

        } else {

            Result = (LONG)DocumentPropertySheets(NULL, (LPARAM)&DPHdr);
        }

        vUnprotectHandle( hTmpPrinter );
    }

    if (hPrinter == NULL) {

        if( hTmpPrinter ){

            ClosePrinter(hTmpPrinter);

        }
    }

    return Result;
}


LONG
DocumentPropertiesWThunk(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput,
    DWORD       fMode
    )

/*++

Routine Description:

    DocumentProperties entry point to call DocumentPropertySheets() depends on
    the DM_PROMPT

--*/

{
    DOCUMENTPROPERTYHEADER  DPHdr;
    PDEVMODE                pDM;
    LONG                    Result = -1;
    HANDLE                  hTmpPrinter = NULL;
    PSPOOL                  pSpool  = (PSPOOL)hPrinter;


    if (hPrinter == NULL)
    {
        if (!OpenPrinter( pDeviceName, &hTmpPrinter, NULL ))
        {
            hTmpPrinter = NULL;
        }
    }
    else
    {

        hTmpPrinter = hPrinter;
    }


    if( !eProtectHandle( hTmpPrinter, FALSE ))
    {
        LPWSTR PrinterName;
        MSG    msg;
        LONG   RetVal;
        DWORD  dwRet                = ERROR_SUCCESS;
        DWORD  ClonedDevModeOutSize = 0;
        DWORD  TouchedDevModeSize   = 0;
        BOOL   ClonedDevModeFill = (!!(fMode & DM_OUT_BUFFER) && pDevModeOutput);
        DWORD  DevModeInSize =  pDevModeInput ? (pDevModeInput->dmSize + pDevModeInput->dmDriverExtra) : 0;
        byte   **ClonedDevModeOut = NULL;

        if(ClonedDevModeOut = (byte **)LocalAlloc(LPTR,sizeof(byte *)))
        {
            *ClonedDevModeOut = NULL;

            if(pSpool)
            {
                PrinterName = pSpool->pszPrinter;
            }
            else
            {
                PrinterName = pDeviceName;
            }

            //
            // If fMode doesn't specify DM_IN_BUFFER, then zero out
            // pDevModeInput.
            //
            // Old 3.51 (version 1-0) drivers used to ignore the absence of
            // DM_IN_BUFFER and use pDevModeInput if it was not NULL.  It
            // probably did this because Printman.exe was broken.
            //
            // If the devmode is invalid, then don't pass one in.
            // This fixes MS Imager32 (which passes dmSize == 0) and
            // Milestones etc. 4.5.
            //
            // Note: this assumes that pDevModeOutput is still the
            // correct size!
            //
            if( !(fMode & DM_IN_BUFFER) || !bValidDevModeW( pDevModeInput ))
            {

                //
                // If either are not set, make sure both are not set.
                //
                pDevModeInput  = NULL;
                DevModeInSize  = 0;
                fMode &= ~DM_IN_BUFFER;
            }

            RpcTryExcept
            {
                if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
                   (!hWnd ||
                   ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS)))
                 {
                      HANDLE       hUIMsgThrd  = NULL;
                      DWORD        UIMsgThrdId = 0;
                      PumpThrdData ThrdData;

                      ThrdData.hWnd = (ULONG_PTR)hWnd;
                      ThrdData.PrinterName=PrinterName;
                      ThrdData.TouchedDevModeSize   = &TouchedDevModeSize;
                      ThrdData.ClonedDevModeOutSize = &ClonedDevModeOutSize;
                      ThrdData.ClonedDevModeOut = (byte**)ClonedDevModeOut;
                      ThrdData.DevModeInSize = DevModeInSize;
                      ThrdData.pDevModeInput = (byte*)pDevModeInput;
                      ThrdData.fMode = fMode;
                      ThrdData.fExclusionFlags = 0;
                      ThrdData.dwRet = &dwRet;
                      ThrdData.ClonedDevModeFill = ClonedDevModeFill;
                      ThrdData.Result = &Result;


                      //
                      // If we have a window handle , the following functions cann't
                      // proceed synchronasly. The reason for that is in order to show
                      // the UI of the driver property sheets we need to be able to dispatch
                      // incomming messages and process them.For this reason the following
                      // call would be asynchronous call and the success or failure doesn't
                      // in reality tell us anything more than than the async process started
                      // or not. We get the success of failure from the termination message.
                      // If we don't have a window handle, then the call is synchronous.
                      //
                      if(!(hUIMsgThrd = CreateThread(NULL,
                                                     INITIAL_STACK_COMMIT,
                                                     AsyncDocumentPropertiesW,
                                                     (PVOID)&ThrdData,
                                                     0,
                                                     &UIMsgThrdId)))
                      {
                           dwRet = GetLastError();
                      }
                      //
                      // The following is the required message loop for processing messages
                      // from the UI in case we have a window handle.
                      //
                      //
                       if(hUIMsgThrd && hWnd && (fMode & DM_PROMPT))
                       {
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                 //
                                 // In This message loop We should trap a User defined message
                                 // which indicates the success or the failure of the operation
                                 //
                                 if(msg.message == WM_ENDDOCUMENTPROPERTIES)
                                 {
                                      Result     = (LONG)msg.wParam;
                                      if(Result == -1)
                                           SetLastError((DWORD)msg.lParam);
                                      DelHandleFromList(hWnd);
                                      break;
                                 }
                                 else if(msg.message == WM_SURROGATEFAILURE)
                                 {
                                      //
                                      // This means that the server process died and we have
                                      // break from the message loop
                                      //
                                      Result = -1;
                                      SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                      break;
                                 }
                                 TranslateMessage(&msg);
                                 DispatchMessage(&msg);
                            }
                      }

                      if(hUIMsgThrd)
                      {
                          WaitForSingleObject(hUIMsgThrd,INFINITE);
                          CloseHandle(hUIMsgThrd);
                      }

                      if(Result!=-1 && pDevModeOutput)
                      {
                          memcpy((PVOID)pDevModeOutput,(PVOID)*ClonedDevModeOut,TouchedDevModeSize);
                      }

                      if(*ClonedDevModeOut)
                      {
                           MIDL_user_free((PVOID)*ClonedDevModeOut);
                      }

                      if(ClonedDevModeOut)
                      {
                           LocalFree((PVOID) ClonedDevModeOut);
                      }
                 }
                 else
                 {
                      SetLastError(dwRet);
                 }
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                 SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            }
            RpcEndExcept

            vUnprotectHandle( hTmpPrinter );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }

    }

    if (hPrinter == NULL)
    {
        if( hTmpPrinter )
        {
            ClosePrinter(hTmpPrinter);
        }
    }
    return(Result);
}



LONG
DocumentPropertiesW(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput,
    DWORD       fMode
    )
{
     if(RunInWOW64())
     {
          return(DocumentPropertiesWThunk(hWnd,
                                          hPrinter,
                                          pDeviceName,
                                          pDevModeOutput,
                                          pDevModeInput,
                                          fMode));
     }
     else
     {
          return(DocumentPropertiesWNative(hWnd,
                                           hPrinter,
                                           pDeviceName,
                                           pDevModeOutput,
                                           pDevModeInput,
                                           fMode));
     }

}

LONG
AdvancedDocumentPropertiesW(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPWSTR      pDeviceName,
    PDEVMODE    pDevModeOutput,
    PDEVMODE    pDevModeInput
    )

/*++

Routine Description:

    AdvanceDocumentProperties() will call DocumentProperties() with DM_ADVANCED
    flag mode set


Arguments:



Return Value:

    TRUE/FALSE


Author:

    13-Jun-1996 Thu 16:00:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    return((DocumentPropertiesW(hWnd,
                                hPrinter,
                                pDeviceName,
                                pDevModeOutput,
                                pDevModeInput,
                                DM_PROMPT           |
                                    DM_MODIFY       |
                                    DM_COPY         |
                                    DM_ADVANCED) == CPSUI_OK) ? 1 : 0);

}

LONG
AdvancedSetupDialogW(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODE   pDevModeInput,
    LPDEVMODE   pDevModeOutput
)
{
    HANDLE  hPrinter;
    LONG    ReturnValue = -1;

    if (OpenPrinterW(pDevModeInput->dmDeviceName, &hPrinter, NULL)) {
        ReturnValue = AdvancedDocumentPropertiesW(hWnd, hPrinter,
                                                  pDevModeInput->dmDeviceName,
                                                  pDevModeOutput,
                                                  pDevModeInput);
        ClosePrinter(hPrinter);
    }

    return ReturnValue;
}

int
WINAPI
DeviceCapabilitiesWNative(
    LPCWSTR   pDevice,
    LPCWSTR   pPort,
    WORD    fwCapability,
    LPWSTR   pOutput,
    CONST DEVMODEW *pDevMode
)
{
    HANDLE  hPrinter, hModule;
    int  ReturnValue=-1;
    INT_FARPROC pfn;

    if (OpenPrinter((LPWSTR)pDevice, &hPrinter, NULL)) {

        if (hModule = LoadPrinterDriver(hPrinter)) {

            if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DrvDeviceCapabilities")) {

                try {

                    ReturnValue = (*pfn)(hPrinter, pDevice, fwCapability,
                                         pOutput, pDevMode);

                } except(1) {

                    SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                    ReturnValue = -1;
                }
            }

            RefCntUnloadDriver(hModule, TRUE);
        }

        ClosePrinter(hPrinter);
    }

    return  ReturnValue;
}


int
WINAPI
DeviceCapabilitiesWThunk(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD    fwCapability,
    LPWSTR  pOutput,
    CONST DEVMODEW *pDevMode
)
{
    HANDLE      hPrinter, hModule;
    int         ReturnValue = -1;
    INT_FARPROC pfn;
    LPWSTR      DriverFileName;


    DWORD    DevModeSize;
    DWORD    ClonedOutputSize = 0;
    BOOL     ClonedOutputFill = FALSE;
    DWORD    dwRet            = ERROR_SUCCESS;
    byte     **ClonedOutput = NULL;
    DevModeSize      = pDevMode ? (pDevMode->dmSize + pDevMode->dmDriverExtra) : 0;
    ClonedOutputFill = (pOutput != NULL);

    if(ClonedOutput = (byte **)LocalAlloc(LPTR,sizeof(byte *)))
    {
        *ClonedOutput    = NULL;
        RpcTryExcept
        {
            if((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS)
            {
                 ReturnValue = RPCSplWOW64DeviceCapabilities((LPWSTR)pDevice,
                                                             (LPWSTR)pPort,
                                                             fwCapability,
                                                             DevModeSize,
                                                             (byte*)pDevMode,
                                                             ClonedOutputFill,
                                                             &ClonedOutputSize,
                                                             (byte**)ClonedOutput,
                                                             &dwRet);
                 if(ReturnValue!=-1 &&
                    pOutput         &&
                    *ClonedOutput)
                 {
                     memcpy((PVOID)pOutput,(PVOID)*ClonedOutput,ClonedOutputSize);
                 }
                 if(*ClonedOutput)
                 {
                      MIDL_user_free((PVOID)*ClonedOutput);
                 }
            }
            else
            {
                 SetLastError(dwRet);
            }
            if(ClonedOutput)
            {
                 LocalFree((PVOID) ClonedOutput);
            }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = -1;
        }
        RpcEndExcept
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
    }
    return(ReturnValue);
}


int
WINAPI
DeviceCapabilitiesW(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD    fwCapability,
    LPWSTR  pOutput,
    CONST DEVMODEW *pDevMode
)
{
     if(RunInWOW64())
     {
          return(DeviceCapabilitiesWThunk(pDevice,
                                         pPort,
                                         fwCapability,
                                         pOutput,
                                         pDevMode));
     }
     else
     {
          return(DeviceCapabilitiesWNative(pDevice,
                                           pPort,
                                           fwCapability,
                                           pOutput,
                                           pDevMode));
     }
}


BOOL
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
    )
{
    BOOL                ReturnValue;
    GENERIC_CONTAINER   FormContainer;
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    UINT                cRetry = 0;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FormContainer.Level = Level;
    FormContainer.pData = pForm;

    do {

        RpcTryExcept {

            if (ReturnValue = RpcAddForm(pSpool->hPrinter,
                                         (PFORM_CONTAINER)&FormContainer)) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (ReturnValue = RpcDeleteForm(pSpool->hPrinter, pFormName)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
GetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    FieldInfo *pFieldInfo;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;
    SIZE_T cbStruct;

    switch (Level) {

    case 1:
        pFieldInfo = FormInfo1Fields;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (pForm)
                memset(pForm, 0, cbBuf);

            if (ReturnValue = RpcGetForm(pSpool->hPrinter, pFormName, Level, pForm,
                                         cbBuf, pcbNeeded)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    ReturnValue = MarshallUpStructure(pForm, pFieldInfo, cbStruct, RPC_CALL);
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
SetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER FormContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    UINT cRetry = 0;

    switch (Level) {

    case 1:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    FormContainer.Level = Level;
    FormContainer.pData = pForm;

    do {

        RpcTryExcept {

            if (ReturnValue = RpcSetForm(pSpool->hPrinter, pFormName,
                                        (PFORM_CONTAINER)&FormContainer)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL        ReturnValue;
    DWORD       cbStruct, cbStruct32;
    FieldInfo   *pFieldInfo;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    UINT        cRetry = 0;

    switch (Level) {

    case 1:
        pFieldInfo = FormInfo1Fields;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (pForm)
                memset(pForm, 0, cbBuf);

            if (ReturnValue = RpcEnumForms(pSpool->hPrinter, Level, pForm, cbBuf,
                                           pcbNeeded, pcReturned)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    ReturnValue = MarshallUpStructuresArray(pForm, *pcReturned, pFieldInfo,
                                                            cbStruct, RPC_CALL);

                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
EnumPortsW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL        ReturnValue;
    DWORD       cbStruct;
    FieldInfo   *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = PortInfo1Fields;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pFieldInfo = PortInfo2Fields;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pPort)
            memset(pPort, 0, cbBuf);

        if (ReturnValue = RpcEnumPorts(pName, Level, pPort, cbBuf,
                                       pcbNeeded, pcReturned)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPort) {

                ReturnValue = MarshallUpStructuresArray(pPort, *pcReturned, pFieldInfo,
                                                        cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumMonitorsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitor,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    FieldInfo *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = MonitorInfo1Fields;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pFieldInfo = MonitorInfo2Fields;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pMonitor)
            memset(pMonitor, 0, cbBuf);

        if (ReturnValue = RpcEnumMonitors(pName, Level, pMonitor, cbBuf,
                                          pcbNeeded, pcReturned)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pMonitor) {

                ReturnValue = MarshallUpStructuresArray(pMonitor, *pcReturned, pFieldInfo,
                                                        cbStruct, RPC_CALL);

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

typedef struct {
    LPWSTR pName;
    HWND  hWnd;
    LPWSTR pPortName;
    HANDLE Complete;
    DWORD  ReturnValue;
    DWORD  Error;
    INT_FARPROC pfn;
} CONFIGUREPORT_PARAMETERS;

void
PortThread(
    CONFIGUREPORT_PARAMETERS *pParam
)
{
    DWORD   ReturnValue;

    /* It's no use setting errors here, because they're kept on a per-thread
     * basis.  Instead we have to pass any error code back to the calling
     * thread and let him set it.
     */

    RpcTryExcept {

        if (ReturnValue = (*pParam->pfn)(pParam->pName, pParam->hWnd,
                                           pParam->pPortName)) {
            pParam->Error = ReturnValue;
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        pParam->Error = TranslateExceptionCode(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    pParam->ReturnValue = ReturnValue;

    SetEvent(pParam->Complete);
}

BOOL
KickoffThread(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    INT_FARPROC pfn
)
{
    CONFIGUREPORT_PARAMETERS Parameters;
    HANDLE  ThreadHandle;
    MSG      msg;
    DWORD  ThreadId;

    if( hWnd ){
        EnableWindow(hWnd, FALSE);
    }

    Parameters.pName = pName;
    Parameters.hWnd = hWnd;
    Parameters.pPortName = pPortName;
    Parameters.Complete = CreateEvent(NULL, TRUE, FALSE, NULL);
    Parameters.pfn = pfn;

    ThreadHandle = CreateThread(NULL, INITIAL_STACK_COMMIT,
                                (LPTHREAD_START_ROUTINE)PortThread,
                                 &Parameters, 0, &ThreadId);

    if( ThreadHandle ){

        CloseHandle(ThreadHandle);

        while (MsgWaitForMultipleObjects(1, &Parameters.Complete, FALSE, INFINITE,
                                         QS_ALLEVENTS | QS_SENDMESSAGE) == 1) {

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(Parameters.Complete);

        if( hWnd ){
            EnableWindow(hWnd, TRUE);
            SetForegroundWindow(hWnd);

            SetFocus(hWnd);
        }

        if(!Parameters.ReturnValue)
            SetLastError(Parameters.Error);

        return Parameters.ReturnValue;
    }

    return FALSE;
}


BOOL
AddPortWNative(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    PMONITORUIDATA pMonitorUIData = NULL;

    dwRet = GetMonitorUI(pName, pMonitorName, L"XcvMonitor", &pMonitorUI, &pMonitorUIData);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS) {
            bRet = (*pMonitorUI->pfnAddPortUI)(pName, hWnd, pMonitorName, NULL);
            dwRet = GetLastError();
        } else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId) {
            bRet = FALSE;
            dwRet = ERROR_NOT_SUPPORTED;
        } else {
            bRet = KickoffThread(pName, hWnd, pMonitorName, RpcAddPort);
            dwRet = GetLastError();
        }

        SetLastError(dwRet);

    } else {

        SetLastError(dwRet);
        bRet = FALSE;
    }

    FreeMonitorUI(pMonitorUIData);

    return bRet;
}


BOOL
AddPortWThunk(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    LPWSTR      pMonitorUIDll = NULL;

    dwRet = GetMonitorUIDll(pName,pMonitorName,L"XcvMonitor",&pMonitorUIDll);

    RpcTryExcept
    {
         if (dwRet == ERROR_SUCCESS ||
             dwRet == ERROR_INVALID_PRINT_MONITOR ||
             dwRet == ERROR_INVALID_PRINTER_NAME ||
             dwRet == ERROR_NOT_SUPPORTED ||
             dwRet == ERROR_MOD_NOT_FOUND ||
             dwRet == ERROR_UNKNOWN_PORT) {

             if (dwRet == ERROR_SUCCESS)
             {
                 MSG    msg;
                 if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
                    ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                 {
                      //
                      // The following functions cann't proceed synchronasly. The reason
                      // for that is in order to show the UI of the port monitor we need
                      // to be able to dispatch incomming messages and process them.
                      // For this reason the following call is an asynchronous call and the
                      // success or failure doesn't in reality tell us anything more than
                      // than the async process started or not
                      //
                      if(bRet = RPCSplWOW64AddPort((ULONG_PTR)hWnd,
                                                   pName,
                                                   pMonitorUIDll,
                                                   pMonitorName,
                                                   &dwRet))
                      {
                           //
                           // The following is the required message loop for processing messages
                           // from the UI. The window handle has to be NULL in order to process
                           // messages from all windows in the calling Thread , otherwise we would
                           // have message dispatching problems
                           //
                           while (GetMessage(&msg, NULL, 0, 0))
                           {
                               //
                               // In This message loop We should trap a User defined message
                               // which indicates the success or the failure of the operation
                               //
                               if(msg.message == WM_ENDADDPORT)
                               {
                                   bRet      = (BOOL)msg.wParam;
                                   if(!bRet)
                                        dwRet = (DWORD)msg.lParam;
                                   else
                                        dwRet = ERROR_SUCCESS;
                                   DelHandleFromList(hWnd);
                                   break;
                               }
                               else if(msg.message == WM_SURROGATEFAILURE)
                               {
                                    //
                                    // This means that the server process died and we have
                                    // break from the message loop
                                    //
                                    bRet = FALSE;
                                    SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                    PostMessage(hWnd,WM_ACTIVATEAPP,TRUE,0);
                                    break;
                               }
                               TranslateMessage(&msg);
                               DispatchMessage(&msg);
                           }
                      }
                 }
                 else
                 {
                      bRet = FALSE;
                 }
                 SetLastError(dwRet);
             }
             else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId)
             {
                 bRet  = FALSE;
                 dwRet = ERROR_NOT_SUPPORTED;
             }
             else
             {
                 bRet = KickoffThread(pName, hWnd, pMonitorName, RpcAddPort);
                 dwRet = GetLastError();
             }

             if(pMonitorUIDll)
             {
                FreeSplMem(pMonitorUIDll);
             }
             /* FreeLibrary is busting the last error, so we need to set it here
              */
             SetLastError(dwRet);
         }
         else
         {
             SetLastError(dwRet);
             bRet = FALSE;
         }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
          bRet = FALSE;
    }
    RpcEndExcept

    return(bRet);
}


BOOL
AddPortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
    )
{
     if(RunInWOW64())
     {
          return(AddPortWThunk(pName,
                               hWnd,
                               pMonitorName));
     }
     else
     {
          return(AddPortWNative(pName,
                                hWnd,
                                pMonitorName));
     }
}


BOOL
ConfigurePortWNative(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    PMONITORUIDATA pMonitorUIData = NULL;

    dwRet = GetMonitorUI(pName, pPortName, L"XcvPort", &pMonitorUI, &pMonitorUIData);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS) {
            bRet = (*pMonitorUI->pfnConfigurePortUI)(pName, hWnd, pPortName);
        } else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId) {
            bRet = FALSE;
            SetLastError(ERROR_NOT_SUPPORTED);
        } else {
            bRet = KickoffThread(pName, hWnd, pPortName, RpcConfigurePort);
        }

    } else {

        SetLastError(dwRet);

        bRet = FALSE;
    }

    FreeMonitorUI(pMonitorUIData);

    return bRet;
}


BOOL
ConfigurePortWThunk(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName
)
{
    DWORD       dwRet;
    DWORD       dwSessionId;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    LPWSTR      pMonitorUIDll = NULL;

    dwRet = GetMonitorUIDll(pName,pPortName,L"XcvPort",&pMonitorUIDll);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME  ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS)
        {
             RpcTryExcept
             {
                  MSG    msg;
                  if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
                     ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                  {
                       //
                       // The following functions cann't proceed synchronasly. The reason
                       // for that is in order to show the UI of the port monitor we need
                       // to be able to dispatch incomming messages and process them.
                       // For this reason the following call is an asynchronous call and the
                       // success or failure doesn't in reality tell us anything more than
                       // than the async process started or not
                       //
                       if(bRet = RPCSplWOW64ConfigurePort((ULONG_PTR)hWnd,
                                                          pName,
                                                          pMonitorUIDll,
                                                          pPortName,
                                                          &dwRet))
                       {
                            //
                            // The following is the required message loop for processing messages
                            // from the UI. The window handle has to be NULL in order to process
                            // messages from all windows in the calling Thread , otherwise we would
                            // have message dispatching problems
                            //
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                //
                                // In This message loop We should trap a User defined message
                                // which indicates the success or the failure of the operation
                                //
                                if(msg.message == WM_ENDCFGPORT)
                                {
                                    bRet      = (BOOL)msg.wParam;
                                    if(!bRet)
                                         dwRet = (DWORD)msg.lParam;
                                    else
                                         dwRet = ERROR_SUCCESS;
                                    DelHandleFromList(hWnd);
                                    break;
                                }
                                else if(msg.message == WM_SURROGATEFAILURE)
                                {
                                     //
                                     // This means that the server process died and we have
                                     // break from the message loop
                                     //
                                     bRet = FALSE;
                                     SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                     break;
                                }
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                       }
                  }
                  else
                  {
                       bRet = FALSE;
                  }

                  SetLastError(dwRet);
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                  bRet = FALSE;
             }
             RpcEndExcept
        }
        else if ((bRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId)) && dwSessionId) {
            bRet = FALSE;
            SetLastError(ERROR_NOT_SUPPORTED);
        } else {
            bRet = KickoffThread(pName, hWnd, pPortName, RpcConfigurePort);
        }

        if(pMonitorUIDll)
        {
           FreeSplMem(pMonitorUIDll);
        }

    }
    else
    {
        SetLastError(dwRet);
        bRet = FALSE;
    }
    return(bRet);
}


BOOL
ConfigurePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
     if(RunInWOW64())
     {
          return(ConfigurePortWThunk(pName,
                                     hWnd,
                                     pPortName));
     }
     else
     {
          return(ConfigurePortWNative(pName,
                                      hWnd,
                                      pPortName));
     }
}


BOOL
DeletePortWNative(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    DWORD       dwRet;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    PMONITORUIDATA pMonitorUIData = NULL;

    dwRet = GetMonitorUI(pName, pPortName, L"XcvPort", &pMonitorUI, &pMonitorUIData);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS)
            bRet = (*pMonitorUI->pfnDeletePortUI)(pName, hWnd, pPortName);
        else
            bRet = KickoffThread(pName, hWnd, pPortName, RpcDeletePort);

    } else {

        SetLastError(dwRet);
        bRet = FALSE;
    }

    FreeMonitorUI(pMonitorUIData);

    return bRet;
}


BOOL
DeletePortWThunk(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    DWORD       dwRet;
    BOOL        bRet;
    PMONITORUI  pMonitorUI;
    LPWSTR      pMonitorUIDll = NULL;

    dwRet = GetMonitorUIDll(pName,pPortName,L"XcvPort",&pMonitorUIDll);

    if (dwRet == ERROR_SUCCESS ||
        dwRet == ERROR_INVALID_PRINT_MONITOR ||
        dwRet == ERROR_INVALID_PRINTER_NAME ||
        dwRet == ERROR_NOT_SUPPORTED ||
        dwRet == ERROR_MOD_NOT_FOUND ||
        dwRet == ERROR_UNKNOWN_PORT) {

        if (dwRet == ERROR_SUCCESS)
        {
             RpcTryExcept
             {
                  MSG    msg;
                  if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
                     ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
                  {
                       //
                       // The following functions cann't proceed synchronasly. The reason
                       // for that is in order to show the UI of the port monitor we need
                       // to be able to dispatch incomming messages and process them.
                       // For this reason the following call is an asynchronous call and the
                       // success or failure doesn't in reality tell us anything more than
                       // than the async process started or not
                       //
                       if(bRet = RPCSplWOW64DeletePort((ULONG_PTR)hWnd,
                                                       pName,
                                                       pMonitorUIDll,
                                                       pPortName,
                                                       &dwRet))
                       {
                            //
                            // The following is the required message loop for processing messages
                            // from the UI. The window handle has to be NULL in order to process
                            // messages from all windows in the calling Thread , otherwise we would
                            // have message dispatching problems
                            //
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                //
                                // In This message loop We should trap a User defined message
                                // which indicates the success or the failure of the operation
                                //
                                if(msg.message == WM_ENDDELPORT)
                                {
                                    bRet      = (BOOL)msg.wParam;
                                    if(!bRet)
                                         dwRet = (DWORD)msg.lParam;
                                    else
                                         dwRet = ERROR_SUCCESS;
                                    DelHandleFromList(hWnd);
                                    break;
                                }
                                else if(msg.message == WM_SURROGATEFAILURE)
                                {
                                     //
                                     // This means that the server process died and we have
                                     // break from the message loop
                                     //
                                     bRet = FALSE;
                                     SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                     break;
                                }
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                       }
                  }
                  else
                  {
                       bRet = FALSE;
                  }
                  SetLastError(dwRet);
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                  bRet = FALSE;
             }
             RpcEndExcept
        }
        else
            bRet = KickoffThread(pName, hWnd, pPortName, RpcDeletePort);

        if(pMonitorUIDll)
        {
           FreeSplMem(pMonitorUIDll);
        }

    }
    else
    {
        SetLastError(dwRet);
        bRet = FALSE;
    }
    return(bRet);
}


BOOL
DeletePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
     if(RunInWOW64())
     {
          return(DeletePortWThunk(pName,
                                  hWnd,
                                  pPortName));
     }
     else
     {
          return(DeletePortWNative(pName,
                                   hWnd,
                                   pPortName));
     }
}

DWORD
GetMonitorUI(
    IN PCWSTR           pszMachineName,
    IN PCWSTR           pszObjectName,
    IN PCWSTR           pszObjectType,
    OUT PMONITORUI      *ppMonitorUI,
    OUT PMONITORUIDATA  *ppMonitorUIData
    )
{
    DWORD   ReturnValue;
    DWORD   dwDummy;        // RPC needs an address for 'out' parameters
    HANDLE  hXcv = NULL;
    PBYTE   pOutputData = NULL;
    DWORD   cbOutput;
    PWSTR   pszServerName = NULL;
    PRINTER_DEFAULTS Default;
    PMONITORUI  (*pfnInitializePrintMonitorUI)(VOID) = NULL;
    DWORD   dwStatus;
    BOOL    bAllocBuffer = FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];
    PMONITORUIDATA pMonitorUIData = NULL;
    HRESULT hRetval;

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    *ppMonitorUI        = NULL;
    *ppMonitorUIData    = NULL;

    if (!(pszServerName = ConstructXcvName(pszMachineName, pszObjectName, pszObjectType))) {
        ReturnValue = GetLastError();
        goto Done;
    }

    RpcTryExcept {

        ReturnValue = OpenPrinter(  pszServerName,
                                    &hXcv,
                                    &Default);

        if (!ReturnValue) {
            ReturnValue = GetLastError();
            goto Done;
        }

        pOutputData = (PBYTE) btBuffer;
        ZeroMemory(pOutputData, MAX_STATIC_ALLOC);

        ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                    L"MonitorUI",
                                    (PBYTE) &dwDummy,
                                    0,
                                    pOutputData,
                                    MAX_STATIC_ALLOC,
                                    &cbOutput,
                                    &dwStatus);

        if (ReturnValue != ERROR_SUCCESS)
             goto Done;

        if (dwStatus != ERROR_SUCCESS) {

            if (dwStatus != ERROR_INSUFFICIENT_BUFFER) {
                ReturnValue = dwStatus;
                goto Done;
            }
            if (!(pOutputData = AllocSplMem(cbOutput))) {
                ReturnValue = GetLastError();
                goto Done;
            }

            bAllocBuffer = TRUE;
            ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                        L"MonitorUI",
                                        (PBYTE) &dwDummy,
                                        0,
                                        pOutputData,
                                        cbOutput,
                                        &cbOutput,
                                        &dwStatus);
        }

        if (ReturnValue != ERROR_SUCCESS)
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            ReturnValue = dwStatus;
            goto Done;
        }

        //
        // Create and initialize the monitor UI data.
        //
        hRetval = CreateMonitorUIData(&pMonitorUIData);

        if (FAILED(hRetval)) {
            ReturnValue = HRESULT_CODE(hRetval);
            goto Done;
        }

        //
        // Get and activate the monitor UI context.
        //
        hRetval = GetMonitorUIActivationContext((PCWSTR)pOutputData, pMonitorUIData);

        if (FAILED(hRetval)) {
            ReturnValue = HRESULT_CODE(hRetval);
            goto Done;
        }

        if (!(pMonitorUIData->hLibrary = LoadLibrary(pMonitorUIData->pszMonitorName))) {
            ReturnValue = GetLastError();
            goto Done;
        }

        pfnInitializePrintMonitorUI = (PMONITORUI (*)(VOID))
                                       GetProcAddress(pMonitorUIData->hLibrary, "InitializePrintMonitorUI");

        if (!pfnInitializePrintMonitorUI) {
            ReturnValue = GetLastError();
            goto Done;
        }

        *ppMonitorUI     = (*pfnInitializePrintMonitorUI)();
        *ppMonitorUIData = pMonitorUIData;
        pMonitorUIData   = NULL;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(ReturnValue = TranslateExceptionCode(RpcExceptionCode()));

    } RpcEndExcept


Done:

    if (bAllocBuffer) {
        FreeSplMem(pOutputData);
    }

    if (hXcv) {
        ClosePrinter(hXcv);
    }

    FreeSplMem(pszServerName);
    FreeMonitorUI(pMonitorUIData);

    return ReturnValue;
}

/*++

Routine Name:

    CreateMonitorUIData

Routine Description:

    This function creates and initialize the monitor UI data.

Arguments:

    ppMonitorUIData - pointer where to return the monitor UI data

Returns:

    An HRESULT

--*/
HRESULT
CreateMonitorUIData(
    OUT MONITORUIDATA **ppMonitorUIData
    )
{
    HRESULT         hRetval         = E_FAIL;
    MONITORUIDATA   *pMonitorUIData = NULL;

    hRetval = ppMonitorUIData ? S_OK : E_POINTER;

    if (SUCCEEDED(hRetval))
    {
        *ppMonitorUIData = NULL;
    }

    if (SUCCEEDED(hRetval))
    {
        pMonitorUIData = AllocSplMem(sizeof(MONITORUIDATA));

        hRetval = pMonitorUIData ? S_OK : E_OUTOFMEMORY;
    }

    //
    // Initialize the monitor UI data.
    //
    if (SUCCEEDED(hRetval))
    {
        ZeroMemory(pMonitorUIData, sizeof(MONITORUIDATA));
        pMonitorUIData->hActCtx = INVALID_HANDLE_VALUE;
    }

    //
    // Everything succeeded, copy back the pointer.
    //
    if (SUCCEEDED(hRetval))
    {
        *ppMonitorUIData = pMonitorUIData;
    }

    return hRetval;
}

/*++

Routine Name:

    FreeMonitorUI

Routine Description:

    This function releases the monitor UI data.  It is responsible
    for releasing the monitor library as well the monitor fusion
    activation context.  Note this function is called in error cases
    when GetMonitorUI fails so all the parameters must be checked
    for validity before use.

Arguments:

    pMonitorUIData - pointer to the monitor UI data created in GetMonitorUI

Returns:

    Nothing.

--*/
VOID
FreeMonitorUI(
    IN PMONITORUIDATA pMonitorUIData
    )
{
    //
    // Preserve the last error.
    //
    DWORD dwLastError = GetLastError();

    if (pMonitorUIData)
    {
        //
        // Release the monitor library.
        //
        if (pMonitorUIData->hLibrary)
        {
            FreeLibrary(pMonitorUIData->hLibrary);
        }

        //
        // If we have an activation cookie then deactivate this context
        //
        if (pMonitorUIData->bDidActivate)
        {
            DeactivateActCtx(0, pMonitorUIData->lActCtx);
        }

        //
        // If we have created an activation context then release it.
        //
        if (pMonitorUIData->hActCtx != INVALID_HANDLE_VALUE && pMonitorUIData->hActCtx != ACTCTX_EMPTY)
        {
            ReleaseActCtx(pMonitorUIData->hActCtx);
        }

        //
        // Release the monitor name
        //
        if (pMonitorUIData->pszMonitorName)
        {
            FreeSplMem(pMonitorUIData->pszMonitorName);
        }

        //
        // Release the monitor UI data back to the heap.
        //
        FreeSplMem(pMonitorUIData);
    }

    SetLastError(dwLastError);
}

/*++

Routine Name:

    GetMonitorUIActivationContext

Routine Description:

    This routine gets the monitor UI activation context and then
    activates the context.  If the monitor does not have an activation
    context in it's resource file it will activate the empty context
    for compatiblity with previous version of common control.

Arguments:

    pszMonitorName  - pointer to the monitor name.
    pMonitorUIData  - pointer to the monitor UI data created in GetMonitorUI

Returns:

    An HRESULT

--*/
HRESULT
GetMonitorUIActivationContext(
    IN PCWSTR           pszMonitorName,
    IN MONITORUIDATA    *pMonitorUIData
    )
{
    HRESULT hRetval     = E_FAIL;

    hRetval = pszMonitorName && pMonitorUIData ? S_OK : E_INVALIDARG;

    //
    // Get the monitor full name.
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetMonitorUIFullName(pszMonitorName, &pMonitorUIData->pszMonitorName);
    }

    //
    // See if there is an activation context in the resouce of this
    // monitor UI binary.  If there is we will create this context
    // else we will create the empty context for backward compatibility.
    //
    if (SUCCEEDED(hRetval))
    {
        ACTCTX  act;

        ZeroMemory(&act, sizeof(act));

        act.cbSize          = sizeof(act);
        act.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpSource        = pMonitorUIData->pszMonitorName;
        act.lpResourceName  = MAKEINTRESOURCE(ACTIVATION_CONTEXT_RESOURCE_ID);

        pMonitorUIData->hActCtx = CreateActCtx(&act);

        if (pMonitorUIData->hActCtx == INVALID_HANDLE_VALUE)
        {
            pMonitorUIData->hActCtx = ACTCTX_EMPTY;
        }

        hRetval = pMonitorUIData->hActCtx ? S_OK : E_FAIL;
    }

    //
    // Activate this context.
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = ActivateActCtx(pMonitorUIData->hActCtx,
                                 &pMonitorUIData->lActCtx) ? S_OK : GetLastErrorAsHResult();

        pMonitorUIData->bDidActivate = SUCCEEDED(hRetval);
    }

    return hRetval;
}

/*++

Routine Name:

    GetMonitorUIFullName

Routine Description:

    Get's the full monitor name.  XCV is currently returning just the file name
    not fully qualified.  However the ddk does not indicate whether a monitor
    should or should not return the monitor name fully qualified or not.  Hence
    this routine was written.  It first builds a full name then it checkes if the
    name is valid and if it is not then the orginal name is assumed fully
    qualified and returned to the caller.

Arguments:

    pszMonitorName  - pointer to the monitor name.
    ppszMonitorName - pointer where to return a monitor name pointer

Returns:

    An HRESULT

--*/
HRESULT
GetMonitorUIFullName(
    IN PCWSTR   pszMonitorName,
    IN PWSTR    *ppszMonitorName
    )
{
    HRESULT hRetval             = E_FAIL;
    PWSTR   pszTempMonitorName  = NULL;
    PWSTR   pszBuff             = NULL;
    DWORD   dwRetval            = ERROR_SUCCESS;

    hRetval = pszMonitorName && ppszMonitorName ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *ppszMonitorName = NULL;
    }

    //
    // Allocate a temp buffer, use the heap.  Too much stack usage
    // will cause stress failures.
    //
    if (SUCCEEDED(hRetval))
    {
        pszBuff = (PWSTR)AllocSplMem(MAX_PATH * sizeof(WCHAR));

        hRetval = pszBuff ? S_OK : E_OUTOFMEMORY;
    }

    //
    // We need a full path to create an activation context.  Xcv
    // is only returning the monitor name not the full path.
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetSystemDirectory(pszBuff, MAX_PATH) ? S_OK : GetLastErrorAsHResult();
    }

    //
    // Append the monitor name to the system directory.
    //
    if (SUCCEEDED(hRetval))
    {
        dwRetval = StrCatAlloc(&pszTempMonitorName,
                               pszBuff,
                               szSlash,
                               pszMonitorName,
                               NULL);

        hRetval = HRESULT_FROM_WIN32(dwRetval);
    }

    //
    // Check to see if this is a valid name.
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileAttributes(pszTempMonitorName) != -1 ? S_OK : GetLastErrorAsHResult();

        //
        // Name is not valid, release the current name and
        // make a copy of the name passed to us and return this
        // and the full monitor name.
        //
        if (FAILED(hRetval))
        {
            FreeSplMem(pszTempMonitorName);

            dwRetval = StrCatAlloc(&pszTempMonitorName,
                                   pszMonitorName,
                                   NULL);

            hRetval = HRESULT_FROM_WIN32(dwRetval);
        }
    }

    //
    // We have a valid name return it to the caller.
    //
    if (SUCCEEDED(hRetval))
    {
        *ppszMonitorName    = pszTempMonitorName;
        pszTempMonitorName  = NULL;
    }

    FreeSplMem(pszBuff);
    FreeSplMem(pszTempMonitorName);

    return hRetval;
}

DWORD
GetMonitorUIDll(
    PCWSTR      pszMachineName,
    PCWSTR      pszObjectName,
    PCWSTR      pszObjectType,
    PWSTR       *pMonitorUIDll
)
{
    DWORD   ReturnValue;
    DWORD   dwDummy;        // RPC needs an address for 'out' parameters
    HANDLE  hXcv = NULL;
    PBYTE   pOutputData = NULL;
    DWORD   cbOutput;
    PWSTR   pszServerName = NULL;
    PRINTER_DEFAULTS Default;
    PMONITORUI  (*pfnInitializePrintMonitorUI)(VOID) = NULL;
    DWORD   dwStatus;
    BOOL    bAllocBuffer = FALSE;
    BYTE    btBuffer[MAX_STATIC_ALLOC];

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    *pMonitorUIDll = NULL;

    if (!(pszServerName = ConstructXcvName(pszMachineName, pszObjectName, pszObjectType))) {
        ReturnValue = GetLastError();
        goto Done;
    }

    RpcTryExcept {

        ReturnValue = OpenPrinter(  pszServerName,
                                    &hXcv,
                                    &Default);

        if (!ReturnValue) {
            ReturnValue = GetLastError();
            goto Done;
        }

        pOutputData = (PBYTE) btBuffer;
        ZeroMemory(pOutputData, MAX_STATIC_ALLOC);

        ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                    L"MonitorUI",
                                    (PBYTE) &dwDummy,
                                    0,
                                    pOutputData,
                                    MAX_STATIC_ALLOC,
                                    &cbOutput,
                                    &dwStatus);

        if (ReturnValue != ERROR_SUCCESS)
             goto Done;

        if (dwStatus != ERROR_SUCCESS) {

            if (dwStatus != ERROR_INSUFFICIENT_BUFFER) {
                ReturnValue = dwStatus;
                goto Done;
            }
            if (!(pOutputData = AllocSplMem(cbOutput))) {
                ReturnValue = GetLastError();
                goto Done;
            }

            bAllocBuffer = TRUE;
            ReturnValue = RpcXcvData(   ((PSPOOL)hXcv)->hPrinter,
                                        L"MonitorUI",
                                        (PBYTE) &dwDummy,
                                        0,
                                        pOutputData,
                                        cbOutput,
                                        &cbOutput,
                                        &dwStatus);
        }
        else
        {
            cbOutput = MAX_STATIC_ALLOC;
        }

        if (ReturnValue != ERROR_SUCCESS)
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            ReturnValue = dwStatus;
            goto Done;
        }

        if (!(*pMonitorUIDll = AllocSplMem(cbOutput))) {
                ReturnValue = GetLastError();
                goto Done;
        }

        wcscpy(*pMonitorUIDll,(LPWSTR)pOutputData);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(ReturnValue = TranslateExceptionCode(RpcExceptionCode()));

    } RpcEndExcept


Done:

    if (bAllocBuffer) {
        FreeSplMem(pOutputData);
    }

    FreeSplMem(pszServerName);

    if (hXcv) {
        ClosePrinter(hXcv);
    }
    return ReturnValue;
}

HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW   pDevMode
)
{
    HANDLE  ReturnValue;
    DWORD   Error;
    DEVMODE_CONTAINER DevModeContainer;
    HANDLE  hGdi;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    if( bValidDevModeW( pDevMode )){

        DevModeContainer.cbBuf = pDevMode->dmSize + pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pDevMode;

    } else {

        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = (LPBYTE)pDevMode;
    }

    do {

        RpcTryExcept {

            if (Error = RpcCreatePrinterIC( pSpool->hPrinter,
                                            &hGdi,
                                            &DevModeContainer )){

                SetLastError(Error);
                ReturnValue = FALSE;

            } else {

                ReturnValue = hGdi;
                InterlockedIncrement( &gcClientICHandle );
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    BOOL ReturnValue;

    RpcTryExcept {

        if (ReturnValue = RpcPlayGdiScriptOnPrinterIC(hPrinterIC, pIn, cIn,
                                                      pOut, cOut, ul)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
)
{
    BOOL    ReturnValue;

    RpcTryExcept {

        if (ReturnValue = RpcDeletePrinterIC(&hPrinterIC)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
            InterlockedDecrement( &gcClientICHandle );
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


/****************************************************************************
*  INT QueryRemoteFonts( HANDLE, PUNIVERSAL_FONT_ID, ULONG )
*
* This is a hacky version of QueryRemoteFonts that doesn't do any
* caching based on the time stamp returned by QueryFonts.  Additionally,
* it uses the CreatePrinterIC/PlayGdiScriptOnDC mechanism since it was
* already in place.  It may be better to eliminate CreatePrinterIC and use
* an HPRINTER instead.
*
* Note that if the user doesn't pass in a buffer large enough to hold all
* the fonts we truncate the list and copy only enough fonts for which there
* is room but will still return success.  This is okay because the worst
* that can happen in this case is that we may download unecessary fonts in
* the spool stream.
*
*
*  History:
*   5/25/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/


INT QueryRemoteFonts(
    HANDLE hPrinter,
    PUNIVERSAL_FONT_ID pufi,
    ULONG nBufferSize
)
{
    HANDLE hPrinterIC;
    PBYTE pBuf;
    DWORD dwDummy,cOut;
    INT  iRet = -1;

    hPrinterIC = CreatePrinterIC( hPrinter, NULL );

    if( hPrinterIC )
    {
        cOut = (nBufferSize * sizeof(UNIVERSAL_FONT_ID)) + sizeof(INT);

        pBuf = LocalAlloc( LMEM_FIXED, cOut );

        if( pBuf )
        {
            // Just call PlayGdiScriptOnPrinterIC for now since the piping is in place.
            // For some reason the RPC stuff doesn't like NULL pointers for pIn so we
            // use &dwDummy instead;


            if(PlayGdiScriptOnPrinterIC(hPrinterIC,(PBYTE) &dwDummy,
                                        sizeof(dwDummy),pBuf,cOut, 0))
            {
                DWORD dwSize = *((DWORD*) pBuf );

                iRet = (INT) dwSize;
                SPLASSERT( iRet >= 0 );

                //
                // If the supplied buffer is not large enough, we truncate the data
                // The caller needs to check if he needs to call again this function
                // with a larger buffer
                //
                if( dwSize > nBufferSize )
                {
                    dwSize = nBufferSize;
                }
                memcpy(pufi,pBuf+sizeof(DWORD),dwSize * sizeof(UNIVERSAL_FONT_ID));
            }

            LocalFree( pBuf );
        }

        DeletePrinterIC( hPrinterIC );
    }

    return(iRet);
}



DWORD
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    return ERROR_NOT_SUPPORTED;
}

BOOL
AddMonitorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    BOOL  ReturnValue;
    MONITOR_CONTAINER   MonitorContainer;
    MONITOR_INFO_2  MonitorInfo2;

    switch (Level) {

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (pMonitorInfo)
        MonitorInfo2 = *(PMONITOR_INFO_2)pMonitorInfo;
    else
        memset(&MonitorInfo2, 0, sizeof(MonitorInfo2));

    if (!MonitorInfo2.pEnvironment || !*MonitorInfo2.pEnvironment) {
        if(RunInWOW64()) {
            MonitorInfo2.pEnvironment = szIA64Environment;
        }
        else {
            MonitorInfo2.pEnvironment = szEnvironment;
        }
    }

    MonitorContainer.Level = Level;
    MonitorContainer.MonitorInfo.pMonitorInfo2 = (MONITOR_INFO_2 *)&MonitorInfo2;

    RpcTryExcept {

        if (ReturnValue = RpcAddMonitor(pName, &MonitorContainer)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeleteMonitorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
)
{
    BOOL  ReturnValue;

    if (!pMonitorName || !*pMonitorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeleteMonitor(pName,
                                           pEnvironment,
                                           pMonitorName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    BOOL  ReturnValue;

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrintProcessor(pName,
                                                  pEnvironment,
                                                  pPrintProcessorName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
AddPrintProvidorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pProvidorInfo
)
{
    BOOL    ReturnValue;
    LPWSTR  pStr;

    PROVIDOR_CONTAINER   ProvidorContainer;
    RPC_PROVIDOR_INFO_2W RpcProvidorInfo;

    ProvidorContainer.Level = Level;

    switch (Level) {

    case 1:
        ProvidorContainer.ProvidorInfo.pProvidorInfo1 = (PROVIDOR_INFO_1 *)pProvidorInfo;
        break;

    case 2:
        RpcProvidorInfo.pOrder = ((PROVIDOR_INFO_2 *) pProvidorInfo)->pOrder;

        for (pStr = RpcProvidorInfo.pOrder;
             pStr && *pStr;
             pStr += (wcslen(pStr) + 1)) ;

        // Set the character count for the multisz string
        RpcProvidorInfo.cchOrder = (DWORD) ((ULONG_PTR) (pStr - RpcProvidorInfo.pOrder + 1));

        ProvidorContainer.ProvidorInfo.pRpcProvidorInfo2 = &RpcProvidorInfo;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (ReturnValue = RpcAddPrintProvidor(pName, &ProvidorContainer)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrintProvidorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProvidorName
)
{
    BOOL  ReturnValue;

    RpcTryExcept {

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = RpcDeletePrintProvidor(pName,
                                                 pEnvironment,
                                                 pPrintProvidorName)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

LPWSTR
IsaFileName(
    LPWSTR pOutputFile,
    LPWSTR FullPathName,
    DWORD  cchFullPathName
    )
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LPWSTR  pFileName=NULL;
    LPWSTR  pFullPathName=NULL;

    //
    // Hack for Word20c.Win
    //

    if (!_wcsicmp(pOutputFile, L"FILE")) {
        return NULL;
    }

    //
    // cchFullPathName needs to be at least MAX_PATH
    //
    if (GetFullPathName(pOutputFile, cchFullPathName, FullPathName, &pFileName)) {

        DBGMSG(DBG_TRACE, ("Fully qualified filename is %ws\n", FullPathName));

        //
        // Filenames containing ":" create a stream and a file on NTFS.  When the file is closed,
        // the stream is deleted (if DELETE_ON_CLOSE is specified) but the file remains.  Not only
        // that, but GetFileType will return FILE_TYPE_DISK.  You can see this by printing from IE
        // to a network printer.  The incoming name will be something like "157.55.3.5:PASSTHRU".
        // Therefore, we need to catch this case here.
        //
        if (pFileName && wcschr(pFileName, L':')) {
            return NULL;
        }

        hFile = CreateFile(pOutputFile,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE) {

            hFile = CreateFile(pOutputFile,
                               GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                               NULL);
        }

        if (hFile != INVALID_HANDLE_VALUE) {
            if (GetFileType(hFile) == FILE_TYPE_DISK) {
                pFullPathName = FullPathName;
            }
            CloseHandle(hFile);
        }
    }

    return pFullPathName;
}

BOOL IsaPortName(
        PKEYDATA pKeyData,
        LPWSTR pOutputFile
        )
{
    DWORD i = 0;
    UINT uStrLen;

    if (!pKeyData) {
        return(FALSE);
    }
    for (i=0; i < pKeyData->cTokens; i++) {

        //
        // If FILE: is one of the ports, and the app got the port
        // name from win.in (e.g., Nexx:), then we will put up the
        // print to file dialog, so we're not really printing to a port.
        //
        if (!lstrcmpi(pKeyData->pTokens[i], szFilePort)) {
            if ((!wcsncmp(pOutputFile, L"Ne", 2)) &&
                (*(pOutputFile + 4) == L':')) {
                return(FALSE);
            } else {
                continue;
            }
        }

        if (!lstrcmpi(pKeyData->pTokens[i], pOutputFile)) {
            return(TRUE);
        }
    }

    //
    // Hack for NeXY: ports
    //

    if (!_wcsnicmp(pOutputFile, L"Ne", 2)) {

        uStrLen = wcslen( pOutputFile );

        //
        // Ne00: or Ne00 if app truncates it
        //
        if (( uStrLen == 5 ) || ( uStrLen == 4 ) )  {

            // Check for two Digits

            if (( pOutputFile[2] >= L'0' ) && ( pOutputFile[2] <= L'9' ) &&
                ( pOutputFile[3] >= L'0' ) && ( pOutputFile[3] <= L'9' )) {

                //
                // Check for the final : as in Ne01:,
                // note some apps will truncate it.
                //
                if (( uStrLen == 5 ) && (pOutputFile[4] != L':')) {
                    return FALSE;
                }
                return TRUE;
            }
        }
    }
    return(FALSE);
}

BOOL HasAFilePort(PKEYDATA pKeyData)
{
    DWORD i = 0;

    if (!pKeyData) {
        return(FALSE);
    }
    for (i=0; i < pKeyData->cTokens; i++) {
        if (!lstrcmpi(pKeyData->pTokens[i], szFilePort)) {
            return(TRUE);
        }
    }
    return(FALSE);
}

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT
GetCurrentThreadLastPopup(
        OUT HWND    *phwnd
    )
{
    HWND hwndOwner, hwndParent;
    HRESULT hr = E_INVALIDARG;
    GUITHREADINFO ti = {0};

    if( phwnd )
    {
        hr = E_FAIL;
        *phwnd = NULL;

        ti.cbSize = sizeof(ti);
        if( GetGUIThreadInfo(0, &ti) && ti.hwndActive )
        {
            *phwnd = ti.hwndActive;
            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner window
            *phwnd = GetLastActivePopup(*phwnd);
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}

LPWSTR
StartDocDlgW(
        HANDLE hPrinter,
        DOCINFO *pDocInfo
        )
 {
     DWORD       dwError = 0;
     DWORD       dwStatus = FALSE;
     LPWSTR      lpFileName = NULL;
     DWORD       rc = 0;
     PKEYDATA    pKeyData = NULL;
     LPWSTR      pPortNames = NULL;
     WCHAR      FullPathName[MAX_PATH];
     WCHAR      CurrentDirectory[MAX_PATH];
     PKEYDATA   pOutputList = NULL;
     WCHAR      PortNames[MAX_PATH];
     DWORD      i = 0;
     HWND       hwndParent = NULL;

#if DBG


     GetCurrentDirectory(MAX_PATH, CurrentDirectory);
     DBGMSG(DBG_TRACE, ("The Current Directory is %ws\n", CurrentDirectory));
#endif

     if (pDocInfo) {
         DBGMSG(DBG_TRACE, ("lpOutputFile is %ws\n", pDocInfo->lpszOutput ? pDocInfo->lpszOutput: L""));
     }
     memset(FullPathName, 0, sizeof(WCHAR)*MAX_PATH);

     pPortNames = GetPrinterPortList(hPrinter);
     pKeyData = CreateTokenList(pPortNames);

     //
     //  Check for the presence of multiple ports in the lpszOutput field
     //  the assumed delimiter is the comma. Thus there can be  no files with commas
     //

     if (pDocInfo && pDocInfo->lpszOutput && pDocInfo->lpszOutput[0]) {

         //
         // Make a copy of the pDocInfo->lpszOutput because CreateTokenList is destructive
         //

         wcsncpy(PortNames, pDocInfo->lpszOutput, COUNTOF(PortNames)-1);
         PortNames[COUNTOF(PortNames)-1] = 0;

         pOutputList = CreateTokenList(PortNames);
         if (pOutputList && (pOutputList->cTokens > 1) &&
             !lstrcmpi(pPortNames, pDocInfo->lpszOutput))
         {
             for (i= 0; i < pOutputList->cTokens; i++) {
                 if (!lstrcmpi(pOutputList->pTokens[i], szFilePort)) {

                     wcscpy((LPWSTR)pDocInfo->lpszOutput, szFilePort);
                     break;
                 }
            }
            if (i == pOutputList->cTokens) {
                wcscpy((LPWSTR)pDocInfo->lpszOutput, pOutputList->pTokens[0]);
            }
         }

         FreeSplMem(pOutputList);
     }


     if (pDocInfo && pDocInfo->lpszOutput && pDocInfo->lpszOutput[0]) {

         if (IsaPortName(pKeyData, (LPWSTR)pDocInfo->lpszOutput)) {
             lpFileName = NULL;
             goto StartDocDlgWReturn;
         }

         if (IsaFileName((LPWSTR)pDocInfo->lpszOutput, FullPathName, COUNTOF(FullPathName))) {

             //
             // Fully Qualify the pathname for Apps like PageMaker and QuatroPro
             //
             if (lpFileName = LocalAlloc(LPTR, (wcslen(FullPathName)+1)*sizeof(WCHAR))) {
                 wcscpy(lpFileName, FullPathName);
             }
             goto StartDocDlgWReturn;
         }

     }

     if ((HasAFilePort(pKeyData)) ||
                 (pDocInfo && pDocInfo->lpszOutput
                    && (!_wcsicmp(pDocInfo->lpszOutput, L"FILE:") ||
                        !_wcsicmp(pDocInfo->lpszOutput, L"FILE"))))
     {
        //
        // since we have no idea who is calling us and we want to show
        // modal against the last active popup, we need to figure out
        // who is the last active popup of the calling app and then specify
        // as parent - GetCurrentThreadLastPopup does a little magic to
        // find the appropriate window.
        //
        DBGMSG(DBG_TRACE, ("We returned True from has file\n"));
        rc = (DWORD)DialogBoxParam( hInst,
                            MAKEINTRESOURCE( DLG_PRINTTOFILE ),
                            SUCCEEDED(GetCurrentThreadLastPopup(&hwndParent)) ? hwndParent : NULL, (DLGPROC)PrintToFileDlg,
                            (LPARAM)&lpFileName );
        if (rc == -1) {
           DBGMSG(DBG_TRACE, ("Error from DialogBoxParam- %d\n", GetLastError()));
           lpFileName = (LPWSTR)-1;
           goto StartDocDlgWReturn;

        } else if (rc == 0) {
           DBGMSG(DBG_TRACE, ("User cancelled the dialog\n"));
           lpFileName = (LPWSTR)-2;
           SetLastError( ERROR_CANCELLED );
           goto StartDocDlgWReturn;
        } else {
           DBGMSG(DBG_TRACE, ("The string was successfully returned\n"));
           DBGMSG(DBG_TRACE, ("The string is %ws\n", lpFileName? lpFileName: L"NULL"));
           goto StartDocDlgWReturn;
         }
     } else {
         lpFileName = (LPWSTR)NULL;
    }

StartDocDlgWReturn:

    FreeSplMem(pKeyData);
    FreeSplStr(pPortNames);

    return(lpFileName);
  }

BOOL
AddPortExW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
)
{
    DWORD   ReturnValue;
    PORT_CONTAINER PortContainer;
    PORT_VAR_CONTAINER PortVarContainer;
    PPORT_INFO_FF pPortInfoFF;
    PPORT_INFO_1 pPortInfo1;


    if (!lpBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (Level) {
    case (DWORD)-1:
        pPortInfoFF = (PPORT_INFO_FF)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfoFF = (PPORT_INFO_FF)pPortInfoFF;
        PortVarContainer.cbMonitorData = pPortInfoFF->cbMonitorData;
        PortVarContainer.pMonitorData = pPortInfoFF->pMonitorData;
        break;

    case 1:
        pPortInfo1 = (PPORT_INFO_1)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfo1 = (PPORT_INFO_1)pPortInfo1;
        PortVarContainer.cbMonitorData = 0;
        PortVarContainer.pMonitorData = NULL;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return(FALSE);
    }

    RpcTryExcept {
        if (ReturnValue = RpcAddPortEx(pName, (LPPORT_CONTAINER)&PortContainer,
                                         (LPPORT_VAR_CONTAINER)&PortVarContainer,
                                         lpMonitorName
                                         )) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else {
            ReturnValue = TRUE;
        }
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;
    } RpcEndExcept

    return ReturnValue;
}



BOOL
DevQueryPrint(
    HANDLE      hPrinter,
    LPDEVMODE   pDevMode,
    DWORD      *pResID
)
{
    BOOL        Ok = FALSE;
    HANDLE      hModule;
    INT_FARPROC pfn;

    if (hModule = LoadPrinterDriver(hPrinter)) {

        if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrint")) {

            try {

                Ok = (*pfn)(hPrinter, pDevMode, pResID);

            } except(1) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                Ok = FALSE;
            }
        }

        RefCntUnloadDriver(hModule, TRUE);
    }

    return(Ok);
}



BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
)
{
    BOOL        Ok = FALSE;
    HANDLE      hModule;
    INT_FARPROC pfn;

    if (hModule = LoadPrinterDriver(pDQPInfo->hPrinter)) {

        if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrintEx")) {

            try {

                Ok = (*pfn)(pDQPInfo);

            } except(1) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                Ok = FALSE;
            }
        }

        RefCntUnloadDriver(hModule, TRUE);
    }

    return(Ok);
}



BOOL
SpoolerDevQueryPrintW(
    HANDLE     hPrinter,
    LPDEVMODE  pDevMode,
    DWORD      *pResID,
    LPWSTR     pszBuffer,
    DWORD      cchBuffer
)
{
    BOOL        Ok = FALSE;
    HANDLE      hModule;
    INT_FARPROC pfn;

    if (hModule = LoadPrinterDriver(hPrinter)) {

        if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrintEx")) {

            DEVQUERYPRINT_INFO  DQPInfo;

            DQPInfo.cbSize      = sizeof(DQPInfo);
            DQPInfo.Level       = 1;
            DQPInfo.hPrinter    = hPrinter;
            DQPInfo.pDevMode    = pDevMode;
            DQPInfo.pszErrorStr = (LPTSTR)pszBuffer;
            DQPInfo.cchErrorStr = (WORD)cchBuffer;
            DQPInfo.cchNeeded   = 0;

            try {

                *pResID = (Ok = (*pfn)(&DQPInfo)) ? 0 : 0xDCDCDCDC;

            } except(1) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                Ok = FALSE;
            }

        } else if (pfn = (INT_FARPROC)GetProcAddress(hModule, "DevQueryPrint")) {

            try {

                if ((Ok = (*pfn)(hPrinter, pDevMode, pResID))  &&
                    (*pResID)) {

                    UINT    cch;

                    *pszBuffer = L'\0';
                    SelectFormNameFromDevMode(hPrinter, pDevMode, pszBuffer);

                    if (cch = lstrlen(pszBuffer)) {

                        pszBuffer    += cch;
                        *pszBuffer++  = L' ';
                        *pszBuffer++  = L'-';
                        *pszBuffer++  = L' ';
                        cchBuffer    -= (cch + 3);
                    }

                    LoadString(hModule, *pResID, pszBuffer, cchBuffer);
                }

            } except(1) {

                SetLastError(TranslateExceptionCode(RpcExceptionCode()));
                Ok = FALSE;
            }
        }

        RefCntUnloadDriver(hModule, TRUE);
    }

    return(Ok);
}


LPWSTR
SelectFormNameFromDevMode(
    HANDLE      hPrinter,
    PDEVMODEW   pDevModeW,
    LPWSTR      pFormName
    )

/*++

Routine Description:

    This function pick the current form associated with current devmode and
    return a form name pointer


Arguments:

    hPrinter    - Handle to the printer object

    pDevModeW   - Pointer to the unicode devmode for this printer

    FormName    - Pointer to the formname to be filled


Return Value:

    Either a pointer to the FormName passed in if we do found one form,
    otherwise it return NULL to signal a failue


Author:

    21-Mar-1995 Tue 16:57:51 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    DWORD           cb;
    DWORD           cRet;
    LPFORM_INFO_1   pFIBase;
    LPFORM_INFO_1   pFI;
    BYTE            btBuffer[MAX_STATIC_ALLOC];
    BOOL            bAllocBuffer = FALSE, bReturn;

    //
    // 1. If the DM_FORMNAME is turned on, then we want to check this bit first
    //    because it only specific to the NT which using form.  The form name
    //    supposed set by any NT driver but not win31 or Win95.Use the
    //    dmFormName only if dmPaperSize, dmPaperLength and dmPaperWidth fields
    //    are not set. If any of them is set then we have to find a form using
    //    the value in these fields.
    //

    if ( (pDevModeW->dmFields & DM_FORMNAME)
         && (!(pDevModeW->dmFields & (DM_PAPERSIZE |
                                      DM_PAPERLENGTH |
                                      DM_PAPERWIDTH))) ) {

        wcscpy(pFormName, pDevModeW->dmFormName);
        return(pFormName);
    }

    //
    // For all other cases we need to get forms data base first, but we want
    // to set the form name to NULL so that we can check if we found one
    //

    cb      =
    cRet    = 0;
    pFIBase =
    pFI     = NULL;

    pFIBase = (LPFORM_INFO_1) btBuffer;
    ZeroMemory(pFIBase, MAX_STATIC_ALLOC);

    bReturn = EnumForms(hPrinter, 1, (LPBYTE)pFIBase, MAX_STATIC_ALLOC,
                        &cb, &cRet);

    if (!bReturn &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pFIBase = (LPFORM_INFO_1)LocalAlloc(LPTR, cb))) {

         bAllocBuffer = TRUE;
         bReturn = EnumForms(hPrinter, 1, (LPBYTE)pFIBase, cb, &cb, &cRet);
    }

    if (bReturn) {

        //
        // 2. If user specified dmPaperSize then honor it, otherwise, it must
        //    be a custom form, and we will check to see if it match one of
        //    in the database
        //

        if ((pDevModeW->dmFields & DM_PAPERSIZE)        &&
            (pDevModeW->dmPaperSize >= DMPAPER_FIRST)   &&
            (pDevModeW->dmPaperSize <= (SHORT)cRet)) {

            //
            // We go the valid index now
            //

            pFI = pFIBase + (pDevModeW->dmPaperSize - DMPAPER_FIRST);

        } else if ((pDevModeW->dmFields & DM_PAPER_WL) == DM_PAPER_WL) {

            LPFORM_INFO_1   pFICur = pFIBase;

            while (cRet--) {

                if ((DM_MATCH(pDevModeW->dmPaperWidth,  pFICur->Size.cx)) &&
                    (DM_MATCH(pDevModeW->dmPaperLength, pFICur->Size.cy))) {

                    //
                    // We found the match which has discern size differences
                    //

                    pFI = pFICur;

                    break;
                }

                pFICur++;
            }
        }
    }

    //
    // If we found the form then copy the name down, otherwise set the
    // formname to be NULL
    //

    if (pFI) {

        wcscpy(pFormName, pFI->pName);

    } else {

        *pFormName = L'\0';
        pFormName  = NULL;
    }

    if (bAllocBuffer) {
        LocalFree((HLOCAL)pFIBase);
    }

    return(pFormName);
}


BOOL
SetAllocFailCount(
    HANDLE  hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = hPrinter;
    UINT cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE )){
        return FALSE;
    }

    do {

        RpcTryExcept {

            if (ReturnValue = RpcSetAllocFailCount( pSpool->hPrinter,
                                                    dwFailCount,
                                                    lpdwAllocCount,
                                                    lpdwFreeCount,
                                                    lpdwFailCountHit )) {


                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}



BOOL
WINAPI
EnumPrinterPropertySheets(
    HANDLE  hPrinter,
    HWND    hWnd,
    LPFNADDPROPSHEETPAGE lpfnAdd,
    LPARAM  lParam
)
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
}


VOID
vUpdateTrayIcon(
    IN HANDLE hPrinter,
    IN DWORD JobId
    )
{
    SHCNF_PRINTJOB_DATA JobData;
    LPPRINTER_INFO_1 pPrinterInfo1;
    FARPROC pfnSHChangeNotify;
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BYTE btBuffer[MAX_PRINTER_INFO1];

    SPLASSERT( JobId );

    //
    // Avoid sending multiple notifications by setting this flag.
    // When other calls (notably StartDocPrinter) see this,
    // they will avoid sending a notification.
    //
    pSpool->Status |= SPOOL_STATUS_TRAYICON_NOTIFIED;

    if (InCSRProcess()) {

        //
        // We are running in CSR, don't load up shell.
        //
        return;
    }

    ZeroMemory( &JobData, sizeof( JobData ));
    JobData.JobId = JobId;

    //
    // Get a copy of the real printer name
    //
    pPrinterInfo1 = (LPPRINTER_INFO_1) btBuffer;
    ZeroMemory(pPrinterInfo1, MAX_PRINTER_INFO1);

    if( pPrinterInfo1 ){

        DWORD dwNeeded;

        if( GetPrinter( hPrinter,
                        1,
                        (PBYTE)pPrinterInfo1,
                        MAX_PRINTER_INFO1,
                        &dwNeeded )){

            if (hShell32 == INVALID_HANDLE_VALUE)
                hShell32 = LoadLibrary( gszShell32 );

            if (hShell32) {

                pfnSHChangeNotify = GetProcAddress( hShell32,
                                                    "SHChangeNotify" );

                if( pfnSHChangeNotify ){

                    (*pfnSHChangeNotify)(
                        SHCNE_CREATE,
                        SHCNF_PRINTJOB | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
                        pPrinterInfo1->pName,
                        &JobData );

                }
            }
        }
    }
}


INT
CallDrvDocumentEventNative(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )
/*++

Routine Description:

    Call DrvDocumentEvent on driver UI

Arguments:

Return Value:

    -1  : DOCUMENTEVENT_FAILURE
     0  : DOCUMENTEVENT_UNSUPPORTED
     1  : DOCUMENTEVENT_SUCCESS

--*/
{
    HANDLE          hLibrary;
    INT_FARPROC     pfn;
    INT             ReturnValue=DOCUMENTEVENT_UNSUPPORTED;
    PSPOOL          pSpool = (PSPOOL)hPrinter;
    ULONG_PTR       lActCtx = 0;
    BOOL            bDidActivate = FALSE;

    if ( hLibrary = LoadPrinterDriver( hPrinter )) {

        //
        // Activate the empty context, we do not check the return value.
        // because this may be called for non UI document events.
        //
        bDidActivate = ActivateActCtx( ACTCTX_EMPTY, &lActCtx );

        //
        // Disable the call so we don't recurse if the
        // callback calls StartPage, etc.
        //
        pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

        if( pfn = (INT_FARPROC)GetProcAddress( hLibrary, "DrvDocumentEvent")){

            try {

                ReturnValue = (*pfn)( hPrinter,
                                      hdc,
                                      iEsc,
                                      cbIn,
                                      pulIn,
                                      cbOut,
                                      pulOut);

            } except(1) {

                SetLastError(TranslateExceptionCode(GetExceptionCode()));
                ReturnValue = DOCUMENTEVENT_FAILURE;
            }

            //
            // When driver does not export DrvDocumentEvent we leave
            // this bit disabled so we will not try to load the DLL
            // for future calls
            //
            pSpool->Status |= SPOOL_STATUS_DOCUMENTEVENT_ENABLED;
        }

        //
        // Deactivate the context
        //
        if( bDidActivate ){
            DeactivateActCtx( 0, lActCtx );
        }

        RefCntUnloadDriver(hLibrary, TRUE);
    }

    return ReturnValue;
}

INT
CallDrvDocumentEventThunk(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )
/*++

Routine Description:

    Call DrvDocumentEvent on driver UI

Arguments:

Return Value:

    -1  : DOCUMENTEVENT_FAILURE
     0  : DOCUMENTEVENT_UNSUPPORTED
     1  : DOCUMENTEVENT_SUCCESS

--*/
{
    HANDLE          hLibrary;
    INT_FARPROC     pfn;
    INT             ReturnValue=DOCUMENTEVENT_UNSUPPORTED;
    DWORD           dwRet = ERROR_SUCCESS;
    PSPOOL          pSpool = (PSPOOL)hPrinter;

    LPWSTR  PrinterName = pSpool->pszPrinter;

    pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

    RpcTryExcept
    {
        *((PULONG_PTR)pulOut) = (ULONG_PTR)0L;

        if((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS)
        {
             ReturnValue = RPCSplWOW64DocumentEvent(PrinterName,
                                                    (ULONG_PTR)hdc,
                                                    iEsc,
                                                    cbIn,
                                                    (LPBYTE) pulIn,
                                                    &cbOut,
                                                    (LPBYTE*) pulOut,
                                                    &dwRet);
        }
        else
        {
            SetLastError(dwRet);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = -1;
    }
    RpcEndExcept

    pSpool->Status |= SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

    return ReturnValue;
}

INT
CallDrvDocumentEvent(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )
{
     if(RunInWOW64())
     {
          return(CallDrvDocumentEventThunk(hPrinter,
                                           hdc,
                                           iEsc,
                                           cbIn,
                                           pulIn,
                                           cbOut,
                                           pulOut));
     }
     else
     {
          return(CallDrvDocumentEventNative(hPrinter,
                                            hdc,
                                            iEsc,
                                            cbIn,
                                            pulIn,
                                            cbOut,
                                            pulOut));
     }
}


INT
DocumentEvent(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pulIn,
    ULONG       cbOut,
    PVOID       pulOut
    )

/*++

Routine Description:

    Allow the driver UI dll to hook specific print events.

Arguments:

Return Value:

    -1  : DOCUMENTEVENT_FAILURE
     0  : DOCUMENTEVENT_UNSUPPORTED
     1  : DOCUMENTEVENT_SUCCESS

--*/

{
    DWORD               cbNeeded;
    INT                 ReturnValue = DOCUMENTEVENT_FAILURE;
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    PDOCEVENT_FILTER    pDoceventFilter = NULL;
    BOOL                bDocEventFilter = FALSE;
    BOOL                bCallDriver     = TRUE;
    UINT                uIndex;

    if( eProtectHandle( hPrinter, FALSE )){
        return DOCUMENTEVENT_FAILURE;
    }

    if( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_CREATEDCPRE ){

        if ( pSpool->pDoceventFilter ) {

            FreeSplMem(pSpool->pDoceventFilter);
            pSpool->pDoceventFilter = NULL;
        }

        //
        // First we will check if the driver wants to filter the events
        //
        cbNeeded = sizeof(DOCEVENT_FILTER) + sizeof(DWORD) * (DOCUMENTEVENT_LAST-2);
        pDoceventFilter = AllocSplMem(cbNeeded);

        if ( pDoceventFilter == NULL )
            goto Fail;

        pDoceventFilter->cbSize             = sizeof(DOCEVENT_FILTER);
        pDoceventFilter->cElementsAllocated = DOCUMENTEVENT_LAST-1;
        pDoceventFilter->cElementsReturned  = (UINT)-1;
        pDoceventFilter->cElementsNeeded    = (UINT)-1;

        //
        // Before every CreateDC, re-enable DocumentEvent.
        // If it fails on the first try, then don't try again
        // until the next CreateDC.
        //
        pSpool->Status |= SPOOL_STATUS_DOCUMENTEVENT_ENABLED;

        ReturnValue = CallDrvDocumentEvent( hPrinter,
                                            hdc,
                                            DOCUMENTEVENT_QUERYFILTER,
                                            cbIn,
                                            pulIn,
                                            cbNeeded,
                                            (PVOID)pDoceventFilter);

        //
        // We only regard the call to be successful if the driver returned
        // success _and_ modified aither cElementsReturned or cElementsNeeded.
        // This is to handle the case where a driver returns success, but in
        // fact does not know how to handle the call.
        //
        bDocEventFilter = ReturnValue == DOCUMENTEVENT_SUCCESS &&
                            (pDoceventFilter->cElementsReturned  != (UINT)-1 ||
                             pDoceventFilter->cElementsNeeded    != (UINT)-1);

        if (pDoceventFilter->cElementsReturned  == (UINT)-1)
        {
            pDoceventFilter->cElementsReturned = 0;
        }

        if (pDoceventFilter->cElementsNeeded  == (UINT)-1)
        {
            pDoceventFilter->cElementsNeeded = 0;
        }

        if (bDocEventFilter) {

            //
            // Validity check
            //
            if ( pDoceventFilter->cElementsReturned > pDoceventFilter->cElementsAllocated ) {

                SPLASSERT(pDoceventFilter->cElementsReturned <= pDoceventFilter->cElementsAllocated);
                ReturnValue = DOCUMENTEVENT_FAILURE;
                goto Fail;

            //
            // For drivers that are written for future OS (with new doc events)
            // we still want to filter and send the doc events we support
            //
            // So we realloc and query
            //
            } else if ( pDoceventFilter->cElementsNeeded > pDoceventFilter->cElementsAllocated ) {

                uIndex = pDoceventFilter->cElementsNeeded;
                cbNeeded = sizeof(DOCEVENT_FILTER) + sizeof(DWORD) * (uIndex - 1);
                FreeSplMem(pDoceventFilter);
                ReturnValue = DOCUMENTEVENT_FAILURE;

                pDoceventFilter = AllocSplMem(cbNeeded);
                if ( pDoceventFilter == NULL )
                    goto Fail;

                pDoceventFilter->cbSize             = sizeof(DOCEVENT_FILTER);
                pDoceventFilter->cElementsAllocated = uIndex;

                ReturnValue = CallDrvDocumentEvent( hPrinter,
                                                    hdc,
                                                    DOCUMENTEVENT_QUERYFILTER,
                                                    cbIn,
                                                    pulIn,
                                                    cbNeeded,
                                                    (PVOID)pDoceventFilter);

                //
                // Validity check for second call
                //
                if ( ReturnValue == DOCUMENTEVENT_SUCCESS ) {

                    if ( pDoceventFilter->cElementsReturned > pDoceventFilter->cElementsAllocated ) {

                        SPLASSERT(pDoceventFilter->cElementsReturned <= pDoceventFilter->cElementsAllocated);
                        ReturnValue = DOCUMENTEVENT_FAILURE;;
                        goto Fail;
                    }
                }
            }
        }

        //
        // Not supported we go to old behavior (no filtering)
        //
        if ( bDocEventFilter && ReturnValue == DOCUMENTEVENT_SUCCESS )  {

            pSpool->pDoceventFilter = pDoceventFilter;
        } else {

            FreeSplMem(pDoceventFilter);
            pDoceventFilter = NULL;
        }
    }

    ReturnValue = DOCUMENTEVENT_UNSUPPORTED;

    if( pSpool->Status & SPOOL_STATUS_DOCUMENTEVENT_ENABLED ){

        //
        // When driver supports DOCUMENTEVENT_QUERYFILTER we will
        // only call events in the filter with
        // DOCUMENTEVENT_CREATEDCPRE being an exception
        //
        // When driver does not support it (or fails it) we revert to old
        // behavior and make all callbacks
        //
        if ( DOCUMENTEVENT_EVENT( iEsc ) != DOCUMENTEVENT_CREATEDCPRE   &&
             (pDoceventFilter = pSpool->pDoceventFilter) != NULL ) {

            for ( uIndex = 0, bCallDriver = FALSE ;
                  uIndex < pDoceventFilter->cElementsReturned && !bCallDriver ;
                  ++uIndex ) {

                if ( pDoceventFilter->aDocEventCall[uIndex] == DOCUMENTEVENT_EVENT(iEsc) )
                    bCallDriver = TRUE;
            }
        }

        if ( bCallDriver ) {

            ReturnValue = CallDrvDocumentEvent( hPrinter,
                                                hdc,
                                                iEsc,
                                                cbIn,
                                                pulIn,
                                                cbOut,
                                                pulOut);

            //
            // Old (i.e. before DOCUMENTEVENT_QUERYFILTER) behavior is
            // on DOCUMENTEVENT_CREATEDCPRE failure no more calls are made
            // to the driver UI dll. We preserve the same behavior.
            //
            // Note that some drivers return a large positive value for a success
            // code. So, ReturnValue <= DOCUMENTEVENT_UNSUPPORTED is the correct
            // implementation.
            // 
            if ( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_CREATEDCPRE   &&
                 ReturnValue <= DOCUMENTEVENT_UNSUPPORTED )
                pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;
        }

    }

    //
    // If it's a StartDocPost, a job was just added.  Notify the
    // tray icon if we haven't already.
    //
    if( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_STARTDOCPOST ){

        if( !( pSpool->Status & SPOOL_STATUS_TRAYICON_NOTIFIED )){

            //
            // If we have a StartDocPost, then issue a notification so that
            // the user's tray starts polling.  pulIn[0] holds the JobId.
            //
            vUpdateTrayIcon( hPrinter, (DWORD)((PULONG_PTR)pulIn)[0] );
        }

    } else {

        //
        // If we have sent a notification, then by the next time we get a
        // document event, we have completed any additional AddJobs or
        // StartDocPrinters.  Therefore we can reset the TRAYICON_NOTIFIED
        // flag, since any more AddJobs/StartDocPrinters are really new
        // jobs.
        //
        pSpool->Status &= ~SPOOL_STATUS_TRAYICON_NOTIFIED;
    }

Fail:
    if ( DOCUMENTEVENT_EVENT( iEsc ) == DOCUMENTEVENT_CREATEDCPRE   &&
         ReturnValue == DOCUMENTEVENT_FAILURE ) {

        FreeSplMem(pDoceventFilter);
        pSpool->Status &= ~SPOOL_STATUS_DOCUMENTEVENT_ENABLED;
        pSpool->pDoceventFilter = NULL;
    }

    vUnprotectHandle( hPrinter );
    return ReturnValue;
}

/****************************************************************************
* INT QueryColorProfile()
*
* Returns:
*
*  -1 : Printer driver does not hook color profile.
*   0 : Error.
*   1 : Success.
*
* History:
*   8/Oct/1997 by Hideyuki Nagase [hideyukn]
*  Wrote it.
*****************************************************************************/

INT
QueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdevmode,
    ULONG       ulQueryMode,
    PVOID       pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
)
{
    INT    iRet = 0;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    if( eProtectHandle( hPrinter, FALSE )){
        return 0;
    }

    if (pSpool->Status & SPOOL_STATUS_NO_COLORPROFILE_HOOK) {

        //
        // DrvQueryColorProfile is not supported in Printer driver.
        //
        iRet = -1;

    } else {

        HANDLE  hLibrary;
        INT_FARPROC pfn;

        if (hLibrary = LoadPrinterDriver( hPrinter )) {

            if (pfn = (INT_FARPROC)GetProcAddress( hLibrary, "DrvQueryColorProfile" )) {

                try {

                    //
                    // Call the Printer UI driver.
                    //
                    iRet = (*pfn)( hPrinter,
                                   pdevmode,
                                   ulQueryMode,
                                   pvProfileData,
                                   pcbProfileData,
                                   pflProfileData );

                } except(1) {

                    SetLastError(TranslateExceptionCode(RpcExceptionCode()));

                }

            } else {

                //
                // Mark this driver does not export it, so later
                // we can fail without load printer driver.
                //
                pSpool->Status |= SPOOL_STATUS_NO_COLORPROFILE_HOOK;

                //
                // Tell callee it is not supported.
                //
                iRet = -1;
            }

            RefCntUnloadDriver(hLibrary, TRUE);
        }
    }

    vUnprotectHandle( hPrinter );

    return (iRet);
}

/****************************************************************************
*  BOOL QuerySpoolMode( hPrinter, pflSpoolMode, puVersion )
*
*  This function is called by GDI at StartDoc time when printing to an EMF.
*  It tell GDI whether to embed fonts in the job as well as what version of
*  EMF to generate.
*
*  For now I am doing something hacky: I'm calling GetPrinterInfo to determine
*  if the target is a remote machine and if so always telling GDI to embed
*  fonts which don't exist on the server into spool file.  Eventually this
*  call will be routed to the print processor on the target machine which
*  will use some UI/registry setting to determine what to do with fonts and
*  set the version number correctly.
*
*  History:
*   5/13/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

// !!later move this define to the appropriate header file

#define QSM_DOWNLOADFONTS       0x00000001

BOOL
QuerySpoolMode(
    HANDLE hPrinter,
    LONG *pflSpoolMode,
    ULONG *puVersion
    )
{
    DWORD dwPrinterInfoSize = 0;
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    BOOL bRet = FALSE, bStatus, bAllocBuffer = FALSE;
    BYTE btBuffer[MAX_STATIC_ALLOC];


    pPrinterInfo2 = (PPRINTER_INFO_2) btBuffer;
    ZeroMemory(pPrinterInfo2, MAX_STATIC_ALLOC);

    bStatus = GetPrinter(hPrinter, 2, (LPBYTE) pPrinterInfo2,
                         MAX_STATIC_ALLOC, &dwPrinterInfoSize);

    if (!bStatus &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pPrinterInfo2 = (PRINTER_INFO_2*) LocalAlloc(LPTR,
                                                      dwPrinterInfoSize)))
    {
         bAllocBuffer = TRUE;
         bStatus = GetPrinter(hPrinter, 2, (LPBYTE) pPrinterInfo2,
                               dwPrinterInfoSize, &dwPrinterInfoSize);
    }

    if (bStatus)
    {
        *puVersion = 0x00010000;    // version 1.0

        //
        // No server means we are printing locally
        //
        *pflSpoolMode = ( pPrinterInfo2->pServerName == NULL ) ?
                            0 :
                            QSM_DOWNLOADFONTS;
        bRet = TRUE;
    }
    else
    {
        DBGMSG( DBG_WARNING, ( "QuerySpoolMode: GetPrinter failed %d.\n", GetLastError( )));
    }

    if (bAllocBuffer)
    {
        LocalFree( pPrinterInfo2 );
    }
    return bRet;
}


BOOL
SetPortW(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    )
{
    BOOL            ReturnValue;
    PORT_CONTAINER  PortContainer;

    switch (dwLevel) {

        case 3:
            if ( !pPortInfo ) {

                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            PortContainer.Level                 = dwLevel;
            PortContainer.PortInfo.pPortInfo3   = (PPORT_INFO_3)pPortInfo;
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    RpcTryExcept {

        if (bLoadedBySpooler && fpYSetPort) {

            ReturnValue = (*fpYSetPort)(pszName, pszPortName, &PortContainer, NATIVE_CALL);
        }
        else {
            ReturnValue = RpcSetPort(pszName, pszPortName, &PortContainer);
        }

        if (ReturnValue != ERROR_SUCCESS) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else {

            ReturnValue = TRUE;
        }
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
bValidDevModeW(
    const DEVMODE *pDevMode
    )

/*++

Routine Description:

    Check whether a devmode is valid to be RPC'd across to the spooler.

Arguments:

    pDevMode - DevMode to check.

Return Value:

    TRUE - Devmode can be RPC'd to spooler.
    FALSE - Invalid Devmode.

--*/

{
    if( !pDevMode || pDevMode == (PDEVMODE)-1 ){
        return FALSE;
    }

    if( pDevMode->dmSize < MIN_DEVMODE_SIZEW ){

        //
        // The only valid case is if pDevModeW is NULL.  If it's
        // not NULL, then a bad devmode was passed in and the
        // app should fix it's code.
        //
        SPLASSERT( pDevMode->dmSize >= MIN_DEVMODE_SIZEW );
        return FALSE;
    }

    return TRUE;
}

BOOL
XcvDataW(
    HANDLE  hPrinter,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType  = 0;
    PSPOOL  pSpool      = (PSPOOL)hPrinter;
    UINT    cRetry      = 0;

    if (!pcbOutputNeeded){
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( eProtectHandle( hPrinter, FALSE )){
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // a dummy pointer.
    //

    if (!pInputData && !cbInputData)
        pInputData = (PBYTE) &ReturnValue;

    if (!pOutputData && !cbOutputData)
        pOutputData = (PBYTE) &ReturnValue;

    do {
        RpcTryExcept {

            if (ReturnValue = RpcXcvData(   pSpool->hPrinter,
                                            pszDataName,
                                            pInputData,
                                            cbInputData,
                                            pOutputData,
                                            cbOutputData,
                                            pcbOutputNeeded,
                                            pdwStatus)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;
            } else {
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            ReturnValue = FALSE;

        } RpcEndExcept

    } while( !ReturnValue &&
             GetLastError() == ERROR_INVALID_HANDLE &&
             cRetry++ < MAX_RETRY_INVALID_HANDLE &&
             RevalidateHandle( pSpool ));

    if (!ReturnValue) {
        DBGMSG(DBG_TRACE,("XcvData Exception: %d\n", GetLastError()));
    }

    vUnprotectHandle( hPrinter );

    return ReturnValue;
}


PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
)
{
    DWORD   cbOutput;
    PWSTR   pOut;

    cbOutput = pServerName ? (wcslen(pServerName) + 2)*sizeof(WCHAR) : sizeof(WCHAR);   /* "\\Server\," */
    cbOutput += (wcslen(pObjectType) + 2)*sizeof(WCHAR);                    /* "\\Server\,XcvPort _" */
    cbOutput += pObjectName ? (wcslen(pObjectName))*sizeof(WCHAR) : 0;      /* "\\Server\,XcvPort Object_" */

    if (pOut = AllocSplMem(cbOutput)) {

        if (pServerName) {
            wcscpy(pOut,pServerName);
            wcscat(pOut, L"\\");
        }

        wcscat(pOut,L",");
        wcscat(pOut,pObjectType);
        wcscat(pOut,L" ");

        if (pObjectName)
            wcscat(pOut,pObjectName);
    }

    return pOut;
}


HANDLE
ConnectToPrinterDlg(
    IN HWND hwnd,
    IN DWORD dwFlags
    )
{
    typedef HANDLE (WINAPI *PF_CONNECTTOPRINTERDLG)( HWND, DWORD );

    PF_CONNECTTOPRINTERDLG  pfConnectToPrinterDlg   = NULL;
    HANDLE                  hHandle                 = NULL;
    HINSTANCE               hLib                    = NULL;

    hLib = LoadLibrary( szPrintUIDll );

    if( hLib )
    {
        pfConnectToPrinterDlg = (PF_CONNECTTOPRINTERDLG)GetProcAddress( hLib, "ConnectToPrinterDlg" );

        if( pfConnectToPrinterDlg )
        {
            hHandle = pfConnectToPrinterDlg( hwnd, dwFlags );
        }

        FreeLibrary( hLib );

    }

    return hHandle;
}

DWORD
SendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCWSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
    )
{
    DWORD  dwRet  = ERROR_SUCCESS;
    PSPOOL pSpool = (PSPOOL)hPrinter;
    UINT   cRetry = 0;

    if( eProtectHandle( hPrinter, FALSE ))
    {
        dwRet = GetLastError();
    }
    else
    {
        do
        {
            RpcTryExcept
            {
                if(ppResData)
                {
                    *ppResData = NULL;
                }

                dwRet = RpcSendRecvBidiData(pSpool->hPrinter,
                                            pAction,
                                            (PRPC_BIDI_REQUEST_CONTAINER)pReqData,
                                            (PRPC_BIDI_RESPONSE_CONTAINER*)ppResData);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                 dwRet = TranslateExceptionCode(RpcExceptionCode());
            }
            RpcEndExcept

        } while (dwRet == ERROR_INVALID_HANDLE &&
                 cRetry++ < MAX_RETRY_INVALID_HANDLE &&
                 RevalidateHandle( pSpool ));

        vUnprotectHandle( hPrinter );
    }
    //
    // If we are trying to communicate with a downlevel router, that does
    // not understand the meaning of SendRecvBidiData , we would get the
    // error code: RPC_S_PROCNUM_OUT_OF_RANGE which might be converted to
    // ERROR_NOT_SUPPORTED for better clearity and more consistency with
    // the a genaral return error code if feature is not supported.
    if(dwRet == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        dwRet = ERROR_NOT_SUPPORTED;
    }
    return (dwRet);
}

VOID
PrintUIQueueCreate(
    IN HWND    hWnd,
    IN LPCWSTR PrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{

     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIQueueCreate((ULONG_PTR)GetForeGroundWindow(),
                                                       PrinterName,
                                                       CmdShow,
                                                       lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDQUEUECREATE)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}


VOID
PrintUIPrinterPropPages(
    IN HWND    hWnd,
    IN LPCWSTR PrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIPrinterPropPages((ULONG_PTR)GetForeGroundWindow(),
                                                            PrinterName,
                                                            CmdShow,
                                                            lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDPRINTERPROPPAGES)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}


VOID
PrintUIDocumentDefaults(
    IN HWND    hWnd,
    IN LPCWSTR PrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIDocumentDefaults((ULONG_PTR)GetForeGroundWindow(),
                                                            PrinterName,
                                                            CmdShow,
                                                            lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDDOCUMENTDEFAULTS)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}

DWORD WINAPI
AsyncPrinterSetup(
    PVOID pData
    )
{
     PrinterSetupData *pThrdData = (PrinterSetupData *)pData;

     RpcTryExcept
     {
         RPCSplWOW64PrintUIPrinterSetup((ULONG_PTR)GetForeGroundWindow(),
                                         pThrdData->uAction,
                                         pThrdData->cchPrinterName,
                                         pThrdData->PrinterNameSize,
                                         (byte *)pThrdData->pszPrinterName,
                                         pThrdData->pcchPrinterName,
                                         pThrdData->pszServerName);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}


BOOL
PrintUIPrinterSetup(
    IN     HWND     hWnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPWSTR   pszPrinterName,
       OUT UINT     *pcchPrinterName,
    IN     LPCWSTR  pszServerName
    )
{

    BOOL bRet   = FALSE;
    DWORD dwRet = ERROR_SUCCESS;


    RpcTryExcept
    {
        if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
           ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
        {
            HANDLE           hAsyncSetupThrd  = NULL;
            DWORD            AsyncSetupThrdId = 0;
            PrinterSetupData ThrdData;

            AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

            ThrdData.hWnd            = (ULONG_PTR)GetForeGroundWindow();
            ThrdData.uAction         = uAction;
            ThrdData.cchPrinterName  = cchPrinterName;
            ThrdData.PrinterNameSize = cchPrinterName*2;
            ThrdData.pszPrinterName  = pszPrinterName;
            ThrdData.pcchPrinterName = pcchPrinterName;
            ThrdData.pszServerName    = pszServerName;

            if(!(hAsyncSetupThrd = CreateThread(NULL,
                                                INITIAL_STACK_COMMIT,
                                                AsyncPrinterSetup,
                                                (PVOID)&ThrdData,
                                                0,
                                                &AsyncSetupThrdId)))
            {
                 dwRet = GetLastError();
            }
            else
            {
                MSG msg;
                while(GetMessage(&msg, NULL, 0, 0))
                {
                    if(msg.message == WM_ENDPRINTERSETUP)
                    {
                        bRet = (BOOL)msg.wParam;
                        SetLastError((DWORD)msg.lParam);
                        DelHandleFromList(hWnd);
                        break;
                    }
                    else if(msg.message == WM_SURROGATEFAILURE)
                    {
                         //
                         // This means that the server process died and we have
                         // break from the message loop
                         //
                         SetLastError(RPC_S_SERVER_UNAVAILABLE);
                         break;
                    }
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                WaitForSingleObject(hAsyncSetupThrd,INFINITE);
                CloseHandle(hAsyncSetupThrd);
            }
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
         SetLastError(TranslateExceptionCode(RpcExceptionCode()));
    }
    RpcEndExcept

    return bRet;
}

VOID
PrintUIServerPropPages(
    IN HWND    hWnd,
    IN LPCWSTR ServerName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
     DWORD dwRet = ERROR_SUCCESS;

     RpcTryExcept
     {
         if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
            ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS))
         {
             AllowSetForegroundWindow(RPCSplWOW64GetProcessID());

             if((dwRet = RPCSplWOW64PrintUIServerPropPages((ULONG_PTR)GetForeGroundWindow(),
                                                            ServerName,
                                                            CmdShow,
                                                            lParam)) == ERROR_SUCCESS)
             {
                 MSG msg;
                 while(GetMessage(&msg, NULL, 0, 0))
                 {
                     if(msg.message == WM_ENDSERVERPROPPAGES)
                     {
                         DelHandleFromList(hWnd);
                         break;
                     }
                     else if(msg.message == WM_SURROGATEFAILURE)
                     {
                          //
                          // This means that the server process died and we have
                          // break from the message loop
                          //
                          SetLastError(RPC_S_SERVER_UNAVAILABLE);
                          break;
                     }
                     TranslateMessage(&msg);
                     DispatchMessage(&msg);
                 }
             }
             else
             {
                  SetLastError(dwRet);
             }
         }
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
}


DWORD WINAPI
AsyncDocumentPropertiesWrap(
    PVOID pData
    )
{
     PumpThrdData *ThrdData = (PumpThrdData *)pData;

     RpcTryExcept
     {
         *ThrdData->Result = RPCSplWOW64PrintUIDocumentProperties(ThrdData->hWnd,
                                                                  ThrdData->PrinterName,
                                                                  ThrdData->TouchedDevModeSize,
                                                                  ThrdData->ClonedDevModeOutSize,
                                                                  ThrdData->ClonedDevModeOut,
                                                                  ThrdData->DevModeInSize,
                                                                  ThrdData->pDevModeInput,
                                                                  ThrdData->ClonedDevModeFill,
                                                                  ThrdData->fMode,
                                                                  ThrdData->fExclusionFlags,
                                                                  ThrdData->dwRet);
     }
     RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
     {
          SetLastError(TranslateExceptionCode(RpcExceptionCode()));
     }
     RpcEndExcept
     return(0);
}


LONG
PrintUIDocumentPropertiesWrap(
    HWND hWnd,                  // handle to parent window
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    )
{
    DOCUMENTPROPERTYHEADER  DPHdr;
    PDEVMODE                pDM;
    LONG                    Result = -1;
    HANDLE                  hTmpPrinter = NULL;
    PSPOOL                  pSpool  = (PSPOOL)hPrinter;


    if (hPrinter == NULL)
    {
        if (!OpenPrinter( pDeviceName, &hTmpPrinter, NULL ))
        {
            hTmpPrinter = NULL;
        }
    }
    else
    {

        hTmpPrinter = hPrinter;
    }


    if( !eProtectHandle( hTmpPrinter, FALSE ))
    {
        LPWSTR PrinterName;
        MSG    msg;
        LONG   RetVal;
        DWORD  dwRet                = ERROR_SUCCESS;
        DWORD  ClonedDevModeOutSize = 0;
        DWORD  TouchedDevModeSize   = 0;
        BOOL   ClonedDevModeFill = (!!(fMode & DM_OUT_BUFFER) && pDevModeOutput);
        DWORD  DevModeInSize =  pDevModeInput ? (pDevModeInput->dmSize + pDevModeInput->dmDriverExtra) : 0;
        byte   **ClonedDevModeOut = NULL;

        if(ClonedDevModeOut = (byte **)LocalAlloc(LPTR,sizeof(byte *)))
        {
            *ClonedDevModeOut = NULL;

            if(pSpool)
            {
                PrinterName = pSpool->pszPrinter;
            }
            else
            {
                PrinterName = pDeviceName;
            }

            //
            // If fMode doesn't specify DM_IN_BUFFER, then zero out
            // pDevModeInput.
            //
            // Old 3.51 (version 1-0) drivers used to ignore the absence of
            // DM_IN_BUFFER and use pDevModeInput if it was not NULL.  It
            // probably did this because Printman.exe was broken.
            //
            // If the devmode is invalid, then don't pass one in.
            // This fixes MS Imager32 (which passes dmSize == 0) and
            // Milestones etc. 4.5.
            //
            // Note: this assumes that pDevModeOutput is still the
            // correct size!
            //
            if( !(fMode & DM_IN_BUFFER) || !bValidDevModeW( pDevModeInput ))
            {

                //
                // If either are not set, make sure both are not set.
                //
                pDevModeInput  = NULL;
                DevModeInSize  = 0;
                fMode &= ~DM_IN_BUFFER;
            }

            RpcTryExcept
            {
                if(((dwRet = ConnectToLd64In32Server(&hSurrogateProcess)) == ERROR_SUCCESS) &&
                   (!hWnd ||
                   ((dwRet = AddHandleToList(hWnd)) == ERROR_SUCCESS)))
                 {
                      HANDLE       hUIMsgThrd  = NULL;
                      DWORD        UIMsgThrdId = 0;
                      PumpThrdData ThrdData;

                      ThrdData.hWnd = (ULONG_PTR)hWnd;
                      ThrdData.PrinterName=PrinterName;
                      ThrdData.TouchedDevModeSize   = &TouchedDevModeSize;
                      ThrdData.ClonedDevModeOutSize = &ClonedDevModeOutSize;
                      ThrdData.ClonedDevModeOut = (byte**)ClonedDevModeOut;
                      ThrdData.DevModeInSize = DevModeInSize;
                      ThrdData.pDevModeInput = (byte*)pDevModeInput;
                      ThrdData.fMode = fMode;
                      ThrdData.fExclusionFlags = fExclusionFlags;
                      ThrdData.dwRet = &dwRet;
                      ThrdData.ClonedDevModeFill = ClonedDevModeFill;
                      ThrdData.Result = &Result;


                      //
                      // If we have a window handle , the following functions cann't
                      // proceed synchronasly. The reason for that is in order to show
                      // the UI of the driver property sheets we need to be able to dispatch
                      // incomming messages and process them.For this reason the following
                      // call would be asynchronous call and the success or failure doesn't
                      // in reality tell us anything more than than the async process started
                      // or not. We get the success of failure from the termination message.
                      // If we don't have a window handle, then the call is synchronous.
                      //
                      if(!(hUIMsgThrd = CreateThread(NULL,
                                                     INITIAL_STACK_COMMIT,
                                                     AsyncDocumentPropertiesWrap,
                                                     (PVOID)&ThrdData,
                                                     0,
                                                     &UIMsgThrdId)))
                      {
                           dwRet = GetLastError();
                      }
                      //
                      // The following is the required message loop for processing messages
                      // from the UI in case we have a window handle.
                      //
                      //
                       if(hUIMsgThrd && hWnd)
                       {
                            while (GetMessage(&msg, NULL, 0, 0))
                            {
                                 //
                                 // In This message loop We should trap a User defined message
                                 // which indicates the success or the failure of the operation
                                 //
                                 if(msg.message == WM_ENDPRINTUIDOCUMENTPROPERTIES)
                                 {
                                      Result     = (LONG)msg.wParam;
                                      if(Result == -1)
                                           SetLastError((DWORD)msg.lParam);
                                      DelHandleFromList(hWnd);
                                      break;
                                 }
                                 else if(msg.message == WM_SURROGATEFAILURE)
                                 {
                                      //
                                      // This means that the server process died and we have
                                      // break from the message loop
                                      //
                                      Result = -1;
                                      SetLastError(RPC_S_SERVER_UNAVAILABLE);
                                      break;
                                 }
                                 TranslateMessage(&msg);
                                 DispatchMessage(&msg);
                            }
                      }

                      if(hUIMsgThrd)
                      {
                          WaitForSingleObject(hUIMsgThrd,INFINITE);
                          CloseHandle(hUIMsgThrd);
                      }

                      if(Result!=-1 && pDevModeOutput)
                      {
                          memcpy((PVOID)pDevModeOutput,(PVOID)*ClonedDevModeOut,TouchedDevModeSize);
                      }
                      if(*ClonedDevModeOut)
                      {
                           MIDL_user_free((PVOID)*ClonedDevModeOut);
                      }

                      if(ClonedDevModeOut)
                      {
                           LocalFree((PVOID) ClonedDevModeOut);
                      }
                 }
                 else
                 {
                      SetLastError(dwRet);
                 }
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                 SetLastError(TranslateExceptionCode(RpcExceptionCode()));
            }
            RpcEndExcept

            vUnprotectHandle( hTmpPrinter );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }

    }

    if (hPrinter == NULL)
    {
        if( hTmpPrinter )
        {
            ClosePrinter(hTmpPrinter);
        }
    }
    return(Result);
}

/*++
    Function Name:
        MonitorRPCServerProcess

    Description:
        This function monitors the status of the RPC surrogate
        process. The one used in loading the required 64 dlls
        in a 32 bit client.This function always run in a
        separate thread

     Parameters:
        pData : Pointer to the process handle to monitor

     Return Value
       Always return 0
--*/


DWORD WINAPI
MonitorRPCServerProcess(
    PVOID pData
    )
{
    WndHndlList      ListObj;
    HANDLE*          phProcess;
    HANDLE           hEvent;
    LPMonitorThrdData pThrdData = (LPMonitorThrdData)pData;

    ListObj.Head       = 0x00000000;
    ListObj.Tail       = 0x00000000;
    ListObj.NumOfHndls = 0;

    //
    // reconstruct the Data for the thread
    //
    hEvent    = pThrdData->hEvent;
    phProcess = pThrdData->hProcess;

    EnterCriticalSection(&ProcessHndlCS);
    {
        GWndHndlList = &ListObj;
    }
    LeaveCriticalSection(&ProcessHndlCS);

    SetEvent(hEvent);

    WaitForSingleObject(*phProcess,INFINITE);

    EnterCriticalSection(&ProcessHndlCS);
    {
        CloseHandle(*((HANDLE *)phProcess));
        *((HANDLE *)phProcess) = 0x00000000;
        RpcBindingFree(&hSurrogate);
        //
        // Release any windows which might be
        // locked on a surrogate process waiting
        // for its completion
        //
        ReleaseAndCleanupWndList();
    }
    LeaveCriticalSection(&ProcessHndlCS);

    return(0);
}

/*++
    Function Name:
        ConnectToLd64In32Server

    Description:
        This function make sure that we retry connection to the server
        in case of a very slight window where the Server terminated between
        our connection and the very first call.

     Parameters:
        hProcess : Pointer to the process handle that retrieves
                   the process handle of the server

     Return Value

--*/
DWORD
ConnectToLd64In32Server(
    HANDLE *hProcess
    )
{
     DWORD RetVal = ERROR_SUCCESS;

     //
     // As GDI would be using the same monitoring Thread, So we spin
     // only one thread.
     //
     if(!hProcess)
     {
         hProcess = &hSurrogateProcess;
     }

     if( (RetVal =  ConnectToLd64In32ServerWorker(hProcess)) != ERROR_SUCCESS)
     {
          if(RetVal == RPC_S_SERVER_UNAVAILABLE || RetVal == RPC_S_CALL_FAILED_DNE)
          {
               RetVal =  ConnectToLd64In32ServerWorker(hProcess);
          }
     }
     return(RetVal);
}



/*++
    Function Name:
        ConnectToLd64In32ServerWorker

    Description:
        This function handles the connectivity issues with
        the RPC surrogate process (the one that loads 64 bit
        dlls in a 32 bit process).

     Parameters:
        hProcess : Pointer to the process handle that retrieves
                   the process handle of the server

     Return Value

--*/
DWORD
ConnectToLd64In32ServerWorker(
    HANDLE *hProcess
    )
{
    DWORD      RetVal = ERROR_SUCCESS;
    RPC_STATUS RpcStatus;

    EnterCriticalSection(&ProcessHndlCS);
    {
        if(!*hProcess)
        {
               WCHAR*                StringBinding = NULL;
               STARTUPINFO           StartUPInfo;
               PROCESS_INFORMATION   ProcessInfo;

               ZeroMemory(&StartUPInfo,sizeof(STARTUPINFO));
               ZeroMemory(&ProcessInfo,sizeof(PROCESS_INFORMATION));
               StartUPInfo.cb = sizeof(STARTUPINFO);

               RpcTryExcept
               {
                   HANDLE hOneProcessMutex = NULL;
                   WCHAR  SessionEndPoint[50];
                   DWORD  CurrSessionId;
                   DWORD  CurrProcessId = GetCurrentProcessId();

                   if(ProcessIdToSessionId(CurrProcessId,&CurrSessionId))
                   {
                        wsprintf(SessionEndPoint,L"%s_%x",L"splwow64",CurrSessionId);

                        if(!(((RpcStatus = RpcStringBindingCompose(NULL,
                                                                   L"ncalrpc",
                                                                   NULL,
                                                                   SessionEndPoint,
                                                                   NULL,
                                                                   &StringBinding))==RPC_S_OK)     &&

                             ((RpcStatus = RpcBindingFromStringBinding(StringBinding,
                                                                       &hSurrogate))==RPC_S_OK)    &&

                             ((RpcStatus = RpcStringFree(&StringBinding)) == RPC_S_OK)))
                        {
                             RetVal = (DWORD)RpcStatus;
                        }
                        else
                        {
                             //
                             // This mutex is defined as Local to be different for
                             // each TS session
                             //
                             if(hOneProcessMutex = CreateMutex(NULL,
                                                               FALSE,
                                                               L"Local\\WinSpl64To32Mutex"))
                             {
                                  HANDLE hThread;
                                  HANDLE hMonitorStartedEvent;
                                  DWORD  ThreadId;
                                  DWORD i=0;
                                  DWORD RpcRetCode;

                                  WaitForSingleObject(hOneProcessMutex,INFINITE);
                                  {
                                       if(RpcMgmtIsServerListening(hSurrogate) == RPC_S_NOT_LISTENING)
                                       {
                                            WCHAR ProcessName[MAX_PATH+1];
                                            WCHAR WindowsDirectory[MAX_PATH+1];
                                            //
                                            // In the future this should work , but
                                            // for the time being , wow64 redirects
                                            // any CreateProcess initiated from a wow
                                            // app and requesting an app from system32
                                            // to syswow64. That is why I moving the exe
                                            // out of the system32 directory.
                                            //
                                            GetSystemWindowsDirectory(WindowsDirectory,MAX_PATH);
                                            wsprintf(ProcessName,L"%ws\\splwow64.exe",WindowsDirectory);
                                            if(!CreateProcess(ProcessName,
                                                              L"splwow64",
                                                              NULL,
                                                              NULL,
                                                              FALSE,
                                                              CREATE_DEFAULT_ERROR_MODE |
                                                              CREATE_NO_WINDOW          |
                                                              DETACHED_PROCESS,
                                                              NULL,
                                                              WindowsDirectory,
                                                              &StartUPInfo,
                                                              &ProcessInfo))
                                            {
                                                 RetVal = GetLastError();
                                            }
                                            else
                                            {
                                                 *hProcess = ProcessInfo.hProcess;
                                                 //
                                                 // A spinlock making sure that the process is really live and kicking.
                                                 // I also added to the spin lock a time out value in order not to enter
                                                 // in an endless loop. So, after a minute we just break.
                                                 //


                                                 for(i=0,
                                                     RpcRetCode = RpcMgmtIsServerListening(hSurrogate);

                                                     ((i<60) && (RpcRetCode == RPC_S_NOT_LISTENING));

                                                     Sleep(1000),
                                                     RpcRetCode = RpcMgmtIsServerListening(hSurrogate),
                                                     i++
                                                     );
                                            }
                                       }
                                       else
                                       {
                                            *hProcess = (HANDLE) RPCSplWOW64GetProcessHndl((DWORD)GetCurrentProcessId(),&RetVal);
                                       }
                                  }
                                  ReleaseMutex(hOneProcessMutex);
                                  CloseHandle(hOneProcessMutex);

                                  if(!(hMonitorStartedEvent=CreateEvent(NULL,FALSE,FALSE,NULL)))
                                  {
                                      RetVal = GetLastError();
                                  }
                                  else
                                  {
                                      MonitorThrdData ThrdData;

                                      ThrdData.hEvent   = hMonitorStartedEvent;
                                      ThrdData.hProcess = hProcess;

                                      if(!(hThread = CreateThread(NULL,
                                                                  INITIAL_STACK_COMMIT,
                                                                  MonitorRPCServerProcess,
                                                                  (PVOID)&ThrdData,
                                                                  0,
                                                                  &ThreadId)))
                                      {
                                           RetVal = GetLastError();
                                      }
                                      else
                                      {
                                          LeaveCriticalSection(&ProcessHndlCS);
                                          {
                                              WaitForSingleObject(hMonitorStartedEvent,INFINITE);
                                          }
                                          EnterCriticalSection(&ProcessHndlCS);

                                          CloseHandle(hThread);
                                      }
                                      CloseHandle(hMonitorStartedEvent);
                                  }
                             }
                             else
                             {
                                  RetVal = GetLastError();
                             }
                        }

                   }
                   else
                   {
                        RetVal = GetLastError();
                   }
               }
               RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
               {
                    RetVal = RpcExceptionCode();
               }
               RpcEndExcept

        }
        else
        {
             //
             // Refresh the life of the server
             //
             RpcTryExcept
             {
                  RPCSplWOW64RefreshLifeSpan();
             }
             RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
                  RetVal = RpcExceptionCode();
             }
             RpcEndExcept
        }

    }
    LeaveCriticalSection(&ProcessHndlCS);
    return(RetVal);
}


DWORD
AddHandleToList(
    HWND hWnd
    )
{
    LPWndHndlNode NewNode = 0x00000000;
    DWORD         RetVal  = ERROR_SUCCESS;

    EnterCriticalSection(&ProcessHndlCS);
    {
        if(GWndHndlList)
        {
            if(NewNode = (LPWndHndlNode)LocalAlloc(LMEM_FIXED, sizeof(WndHndlNode)))
            {
                NewNode->PrevNode = 0x000000000;
                NewNode->NextNode = 0x000000000;
                NewNode->hWnd     = hWnd;
                if(!GWndHndlList->Head &&
                   !GWndHndlList->NumOfHndls)
                {
                    GWndHndlList->Head = NewNode;
                    GWndHndlList->Tail = NewNode;
                }
                else
                {
                     NewNode->PrevNode            = GWndHndlList->Tail;
                     GWndHndlList->Tail->NextNode = NewNode;
                     GWndHndlList->Tail           = NewNode;
                }
                GWndHndlList->NumOfHndls++;
            }
            else
            {
                RetVal = GetLastError();
            }
        }
        else
        {
            RetVal = ERROR_INVALID_PARAMETER;
        }
    }
    LeaveCriticalSection(&ProcessHndlCS);

    return(RetVal);
}


BOOL
DelHandleFromList(
    HWND hWnd
    )
{
    DWORD       RetVal = ERROR_SUCCESS;
    BOOL        Found  = FALSE;

    EnterCriticalSection(&ProcessHndlCS);
    {
        LPWndHndlNode TempNode = 0x00000000;

        if(GWndHndlList)
        {
            if(GWndHndlList->NumOfHndls)
            {
                //
                // Is it last Element in list
                //
                if(GWndHndlList->Tail->hWnd == hWnd)
                {
                    TempNode = GWndHndlList->Tail;
                    GWndHndlList->Tail = TempNode->PrevNode;
                    if(GWndHndlList->Tail)
                    {
                        GWndHndlList->Tail->NextNode = 0x00000000;
                    }
                    Found = TRUE;
                }

                //
                // Is it first Element in list
                //
                else if(GWndHndlList->Head->hWnd == hWnd)
                {
                    TempNode = GWndHndlList->Head;
                    GWndHndlList->Head = TempNode->NextNode;
                    if(GWndHndlList->Head)
                        GWndHndlList->Head->PrevNode = 0x00000000;
                    Found = TRUE;
                }

                //
                // Is it an intermediate Element
                //
                else
                {
                    TempNode = GWndHndlList->Head->NextNode;
                    while(TempNode                 &&
                          (TempNode->hWnd != hWnd) &&
                          TempNode != GWndHndlList->Tail)
                    {
                        TempNode = TempNode->NextNode;
                    }
                    if(TempNode && TempNode!=GWndHndlList->Tail)
                    {
                        Found = TRUE;
                        TempNode->PrevNode->NextNode = TempNode->NextNode;
                        TempNode->NextNode->PrevNode = TempNode->PrevNode;
                    }
                }
                if(Found)
                {
                    if(!--GWndHndlList->NumOfHndls)
                    {
                        GWndHndlList->Head = GWndHndlList->Tail = 0x00000000;
                    }
                    LocalFree(TempNode);
                }
            }
        }
        else
        {
            RetVal = ERROR_INVALID_PARAMETER;
        }
    }
    LeaveCriticalSection(&ProcessHndlCS);

    return(RetVal);
}

VOID
ReleaseAndCleanupWndList(
    VOID
    )
{
    LPWndHndlNode TempNode = (LPWndHndlNode)GWndHndlList->Head;
    while(TempNode)
    {
        PostMessage(TempNode->hWnd,
                    WM_SURROGATEFAILURE,
                    0,
                    0);
        GWndHndlList->Head = TempNode->NextNode;
        LocalFree(TempNode);
        TempNode = GWndHndlList->Head;
    }
    GWndHndlList->NumOfHndls = 0;
}

BOOL
JobCanceled(
    IN PSJobCancelInfo pJobCancelInfo
    )
{
    if (!pJobCancelInfo->NumOfCmpltWrts && pJobCancelInfo->pSpool->cbFlushPending)
    {
        //
        // Data to be flushed =
        // pSpool->cbFlushPending
        //
        FlushPrinter(pJobCancelInfo->pSpool,
                     pJobCancelInfo->pSpool->pBuffer+pJobCancelInfo->cbFlushed,
                     pJobCancelInfo->pSpool->cbFlushPending,
                     pJobCancelInfo->pcbWritten,
                     0);

        pJobCancelInfo->pSpool->Flushed = 1;
    }
    else
    {
        DWORD WrittenDataSize = *pJobCancelInfo->pcTotalWritten + pJobCancelInfo->cbFlushed;
        //
        // Data to be flushed =
        // I/P Data + Pending Data - Total Written
        //    
        SPLASSERT(WrittenDataSize <= pJobCancelInfo->ReqTotalDataSize);

        if (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize)
        {
            LPBYTE pFlushBuffer;
            //
            // Location in pFlushBuffer where data from the 
            // i/p buffer starts
            //
            DWORD  InitialBuffStart = 0;
            if ((pFlushBuffer = VirtualAlloc(NULL,
                                             (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize),
                                             MEM_COMMIT, PAGE_READWRITE)))
            {
                //
                // Since this seems to be quite a complicated functionality
                // I'll try explaining it in details here
                // These are the Data Buffers we are dealing with and their
                // initial states
                //
                //      pSpool->pBuffer             pBuf = pInitialBuf
                //   ____________________   _________________________________
                //  |       |           |  |                                |
                //  |       |           |  |                                |
                //  --------------------   ---------------------------------
                //  <------->              <-------------------------------->
                //   pending                      ReqToWriteDataSize      
                //      |                                 |  
                //      |                                 |
                //       ----------------+----------------
                //                       |
                //            (RequiredTotalDataSize)
                //
                // At this stage of the function we could have the
                // following conditions
                // 1. Written < Pending   -----> Then we have to 
                //                               count both Buffers for Flushing
                // 2. Written > Pending   -----> Then we count only pBuf for 
                //                               Flushing
                // Based on these conditions we need to figure out which of the 
                // of the 2 buffers is used for flushing the data and what pointer 
                // in either is the starting point of this data
                // For Condition 1 FlushBuffer would be the aggregation of :
                //      pSpool->pBuffer             pBuf = pInitialBuf
                //   ____________________   _________________________________
                //  |    |   |          |  |                                |
                //  |    |   |          |  |                                |
                //  --------------------   ---------------------------------
                //       <--->             <------------------------------->
                //    Pending-Written              ReqToWriteDataSize
                //
                //                    FlushBuffer
                //         _____________________________________
                //        |   |                                |
                //        |   |                                |
                //        -------------------------------------
                //           |
                //           |
                //     InitialBuffStart(where pBuf starts in FlushBuffer)
                //        <---><------------------------------->
                //    Pending-Written   ReqToWriteDataSize
                //
                // For Condition 2 FlushBuffer would be a portion of pBuf:
                //             pBuf = pInitialBuf
                //    _________________________________
                //   |        |                       |
                //   |        |                       |
                //   ---------------------------------
                //            <----------------------->
                //            ReqTotalDataSize - Written
                //
                //               FlushBuffer
                //         _______________________
                //        |                      |
                //        |                      |
                //        -----------------------
                //        |
                //        |
                //     InitialBuffStart(at the very beginning)
                //        <--------------------->
                //      ReqTotalDataSize - Written
                //
                if (WrittenDataSize < pJobCancelInfo->FlushPendingDataSize)
                {
                    InitialBuffStart = pJobCancelInfo->FlushPendingDataSize - WrittenDataSize;
                    CopyMemory( pFlushBuffer ,
                                pJobCancelInfo->pSpool->pBuffer + WrittenDataSize,
                                InitialBuffStart);
                }

                CopyMemory(pFlushBuffer + InitialBuffStart ,
                           pJobCancelInfo->pInitialBuf + 
                           (InitialBuffStart ? 0 : WrittenDataSize - pJobCancelInfo->FlushPendingDataSize),
                           pJobCancelInfo->ReqTotalDataSize - WrittenDataSize - InitialBuffStart);

                FlushPrinter(pJobCancelInfo->pSpool,
                             pFlushBuffer,
                             pJobCancelInfo->ReqTotalDataSize - WrittenDataSize,
                             pJobCancelInfo->pcbWritten,
                             0);

                VirtualFree(pFlushBuffer,
                            (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize),
                            MEM_RELEASE);

                pJobCancelInfo->ReturnValue = TRUE;
                pJobCancelInfo->pSpool->Flushed = 1;
                if (*pJobCancelInfo->pcbWritten == (pJobCancelInfo->ReqTotalDataSize - WrittenDataSize))
                {
                    *pJobCancelInfo->pcTotalWritten+=pJobCancelInfo->ReqToWriteDataSize;
                }
            }
            else
            {
                DBGMSG(DBG_WARNING, ("JObCanceled::VirtualAlloc Failed to allocate 4k buffer %d\n",GetLastError()));
            }
        }
    }
    if (pJobCancelInfo->pSpool->Flushed)
    {
        pJobCancelInfo->pSpool->cbFlushPending = 0;
        pJobCancelInfo->pSpool->cbBuffer       = 0;
    }
    return pJobCancelInfo->ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines

Author:

    Dave Snipp (davesn)     01-Jun-1991

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LPWSTR InterfaceAddress = L"\\pipe\\spoolss";
handle_t GlobalBindHandle;

handle_t
PRINTER_HANDLE_bind (
    PRINTER_HANDLE   hPrinter)

/*++

Routine Description:

    This routine is used to obtain a binding to the printer spooler.

Arguments:

    Server - Supplies the name of the server where the printer spooler
        should be binded with.

Return Value:

    A binding to the server will be returned, unless an error occurs,
    in which case zero will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", 0, InterfaceAddress,
                       L"Security=Anonymous Static False", &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

    return(BindingHandle);
}


void
PRINTER_HANDLE_unbind (
    PRINTER_HANDLE hPrinter,
    handle_t       BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);

    return;
}

handle_t
STRING_HANDLE_bind (
    STRING_HANDLE  lpStr)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    lpStr - \\ServerName\PrinterName

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;
    WCHAR   ServerName[MAX_PATH+2];
    DWORD   i;

    if (lpStr && lpStr[0] == L'\\' && lpStr[1] == L'\\') {

        // We have a servername
        for (i = 2 ; lpStr[i] && lpStr[i] != L'\\' ; ++i)
            ;

        if (i >= COUNTOF(ServerName))
            return FALSE;
        
        wcsncpy(ServerName, lpStr, i);
        ServerName[i] = L'\0';

    } else

        return FALSE;

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", ServerName,
                                         InterfaceAddress,
                                         L"Security=Impersonation Static True",
                                         &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

    return(BindingHandle);
}


void
STRING_HANDLE_unbind (
    STRING_HANDLE  lpStr,
    handle_t    BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\wlkprn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    walkreg.cxx

Abstract:

    Printer data walking class definition.

Author:

    Adina Trufinescu (AdinaTru)  15-Oct-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "wlkprn.hxx"

#define gszWack TEXT("\\")

/*++

Title:

    WalkPrinterData::WalkPrinterData

Routine Description:

    Default constructor

Arguments:

    None

Return Value:

    None

--*/
WalkPrinterData::
WalkPrinterData(
    VOID
    )
{
    InitializeClassVariables();
}

/*++

Title:

    WalkPrinterData

Routine Description:

    class constructor

Arguments:

    pszPrinterName      -- printer name

    resource type       -- printer / server

    access type     -- converted to printer access flags

Return Value:

    Nothing

--*/

WalkPrinterData::
WalkPrinterData(
    IN TString&                         pszPrinterName,
    IN WalkPrinterData::EResourceType   eResourceType,
    IN WalkPrinterData::EAccessType     eAccessType
    )
{
    InitializeClassVariables();

    m_strPrnName.bUpdate( pszPrinterName );

    PRINTER_DEFAULTS Access = {0, 0, PrinterAccessFlags( eResourceType, eAccessType ) };

    //
    // Null string indicate the local server.
    //
    if(m_strPrnName.bValid())
    {
        if (OpenPrinter(const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strPrnName)), &m_hPrinter, &Access))
        {
            m_eAccessType = eAccessType;
        }
    }
}

/*++

Title:

    WalkPrinterData

Routine Description:

    constructor

Arguments:

    hPrinter -- handle to an open printer

Return Value:

    Nothing

--*/
WalkPrinterData::
WalkPrinterData(
    IN HANDLE       hPrinter
    )
{
    InitializeClassVariables();
    m_hPrinter          = hPrinter;
    m_bAcceptedHandle   = TRUE;
}

/*++

Title:

    Bind

Routine Description:

    late initialization

Arguments:

    hPrinter -- handle to an opened printer

Return Value:

    Nothing

--*/
VOID
WalkPrinterData::
BindToPrinter(
    IN HANDLE   hPrinter
    )
{
    m_hPrinter          = hPrinter;
    m_bAcceptedHandle   = TRUE;
}


/*++

Title:

    ~WalkPrinterData

Routine Description:

    class    destructor

Arguments:

    None

Return Value:

    Nothing

--*/
WalkPrinterData::
~WalkPrinterData(
    VOID
    )
{
    if( !m_bAcceptedHandle && m_hPrinter )
    {
        ClosePrinter(m_hPrinter);
    }
}


/*++

Title:

    bValid

Routine Description:

    Checks member initialisation

Arguments:

    None

Return Value:

    TRUE if valid m_hPrinter

--*/
BOOL
WalkPrinterData::
bValid(
    VOID
    ) const
{
    return m_hPrinter != INVALID_HANDLE_VALUE ;

}


/*++

Title:

    InitializeClassVariables

Routine Description:

    initialise class members

Arguments:

Return Value:

    VOID

Last Error:

--*/
VOID
WalkPrinterData::
InitializeClassVariables(
    VOID
    )
{
    m_strPrnName.bUpdate(NULL);

    m_hPrinter                  = NULL;
    m_eAccessType               = kAccessUnknown;
    m_bAcceptedHandle           = FALSE;
}

/*++

Title:

    PrinterAccessFlags

Routine Description:

    Convert class access flags to printer ACCESS_MASK

Arguments:

    resource type       -- printer / server

    access type     -- converted to printer access flags

Return Value:

    an access mask built upon eResourceType and eAccessType

--*/
ACCESS_MASK
WalkPrinterData::
PrinterAccessFlags(
    IN EResourceType   eResourceType,
    IN EAccessType     eAccessType
    ) const
{
    static const DWORD adwAccessPrinter[] =
    {
        PRINTER_ALL_ACCESS,
        PRINTER_READ  | PRINTER_WRITE,
        0,
    };

    static const DWORD adwAccessServer[] =
    {
        SERVER_ALL_ACCESS,
        SERVER_READ       | SERVER_WRITE,
        0,
    };

    DWORD   dwAccess    = 0;
    UINT    uAccessType = eAccessType > 3 ? 2 : eAccessType;

    switch( eResourceType )
    {
        case kResourceServer:
            dwAccess = adwAccessServer[uAccessType];
            break;

        case kResourcePrinter:
            dwAccess = adwAccessPrinter[uAccessType];
            break;

        case kResourceUnknown:
        default:
            break;
    }

    return dwAccess;
}



/*++

Title:  NextStrT

Routine Description:

    Returns next sz string in a multi zero string

Arguments:

    lpszStr - ptr to multi zero string

Return Value:

    pointer to zero string

--*/
LPTSTR
WalkPrinterData::
NextStrT(
    IN  LPCTSTR lpszStr
    )
{
    return const_cast<LPTSTR>(lpszStr) + (_tcslen(lpszStr) + 1);
}


/*++

Title:

    bHasSubKeys

Routine Description:

    Check if a Printer data key has subkeys

Arguments:

    strKey  -   key string

    mszSubKeys -    ptr to multi zero string

    must be checked at return time ; fnct can return TRUE and

    mszSubKeys == NULL -> has subkeys but couldn't allocate mszSubKeys

Return Value:

    TRUE if is has subkeys
    FALSE if has no sub keys

--*/
BOOL
WalkPrinterData::
bHasSubKeys(
    IN   TString&   strKey,
    OUT  LPTSTR*    mszSubKeys  //ORPHAN
    )
{
    DWORD       cbSize;
    TStatus     Status(DBG_WARN, ERROR_MORE_DATA);
    TStatusB    bStatus;

    bStatus DBGCHK =  bValid();

    if(bStatus)
    {
        //
        // Determine the size necessary for enumerating all the
        // sub-keys for this key.

        cbSize = 0;

        Status  DBGCHK = EnumPrinterKey(m_hPrinter, static_cast<LPCTSTR>(strKey), NULL, 0, &cbSize);

        //
        // If OK, then proceed to the enumeration.
        //
        if (cbSize && (Status == ERROR_MORE_DATA))
        {
            //
            // Allocate the space for retrieving the keys.
            //
            *mszSubKeys = reinterpret_cast<LPTSTR>( AllocMem(cbSize) );

            bStatus DBGCHK = (*mszSubKeys != NULL);

            if(bStatus)
            {
                //
                // Enumerate the sub-keys for this level in (lpszKey).
                //
                Status DBGCHK = EnumPrinterKey(m_hPrinter, static_cast<LPCTSTR>(strKey), *mszSubKeys, cbSize, &cbSize);

                bStatus DBGCHK = (Status == ERROR_SUCCESS);

                if(bStatus)
                {
                    goto End;
                }

                //
                // Free mszSubKeys if EnumPrinterKey fails
                //
                FreeMem(*mszSubKeys);
            }

        }
        else
        {
            bStatus DBGCHK = FALSE;
        }
    }

End:

    return bStatus;

}


/*++

Title:

    bInternalWalk

Routine Description:

    Walking function through printer data keys; calls Walk IN/POST/PRE for every key

Arguments:

    strKey  - key string

    lpcItems - number of keys walked through

Return Value:

    TRUE if is has subkeys

    FALSE if has no sub keys

--*/
BOOL
WalkPrinterData::
bInternalWalk (
    IN   TString& strKey,
    OUT  LPDWORD  lpcItems  OPTIONAL
    )
{
    LPTSTR          lpszSubKey;
    LPTSTR          mszSubKeys;
    TString         strFullSubKey;
    DWORD           cItems = 0;
    TStatusB        bStatus;

    *lpcItems = 0;

    if(bHasSubKeys(strKey, &mszSubKeys))
    {
        bStatus DBGCHK =  (mszSubKeys != NULL);

        if(bStatus)
        {
            //
            // Walk PRE before walking subkeys
            //
            bStatus DBGCHK = bWalkPre(strKey , &cItems);

            //
            // Browse subkeys multi zero string and call bInternalWalk for every subkey
            // this loop will won't execute if bWalkPre failed
            //
            for (lpszSubKey = mszSubKeys; *lpszSubKey && bStatus; )
            {
                //
                // Builds strSubKey and strFullKey
                //
                if(strKey.uLen() > 0)
                {
                    bStatus DBGCHK = strFullSubKey.bUpdate(strKey)  &&
                                     strFullSubKey.bCat(gszWack)    &&
                                     strFullSubKey.bCat(lpszSubKey);
                }
                else
                {
                    bStatus DBGCHK = strFullSubKey.bUpdate(lpszSubKey);
                }


                if(bStatus)
                {
                    bStatus DBGCHK = bInternalWalk(strFullSubKey, &cItems);
                    bStatus ? *lpcItems += cItems :  *lpcItems;
                    lpszSubKey = NextStrT(lpszSubKey);
                }

            }

           FreeMem(mszSubKeys);
        }

        if(bStatus)
        {
            //
            // Walk POST after walking all subkeys
            //
            bStatus DBGCHK = bWalkPost(strKey , &cItems);

            bStatus ? *lpcItems += cItems :  *lpcItems;
        }
    }
    else
    {
        //
        // Current key is not <directory> ,so walk IN!!!
        //
        bStatus DBGCHK = bWalkIn(strKey , &cItems);

        bStatus ? *lpcItems = cItems : *lpcItems;

    }

    return bStatus;
}



/*++

Title:

    bWalkPre

Routine Description:

    PRE walking

Arguments:

    strKey  -   key string

Return Value:

    TRUE

--*/
BOOL
WalkPrinterData::
bWalkPre(
    IN   TString&    strKey,
    OUT  LPDWORD     lpcItems
    )
{
    return TRUE;
}

/*++

Title:

    bWalkIn

Routine Description:

    IN walking

Arguments:

    strKey  -   key string

Return Value:

    TRUE

Last Error:

--*/
BOOL
WalkPrinterData::
bWalkIn (
    IN   TString&     str,
    OUT  LPDWORD      lpcItems
    )
{
    return TRUE;
}

/*++

Title:

    bWalkPost

Routine Description:

    POST walking

Arguments:

    strKey  -   key string

Return Value:

    TRUE

--*/
BOOL
WalkPrinterData::
bWalkPost (
    IN   TString&     strKey,
    OUT  LPDWORD      lpcItem
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\util.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Client Side Utility Routines


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

HANDLE hCSR = INVALID_HANDLE_VALUE;

BOOL
InCSRProcess(
    VOID
    )
{
    //
    // hCSR == INVALID_HANDLE_VALUE  Not initialized, must check.
    //         NULL                  Not running in CSR
    //         hModule value         Running in CSR
    //

    if (hCSR != NULL) {

        //
        // Check if we are running in CSR.  If so, then don't try
        // any notifications.
        //
        if (hCSR == INVALID_HANDLE_VALUE) {
            hCSR = GetModuleHandle( gszCSRDll );
        }
    }

    return hCSR != NULL;
}

LPVOID
DllAllocSplMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    PDWORD_PTR  pMem;
    DWORD    cbNew;

    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb+sizeof(DWORD_PTR)+sizeof(DWORD);

    pMem= LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        DBGMSG( DBG_WARNING, ("Memory Allocation failed for %d bytes\n", cbNew ));
        return 0;
    }

    *pMem=cb;
    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadbeef;

    return (LPVOID)(pMem+1);
}

BOOL
DllFreeSplMem(
   LPVOID pMem
)
{
    DWORD_PTR   cbNew;
    PDWORD_PTR pNewMem;

    if( !pMem ){
        return TRUE;
    }
    pNewMem = pMem;
    pNewMem--;

    cbNew = *pNewMem;

    if (*(LPDWORD)((LPBYTE)pMem + cbNew) != 0xdeadbeef) {
        DBGMSG(DBG_ERROR, ("DllFreeSplMem Corrupt Memory in winspool : %0p\n", pNewMem));
        return FALSE;
    }

    memset(pNewMem, 0x65, (size_t) cbNew);

    LocalFree((LPVOID)pNewMem);

    return TRUE;
}

LPVOID
ReallocSplMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocSplMem(cbNew);

    if (pOldMem && pNewMem) {

        if (cbOld) {
            CopyMemory( pNewMem, pOldMem, min(cbNew, cbOld));
        }
        FreeSplMem(pOldMem);
    }
    return pNewMem;
}

LPTSTR
AllocSplStr(
    LPCTSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPTSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = AllocSplMem( _tcslen(pStr)*sizeof(TCHAR) + sizeof(TCHAR) ))
      _tcscpy(pMem, pStr);

   return pMem;
}

BOOL
DllFreeSplStr(
   LPTSTR pStr
)
{
   return pStr ?
              DllFreeSplMem(pStr) :
              FALSE;
}

BOOL
ReallocSplStr(
   LPTSTR *ppStr,
   LPCTSTR pStr
)
{
    LPWSTR pOldStr = *ppStr;

    *ppStr=AllocSplStr(pStr);
    FreeSplStr(pOldStr);

    return TRUE;
}

/* Message
 *
 * Displays a message by loading the strings whose IDs are passed into
 * the function, and substituting the supplied variable argument list
 * using the varargs macros.
 *
 */
INT
Message(
    HWND    hwnd,
    DWORD   Type,
    INT     CaptionID,
    INT     TextID,
    ...
    )
{
    TCHAR MsgText[256];
    TCHAR MsgFormat[256];
    TCHAR MsgCaption[40];
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      COUNTOF(MsgFormat)) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption, COUNTOF(MsgCaption) ) > 0 ) )
    {
        va_start( vargs, TextID );
        wvsprintf( MsgText, MsgFormat, vargs );
        va_end( vargs );

        return MessageBox( hwnd, MsgText, MsgCaption, Type );
    }
    else
        return 0;
}

/*
 *
 */
LPTSTR
GetErrorString(
    DWORD   Error
)
{
    TCHAR   Buffer[1024];
    LPTSTR  pErrorString = NULL;
    DWORD   dwFlags;
    HANDLE  hModule;

    if ((Error >= NERR_BASE) && (Error <= MAX_NERR)){
        hModule = LoadLibrary(szNetMsgDll);
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;
    }
    else {
        hModule = NULL;
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;
    }

    if( FormatMessage( dwFlags, hModule,
                       Error, 0, Buffer,
                       COUNTOF(Buffer), NULL )
      == 0 )

        LoadString( hInst, IDS_UNKNOWN_ERROR, Buffer,
                    COUNTOF(Buffer));

    pErrorString = AllocSplStr(Buffer);

    if (hModule) {
        FreeLibrary(hModule);
    }

    return pErrorString;
}

DWORD ReportFailure( HWND  hwndParent,
                   DWORD idTitle,
                   DWORD idDefaultError )
{
    DWORD  ErrorID;
    DWORD  MsgType;
    LPTSTR pErrorString;

    ErrorID = GetLastError( );

    MsgType = MB_OK | MB_ICONSTOP;

    pErrorString = GetErrorString( ErrorID );

    Message( hwndParent, MsgType, idTitle,
             idDefaultError, pErrorString );

    FreeSplStr( pErrorString );


    return ErrorID;
}

/*
 *
 */
#define ENTRYFIELD_LENGTH      256
LPTSTR AllocDlgItemText(HWND hwnd, int id)
{
    TCHAR string[ENTRYFIELD_LENGTH];

    GetDlgItemText (hwnd, id, string, COUNTOF(string));
    return ( *string ? AllocSplStr(string) : NULL );
}

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
    )
/*++


--*/
{
    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   SDLength = 0;


    //
    // Initialize *pSizeSD = 0;
    //

    *pSizeSD = 0;
    if (!IsValidSecurityDescriptor(pPrinterSD)) {
        return(NULL);
    }
    if (!InitializeSecurityDescriptor (&AbsoluteSD, SECURITY_DESCRIPTOR_REVISION1)) {
        return(NULL);
    }

    if(!GetSecurityDescriptorOwner(pPrinterSD,
                                    &pOwnerSid, &Defaulted)){
        return(NULL);
    }
    SetSecurityDescriptorOwner(&AbsoluteSD,
                               pOwnerSid, Defaulted );

    if(! GetSecurityDescriptorGroup( pPrinterSD,
                                    &pGroupSid, &Defaulted )){
        return(NULL);
    }
    SetSecurityDescriptorGroup( &AbsoluteSD,
                                    pGroupSid, Defaulted );

    if(!GetSecurityDescriptorDacl( pPrinterSD,
                                   &DaclPresent, &pDacl, &Defaulted )){
        return(NULL);
    }

    SetSecurityDescriptorDacl( &AbsoluteSD,
                                   DaclPresent, pDacl, Defaulted );

    if(!GetSecurityDescriptorSacl( pPrinterSD,
                                   &SaclPresent, &pSacl, &Defaulted)){
        return(NULL);
    }
    SetSecurityDescriptorSacl( &AbsoluteSD,
                                 SaclPresent, pSacl, Defaulted );

    SDLength = GetSecurityDescriptorLength( &AbsoluteSD);
    pRelative = LocalAlloc(LPTR, SDLength);
    if (!pRelative) {
        return(NULL);
    }
    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &SDLength)) {
        LocalFree(pRelative);
        return(NULL);
    }

    *pSizeSD = SDLength;
    return(pRelative);
}


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    /* Scan through the string looking for commas,
     * ensuring that each is followed by a non-NULL character:
     */
    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +

         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocSplMem(cb)))
        return NULL;

    pResult->cb = cb;

    /* Initialise pDest to point beyond the token pointers:
     */
    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    /* Then copy the key data buffer there:
     */
    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;

    psz = pDest;

    do {

        *ppToken++ = psz;

        if ( psz = wcschr(psz, L',') )
            *psz++ = L'\0';

    } while (psz);

    pResult->cTokens = cTokens;

    return( pResult );
}


LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    )
{
    LPBYTE pMem;
    LPTSTR pPort;
    DWORD  dwPassed = 1024; //Try 1K to start with
    LPPRINTER_INFO_2 pPrinter;
    DWORD dwLevel = 2;
    DWORD dwNeeded;
    PKEYDATA pKeyData;
    DWORD i = 0;
    LPWSTR pPortNames = NULL;


    pMem = AllocSplMem(dwPassed);
    if (pMem == NULL) {
        return FALSE;
    }
    if (!GetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
        DBGMSG(DBG_TRACE, ("Last error is %d\n", GetLastError()));
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            return NULL;
        }
        pMem = ReallocSplMem(pMem, dwPassed, dwNeeded);
        dwPassed = dwNeeded;
        if (!GetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
            FreeSplMem(pMem);
            return (NULL);
        }
    }
    pPrinter = (LPPRINTER_INFO_2)pMem;

    //
    // Fixes the null pPrinter->pPortName problem where
    // downlevel may return null
    //

    if (!pPrinter->pPortName) {
        FreeSplMem(pMem);
        return(NULL);
    }

    pPortNames = AllocSplStr(pPrinter->pPortName);
    FreeSplMem(pMem);

    return(pPortNames);
}

BOOL
UpdateString(
    IN     LPCTSTR pszString,  OPTIONAL
       OUT LPTSTR* ppszOut
    )

/*++

Routine Description:

    Updates an output string if the input is non-NULL.

Arguments:

    pszString - String to update to.  If NULL or -1, function does nothing.

Return Value:

    TRUE - Success
    FALSE - FAILED.  *ppszOut = NULL

--*/

{
    if( pszString && pszString != (LPCTSTR)-1 ){

        FreeSplStr( *ppszOut );
        *ppszOut = AllocSplStr( pszString );

        if( !*ppszOut ){
            return FALSE;
        }
    }
    return TRUE;
}

DWORD
RouterFreeBidiResponseContainer(
    PBIDI_RESPONSE_CONTAINER pData
)
{
    BIDI_RESPONSE_DATA *p;
    DWORD              Count = 0;
    DWORD              NumOfRspns;
    DWORD              dwRet = ERROR_SUCCESS;

    try
    {
        if(pData)
        {
            Count = pData->Count;

            for(NumOfRspns= 0,
                p         = &pData->aData[0];

                NumOfRspns < Count;

                NumOfRspns++,
                p++
               )
            {
                if(p)
                {
                    if(p->pSchema)
                    {
                        MIDL_user_free(p->pSchema);
                    }

                    switch(p->data.dwBidiType)
                    {
                        //
                        // Text Data (ANSI String)
                        //
                        case BIDI_TEXT:
                        //
                        // String (UNICODE string)
                        //
                        case BIDI_ENUM:
                        //
                        // Enumeration Data (ANSI String)
                        //
                        case BIDI_STRING:
                        {
                            if(p->data.u.sData)
                            {
                                MIDL_user_free(p->data.u.sData);
                            }
                        }
                        break;

                        //
                        // Binary Data (BLOB)
                        //
                        case BIDI_BLOB:
                        {
                            if(p->data.u.biData.pData)
                            {
                                MIDL_user_free(p->data.u.biData.pData);
                            }
                        }
                        break;

                        //
                        // Undefined Type
                        //
                        default:
                        {
                            //
                            // Nothing really , just return
                            //
                        }
                        break;
                    }
                }
            }
            MIDL_user_free(pData);
        }
    }
    except(1)
    {
        dwRet = TranslateExceptionCode(GetExceptionCode());
        DBGMSG(DBG_ERROR, ("RouterFreeBidiResponseContainer raised an exception : %u \n", dwRet));
    }
    return(dwRet);
}

ClientVersion
GetClientVer()
{
    ClientVersion ClientVer;
    return(ClientVer = sizeof(ULONG_PTR));
}

ServerVersion
GetServerVer()
{
    ULONG_PTR       ul;
    NTSTATUS        st;
    ServerVersion   CurrVer;

    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &ul,
                                   sizeof(ul),
                                   NULL);
    if (NT_SUCCESS(st))
    {
        // If this call succeeds, we're on Win2000 or newer machines.
        if (0 != ul)
        {
            // 32-bit code running on Win64
            CurrVer = THUNKVERSION;
        } else
        {
            // 32-bit code running on Win2000 or later 32-bit OS
            CurrVer = NATIVEVERSION;
        }
    } else
    {
        CurrVer = NATIVEVERSION;
    }
    return(CurrVer);
}

BOOL
RunInWOW64()
{
    return((GetClientVer() == RUN32BINVER)  &&
           (GetServerVer() == THUNKVERSION) &&
           !bLoadedBySpooler);
    /*return(bLoadedBySpooler ? FALSE : TRUE);*/
}

HWND
GetForeGroundWindow(
    VOID
)
{
    //
    // get the foreground window first
    //
    HWND hWndOwner;
    HWND hWndLastPopup;
    HWND hWndForeground = GetForegroundWindow();
    //
    // climb up to the top parent in case it's a child window...
    //
    HWND hWndParent = hWndForeground;
    while ( hWndParent = GetParent(hWndParent) )
    {
        hWndForeground = hWndParent;
    }
    //
    // get the owner in case the top parent is owned
    //
    hWndOwner= GetWindow(hWndForeground, GW_OWNER);

    if ( hWndOwner )
    {
        hWndForeground = hWndOwner;
    }

    hWndLastPopup = GetLastActivePopup(hWndForeground);

    return(hWndLastPopup);
}

LPCWSTR
FindFileName(
    IN      LPCWSTR pPathName
    )
/*++

Routine Description:

    Retrieve the filename portion of a path.

    This will can the input string until it finds the last backslash,
    then return the portion of the string immediately following it.
    If the string terminates with a backslash, then NULL is returned.

    Note: this can return illegal file names; no validation is done.

Arguments:

    pPathName - Path name to parse.

Return Value:

    Last portion of file name or NULL if none available.

--*/

{
    LPCWSTR pSlash;
    LPCWSTR pTemp;

    if( !pPathName ){
       return NULL;
    }

    pTemp = pPathName;
    while( pSlash = wcschr( pTemp, L'\\' )) {
        pTemp = pSlash+1;
    }

    if( !*pTemp ){
       return NULL;
    }

    return pTemp;
}

/*++

Name:

    BuildSpoolerObjectPath

Description:

    This function addresses bug 461462. When the spooler is not running,
    this function can build the path to the drivers directory or the print 
    processors directory. The result of this function is a path like:
    C:\Windows\System32\spool\Drivers\w32x86
    or
    C:\Windows\System32\spool\Prtprocs\w32x86
    depending on the pszPath argument.
    
Arguments:

    pszPath          - can be "drivers" or "prtprocs"
    pszName          - must be NULL or ""
    pszEnvironment   - can be "windows nt x86" etc. This argument must be validated by the caller
                       (GetPrinterDriverDirectoryW and GetPrintProcessorDirectoryW)  
    Level            - must be 1
    pDriverDirectory - buffer where to store the path
    cbBuf            - count of bytes in the buffer
    pcbNeeded        - count of bytes needed to store the path


Return Value:

    TRUE - the function succeeded, pDriverDirectory can be used
    FALSE - the function failed, pDriverDirectory cannot be used.
    
Last error:

    This function sets the last error in both failure and success cases.    

--*/
BOOL
BuildSpoolerObjectPath(
    IN  PCWSTR  pszPath,
    IN  PCWSTR  pszName,
    IN  PCWSTR  pszEnvironment, 
    IN  DWORD   Level, 
    IN  PBYTE   pDriverDirectory, 
    IN  DWORD   cbBuf, 
    IN  PDWORD  pcbNeeded
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pcbNeeded && (!pszName || !*pszName))
    {
        HKEY  hkRoot = NULL;
        HKEY  hkEnv  = NULL;
        DWORD cchDir = MAX_PATH;
        WCHAR szDir[MAX_PATH];
        
        Error = GetSystemWindowsDirectory(szDir, cchDir) ? ERROR_SUCCESS : GetLastError();
        
        if (Error == ERROR_SUCCESS &&
            (Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                  gszRegEnvironments, 
                                  0, 
                                  KEY_READ, 
                                  &hkRoot)) == ERROR_SUCCESS &&
            (Error = RegOpenKeyEx(hkRoot, 
                                  pszEnvironment, 
                                  0, 
                                  KEY_READ, 
                                  &hkEnv)) == ERROR_SUCCESS &&
            (Error = StrNCatBuff(szDir,
                                 cchDir,
                                 szDir,
                                 szSlash,
                                 gszSystem32Spool,
                                 szSlash,
                                 pszPath,
                                 szSlash,
                                 NULL)) == ERROR_SUCCESS)
        {
            DWORD Length       = wcslen(szDir);
            DWORD cbAvailable  = (cchDir - Length) * sizeof(WCHAR);
            
            if ((Error = RegQueryValueEx(hkEnv, 
                                         gszEnivronmentDirectory, 
                                         NULL, 
                                         NULL, 
                                         (PBYTE)&szDir[Length], 
                                         &cbAvailable)) == ERROR_SUCCESS)
            {
                *pcbNeeded = (wcslen(szDir) + 1) * sizeof(WCHAR);

                if (cbBuf >= *pcbNeeded)
                {
                    wcscpy((PWSTR)pDriverDirectory, szDir);                    
                }
                else
                {
                    Error = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }
        else if (Error == ERROR_FILE_NOT_FOUND)
        {
            //
            // If we cannot open the "pszEnvironment" key then the environment is invalid.
            //
            Error = ERROR_INVALID_ENVIRONMENT;
        }

        if (hkRoot) RegCloseKey(hkRoot);
        if (hkEnv)  RegCloseKey(hkEnv);
    }

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles implementation for WaitForPrinterChange and related apis.

    FindFirstPrinterChangeNotification
    RouterFindNextPrinterChangeNotification
    FindClosePrinterChangeNotification

    Used by providors:

    ReplyPrinterChangeNotification  [Function Call]
    CallRouterFindFirstPrinterChangeNotification [Function Call]

Author:

    Albert Ting (AlbertT) 18-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntfytab.h>

#define PRINTER_NOTIFY_DEFAULT_POLLTIME 10000

CRITICAL_SECTION  RouterNotifySection;
PCHANGEINFO       pChangeInfoHead;
HANDLE            hEventPoll;


BOOL
SetupReplyNotification(
    PCHANGE pChange,
    DWORD fdwOptions,
    DWORD fdwStatus,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit);

BOOL
FindFirstPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent,
    BOOL bSpooler);

DWORD
FindClosePrinterChangeNotificationWorker(
    HANDLE hPrinter);

BOOL
SetupChange(
    PPRINTHANDLE pPrintHandle,
    DWORD dwPrinterRemote,
    LPWSTR pszLocalMachine,
    PDWORD pfdwStatus,
    DWORD fdwOptions,
    DWORD fdwFilterFlags,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT* pPrinterNotifyInit);

VOID
FailChange(
    PPRINTHANDLE pPrintHandle);

BOOL
RouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PPRINTER_NOTIFY_INFO* ppInfo);


BOOL
WPCInit()
{
    //
    // Create non-signaled, autoreset event.
    //
    hEventPoll = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!hEventPoll)
        return FALSE;

    __try {

        InitializeCriticalSection(&RouterNotifySection);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        SetLastError(GetExceptionCode());
        return FALSE;
    }            

    return TRUE;
}

VOID
WPCDestroy()
{
#if 0
    DeleteCriticalSection(&RouterNotifySection);
    CloseHandle(hEventPoll);
#endif
}





BOOL
RouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent)
{
    return FindFirstPrinterChangeNotificationWorker(
               hPrinter,
               fdwFilterFlags,
               fdwOptions,
               dwPID,
               pPrinterNotifyOptions,
               phEvent,
               FALSE);
}


BOOL
FindFirstPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent,
    BOOL bSpooler)

/*++

Routine Description:

    Sets up notification (coming from client side, winspool.drv).
    Create an event and duplicate it into the clients address
    space so we can communicate with it.

Arguments:

    hPrinter - Printer to watch

    fdwFilterFlags - Type of notification to set up (filter)

    fdwOptions - user specified option (GROUPING, etc.)

    dwPID - PID of the client process (needed to dup handle)

    phEvent - hEvent to pass back to the client.

    bSpooler - Indicates if called from spooler.  If TRUE, then we don't
               need to duplicate the event.

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    HANDLE hProcess;
    DWORD fdwStatus = 0;
    PCHANGE pChange = NULL;
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit = NULL;
    BOOL bReturn;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    EnterRouterSem();

    //
    // Clear this out
    //
    *phEvent = NULL;

    // Give a unique DWORD session ID for pPrintHandle
    while (pPrintHandle->dwUniqueSessionID == 0  ||
           pPrintHandle->dwUniqueSessionID == 0xffffffff) {

        pPrintHandle->dwUniqueSessionID = dwRouterUniqueSessionID++;
    }

    if (!SetupChange(pPrintHandle,
                     pPrintHandle->dwUniqueSessionID,
                     szMachineName,
                     &fdwStatus,
                     fdwOptions,
                     fdwFilterFlags,
                     pPrinterNotifyOptions,
                     &pPrinterNotifyInit)) {

        LeaveRouterSem();
        return FALSE;
    }

    //
    // !! LATER !!
    //
    // When Delegation is supported:
    //
    // Create the event with security access based on the impersonation
    // token so that we can filter out bogus notifications from
    // random people. (Save the token in the pSpool in localspl, then
    // impersonate before RPCing back here.  Then we can check if
    // we have access to the event.)
    //

    //
    // Create the event here that we trigger on notifications.
    // We will duplicate this event into the target client process.
    //
    pPrintHandle->pChange->hEvent = CreateEvent(
                                       NULL,
                                       TRUE,
                                       FALSE,
                                       NULL);

    if (!pPrintHandle->pChange->hEvent) {
        goto Fail;
    }

    if (bSpooler) {

        //
        // Client is in the spooler process.
        //
        *phEvent = pPrintHandle->pChange->hEvent;

    } else {

        //
        // Client is local.
        //

        //
        // Success, create pair
        //
        hProcess = OpenProcess(PROCESS_DUP_HANDLE,
                               FALSE,
                               dwPID);

        if (!hProcess) {
            goto Fail;
        }

        bReturn = DuplicateHandle(GetCurrentProcess(),
                                  pPrintHandle->pChange->hEvent,
                                  hProcess,
                                  phEvent,
                                  EVENT_ALL_ACCESS,
                                  TRUE,
                                  0);
        CloseHandle(hProcess);

        if (!bReturn) {
            goto Fail;
        }
    }

    bReturn = SetupReplyNotification(pPrintHandle->pChange,
                                     fdwStatus,
                                     fdwOptions,
                                     pPrinterNotifyOptions,
                                     pPrinterNotifyInit);

    if (bReturn) {

        pPrintHandle->pChange->eStatus &= ~STATUS_CHANGE_FORMING;
        pPrintHandle->pChange->eStatus |=
            STATUS_CHANGE_VALID|STATUS_CHANGE_CLIENT;

    } else {

Fail:
        if (pPrintHandle->pChange->hEvent)
            CloseHandle(pPrintHandle->pChange->hEvent);

        //
        // Local case must close handle twice since we may have
        // duplicated the event.
        //
        if (!bSpooler && *phEvent)
            CloseHandle(*phEvent);

        FailChange(pPrintHandle);
        bReturn = FALSE;
    }

    LeaveRouterSem();

    return bReturn;
}


BOOL
RemoteFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterRemote,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions)

/*++

Routine Description:

    Handles FFPCN coming from other machines.  Providers can use
    the ProvidorRemoteFFPCN call to initiate the RPC which this function
    handles.  This code ships the call to the print provider.  Note
    that we don't create any events here since the client is on
    a remote machine.

Arguments:

    hPrinter - printer to watch

    fdwFilterFlags - type of notification to watch

    fdwOptions -- options on watch

    pszLocalMachine - name of local machine that requested the watch

    dwPrinterRemote - remote Printer handle

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    BOOL bReturn;
    DWORD fdwStatus = 0;
    PCHANGE pChange = NULL;
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit = NULL;
    LPWSTR pszLocalMachineCopy;

    pszLocalMachineCopy = AllocSplStr(pszLocalMachine);

    if (!pszLocalMachineCopy)
        return FALSE;

    EnterRouterSem();

    if (!SetupChange(pPrintHandle,
                     dwPrinterRemote,
                     pszLocalMachineCopy,
                     &fdwStatus,
                     fdwOptions,
                     fdwFilterFlags,
                     pPrinterNotifyOptions,
                     &pPrinterNotifyInit)) {

        LeaveRouterSem();
        return FALSE;
    }

    bReturn = SetupReplyNotification(pPrintHandle->pChange,
                                     fdwStatus,
                                     fdwOptions,
                                     pPrinterNotifyOptions,
                                     pPrinterNotifyInit);

    if (bReturn) {

        pPrintHandle->pChange->eStatus = STATUS_CHANGE_VALID;

    } else {

        FailChange(pPrintHandle);
    }

    LeaveRouterSem();

    return bReturn;
}


BOOL
RouterFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    LPDWORD pfdwChangeFlags,
    PPRINTER_NOTIFY_OPTIONS pOptions,
    PPRINTER_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Return information about notification that just occurred and
    reset to look for more notifications.

Arguments:

    hPrinter - printer to reset event handle

    fdwFlags - flags (PRINTER_NOTIFY_NEXT_INFO)

    pfdwChange - return result of changes

    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions

    pReplyContainer - Reply info to pass out.

Return Value:

    BOOL

    ** NOTE **
    Always assume client process is on the same machine.  The client
    machine router always handles this call.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    PCHANGE pChange = pPrintHandle->pChange;
    BOOL bReturn = FALSE;

    if (ppInfo) {
        *ppInfo = NULL;
    }

    //
    // Currently only REFRESH option is defined.
    //
    if( pOptions && ( pOptions->Flags & ~PRINTER_NOTIFY_OPTIONS_REFRESH )){

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    EnterRouterSem();

    if (pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pChange ||
        !(pChange->eStatus & (STATUS_CHANGE_VALID|STATUS_CHANGE_CLIENT))) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    //
    // For now, we collapse all notifications into 1.
    //
    pChange->dwCount = 0;

    //
    // Tell the user what changes occurred,
    // then clear it out.
    //
    *pfdwChangeFlags = pChange->fdwChangeFlags;
    pChange->fdwChangeFlags = 0;

    ResetEvent(pChange->hEvent);

    if (pOptions && pOptions->Flags & PRINTER_NOTIFY_OPTIONS_REFRESH) {

        //
        // Increment color.
        //
        pPrintHandle->pChange->dwColor++;

        LeaveRouterSem();

        bReturn = RouterRefreshPrinterChangeNotification(
                      hPrinter,
                      pPrintHandle->pChange->dwColor,
                      pOptions,
                      ppInfo);

        return bReturn;
    }

    //
    // If they want data && (we have data || if we have flags that we wish
    // to send to the user), copy the data.
    //
    if( ppInfo &&
        (fdwFlags & PRINTER_NOTIFY_NEXT_INFO) &&
        NotifyNeeded( pChange )){

        *ppInfo = pChange->ChangeInfo.pPrinterNotifyInfo;
        pChange->ChangeInfo.pPrinterNotifyInfo = NULL;

        //
        // If we need to notify because of a DISCARD, but we don't
        // have a pPrinterNotifyInfo, then allocate one and return it.
        //
        if( !*ppInfo ){

            DBGMSG( DBG_TRACE,
                    ( "RFNPCN: Discard with no pPrinterNotifyInfo: pChange %x\n",
                      pChange ));

            //
            // We need to return some information back to the client, so
            // allocate a block that has zero items.  The header will be
            // marked as DISCARDED, which tells the user to refresh.
            //
            *ppInfo = RouterAllocPrinterNotifyInfo( 0 );

            if( !*ppInfo ){

                //
                // Failed to alloc memory; fail the call.
                //
                bReturn = FALSE;
                goto Done;
            }

            //
            // Mark the newly allocated information as DISCARDED.
            //
            (*ppInfo)->Flags = PRINTER_NOTIFY_INFO_DISCARDED;
        }
    }

    bReturn = TRUE;

Done:
    LeaveRouterSem();

    return bReturn;
}





BOOL
FindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    DWORD dwError;
    LPPRINTHANDLE pPrintHandle = (LPPRINTHANDLE)hPrinter;

    EnterRouterSem();

    if (pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange ||
        !(pPrintHandle->pChange->eStatus & STATUS_CHANGE_VALID)) {

        DBGMSG(DBG_WARN, ("FCPCNW: Invalid handle 0x%x\n", pPrintHandle));
        dwError = ERROR_INVALID_HANDLE;

    } else {

        dwError = FindClosePrinterChangeNotificationWorker(hPrinter);
    }

    LeaveRouterSem();

    if (dwError) {

        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}

DWORD
FindClosePrinterChangeNotificationWorker(
    HANDLE hPrinter)

/*++

Routine Description:

    Close a notification.

Arguments:

    hPrinter -- printer that we want to close

Return Value:

    ERROR code

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    BOOL bLocal = FALSE;
    HANDLE hNotifyRemote = NULL;
    DWORD dwError = ERROR_SUCCESS;

    DBGMSG(DBG_NOTIFY, ("FCPCN: Closing 0x%x ->pChange 0x%x\n",
                        pPrintHandle, pPrintHandle->pChange));

    RouterInSem();

    //
    // If the notification exists, shut it down (this is the
    // local case).  If we are called remotely, we don't need to
    // do this, since hEvent wasn't created.
    //
    if (pPrintHandle->pChange->eStatus & STATUS_CHANGE_CLIENT) {

        CloseHandle(pPrintHandle->pChange->hEvent);
        bLocal = TRUE;
    }

    //
    // Remember what the hNotifyRemote is, in case we want to delete it.
    //
    hNotifyRemote = pPrintHandle->pChange->hNotifyRemote;

    //
    // Failure to free implies we're using it now.  In this case,
    // don't try and free the hNotifyRemote.
    //
    if (!FreeChange(pPrintHandle->pChange)) {
        hNotifyRemote = NULL;
    }

    //
    // If local, don't allow new reply-s to be set up.
    //
    if (bLocal) {

        RemoveReplyClient(pPrintHandle,
                          REPLY_TYPE_NOTIFICATION);
    }


    //
    // We must zero this out to prevent other threads from
    // attempting to close this context handle (client side)
    // at the same time we are closing it.
    //
    pPrintHandle->pChange = NULL;

    if (!bLocal) {

        //
        // Remote case, shut down the notification handle if
        // there is one here.  (If there is a double hop, only
        // the second hop will have a notification reply.  Currently
        // only 1 hop is support during registration, however.)
        //
        LeaveRouterSem();

        CloseReplyRemote(hNotifyRemote);

        EnterRouterSem();
    }

    LeaveRouterSem();

    RouterOutSem();

    if (!(*pPrintHandle->pProvidor->PrintProvidor.
          fpFindClosePrinterChangeNotification) (pPrintHandle->hPrinter)) {

          dwError = GetLastError();
    }
    EnterRouterSem();

    return dwError;
}



BOOL
SetupReplyNotification(
    PCHANGE pChange,
    DWORD fdwStatus,
    DWORD fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT pPrinterNotifyInit)
{
    DWORD dwReturn = ERROR_SUCCESS;

    RouterInSem();

    if (!pChange) {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto Fail;
    }

    SPLASSERT(pChange->eStatus & STATUS_CHANGE_FORMING);

    if (fdwStatus & PRINTER_NOTIFY_STATUS_ENDPOINT) {

        //
        // For remote notification, we must setup a reply.
        //
        if (_wcsicmp(pChange->pszLocalMachine, szMachineName)) {

            LeaveRouterSem();

            dwReturn = OpenReplyRemote(pChange->pszLocalMachine,
                                       &pChange->hNotifyRemote,
                                       pChange->dwPrinterRemote,
                                       REPLY_TYPE_NOTIFICATION,
                                       0,
                                       NULL);

            EnterRouterSem();

            if (dwReturn)
                goto Fail;
        }

        //
        // The user can specify different status flags for the
        // notfication.  Process them here.
        //

        if (fdwStatus & PRINTER_NOTIFY_STATUS_POLL) {

            //
            // If there wasn't an error, then our reply notification
            // handle is valid, and we should do the polling.
            //
            pChange->ChangeInfo.dwPollTime =
                (pPrinterNotifyInit &&
                pPrinterNotifyInit->PollTime) ?
                    pPrinterNotifyInit->PollTime :
                    PRINTER_NOTIFY_DEFAULT_POLLTIME;

            pChange->ChangeInfo.dwPollTimeLeft = pChange->ChangeInfo.dwPollTime;

            //
            // Don't cause a poll the first time it's added.
            //
            pChange->ChangeInfo.bResetPollTime = TRUE;
            LinkAdd(&pChange->ChangeInfo.Link, (PLINK*)&pChangeInfoHead);

            SetEvent(hEventPoll);

        }
        pChange->ChangeInfo.fdwStatus = fdwStatus;

    } else {

        pChange->dwPrinterRemote = 0;
    }

    if (pPrinterNotifyOptions) {

        pChange->eStatus |= STATUS_CHANGE_INFO;
    }

Fail:
    if (dwReturn) {
        SetLastError(dwReturn);
        return FALSE;
    }

    return TRUE;
}



//
// The Reply* functions handle calls from the server back to the client,
// indicating that something changed.
//



BOOL
ReplyPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD dwColor,
    DWORD fdwChangeFlags,
    PDWORD pdwResult,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
    )

/*++

Routine Description:

    Notifies the client that something happened.  If local, simply
    set the event.  If remote, call ThreadNotify which spawns a thread
    to RPC to the client router.  (This call from the server -> client
    requires that the spooler pipe use the NULL session, since we
    are in local system context and RPC calls (with no impersonation)
    use the NULL session.)

Arguments:

    hPrinter -- printer that changed

    dwColor -- color time stamp of data

    fdwChangeFlags -- flags that changed

    pdwResult -- result flags (OPTIONAL)

    pPrinterNotifyInfo -- Notify info data.  Note that if this is NULL,
                          we don't set the DISCARDED flag.  This is different
                          than PartialRPN,

Return Value:

    BOOL  TRUE  = success
          FALSE = fail

--*/

{
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;
    PCHANGE pChange;
    BOOL bReturn = FALSE;

    EnterRouterSem();

    if (!pPrintHandle ||
        pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange ||
        !(pPrintHandle->pChange->eStatus & STATUS_CHANGE_VALID)) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    pChange = pPrintHandle->pChange;

    if (pdwResult) {
        *pdwResult = 0;
    }

    if (pChange->eStatus & STATUS_CHANGE_DISCARDED) {

        DBGMSG(DBG_WARNING,
               ("RPCNW: Discarded x%x, eStatus = 0x%x, pInfo = 0x%x\n",
                pChange,
                pChange->eStatus,
                pChange->ChangeInfo.pPrinterNotifyInfo));

        if (pdwResult && pPrinterNotifyInfo) {

            *pdwResult |= (PRINTER_NOTIFY_INFO_DISCARDED |
                          PRINTER_NOTIFY_INFO_DISCARDNOTED);
        }

        //
        // If the discard has already been noted, then we don't need
        // to notify the client.  If it hasn't been noted, we need to
        // trigger a notification, since the the client needs to refresh.
        //
        if (pChange->eStatus & STATUS_CHANGE_DISCARDNOTED) {
            bReturn = TRUE;
            goto Done;
        }
    }

    if (pChange->eStatus & STATUS_CHANGE_INFO && pPrinterNotifyInfo) {

        *pdwResult |= AppendPrinterNotifyInfo(pPrintHandle,
                                              dwColor,
                                              pPrinterNotifyInfo);

        //
        // AppendPrinterNotifyInfo will set the color mismatch
        // bit if the notification info is stale (doesn't match color).
        //
        if (*pdwResult & PRINTER_NOTIFY_INFO_COLORMISMATCH) {

            DBGMSG(DBG_WARNING, ("RPCN: Color mismatch; discarding\n"));

            bReturn = TRUE;
            goto Done;
        }
    }

    //
    // Store up the changes for querying later.
    //
    pChange->fdwChangeFlags |= fdwChangeFlags;

    //
    // Ensure that there is a valid notification waiting.
    // This is an optimization that avoids the case where the print
    // providor calls PartialRPCN several times, then is about to
    // call ReplyPCN.  Before it does this, we process the
    // the notification (either the client picks it up, or it rpcs
    // out to a remote router).  Suddenly we have no notification
    // data, so return instead of sending nothing.
    //
    if (!NotifyNeeded(pChange)) {

        bReturn = TRUE;
        goto Done;
    }

    //
    // Notify Here
    //
    // If this is the local machine, then just set the event and update.
    //
    if (pChange->eStatus & STATUS_CHANGE_CLIENT) {

        if (!pChange->hEvent ||
            pChange->hEvent == INVALID_HANDLE_VALUE) {

            DBGMSG(DBG_WARNING, ("ReplyNotify invalid event\n"));
            SetLastError(ERROR_INVALID_HANDLE);

            goto Done;
        }

        if (!SetEvent(pChange->hEvent)) {

            //
            // SetEvent failed!
            //
            DBGMSG(DBG_ERROR, ("ReplyNotify SetEvent Failed (ignore it!): Error %d.\n", GetLastError()));

            goto Done;
        }

        //
        // Keep count of notifications so that we return the correct
        // number of FNPCNs.
        //
        pChange->dwCount++;

        DBGMSG(DBG_NOTIFY, (">>>> Local trigger 0x%x\n", fdwChangeFlags));
        bReturn = TRUE;

    } else {

        //
        // Remote case.
        //
        // Note: pPrintHandle is invalid, since hNotify is valid only in the
        // client router address space.
        //

        DBGMSG(DBG_NOTIFY, ("*** Trigger remote event *** 0x%x\n",
                            pPrintHandle));

        bReturn = ThreadNotify(pPrintHandle);
    }

Done:
    LeaveRouterSem();
    return bReturn;
}


BOOL
FreeChange(
    PCHANGE pChange)

/*++

Routine Description:

    Frees the change structure.

Arguments:

Return Value:

    TRUE = Deleted
    FALSE = deferred.

NOTE: Assumes in Critical Section

--*/

{
    RouterInSem();

    //
    // Remove ourselves from the list if the providor wanted us
    // to send out polling notifications.
    //
    if (pChange->ChangeInfo.fdwStatus & PRINTER_NOTIFY_STATUS_POLL)
        LinkDelete(&pChange->ChangeInfo.Link, (PLINK*)&pChangeInfoHead);

    //
    // pPrintHandle should never refer to the pChange again.  This
    // ensures that the FreePrinterHandle only frees the pChange once.
    //
    if (pChange->ChangeInfo.pPrintHandle) {

        pChange->ChangeInfo.pPrintHandle->pChange = NULL;
        pChange->ChangeInfo.pPrintHandle = NULL;
    }

    if (pChange->cRef || pChange->eStatus & STATUS_CHANGE_FORMING) {

        pChange->eStatus |= STATUS_CHANGE_CLOSING;

        DBGMSG(DBG_NOTIFY, ("FreeChange: 0x%x in use: cRef = %d\n",
                            pChange,
                            pChange->cRef));
        return FALSE;
    }

    //
    // If the pszLocalMachine is ourselves, then don't free it,
    // since there's a single instance locally.
    //
    if (pChange->pszLocalMachine != szMachineName && pChange->pszLocalMachine)
        FreeSplStr(pChange->pszLocalMachine);

    if (pChange->ChangeInfo.pPrinterNotifyInfo) {

        RouterFreePrinterNotifyInfo(pChange->ChangeInfo.pPrinterNotifyInfo);
    }

    DBGMSG(DBG_NOTIFY, ("FreeChange: 0x%x ->pPrintHandle 0x%x\n",
                        pChange, pChange->ChangeInfo.pPrintHandle));

    FreeSplMem(pChange);

    return TRUE;
}


VOID
FreePrinterHandle(
    PPRINTHANDLE pPrintHandle
    )
{
    if( !pPrintHandle ){
        return;
    }

    EnterRouterSem();

    //
    // If on wait list, force wait list to free it.
    //
    if (pPrintHandle->pChange) {

        FreeChange(pPrintHandle->pChange);
    }

    //
    // Inform all notifys on this printer handle that they are gone.
    //
    FreePrinterHandleNotifys(pPrintHandle);

    LeaveRouterSem();

    DBGMSG(DBG_NOTIFY, ("FreePrinterHandle: 0x%x, pChange = 0x%x, pNotify = 0x%x\n",
                        pPrintHandle, pPrintHandle->pNotify,
                        pPrintHandle->pChange));

    // Log warning to detect handle free
    DBGMSG(DBG_TRACE, ("FreePrinterHandle: 0x%x\n", pPrintHandle));

    // Close tempfile handle, if any
    if (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE) {
        CloseHandle(pPrintHandle->hFileSpooler);
    }

    if (pPrintHandle->szTempSpoolFile) {

        if (!DeleteFile(pPrintHandle->szTempSpoolFile)) {

            MoveFileEx(pPrintHandle->szTempSpoolFile, NULL,
                       MOVEFILE_DELAY_UNTIL_REBOOT);
        }

        FreeSplMem(pPrintHandle->szTempSpoolFile);
        pPrintHandle->szTempSpoolFile = NULL;
    }

    FreeSplStr( pPrintHandle->pszPrinter );

    FreeSplMem( pPrintHandle );
}


VOID
HandlePollNotifications(
    VOID)

/*++

Routine Description:

    This handles the pulsing of notifications for any providor that wants
    to do polling.  It never returns.

Arguments:

    VOID

Return Value:

    VOID  (also never returns)

    NOTE: This thread should never exit, since hpmon uses this thread
          for initialization.  If this thread exists, certain services
          this thread initializes quit.

--*/

{
    HANDLE          hWaitObjects[1];
    PCHANGEINFO     pChangeInfo;
    DWORD           dwSleepTime = INFINITE, dwTimeElapsed, dwPreSleepTicks,
                    dwEvent;
    MSG             msg;

    hWaitObjects[0] = hEventPoll;


    while (TRUE) {

        dwPreSleepTicks = GetTickCount();

        dwEvent = MsgWaitForMultipleObjects(1,
                                            hWaitObjects,
                                            FALSE,
                                            dwSleepTime,
                                            QS_ALLEVENTS | QS_SENDMESSAGE);

        if ( dwEvent == WAIT_TIMEOUT ) {

            dwTimeElapsed = dwSleepTime;

        } else if ( dwEvent == WAIT_OBJECT_0 + 0 ) {

            dwTimeElapsed = GetTickCount() - dwPreSleepTicks;
        } else {

            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) ) {

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            continue;
        }

        EnterRouterSem();

        //
        // Initialize sleep time to INFINITY.
        //
        dwSleepTime = INFINITE;

        for (pChangeInfo = pChangeInfoHead;
            pChangeInfo;
            pChangeInfo = (PCHANGEINFO)pChangeInfo->Link.pNext) {

            //
            // If first time or a notification came in,
            // we just want to reset the time.
            //
            if (pChangeInfo->bResetPollTime) {

                pChangeInfo->dwPollTimeLeft = pChangeInfo->dwPollTime;
                pChangeInfo->bResetPollTime = FALSE;

            } else if (pChangeInfo->dwPollTimeLeft <= dwTimeElapsed) {

                //
                // Cause a notification.
                //
                ReplyPrinterChangeNotificationWorker(
                    pChangeInfo->pPrintHandle,
                    0,
                    pChangeInfo->fdwFilterFlags,
                    NULL,
                    NULL);

                pChangeInfo->dwPollTimeLeft = pChangeInfo->dwPollTime;

            } else {

                //
                // They've slept dwTimeElapsed, so take that off of
                // their dwPollTimeLeft.
                //
                pChangeInfo->dwPollTimeLeft -= dwTimeElapsed;
            }

            //
            // Now compute what is the least amout of time we wish
            // to sleep before the next guy should be woken up.
            //
            if (dwSleepTime > pChangeInfo->dwPollTimeLeft)
                dwSleepTime = pChangeInfo->dwPollTimeLeft;
        }

        LeaveRouterSem();
    }
}



BOOL
SetupChange(
    PPRINTHANDLE pPrintHandle,
    DWORD dwPrinterRemote,
    LPWSTR pszLocalMachine,
    PDWORD pfdwStatus,
    DWORD fdwOptions,
    DWORD fdwFilterFlags,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT* ppPrinterNotifyInit)

/*++

Routine Description:

    Sets up the pChange structure.  Validates the handle,
    then attempts to alloc it.

Arguments:

Return Value:

--*/

{
    PCHANGE pChange;
    BOOL bReturn;

    RouterInSem();

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pPrintHandle->pChange) {

        DBGMSG(DBG_ERROR, ("FFPCN: Already watching printer handle.\n"));

        //
        // Error: already watched
        //
        SetLastError(ERROR_ALREADY_WAITING);
        return FALSE;
    }

    pChange = AllocSplMem(sizeof(CHANGE));

    DBGMSG(DBG_NOTIFY, ("FFPCN pChange allocated 0x%x\n", pChange));

    if (!pChange) {

        //
        // Failed to allocate memory, quit.
        //
        return FALSE;
    }

    pPrintHandle->pChange = pChange;

    pChange->signature = CHANGEHANDLE_SIGNATURE;
    pChange->eStatus = STATUS_CHANGE_FORMING;
    pChange->ChangeInfo.pPrintHandle = pPrintHandle;
    pChange->ChangeInfo.fdwOptions = fdwOptions;

    //
    // Don't watch for Failed Connections.
    //
    pChange->ChangeInfo.fdwFilterFlags =
        fdwFilterFlags & ~PRINTER_CHANGE_FAILED_CONNECTION_PRINTER;

    pChange->dwPrinterRemote = dwPrinterRemote;
    pChange->pszLocalMachine = pszLocalMachine;

    //
    // As soon as we leave the critical section, pPrintHandle
    // may vanish!  If this is the case, out pChange->eStatus STATUS_CHANGE_CLOSING
    // bit will be set.
    //
    LeaveRouterSem();

    //
    // Once we leave the critical section, we are may try and
    // alter the notification.  To guard against this, we always
    // check eValid.
    //
    bReturn = (*pPrintHandle->pProvidor->PrintProvidor.
              fpFindFirstPrinterChangeNotification) (pPrintHandle->hPrinter,
                                                     fdwFilterFlags,
                                                     fdwOptions,
                                                     (HANDLE)pPrintHandle,
                                                     pfdwStatus,
                                                     pPrinterNotifyOptions,
                                                     ppPrinterNotifyInit);

    EnterRouterSem();

    //
    // On fail exit.
    //
    if (!bReturn) {

        pPrintHandle->pChange = NULL;

        if (pChange) {

            //
            // We no longer need to be saved, so change
            // eStatus to be 0.
            //
            pChange->eStatus = 0;
            DBGMSG(DBG_NOTIFY, ("FFPCN: Error %d, pChange deleting 0x%x %d\n",
                                GetLastError(),
                                pChange));

            FreeChange(pChange);
        }

        return FALSE;
    }

    return TRUE;
}

VOID
FailChange(
    PPRINTHANDLE pPrintHandle)
{
    LeaveRouterSem();

    //
    // Shut it down since we failed.
    //
    (*pPrintHandle->pProvidor->PrintProvidor.
    fpFindClosePrinterChangeNotification) (pPrintHandle->hPrinter);

    EnterRouterSem();

    //
    // We no longer need to be saved, so change
    // eStatus to be 0.
    //
    pPrintHandle->pChange->eStatus = 0;
    DBGMSG(DBG_NOTIFY, ("FFPCN: Error %d, pChange deleting 0x%x %d\n",
                        GetLastError(),
                        pPrintHandle->pChange));

    FreeChange(pPrintHandle->pChange);
}



/*------------------------------------------------------------------------

    Entry points for providors.

------------------------------------------------------------------------*/

BOOL
ProvidorFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    HANDLE hChange,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PPRINTER_NOTIFY_INIT* ppPrinterNotifyInit)

/*++

Routine Description:

    Handles any FFPCN that originates from a providor.
    Localspl does this when it wants to put a notification on a port.

Arguments:

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    BOOL bReturnValue;
    DWORD fdwStatus = 0;

    bReturnValue = (*pPrintHandle->pProvidor->PrintProvidor.
            fpFindFirstPrinterChangeNotification) (pPrintHandle->hPrinter,
                                                   fdwFilterFlags,
                                                   fdwOptions,
                                                   hChange,
                                                   &fdwStatus,
                                                   pPrinterNotifyOptions,
                                                   ppPrinterNotifyInit);

    if (bReturnValue) {

        //
        // !! LATER !! Check return value of SetupReply...
        //
        EnterRouterSem();

        SetupReplyNotification(((PPRINTHANDLE)hChange)->pChange,
                               fdwStatus,
                               fdwOptions,
                               pPrinterNotifyOptions,
                               ppPrinterNotifyInit ?
                                   *ppPrinterNotifyInit :
                                   NULL);

        LeaveRouterSem();
    }

    return bReturnValue;
}


DWORD
CallRouterFindFirstPrinterChangeNotification(
    HANDLE hPrinterRPC,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    HANDLE hPrinterLocal,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions)

/*++

Routine Description:

    This is called by providers if they want to pass a notification
    along to another machine.  This notification must originate from
    this machine but needs to be passed to another spooler.

Arguments:

    hPrinter - context handle to use for communication

    fdwFilterFlags - watch items

    fdwOptions - watch options

    hPrinterLocal - pPrinter structure valid in this address space,
                    and also is the sink for the notifications.

Return Value:

    Error code

--*/
{
    DWORD ReturnValue = 0;
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinterLocal;

    EnterRouterSem();

    BeginReplyClient(pPrintHandle,
                     REPLY_TYPE_NOTIFICATION);

    LeaveRouterSem();

    RpcTryExcept {

        ReturnValue = RpcRemoteFindFirstPrinterChangeNotificationEx(
                          hPrinterRPC,
                          fdwFilterFlags,
                          fdwOptions,
                          pPrintHandle->pChange->pszLocalMachine,
                          pPrintHandle->dwUniqueSessionID,
                          (PRPC_V2_NOTIFY_OPTIONS)pPrinterNotifyOptions);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        ReturnValue = RpcExceptionCode();

    } RpcEndExcept

    //
    // Talking to downlevel (Daytona) box.
    //
    if (ReturnValue == RPC_S_PROCNUM_OUT_OF_RANGE) {

        if (!pPrinterNotifyOptions) {

            RpcTryExcept {

                ReturnValue = RpcRemoteFindFirstPrinterChangeNotification(
                                  hPrinterRPC,
                                  fdwFilterFlags,
                                  fdwOptions,
                                  pPrintHandle->pChange->pszLocalMachine,
                                  pPrintHandle->dwUniqueSessionID,
                                  0,
                                  NULL);

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                ReturnValue = RpcExceptionCode();

            } RpcEndExcept
        }
    }

    EnterRouterSem();

    EndReplyClient(pPrintHandle,
                   REPLY_TYPE_NOTIFICATION);

    LeaveRouterSem();

    return ReturnValue;
}



BOOL
ProvidorFindClosePrinterChangeNotification(
    HANDLE hPrinter)

/*++

Routine Description:

    Handles any FCPCN that originates from a providor.
    Localspl does this when it wants to put a notification on a port.

Arguments:

Return Value:

    NOTE: Assumes a client notification was setup already.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    return  (*pPrintHandle->pProvidor->PrintProvidor.
            fpFindClosePrinterChangeNotification) (pPrintHandle->hPrinter);
}





/*------------------------------------------------------------------------

    Entry points for spooler components.

------------------------------------------------------------------------*/

BOOL
SpoolerFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    PHANDLE phEvent,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PVOID pvReserved)
{
    return FindFirstPrinterChangeNotificationWorker(
               hPrinter,
               fdwFilterFlags,
               fdwOptions,
               0,
               pPrinterNotifyOptions,
               phEvent,
               TRUE);
}


BOOL
SpoolerFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    LPDWORD pfdwChange,
    LPVOID pPrinterNotifyOptions,
    LPVOID *ppPrinterNotifyInfo)

/*++

Routine Description:

    Jump routine for FindNext for internal spooler components to use.

Arguments:

Return Value:

--*/

{
    BOOL bReturn;
    DWORD fdwFlags = 0;

    if (ppPrinterNotifyInfo) {

        fdwFlags = PRINTER_NOTIFY_NEXT_INFO;
    }

    bReturn = RouterFindNextPrinterChangeNotification(
                  hPrinter,
                  fdwFlags,
                  pfdwChange,
                  pPrinterNotifyOptions,
                  (PPRINTER_NOTIFY_INFO*)ppPrinterNotifyInfo);

    return bReturn;
}

VOID
SpoolerFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo)
{
    RouterFreePrinterNotifyInfo(pInfo);
}

BOOL
SpoolerFindClosePrinterChangeNotification(
    HANDLE hPrinter)

/*++

Routine Description:

    Jump routine for FindClose for internal spooler components to use.

Arguments:

Return Value:

--*/

{
    return FindClosePrinterChangeNotification(hPrinter);
}


#if DBG

VOID
EnterRouterSem()
{
    EnterCriticalSection(&RouterNotifySection);
}


VOID
LeaveRouterSem(
    VOID)
{
    if ((ULONG_PTR)RouterNotifySection.OwningThread != GetCurrentThreadId()) {
        DBGMSG(DBG_ERROR, ("Not in router semaphore\n"));
    }
    LeaveCriticalSection(&RouterNotifySection);
}

VOID
RouterInSem(
   VOID
)
{
    if ((ULONG_PTR)RouterNotifySection.OwningThread != GetCurrentThreadId()) {
        DBGMSG(DBG_ERROR, ("Not in spooler semaphore\n"));
    }
}

VOID
RouterOutSem(
   VOID
)
{
    if ((ULONG_PTR)RouterNotifySection.OwningThread == GetCurrentThreadId()) {
        DBGMSG(DBG_ERROR, ("Inside spooler semaphore !!\n"));
        SPLASSERT((ULONG_PTR)RouterNotifySection.OwningThread != GetCurrentThreadId());
    }
}

#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\clusspl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusspl.c

Abstract:

    Cluster code support.

Author:

    Albert Ting (AlbertT) 1-Oct-96

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "local.h"
#include "clusrout.h"

typedef struct _CLUSTERHANDLE {
    DWORD       signature;
    LPPROVIDOR  pProvidor;
    HANDLE      hCluster;
} CLUSTERHANDLE, *PCLUSTERHANDLE;


BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )

/*++

Routine Description:

    Open a hSpooler resource by searching the providers.

Arguments:

    pszServer - Server that should be opened.  Currently only NULL
        is supported.

    pszResource - Name of the resource to open.

    phSpooler - Receives new spooler handle.

    pszName - Name that the resource should recognize.  Comma delimted.

    pszAddress - Tcp/ip address the resource should recognize.  Comma delimited.

Return Value:

    TRUE - Success

    FALSE - Failure, GetLastError() set.

--*/

{
    LPPROVIDOR      pProvidor;
    DWORD           dwFirstSignificantError = ERROR_INVALID_NAME;
    PCLUSTERHANDLE  pClusterHandle;
    LPWSTR          pPrinterName;
    DWORD           dwStatus;
    HANDLE          hCluster;

    WaitForSpoolerInitialization();

    if( pszServer ){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pClusterHandle = AllocSplMem( sizeof( CLUSTERHANDLE ));

    if (!pClusterHandle) {

        DBGMSG( DBG_WARNING, ("Failed to alloc cluster handle."));
        return FALSE;
    }


    pProvidor = pLocalProvidor;
    *phSpooler = NULL;

    while (pProvidor) {

        dwStatus = (*pProvidor->PrintProvidor.fpClusterSplOpen)(
                       pszServer,
                       pszResource,
                       &hCluster,
                       pszName,
                       pszAddress);

        if ( dwStatus == ROUTER_SUCCESS ) {

            pClusterHandle->signature = CLUSTERHANDLE_SIGNATURE;
            pClusterHandle->pProvidor = pProvidor;
            pClusterHandle->hCluster = hCluster;

            *phSpooler = (HANDLE)pClusterHandle;
            return TRUE;

        } else {

            UpdateSignificantError( GetLastError(),
                                    &dwFirstSignificantError );
        }

        pProvidor = pProvidor->pNext;
    }

    FreeSplMem(pClusterHandle);

    UpdateSignificantError( ERROR_INVALID_PRINTER_NAME,
                            &dwFirstSignificantError );
    SetLastError(dwFirstSignificantError);

    return FALSE;
}

BOOL
ClusterSplClose(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Closes the spooler handle.

Arguments:

    hSpooler - hSpooler to close.

Return Value:

    TRUE - Success

    FALSE - Failure.  LastError set.

    Note: What happens if this fails?  Should the user try again.

--*/

{
    PCLUSTERHANDLE pClusterHandle=(PCLUSTERHANDLE)hSpooler;

    EnterRouterSem();

    if (!pClusterHandle ||
        pClusterHandle->signature != CLUSTERHANDLE_SIGNATURE) {

        LeaveRouterSem();
        SetLastError(ERROR_INVALID_HANDLE);

        return FALSE;
    }

    LeaveRouterSem();

    if ((*pClusterHandle->pProvidor->PrintProvidor.fpClusterSplClose)(
              pClusterHandle->hCluster)) {

        FreeSplMem( pClusterHandle );
        return TRUE;
    }

    return FALSE;
}

BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Determines whether the spooler is alive.

Arguments:

    hSpooler - Spooler to check.

Return Value:

    TRUE - Alive

    FALSE - Dead, LastError set.

--*/


{
    PCLUSTERHANDLE pClusterHandle=(PCLUSTERHANDLE)hSpooler;

    if (!pClusterHandle ||
        pClusterHandle->signature != CLUSTERHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pClusterHandle->pProvidor->PrintProvidor.fpClusterSplIsAlive)(
                 pClusterHandle->hCluster );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\info.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    info.c

Abstract:

    Handles marshalling support for notifications.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntfytab.h>
#include <stddef.h>

#define PRINTER_STRINGS
#include <data.h>

#define DEFINE(field, attrib, table, x, y) { attrib, table },

NOTIFY_ATTRIB_TABLE NotifyAttribPrinter[] = {
#include "ntfyprn.h"
};

NOTIFY_ATTRIB_TABLE NotifyAttribJob[] = {
#include "ntfyjob.h"
};
#undef DEFINE

PNOTIFY_ATTRIB_TABLE pNotifyAttribTable[] = {
    NotifyAttribPrinter,
    NotifyAttribJob
};

DWORD adwNotifyAttribMax[] = {
    COUNTOF(NotifyAttribPrinter),
    COUNTOF(NotifyAttribJob)
};

DWORD adwNotifyDatatypes[] = NOTIFY_DATATYPES;
extern DWORD cDefaultPrinterNotifyInfoData;

//
// Forward prototypes.
//

PPRINTER_NOTIFY_INFO
RouterAllocPrinterNotifyInfo(
    DWORD cPrinterNotifyInfoData)
{
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo;

    if (!cPrinterNotifyInfoData)
        cPrinterNotifyInfoData = cDefaultPrinterNotifyInfoData;

    pPrinterNotifyInfo = MIDL_user_allocate(
                             sizeof(*pPrinterNotifyInfo) -
                             sizeof(pPrinterNotifyInfo->aData) +
                             cPrinterNotifyInfoData *
                                sizeof(PRINTER_NOTIFY_INFO_DATA));

    //
    // Must initialize version/count.
    //
    if (pPrinterNotifyInfo != NULL) {
        pPrinterNotifyInfo->Version = NOTIFICATION_VERSION;
        pPrinterNotifyInfo->Count = 0;

        if (pPrinterNotifyInfo) {

            ClearPrinterNotifyInfo(pPrinterNotifyInfo, NULL);
        }
    }
    return pPrinterNotifyInfo;
}

VOID
SetupPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange)
{
    //
    // Set the color flag.
    //
    pInfo->Flags |= PRINTER_NOTIFY_INFO_COLORSET;

    //
    // We should set the discard bit if there was a previous overflow
    // and we didn't or couldn't allocate a pInfo structure.
    // Do it now.
    //
    if (pChange && pChange->eStatus & STATUS_CHANGE_DISCARDED) {

        pInfo->Flags |= PRINTER_NOTIFY_INFO_DISCARDED;
    }
}


BOOL
FreePrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfo)
{
    DWORD i;
    PPRINTER_NOTIFY_INFO_DATA pData;

    for(pData = pInfo->aData, i=pInfo->Count;
        i;
        pData++, i--) {

        if ((TABLE)pData->Reserved != TABLE_DWORD) {

            MIDL_user_free(pData->NotifyData.Data.pBuf);
        }
    }
    return TRUE;
}



BOOL
RouterFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo)
{
    if (!pInfo) {

        DBGMSG(DBG_WARNING, ("RFreePrinterNotifyInfo called with NULL!\n"));
        return FALSE;
    }

    FreePrinterNotifyInfoData(pInfo);

    MIDL_user_free(pInfo);
    return TRUE;
}



VOID
ClearPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange)

/*++

Routine Description:

    Clears the PRINTER_NOTIFY structure for more notifications.

Arguments:

    pInfo - Info to clear ( pInfo->aData must be valid if pInfo->Count != 0 )

    pChange - Associated pChange structure.

Return Value:

--*/

{
    if (!pInfo)
        return;

    FreePrinterNotifyInfoData(pInfo);

    pInfo->Flags = 0;
    pInfo->Count = 0;

    if (pChange)
        SetupPrinterNotifyInfo(pInfo, pChange);
}


VOID
SetDiscardPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange)
{
    if (pInfo) {

        FreePrinterNotifyInfoData(pInfo);

        pInfo->Count = 0;
        pInfo->Flags |= PRINTER_NOTIFY_INFO_DISCARDED;
    }

    if (pChange)
        pChange->eStatus |= STATUS_CHANGE_DISCARDED;
}


DWORD
AppendPrinterNotifyInfo(
    PPRINTHANDLE pPrintHandle,
    DWORD dwColor,
    PPRINTER_NOTIFY_INFO pInfoSrc)

/*++

Routine Description:

    Appends pInfoSrc to the pPrintHandle.  We may get Src with zero
    notifications.  This occurs when when the user requests a refresh
    and the client spooler synchronously replies back to clear out
    everything.

Arguments:

    pPrintHandle -- handle to update

    pInfoSrc -- Source of info.  NULL = no info.

Return Value:

    Result of action.

--*/

{
    PPRINTER_NOTIFY_INFO pInfoDest;
    PCHANGE pChange;
    PPRINTER_NOTIFY_INFO_DATA pDataSrc;

    DWORD i;

    pChange = pPrintHandle->pChange;
    pInfoDest = pChange->ChangeInfo.pPrinterNotifyInfo;


    //
    // May be NULL if RPCing and the buffer is being used.
    // The worker thread will free the data.
    //
    if (!pInfoDest) {

        pInfoDest = RouterAllocPrinterNotifyInfo(0);

        if (!pInfoDest) {

            DBGMSG(DBG_WARNING,
                   ("AppendPrinterNotifyInfo: Alloc fail, Can't set DISCARD\n"));

            goto Discard;
        }

        SetupPrinterNotifyInfo(pInfoDest, pChange);
        pChange->ChangeInfo.pPrinterNotifyInfo = pInfoDest;
    }


    if (!pInfoSrc) {
        return 0;
    }


    //
    // We must handle the case where the user requests and receives
    // a refresh, but the there was an outstanding RPC that is just
    // now being processed.  In this case, we must drop this
    // notification.  We determine this by maintaining a color value.
    //
    // Note that we can't return the DISCARDNOTED flag, since this can't
    // trigger an overflow.
    //
    // If (Color is set) AND (NOT color same) fail.
    //
    if (pInfoSrc->Flags & PRINTER_NOTIFY_INFO_COLORSET) {

        if (dwColor != pChange->dwColor) {

            DBGMSG(DBG_WARNING, ("AppendPrinterNotifyInfo: Color mismatch info %d != %d; discard\n",
                                 dwColor, pChange->dwColor));
            //
            // Clear it out, and we're done.
            //
            ClearPrinterNotifyInfo(pInfoDest,
                                   pChange);

            return PRINTER_NOTIFY_INFO_COLORMISMATCH;
        }
    }

    //
    // OR in the flags.
    //
    pInfoDest->Flags |= pInfoSrc->Flags;

    //
    // Check for overflow.
    //
    if (pInfoSrc->Count + pInfoDest->Count < cDefaultPrinterNotifyInfoData) {

        //
        // Now copy everything over.
        //
        for (pDataSrc = pInfoSrc->aData, i = pInfoSrc->Count;
            i;
            i--, pDataSrc++) {

            AppendPrinterNotifyInfoData(
                pInfoDest,
                pDataSrc,
                PRINTER_NOTIFY_INFO_DATA_COMPACT);
        }
    } else {

Discard:
        SetDiscardPrinterNotifyInfo(pInfoDest, pChange);

        return PRINTER_NOTIFY_INFO_DISCARDED |
               PRINTER_NOTIFY_INFO_DISCARDNOTED;
    }
    return 0;
}


BOOL
AppendPrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfoDest,
    PPRINTER_NOTIFY_INFO_DATA pDataSrc,
    DWORD fdwFlags)

/*++

Routine Description:

    Append the data to the pInfoDest.  If pDataSrc is NULL, set discard.

Arguments:

Return Value:

--*/

{
    PPRINTER_NOTIFY_INFO_DATA pDataDest;
    DWORD i;
    BOOL bCompact = FALSE;
    DWORD Count;
    PPRINTER_NOTIFY_INFO_DATA pDataNew;
    BOOL bNewSlot = TRUE;

    DWORD Type;
    DWORD Field;
    DWORD Table;
    DWORD Id;

    EnterRouterSem();

    if (!pDataSrc || (pInfoDest->Flags & PRINTER_NOTIFY_INFO_DISCARDED)) {

        SetLastError(ERROR_OUT_OF_STRUCTURES);
        goto DoDiscard;
    }

    Type = pDataSrc->Type;
    Field = pDataSrc->Field;
    Table = pDataSrc->Reserved;
    Id = pDataSrc->Id;

    //
    // Validate this is a correct type.
    //
    if (Type < NOTIFY_TYPE_MAX && Field < adwNotifyAttribMax[Type]) {

        //
        // If Table == 0, then the caller did not specify the type,
        // so we fill it in as appropriate.
        //
        // If it is non-zero and it's doesn't match our value, then
        // return an error.
        //
        if (Table != pNotifyAttribTable[Type][Field].Table) {

            if (Table) {

                //
                // The specified table type does not match our table
                // type.  Punt, since we can't marshall.
                //
                DBGMSG(DBG_WARNING, ("Table = %d, != Type %d /Field %d!\n",
                                     Table, Field, Type));

                SetLastError(ERROR_INVALID_PARAMETER);
                goto DoDiscard;
            }

            //
            // Fix up the Table entry.
            //
            Table = pNotifyAttribTable[Type][Field].Table;
            pDataSrc->Reserved = (TABLE)Table;
        }

        bCompact = (fdwFlags & PRINTER_NOTIFY_INFO_DATA_COMPACT) &&
                   (pNotifyAttribTable[Type][Field].Attrib &
                       TABLE_ATTRIB_COMPACT);
    } else {

        //
        // This is not an error case, since we can still marshall fields
        // we don't know about as long as the Table is valid.
        //
        DBGMSG(DBG_WARNING, ("Unknown: Type= %d Field= %d!\n", Type, Field));
    }

    if (!Table || Table >= COUNTOF(adwNotifyDatatypes)) {

        DBGMSG(DBG_WARNING, ("Table %d unknown; can't marshall!\n",
                             Table));

        SetLastError(ERROR_INVALID_PARAMETER);
        goto DoDiscard;
    }

    SPLASSERT(Table);

    //
    // Check if compactable.
    //
    if (bCompact) {

        //
        // We can compact, see if there is a match.
        //
        for (pDataDest = pInfoDest->aData, i = pInfoDest->Count;
            i;
            pDataDest++, i--) {

            if (Type == pDataDest->Type &&
                Field == pDataDest->Field &&
                Id == pDataDest->Id) {

                if (Table == TABLE_DWORD) {

                    pDataDest->NotifyData.adwData[0] =
                        pDataSrc->NotifyData.adwData[0];

                    pDataDest->NotifyData.adwData[1] =
                        pDataSrc->NotifyData.adwData[1];

                    goto Done;
                }

                //
                // Must copy the data, so free the old one.
                //
                MIDL_user_free(pDataDest->NotifyData.Data.pBuf);

                bNewSlot = FALSE;
                break;
            }
        }

        //
        // pDataDest now points to the correct slot (either end or
        // somewhere in the middle if we are compacting.
        //

    } else {

        //
        // Slot defaults to the end.
        //
        pDataDest = &pInfoDest->aData[pInfoDest->Count];
    }


    //
    // Copy structure first
    //
    *pDataDest = *pDataSrc;

    //
    // The data may be either a pointer or the actual DWORD data.
    //
    if (adwNotifyDatatypes[Table] & TABLE_ATTRIB_DATA_PTR) {

        DWORD cbData = pDataSrc->NotifyData.Data.cbBuf;

        //
        // Now copy everything over.
        //
        pDataNew = (PPRINTER_NOTIFY_INFO_DATA)MIDL_user_allocate(cbData);

        if (!pDataNew) {

            pDataDest->NotifyData.Data.pBuf = NULL;
            DBGMSG( DBG_WARNING, ("Alloc %d bytes failed with %d\n",
                                  GetLastError()));
            goto DoDiscard;
        }

        CopyMemory(pDataNew, pDataSrc->NotifyData.Data.pBuf, cbData);

        pDataDest->NotifyData.Data.cbBuf = cbData;
        pDataDest->NotifyData.Data.pBuf = pDataNew;
    }

    //
    // Increment if necessary.
    //
    if (bNewSlot)
        pInfoDest->Count++;

Done:

    LeaveRouterSem();
    return TRUE;

DoDiscard:

    SetDiscardPrinterNotifyInfo(pInfoDest, NULL);
    LeaveRouterSem();

    return FALSE;
}


BOOL
RouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PPRINTER_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Implements the refresh portion of FindNextPrinterChangeNotification.

Arguments:

Return Value:

--*/

{
    PPRINTHANDLE pPrintHandle = (PPRINTHANDLE)hPrinter;
    BOOL bReturn;

    EnterRouterSem();

    if (!pPrintHandle ||
        pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange ||
        !(pPrintHandle->pChange->eStatus & (STATUS_CHANGE_VALID |
                                            STATUS_CHANGE_INFO))) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Fail;
    }

    if (!pPrintHandle->pProvidor->PrintProvidor.fpRefreshPrinterChangeNotification) {

        SetLastError(RPC_S_PROCNUM_OUT_OF_RANGE);
        goto Fail;
    }

    pPrintHandle->pChange->dwColor = dwColor;

    //
    // Allow notifications to begin again.
    //
    pPrintHandle->pChange->eStatus &= ~(STATUS_CHANGE_DISCARDED |
                                        STATUS_CHANGE_DISCARDNOTED);

    ClearPrinterNotifyInfo(pPrintHandle->pChange->ChangeInfo.pPrinterNotifyInfo,
                           pPrintHandle->pChange);

    LeaveRouterSem();

    bReturn = (*pPrintHandle->pProvidor->PrintProvidor.fpRefreshPrinterChangeNotification)(
                  pPrintHandle->hPrinter,
                  pPrintHandle->pChange->dwColor,
                  pPrinterNotifyRefresh,
                  ppInfo);

    //
    // On failure, set discard.
    //
    if (!bReturn) {

        EnterRouterSem();

        //
        // The handle should be valid since RPC guarentees that context
        // handle access is serialized.  However, a misbehaved
        // multithreaded spooler component could cause this to happen.
        //
        SPLASSERT(pPrintHandle->signature == PRINTHANDLE_SIGNATURE);

        if (pPrintHandle->pChange) {

            //
            // Disallow notifications since the refresh failed.
            //
            pPrintHandle->pChange->eStatus |= STATUS_CHANGE_DISCARDED;
        }

        LeaveRouterSem();
    }

    return bReturn;

Fail:
    LeaveRouterSem();
    return FALSE;
}



BOOL
NotifyNeeded(
    PCHANGE pChange)
{
    register PPRINTER_NOTIFY_INFO pInfo;

    pInfo = pChange->ChangeInfo.pPrinterNotifyInfo;

    if (pChange->eStatus & STATUS_CHANGE_DISCARDNOTED) {
        return FALSE;
    }

    if (pChange->fdwChangeFlags || pChange->eStatus & STATUS_CHANGE_DISCARDED) {
        return TRUE;
    }

    if (!pInfo) {
        return FALSE;
    }

    if (pInfo->Flags & PRINTER_NOTIFY_INFO_DISCARDED || pInfo->Count) {
        return TRUE;
    }
    return FALSE;
}


/*------------------------------------------------------------------------

    Entry points for providors.

------------------------------------------------------------------------*/


BOOL
ReplyPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwChangeFlags,
    PDWORD pdwResult,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
    )

/*++

Routine Description:

    Updates a notification with an entire pPrinterNotifyInfo packet.
    Providers can call PartialRPCN several times with small packets (the
    router won't send them until ReplyPrinterChangeNotification is sent).
    This allows batching and guarentees atmoic notifications.

Arguments:

    hPrinter - Handle that is being watched.

    fdwChangeFlags - Flags that changed (WPC type flags for compatibility)

    pdwResult - Result of changes (OPTIONAL).  Indicates whether changes
        were discarded, and if the discard was noted.

    pPrinterNotifyInfo - Information about change.

Return Value:

    TRUE - success
    FALSE - failure, call GetLastError().

--*/

{
    return ReplyPrinterChangeNotificationWorker(
               hPrinter,
               0,
               fdwChangeFlags,
               pdwResult,
               pPrinterNotifyInfo);
}


BOOL
PartialReplyPrinterChangeNotification(
    HANDLE hPrinter,
    PPRINTER_NOTIFY_INFO_DATA pDataSrc
    )

/*++

Routine Description:

    Updates the notify info without triggering a notification.  This is
    used to send multiple infos without rpcing on each one.  Do a
    ReplyPrinterChangeNotificiation at the end.

Arguments:

    hPrinter -- Printer handle that changed.

    pDataSrc -- Partial data to store.  If NULL, indicates a discard
        should be stored, causing the client to refresh.

Return Value:

--*/

{
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;
    BOOL bReturn = FALSE;
    PPRINTER_NOTIFY_INFO* ppInfoDest;

    EnterRouterSem();

    if (!pPrintHandle ||
        pPrintHandle->signature != PRINTHANDLE_SIGNATURE ||
        !pPrintHandle->pChange) {

        DBGMSG(DBG_WARNING, ("PartialRPCN: Invalid handle 0x%x!\n",
                             hPrinter));
        SetLastError(ERROR_INVALID_HANDLE);
        goto Fail;
    }

    if (!(pPrintHandle->pChange->eStatus &
        (STATUS_CHANGE_VALID|STATUS_CHANGE_INFO))) {

        DBGMSG(DBG_WARNING, ("PartialRPCN: Invalid handle 0x%x state = 0x%x!\n",
                             hPrinter,
                             pPrintHandle->pChange->eStatus));

        SetLastError(ERROR_INVALID_HANDLE);
        goto Fail;
    }

    ppInfoDest = &pPrintHandle->pChange->ChangeInfo.pPrinterNotifyInfo;

    if (!pDataSrc) {

        bReturn = TRUE;
        goto Discard;
    }

    //
    // May be NULL if RPCing and the buffer is being used.
    // The worker thread will free the data.
    //
    if (!*ppInfoDest) {

        *ppInfoDest = RouterAllocPrinterNotifyInfo(0);

        if (!*ppInfoDest) {

            DBGMSG(DBG_WARNING,
                   ("PartialReplyPCN: Alloc failed, discarding\n"));

            //
            // We should set the discard flag here, but we can't,
            // so punt.
            //
            goto Discard;
        }

        SetupPrinterNotifyInfo(*ppInfoDest, pPrintHandle->pChange);
    }

    //
    // Check that we have enough space for the current data.
    //
    if ((*ppInfoDest)->Count < cDefaultPrinterNotifyInfoData) {

        bReturn = AppendPrinterNotifyInfoData(
                      *ppInfoDest,
                      pDataSrc,
                      PRINTER_NOTIFY_INFO_DATA_COMPACT);
    } else {

        SetLastError(ERROR_OUT_OF_STRUCTURES);

Discard:
        SetDiscardPrinterNotifyInfo(*ppInfoDest, pPrintHandle->pChange);
    }

Fail:
    LeaveRouterSem();
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\devmode.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved

Module Name:

    devmode.c

Abstract:

    Handles per-user devmode implementation.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"
#include <offsets.h>

/********************************************************************

    Forward prototypes

********************************************************************/

BOOL
bGetDevModeLocation(
    IN HKEY hKeyUser, OPTIONAL
    IN LPCWSTR pszPrinter,
    OUT PHKEY phKey,
    OUT LPCWSTR *ppszValue
    );


const WCHAR gszPrinterConnections[] = L"Printers\\Connections\\";
const WCHAR gszDevMode[] = L"DevMode";
const WCHAR gszDevModePerUserLocal[] = L"Printers\\DevModePerUser";

/********************************************************************

    Private  Functions

********************************************************************/


DWORD
RegOpenConnectionKey(
    HKEY hKeyUser,
    LPWSTR pszPrinter,
    PHKEY phKey
    )
{
    PWCHAR pszPrinterScratch = NULL;
    DWORD  dwRetValue        = ERROR_SUCCESS;
    DWORD  cchSize           = MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX + COUNTOF( gszPrinterConnections );

    if (pszPrinter &&
        wcslen(pszPrinter) < MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX) {

        if (pszPrinterScratch = AllocSplMem(cchSize * sizeof(WCHAR))) {

            wcscpy(pszPrinterScratch, gszPrinterConnections);

            FormatPrinterForRegistryKey(pszPrinter,
                                        &pszPrinterScratch[ COUNTOF( gszPrinterConnections )-1] );

            dwRetValue = RegOpenKeyEx(hKeyUser,
                                      pszPrinterScratch,
                                      0,
                                      KEY_READ | KEY_WRITE,
                                      phKey );

            FreeSplMem(pszPrinterScratch);

        } else {

            dwRetValue = GetLastError();
        }

    } else {

        dwRetValue = ERROR_INVALID_PARAMETER;
    }

    return dwRetValue;
}


/********************************************************************

    Public functions

********************************************************************/

BOOL
bSetDevModePerUser(
    HANDLE hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE pDevMode
    )

/*++

Routine Description:

    Sets the per-user DevMode in HKCU.

Arguments:

    hKeyUser - HKEY_CURRENT_USER handle.  OPTIONAL

    pszPrinter - Printer to set.

    pDevMode - DevMode to save.  If NULL, deletes value.

Return Value:

    TRUE - Success
    FALSE - Failure

--*/

{
    HKEY hKey = NULL;
    LPWSTR pszValue = NULL;
    DWORD Status;

    if( !pszPrinter ){
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    //
    // Retrieve the location of the DevMode.
    //
    if( !bGetDevModeLocation( hKeyUser,
                              pszPrinter,
                              &hKey,
                              &pszValue )){

        return FALSE;
    }

    if( !pDevMode ){

        //
        // NULL, so delete the value.
        //
        Status = RegDeleteValue( hKey, pszValue );

        //
        // If value not found, don't fail.
        //
        if( Status == ERROR_FILE_NOT_FOUND ){
            Status = ERROR_SUCCESS;
        }

    } else {

        Status = RegSetValueEx( hKey,
                                pszValue,
                                0,
                                REG_BINARY,
                                (PBYTE)pDevMode,
                                pDevMode->dmSize +
                                    pDevMode->dmDriverExtra );

        if( Status == ERROR_SUCCESS ){

            //
            // Notify everyone that the DevMode has changed.
            //
            SendNotifyMessage( HWND_BROADCAST,
                               WM_DEVMODECHANGE,
                               0,
                               (LPARAM)pszPrinter );
        }
    }

    RegCloseKey( hKey );

    if( Status != ERROR_SUCCESS ){
        SetLastError( Status );
        return FALSE;
    }

    return TRUE;
}

BOOL
bGetDevModePerUser(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE *ppDevMode
    )

/*++

Routine Description:

    Retrieves the per-user DevMode based on the current user.

Arguments:

    hKeyUser - HKEY_CURRENT_USER handle.  OPTIONAL

    pszPrinter - Printer to get.

    ppDevMode - Receives pointer to devmode.  Must be freed by callee.

Return Value:

    TRUE - Success: able to check if per-user DevMode exists.  *ppDevMode
        is NULL if no per-user DevMode is there.  (TRUE does not indicate
        that a per-user DevMode was found, only that we successfully checked.)

    FALSE - Failure.

--*/

{
    HKEY hKey = NULL;
    LPWSTR pszValue = NULL;
    LONG Status;

    *ppDevMode = NULL;

    if( !pszPrinter ){
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }
    //
    // Retrieve the location of the DevMode.
    //
    if( !bGetDevModeLocation( hKeyUser,
                              pszPrinter,
                              &hKey,
                              &pszValue )){

        Status = GetLastError();

    } else {

        DWORD cbDevModePerUser;

        //
        // Key exists.  See if we can read it and get the per-user DevMode.
        //
        Status = RegQueryInfoKey( hKey,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &cbDevModePerUser,
                                  NULL,
                                  NULL );

        if( Status == ERROR_SUCCESS ){

            if( cbDevModePerUser >= MIN_DEVMODE_SIZEW ){

                *ppDevMode = AllocSplMem( cbDevModePerUser );

                if( !*ppDevMode ){

                    Status = GetLastError();

                } else {

                    Status = RegQueryValueEx( hKey,
                                              pszValue,
                                              NULL,
                                              NULL,
                                              (PBYTE)*ppDevMode,
                                              &cbDevModePerUser );

                    if (ERROR_SUCCESS == Status) {

                        Status = IsValidDevmode(*ppDevMode, cbDevModePerUser);

                        //
                        // If the devmode isn't valid, delete it and treat it
                        // as if the devmode cannot be found.
                        //
                        if (ERROR_SUCCESS != Status) {

                            //
                            // If we can delete the key, just consider it as if
                            // it does not exist.
                            //
                            if (ERROR_SUCCESS == RegDeleteValue(hKey, pszValue)) {

                                Status = ERROR_FILE_NOT_FOUND;
                            }
                        }
                    }

                    if( Status != ERROR_SUCCESS ){
                        FreeSplMem( *ppDevMode );
                        *ppDevMode = NULL;
                    }

                    //
                    // Allow ERROR_FILE_NOT_FOUND to return success.  *ppDevMode
                    // is still NULL, but we return TRUE to indicate that we
                    // successfully checked the registry--we just didn't find one.
                    //
                    if( Status == ERROR_FILE_NOT_FOUND ){
                        Status = ERROR_SUCCESS;
                    }
                }
            }
        }

        RegCloseKey( hKey );
    }

    if( Status != ERROR_SUCCESS ){
        SetLastError( Status );
        return FALSE;
    }

    return TRUE;
}


BOOL
bCompatibleDevMode(
    PPRINTHANDLE pPrintHandle,
    PDEVMODE pDevModeBase,
    PDEVMODE pDevModeNew
    )

/*++

Routine Description:

    Check if two DevModes are compatible (e.g., they can be used
    interchangably).

    This is done by checking size and version information.  Not
    foolproof, but the best we can do since we can't look at private
    information.

Arguments:

    pPrintHandle - Printer to check.

    pDevModeBase - Known good DevMode.

    pDevModeNew - DevMode to check.

Return Value:

    TRUE - Appears compatible.
    FALSE - Not compatible.

--*/
{
    if( !pDevModeBase || ! pDevModeNew ){
        return FALSE;
    }

    return pDevModeBase->dmSize == pDevModeNew->dmSize &&
           pDevModeBase->dmDriverExtra == pDevModeNew->dmDriverExtra &&
           pDevModeBase->dmSpecVersion == pDevModeNew->dmSpecVersion &&
           pDevModeBase->dmDriverVersion == pDevModeNew->dmDriverVersion;
}

/********************************************************************

    Support Functions

********************************************************************/

BOOL
bGetDevModeLocation(
    IN HKEY hKeyUser, OPTIONAL
    IN LPCWSTR pszPrinter,
    OUT PHKEY phKey,
    OUT LPCWSTR *ppszValue
    )

/*++

Routine Description:

    Retrieves the location of the per-user DevMode.

    On success, caller is responsible for closing phKey.  ppszValue's
    life is dependent on pszPrinter.

Arguments:

    hKeyUser - HKEY_CURRENT_USER key--optional.  If not specified, current
        impersonation used.

    pszPrinter - Printer to use.

    phKey - Receives R/W key of per-user DevMode.  On success, this
        must be closed by caller.

    ppszValue - Receives value of per-user DevMode (where to read/write).

Return Value:

    TRUE - Success

    FALSE - Failure, LastError set.

--*/

{
    HANDLE hKeyClose = NULL;
    DWORD Status;

    *phKey = NULL;
    *ppszValue = NULL;

    if( !hKeyUser ){

        hKeyUser = GetClientUserHandle( KEY_READ|KEY_WRITE );
        hKeyClose = hKeyUser;
    }

    if( !hKeyUser ){

        //
        // Failed to get impersonation information.  Probably because
        // we're not impersonating, so there's no per-user information.
        //
        Status = GetLastError();

    } else {

        //
        // If it starts with two backslashes, it may be either a connection
        // or a masq printer.
        //
        if( pszPrinter[0] == L'\\' && pszPrinter[1] == L'\\' )
        {

            //
            // Query the registry for pszPrinter and look for DevMode.
            // First look at the HKCU:Printer\Connections.
            //

            if((Status = RegOpenConnectionKey(hKeyUser,(LPWSTR)pszPrinter,phKey)) == ERROR_SUCCESS)
            {
                *ppszValue = gszDevMode;
            }
        }

        //
        // If we didn't find it in Printer\Connection, then it
        // must be a local or masq printer.
        //
        if( !*ppszValue ){

            DWORD dwIgnore;

            //
            // Not a connection or didn't exist in the connections key.
            // Look in the Printers\DevModePerUser key.
            //
            Status = RegCreateKeyEx( hKeyUser,
                                     gszDevModePerUserLocal,
                                     0,
                                     NULL,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     phKey,
                                     &dwIgnore );

            if( Status == ERROR_SUCCESS ){
                *ppszValue = pszPrinter;
            }
        }
    }

    if( hKeyClose ){
        RegCloseKey( hKeyClose );
    }

    if( Status != ERROR_SUCCESS ){
        SetLastError( Status );
        return FALSE;
    }

    return TRUE;
}

BOOL bGetDevModePerUserEvenForShares(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE *ppDevMode
    )
{
    BOOL   RetVal = FALSE;
    HANDLE hPrinter;

    if(OpenPrinter((LPWSTR)pszPrinter,&hPrinter,NULL))
    {
        DWORD            PrntrInfoSize=0,PrntrInfoSizeReq=0;
        PPRINTER_INFO_2  pPrinterInfo2 = NULL;

        if(!GetPrinter(hPrinter,
                       2,
                       (LPBYTE)pPrinterInfo2,
                       PrntrInfoSize,
                       &PrntrInfoSizeReq)                                                      &&
           (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                                       &&
           (pPrinterInfo2 = (PPRINTER_INFO_2)AllocSplMem((PrntrInfoSize = PrntrInfoSizeReq)))  &&
           GetPrinter(hPrinter,
                      2,
                      (LPBYTE)pPrinterInfo2,
                      PrntrInfoSize,
                      &PrntrInfoSizeReq))
        {
            RetVal = bGetDevModePerUser( hKeyUser,
                                         pPrinterInfo2->pPrinterName,
                                         ppDevMode );
        }

        if(hPrinter)
            ClosePrinter(hPrinter);

        if(pPrinterInfo2)
            FreeSplMem(pPrinterInfo2);
    }
    else
    {
        RetVal = bGetDevModePerUser( hKeyUser,
                                     pszPrinter,
                                     ppDevMode );
    }

    return(RetVal);
}


/*++

Routine Name:

    IsValidDevmode

Description:

    Check to see whether the devmode passed in is at least as advertised in its
    buffer.

Arguments:

    pDevmode    - The devmode
    DevmodeSize - The size of the devmode as advertised in the registry.

Return Value:

    An HRESULT

--*/
DWORD
IsValidDevmode(
    IN      PDEVMODE        pDevmode,
    IN      size_t          DevmodeSize
    )
{
    DWORD   Status = ERROR_SUCCESS;

    //
    // This guarantees that the devmode is at least big enough to get the dmSize
    // and dmDriverExtra.
    //
    Status = DevmodeSize >= MIN_DEVMODE_SIZEW ?  ERROR_SUCCESS : ERROR_INVALID_DATA;

    //
    // The advertised devmode size must be contained inside
    //
    if (ERROR_SUCCESS == Status)
    {
        Status = (size_t)(pDevmode->dmSize + pDevmode->dmDriverExtra) <= DevmodeSize ? ERROR_SUCCESS : ERROR_INVALID_DATA;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\memory.c ===
/*++


Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994


Revision History:

    Matthew Felton  (MattFe) Jan 21 1995
    Add Failure Count

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG
DWORD   gFailCount = 0;
DWORD   gAllocCount = 0;
DWORD   gFreeCount = 0;
DWORD   gbFailAllocs = FALSE;
DWORD   gFailCountHit = FALSE;
#endif

BOOL
SetAllocFailCount(
    HANDLE   hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
    )
{
#if DBG
    if ( gbFailAllocs ) {
        gFailCount = dwFailCount;

        *lpdwAllocCount = gAllocCount;
        *lpdwFreeCount  = gFreeCount;
        *lpdwFailCountHit = gFailCountHit;

        gAllocCount = 0;
        gFreeCount = 0;
        gFailCountHit = FALSE;

        return TRUE;

    } else {

        SetLastError( ERROR_INVALID_PRINTER_COMMAND );
        return FALSE;
    }
#else
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
#endif
}

#if DBG
BOOL
TestAllocFailCount(
    VOID
    )

/*++

Routine Description:

    Determines whether the memory allocator should return failure
    for testing purposes.

Arguments:

Return Value:

    TRUE - Alloc should fail
    FALSE - Alloc should succeed

--*/

{
    gAllocCount++;

    if ( gFailCount != 0 && !gFailCountHit && gFailCount <= gAllocCount ) {
        gFailCountHit = TRUE;
        return TRUE;
    }

    return FALSE;
}
#endif


LPVOID
DllAllocSplMem(
    DWORD cbAlloc
    )

/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    PVOID pvMemory;

#if DBG
    if( TestAllocFailCount( )){
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return 0;
    }
#endif

    pvMemory = AllocMem( cbAlloc );

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}

BOOL
DllFreeSplMem(
    LPVOID pMem
    )
{

#if DBG
    gFreeCount++;
#endif

    FreeMem( pMem );
    return TRUE;
}

LPVOID
ReallocSplMem(
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    LPVOID pNewMem;

    pNewMem=AllocSplMem(cbNew);

    if (pOldMem && pNewMem) {

        if (cbOld) {
            CopyMemory( pNewMem, pOldMem, min(cbNew, cbOld));
        }
        FreeSplMem(pOldMem);
    }
    return pNewMem;
}

BOOL
DllFreeSplStr(
    LPWSTR pStr
    )
{
    return pStr ?
               FreeSplMem(pStr) :
               FALSE;
}

LPWSTR
AllocSplStr(
    LPCWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}

BOOL
ReallocSplStr(
    LPWSTR *ppStr,
    LPCWSTR pStr
    )
{
    LPWSTR pNewStr;

    pNewStr = AllocSplStr(pStr);

    if( pStr && !pNewStr ){
        return FALSE;
    }

    FreeSplStr(*ppStr);
    *ppStr = pNewStr;

    return TRUE;
}



LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    LPBYTE pRet = NULL;
    
    //
    // Make sure all our parameters are valid.
    // This will return NULL if one of the parameters is NULL.
    //
    if (pSource && pDest && DestOffsets && pEnd) {
        
        WORD_ALIGN_DOWN(pEnd);

        while (*DestOffsets != -1) {
            if (*pSource) {
                cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
                pEnd -= cbStr;
                CopyMemory( pEnd, *pSource, cbStr);
                *(LPWSTR UNALIGNED *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
            } else {
                *(LPWSTR UNALIGNED *)(pDest+*DestOffsets)=0;
            }
            pSource++;
            DestOffsets++;
        }
    
        pRet = pEnd;
    }
    return pRet;
}



LPVOID
AlignRpcPtr (
    LPVOID  pBuffer,
    LPDWORD pcbBuf
    )
/*++

Routine Description:

    This routine is called on the server side for methods using custom marshalling. 
    These methods cheat on RPC by asking for LPBYTE pointers and using the buffer as 
    pointer to structures. The LPBYTE pointer that RPC sends us can be unaligned.
    Here is where we take data missalignments.
    The reason the size of the buffer is aligned down is because providers will use
    the end of the buffer as a pEnd = pBuffer + cbBuf pointer. 
    If cbBuf is an unaligned value, pEnd will be unaligned as well. This will generate unaligned 
    pointers inside the structure as well.

Arguments:

    pBuffer - Pointer to a buffer
    pcbBuf  - Pointer to a DWORD representing the size of the buffer


Return Value:

    Aligned pointer

--*/
{
    LPVOID pAligned = NULL;
    
    pAligned = (LPVOID)ALIGN_PTR_UP(pBuffer);

    *pcbBuf = (DWORD)ALIGN_DOWN(*pcbBuf, ULONG_PTR);

    if (pAligned != pBuffer)
    {
        pAligned = AllocSplMem(*pcbBuf);
    }

    return pAligned;

}

VOID
UndoAlignRpcPtr (
    LPVOID  pBuffer,
    LPVOID  pAligned,
    SIZE_T  cbSize,
    LPDWORD pcbNeeded
    )
/*++

Routine Description:

    This routine is called on the server side for methods using custom marshalling. 
    These methods cheat on RPC by asking for LPBYTE pointers and using the buffer as 
    pointer to structures. The LPBYTE pointer that RPC sends us can be unaligned.
    Here is where we take data missalignments.
    This routine moves data between pointers if they are different. 
    Free pSource pointer after copy data to pDestination.
    pcbNeeded is adjusted evey time. The providor could request a a buffer size which is unaligned.
    We always align up the needed size, no matter the provider.
    
Arguments:

    pDestination - Pointer to a destination buffer
    pSource      - Pointer to a source buffer
    cbSize       - Number of bites

Return Value:

--*/
{
    //
    // pBuffer and pAligned will be either both NULL or both not NULL. See AlignRpcPtr.
    //
    if (pBuffer != pAligned)
    {
        //
        // The way AlignRpcPtr and UndoAlignRpcPtr use the pBuffer and pAligned is 
        // very subtle and confusing. UndoAlignRpcPtr doesn't offer any indication
        // that it won't access NULL pointers in CopyMemory. That's why the if 
        // statement is here, though not required.
        //
        if (pBuffer && pAligned) 
        {
            CopyMemory(pBuffer, pAligned, cbSize);
        }

        FreeSplMem(pAligned);
    }

    if (pcbNeeded)
    {
        *pcbNeeded = (DWORD)ALIGN_UP(*pcbNeeded, ULONG_PTR);        
    }
}


LPVOID
AlignKMPtr (
	LPVOID	pBuffer,
    DWORD   cbBuf
    )
/*++

Routine Description:

    This routine is called for Do* methods inside splkernl.c
    The buffer used by spooler in user mode is a pointer inside 
    The message send by GDI from kernel mode. This pointer can be unaligned.
    This method duplicates the pBuffer if unaligned.

    !!! All Do* methods could have this problem is the pointer is unaligned.
    Even so, not all of them fault. To minimize the regression chances and code pollution,
    I only call this functions for the methods where I coulds see missalignent faults.!!!

Arguments:

    pBuffer - Pointer to a buffer
    bBuf    - Size of the buffer

Return Value:

    Aligned pointer

--*/
{
    LPVOID pAligned = NULL;
    
    pAligned = (LPVOID)ALIGN_PTR_UP(pBuffer);

    if (pAligned != pBuffer)
    {
        pAligned = AllocSplMem(cbBuf);

        if (pAligned) 
        {
            CopyMemory( pAligned, pBuffer, cbBuf);
        }
    }

    return pAligned;

}

VOID
UndoAlignKMPtr (
    LPVOID  pBuffer,
    LPVOID  pAligned
    )
/*++

Routine Description:

    This method frees the duplicated memory allocated in the case where the 
    pointer is misaligned.    

Arguments:

    pBuffer     - Pointer to potentially unaligned buffer
    pAligned    - Pointer to an aligned buffer; pAligned is a copy of pBuffer    

Return Value:

--*/
{
    if (pAligned != pBuffer)
    {
        FreeSplMem(pBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\local.h ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Header file for Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matt Feton (MattFe) Jan 17 1995 add separate heaps

--*/


#define ONEDAY  60*24

// Timeout to start spooler's phase 2 initialization in milliseconds
#define SPOOLER_START_PHASE_TWO_INIT 2*60*1000

#define offsetof(type, identifier) (DWORD)(&(((type*)0)->identifier))

extern  char  *szDriverIni;
extern  char  *szDriverFileEntry;
extern  char  *szDriverDataFile;
extern  char  *szDriverConfigFile;
extern  char  *szDriverDir;
extern  char  *szPrintProcDir;
extern  char  *szPrinterDir;
extern  char  *szPrinterIni;
extern  char  *szAllShadows;
extern  char  *szNullPort;
extern  char  *szComma;

extern  HANDLE   hHeap;
extern  HANDLE   HeapSemaphore;
extern  HANDLE   InitSemaphore;
extern  BOOL     Initialized;
extern  CRITICAL_SECTION    SpoolerSection;
extern  DWORD    gbFailAllocs;

BOOL
LocalInitialize(
   VOID
);

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

LPVOID
DllAllocSplMem(
    DWORD cb
);

BOOL
DllFreeSplMem(
   LPVOID pMem
);

LPVOID
DllReallocSplMem(
   LPVOID lpOldMem,
   DWORD cbOld,
   DWORD cbNew
);

BOOL
DllFreeSplStr(
   LPWSTR lpStr
);

BOOL
ValidateReadPointer(
    PVOID pPoint,
    ULONG Len
);

BOOL
ValidateWritePointer(
    PVOID pPoint,
    ULONG Len
);

BOOL
DeleteSubKeyTree(
    HKEY ParentHandle,
    WCHAR SubKeyName[]
);

LPWSTR
AppendOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

LPWSTR
RemoveOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

LPPROVIDOR
InitializeProvidor(
   LPWSTR   pProvidorName,
   LPWSTR   pFullName
);

VOID
WaitForSpoolerInitialization(
    VOID
);

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
);


BOOL
MyUNCName(
    LPWSTR   pNameStart
);


BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszMyOtherNames,
    DWORD   *cOtherNames
);

BOOL
bCompatibleDevMode(
    PPRINTHANDLE pPrintHandle,
    PDEVMODE pDevModeBase,
    PDEVMODE pDevModeNew
    );



LPWSTR
FormatPrinterForRegistryKey(
    LPCWSTR pSource,    /* The string from which backslashes are to be removed. */
    LPWSTR pScratch     /* Scratch buffer for the function to write in;     */
    );                  /* must be at least as long as pSource.             */

LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,     /* The string from which backslashes are to be added. */
    LPWSTR pScratch     /* Scratch buffer for the function to write in;     */
    );                  /* must be at least as long as pSource.             */



PWSTR
AutoCat(
    PCWSTR pszInput,
    PCWSTR pszCat
);

BOOL
bGetDevModePerUserEvenForShares(
    IN  HKEY hKeyUser, OPTIONAL
    IN  LPCWSTR pszPrinter,
    OUT PDEVMODE *ppDevMode
    );

DWORD
GetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN LPDWORD pValue
    );

DWORD
SetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN DWORD   Value
    );

DWORD
IsValidDevmode(
    IN  PDEVMODE    pDevmode,
    IN  size_t      DevmodeSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\init.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    init.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

--*/

#include "precomp.h"
#include "local.h"
#include <wmi.h>
#pragma hdrstop

WCHAR szDefaultPrinterNotifyInfoDataSize[] = L"DefaultPrinterNotifyInfoDataSize";
WCHAR szFailAllocs[] = L"FailAllocs";

WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];

#define DEFAULT_PRINTER_NOTIFY_DATA 0x80
DWORD cDefaultPrinterNotifyInfoData = DEFAULT_PRINTER_NOTIFY_DATA;
WCHAR szRouterCacheSize[] = L"RouterCacheSize";

fnWinSpoolDrv   fnClientSide;
BOOL bInitialized = FALSE;

HANDLE hEventInit  = NULL;
BOOL   Initialized = FALSE;
DWORD  dwUpgradeFlag = 0;
SERVICE_STATUS_HANDLE   ghSplHandle = NULL;

extern CRITICAL_SECTION RouterCriticalSection;
extern PROUTERCACHE RouterCacheTable;
extern DWORD RouterCacheSize;
extern LPWSTR *ppszOtherNames;

VOID
SpoolerInitAll();

VOID
RegisterForPnPEvents(
    VOID
    );

LPPROVIDOR
InitializeProvidor(
   LPWSTR   pProvidorName,
   LPWSTR   pFullName)
{
    BOOL        bRet = FALSE;
    HANDLE      hModule = NULL;
    LPPROVIDOR  pProvidor;
    UINT        ErrorMode;
    HANDLE      hToken = NULL;

    hToken = RevertToPrinterSelf();

    if (!hToken)
    {
        goto Cleanup;
    }

    //
    // WARNING-WARNING-WARNING, we null set the print providor
    // structure. older version of the print providor have different print
    // providor sizes so they will set only some function pointers and not
    // all of them
    //

    if ( !(pProvidor = (LPPROVIDOR)AllocSplMem(sizeof(PROVIDOR)))   ||
         !(pProvidor->lpName = AllocSplStr(pProvidorName)) ) {

        DBGMSG(DBG_ERROR,
               ("InitializeProvidor can't allocate memory for %ws\n",
                pProvidorName));
        goto Cleanup;
    }
    
    //
    // Make sure we don't get any dialogs popping up while this goes on.
    //
    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    
    hModule = pProvidor->hModule = LoadLibraryEx( pProvidorName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    
    SetErrorMode( ErrorMode );
    
    if ( !hModule ) {

        DBGMSG(DBG_WARNING,
               ("InitializeProvider failed LoadLibrary( %ws ) error %d\n",
                pProvidorName, GetLastError() ));
        goto Cleanup;
    }

    pProvidor->fpInitialize = GetProcAddress(hModule, "InitializePrintProvidor");

    if ( !pProvidor->fpInitialize )
        goto Cleanup;

    bRet = (BOOL)pProvidor->fpInitialize(&pProvidor->PrintProvidor,
                                   sizeof(PRINTPROVIDOR),
                                   pFullName);

    if ( !bRet ) {

        DBGMSG(DBG_WARNING,
               ("InitializePrintProvider failed for providor %ws error %d\n",
                pProvidorName, GetLastError()));
    }

    //
    // It is not a critical error if ImpersonatePrinterClient fails.
    // If fpInitialize succeeds and ImpersonatePrinterClient fails, 
    // then if we set bRet to FALSE we forcefully unload the initialized 
    // provider DLL and can cause resource leaks.
    //
    ImpersonatePrinterClient(hToken);
    
Cleanup:

    if ( bRet ) {

        //
        // Fixup any NULL entrypoints.
        //
        FixupOldProvidor( &pProvidor->PrintProvidor );

        return pProvidor;
    } else {

        if ( hModule )
            FreeLibrary(hModule);

        if ( pProvidor ) {

            FreeSplStr(pProvidor->lpName);
            FreeSplMem(pProvidor);
        }
        return NULL;
    }
}

#if SPOOLER_HEAP
HANDLE  ghMidlHeap;
#endif

BOOL
DllMain(
    HINSTANCE hInstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    BOOL Failed = FALSE;
    BOOL ThreadInitted = FALSE,
         WPCInitted = FALSE,
         CritSecInit = TRUE;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:

#if SPOOLER_HEAP
        ghMidlHeap = HeapCreate( 0, 1024*4, 0 );

        if ( ghMidlHeap == NULL ) {
            DBGMSG( DBG_WARNING, ("DllMain heap Failed %d\n", GetLastError() ));
            Failed = TRUE;
            goto Done;
        }
#endif

        if( !bSplLibInit(NULL)){
            Failed = TRUE;
            goto Done;
        }

        DisableThreadLibraryCalls(hInstDLL);

        __try {

            InitializeCriticalSection(&RouterCriticalSection);

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            SetLastError(GetExceptionCode());
            Failed = TRUE;
            CritSecInit = FALSE;
            goto Done;

        }            

        if (!WPCInit()) {
            Failed = TRUE;
            goto Done;
        } else {
            WPCInitted = TRUE;
        }

        if (!ThreadInit()) {
            Failed = TRUE;
            goto Done;
        } else {
            ThreadInitted = TRUE;
        }
        
        //
        // Create our global init event (manual reset)
        // This will be set when we are initialized.
        //
        hEventInit = CreateEvent(NULL,
                                 TRUE,
                                 FALSE,
                                 NULL);

        if (!hEventInit) {

            Failed = TRUE;
            goto Done;
        }
        
Done:
        if (Failed)
        {
#if SPOOLER_HEAP
            if ( ghMidlHeap != NULL ) {
                (void)HeapDestroy(ghMidlHeap);
            }
#endif
            if (CritSecInit) {
                DeleteCriticalSection(&RouterCriticalSection);
            }
            if (hEventInit) {
                CloseHandle(hEventInit);
            }

            if (WPCInitted) {
                WPCDestroy();
            }
            
            if (ThreadInitted) {
                ThreadDestroy();
            }

            WmiTerminateTrace();    // Unregisters spoolss from WMI.

            return FALSE;
        }
        break;

    case DLL_PROCESS_DETACH:

        ThreadDestroy();
        WPCDestroy();

        CloseHandle(hEventInit);
        break;
    }
    return TRUE;
}




BOOL
InitializeRouter(
    SERVICE_STATUS_HANDLE SpoolerStatusHandle
)
/*++

Routine Description:

    This function will Initialize the Routing layer for the Print Providors.
    This will involve scanning the win.ini file, loading Print Providors, and
    creating instance data for each.

Arguments:

    None

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPPROVIDOR  pProvidor;
    DWORD   cbDll;
    WCHAR   ProvidorName[MAX_PATH], Dll[MAX_PATH], szFullName[MAX_PATH];
    HKEY    hKey, hKey1;
    LONG    Status;

    LPWSTR  lpMem = NULL;
    LPWSTR  psz = NULL;
    DWORD   dwRequired = 0;

    DWORD   SpoolerPriorityClass = 0;
    NT_PRODUCT_TYPE NtProductType;
    DWORD   dwCacheSize = 0;

    DWORD dwType;
    DWORD cbData;

    DWORD i;
    extern DWORD cOtherNames;
    WCHAR szSetupKey[] = L"System\\Setup";

    //
    // WMI Trace Events. Registers spoolss with WMI.
    //
    WmiInitializeTrace();  
    
    ghSplHandle = SpoolerStatusHandle;

    //
    // We are now assume that the other services and drivers have
    // initialized.  The loader of this dll must do this syncing.
    //
    // spoolss\server does this by using the GroupOrderList
    // SCM will try load load parallel and serial before starting
    // the spooler service.
    //

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szPrintKey,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey)) {

        cbData = sizeof(SpoolerPriorityClass);

        // SpoolerPriority
        Status = RegQueryValueEx(hKey,
                        L"SpoolerPriority",
                        NULL,
                        &dwType,
                        (LPBYTE)&SpoolerPriorityClass,
                        &cbData);


        if (Status == ERROR_SUCCESS &&
           (SpoolerPriorityClass == IDLE_PRIORITY_CLASS ||
            SpoolerPriorityClass == NORMAL_PRIORITY_CLASS ||
            SpoolerPriorityClass == HIGH_PRIORITY_CLASS)) {

                Status = SetPriorityClass(GetCurrentProcess(), SpoolerPriorityClass);
        }


        cbData = sizeof(cDefaultPrinterNotifyInfoData);

        //
        // Ignore failure case since we can use the default
        //
        RegQueryValueEx(hKey,
                        szDefaultPrinterNotifyInfoDataSize,
                        NULL,
                        &dwType,
                        (LPBYTE)&cDefaultPrinterNotifyInfoData,
                        &cbData);


#if DBG
        //
        // Inore failure default is to not fail memory allocations
        //
        RegQueryValueEx(hKey,
                        szFailAllocs,
                        NULL,
                        &dwType,
                        (LPBYTE)&gbFailAllocs,
                        &cbData);
#endif

        RegCloseKey(hKey);
    }


    // Is it an upgrade?

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szSetupKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey)) {

        /*++
            You can tell if you are inside gui setup by looking for
            HKLM\System\Setup\SystemSetupInProgress  -- non zero means gui-setup is running.
        

            The following description is outdated. 
                                             
            Description: the query update flag is set up by TedM. We will read this flag
            if the flag has been set, we will set a boolean variable saying that we're in
            the upgrade mode. All upgrade activities will be carried out based on this flag.
            For subsequents startups of the spooler, this flag will be unvailable so we
            won't run the spooler in upgrade mode.

        --*/

        dwUpgradeFlag = 0;

        cbData = sizeof(dwUpgradeFlag);

        Status = RegQueryValueEx(hKey,
                        L"SystemSetupInProgress",
                        NULL,
                        &dwType,
                        (LPBYTE)&dwUpgradeFlag,
                        &cbData);


        if (Status != ERROR_SUCCESS) {
            dwUpgradeFlag = 0;
        }

        
        DBGMSG(DBG_TRACE, ("The Spooler Upgrade flag is %d\n", dwUpgradeFlag));
        
        RegCloseKey(hKey);
    }



    // Setup machine names
    szMachineName[0] = szMachineName[1] = L'\\';

    i = MAX_COMPUTERNAME_LENGTH + 1;

    if (!GetComputerName(szMachineName+2, &i)) {
        DBGMSG(DBG_ERROR, ("Failed to get computer name %d\n", GetLastError()));
        ExitProcess(0);
    }

    if (!BuildOtherNamesFromMachineName(&ppszOtherNames, &cOtherNames)) {
        DBGMSG(DBG_TRACE, ("Failed to determine other machine names %d\n", GetLastError()));
    }


    if (!(pLocalProvidor = InitializeProvidor(szLocalSplDll, NULL))) {

        DBGMSG(DBG_WARN, ("Failed to initialize local print provider, error %d\n", GetLastError() ));

        ExitProcess(0);
    }

    pProvidor = pLocalProvidor;

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryProvidors, 0,
                          KEY_READ, &hKey);

    if (Status == ERROR_SUCCESS) {

        //
        // Now query szCacheSize for the RouterCacheSize value
        // if there is no RouterCacheSize replace it with the
        // default value.
        //
        RouterCacheSize = ROUTERCACHE_DEFAULT_MAX;

        cbData = sizeof(dwCacheSize);

        Status = RegQueryValueEx(hKey,
                                 szRouterCacheSize,
                                 NULL, NULL,
                                 (LPBYTE)&dwCacheSize,
                                 &cbData);

        if (Status == ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("RouterCacheSize = %d\n", dwCacheSize));

            if (dwCacheSize > 0) {
                RouterCacheSize = dwCacheSize;
            }
        }

        if ((RouterCacheTable = AllocSplMem(RouterCacheSize *
                                            sizeof(ROUTERCACHE))) == NULL) {

            DBGMSG(DBG_ERROR, ("Error: Cannot create RouterCache Table\n"));
            RouterCacheSize = 0;
        }

        //
        // Now query szRegistryProvidors for the Order value
        // if there is no Order value for szRegistryProvidors
        // RegQueryValueEx will return ERROR_FILE_NOT_FOUND
        // if that's the case, then quit, because we have
        // no providors to initialize.
        //
        Status = RegQueryValueEx(hKey, szOrder, NULL, NULL,
                                (LPBYTE)NULL, &dwRequired);

        //
        // If RegQueryValueEx returned ERROR_SUCCESS, then
        // call it again to determine how many bytes were
        // allocated. Note, if Order does exist, but it has
        // no data then dwReturned will be zero, in which
        // don't allocate any memory for it, and don't
        // bother to call RegQueryValueEx a second time.
        //
        if (Status == ERROR_SUCCESS) {
            if (dwRequired != 0) {
                lpMem = (LPWSTR) AllocSplMem(dwRequired);
                if (lpMem == NULL) {

                    Status = GetLastError();

                } else {
                    Status = RegQueryValueEx(hKey, szOrder, NULL, NULL,
                                    (LPBYTE)lpMem, &dwRequired);
                }
            }
        }
        if (Status == ERROR_SUCCESS) {

            cbDll = sizeof(Dll);

            pProvidor = pLocalProvidor;

            // Now parse the string retrieved from \Providors{Order = "....."}
            // Remember each string is separated by a null terminator char ('\0')
            // and the entire array is terminated by two null terminator chars

            // Also remember, that if there was no data in Order, then
            // psz = lpMem = NULL, and we have nothing to parse, so
            // break out of the while loop, if psz is NULL as well

            psz =  lpMem;

            while (psz && *psz) {

               //
               // Truncate the provider name if it does not fit in
               // the stack allocated buffer.
               // 
               lstrcpyn(ProvidorName, psz, COUNTOF(ProvidorName));

               psz = psz + lstrlen(psz) + 1; // skip (length) + 1
                                             // lstrlen returns length sans '\0'

               if (RegOpenKeyEx(hKey, ProvidorName, 0, KEY_READ, &hKey1)
                                                            == ERROR_SUCCESS) {

                    cbDll = sizeof(Dll);

                    if (RegQueryValueEx(hKey1, L"Name", NULL, NULL,
                                        (LPBYTE)Dll, &cbDll) == ERROR_SUCCESS)
                    {
                        if((StrNCatBuff(szFullName,
                                       COUNTOF(szFullName),
                                       szRegistryProvidors,
                                       L"\\",
                                       ProvidorName,
                                       NULL)==ERROR_SUCCESS))
                        {
                             if (pProvidor->pNext = InitializeProvidor(Dll, szFullName))
                             {
     
                                 pProvidor = pProvidor->pNext;
                             }
                        }
                    } //close RegQueryValueEx

                    RegCloseKey(hKey1);

                } // closes RegOpenKeyEx on ERROR_SUCCESS

            } //  end of while loop parsing REG_MULTI_SZ

            // Now free the buffer allocated for RegQuery
            // (that is if you have allocated - if dwReturned was
            // zero, then no memory was allocated (since none was
            // required (Order was empty)))

            if (lpMem) {
                FreeSplMem(lpMem);
            }

        }   //  closes RegQueryValueEx on ERROR_SUCCESS

        RegCloseKey(hKey);
    }

    //
    // We are now initialized!
    //
    SetEvent(hEventInit);
    Initialized=TRUE;

    //
    // Register for PnP events we care about
    //
    RegisterForPnPEvents();

    SpoolerInitAll();

    // When we return this thread goes away

    //
    // NOTE-NOTE-NOTE-NOTE-NOTE KrishnaG  12/22/93
    // This thread should go away, however the HP Monitor relies on this
    // thread. HPMon calls the initialization function on this thread which
    // calls an asynchronous receive for data. While the data itself is
    // picked up by hmon!_ReadThread, if the thread which initiated the
    // receive goes away, we will not be able to receive the data.
    //

    //
    // Instead of sleeping infinite, let's use it to for providors that
    // just want FFPCNs to poll.  This call never returns.
    //

    HandlePollNotifications();
    return TRUE;
}


VOID
WaitForSpoolerInitialization(
    VOID)
{
    HANDLE hPhase2Init;
    HANDLE hImpersonationToken = NULL;
    
    if (!Initialized)
    {
        //
        // Impersonate the spooler service token
        //
        hImpersonationToken = RevertToPrinterSelf();
        
        //
        // Start phase 2 initialization. hPhase2Init may set multiple times, but that
        // is OK since there is only 1 thread waiting once on this event.
        //
        hPhase2Init = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"RouterPreInitEvent");

        if (hPhase2Init == NULL)
        {
            //
            // Fail if the event is not created
            //
            DBGMSG(DBG_ERROR, ("Failed to create Phase2Init Event in WaitForSpoolerInitialization, error %d\n", GetLastError()));
            ExitProcess(0);
        }
        SetEvent(hPhase2Init);
        CloseHandle(hPhase2Init);

        //
        // Revert back to the client token
        //
        if (hImpersonationToken)
        {  
            if (!ImpersonatePrinterClient(hImpersonationToken))
            {
                DBGMSG(DBG_ERROR, ("Failed to impersonate the client, error %d\n", GetLastError()));
                ExitProcess(0);
            }
        }

        WaitForSingleObject(hEventInit, INFINITE);
    }
}

VOID
SplStartPhase2Init(
    VOID)
{
    HANDLE hPhase2Init;
    HANDLE hImpersonationToken = NULL;
    
    //
    // Impersonate the spooler service token
    //
    hImpersonationToken = RevertToPrinterSelf();

    //
    // Start the phase 2 initialization. This function is when SERVICE_CONTROL_SYSTEM_IDLE
    // message is sent to the spooler by the SCM.
    //
    hPhase2Init = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"RouterPreInitEvent");
    if (hPhase2Init == NULL)
    {
        //
        // Fail if the event is not created
        //
        DBGMSG(DBG_ERROR, ("Failed to open Phase2Init Event in SplStartPhase2Init, error %d\n", GetLastError()));
        ExitProcess(0);
    }
    SetEvent(hPhase2Init);
    CloseHandle(hPhase2Init);

    //
    // Revert back to the client token
    //
    if (hImpersonationToken)
    {
        ImpersonatePrinterClient(hImpersonationToken);
    }

}

VOID
ShutDownProvidor(
    LPPROVIDOR pProvidor)
{
    if (pProvidor->PrintProvidor.fpShutDown) {

        (*pProvidor->PrintProvidor.fpShutDown)(NULL);
    }

    FreeSplStr(pProvidor->lpName);
    FreeLibrary(pProvidor->hModule);
    FreeSplMem(pProvidor);
    return;
}


VOID
SplShutDownRouter(
    VOID
    )
{
    DBGMSG(DBG_TRACE, ("SplShutDownRouter:\n"));

    //
    // WMI Trace Events. Unregisters spoolss from WMI.
    //
    WmiTerminateTrace();

//
// This code is commented out because it is not
// tested and clearly it will not work with
// all known print providers.  Maybe in the future
// we will have correct provider shutdown.
//
#if 0
    LPPROVIDOR pTemp;
    LPPROVIDOR pProvidor;

    DbgPrint("We're in the cleanup function now!!\n");

    pProvidor = pLocalProvidor;
    while (pProvidor) {
        pTemp = pProvidor;
        pProvidor = pProvidor->pNext;
        ShutDownProvidor(pTemp);
    }
#endif

}

BOOL
SplInitializeWinSpoolDrv(
    pfnWinSpoolDrv    pfnList)
{
    HANDLE  hWinSpoolDrv;

    // Check if the client side handles are available in fnClientSide
    if (!bInitialized) {

       if (!(hWinSpoolDrv = LoadLibrary(TEXT("winspool.drv")))) {
           // Could not load the client side of the spooler
           return FALSE;
       }

       fnClientSide.pfnOpenPrinter   = (BOOL (*)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS))
                                        GetProcAddress( hWinSpoolDrv,"OpenPrinterW" );

       fnClientSide.pfnClosePrinter  = (BOOL (*)(HANDLE))
                                        GetProcAddress( hWinSpoolDrv,"ClosePrinter" );

       fnClientSide.pfnDocumentProperties = (LONG (*)(HWND, HANDLE, LPWSTR, PDEVMODE,
                                                      PDEVMODE, DWORD))
                                             GetProcAddress( hWinSpoolDrv,"DocumentPropertiesW" );

       fnClientSide.pfnDevQueryPrint = (BOOL (*)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD))
                                        GetProcAddress( hWinSpoolDrv,"SpoolerDevQueryPrintW" );

       fnClientSide.pfnPrinterEvent  = (BOOL (*)(LPWSTR, INT, DWORD, LPARAM))
                                        GetProcAddress( hWinSpoolDrv,"SpoolerPrinterEvent" );

       fnClientSide.pfnLoadPrinterDriver  = (HANDLE (*)(HANDLE))
                                             GetProcAddress( hWinSpoolDrv,
                                                             (LPCSTR)MAKELPARAM( 212, 0 ));

       fnClientSide.pfnRefCntLoadDriver  = (HANDLE (*)(LPWSTR, DWORD, DWORD, BOOL))
                                            GetProcAddress( hWinSpoolDrv,
                                                            (LPCSTR)MAKELPARAM( 213, 0 ));

       fnClientSide.pfnRefCntUnloadDriver  = (BOOL (*)(HANDLE, BOOL))
                                              GetProcAddress( hWinSpoolDrv,
                                                              (LPCSTR)MAKELPARAM( 214, 0 ));

       fnClientSide.pfnForceUnloadDriver  = (BOOL (*)(LPWSTR))
                                           GetProcAddress( hWinSpoolDrv,
                                                           (LPCSTR)MAKELPARAM( 215, 0 ));

       if ( fnClientSide.pfnOpenPrinter        == NULL ||
            fnClientSide.pfnClosePrinter       == NULL ||
            fnClientSide.pfnDocumentProperties == NULL ||
            fnClientSide.pfnPrinterEvent       == NULL ||
            fnClientSide.pfnDevQueryPrint      == NULL ||
            fnClientSide.pfnLoadPrinterDriver  == NULL ||
            fnClientSide.pfnRefCntLoadDriver   == NULL ||
            fnClientSide.pfnRefCntUnloadDriver == NULL ||
            fnClientSide.pfnForceUnloadDriver  == NULL ) {

             return FALSE;
       }

       // Use these pointers for future calls to SplInitializeWinspoolDrv
       bInitialized = TRUE;
    }

    pfnList->pfnOpenPrinter        = fnClientSide.pfnOpenPrinter;
    pfnList->pfnClosePrinter       = fnClientSide.pfnClosePrinter;
    pfnList->pfnDocumentProperties = fnClientSide.pfnDocumentProperties;
    pfnList->pfnDevQueryPrint      = fnClientSide.pfnDevQueryPrint;
    pfnList->pfnPrinterEvent       = fnClientSide.pfnPrinterEvent;
    pfnList->pfnLoadPrinterDriver  = fnClientSide.pfnLoadPrinterDriver;
    pfnList->pfnRefCntLoadDriver   = fnClientSide.pfnRefCntLoadDriver;
    pfnList->pfnRefCntUnloadDriver = fnClientSide.pfnRefCntUnloadDriver;
    pfnList->pfnForceUnloadDriver  = fnClientSide.pfnForceUnloadDriver;

    return TRUE;
}


BOOL
SpoolerHasInitialized(
    VOID
    )
{
    return Initialized;
}

/*++

Routine Name

    SplPowerEvent

Routine Description:

    Checks if the spooler is ready for power management events like hibernation/stand by.
    
Arguments:

    Event - power management event
    
Return Value:

    TRUE  - the spooler allowd the system to be powered down
    FALSE - the spooler denies the request for powering down
    
--*/
BOOL
SplPowerEvent(
    DWORD Event
    )
{
    BOOL bRet = TRUE;

    //
    // We need the router to be completely initialized and having loaded
    // all print providers in order to check if we can allow powering down
    // the system
    //
    if (bInitialized) 
    {
        HMODULE   hLib = NULL;
        typedef BOOL (*PACPIFUNC)(DWORD);
        PACPIFUNC pfn;
        
        if ((hLib = LoadLibrary(L"localspl.dll")) &&
            (pfn  = (PACPIFUNC)GetProcAddress(hLib, "SplPowerEvent"))) 
        {
            bRet = (*pfn)(Event);
        }
        
        if (hLib) 
        {
            FreeLibrary(hLib);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\job.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    job.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
SetJobW(
    HANDLE hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command)

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetJob) (pPrintHandle->hPrinter,
                                                 JobId, Level, pJob, Command);
}

BOOL
GetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pJob == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetJob)
                    (pPrintHandle->hPrinter, JobId, Level, pJob,
                     cbBuf, pcbNeeded);
}

BOOL
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pJob == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumJobs)(pPrintHandle->hPrinter,
                                               FirstJob, NoJobs,
                                               Level, pJob, cbBuf,
                                               pcbNeeded, pcReturned);
}



BOOL
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pAddJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pAddJob == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpAddJob) (pPrintHandle->hPrinter,
                                                     Level, pAddJob, cbBuf,
                                                     pcbNeeded);
}

BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpScheduleJob) (pPrintHandle->hPrinter,
                                                      JobId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include "precomp.h"
#pragma hdrstop

PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{

#if SPOOLER_HEAP
    return (PVOID)HeapAlloc( ghMidlHeap, HEAP_ZERO_MEMORY, NumBytes );
#else
    return AllocSplMem(NumBytes);
#endif

}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
#if SPOOLER_HEAP
    HeapFree( ghMidlHeap, 0, (LPVOID)MemPointer );
#else
    FreeSplMem(MemPointer);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\netid.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    netid.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define MAXNETIDS       100

extern WCHAR *szRegDevicesPath;
extern WCHAR *szDotDefault;

DWORD
GetNetworkIdWorker(
    HKEY hKeyDevices,
    LPWSTR pDeviceName);


LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  &&
            (*string >= L'0') &&
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}


DWORD
GetNextNetId(
    DWORD pNetTable[]
    )
{
    DWORD i;
    for (i = 0; i < MAXNETIDS; i++) {
        if (!ISBITON(pNetTable, i)) {
            return(i);
        }
    }
    return((DWORD)-1);
}

DWORD
GetNetworkId(
    HKEY hKeyUser,
    LPWSTR pDeviceName)
{
    HKEY hKeyUserDevices;
    DWORD dwNetId;

    if (RegOpenKeyEx(hKeyUser,
                     szRegDevicesPath,
                     0,
                     KEY_READ,
                     &hKeyUserDevices) != ERROR_SUCCESS) {

        return 0;
    }

    dwNetId = GetNetworkIdWorker(hKeyUserDevices,
                                 pDeviceName);

    RegCloseKey(hKeyUserDevices);

    return dwNetId;
}


DWORD
GetNetworkIdWorker(
    HKEY hKeyUserDevices,
    LPWSTR pDeviceName)

/*++

    Parses the Devices section of Win.ini to determine if the
    printer device is a remote device.  We determine this by checking
    if the first two characters are "Ne." If they are then we know
    that the next two characters are the NetId.  If we find a Printer
    device mapping the input pDeviceName, then return the id.  If we
    don't find a Printer device mapping return the next possible /
    available id.

--*/

{
    LPWSTR p;
    WCHAR szData[MAX_PATH];
    WCHAR szValue[MAX_PATH];
    DWORD cchValue;
    DWORD cbData;
    DWORD i;
    DWORD dwId;

    DWORD dwError;

    //
    // Alloc 104 bits  - but we'll use only 100 bits
    //
    DWORD  adwNetTable[4];

    memset(adwNetTable, 0, sizeof(adwNetTable));

    for (i=0; TRUE; i++) {

        cchValue = COUNTOF(szValue);
        cbData = sizeof(szData);

        dwError = RegEnumValue(hKeyUserDevices,
                               i,
                               szValue,
                               &cchValue,
                               NULL,
                               NULL,
                               (PBYTE)szData,
                               &cbData);

        if (dwError != ERROR_SUCCESS)
            break;

        if (*szData) {

            if (p = wcschr(szData, L',')) {

                //
                // null set szOutput; szPrinter is now the
                // the name of our printer.
                //
                *p = 0;

                //
                // Get the Port name out of szOutput
                //
                p++;
                while (*p == ' ') {
                    p++;
                }

                if (!_wcsnicmp(p, L"Ne", 2)) {

                    p += 2;
                    *(p+2) = L'\0';
                    dwId = wtol(p);

                    //
                    // if we have a match for the id, then
                    // use it and return, no need to generate
                    // a table
                    //
                    if (!wcscmp(szValue, pDeviceName)) {
                        return dwId;
                    }

                    //
                    // Error if >= 100!
                    //
                    if (dwId < 100)
                        MARKUSE(adwNetTable, dwId);
                }
            }
        }
    }

    //
    //  So we didn't find the printer
    //

    return GetNextNetId(adwNetTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\monitor.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    monitor.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

BOOL
GetPortInfo2UsingPortInfo1(
    LPPROVIDOR      pProvidor,
    LPWSTR          pName,
    LPBYTE          pPorts,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded,
    LPDWORD         pcReturned
    )
{

    BOOL            bRet;
    LPPORT_INFO_1   pPortInfo1;
    LPPORT_INFO_2   pPortInfo2;
    DWORD           cReturned;

    bRet = (*pProvidor->PrintProvidor.fpEnumPorts) (pName, 1, pPorts, cbBuf,
                                          pcbNeeded, pcReturned);

    if ( !bRet ) {

        //
        // This is the upperbound
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            *pcbNeeded += (*pcbNeeded / sizeof(PORT_INFO_1)) *
                                  (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));
    } else {

        *pcbNeeded += *pcReturned * (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));


        if ( *pcbNeeded <= cbBuf ) {

            cReturned = *pcReturned;
            while ( cReturned-- ) {

                pPortInfo1 = (LPPORT_INFO_1) (pPorts + cReturned * sizeof(PORT_INFO_1));
                pPortInfo2 = (LPPORT_INFO_2) (pPorts + cReturned * sizeof(PORT_INFO_2));

                pPortInfo2->pPortName    = pPortInfo1->pName;
                pPortInfo2->pMonitorName = NULL;
                pPortInfo2->pDescription = NULL;
                pPortInfo2->fPortType    = 0;
                pPortInfo2->Reserved     = 0;
            }
        } else {

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            *pcReturned = 0;
            bRet = FALSE;
        }
    }

    return bRet;
}


BOOL
EnumPortsW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pPort,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    DWORD   cReturned, TotalcbNeeded;
    DWORD   Error = ERROR_SUCCESS, TempError = ERROR_SUCCESS;
    PROVIDOR *pProvidor;
    DWORD   BufferSize=cbBuf;
    BOOL bPartialSuccess = FALSE;
    DWORD rc;

    if ((pPort == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    TotalcbNeeded = cReturned = 0;

    while (pProvidor) {

        *pcReturned = 0;
        *pcbNeeded = 0;

        //
        // CLS
        //
        rc = (*pProvidor->PrintProvidor.fpEnumPorts)(pName, Level,
                                                     pPort, BufferSize,
                                                     pcbNeeded, pcReturned);

        if( !rc ){

            TempError = GetLastError();

            //
            // Netware providor returns INVALID_NAME and not INVALID_LEVEL
            // So if Level = 2 and error always try a Level 1 query
            //
            if ( Level == 2 &&
                 ( TempError == ERROR_INVALID_LEVEL ||
                   TempError == ERROR_INVALID_NAME) ) {

                TempError = ERROR_SUCCESS;
                if ( !GetPortInfo2UsingPortInfo1(pProvidor,
                                                 pName,
                                                 pPort,
                                                 BufferSize,
                                                 pcbNeeded,
                                                 pcReturned) ) {

                    TempError = GetLastError();
                } else {

                    bPartialSuccess = TRUE;
                }
            }

            //
            // HACK FIX:
            //
            // NT 3.51 returns bogus pcbNeeded/pcReturned data if the
            // Level is invalid (i.e., PORT_INFO_2).  So we should zero
            // these vars if the level is bad, otherwise the error returned
            // is ERROR_INSUFFICIENT_BUFFER.
            //
            if ( TempError ) {

                *pcReturned = 0;
                Error = TempError;
                if ( Error != ERROR_INSUFFICIENT_BUFFER )
                    *pcbNeeded = 0;
            }

        } else {

            bPartialSuccess = TRUE;
        }

        cReturned += *pcReturned;

        switch (Level) {

            case 1:
                pPort += *pcReturned * sizeof(PORT_INFO_1);
                break;

            case 2:
                pPort += *pcReturned * sizeof(PORT_INFO_2);
                break;

            default:
                DBGMSG(DBG_ERROR,
                       ("EnumPortsW: invalid level %d", Level));
                SetLastError(ERROR_INVALID_LEVEL);
                return FALSE;
        }

        if (*pcbNeeded <= BufferSize)
            BufferSize -= *pcbNeeded;
        else
            BufferSize = 0;

        TotalcbNeeded += *pcbNeeded;

        //
        // CLS
        //
        // Stop routing if the provider tells us to.
        //
        if( rc == ROUTER_STOP_ROUTING ){
            break;
        }

        pProvidor = pProvidor->pNext;
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cReturned;

    if (TotalcbNeeded > cbBuf) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    } else if (bPartialSuccess) {
        SetLastError(ERROR_SUCCESS);
    } else if (Error != ERROR_SUCCESS) {
        SetLastError(Error);
        return FALSE;
    }

    return TRUE;
}

BOOL
EnumMonitorsW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pMonitor,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    DWORD   cReturned, cbStruct, TotalcbNeeded;
    DWORD   Error;
    PROVIDOR *pProvidor;
    DWORD   BufferSize=cbBuf;
    BOOL bPartialSuccess = FALSE;
    DWORD rc;

    if ((pMonitor == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    switch (Level) {

    case 1:
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
         DBGMSG(DBG_ERROR,
                ("EnumMonitorsW: invalid level %d", Level));
         SetLastError(ERROR_INVALID_LEVEL);
         return FALSE;
    }

    pProvidor = pLocalProvidor;

    TotalcbNeeded = cReturned = 0;

    Error = ERROR_SUCCESS;

    while (pProvidor) {

        *pcReturned = 0;

        *pcbNeeded = 0;

        rc = (*pProvidor->PrintProvidor.fpEnumMonitors) (pName,
                                                         Level,
                                                         pMonitor,
                                                         BufferSize,
                                                         pcbNeeded,
                                                         pcReturned);

        cReturned += *pcReturned;

        pMonitor += *pcReturned * cbStruct;

        if (*pcbNeeded <= BufferSize)
            BufferSize -= *pcbNeeded;
        else
            BufferSize = 0;

        TotalcbNeeded += *pcbNeeded;

        if( rc == ROUTER_UNKNOWN ){

            Error = GetLastError();

        } else {

            bPartialSuccess = TRUE;

            if( rc == ROUTER_STOP_ROUTING ){

                break;
            }
        }

        pProvidor = pProvidor->pNext;
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cReturned;

    if (TotalcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    } else if (bPartialSuccess) {
        SetLastError(ERROR_SUCCESS);
    } else if (Error != ERROR_SUCCESS) {
        SetLastError(Error);
        return FALSE;
    }

    return TRUE;
}




BOOL
AddPortExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pBuffer,
    LPWSTR  pMonitorName
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (pProvidor->PrintProvidor.fpAddPortEx) {
            if ((*pProvidor->PrintProvidor.fpAddPortEx) (pName, Level, pBuffer, pMonitorName)) {
                return TRUE;
            }
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}



BOOL
AddPortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
)
{
    LPPROVIDOR  pProvidor;
    DWORD       Error = NO_ERROR;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!pProvidor->PrintProvidor.fpAddPort)
            break;

        if ((*pProvidor->PrintProvidor.fpAddPort)(pName, hWnd, pMonitorName)) {

            return TRUE;

        } else {

            DWORD LastError = GetLastError();

            /* If the function is not supported, don't return yet
             * in case there's a print provider that does support it.
             */
            if (LastError == ERROR_NOT_SUPPORTED)
                Error = ERROR_NOT_SUPPORTED;

            else if (LastError != ERROR_INVALID_NAME)
                return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(Error == NO_ERROR ? ERROR_INVALID_PARAMETER : Error);

    return FALSE;
}

BOOL
ConfigurePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    LPPROVIDOR  pProvidor;
    DWORD       Error = NO_ERROR;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!pProvidor->PrintProvidor.fpConfigurePort)
            break;

        if ((*pProvidor->PrintProvidor.fpConfigurePort) (pName, hWnd, pPortName)) {

            return TRUE;

        } else {

            DWORD LastError = GetLastError();

            /* If the function is not supported, don't return yet
             * in case there's a print provider that does support it.
             */
            if (LastError == ERROR_NOT_SUPPORTED)
                Error = ERROR_NOT_SUPPORTED;

            else if ((LastError != ERROR_INVALID_NAME) && (LastError != ERROR_UNKNOWN_PORT))
                return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(Error == NO_ERROR ? ERROR_INVALID_PARAMETER : Error);

    return FALSE;
}

BOOL
DeletePortW(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
)
{
    LPPROVIDOR  pProvidor;
    DWORD       Error = NO_ERROR;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!pProvidor->PrintProvidor.fpDeletePort)
            break;

        if ((*pProvidor->PrintProvidor.fpDeletePort) (pName, hWnd, pPortName)) {

            return TRUE;

        } else {

            DWORD LastError = GetLastError();

            /* If the function is not supported, don't return yet
             * in case there's a print provider that does support it.
             */
            if (LastError == ERROR_NOT_SUPPORTED)
                Error = ERROR_NOT_SUPPORTED;

            else if ((LastError != ERROR_INVALID_NAME) && (LastError != ERROR_UNKNOWN_PORT))
                return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(Error == NO_ERROR ? ERROR_INVALID_PARAMETER : Error);

    return FALSE;
}


BOOL
AddMonitorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddMonitor) (pName, Level, pMonitorInfo)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
DeleteMonitorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpDeleteMonitor)
                                (pName, pEnvironment, pMonitorName)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
SetPortW(
    LPWSTR  pszName,
    LPWSTR  pszPortName,
    DWORD   dwLevel,
    LPBYTE  pPortInfo
    )
{
    LPPROVIDOR  pProvidor;
    DWORD       dwLastError;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ( (*pProvidor->PrintProvidor.fpSetPort)(pszName,
                                                   pszPortName,
                                                   dwLevel,
                                                   pPortInfo) ) {

            return TRUE;
        }

        dwLastError = GetLastError();
        if ( dwLastError != ERROR_INVALID_NAME    &&
             dwLastError != ERROR_UNKNOWN_PORT    &&
             dwLastError != ERROR_NOT_SUPPORTED ) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\nullpp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    NullPP.c

Abstract:

    Implements the NULL print providor.

Author:

    Albert Ting (AlbertT)  16-Feb-95

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
NullOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return ROUTER_UNKNOWN;
}

BOOL
NullOpenPrinterEx(
    LPWSTR              pPrinterName,
    LPHANDLE            phPrinter,
    LPPRINTER_DEFAULTS  pDefault,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return ROUTER_UNKNOWN;
}

BOOL
NullSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    DWORD               dwLevel,
    LPBYTE              pPortInfo
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSetJob(
    HANDLE hPrinter,
    DWORD JobId,
    DWORD Level,
    LPBYTE pJob,
    DWORD Command
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetJob(
    HANDLE   hPrinter,
    DWORD    JobId,
    DWORD    Level,
    LPBYTE   pJob,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


HANDLE
NullAddPrinter(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return NULL;
}


HANDLE
NullAddPrinterEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pClientInfo,
    DWORD   dwLevel
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return NULL;
}


BOOL
NullDeletePrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


BOOL
NullSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


BOOL
NullGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullAddDriverCatalog(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    VOID    *pvDriverInfCatInfo,
    DWORD   dwCatalogCopyFlags
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
NullGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
NullDeletePrinterDriver(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
)
{
    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullAddPerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName,
    LPCWSTR   pPrintServer,
    LPCWSTR   pProvider
)
{
    SetLastError( ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullDeletePerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName
)
{
    SetLastError( ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullEnumPerMachineConnections(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
NullAddPrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDataypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

DWORD
NullStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return 0;
}

BOOL
NullStartPagePrinter(
    HANDLE  hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEndPagePrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAbortPrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSplDriverUnloadComplete(
    LPWSTR  pDriverFile
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetSpoolFileHandle(
    HANDLE    hPrinter,
    LPWSTR    *pSpoolDir,
    LPHANDLE  phFile,
    HANDLE    hSpoolerProcess,
    HANDLE    hAppProcess)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   cbCommit)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullCloseSpoolFileHandle(
    HANDLE  hPrinter)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEndDocPrinter(
    HANDLE   hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
NullGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
NullGetPrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,        // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,    // address for size of value buffer
    LPDWORD pType,            // address of buffer for type code
    LPBYTE  pData,            // address of buffer for value data
    DWORD   cbData,            // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
NullEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey        // address for size of value buffer
)
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    return ERROR_NOT_SUPPORTED;
}

DWORD
NullDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    return ERROR_NOT_SUPPORTED;
}



DWORD
NullSetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
NullWaitForPrinterChange(
    HANDLE hPrinter, DWORD Flags
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return 0;
}

BOOL
NullClosePrinter(
    HANDLE hPrinter
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeleteForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullSetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumMonitors(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullEnumPorts(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddPort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pMonitorName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullConfigurePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeletePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

HANDLE
NullCreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW   pDevMode
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return NULL;
}

BOOL
NullPlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeletePrinterIC(
    HANDLE  hPrinterIC
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullAddPrinterConnection(
    LPWSTR  pName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullDeletePrinterConnection(
    LPWSTR pName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

DWORD
NullPrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return 0;
}

BOOL
NullAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullDeleteMonitor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
    )
{
    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
NullResetPrinter(
    HANDLE hPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


BOOL
NullFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pPrinterNotifyOptions,
    PVOID pPrinterNotifyInit
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullFindClosePrinterChangeNotification(
    HANDLE hPrinter
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}


BOOL
NullAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullShutDown(
    LPVOID pvReserved
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  Reserved,
    PVOID pvReserved,
    PVOID pPrinterNotifyInfo
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWrite
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
NullFlushPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;    
}

DWORD
NullSendRecvBidiData(
    HANDLE                    hPrinter,
    LPCTSTR                   pAction,
    PBIDI_REQUEST_CONTAINER   pReqData,
    PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    return(ERROR_NOT_SUPPORTED);
}

BOOL
NullClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullClusterSplClose(
    HANDLE  hSpooler
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullClusterSplIsAlive(
    HANDLE hSpooler
    )
{
    SetLastError( RPC_S_PROCNUM_OUT_OF_RANGE );
    return FALSE;
}

BOOL
NullXcvData(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
        PDWORD  pdwStatus
)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}




//
// Note: If the providor structure changes to hold something other than
// an array of function pointers, FixupOldProvidor must be changed.
// We will get a compile time error in the definition of NullProvidor below
// if the structure changes.
//
PRINTPROVIDOR NullProvidor = {
    NullOpenPrinter,
    NullSetJob,
    NullGetJob,
    NullEnumJobs,
    NullAddPrinter,
    NullDeletePrinter,
    NullSetPrinter,
    NullGetPrinter,
    NullEnumPrinters,
    NullAddPrinterDriver,
    NullEnumPrinterDrivers,
    NullGetPrinterDriver,
    NullGetPrinterDriverDirectory,
    NullDeletePrinterDriver,
    NullAddPrintProcessor,
    NullEnumPrintProcessors,
    NullGetPrintProcessorDirectory,
    NullDeletePrintProcessor,
    NullEnumPrintProcessorDatatypes,
    NullStartDocPrinter,
    NullStartPagePrinter,
    NullWritePrinter,
    NullEndPagePrinter,
    NullAbortPrinter,
    NullReadPrinter,
    NullEndDocPrinter,
    NullAddJob,
    NullScheduleJob,
    NullGetPrinterData,
    NullSetPrinterData,
    NullWaitForPrinterChange,
    NullClosePrinter,
    NullAddForm,
    NullDeleteForm,
    NullGetForm,
    NullSetForm,
    NullEnumForms,
    NullEnumMonitors,
    NullEnumPorts,
    NullAddPort,
    NullConfigurePort,
    NullDeletePort,
    NullCreatePrinterIC,
    NullPlayGdiScriptOnPrinterIC,
    NullDeletePrinterIC,
    NullAddPrinterConnection,
    NullDeletePrinterConnection,
    NullPrinterMessageBox,
    NullAddMonitor,
    NullDeleteMonitor,
    NullResetPrinter,

    //
    // If GetPrinterDriverEx doesn't exist, we'll call the old one.
    // Don't stub out.
    //
    NULL,
    NullFindFirstPrinterChangeNotification,
    NullFindClosePrinterChangeNotification,
    NullAddPortEx,
    NullShutDown,
    NullRefreshPrinterChangeNotification,
    NullOpenPrinterEx,
    NullAddPrinterEx,
    NullSetPort,
    NullEnumPrinterData,
    NullDeletePrinterData,

    NullClusterSplOpen,
    NullClusterSplClose,
    NullClusterSplIsAlive,

    NullSetPrinterDataEx,
    NullGetPrinterDataEx,
    NullEnumPrinterDataEx,
    NullEnumPrinterKey,
    NullDeletePrinterDataEx,
    NullDeletePrinterKey,
    NullSeekPrinter,
    NullDeletePrinterDriverEx,
    NullAddPerMachineConnection,
    NullDeletePerMachineConnection,
    NullEnumPerMachineConnections,
    NullXcvData,
    NullAddPrinterDriverEx,
    NullSplReadPrinter,
    NullSplDriverUnloadComplete,
    NullGetSpoolFileHandle,
    NullCommitSpoolData,
    NullCloseSpoolFileHandle,
    NullFlushPrinter,
    NullSendRecvBidiData,
    NullAddDriverCatalog,
};


VOID
FixupOldProvidor(
    LPPRINTPROVIDOR pProvidor
    )
/*++

Routine Description:

    Fixup the providor function vector, adding stubs to any calls
    that were not implemented by the providor.

Arguments:

    pProvidor - Providor to fix up

Return Value:

Assumes:

    PRINTPROVIDOR structure is an array of function vectors, and
    nothing else.

--*/

{
    UINT i;
    FARPROC* pSource;
    FARPROC* pDest;

    for( i=0, pSource = (FARPROC*)&NullProvidor, pDest = (FARPROC*)pProvidor;
         i < sizeof( NullProvidor ) / sizeof( NullProvidor.fpOpenPrinter );
         i++, pSource++, pDest++ ){

        if( !*pDest ){

            *pDest = *pSource;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\reply.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Reply.c

Abstract:

    Handles all communication setup for RPC from the Server back
    to the Client.

    This implementation allows multiple reply handles for one print
    handle, but relies on serialized access to context handles on this
    machine.

Author:

    Albert Ting (AlbertT) 04-June-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntfytab.h"

PPRINTHANDLE pPrintHandleReplyList = NULL;
DWORD        dwRouterUniqueSessionID = 1;

DWORD
OpenReplyRemote(
    LPWSTR pszMachine,
    PHANDLE phNotifyRemote,
    DWORD dwPrinterRemote,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:

    Establishes a context handle from the server back to the client.
    RpcReplyOpenPrinter call will fail with access denied when the 
    client machine is in a different, un-trusted domain than the server.
    For that case, we'll continue impersonate and will try to make the call
    in the user context.However, if the client machine was previously joined
    the server's domain, but is now in another domain, the server can still successfully
    make the RPC call back to client.This scenario works because the client's mac address
    is still in the server's domain(even if the client's machine name changes). 
    
    We know that a call of RpcReplyOpenPrinter in the user context would succeed 
    in the case when the machines are in the same domain anyway.
    but for safety reasons we preffer to first try to make the call in the local system 
    context ( as it was until RC2 ) and only if it fails we try to make the call in user context.
      

Arguments:

    pszLocalMachine - Machine to talk to.

    phNotifyRemote - Remote context handle to set up

    dwPrinterRemote - remote printer handle we are talking to.

Return Value:

--*/

{
    DWORD dwReturn;
    HANDLE hToken;

    //
    // Stop impersonating: This prevents separate session ids from
    // being used.
    //
    hToken = RevertToPrinterSelf();

    //
    // If create a context handle to reply.
    //
    RpcTryExcept {

        dwReturn = RpcReplyOpenPrinter(
                       pszMachine,
                       phNotifyRemote,
                       dwPrinterRemote,
                       dwType,
                       cbBuffer,
                       pBuffer);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwReturn = RpcExceptionCode();

    } RpcEndExcept

    //
    // Resume impersonating.
    //
    ImpersonatePrinterClient(hToken);

#if DBG
    if (dwReturn) {
        DBGMSG(DBG_TRACE, ("1st OpenReplyRemote ERROR dwReturn = %d, hPrinterRemote = 0x%x\n",
                             dwReturn, dwPrinterRemote));
    }
#endif

    //
    // Try the rpc call in user context.
    //
    if (dwReturn) {

        RpcTryExcept {

            dwReturn = RpcReplyOpenPrinter(
                           pszMachine,
                           phNotifyRemote,
                           dwPrinterRemote,
                           dwType,
                           cbBuffer,
                           pBuffer);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwReturn = RpcExceptionCode();

        } RpcEndExcept

    }

#if DBG
    if (dwReturn) {
        DBGMSG(DBG_TRACE, ("2nd OpenReplyRemote ERROR dwReturn = %d, hPrinterRemote = 0x%x\n",
                             dwReturn, dwPrinterRemote));
    }
#endif

    return dwReturn;
}

VOID
CloseReplyRemote(
    HANDLE hNotifyRemote)
{
    HANDLE hToken;
    DWORD dwError;

    DBGMSG(DBG_NOTIFY, ("CloseReplyRemote requested: 0x%x\n",
                        hNotifyRemote));

    if (!hNotifyRemote)
        return;

    //
    // Stop impersonating: This prevents separate session ids from
    // being used.
    //
    hToken = RevertToPrinterSelf();

    RpcTryExcept {

        dwError = RpcReplyClosePrinter(
                      &hNotifyRemote);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = RpcExceptionCode();

    } RpcEndExcept

    //
    // Resume impersonating.
    //
    ImpersonatePrinterClient(hToken);

    if (dwError) {

        DBGMSG(DBG_WARNING, ("FCPCN:ReplyClose error %d, DestroyClientContext: 0x%x\n",
                             dwError,
                             hNotifyRemote));

        //
        // Error trying to close down the notification,
        // clear up our context.
        //
        RpcSmDestroyClientContext(&hNotifyRemote);
    }
}


BOOL
RouterReplyPrinter(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwChangeFlags,
    PDWORD pdwResult,
    DWORD dwReplyType,
    PVOID pBuffer)

/*++

Routine Description:

    Handle the notification coming in from a remote router (as
    opposed to a print providor).

Arguments:

    hNotify -- printer that changed, notification context handle

    dwColor -- indicates color of data

    fdwChangeFlags -- flags that changed

    pdwResult -- out DWORD result

    dwReplyType -- type of reply that is coming back

    pBuffer -- data based on dwReplyType

Return Value:

    BOOL  TRUE  = success
          FALSE = fail

--*/

{
    PNOTIFY pNotify = (PNOTIFY)hNotify;
    BOOL bReturn = FALSE;

    EnterRouterSem();

    if (!pNotify ||
        pNotify->signature != NOTIFYHANDLE_SIGNATURE ||
        !pNotify->pPrintHandle) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    DBGMSG(DBG_NOTIFY, ("RRP: Remote notification received: pNotify 0x%x, pPrintHandle 0x%x\n",
                        pNotify, pNotify->pPrintHandle));

    switch (pNotify->dwType) {
    case REPLY_TYPE_NOTIFICATION:

        SPLASSERT(dwReplyType == REPLY_PRINTER_CHANGE);

        bReturn = ReplyPrinterChangeNotificationWorker(
                      pNotify->pPrintHandle,
                      dwColor,
                      fdwChangeFlags,
                      pdwResult,
                      (PPRINTER_NOTIFY_INFO)pBuffer);
        break;

    default:

        DBGMSG(DBG_ERROR, ("RRPCN: Bogus notify 0x%x type: %d\n",
                           pNotify, pNotify->dwType));

        bReturn = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

Done:
    LeaveRouterSem();

    return bReturn;
}



/*------------------------------------------------------------------------

    Routines from here down occur on the client machine.

------------------------------------------------------------------------*/

VOID
FreePrinterHandleNotifys(
    PPRINTHANDLE pPrintHandle)
{
    PNOTIFY pNotify;
    RouterInSem();

#if 0
    DBGMSG(DBG_NOTIFY, ("FreePrinterHandleNotifys on 0x%x\n",
                        pPrintHandle));
#endif
    for(pNotify = pPrintHandle->pNotify;
        pNotify;
        pNotify = pNotify->pNext) {

        pNotify->pPrintHandle = NULL;
    }

    //
    // For safety, remove all replys.
    //
    RemoveReplyClient(pPrintHandle,
                      (DWORD)~0);
}

VOID
BeginReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType)
{
    RouterInSem();

    DBGMSG(DBG_NOTIFY, ("BeginReplyClient called 0x%x type %x (sig=0x%x).\n",
                        pPrintHandle, fdwType, pPrintHandle->signature));

    if (!pPrintHandle->fdwReplyTypes) {

        // Give a unique DWORD session ID for pPrintHandle
        while (pPrintHandle->dwUniqueSessionID == 0  ||
               pPrintHandle->dwUniqueSessionID == 0xffffffff) {

            pPrintHandle->dwUniqueSessionID = dwRouterUniqueSessionID++;
        }

        pPrintHandle->pNext = pPrintHandleReplyList;
        pPrintHandleReplyList = pPrintHandle;
    }

    pPrintHandle->fdwReplyTypes |= fdwType;
}

VOID
EndReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType)
{
    RouterInSem();
    DBGMSG(DBG_NOTIFY, ("EndReplyClient called 0x%x type %x.\n",
                        pPrintHandle, fdwType));
}

VOID
RemoveReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType)
{
    PPRINTHANDLE p;

    RouterInSem();

    DBGMSG(DBG_NOTIFY, ("RemoveReplyClient called 0x%x typed %x (sig=0x%x).\n",
                        pPrintHandle, fdwType, pPrintHandle->signature));

    //
    // Remove this reply type from the print handle.
    //
    pPrintHandle->fdwReplyTypes &= ~fdwType;

    //
    // If no replys remain, remove from linked list.
    //
    if (!pPrintHandle->fdwReplyTypes) {

        // Recover the unique session ID
        pPrintHandle->dwUniqueSessionID = 0;

        //
        // Remove from linked list.
        //
        if (pPrintHandleReplyList == pPrintHandle) {

            pPrintHandleReplyList = pPrintHandle->pNext;

        } else {

            for (p = pPrintHandleReplyList; p; p=p->pNext) {

                if (p->pNext == pPrintHandle) {

                    p->pNext = pPrintHandle->pNext;
                    return;
                }
            }
        }
    }
}


BOOL
ReplyOpenPrinter(
    DWORD dwPrinterHandle,
    PHANDLE phNotify,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:

    When sending a notification back from the print server to the
    client, we open up a notification context handle back on the client.
    This way, every time we send back a notification, we just use this
    context handle.

Arguments:

    dwPrinterHandle - printer handle valid here (on the client).  The spoolss.exe
               switches this around for us.

    phNotify - context handle to return to the remote print server.

    dwType - Type of notification

    cbBuffer - reserved for extra information passed

    pBuffer - reserved for extra information passed

Return Value:

    BOOL TRUE = success
         FALSE

--*/

{
    PPRINTHANDLE pPrintHandle;
    PNOTIFY      pNotify;
    BOOL         bReturnValue = FALSE;

    EnterRouterSem();

    //
    // Validate that we are waiting on this print handle.
    // We traverse the linked list to ensure that random bogus
    // hPrinters (which may point to garbage that looks valid)
    // are rejected.
    //

    for (pPrintHandle = pPrintHandleReplyList;
         pPrintHandle;
         pPrintHandle = pPrintHandle->pNext) {

        if (pPrintHandle->dwUniqueSessionID == dwPrinterHandle)
            break;
    }

    if (!pPrintHandle || !(pPrintHandle->fdwReplyTypes & dwType)) {

        DBGMSG(DBG_WARNING, ("ROPCN: Invalid printer handle 0x%x\n",
                             dwPrinterHandle));
        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    pNotify = AllocSplMem(sizeof(NOTIFY));

    if (!pNotify) {

        goto Done;
    }

    pNotify->signature = NOTIFYHANDLE_SIGNATURE;
    pNotify->pPrintHandle = pPrintHandle;
    pNotify->dwType = dwType;

    //
    // Add us to the list of Notifys.
    //
    pNotify->pNext = pPrintHandle->pNotify;
    pPrintHandle->pNotify = pNotify;

    DBGMSG(DBG_NOTIFY, ("ROPCN: Notification 0x%x (pPrintHandle 0x%x) set up\n",
                        pNotify,
                        pPrintHandle));

    *phNotify = (HANDLE)pNotify;
    bReturnValue = TRUE;

Done:
    LeaveRouterSem();

    return bReturnValue;
}


BOOL
ReplyClosePrinter(
    HANDLE hNotify)
{
    PNOTIFY pNotify = (PNOTIFY)hNotify;
    PNOTIFY pNotifyTemp;

    BOOL bReturnValue = FALSE;

    EnterRouterSem();

    if (!pNotify || pNotify->signature != NOTIFYHANDLE_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto Done;
    }

    if (pNotify->pPrintHandle) {

        //
        // Trigger a notification if the user is still watching the
        // handle.
        //
        ReplyPrinterChangeNotification(pNotify->pPrintHandle,
                                       PRINTER_CHANGE_FAILED_CONNECTION_PRINTER,
                                       NULL,
                                       NULL);
        //
        // Remove from notification list
        //
        if (pNotify->pPrintHandle->pNotify == pNotify) {

            pNotify->pPrintHandle->pNotify = pNotify->pNext;

        } else {

            for (pNotifyTemp = pNotify->pPrintHandle->pNotify;
                pNotifyTemp;
                pNotifyTemp = pNotifyTemp->pNext) {

                if (pNotifyTemp->pNext == pNotify) {
                    pNotifyTemp->pNext = pNotify->pNext;
                    break;
                }
            }
        }
    }

    DBGMSG(DBG_NOTIFY, ("RCPCN: Freeing notify: 0x%x (pPrintHandle 0x%x)\n",
                         pNotify,
                         pNotify->pPrintHandle));

    FreeSplMem(pNotify);
    bReturnValue = TRUE;

Done:
    LeaveRouterSem();

    return bReturnValue;
}


VOID
RundownPrinterNotify(
    HANDLE hNotify)

/*++

Routine Description:

    This is the rundown routine for notifications (the context handle
    for the print server -> client communication).  When the print server
    goes down, the context handle gets rundown on the client (now acting
    as an RPC server).  We should signal the user that something has
    changed.

Arguments:

    hNotify - Handle that has gone invalid

Return Value:

--*/

{
    PNOTIFY pNotify = (PNOTIFY)hNotify;

    DBGMSG(DBG_NOTIFY, ("Rundown called: 0x%x type %d\n",
                        pNotify,
                        pNotify->dwType));

    //
    // Notify the client that the printer has changed--it went away.
    // This should _always_ be a local event.
    //
    switch (pNotify->dwType) {

    case REPLY_TYPE_NOTIFICATION:

        ReplyPrinterChangeNotification((HANDLE)pNotify->pPrintHandle,
                                       PRINTER_CHANGE_FAILED_CONNECTION_PRINTER,
                                       NULL,
                                       NULL);

        ReplyClosePrinter(hNotify);
        break;

    default:

        //
        // This can legally occur on a pNotify that was reopened
        // (due to network error) and hasn't been used yet.
        // dwType should be reinitialized every time the pNotify
        // is used.
        //
        DBGMSG(DBG_ERROR, ("Rundown: unknown notify type %d\n",
                           pNotify->dwType));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\reghand.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation
All rights reserved

Module Name:

    reghand.c

Abstract:

    Processes that do impersonation should not attempt to open
    per-process aliases like HKEY_CURRENT_USER. HKEY_CURRENT_USER
    has meaning only for end user programs that run in the context
    of a single local user.

    Server processes should not depend on predefined handles or any
    other per process state. It should determine whether
    the user (client) being impersonated is local or remote.

Author:

    KrishnaG (20-May-93)

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

#define MAX_SID_STRING 256


//
// Function Declarations
//

BOOL
InitClientUserString(
    LPWSTR pString
    );

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    )

/*++

Routine Description:

Arguments:

Returns:

---*/

{
    HANDLE hKeyClient;
    WCHAR  String[MAX_SID_STRING];
    LONG   ReturnValue;

    if (!InitClientUserString(String)) {
        DBGMSG( DBG_WARNING, ("GetClientUserHandle InitClientUserString failed %d\n", GetLastError() ));
        return NULL ;
    }

    //
    // We now have the Unicode string representation of the
    // local client's Sid we'll use this string to open a handle
    // to the client's key in  the registry.

    ReturnValue = RegOpenKeyEx( HKEY_USERS,
                                String,
                                0,
                                samDesired,
                                &hKeyClient );

    //
    // If we couldn't get a handle to the local key
    // for some reason, return a NULL handle indicating
    // failure to obtain a handle to the key
    //

    if ( ReturnValue != ERROR_SUCCESS ) {
        DBGMSG( DBG_TRACE, ( "GetClientUserHandle failed %d\n", ReturnValue ));
        SetLastError( ReturnValue );
        return NULL;
    }

    return( hKeyClient );
}



BOOL
InitClientUserString (
    LPWSTR pString
    )

/*++

Routine Description:

Arguments:

    pString - output string of current user

Return Value:

    TRUE = success,
    FALSE = fail

    Returns in pString a ansi string if the impersonated client's
    SID can be expanded successfully into  Unicode string. If the conversion
    was unsuccessful, returns FALSE.

--*/

{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    BOOL        Status;
    DWORD       dwLastError;
    UNICODE_STRING UnicodeString;

    //
    // We can use OpenThreadToken because this server thread
    // is impersonating a client
    //
    Status = OpenThreadToken( GetCurrentThread(),
                              TOKEN_READ,
                              TRUE,                // Open as self
                              &TokenHandle
                              );

    if( Status == FALSE ) {
        DBGMSG(DBG_WARNING, ("InitClientUserString: OpenThreadToken failed: Error %d\n",
                             GetLastError()));
        return FALSE ;
    }

    //
    // Notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure
    //
    Status = GetTokenInformation( TokenHandle,
                                  TokenUser,
                                  TokenInformation,
                                  sizeof( TokenInformation ),
                                  &ReturnLength
                                   );
    dwLastError = GetLastError();
    CloseHandle( TokenHandle );

    if ( Status == FALSE ) {
        DBGMSG(DBG_WARNING, ("InitClientUserString: GetTokenInformation failed: Error %d\n",
                             dwLastError ));
        return FALSE;
    }

    //
    // Convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.
    //

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_SID_STRING;
    UnicodeString.Buffer = pString;

    Status = RtlConvertSidToUnicodeString(
                 &UnicodeString,
                 ((PTOKEN_USER)TokenInformation)->User.Sid,
                 FALSE );

    if( !NT_SUCCESS( Status )){
        DBGMSG( DBG_WARN,
                ( "InitClientUserString: RtlConvertSidToUnicodeString failed: Error %d\n",
                  Status ));
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for router.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef MODULE
#define MODULE "SPL:"
#define MODULE_DEBUG RouterDebug
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <excpt.h>
#include <string.h>

#include <windows.h>
#include <rpc.h>    // DataTypes and runtime APIs
#include <rpcasync.h>
#include <winspool.h>
#include <winsplp.h>
#include <winspl.h> // generated by the MIDL complier
#include <wininet.h>
#include <splcom.h>
#include <change.h>
#include <dbt.h>
#include "router.h"
#include "reply.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\reply.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    reply.h

Abstract:

    Header for RPC conversations initiated from the server to the client.

Author:

    Albert Ting (AlbertT) 04-June-94

Environment:

    User Mode -Win32

Revision History:

--*/

typedef struct _NOTIFY {
    DWORD        signature;         // Must be first (match _PRINTHANDLE) 6e6f
    PPRINTHANDLE pPrintHandle;
    PNOTIFY      pNext;
    DWORD        dwType;
} NOTIFY;


#define REPLY_TYPE_NULL         0
#define REPLY_TYPE_NOTIFICATION 1
#define REPLY_TYPE_BROWSE       2

extern  DWORD        dwRouterUniqueSessionID;

DWORD
OpenReplyRemote(
    LPWSTR pszMachine,
    PHANDLE phNotifyRemote,
    DWORD dwPrinterRemote,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer);

VOID
CloseReplyRemote(
    HANDLE hNotifyRemote);

BOOL
RouterReplyPrinter(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    DWORD dwReplyType,
    PVOID pBuffer);

VOID
FreePrinterHandleNotifys(
    PPRINTHANDLE pPrintHandle);

VOID
BeginReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType);

VOID
EndReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType);

VOID
RemoveReplyClient(
    PPRINTHANDLE pPrintHandle,
    DWORD fdwType);


//
// PrinterNotifyInfo related headers:
//


VOID
ClearPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo,
    PCHANGE pChange);

VOID
SetDiscardPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo,
    PCHANGE pChange);

DWORD
AppendPrinterNotifyInfo(
    PPRINTHANDLE pPrintHandle,
    DWORD dwColor,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo);

VOID
SetupPrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo,
    PCHANGE pChange);

BOOL
ReplyPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\router.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Router.h

Abstract:

    Holds defs for router

Author:

    Albert Ting (AlbertT) 18-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#if SPOOLER_HEAP
extern  HANDLE ghMidlHeap;
#endif

typedef enum _ESTATUSCHANGE {
    STATUS_CHANGE_EMPTY   = 0,      // One of these is valid,
    STATUS_CHANGE_FORMING = 1,      // but they still need x^2.
    STATUS_CHANGE_VALID   = 2,

    STATUS_CHANGE_CLOSING      =  0x000100, // bitfield
    STATUS_CHANGE_CLIENT       =  0x000200, // Event valid (local pChange)
    STATUS_CHANGE_ACTIVE       =  0x000400, // Currently processing or on LL
    STATUS_CHANGE_ACTIVE_REQ   =  0x000800, // Needs to go on Linked List
    STATUS_CHANGE_INFO         =  0x001000, // Info requested.
    STATUS_CHANGE_DISCARDED    =  0x008000, // Discard locally

    STATUS_CHANGE_DISCARDNOTED =  0x010000, // Discard noted on client
} ESTATUSCHANGE;


typedef struct _LINK *PLINK, *LPLINK;

typedef struct _LINK {
    PLINK pNext;
} LINK;

#if 1
VOID
LinkAdd(
    PLINK pLink,
    PLINK* ppLinkHead);
#else
#define LINKADDFAST
#define LinkAdd(pLink, ppLinkHead) \
{                                  \
    (pLink)->pNext = *(ppLinkHead);   \
    *(ppLinkHead) = (pLink);          \
}
#endif


VOID
LinkDelete(
    PLINK pLink,
    PLINK* ppLinkHead);

#define CLUSTERHANDLE_SIGNATURE 0x6262

typedef struct _PRINTHANDLE *PPRINTHANDLE, *LPPRINTHANDLE;

typedef struct _CHANGEINFO {
    LINK          Link;                  // Must be first item
    PPRINTHANDLE  pPrintHandle;
    DWORD         fdwOptions;
    DWORD         fdwFilterFlags;        // Original filter of flags to watch
    DWORD         fdwStatus;             // Status from providor
    DWORD         dwPollTime;
    DWORD         dwPollTimeLeft;
    BOOL          bResetPollTime;

    DWORD         fdwFlags;
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo;

} CHANGEINFO, *PCHANGEINFO;

typedef struct _CHANGE {
    LINK          Link;                  // Must be first item
    DWORD         signature;
    ESTATUSCHANGE eStatus;
    DWORD         dwColor;
    DWORD         cRef;
    LPWSTR        pszLocalMachine;
    CHANGEINFO    ChangeInfo;
    DWORD         dwCount;               // number of notifications
    HANDLE        hEvent;                // Event for local notification
    DWORD         fdwFlags;
    DWORD         fdwChangeFlags;        // Accumulated changes
    DWORD         dwPrinterRemote;       // Remote printer handle (ID only)
    HANDLE        hNotifyRemote;         // Remote notification handle
} CHANGE, *PCHANGE, *LPCHANGE;

#define CHANGEHANDLE_SIGNATURE 0x6368

typedef struct _NOTIFY *PNOTIFY, *LPNOTIFY;

#define NOTIFYHANDLE_SIGNATURE 0x6e6f

typedef struct _PROVIDOR {
    struct _PROVIDOR *pNext;
    LPWSTR lpName;
    HANDLE hModule;
    FARPROC fpInitialize;
    PRINTPROVIDOR PrintProvidor;
} PROVIDOR, *LPPROVIDOR;

typedef struct _PRINTHANDLE {
   DWORD        signature;       // Must be first (match _NOTIFY)
   LPPROVIDOR   pProvidor;
   HANDLE       hPrinter;
   PCHANGE      pChange;
   PNOTIFY      pNotify;
   PPRINTHANDLE pNext;           // List of handles waiting for replys
   DWORD        fdwReplyTypes;   // Types of replys being used.
   HANDLE       hFileSpooler;
   LPWSTR       szTempSpoolFile;
   LPWSTR       pszPrinter;
   DWORD        dwUniqueSessionID; // DWORD passed as a hprinter to remote machines
                                   // for notifications. Cant be 0 or 0xffffffff when in use.
} PRINTHANDLE;

#define PRINTHANDLE_SIGNATURE 0x6060

typedef struct _GDIHANDLE {
   DWORD        signature;
   LPPROVIDOR   pProvidor;
   HANDLE       hGdi;
} GDIHANDLE, *PGDIHANDLE, *LPGDIHANDLE;


#define GDIHANDLE_SIGNATURE 0x6161


typedef struct _ROUTERCACHE {
    LPWSTR   pPrinterName;
    BOOL    bAvailable;
    LPPROVIDOR pProvidor;
    SYSTEMTIME st;
} ROUTERCACHE, *PROUTERCACHE;



#define ROUTERCACHE_DEFAULT_MAX 16


LPPROVIDOR
FindEntryinRouterCache(
    LPWSTR pPrinterName
);


DWORD
AddEntrytoRouterCache(
    LPWSTR pPrinterName,
    LPPROVIDOR pProvidor
);

VOID
DeleteEntryfromRouterCache(
    LPWSTR pPrinterName
);

DWORD
RouterIsOlderThan(
    DWORD i,
    DWORD j
);

LPBYTE
CopyPrinterNameToPrinterInfo4(
    LPWSTR pServerName,
    LPWSTR pPrinterName,
    LPBYTE  pPrinter,
    LPBYTE  pEnd);

BOOL
RouterOpenPrinterW(
    LPWSTR              pPrinterName,
    HANDLE             *pHandle,
    LPPRINTER_DEFAULTS  pDefault,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel,
    BOOL                bLocalPrintProvidor
);

VOID
FixupOldProvidor(
    LPPRINTPROVIDOR pProvidor
    );

extern  BOOL     Initialized;
extern  DWORD    dwUpgradeFlag;
extern  CRITICAL_SECTION    RouterNotifySection;
extern  LPWSTR pszSelfMachine;
extern  HANDLE hEventInit;
extern  LPPROVIDOR pLocalProvidor;
extern  LPWSTR szEnvironment;
extern  LPWSTR szLocalSplDll;
extern  WCHAR *szDevices;
extern  LPWSTR szPrintKey;
extern  LPWSTR szRegistryProvidors;
extern  LPWSTR szOrder;
extern  DWORD gbFailAllocs;
extern  WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+3];
extern  SERVICE_STATUS_HANDLE   ghSplHandle;

LPWSTR
AppendOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

LPWSTR
RemoveOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
);

BOOL
WPCInit();

VOID
WPCDestroy();


BOOL
ThreadInit();

VOID
ThreadDestroy();

VOID
RundownPrinterChangeNotification(
    HANDLE hNotify);

VOID
FreePrinterHandle(
    PPRINTHANDLE pPrintHandle);

BOOL
FreeChange(
    PCHANGE pChange);

VOID
FreePrinterChangeInfo(
    PCHANGEINFO pChangeInfo);

BOOL
DeleteSubKeyTree(
    HKEY ParentHandle,
    WCHAR SubKeyName[]
    );


BOOL
ThreadNotify(
    LPPRINTHANDLE pPrintHandle);

BOOL
NotifyNeeded(
    PCHANGE pChange);


VOID
HandlePollNotifications();

DWORD
GetNetworkIdWorker(
    HKEY hKeyDevices,
    LPWSTR pDeviceName);

VOID
UpdateSignificantError(
    DWORD dwNewError,
    PDWORD pdwOldError
    );


#if DBG

VOID
EnterRouterSem();
VOID
LeaveRouterSem();

VOID
RouterInSem();
VOID
RouterOutSem();

#else

#define EnterRouterSem() EnterCriticalSection(&RouterNotifySection)
#define LeaveRouterSem() LeaveCriticalSection(&RouterNotifySection)

#define RouterInSem()
#define RouterOutSem()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\printer.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    printer.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"
#include "clusrout.h"
#include <offsets.h>


WCHAR szNoCache[] = L",NoCache";
WCHAR szProvidorValue[] = L"Provider";
WCHAR szRegistryConnections[] = L"Printers\\Connections";
WCHAR szServerValue[] = L"Server";

WCHAR szWin32spl[] = L"win32spl.dll";


//
// Router Cache Table
//
DWORD RouterCacheSize;

PROUTERCACHE RouterCacheTable;
CRITICAL_SECTION RouterCriticalSection;


//
// Forward prototypes
//

BOOL
EnumerateConnectedPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HKEY hKeyUser);

PPRINTER_INFO_2
pGetPrinterInfo2(
    HANDLE hPrinter
    );

BOOL
SavePrinterConnectionInRegistry(
    PPRINTER_INFO_2 pPrinterInfo2,
    LPPROVIDOR pProvidor
    );

BOOL
RemovePrinterConnectionInRegistry(
    LPWSTR pName);

DWORD
FindClosePrinterChangeNotificationWorker(
    HANDLE hPrinter);

VOID
RundownPrinterNotify(
    HANDLE hNotify);



BOOL
EnumPrintersW(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DWORD   cReturned, cbStruct, cbNeeded;
    DWORD   TotalcbNeeded = 0;
    DWORD   cTotalReturned = 0;
    DWORD   Error = ERROR_SUCCESS;
    PROVIDOR *pProvidor;
    DWORD   BufferSize=cbBuf;
    HKEY    hKeyUser;
    BOOL    bPartialSuccess = FALSE;

    if (pPrinterEnum==NULL && cbBuf!=0) 
    {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    switch (Level)
    {
    case STRESSINFOLEVEL:
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (Level==4 && (Flags & PRINTER_ENUM_CONNECTIONS)) 
    {
        //
        // The router will handle info level_4 for connected printers.
        //
        Flags &= ~PRINTER_ENUM_CONNECTIONS;

        if (hKeyUser = GetClientUserHandle(KEY_READ)) 
        {
            if (!EnumerateConnectedPrinters(pPrinterEnum,
                                            BufferSize,
                                            &TotalcbNeeded,
                                            &cTotalReturned,
                                            hKeyUser)) 
            {
                Error = GetLastError();
            } 
            else 
            {
                bPartialSuccess = TRUE;
            }

            RegCloseKey(hKeyUser);

        } 
        else 
        {
            Error = GetLastError();
        }

        pPrinterEnum += cTotalReturned * cbStruct;

        if (TotalcbNeeded <= BufferSize)
            BufferSize -= TotalcbNeeded;
        else
            BufferSize = 0;
    }
    
    for (pProvidor = pLocalProvidor; pProvidor; ) 
    {
        cReturned = 0;
        cbNeeded  = 0;

        if (!(*pProvidor->PrintProvidor.fpEnumPrinters) (Flags, Name, Level,
                                                         pPrinterEnum,
                                                         BufferSize,
                                                         &cbNeeded,
                                                         &cReturned)) 
        {
            Error = GetLastError();

            if (Error==ERROR_INSUFFICIENT_BUFFER) 
            {
                TotalcbNeeded += cbNeeded;
                BufferSize     = 0;
            }            
        } 
        else 
        {
            bPartialSuccess  = TRUE;
            TotalcbNeeded   += cbNeeded;
            cTotalReturned  += cReturned;
            pPrinterEnum    += cReturned * cbStruct;
            BufferSize      -= cbNeeded;
        }
        
        if ((Flags & PRINTER_ENUM_NAME) && Name && (Error!=ERROR_INVALID_NAME))
            pProvidor = NULL;
        else
            pProvidor = pProvidor->pNext;
    }

    *pcbNeeded  = TotalcbNeeded;
    *pcReturned = cTotalReturned;

    //
    // Allow partial returns
    //
    if (bPartialSuccess)
        Error = ERROR_SUCCESS;

    if (TotalcbNeeded > cbBuf)
        Error = ERROR_INSUFFICIENT_BUFFER;

    SetLastError(Error);

    return Error==ERROR_SUCCESS;   
}

BOOL
EnumerateConnectedPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HKEY hClientKey
    )

/*++

Routine Description:

    Handles info level four enumeration.

Arguments:

Return Value:

--*/

{
    HKEY    hKey1=NULL;
    HKEY    hKeyPrinter;
    DWORD   cPrinters, cchData;
    WCHAR   PrinterName[MAX_UNC_PRINTER_NAME];
    WCHAR   ServerName[MAX_UNC_PRINTER_NAME];
    DWORD   cReturned, cbRequired, cbNeeded, cTotalReturned;
    DWORD   Error=0;
    PWCHAR  p;
    LPBYTE  pEnd;

    DWORD cbSize;
    BOOL  bInsufficientBuffer = FALSE;

    if((Error = RegOpenKeyEx(hClientKey, szRegistryConnections, 0,
                 KEY_READ, &hKey1))!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        return(FALSE);
    }

    cPrinters=0;

    cchData = COUNTOF(PrinterName);

    cTotalReturned = 0;

    cReturned = cbNeeded = 0;

    cbRequired = 0;

    pEnd = pPrinter + cbBuf;
    while (RegEnumKeyEx(hKey1, cPrinters, PrinterName, &cchData,
                        NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

        //
        // Fetch server name.  Open the key and read it
        // from the "Server" field.
        //
        Error = RegOpenKeyEx(hKey1,
                             PrinterName,
                             0,
                             KEY_READ,
                             &hKeyPrinter);

        if( Error == ERROR_SUCCESS ){

            cbSize = sizeof(ServerName);

            Error = RegQueryValueEx(hKeyPrinter,
                                    szServerValue,
                                    NULL,
                                    NULL,
                                    (LPBYTE)ServerName,
                                    &cbSize);

            RegCloseKey(hKeyPrinter);

        }

        if( Error == ERROR_SUCCESS ){

            //
            // Force NULL termination of ServerName.
            //
            ServerName[COUNTOF(ServerName)-1] = 0;

        } else {

            //
            // On error condition, try and extract the server name
            // based on the printer name.  Pretty ugly...
            //

            wcscpy(ServerName, PrinterName);

            p = wcschr(ServerName+2, ',');
            if (p)
                *p = 0;
        }

        FormatRegistryKeyForPrinter(PrinterName, PrinterName);

        if (MyUNCName(PrinterName))     // don't enumerate local printers!
        {
            cPrinters++;
            cchData = COUNTOF(PrinterName);
            continue;
        }

        //
        // At this stage we don't care about opening the printers
        // We just want to enumerate the names; in effect we're
        // just reading HKEY_CURRENT_USER and returning the
        // contents; we will copy the name of the printer and we will
        // set its attributes to NETWORK and !LOCAL
        //
        cbRequired = sizeof(PRINTER_INFO_4) +
                     wcslen(PrinterName)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(ServerName)*sizeof(WCHAR) + sizeof(WCHAR);

        if (cbBuf >= cbRequired) {

            //
            // copy it in
            //
            DBGMSG(DBG_TRACE,
                   ("cbBuf %d cbRequired %d PrinterName %ws\n", cbBuf, cbRequired, PrinterName));

            pEnd = CopyPrinterNameToPrinterInfo4(ServerName,
                                                 PrinterName,
                                                 pPrinter,
                                                 pEnd);
            //
            // Fill in any in structure contents
            //
            pPrinter += sizeof(PRINTER_INFO_4);

            //
            // Increment the count of structures copied
            //
            cTotalReturned++;

            //
            // Reduce the size of the buffer by amount required
            //
            cbBuf -= cbRequired;

            //
            // Keep track of the total ammount required.
            //
        } else {

            cbBuf = 0;
            bInsufficientBuffer = TRUE;
        }

        cbNeeded += cbRequired;
        cPrinters++;
        cchData = COUNTOF(PrinterName);
    }

    RegCloseKey(hKey1);

    *pcbNeeded = cbNeeded;
    *pcReturned = cTotalReturned;

    if (bInsufficientBuffer) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}

LPBYTE
CopyPrinterNameToPrinterInfo4(
    LPWSTR pServerName,
    LPWSTR pPrinterName,
    LPBYTE  pPrinter,
    LPBYTE  pEnd)
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_4)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPPRINTER_INFO_4 pPrinterInfo=(LPPRINTER_INFO_4)pPrinter;
    DWORD   *pOffsets;

    pOffsets = PrinterInfo4Strings;

    *pSourceStrings++=pPrinterName;
    *pSourceStrings++=pServerName;

    pEnd = PackStrings(SourceStrings,
                       (LPBYTE) pPrinterInfo,
                       pOffsets,
                       pEnd);

    pPrinterInfo->Attributes = PRINTER_ATTRIBUTE_NETWORK;

    return pEnd;
}

LPPROVIDOR
FindProvidorFromConnection(
    LPWSTR pszPrinter
    )

/*++

Routine Description:

    Looks in the current user's Printer\Connections to see if a printer
    is there, and returns which provider that owns it.

    Note: this will always fail if the pszPrinter is a share name.

Arguments:

    pszPrinter - Printer to search.

Return Value:

    pProvidor - Provider that own's it.
    NULL - none found.

--*/

{
    PWCHAR pszKey = NULL;
    DWORD  cchSize = MAX_UNC_PRINTER_NAME + COUNTOF( szRegistryConnections );

    WCHAR szProvidor[MAX_PATH];
    DWORD cbProvidor;
    LPWSTR pszKeyPrinter;
    LONG Status;

    LPPROVIDOR pProvidor = NULL;

    HKEY hKeyClient = NULL;
    HKEY hKeyPrinter = NULL;

    SPLASSERT(pszPrinter);

    if ( pszPrinter && wcslen(pszPrinter) + 1 < MAX_UNC_PRINTER_NAME ) {
        
        if(pszKey = AllocSplMem(cchSize * sizeof(WCHAR))) {

            //
            // Prepare to read in
            // HKEY_CURRENT_USER:\Printer\Connections\,,server,printer
            //

            wcscpy( pszKey, szRegistryConnections );

            //
            // Find the end of this key so we can append the registry-formatted
            // printer name to it.
            //
            pszKeyPrinter = &pszKey[ COUNTOF( szRegistryConnections ) - 1 ];
            *pszKeyPrinter++ = L'\\';

            FormatPrinterForRegistryKey( pszPrinter, pszKeyPrinter );

            if( hKeyClient = GetClientUserHandle(KEY_READ)){

                Status = RegOpenKeyEx( hKeyClient,
                                       pszKey,
                                       0,
                                       KEY_READ,
                                       &hKeyPrinter );

                if( Status == ERROR_SUCCESS ){
                    
                    cbProvidor = sizeof( szProvidor );

                    Status = RegQueryValueEx( hKeyPrinter,
                                              szProvidorValue,
                                              NULL,
                                              NULL,
                                              (LPBYTE)szProvidor,
                                              &cbProvidor );

                    if( Status == ERROR_SUCCESS ){                        
                        //
                        // Scan through all providers, trying to match dll string.
                        //
                        for( pProvidor = pLocalProvidor; pProvidor; pProvidor = pProvidor->pNext ){

                            if( !_wcsicmp( pProvidor->lpName, szProvidor )){
                                break;
                            }
                        } 
                    }

                    RegCloseKey( hKeyPrinter );
                }
                
                RegCloseKey( hKeyClient );

            }
            FreeSplMem(pszKey);
        }        
    }

    return pProvidor;
}


VOID
UpdateSignificantError(
    DWORD dwNewError,
    PDWORD pdwOldError
    )
/*++

Routine Description:

    Determines whether the new error code is more "important"
    than the previous one in cases where we continue routing.

Arguments:

    dwNewError - New error code that occurred.

    pdwOldError - Pointer to previous significant error.
                  This is updated if a significant error occurs

Return Value:

--*/

{
    //
    // Error code must be non-zero or else it will look
    // like success.
    //
    SPLASSERT(dwNewError);

    //
    // If we have no significant error yet and we have one now,
    // keep it.
    //
    if (*pdwOldError == ERROR_INVALID_NAME    &&
        dwNewError                            &&
        dwNewError != WN_BAD_NETNAME          &&
        dwNewError != ERROR_BAD_NETPATH       &&
        dwNewError != ERROR_NOT_SUPPORTED     &&
        dwNewError != ERROR_REM_NOT_LIST      &&
        dwNewError != ERROR_INVALID_LEVEL     &&
        dwNewError != ERROR_INVALID_PARAMETER &&
        dwNewError != ERROR_INVALID_NAME      &&
        dwNewError != WN_BAD_LOCALNAME) {

        *pdwOldError = dwNewError;
    }

    return;
}


BOOL
OpenPrinterPortW(
    LPWSTR  pPrinterName,
    HANDLE *pHandle,
    LPPRINTER_DEFAULTS pDefault
    )
/*++

Routine Description:

    This routine is exactly the same as OpenPrinterW,
    except that it doesn't call the local provider.
    This is so that the local provider can open a network printer
    with the same name as the local printer without getting
    into a loop.

Arguments:

Return Value:

--*/

{
    //
    // We will set bLocalPrintProvidor = FALSE here
    //
    return(RouterOpenPrinterW(pPrinterName,
                              pHandle,
                              pDefault,
                              NULL,
                              0,
                              FALSE));
}

BOOL
OpenPrinterW(
    LPWSTR              pPrinterName,
    HANDLE             *pHandle,
    LPPRINTER_DEFAULTS  pDefault
    )
{

    //
    // We will set bLocalPrintProvidor = TRUE here
    //
    return(RouterOpenPrinterW(pPrinterName,
                              pHandle,
                              pDefault,
                              NULL,
                              0,
                              TRUE));
}


BOOL
OpenPrinterExW(
    LPWSTR                  pPrinterName,
    HANDLE                 *pHandle,
    LPPRINTER_DEFAULTS      pDefault,
    PSPLCLIENT_CONTAINER    pSplClientContainer
    )
{
    BOOL   bReturn = FALSE;
    DWORD  dwLevel = 0;

    if (pSplClientContainer) {
        dwLevel = pSplClientContainer->Level;
    }

    //
    // We will set bLocalPrintProvidor = TRUE here
    //

    switch (dwLevel) {

    case 1:
             bReturn = RouterOpenPrinterW(pPrinterName,
                                          pHandle,
                                          pDefault,
                                          (LPBYTE) (pSplClientContainer->ClientInfo.pClientInfo1),
                                          1,
                                          TRUE);
             break;

    case 2:
             bReturn = RouterOpenPrinterW(pPrinterName,
                                          pHandle,
                                          pDefault,
                                          NULL,
                                          0,
                                          TRUE);

             if (pSplClientContainer) {
                 if (bReturn) {
                     pSplClientContainer->ClientInfo.pClientInfo2->hSplPrinter = (ULONG_PTR) *pHandle;
                 } else {
                     pSplClientContainer->ClientInfo.pClientInfo2->hSplPrinter = 0;
                 }
             }

             break;

    default:
             break;
    }

    return bReturn;
}


DWORD
TryOpenPrinterAndCache(
    LPPROVIDOR          pProvidor,
    LPWSTR              pszPrinterName,
    PHANDLE             phPrinter,
    LPPRINTER_DEFAULTS  pDefault,
    PDWORD              pdwFirstSignificantError,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )

/*++

Routine Description:

    Attempt to open the printer using the providor.  If there is
    an error, update the dwFirstSignificantError variable.  If the
    providor "knows" the printer (either a success, or ROUTER_STOP_ROUTING),
    then update the cache.

Arguments:

    pProvidor - Providor to try

    pszPrinterName - Name of printer that will be sent to the providor

    phPrinter - Receives printer handle on ROUTER_SUCCESS

    pDefault - Defaults used to open printer

    pdwFirstSignificantError - Pointer to DWORD to get updated error.
        This gets updated on ROUTER_STOP_ROUTING or ROUTER_UNKNOWN.

Return Value:

    ROUTER_* status code:

    ROUTER_SUCCESS, phPrinter holds return handle, name cached
    ROUTER_UNKNOWN, printer not recognized, error updated
    ROUTER_STOP_ROUTING, printer recognized, but failure, error updated

--*/

{
    DWORD OpenError;

    OpenError = (*pProvidor->PrintProvidor.fpOpenPrinterEx)
                                        (pszPrinterName,
                                         phPrinter,
                                         pDefault,
                                         pSplClientInfo,
                                         dwLevel);

    if (( OpenError == ROUTER_UNKNOWN && GetLastError() == ERROR_NOT_SUPPORTED ) ||
        OpenError == ERROR_NOT_SUPPORTED )

        OpenError = (*pProvidor->PrintProvidor.fpOpenPrinter)
                                        (pszPrinterName,
                                         phPrinter,
                                         pDefault);

    if( OpenError == ROUTER_SUCCESS ||
        OpenError == ROUTER_STOP_ROUTING ){

        //
        // Now add this entry into the cache.  We never cache
        // the local providor.
        //
        EnterRouterSem();

        if (!FindEntryinRouterCache(pszPrinterName)) {
            AddEntrytoRouterCache(pszPrinterName, pProvidor);
        }

        LeaveRouterSem();
    }

    if( OpenError != ROUTER_SUCCESS ){
        UpdateSignificantError(GetLastError(), pdwFirstSignificantError);
    }

    return OpenError;
}

BOOL
RouterOpenPrinterW(
    LPWSTR              pszPrinterNameIn,
    HANDLE             *pHandle,
    LPPRINTER_DEFAULTS  pDefault,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel,
    BOOL                bLocalProvidor
    )

/*++

Routine Description:

    Routes the OpenPrinter{Port} call.  This checks the local providor
    first (if bLocalProvidor TRUE), the the cache, and finally all the
    non-local providors.

    To open a printer, the following steps are taken:

        1. Check localspl
           This must be done to ensure that masq printers are handled
           correctly (see comment below in code).

        2. Check cache
           This will speed up most of the connections, since OpenPrinters
           tend to be clumped together.

        3. Check registry under connections
           If this is a connected printer, first try the providor
           that granted the connection.

        4. Check provider order
           This is the last resort, since it is the slowest.

Arguments:

    pPrinterName - Name of printer to open

    pHandle - Handle to receive open printer.  If the open was not
        successful, this value may be modified!

    pDefault - Default attributes of the open.

    pSplClientInfo - Pointer ClientInfox structure

    dwLevel - Level of the ClientInfo structure
    bLocalProvidor TRUE  = OpenPrinterW called, check localspl first.
                   FALSE = OpenPrinterPortW called, don't check localspl.

Return Value:

    TRUE = success
    FALSE = fail,  GetLastError indicates error (must be non-zero!)

--*/

{
    BOOL bReturn = TRUE;
    DWORD dwFirstSignificantError = ERROR_INVALID_NAME;
    LPPROVIDOR  pProvidor;
    LPPROVIDOR  pProvidorAlreadyTried = NULL;
    PPRINTHANDLE pPrintHandle;
    HANDLE  hPrinter;
    DWORD OpenError;
    BOOL bRemoveFromCache = FALSE;
    PRINTER_DEFAULTS Default;
    PDEVMODE pDevModeFree = NULL;
    PWSTR pszPrinterName = pszPrinterNameIn;
    PWSTR pszNoCache;

    //
    // Max name we allow for printers is MAX_UNC_PRINTER_NAME.
    // Providers can use suffixes only for OpenPrinter (not for Add/Set)
    //
    if ( pszPrinterName &&
         wcslen(pszPrinterName) + 1 > MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX ) {

        SetLastError(ERROR_INVALID_PRINTER_NAME);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    // There may be a ",NoCache" appended to the printer name.
    // We only want to send this NoCache name to win32spl, so make
    // a regular name here.
    if (pszPrinterName) {
        pszNoCache = wcsstr(pszPrinterNameIn, szNoCache);
        if (pszNoCache) {
            pszPrinterName = AllocSplStr(pszPrinterNameIn);

            if (!pszPrinterName) {
                DBGMSG(DBG_WARNING, ("RouterOpenPrinter - Failed to alloc pszPrinterName.\n"));
                return FALSE;
            }
            pszPrinterName[pszNoCache - pszPrinterNameIn] = L'\0';
        }
    }

    pPrintHandle = AllocSplMem(sizeof(PRINTHANDLE));

    if (!pPrintHandle) {

        DBGMSG(DBG_WARNING, ("RouterOpenPrinter - Failed to alloc print handle.\n"));

        if (pszPrinterName != pszPrinterNameIn) {
            FreeSplStr(pszPrinterName);
            pszPrinterName = pszPrinterNameIn;
        }
        return FALSE;
    }

    if( pszPrinterName ){
        pPrintHandle->pszPrinter = AllocSplStr( pszPrinterName );

        if (!pPrintHandle->pszPrinter) {

            DBGMSG(DBG_WARNING, ("RouterOpenPrinter - Failed to alloc print name.\n"));

            if (pszPrinterName != pszPrinterNameIn) {
                FreeSplStr(pszPrinterName);
                pszPrinterName = pszPrinterNameIn;
            }

            FreePrinterHandle( pPrintHandle );
            return FALSE;
        }
    }

    //
    // Retrieve the per-user DevMode.  This must be done at the router
    // instead of the provider, since the per-user DevMode is only available
    // on the client.  It also must be here instead of client side, since
    // spooler components will make this call also.
    //
    if( !pDefault || !pDefault->pDevMode ){

        //
        // No default specified--get the per-user one.
        //
        if( bGetDevModePerUser( NULL, pszPrinterName, &pDevModeFree ) &&
            pDevModeFree ){

            if( pDefault ){

                Default.pDatatype = pDefault->pDatatype;
                Default.DesiredAccess = pDefault->DesiredAccess;

            } else {

                Default.pDatatype = NULL;
                Default.DesiredAccess = 0;

            }

            Default.pDevMode = pDevModeFree;

            //
            // Now switch to use the temp structure.
            //
            pDefault = &Default;
        }
    }

    //
    // We must check the local print providor first in
    // the masquerading case.
    //
    // For example, when a Netware printer is opened:
    //
    // 1. First OpenPrinter to the Netware printer will succeed
    //    if it has been cached.
    //
    // 2. We create a local printer masquerading as a network printer.
    //
    // 3. Second OpenPrinter must open local masquerading printer.
    //    If we hit the cache, we will go to the Netware providor,
    //    and we will never use the masquerading printer.
    //
    // For this reason, we will not cache local printers in the
    // RouterCache.  The RouterCache will only containing Network
    // Print Providers, i.e., Win32spl NwProvAu and other such providers.
    //
    // Also, we must always check the local printprovidor since
    // DeletePrinter will be called on a false connect and
    // we need to delete the local network printer rather
    // than the remote printer.  When we get rid of the false
    // connect case, we go directly to the cache.
    //
    if (bLocalProvidor) {

        pProvidor = pLocalProvidor;

        OpenError = (*pProvidor->PrintProvidor.fpOpenPrinterEx)
                        (pszPrinterName, &hPrinter, pDefault,
                         pSplClientInfo, dwLevel);

        if (OpenError == ROUTER_SUCCESS) {
            goto Success;
        }

        UpdateSignificantError(GetLastError(), &dwFirstSignificantError);

        if (OpenError == ROUTER_STOP_ROUTING) {
            goto StopRouting;
        }
    }

    //
    // Now check the cache.
    //
    EnterRouterSem();
    pProvidor = FindEntryinRouterCache(pszPrinterName);
    LeaveRouterSem();

    if (pProvidor) {

        OpenError = (*pProvidor->PrintProvidor.fpOpenPrinterEx)
                                (pszPrinterName,
                                 &hPrinter,
                                 pDefault,
                                 pSplClientInfo,
                                 dwLevel);

        if (( OpenError == ROUTER_UNKNOWN && GetLastError() == ERROR_NOT_SUPPORTED ) ||
              OpenError == ERROR_NOT_SUPPORTED ){

            OpenError = (*pProvidor->PrintProvidor.fpOpenPrinter)
                                (pszPrinterName,
                                 &hPrinter,
                                 pDefault);
        }

        if (OpenError == ROUTER_SUCCESS) {
            goto Success;
        }

        UpdateSignificantError(GetLastError(), &dwFirstSignificantError);

        if (OpenError == ROUTER_STOP_ROUTING) {
            goto StopRouting;
        }

        //
        // Wasn't claimed by above providor, so remove from cache.
        // If a providor returns ROUTER_STOP_ROUTING, then it states
        // that it is the sole owner of the printer name (i.e.,
        // it has been recognized but can't be opened, and can't
        // be accessed by other providors).  Therefore we keep
        // it in the cache.
        //
        bRemoveFromCache = TRUE;

        //
        // Don't try this providor again below.
        //
        pProvidorAlreadyTried = pProvidor;
    }

    //
    // Not in the cache.  Check if it is in the registry under
    // connections.
    //
    pProvidor = FindProvidorFromConnection( pszPrinterName );

    //
    // If we want to remove it from the cache, do so here.  Note
    // we only remove it if we failed above, AND the connection wasn't
    // originally established using the provider.
    //
    // If the connection fails, but that provider "owns" the printer
    // connection, leave it in the cache since we won't try other providers.
    //
    if( bRemoveFromCache && pProvidor != pProvidorAlreadyTried ){

        EnterRouterSem();
        DeleteEntryfromRouterCache(pszPrinterName);
        LeaveRouterSem();
    }

    if( pProvidor ){

        //
        // If we already tried this providor, don't try it again.
        //
        if( pProvidor != pProvidorAlreadyTried ){

            OpenError = TryOpenPrinterAndCache( pProvidor,
                                                pszPrinterName,
                                                &hPrinter,
                                                pDefault,
                                                &dwFirstSignificantError,
                                                pSplClientInfo,
                                                dwLevel);

            if( OpenError == ROUTER_SUCCESS ){
                goto Success;
            }
        }

        //
        // We stop routing at this point!  If a user wants to go with
        // another providor, they need to remove the connection then
        // re-establish it.
        //
        goto StopRouting;
    }

    //
    // Check all non-localspl providors.
    //
    for (pProvidor = pLocalProvidor->pNext;
         pProvidor;
         pProvidor = pProvidor->pNext) {

        if( pProvidor == pProvidorAlreadyTried ){

            //
            // We already tried this providor, and it failed.
            //
            continue;
        }

        // Use ",NoCache" only if Provider is win32spl
        OpenError = TryOpenPrinterAndCache( pProvidor,
                                            _wcsicmp(pProvidor->lpName, szWin32spl) ?
                                            pszPrinterName : pszPrinterNameIn,
                                            &hPrinter,
                                            pDefault,
                                            &dwFirstSignificantError,
                                            pSplClientInfo,
                                            dwLevel);

        switch( OpenError ) {
            case ROUTER_SUCCESS:
                goto Success;
            case ROUTER_STOP_ROUTING:
                goto StopRouting;
        }
    }

StopRouting:

    //
    // Did not find a providor, return the error.
    //
    FreePrinterHandle( pPrintHandle );

    //
    // Set using first significant error.  If there was no signifcant
    // error, we use ERROR_INVALID_PRINTER_NAME.
    //
    SPLASSERT(dwFirstSignificantError);

    if (dwFirstSignificantError == ERROR_INVALID_NAME)
        dwFirstSignificantError = ERROR_INVALID_PRINTER_NAME;

    SetLastError(dwFirstSignificantError);

    bReturn = FALSE;

Success:

    if( bReturn ){

        pPrintHandle->signature = PRINTHANDLE_SIGNATURE;
        pPrintHandle->pProvidor = pProvidor;
        pPrintHandle->hPrinter = hPrinter;
        pPrintHandle->hFileSpooler = INVALID_HANDLE_VALUE;
        pPrintHandle->szTempSpoolFile = NULL;
        pPrintHandle->dwUniqueSessionID = 0;

        *pHandle = (HANDLE)pPrintHandle;
    }

    FreeSplMem( pDevModeFree );

    if (pszPrinterName != pszPrinterNameIn)
        FreeSplStr(pszPrinterName);

    return bReturn;
}


BOOL
ResetPrinterW(
    HANDLE  hPrinter,
    LPPRINTER_DEFAULTS pDefault)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pDefault) {
        if (pDefault->pDatatype == (LPWSTR)-1 ||
            pDefault->pDevMode == (LPDEVMODE)-1) {

            if (!wcscmp(pPrintHandle->pProvidor->lpName, szLocalSplDll)) {
                return (*pPrintHandle->pProvidor->PrintProvidor.fpResetPrinter)
                                                            (pPrintHandle->hPrinter,
                                                             pDefault);
            } else {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        } else {
            return (*pPrintHandle->pProvidor->PrintProvidor.fpResetPrinter)
                                                        (pPrintHandle->hPrinter,
                                                         pDefault);
        }
    } else {
        return (*pPrintHandle->pProvidor->PrintProvidor.fpResetPrinter)
                                                    (pPrintHandle->hPrinter,
                                                     pDefault);
    }
}

HANDLE
AddPrinterExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pClientInfo,
    DWORD   dwLevel
    )
{
    LPPROVIDOR      pProvidor;
    DWORD           dwFirstSignificantError = ERROR_INVALID_NAME;
    HANDLE          hPrinter;
    PPRINTHANDLE    pPrintHandle;
    LPWSTR          pPrinterName = NULL;
    LPWSTR          pszServer = NULL;

    WaitForSpoolerInitialization();

    if ( pPrinter ) {

        switch ( Level ) {

            case 1:
                pPrinterName = ((PPRINTER_INFO_1)pPrinter)->pName;
                break;

            case 2:
                pPrinterName = ((PPRINTER_INFO_2)pPrinter)->pPrinterName;
                pszServer = ((PPRINTER_INFO_2)pPrinter)->pServerName;
                break;

            default:
                break;
        }

        //
        // Name length (plus null terminator) and server
        // name (plus backslash) length check.
        //
        if (( pPrinterName && wcslen(pPrinterName) + 1 > MAX_PRINTER_NAME ) ||
            ( pszServer && wcslen(pszServer) > (MAX_UNC_PRINTER_NAME - MAX_PRINTER_NAME - 1))) {

            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }
    }

    pPrintHandle = AllocSplMem(sizeof(PRINTHANDLE));

    if (!pPrintHandle) {

        DBGMSG( DBG_WARNING, ("Failed to alloc print handle."));
        goto Fail;
    }

    if( pPrinterName ){

        WCHAR szFullPrinterName[MAX_UNC_PRINTER_NAME];
        szFullPrinterName[0] = 0;

        if( pszServer ){
            wcscpy( szFullPrinterName, pszServer );
            wcscat( szFullPrinterName, L"\\" );
        }

        wcscat( szFullPrinterName, pPrinterName );

        pPrintHandle->pszPrinter = AllocSplStr( szFullPrinterName );

        if( !pPrintHandle->pszPrinter ){
            goto Fail;
        }
    }

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        hPrinter = (HANDLE)(*pProvidor->PrintProvidor.fpAddPrinterEx)
                                           (pName,
                                            Level,
                                            pPrinter,
                                            pClientInfo,
                                            dwLevel);

        if ( !hPrinter && GetLastError() == ERROR_NOT_SUPPORTED ) {

            hPrinter = (HANDLE)(*pProvidor->PrintProvidor.fpAddPrinter)
                                                   (pName,
                                                    Level,
                                                    pPrinter);
        }

        if ( hPrinter ) {

            //
            // CLS
            //
            // !! HACK !!
            //
            // Make (HANDLE)-1 ROUTER_STOP_ROUTING.
            //
            if( hPrinter == (HANDLE)-1 ){

                UpdateSignificantError(GetLastError(), &dwFirstSignificantError);
                break;
            }

            pPrintHandle->signature = PRINTHANDLE_SIGNATURE;
            pPrintHandle->pProvidor = pProvidor;
            pPrintHandle->hPrinter = hPrinter;
            pPrintHandle->hFileSpooler = INVALID_HANDLE_VALUE;
            pPrintHandle->szTempSpoolFile = NULL;
            pPrintHandle->dwUniqueSessionID = 0;

            return (HANDLE)pPrintHandle;

        }

        UpdateSignificantError(GetLastError(), &dwFirstSignificantError);

        pProvidor = pProvidor->pNext;
    }

    UpdateSignificantError(ERROR_INVALID_PRINTER_NAME, &dwFirstSignificantError);
    SetLastError(dwFirstSignificantError);

Fail:

    if( pPrintHandle ){

        FreeSplStr( pPrintHandle->pszPrinter );
        FreeSplMem(pPrintHandle);
    }

    return FALSE;
}

HANDLE
AddPrinterW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter
    )
{

    return AddPrinterExW(pName, Level, pPrinter, NULL, 0);
}


BOOL
DeletePrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinter)(pPrintHandle->hPrinter);
}

BOOL
AddPrinterConnectionW(
    LPWSTR  pName
)
{
    DWORD dwLastError;
    HANDLE hPrinter;
    HKEY   hClientKey = NULL;
    BOOL   rc = FALSE;
    LPPRINTER_INFO_2 pPrinterInfo2;
    LPPRINTHANDLE  pPrintHandle;

    WaitForSpoolerInitialization();

    //
    // If the printer connection being made is \\server\sharename,
    // this may be different from the \\server\printername.
    // Make sure we have the real name, so that we can be consistent
    // in the registry.
    //
    if (!OpenPrinter(pName,
                     &hPrinter,
                     NULL)) {

        return FALSE;
    }

    pPrinterInfo2 = pGetPrinterInfo2( hPrinter );
    pPrintHandle = (LPPRINTHANDLE)hPrinter;

    if( pPrinterInfo2 ){

        if ((*pPrintHandle->pProvidor->PrintProvidor.
            fpAddPrinterConnection)(pPrinterInfo2->pPrinterName)) {

            if( SavePrinterConnectionInRegistry(
                pPrinterInfo2,
                pPrintHandle->pProvidor )){

                rc = TRUE;

            } else {

                dwLastError = GetLastError();
                (*pPrintHandle->pProvidor->PrintProvidor.
                    fpDeletePrinterConnection)(pPrinterInfo2->pPrinterName);

                SetLastError(dwLastError);
            }
        }
        FreeSplMem(pPrinterInfo2);
    }

    dwLastError = GetLastError();
    ClosePrinter(hPrinter);
    SetLastError(dwLastError);

    return rc;
}


BOOL
DeletePrinterConnectionW(
    LPWSTR  pName
)
{
    BOOL                bRet  = FALSE;
    BOOL                bDone = FALSE;
    HANDLE              hPrinter;

    //
    // If pName is empty string, all providers will fail with ERROR_INVALID_NAME
    // and we will delete the registry key. For empty string, it will
    // delete all subkeys under Printers\\Connections. Fix it by checking 
    // pName against empty string.
    //
    if (pName && *pName) 
    {
        WaitForSpoolerInitialization();

        //
        // Adding the code required to succeed DeletePrinterConnection
        // with a Share name
        //

        if(OpenPrinter(pName,&hPrinter,NULL))
        {
            DWORD            PrntrInfoSize=0,PrntrInfoSizeReq=0;
            PPRINTER_INFO_2  pPrinterInfo2 = NULL;

            if(!GetPrinter(hPrinter,
                           2,
                           (LPBYTE)pPrinterInfo2,
                           PrntrInfoSize,
                           &PrntrInfoSizeReq)                                                      &&
               (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                                       &&
               (pPrinterInfo2 = (PPRINTER_INFO_2)AllocSplMem((PrntrInfoSize = PrntrInfoSizeReq)))  &&
               GetPrinter(hPrinter,
                          2,
                          (LPBYTE)pPrinterInfo2,
                          PrntrInfoSize,
                          &PrntrInfoSizeReq))
            {
                PPRINTHANDLE pPrintHandle;
                pPrintHandle = (PPRINTHANDLE)hPrinter;

                if((bRet = (*pPrintHandle->
                           pProvidor->
                           PrintProvidor.
                           fpDeletePrinterConnection)(pPrinterInfo2->pPrinterName)))
                {
                    bRet  = RemovePrinterConnectionInRegistry(pPrinterInfo2->pPrinterName);
                    bDone = TRUE;
                }
            }

            if(hPrinter)
                ClosePrinter(hPrinter);

            if(pPrinterInfo2)
                FreeSplMem(pPrinterInfo2);
        }
        else
        {
            LPPROVIDOR pProvidor;
            pProvidor = pLocalProvidor;

            if (pName && (wcslen(pName) < MAX_PRINTER_NAME))
            {
                for(pProvidor=pLocalProvidor;
                    pProvidor && (GetLastError()!=ERROR_INVALID_NAME) &&!bDone;
                    pProvidor = pProvidor->pNext)

                {

                    if(bRet =  (*pProvidor->PrintProvidor.fpDeletePrinterConnection)(pName))
                    {
                        bRet = RemovePrinterConnectionInRegistry(pName);
                        bDone = TRUE;
                    }
                }
            }
            else
            {
                SetLastError(ERROR_INVALID_PRINTER_NAME);
                bDone = TRUE;
            }

        }

        //
        // If all providors failed with ERROR_INVALID_NAME then try to delete
        // from registry
        //
        if(!bDone && (GetLastError()==ERROR_INVALID_NAME))
        {
            if(!(bRet = RemovePrinterConnectionInRegistry(pName)))
            {
                SetLastError(ERROR_INVALID_PRINTER_NAME);
            }
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PRINTER_NAME);
    }
    
    return bRet;
}

BOOL
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;
    LPWSTR          pPrinterName = NULL;
    PDEVMODE        pDevModeRestore = NULL;
    BOOL bReturn;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ( pPrinter ) {

        switch (Level) {
            case 2:
                pPrinterName = ((PPRINTER_INFO_2)pPrinter)->pPrinterName;
                break;

            case 4:
                pPrinterName = ((PPRINTER_INFO_4)pPrinter)->pPrinterName;
                break;

            case 5:
                pPrinterName = ((PPRINTER_INFO_5)pPrinter)->pPrinterName;
                break;
        }

        if ( pPrinterName &&
             wcslen(pPrinterName) + 1 > MAX_PRINTER_NAME ) {

            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }
    }

    switch( Level ){
    case 8:
    {
        //
        // Setting the global DevMode.
        //
        PPRINTER_INFO_8 pPrinterInfo8 = (PPRINTER_INFO_8)pPrinter;
        PPRINTER_INFO_2 pPrinterInfo2;
        DWORD rc = FALSE;;

        if( Command != 0 ){
            SetLastError( ERROR_INVALID_PRINTER_COMMAND );
            return FALSE;
        }

        //
        // Call GetPrinter then SetPrinter.
        //
        pPrinterInfo2 = pGetPrinterInfo2( hPrinter );

        if( pPrinterInfo2 ){

            //
            // Set the DevMode, and also clear the security descriptor
            // so that the set will succeed.
            //
            pPrinterInfo2->pDevMode = pPrinterInfo8->pDevMode;
            pPrinterInfo2->pSecurityDescriptor = NULL;

            rc = (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinter) (
                     pPrintHandle->hPrinter,
                     2,
                     (PBYTE)pPrinterInfo2,
                     Command );

            FreeSplMem( pPrinterInfo2 );
        }

        return rc;
    }
    case 9:
    {
        PPRINTER_INFO_9 pPrinterInfo9 = (PPRINTER_INFO_9)pPrinter;

        //
        // Setting the per-user DevMode.
        //

        if( !pPrinter ){
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if( Command != 0 ){
            SetLastError( ERROR_INVALID_PRINTER_COMMAND );
            return FALSE;
        }

        if( !IsLocalCall( )){
            SetLastError( ERROR_NOT_SUPPORTED );
            return FALSE;
        }

        return bSetDevModePerUser( NULL,
                                   pPrintHandle->pszPrinter,
                                   pPrinterInfo9->pDevMode );
    }
    case 2:
    {
        PPRINTER_INFO_2 pPrinterInfo2 = (PPRINTER_INFO_2)pPrinter;

        if( IsLocalCall( )){

            if( pPrinterInfo2 && pPrinterInfo2->pDevMode ){
                bSetDevModePerUser( NULL,
                                    pPrintHandle->pszPrinter,
                                    pPrinterInfo2->pDevMode );

                //
                // Don't set the global DevMode.
                //
                pDevModeRestore = pPrinterInfo2->pDevMode;
                pPrinterInfo2->pDevMode = NULL;
            }
        }
    }
    default:
        break;
    }

    bReturn = (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinter)
                  (pPrintHandle->hPrinter, Level, pPrinter, Command);

    if( pDevModeRestore ){
        ((PPRINTER_INFO_2)pPrinter)->pDevMode = pDevModeRestore;
    }

    return bReturn;
}

BOOL
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    PDEVMODE pDevModeSrc = NULL;
    PDEVMODE pDevModeDest = NULL;
    PDEVMODE pDevModeFree = NULL;
    BOOL bCallServer = TRUE;
    BOOL bReturnValue = FALSE;
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    DWORD cbDevModeSrc;
    DWORD Error;
    DWORD cbExtraSpace2 = 0;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pPrinter == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    switch( Level ){
    case 2:

        if( pPrintHandle->pszPrinter && IsLocalCall( )){

            bGetDevModePerUser( NULL,
                                pPrintHandle->pszPrinter,
                                &pDevModeFree );

            if( pDevModeFree ){

                pDevModeSrc = pDevModeFree;

                cbDevModeSrc = pDevModeSrc->dmSize +
                               pDevModeSrc->dmDriverExtra;

                cbExtraSpace2 = DWORD_ALIGN_UP( cbDevModeSrc );
                cbBuf = DWORD_ALIGN_DOWN( cbBuf );
            }
        }
        break;

    case 8:
    {
        PPRINTER_INFO_8 pPrinterInfo8 = (PPRINTER_INFO_8)pPrinter;

        //
        // Handle info level 8 calls for global DevModes.
        //
        if( !pPrintHandle->pszPrinter ){

            SetLastError( ERROR_FILE_NOT_FOUND );
            return FALSE;
        }

        bCallServer = FALSE;
        *pcbNeeded = sizeof( PRINTER_INFO_8 );

        //
        // Call GetPrinter to get the real DevMode.
        //
        pPrinterInfo2 = pGetPrinterInfo2( hPrinter );

        if( pPrinterInfo2 ){

            //
            // Pickup the DevMode from pPrinterInfo2;
            // destination is after the pDevModeStructure.
            // Don't need to free pDevModeSrc since it will be
            // freed when pPrinterInfo2 is released.
            //
            pDevModeSrc = pPrinterInfo2->pDevMode;

            if( pDevModeSrc ){

                cbDevModeSrc = pDevModeSrc->dmSize +
                               pDevModeSrc->dmDriverExtra;

                *pcbNeeded += cbDevModeSrc;
            }

            if( cbBuf < *pcbNeeded ){

                //
                // Not enough space.  SetLastError and fall through
                // to the end.
                //
                SetLastError( ERROR_INSUFFICIENT_BUFFER );

            } else {

                bReturnValue = TRUE;

                if( pDevModeSrc ){

                    //
                    // Update the pointer and indicate via pDevModeDest
                    // that we need to copy the DevMode in.
                    //
                    pDevModeDest = (PDEVMODE)&pPrinterInfo8[1];
                    pPrinterInfo8->pDevMode = pDevModeDest;

                } else {

                    //
                    // No DevMode, return pointer to NULL.
                    //
                    pPrinterInfo8->pDevMode = NULL;
                }
            }
        }

        break;
    }
    case 9:
    {
        //
        // Per-user DevMode.  Use the client side one.
        //

        PPRINTER_INFO_9 pPrinterInfo9 = (PPRINTER_INFO_9)pPrinter;

        if( !pPrintHandle->pszPrinter ){
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        if( !IsLocalCall( )){

            SetLastError( ERROR_NOT_SUPPORTED );
            return FALSE;
        }

        bCallServer = FALSE;

        *pcbNeeded = sizeof( PRINTER_INFO_9 );

        if( bGetDevModePerUserEvenForShares( NULL,
                                             pPrintHandle->pszPrinter,
                                             &pDevModeFree )){

            pDevModeSrc = pDevModeFree;

            if( pDevModeSrc ){

                cbDevModeSrc = pDevModeSrc->dmSize +
                               pDevModeSrc->dmDriverExtra;

                *pcbNeeded += cbDevModeSrc;
            }
        }

        if( cbBuf < *pcbNeeded ){

            //
            // Not enough space.  We'll fall through below
            // and fail.
            //
            SetLastError( ERROR_INSUFFICIENT_BUFFER );

        } else {

            bReturnValue = TRUE;

            if( pDevModeSrc ){

                pDevModeDest = (PDEVMODE)&pPrinterInfo9[1];
                pPrinterInfo9->pDevMode = pDevModeDest;

            } else {

                //
                // No per-user DevMode.  Return SUCCESS, but indicate
                // no DevMode available.
                //
                pPrinterInfo9->pDevMode = NULL;
            }
        }
        break;
    }
    default:
        break;
    }

    if( bCallServer ){

        DWORD cbAvailable;

        //
        // Allocate extra space at the end for the per-user DevMode,
        // in case there isn't a global devmode in the printer info 2
        // structure.
        //
        cbAvailable = ( cbBuf >= cbExtraSpace2 ) ?
                          cbBuf - cbExtraSpace2 :
                          0;

        bReturnValue = (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinter)
                           (pPrintHandle->hPrinter, Level, pPrinter,
                            cbAvailable, pcbNeeded);

        *pcbNeeded += cbExtraSpace2;
    }

    Error = GetLastError();

    if( Level == 9 && pDevModeSrc == NULL){

        PPRINTER_INFO_2 pInfo2 = (PPRINTER_INFO_2)pPrinter;

        if( pInfo2 && pInfo2->pDevMode ){

            pDevModeSrc = pInfo2->pDevMode;

        }
    }

    //
    // Special case INFO level 2, since we want to get the provider's
    // information, but then we also want the per-user DevMode.
    //
    // Only do this for local calls.
    //
    if( cbExtraSpace2 ){

        PPRINTER_INFO_2 pInfo2 = (PPRINTER_INFO_2)pPrinter;

        //
        // If we succeeded and we have a buffer, then we need to check if we
        // need to put the per-user DevMode at the end of the buffer.
        //
        if( pInfo2 && bReturnValue ){

            //
            // If we have no DevMode, or it's compatible, then we want to
            // use the per-user DevMode.
            //
            if( !pInfo2->pDevMode ||
                bCompatibleDevMode( pPrintHandle,
                                    pInfo2->pDevMode,
                                    pDevModeSrc )){

                pDevModeDest = (PDEVMODE)(pPrinter + cbBuf - cbExtraSpace2 );
                pInfo2->pDevMode = pDevModeDest;

            } else {

                //
                // !! POLICY !!
                //
                // Not compatible with per-user DevMode.  Delete the
                // per-user one.
                //
                bSetDevModePerUser( NULL, pPrintHandle->pszPrinter, NULL );
            }
        }
    }

    //
    // Check if we need to copy over a DevMode.
    //
    if( pDevModeDest ){

        //
        // Update the DevMode.
        //
        CopyMemory( (PVOID)pDevModeDest,
                    (PVOID)pDevModeSrc,
                    cbDevModeSrc );

        bReturnValue = TRUE;
    }

    FreeSplMem( pDevModeFree );
    FreeSplMem( pPrinterInfo2 );

    SetLastError( Error );

    return bReturnValue;
}


DWORD
GetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterData)(pPrintHandle->hPrinter,
                                                        pValueName,
                                                        pType,
                                                        pData,
                                                        nSize,
                                                        pcbNeeded);
}

DWORD
GetPrinterDataExW(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDataEx)(pPrintHandle->hPrinter,
                                                        pKeyName,
                                                        pValueName,
                                                        pType,
                                                        pData,
                                                        nSize,
                                                        pcbNeeded);
}

DWORD
EnumPrinterDataW(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,        // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,    // address for size of value buffer
    LPDWORD pType,            // address of buffer for type code
    LPBYTE  pData,            // address of buffer for value data
    DWORD   cbData,            // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumPrinterData)(pPrintHandle->hPrinter,
                                                        dwIndex,
                                                        pValueName,
                                                        cbValueName,
                                                        pcbValueName,
                                                        pType,
                                                        pData,
                                                        cbData,
                                                        pcbData);
}

DWORD
EnumPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumPrinterDataEx)(pPrintHandle->hPrinter,
                                                        pKeyName,
                                                        pEnumValues,
                                                        cbEnumValues,
                                                        pcbEnumValues,
                                                        pnEnumValues);
}


DWORD
EnumPrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey        // address for size of value buffer
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumPrinterKey)(pPrintHandle->hPrinter,
                                                        pKeyName,
                                                        pSubkey,
                                                        cbSubkey,
                                                        pcbSubkey);
}



DWORD
DeletePrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinterData)(pPrintHandle->hPrinter,
                                                                         pValueName);
}


DWORD
DeletePrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinterDataEx)(pPrintHandle->hPrinter,
                                                                         pKeyName,
                                                                         pValueName);
}


DWORD
DeletePrinterKeyW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeletePrinterKey)(pPrintHandle->hPrinter,
                                                                        pKeyName);

}



DWORD
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinterData)(pPrintHandle->hPrinter,
                                                        pValueName,
                                                        Type,
                                                        pData,
                                                        cbData);
}


DWORD
SetPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetPrinterDataEx)(pPrintHandle->hPrinter,
                                                                        pKeyName,
                                                                        pValueName,
                                                                        Type,
                                                                        pData,
                                                                        cbData);
}



DWORD
WaitForPrinterChange(
   HANDLE   hPrinter,
   DWORD    Flags
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpWaitForPrinterChange)
                                        (pPrintHandle->hPrinter, Flags);
}

BOOL
ClosePrinter(
   HANDLE hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    EnterRouterSem();

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        LeaveRouterSem();
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Close any notifications on this handle.
    //
    // The local case cleans up the event, while the remote
    // case potentially cleans up the Reply Notification context
    // handle.
    //
    // We must close this first, since the Providor->ClosePrinter
    // call removes data structures that FindClose... relies on.
    //
    // Client side should be shutdown by winspool.drv.
    //
    if (pPrintHandle->pChange &&
        (pPrintHandle->pChange->eStatus & STATUS_CHANGE_VALID)) {

        FindClosePrinterChangeNotificationWorker(hPrinter);
    }

    LeaveRouterSem();

    if ((*pPrintHandle->pProvidor->PrintProvidor.fpClosePrinter) (pPrintHandle->hPrinter)) {

        //
        // We can't just free it, since there may be a reply waiting
        // on it.
        //
        FreePrinterHandle(pPrintHandle);
        return TRUE;

    } else

        return FALSE;
}



/* FormatPrinterForRegistryKey
 *
 * Returns a pointer to a copy of the source string with backslashes removed.
 * This is to store the printer name as the key name in the registry,
 * which interprets backslashes as branches in the registry structure.
 * Convert them to commas, since we don't allow printer names with commas,
 * so there shouldn't be any clashes.
 * If there are no backslashes, the string is unchanged.
 */
LPWSTR
FormatPrinterForRegistryKey(
    LPCWSTR pSource,    /* The string from which backslashes are to be removed. */
    LPWSTR pScratch     /* Scratch buffer for the function to write in;     */
    )                   /* must be at least as long as pSource.             */
{
    LPWSTR p;

    if (pScratch != pSource) {

        //
        // Copy the string into the scratch buffer:
        //
        wcscpy(pScratch, pSource);
    }

    //
    // Check each character, and, if it's a backslash,
    // convert it to a comma:
    //
    for (p = pScratch; *p; ++p) {
        if (*p == L'\\')
            *p = L',';
    }

    return pScratch;
}


/* FormatRegistryKeyForPrinter
 *
 * Returns a pointer to a copy of the source string with backslashes added.
 * This must be the opposite of FormatPrinterForRegistryKey, so the mapping
 * _must_ be 1-1.
 *
 * If there are no commas, the string is unchanged.
 */
LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,     /* The string from which backslashes are to be added. */
    LPWSTR pScratch     /* Scratch buffer for the function to write in;     */
    )                   /* must be at least as long as pSource.             */
{
    /* Copy the string into the scratch buffer:
     */
    wcscpy(pScratch, pSource);

    /* Check each character, and, if it's a backslash,
     * convert it to a comma:
     */
    for (pSource = pScratch; *pSource; pSource++) {
        if (*pSource == L',')
            *pSource = L'\\';
    }

    return pScratch;
}


/* SavePrinterConnectionInRegistry
 *
 * Saves data in the registry for a printer connection.
 * Creates a key under the current impersonation client's key
 * in the registry under \Printers\Connections.
 * The printer name is stripped of backslashes, since the registry
 * API does not permit the creation of keys with backslashes.
 * They are replaced by commas, which are invalid characters
 * in printer names, so we should never get one passed in.
 *
 *
 * *** WARNING ***
 *
 * IF YOU MAKE CHANGES TO THE LOCATION IN THE REGISTRY
 * WHERE PRINTER CONNECTIONS ARE STORED, YOU MUST MAKE
 * CORRESPONDING CHANGES IN USER\USERINIT\USERINIT.C.
 *
 */
BOOL
SavePrinterConnectionInRegistry(
    PPRINTER_INFO_2 pPrinterInfo2,
    LPPROVIDOR pProvidor
    )
{
    HKEY    hClientKey = NULL;
    HKEY    hConnectionsKey;
    HKEY    hPrinterKey;
    DWORD   Status;
    BOOL    rc = FALSE;
    LPCTSTR pszProvidor = pProvidor->lpName;
    PWSTR   pKeyName = NULL;
    DWORD   cchSize = MAX_PATH;
    DWORD   dwError;

    //
    // CLS
    //
    // If the provider is localspl, change it to win32spl.dll.
    // This is required for clustering since localspl handles printer
    // connections, but they should be "owned" by win32spl.dll.  When
    // Someone opens a printer that they are connected to, we will
    // always hit localspl.dll first before we look at this entry.
    //
    // When the cluster is remote, then they need to go through win32spl.dll.
    //
    if( pProvidor == pLocalProvidor ){
        pszProvidor = szWin32spl;
    }

    hClientKey = GetClientUserHandle(KEY_READ);

    if (hClientKey) {

        if (wcslen(pPrinterInfo2->pPrinterName) < cchSize &&
            (pKeyName = AllocSplMem(cchSize * sizeof(WCHAR)))) {

            Status = RegCreateKeyEx(hClientKey, szRegistryConnections,
                                    REG_OPTION_RESERVED, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE, NULL, &hConnectionsKey, NULL);

            if (Status == NO_ERROR) {

                /* Make a key name without backslashes, so that the
                 * registry doesn't interpret them as branches in the registry tree:
                 */
                FormatPrinterForRegistryKey(pPrinterInfo2->pPrinterName,
                                            pKeyName);

                Status = RegCreateKeyEx(hConnectionsKey, pKeyName, REG_OPTION_RESERVED,
                                        NULL, 0, KEY_WRITE, NULL, &hPrinterKey, NULL);

                if (Status == NO_ERROR) {

                    RegSetValueEx(hPrinterKey,
                                  szServerValue,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pPrinterInfo2->pServerName,
                                  (lstrlen(pPrinterInfo2->pServerName)+1) *
                                  sizeof(pPrinterInfo2->pServerName[0]));

                    Status = RegSetValueEx(hPrinterKey,
                                           szProvidorValue,
                                           0,
                                           REG_SZ,
                                           (LPBYTE)pszProvidor,
                                           (lstrlen(pszProvidor)+1) *
                                               sizeof(pszProvidor[0]));

                    if (Status == ERROR_SUCCESS) {

                        dwError = UpdatePrinterRegUser(hClientKey,
                                                       NULL,
                                                       pPrinterInfo2->pPrinterName,
                                                       NULL,
                                                       UPDATE_REG_CHANGE);

                        if (dwError == ERROR_SUCCESS) {

                            BroadcastMessage(BROADCAST_TYPE_MESSAGE,
                                             WM_WININICHANGE,
                                             0,
                                             (LPARAM)szDevices);

                            rc = TRUE;

                        } else {

                            DBGMSG(DBG_TRACE, ("UpdatePrinterRegUser failed: Error %d\n",
                                               dwError));
                        }

                    } else {

                        DBGMSG(DBG_WARNING, ("RegSetValueEx(%ws) failed: Error %d\n",
                               pszProvidor, Status));

                        rc = FALSE;
                    }

                    RegCloseKey(hPrinterKey);

                } else {

                    DBGMSG(DBG_WARNING, ("RegCreateKeyEx(%ws) failed: Error %d\n",
                                         pKeyName, Status ));
                    rc = FALSE;
                }

                RegCloseKey(hConnectionsKey);

            } else {

                DBGMSG(DBG_WARNING, ("RegCreateKeyEx(%ws) failed: Error %d\n",
                                     szRegistryConnections, Status ));
                rc = FALSE;
            }


            if (!rc) {

                DBGMSG(DBG_WARNING, ("Error updating registry: %d\n",
                                     GetLastError())); /* This may not be the error */
                                                       /* that caused the failure.  */
                if (pKeyName)
                    RegDeleteKey(hClientKey, pKeyName);
            }

            FreeSplMem(pKeyName);
        }

        RegCloseKey(hClientKey);
    }

    return rc;
}

BOOL
RemovePrinterConnectionInRegistry(
    LPWSTR pName)
{
    HKEY    hClientKey;
    HKEY    hPrinterConnectionsKey;
    DWORD   Status = NO_ERROR;
    DWORD   i = 0;
    PWSTR   pKeyName = NULL;
    DWORD   cchSize = MAX_PATH;
    BOOL    Found = FALSE;
    BOOL    bRet = FALSE;

    if (pName && 
        wcslen(pName) < cchSize) {

        if (pKeyName = AllocSplMem(cchSize * sizeof(WCHAR))) {
        
            hClientKey = GetClientUserHandle(KEY_READ);


            if (hClientKey) {

                Status = RegOpenKeyEx(hClientKey, szRegistryConnections,
                                      REG_OPTION_RESERVED,
                                      KEY_READ | KEY_WRITE, &hPrinterConnectionsKey);

                if (Status == NO_ERROR) {

                    FormatPrinterForRegistryKey(pName, pKeyName);
                    bRet = DeleteSubKeyTree(hPrinterConnectionsKey, pKeyName);

                    RegCloseKey(hPrinterConnectionsKey);
                }

                if ( bRet ) {

                    UpdatePrinterRegUser(hClientKey,
                                         NULL,
                                         pName,
                                         NULL,
                                         UPDATE_REG_DELETE);
                }

                RegCloseKey(hClientKey);

                if ( bRet ) {

                    BroadcastMessage(BROADCAST_TYPE_MESSAGE,
                                     WM_WININICHANGE,
                                     0,
                                     (LPARAM)szDevices);
                }
            }

            FreeSplMem(pKeyName);
        }
    }

    return bRet;
}

VOID
PrinterHandleRundown(
    HANDLE hPrinter)
{
    LPPRINTHANDLE pPrintHandle;

    if (hPrinter) {

        pPrintHandle = (LPPRINTHANDLE)hPrinter;

        switch (pPrintHandle->signature) {

        case PRINTHANDLE_SIGNATURE:

            // Log warning to detect handle free
            DBGMSG(DBG_WARNING, ("PrinterHandleRundown: 0x%x 0x%x", pPrintHandle, pPrintHandle->hPrinter));

            DBGMSG(DBG_TRACE, ("Rundown PrintHandle 0x%x\n", hPrinter));
            ClosePrinter(hPrinter);
            break;

        case NOTIFYHANDLE_SIGNATURE:

            DBGMSG(DBG_TRACE, ("Rundown NotifyHandle 0x%x\n", hPrinter));
            RundownPrinterNotify(hPrinter);
            break;

        case CLUSTERHANDLE_SIGNATURE:

            DBGMSG(DBG_TRACE, ("Rundown ClusterHandle 0x%x\n", hPrinter ));
            ClusterSplClose(hPrinter);
            break;

        default:

            //
            // Unknown type.
            //
            DBGMSG( DBG_ERROR, ("Rundown: Unknown type 0x%x\n", hPrinter ) );
            break;
        }
    }
    return;
}

BOOL
ValidatePrinterName(
    LPWSTR   pPrinterName)

/*++
Function Description: Validates the fully qualified printer name. Performs the following checks
                      1) Length < MAX_UNC_PRINTER_NAME
                      2) No invalid chars in the names \,!
                      3) No empty names after removing trailing blanks

Parameters: pPrinterName  -  printer name

Return Values: TRUE if valid name; FALSE otherwise
--*/

{
    DWORD  dwLength;
    LPWSTR pWack, pTemp, pLastSpace;
    WCHAR  szServer[MAX_UNC_PRINTER_NAME], szPrinter[MAX_UNC_PRINTER_NAME];

    // Make length checks
    dwLength = wcslen( pPrinterName );
    if ( dwLength < 5  || dwLength > MAX_UNC_PRINTER_NAME )
    {
        return FALSE;
    }

    // Search for invalid characters , and !
    if ( wcschr( pPrinterName, L',' ) ||
         wcschr( pPrinterName, L'!' )  )
    {
        return FALSE;
    }

    // Search for exactly 3 wacks
    if ( (pPrinterName[0] != L'\\') ||
         (pPrinterName[1] != L'\\') ||
         !(pWack = wcschr( pPrinterName+2, L'\\' )) ||
         wcschr( pWack+1, L'\\' ) )
    {
        return FALSE;
    }

    // Check for empty server or printer names
    wcsncpy( szServer, pPrinterName+2, (size_t) (pWack - (pPrinterName+2)) );
    szServer[pWack - (pPrinterName+2)] = L'\0';

    wcsncpy( szPrinter, pWack+1, dwLength - (size_t) ((pWack+1 - pPrinterName)) );
    szPrinter[dwLength - (pWack+1 - pPrinterName)] = L'\0';

    // Remove trailing spaces in the server name
    for (pLastSpace = NULL, pTemp = szServer; pTemp && *pTemp; ++pTemp)
    {
        if (*pTemp == L' ') {
            if (!pLastSpace) {
                pLastSpace = pTemp;
            }
        } else {
            pLastSpace = NULL;
        }
    }

    if (pLastSpace) {
        *pLastSpace = L'\0';
    }

    // Remove trailing spaces in the printer name
    for (pLastSpace = NULL, pTemp = szPrinter; pTemp && *pTemp; ++pTemp)
    {
        if (*pTemp == L' ') {
            if (!pLastSpace) {
                pLastSpace = pTemp;
            }
        } else {
            pLastSpace = NULL;
        }
    }

    if (pLastSpace) {
        *pLastSpace = L'\0';
    }

    if (!*szServer || !*szPrinter) {
        return FALSE;
    }

    return TRUE;
}

BOOL
RouterAddPerMachineConnection(
    LPCWSTR   pPrinterNameP,
    LPCWSTR   pPrintServerP,
    LPCWSTR   pProviderP)

/*++
Function Description: RouterAddPerMachineConnection adds a subkey to HKEY_LOCAL_MACHINE\
                      SYSTEM\CurrentControlSet\Control\Print\Connections with the PrinterName.
                      The PrintServer name and the name of the dll used as a provider for
                      this connection are stored as values in the key.

Parameters:
            pPrinterNameP - pointer to the fully qualified printer name. (\\printserver\name)
            pPrintServerP - pointer to the print server name.
            pProviderP - pointer to the provider name. Currently only LanMan Print Services
                         is supported. This corresponds to win32spl.dll. NULL or szNULL value
                         defaults to this provider. Currently there is no check to enforce that
                         only LanMan Print Services is passed.

Return Value: TRUE for success
              FALSE otherwise.
--*/

{
    BOOL   bReturn = TRUE;
    DWORD  dwLocalConnection = 1, dwLastError, dwType, cbBuf;

    HKEY   hMcConnectionKey = NULL, hPrinterKey = NULL;
    HKEY   hProviderKey = NULL, hAllProviderKey = NULL;
    HANDLE hImpersonationToken = NULL;

    LPWSTR pPrintServer=NULL, pProvider=NULL, pPrinterName=NULL, pEnd;
    WCHAR  szConnData[MAX_PATH];
    WCHAR  szRegistryConnections[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";
    WCHAR  szRegistryProviders[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Providers";

   EnterRouterSem();

    // Getting the name of the library for the provider.
    if (!pProviderP || !*pProviderP) {

       pProvider = AllocSplStr(L"win32spl.dll");

    } else {

       cbBuf = sizeof(szConnData);

       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryProviders, 0,
                        KEY_READ, &hAllProviderKey) ||
           RegOpenKeyEx(hAllProviderKey, pProviderP, 0, KEY_READ,
                        &hProviderKey) ||
           RegQueryValueEx(hProviderKey, L"Name", 0, &dwType,
                           (LPBYTE)szConnData,&cbBuf))  {

            SetLastError(ERROR_INVALID_PARAMETER);
            bReturn = FALSE;
            goto CleanUp;

       } else {

            pProvider = AllocSplStr(szConnData);
       }
    }

    pPrintServer = AllocSplStr(pPrintServerP);
    pPrinterName = AllocSplStr(pPrinterNameP);

    if (!pProvider || !pPrintServer || !pPrinterName) {

        bReturn = FALSE;
        goto CleanUp;
    }

    // Check for a fully qualified printer name without commas
    if (!ValidatePrinterName(pPrinterName)) {

         SetLastError(ERROR_INVALID_PRINTER_NAME);
         bReturn = FALSE;
         goto CleanUp;
    }

    // Replacing the \'s from the Printer name with ,'s
    FormatPrinterForRegistryKey(pPrinterName, pPrinterName);

    hImpersonationToken = RevertToPrinterSelf();

    // Creating the subkey for the holding all printer connections.

    if ((dwLastError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryConnections, 0,
                                      NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                      NULL, &hMcConnectionKey, NULL)) ||
        (dwLastError = RegCreateKeyEx(hMcConnectionKey, pPrinterName, 0, NULL,
                                      REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                      &hPrinterKey, NULL))) {

         SetLastError(dwLastError);
         bReturn = FALSE;
         goto CleanUp;
    }

    // Setting the connection data.
    if ((dwLastError = RegSetValueEx(hPrinterKey, L"Server", 0, REG_SZ, (LPBYTE) pPrintServer,
                                     (wcslen(pPrintServer)+1)*sizeof(pPrintServer[0]))) ||
        (dwLastError = RegSetValueEx(hPrinterKey, L"Provider", 0, REG_SZ, (LPBYTE) pProvider,
                                     (wcslen(pProvider)+1)*sizeof(pProvider[0]))) ||
        (dwLastError = RegSetValueEx(hPrinterKey, L"LocalConnection", 0, REG_DWORD,
                                     (LPBYTE) &dwLocalConnection, sizeof(dwLocalConnection)))) {

         SetLastError(dwLastError);
         bReturn = FALSE;
    }

CleanUp:
    if (pPrintServer) {
       FreeSplStr(pPrintServer);
    }

    if (pProvider) {
       FreeSplStr(pProvider);
    }

    if (hAllProviderKey) {
       RegCloseKey(hAllProviderKey);
    }

    if (hProviderKey) {
       RegCloseKey(hProviderKey);
    }

    if (hPrinterKey) {
        RegCloseKey(hPrinterKey);
    }

    if (!bReturn) {
       if (hMcConnectionKey) RegDeleteKey(hMcConnectionKey,pPrinterName);
    }

    if (pPrinterName) {
       FreeSplStr(pPrinterName);
    }

    if (hMcConnectionKey) {
       RegCloseKey(hMcConnectionKey);
    }

    if (hImpersonationToken) {
       ImpersonatePrinterClient(hImpersonationToken);
    }

   LeaveRouterSem();

    return bReturn;
}

BOOL
AddPerMachineConnectionW(
    LPCWSTR  pServer,
    LPCWSTR  pPrinterName,
    LPCWSTR  pPrintServer,
    LPCWSTR  pProvider
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    if ((*pProvidor->PrintProvidor.fpAddPerMachineConnection)
                (pServer, pPrinterName, pPrintServer, pProvider)) {

        return RouterAddPerMachineConnection(pPrinterName,pPrintServer,pProvider);

    } else if (GetLastError() != ERROR_INVALID_NAME) {

        return FALSE;
    }

    pProvidor = pProvidor->pNext;
    while (pProvidor) {

       if ((*pProvidor->PrintProvidor.fpAddPerMachineConnection)
                (pServer, pPrinterName, pPrintServer, pProvider)) {
          return TRUE;
       }

       if (GetLastError() != ERROR_INVALID_NAME) {
          return FALSE;
       }

       pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
RouterDeletePerMachineConnection(
    LPCWSTR   pPrinterNameP
    )
/*++
Function Description: This function deletes the registry entry in HKEY_LOCAL_MACHINE\
                      SYSTEM\CurrentControlSet\Control\Print\Connections corresponding to
                      pPrinterNameP. All users will lose the connection when they logon.

Parameters: pPrinterNameP - pointer to the fully qualified name of the printer.

Return Values: TRUE for Success
               FALSE otherwise.
--*/
{
    BOOL    bReturn = TRUE, bEnteredRouterSem = FALSE;
    HANDLE  hImpersonationToken = NULL;
    HKEY    hMcConnectionKey = NULL;
    LPWSTR  pPrinterName = NULL;
    DWORD   dwLastError;
    WCHAR   szRegistryConnections[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";


    if (!(pPrinterName = AllocSplStr(pPrinterNameP))) {

        bReturn = FALSE;
        goto CleanUp;
    }

    // Convert \'s to ,'s in the printer name.
    FormatPrinterForRegistryKey(pPrinterName, pPrinterName);

   EnterRouterSem();
   bEnteredRouterSem = TRUE;

    hImpersonationToken = RevertToPrinterSelf();

    if (dwLastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryConnections, 0,
                                   KEY_ALL_ACCESS, &hMcConnectionKey)) {

        SetLastError(dwLastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (dwLastError = RegDeleteKey(hMcConnectionKey, pPrinterName)) {

        SetLastError(dwLastError);
        bReturn = FALSE;
    }

CleanUp:
    if (hMcConnectionKey) {
       RegCloseKey(hMcConnectionKey);
    }
    
    if (pPrinterName) {
       FreeSplStr(pPrinterName);
    }
    if (hImpersonationToken) {
       ImpersonatePrinterClient(hImpersonationToken);
    }
    if (bEnteredRouterSem) {
       LeaveRouterSem();
    }

    return bReturn;
}

BOOL
DeletePerMachineConnectionW(
    LPCWSTR  pServer,
    LPCWSTR  pPrinterName
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    if ((*pProvidor->PrintProvidor.fpDeletePerMachineConnection)
                (pServer, pPrinterName)) {

        return RouterDeletePerMachineConnection(pPrinterName);

    } else if (GetLastError() != ERROR_INVALID_NAME) {

        return FALSE;
    }

    pProvidor = pProvidor->pNext;
    while (pProvidor) {

       if ((*pProvidor->PrintProvidor.fpDeletePerMachineConnection)
                (pServer, pPrinterName)) {
           return TRUE;
       }

       if (GetLastError() != ERROR_INVALID_NAME) {
           return FALSE;
       }

       pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
RouterEnumPerMachineConnections(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
    )
/*++
Function Description: This function copies the PRINTER_INFO_4 structs for all the per
                      machine connections into the buffer (pPrinterEnum).

Parameters: pServer - pointer to the server name (NULL for local)
            pPrinterEnum - pointer to the buffer
            cbBuf - size of the buffer in bytes
            pcbNeeded - pointer to a variable which contains the number of bytes written
                        into the buffer/ number of bytes required (if the given buffer
                        is insufficient)
            pcReturned - pointer to the variable which contains the number of PRINTER_INFO_4
                         structs returned in the buffer.

Return Values: TRUE for success
               FALSE otherwise.

--*/
{
    DWORD     dwRegIndex, dwType, cbdata, dwNameSize, dwLastError;
    BOOL      bReturn = TRUE, bEnteredRouterSem = FALSE;
    HANDLE    hImpersonationToken = NULL;
    HKEY      hMcConnectionKey = NULL, hPrinterKey = NULL;
    LPBYTE    pStart = NULL, pEnd = NULL;

    WCHAR     szMachineConnections[]=L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";
    WCHAR     szPrinterName[MAX_UNC_PRINTER_NAME],szConnData[MAX_UNC_PRINTER_NAME];

    // Check for local machine
    if (pServer && *pServer) {

        if (!MyUNCName((LPWSTR)pServer)) {

            SetLastError(ERROR_INVALID_NAME);
            bReturn = FALSE;
            goto CleanUp;
        }
    }

   EnterRouterSem();
   bEnteredRouterSem = TRUE;

    hImpersonationToken = RevertToPrinterSelf();

    *pcbNeeded = *pcReturned = 0;

    // Open the key containing all per-machine connections.
    if (dwLastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMachineConnections, 0,
                                   KEY_READ , &hMcConnectionKey)) {

        bReturn = (dwLastError == ERROR_FILE_NOT_FOUND) ? TRUE
                                                        : FALSE;
        if (!bReturn) {
            SetLastError(dwLastError);
        }
        goto CleanUp;
    }

    // pStart and pEnd point to the start and end of the buffer respt.
    pStart = pPrinterEnum;
    pEnd = pPrinterEnum + cbBuf;

    for (dwRegIndex = 0;

         dwNameSize = COUNTOF(szPrinterName),
         ((dwLastError = RegEnumKeyEx(hMcConnectionKey, dwRegIndex, szPrinterName,
                                      &dwNameSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS);

         ++dwRegIndex) {

         // Enumerate each of the connections and copy data into the buffer
         cbdata = sizeof(szConnData);

         if ((dwLastError = RegOpenKeyEx(hMcConnectionKey, szPrinterName, 0,
                                         KEY_READ, &hPrinterKey)) ||
             (dwLastError = RegQueryValueEx(hPrinterKey, L"Server", NULL, &dwType,
                                            (LPBYTE)szConnData, &cbdata))) {

             SetLastError(dwLastError);
             bReturn = FALSE;
             goto CleanUp;
         }

         RegCloseKey(hPrinterKey);
         hPrinterKey=NULL;

         // Update the size of the required buffer
         *pcbNeeded = *pcbNeeded + sizeof(PRINTER_INFO_4) + sizeof(DWORD) +
                      (wcslen(szConnData) + 1)*sizeof(szConnData[0]) +
                      (wcslen(szPrinterName) + 1)*sizeof(szPrinterName[0]);

         // Copy data into the buffer if there is space.
         if (*pcbNeeded <= cbBuf) {

             pEnd = CopyPrinterNameToPrinterInfo4(szConnData,szPrinterName,pStart,pEnd);
             FormatRegistryKeyForPrinter(((PPRINTER_INFO_4) pStart)->pPrinterName,
                                         ((PPRINTER_INFO_4) pStart)->pPrinterName);
             pStart += sizeof(PRINTER_INFO_4);
             (*pcReturned)++;
         }
    }

    if (dwLastError != ERROR_NO_MORE_ITEMS) {

        SetLastError(dwLastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (cbBuf < *pcbNeeded) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        bReturn = FALSE;
    }

CleanUp:

    if (hMcConnectionKey) {
       RegCloseKey(hMcConnectionKey);
    }
    if (hPrinterKey) {
       RegCloseKey(hPrinterKey);
    }
    if (hImpersonationToken) {
       ImpersonatePrinterClient(hImpersonationToken);
    }
    if (bEnteredRouterSem) {
       LeaveRouterSem();
    }
    if (!bReturn) {
       *pcReturned = 0;
    }

    return bReturn;
}

BOOL
EnumPerMachineConnectionsW(
    LPCWSTR  pServer,
    LPBYTE   pPrinterEnum,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
    LPPROVIDOR  pProvidor;

    if ((pPrinterEnum == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (RouterEnumPerMachineConnections(pServer, pPrinterEnum, cbBuf,
                                        pcbNeeded, pcReturned)) {

        return TRUE;

    } else if (GetLastError() != ERROR_INVALID_NAME) {

        return FALSE;
    }

    pProvidor = pLocalProvidor;
    while (pProvidor) {

       if ((*pProvidor->PrintProvidor.fpEnumPerMachineConnections)
                 (pServer, pPrinterEnum, cbBuf, pcbNeeded, pcReturned)) {

            return TRUE;
       }

       if (GetLastError() != ERROR_INVALID_NAME) {
           return FALSE;
       }

       pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

PPRINTER_INFO_2
pGetPrinterInfo2(
    HANDLE hPrinter
    )

/*++

Routine Description:

    Retrieve a printer info 2 structure from an hPrinter.  Data must
    be FreeSplMem'd by caller.

Arguments:

    hPrinter - Printer to query.

Return Value:

    PRINTER_INFO_2 - On success, a valid structure.
    NULL - On failure.

--*/

{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;
    DWORD cbPrinter = 0x1000;
    DWORD cbNeeded;
    PPRINTER_INFO_2 pPrinterInfo2;
    BOOL bSuccess = FALSE;

    if( pPrinterInfo2 = AllocSplMem( cbPrinter )){

        bSuccess = (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinter)
                         ( pPrintHandle->hPrinter,
                           2,
                           (PBYTE)pPrinterInfo2,
                           cbPrinter,
                           &cbNeeded );

        if( !bSuccess ){

            if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ){

                FreeSplMem( pPrinterInfo2 );

                if (pPrinterInfo2 = (PPRINTER_INFO_2)AllocSplMem( cbNeeded )){

                    cbPrinter = cbNeeded;
                    bSuccess = (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinter)
                                     ( pPrintHandle->hPrinter,
                                       2,
                                       (PBYTE)pPrinterInfo2,
                                       cbPrinter,
                                       &cbNeeded );
                }
            }
        }
    }

    if( !bSuccess ){
        FreeSplMem( pPrinterInfo2 );
        return NULL;
    }

    return pPrinterInfo2;
}

VOID
SplDriverUnloadComplete(
    LPWSTR   pDriverFile
    )
/*++
Function Description:  Notify the print provider that the driver is being unloaded
                       so that it may continue with any pending driver upgrades.

Parameters: pDriverFile   -- name of the library that has been unloaded

Return Values: NONE
--*/
{
    LPPROVIDOR   pProvidor;

    for (pProvidor = pLocalProvidor; pProvidor; pProvidor = pProvidor->pNext) {
         if ((*pProvidor->PrintProvidor.fpDriverUnloadComplete)(pDriverFile)) {
             break;
         }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\splinit.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    SplInit.c

Abstract:

    Initialize the spooler.

Author:

Environment:

    User Mode -Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

LPWSTR szDevice = L"Device";
LPWSTR szPrinters = L"Printers";

LPWSTR szDeviceOld = L"DeviceOld";
LPWSTR szNULL = L"";

LPWSTR szPorts=L"Ports";

LPWSTR szWinspool = L"winspool";
LPWSTR szNetwork  = L"Ne";
LPWSTR szTimeouts = L",15,45";

LPWSTR szDotDefault = L".Default";

LPWSTR szRegDevicesPath = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Devices";
LPWSTR szRegWindowsPath = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows";
LPWSTR szRegPrinterPortsPath = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\PrinterPorts";
LPWSTR szCurrentVersionPath =  L"Software\\Microsoft\\Windows NT\\CurrentVersion";
LPWSTR szDevModes2Path = L"Printers\\DevModes2";

typedef struct INIT_REG_USER {

    HKEY hKeyUser;
    HKEY hKeyWindows;
    HKEY hKeyDevices;
    HKEY hKeyPrinterPorts;
    BOOL bFoundPrinter;
    BOOL bDefaultSearch;
    BOOL bDefaultFound;
    BOOL bFirstPrinterFound;

    DWORD dwNetCounter;

    WCHAR szFirstPrinter[MAX_PATH * 2];
    WCHAR szDefaultPrinter[MAX_PATH * 2];

} INIT_REG_USER, *PINIT_REG_USER;

//
// Prototypes
//

BOOL
SplRegCopy(
    PINIT_REG_USER pUser,
    HKEY hMcConnectionKey
    );

BOOL
InitializeRegUser(
    LPWSTR szSubKey,
    PINIT_REG_USER pUser
    );

VOID
FreeRegUser(
    PINIT_REG_USER pUser
    );

BOOL
SetupRegForUsers(
    PINIT_REG_USER pUsers,
    DWORD cUsers
    );

VOID
UpdateUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN BOOL             bFindDefault
    );

HRESULT
IsUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN PCWSTR           pszPrinterName
    );

DWORD
ReadPrinters(
    PINIT_REG_USER pUser,
    DWORD Flags,
    PDWORD pcbPrinters,
    LPBYTE* ppPrinters
    );


BOOL
UpdatePrinterInfo(
    const PINIT_REG_USER pCurUser,
    LPCWSTR pPrinterName,
    LPCWSTR pPorts,
    PDWORD pdwNetId
    );


BOOL
EnumerateConnectedPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HKEY hKeyUser
    );

VOID
RegClearKey(
    HKEY hKey
    );

LPWSTR
CheckBadPortName(
    LPWSTR pszPort
    );

BOOL
UpdateLogonTimeStamp(
    void
    );

BOOL
SpoolerInitAll(
    VOID
    )
{
    DWORD dwError;
    WCHAR szClass[MAX_PATH];
    WCHAR szSubKey[MAX_PATH];
    DWORD cUsers;
    DWORD cSubKeys;
    DWORD cchMaxSubkey;
    DWORD cchMaxClass;
    DWORD cValues;
    DWORD cbMaxValueData;
    DWORD cbSecurityDescriptor;
    DWORD cchClass;
    DWORD cchMaxValueName;
    FILETIME ftLastWriteTime;

    BOOL bSuccess;
    DWORD cchSubKey;

    PINIT_REG_USER pUsers;
    PINIT_REG_USER pCurUser;

    DWORD i;

    cchClass = COUNTOF(szClass);

    dwError = RegQueryInfoKey(HKEY_USERS,
                              szClass,
                              &cchClass,
                              NULL,
                              &cSubKeys,
                              &cchMaxSubkey,
                              &cchMaxClass,
                              &cValues,
                              &cchMaxValueName,
                              &cbMaxValueData,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime);

    if (dwError) {
        SetLastError( dwError );
        DBGMSG(DBG_WARNING, ("SpoolerIniAll failed RegQueryInfoKey HKEY_USERS error %d\n", dwError));
        return FALSE;
    }

    if (cSubKeys < 1)
        return TRUE;

    pUsers = AllocSplMem(cSubKeys * sizeof(pUsers[0]));

    if (!pUsers) {
        DBGMSG(DBG_WARNING, ("SpoolerIniAll failed to allocate pUsers error %d\n", dwError));
        return FALSE;
    }

    for (i=0, pCurUser=pUsers, cUsers=0;
        i< cSubKeys;
        i++) {

        cchSubKey = COUNTOF(szSubKey);

        dwError = RegEnumKeyEx(HKEY_USERS,
                          i,
                          szSubKey,
                          &cchSubKey,
                          NULL,
                          NULL,
                          NULL,
                          &ftLastWriteTime);
        if ( dwError ) {

            //
            // We possibly should return an error here if we fail to initiatise a 
            // user.
            //
            DBGMSG( DBG_WARNING, ("SpoolerInitAll failed RegEnumKeyEx HKEY_USERS %ws %d %d\n", szSubKey, i, dwError));
            SetLastError( dwError );

        } else {

            if (!_wcsicmp(szSubKey, szDotDefault) || wcschr(szSubKey, L'_')) {
                continue;
            }

            if (InitializeRegUser(szSubKey, pCurUser)) {

                pCurUser++;
                cUsers++;
            }
        }
    }

    bSuccess = SetupRegForUsers(pUsers,
                                cUsers);

    for (i=0; i< cUsers; i++)
        FreeRegUser(&pUsers[i]);

    //
    // In case we are starting after the user has logged in, inform
    // all applications that there may be printers now.
    //
    BroadcastMessage(BROADCAST_TYPE_CHANGEDEFAULT,
                     0,
                     0,
                     0);

    FreeSplMem(pUsers);

    if ( !bSuccess ) {
        DBGMSG( DBG_WARNING, ("SpoolerInitAll failed error %d\n", GetLastError() ));
    } else {
        DBGMSG( DBG_TRACE, ("SpoolerInitAll Success\n" ));
    }

    return bSuccess;
}

BOOL
DeleteOldPerMcConnections(
    HKEY   hConnectionKey,
    HKEY   hMcConnectionKey
    )

/*++
Function Description - Deletes the existing permachine connections from hConnectionKey

Parameters - hConnectionKey - handle to hUserKey\Printers\Connections

Return Values - TRUE if success
                FALSE otherwise.

--*/

{
    BOOL   bReturn = TRUE;
    struct Node {
       struct Node *pNext;
       LPTSTR szPrinterName;
    }   *phead = NULL,*ptemp = NULL;

    LONG  lstatus;
    DWORD dwRegIndex,dwNameSize,cbdata,dwquerylocal,dwType;
    WCHAR szPrinterName[MAX_UNC_PRINTER_NAME];
    HKEY  hPrinterKey;

    // Before deleting the old permachine connections, we need to record all them into
    // a list. This is required because, the subkeys should not be deleted while they
    // are being enumerated.

    // Identifying permachine connections and saving the printernames in a list.

    for (dwRegIndex = 0;

         dwNameSize = COUNTOF(szPrinterName),
         ((lstatus = RegEnumKeyEx(hConnectionKey, dwRegIndex, szPrinterName,
                                  &dwNameSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS);

         ++dwRegIndex) {

       if (RegOpenKeyEx(hConnectionKey, szPrinterName, 0, KEY_ALL_ACCESS, &hPrinterKey)
                  != ERROR_SUCCESS) {

          bReturn = FALSE;
          goto CleanUp;
       }

       dwquerylocal = 0;
       cbdata = sizeof(dwquerylocal);

       RegQueryValueEx(hPrinterKey, L"LocalConnection", NULL, &dwType,
                        (LPBYTE)&dwquerylocal, &cbdata);

       RegCloseKey(hPrinterKey);

       //
       // See if it's a LocalConnection, and if it exists on the current
       // machine.  We don't want to delete it if it is a per-machine
       // connection, since we want to keep the associated per-user
       // DevMode.
       //
       if( ERROR_SUCCESS == RegOpenKeyEx( hMcConnectionKey,
                                          szPrinterName,
                                          0,
                                          KEY_READ,
                                          &hPrinterKey )) {
           //
           // The per-machine key exists.  Close it and don't bother
           // deleting this connection.
           //
           RegCloseKey( hPrinterKey );

       } else {

           //
           // It's not a per-machine connection.  Prepare to delete it.
           //
           if (dwquerylocal == 1) {
               if (!(ptemp = (struct Node *) AllocSplMem(sizeof(struct Node)))) {
                   bReturn = FALSE;
                   goto CleanUp;
               }
               ptemp->pNext = phead;
               phead = ptemp;
               if (!(ptemp->szPrinterName = AllocSplStr(szPrinterName))) {
                   bReturn = FALSE;
                   goto CleanUp;
               }
           }
       }
    }

    if (lstatus != ERROR_NO_MORE_ITEMS) {
       bReturn = FALSE;
       goto CleanUp;
    }

    // Deleting old permachine connections. The printer names are stored in the
    // list pointed to by phead.

    for (ptemp = phead; ptemp != NULL; ptemp = ptemp->pNext) {
       if (RegDeleteKey(hConnectionKey,ptemp->szPrinterName) != ERROR_SUCCESS) {
          bReturn = FALSE;
          goto CleanUp;
       }
    }


CleanUp:

    while (ptemp = phead) {
       phead = phead->pNext;
       if (ptemp->szPrinterName) FreeSplStr(ptemp->szPrinterName);
       FreeSplMem(ptemp);
    }

    return bReturn;

}

BOOL
AddNewPerMcConnections(
    HKEY   hConnectionKey,
    HKEY   hMcConnectionKey
    )

/*++
Function Description - Adds per-machine connections to the user hive if the connection
                       does not already exist.

Parameters - hConnectionKey   - handle to hUserKey\Printers\Connections
             hMcConnectionKey - handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
                                          Control\Print\Connections
Return Values - TRUE if success
                FALSE otherwise.
--*/

{   DWORD dwRegIndex,dwNameSize,cbdata,dwType,dwlocalconnection = 1;
    WCHAR szPrinterName[MAX_UNC_PRINTER_NAME];
    WCHAR szConnData[MAX_UNC_PRINTER_NAME];
    LONG  lstatus;
    BOOL  bReturn = TRUE;
    HKEY  hNewConnKey = NULL, hPrinterKey = NULL;


    for (dwRegIndex = 0;

         dwNameSize = COUNTOF(szPrinterName),
         ((lstatus = RegEnumKeyEx(hMcConnectionKey, dwRegIndex, szPrinterName,
                              &dwNameSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS);

         ++dwRegIndex) {

       RegOpenKeyEx(hConnectionKey,szPrinterName,0,KEY_READ,&hNewConnKey);

       if (hNewConnKey == NULL) {

          // Connection does not exist. Add one.

          if (RegCreateKeyEx(hConnectionKey, szPrinterName, 0, NULL, REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, &hNewConnKey, NULL)
              || RegOpenKeyEx(hMcConnectionKey, szPrinterName, 0, KEY_READ, &hPrinterKey)) {

               bReturn = FALSE;
               goto CleanUp;
          }

          cbdata = sizeof(szConnData);
          if (RegQueryValueEx(hPrinterKey,L"Server",NULL,&dwType,(LPBYTE)szConnData,&cbdata)
              || RegSetValueEx(hNewConnKey,L"Server",0,dwType,(LPBYTE)szConnData,cbdata)) {

               bReturn = FALSE;
               goto CleanUp;
          }

          cbdata = sizeof(szConnData);
          if (RegQueryValueEx(hPrinterKey,L"Provider",NULL,&dwType,(LPBYTE)szConnData,&cbdata)
              || RegSetValueEx(hNewConnKey,L"Provider",0,dwType,(LPBYTE)szConnData,cbdata)
              || RegSetValueEx(hNewConnKey,L"LocalConnection",0,REG_DWORD,
                               (LPBYTE)&dwlocalconnection,sizeof(dwlocalconnection))) {

               bReturn = FALSE;
               goto CleanUp;
          }

          RegCloseKey(hPrinterKey);
          hPrinterKey = NULL;
       }

       RegCloseKey(hNewConnKey);
       hNewConnKey = NULL;
    }

    if (lstatus != ERROR_NO_MORE_ITEMS) {
       bReturn = FALSE;
    }

CleanUp:

    if (hNewConnKey) {
       RegCloseKey(hNewConnKey);
    }
    if (hPrinterKey) {
       RegCloseKey(hPrinterKey);
    }

    return bReturn;

}

BOOL
SplRegCopy(
    PINIT_REG_USER pUser,
    HKEY   hMcConnectionKey)

/*++
Function Description - Removes old permachine connections for pUser and adds the new
                       permachine connections from hMcConnectionKey

Parameters - pUser - pointer to INIT_REG_USER which contains hUserKey.
             hMcConnectionKey - handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
                                          Control\Print\Connections

Return Values - TRUE if success
                FALSE otherwise.

--*/

{
    LONG  lstatus;
    BOOL  bReturn = TRUE;
    WCHAR szRegistryConnections[] = L"Printers\\Connections";
    HKEY  hConnectionKey = NULL;

    // Create (if not already present) and open Connections subkey
    lstatus = RegCreateKeyEx(pUser->hKeyUser,
                             szRegistryConnections,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hConnectionKey,
                             NULL);

    if (lstatus != ERROR_SUCCESS) {
       bReturn = FALSE;
       goto CleanUp;
    }

    if (!DeleteOldPerMcConnections(hConnectionKey,hMcConnectionKey)
        || !AddNewPerMcConnections(hConnectionKey,hMcConnectionKey)) {
       bReturn = FALSE;
    }

CleanUp:

    if (hConnectionKey) {
       RegCloseKey(hConnectionKey);
    }

    return bReturn;
}

BOOL
SetupRegForUsers(
    PINIT_REG_USER pUsers,
    DWORD cUsers)
{
    DWORD cbPrinters;
    DWORD cPrinters;
    PBYTE pPrinters;
    HKEY  hMcConnectionKey = NULL;
    WCHAR szMachineConnections[] = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Connections";

#define pPrinters2 ((PPRINTER_INFO_2)pPrinters)
#define pPrinters4 ((PPRINTER_INFO_4)pPrinters)

    DWORD i, j;
    LPWSTR pszPort;

    //
    // Read in local printers.
    //
    cbPrinters = 1000;
    pPrinters = AllocSplMem(cbPrinters);

    if (!pPrinters)
        return FALSE;

    if (cPrinters = ReadPrinters(NULL,
                                 PRINTER_ENUM_LOCAL,
                                 &cbPrinters,
                                 &pPrinters)) {

        for (i=0; i< cUsers; i++) {

            for(j=0; j< cPrinters; j++) {

                if( pPrinters2[j].Attributes & PRINTER_ATTRIBUTE_NETWORK ){

                    //
                    // Use NeXX:
                    //
                    pszPort = NULL;

                } else {

                    pszPort = CheckBadPortName( pPrinters2[j].pPortName );
                }

                UpdatePrinterInfo( &pUsers[i],
                                   pPrinters2[j].pPrinterName,
                                   pszPort,
                                   &(pUsers[i].dwNetCounter));
            }
        }
    }

    // Open the Key containing the current list of per-machine connections.
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMachineConnections, 0,
                 KEY_READ , &hMcConnectionKey);

    for (i=0; i< cUsers; i++) {

        // Copy Per Machine Connections into the user hive
        SplRegCopy(&pUsers[i], hMcConnectionKey);

        if (cPrinters = ReadPrinters(&pUsers[i],
                                     PRINTER_ENUM_CONNECTIONS,
                                     &cbPrinters,
                                     &pPrinters)) {

            for(j=0; j< cPrinters; j++) {

                UpdatePrinterInfo(&pUsers[i],
                                  pPrinters4[j].pPrinterName,
                                  NULL,
                                  &(pUsers[i].dwNetCounter));
            }
        }
    }

    // Close the handle to Per Machine Connections.

    if (hMcConnectionKey) RegCloseKey(hMcConnectionKey);

    FreeSplMem(pPrinters);

    for (i=0; i< cUsers; i++) {

        UpdateUsersDefaultPrinter(&pUsers[i], FALSE);
    }
    return TRUE;

#undef pPrinters2
#undef pPrinters4
}


VOID
UpdateUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN BOOL             bFindDefault
    )
/*++

Routine Description:

    Updates the default printer using the information in the
    current users reg structure.  If the bFindDefault flag is
    specified then a default printer is located.  The method for this
    is first see if there is currently a default printer, then user this.
    If a default printer is not found then located the first printer in
    devices section, again if on exists.

Arguments:

    pUser           - Information about the current user, reg keys etc.
                      This routine assumes that hKeyWindows and hKeyDevices
                      are valid opened registry keys, with read access.
    bFindDefault    - TRUE located a default printer, FALSE the default
                      printer is already specified in the users reg
                      structure.

Return Value:

    Nothing.

--*/
{
    LPWSTR pszNewDefault = NULL;

    //
    // If a request to find the default printer.
    //
    if (bFindDefault) {

        DWORD   dwError = ERROR_SUCCESS;
        DWORD   cbData  = sizeof(pUser->szDefaultPrinter);

        //
        // Check if there is a default printer.
        //
        dwError = RegQueryValueEx(pUser->hKeyWindows,
                                  szDevice,
                                  NULL,
                                  NULL,
                                  (PBYTE)pUser->szDefaultPrinter,
                                  &cbData);

        //
        // If the device key was read and there is a non null string
        // as the default printer name.
        //
        if (dwError == ERROR_SUCCESS && pUser->szDefaultPrinter[0] != L'\0') {

            pUser->bDefaultFound = TRUE;

        } else {

            //
            // Default was not found.
            //
            pUser->bDefaultFound = FALSE;

            //
            // If a first printer was not found.
            //
            if (!pUser->bFirstPrinterFound)
            {
                WCHAR szBuffer [MAX_PATH*2];
                DWORD cbDataBuffer = sizeof(szBuffer);

                DBGMSG(DBG_TRACE, ("UpdateUsersDefaultPrinter default printer not found.\n"));

                cbData = COUNTOF(pUser->szFirstPrinter);

                //
                // Default printer was not found, find any printer
                // in the devices section of the registry.
                //
                dwError = RegEnumValue(pUser->hKeyDevices,
                                       0,
                                       pUser->szFirstPrinter,
                                       &cbData,
                                       NULL,
                                       NULL,
                                       (PBYTE)szBuffer,
                                       &cbDataBuffer);

                if (dwError == ERROR_SUCCESS) {

                    wcscat(pUser->szFirstPrinter, L",");
                    wcscat(pUser->szFirstPrinter, szBuffer);

                    pUser->bFirstPrinterFound = TRUE;

                } else {

                    DBGMSG(DBG_WARNING, ("UpdateUsersDefaultPrinter no printer found in devices section.\n"));

                    pUser->bFirstPrinterFound = FALSE;
                }
            }
        }
    }

    //
    // If default wasn't present, and we did get a first printer,
    // make this the default.
    //
    if (!pUser->bDefaultFound) {

        if (pUser->bFirstPrinterFound) {

            pszNewDefault = pUser->szFirstPrinter;
        }

    } else {

        //
        // Write out default.
        //
        pszNewDefault = pUser->szDefaultPrinter;
    }

    if (pszNewDefault) {

        RegSetValueEx(pUser->hKeyWindows,
                      szDevice,
                      0,
                      REG_SZ,
                      (PBYTE)pszNewDefault,
                      (wcslen(pszNewDefault) + 1) * sizeof(pszNewDefault[0]));
    }
}

HRESULT
IsUsersDefaultPrinter(
    IN PINIT_REG_USER   pUser,
    IN PCWSTR           pszPrinterName
    )
/*++

Routine Description:

    Asks if the users default printer matched the specified
    printer name.

Arguments:

    pCurUser        - Information about the current user, reg keys etc.
                      This routine assumes that hKeyWindows is a valid
                      opened registry keys, with at least read access.
    pszPrinterName  - Printer name to check if it is the default printer.

Return Value:

    S_OK the printer name is the default, S_FALSE the printer is not the
    default, An HRESULT error code if an error occurrs attempting to
    determine the default printer.

--*/
{
    HRESULT hr = E_INVALIDARG;

    if (pszPrinterName) {

        WCHAR   szBuffer[MAX_PATH*2];
        DWORD   dwError = ERROR_SUCCESS;
        DWORD   cbData  = sizeof(szBuffer);

        //
        // Read the default printer, if one exists.
        //
        dwError = RegQueryValueEx(pUser->hKeyWindows,
                                  szDevice,
                                  NULL,
                                  NULL,
                                  (PBYTE)szBuffer,
                                  &cbData);

        if (dwError == ERROR_SUCCESS) {

            PWSTR p = wcschr(szBuffer, L',');

            if (p) {

                *p = 0;
            }

            hr = !_wcsicmp(pszPrinterName, szBuffer) ? S_OK : S_FALSE;

        } else {

            hr = HRESULT_FROM_WIN32(dwError);

        }
    }

    return hr;
}

DWORD
ReadPrinters(
    PINIT_REG_USER pUser,
    DWORD Flags,
    PDWORD pcbPrinters,
    LPBYTE* ppPrinters)
{
    BOOL bSuccess;
    DWORD cbNeeded;
    DWORD cPrinters = 0;


    if (Flags == PRINTER_ENUM_CONNECTIONS) {

        bSuccess = EnumerateConnectedPrinters(*ppPrinters,
                                              *pcbPrinters,
                                              &cbNeeded,
                                              &cPrinters,
                                              pUser->hKeyUser);
    } else {

        bSuccess = EnumPrinters(Flags,
                                NULL,
                                2,
                                (PBYTE)*ppPrinters,
                                *pcbPrinters,
                                &cbNeeded,
                                &cPrinters);
   }

    if (!bSuccess) {

        //
        // If not enough space, realloc.
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            if (*ppPrinters = ReallocSplMem(*ppPrinters,
                                            0,
                                            cbNeeded)) {

                *pcbPrinters = cbNeeded;
            }
        }

        if (Flags == PRINTER_ENUM_CONNECTIONS) {

            bSuccess = EnumerateConnectedPrinters(*ppPrinters,
                                                  *pcbPrinters,
                                                  &cbNeeded,
                                                  &cPrinters,
                                                  pUser->hKeyUser);
        } else {

            bSuccess = EnumPrinters(Flags,
                                    NULL,
                                    2,
                                    (PBYTE)*ppPrinters,
                                    *pcbPrinters,
                                    &cbNeeded,
                                    &cPrinters);
        }

        if (!bSuccess)
            cPrinters = 0;
    }

    return cPrinters;
}

BOOL
UpdatePrinterInfo(
    const PINIT_REG_USER pCurUser,
    LPCWSTR pszPrinterName,
    LPCWSTR pszPort,
    PDWORD pdwNetId
    )
/*++

Routine Description:

    Updates the printer information in the registry win.ini.

Arguments:

    pCurUser - Information about the user.  The following fields are
        used by this routine:

        hKeyDevices
        hKeyPrinterPorts
        bDefaultSearch (if true, read/writes to:)
            bDefaultFound
            szDefaultPrinter
        bFirstPrinterFound (if false, writes to:)
            szFirstPrinter

    pszPort - Port name.  If NULL, generates NetId.

    pdwNetId - Pointer to NetId counter.  This value will be incremented
        if the NetId is used.

Return Value:

--*/
{
    WCHAR szBuffer[MAX_PATH * 2];
    LPWSTR p;

    DWORD dwCount = 0;
    DWORD cbLen;

    if (!pszPrinterName)
        return FALSE;

    //
    // Now we know the spooler is up, since the EnumPrinters succeeded.
    // Update all sections.
    //
    dwCount = wsprintf(szBuffer,
                       L"%s,",
                       szWinspool);

    if( !pszPort ){

        HANDLE hToken;

        wsprintf(&szBuffer[dwCount],
                 L"%s%.2d:",
                 szNetwork,
                 *pdwNetId);

        (*pdwNetId)++;

        //
        // !! HACK !!
        //
        // Works 3.0b expects the printer port entry in the
        // [ports] section.
        //
        // This is in the per-machine part of the registry, but we
        // are updating it for each user.  Fix later.
        //
        // We never remove the NeXX: entries from [ports] but since
        // the same entries will be used by all users, this is ok.
        //
        hToken = RevertToPrinterSelf();

        WriteProfileString( szPorts, &szBuffer[dwCount], L"" );

        if( hToken ){
            ImpersonatePrinterClient( hToken );
        }
        //
        // End Works 3.0b HACK
        //

    } else {

        UINT cchBuffer;

        cchBuffer = wcslen( szBuffer );
        wcscpy(&szBuffer[cchBuffer], pszPort);

        //
        // Get the first port only.
        //
        if ( p = wcschr(&szBuffer[cchBuffer], L',') )
            *p = 0;
    }

    cbLen = (wcslen(szBuffer)+1) * sizeof(szBuffer[0]);

    RegSetValueEx(pCurUser->hKeyDevices,
                  pszPrinterName,
                  0,
                  REG_SZ,
                  (PBYTE)szBuffer,
                  cbLen);

    //
    // If the user has a default printer specified, then verify
    // that it exists.
    //

    if (pCurUser->bDefaultSearch) {

        pCurUser->bDefaultFound = !_wcsicmp(pszPrinterName,
                                           pCurUser->szDefaultPrinter);

        if (pCurUser->bDefaultFound) {

            wsprintf(pCurUser->szDefaultPrinter,
                     L"%s,%s",
                     pszPrinterName,
                     szBuffer);

            pCurUser->bDefaultSearch = FALSE;
        }
    }

    if (!pCurUser->bFirstPrinterFound) {

        wsprintf(pCurUser->szFirstPrinter,
                 L"%s,%s",
                 pszPrinterName,
                 szBuffer);

        pCurUser->bFirstPrinterFound = TRUE;
    }

    wcscat(szBuffer, szTimeouts);

    RegSetValueEx(pCurUser->hKeyPrinterPorts,
                  pszPrinterName,
                  0,
                  REG_SZ,
                  (PBYTE)szBuffer,
                  (wcslen(szBuffer)+1) * sizeof(szBuffer[0]));

    return TRUE;
}

VOID
SpoolerInitAsync(
    PINIT_REG_USER  pUser
    )

/*++

Routine Description: Asynchronously sets up the user's registry information

Arguments:  pUser    -  pointer to INIT_REG_USER containing user keys

Return Values: NONE

--*/

{
    if (InitializeRegUser(NULL, pUser))
    {
        SetupRegForUsers(pUser, 1);
    }

    BroadcastMessage(BROADCAST_TYPE_CHANGEDEFAULT,0,0,0);
    FreeRegUser(pUser);
    FreeSplMem(pUser);
}

BOOL
SpoolerInit(
    VOID
    )

/*++

Routine Description:  Initializes just the current user.

Arguments: NONE

Return Value: TRUE if initialized or async init thread created successfully
              FALSE otherwise

--*/

{
    BOOL           bSuccess = FALSE;
    DWORD          dwThreadId;
    HANDLE         hThread;
    PINIT_REG_USER pUser;

    UpdateLogonTimeStamp ();

    if (!(pUser = AllocSplMem(sizeof(INIT_REG_USER)))) {

        return FALSE;
    }

    //
    // Enum just the current user.
    //
    pUser->hKeyUser = GetClientUserHandle(KEY_READ|KEY_WRITE);

    if (pUser->hKeyUser)
    {
        if (!Initialized)
        {
            //
            // Process the user initialization asynchronously if the spooler
            // hasn't completed it's initialization.
            //
            hThread = CreateThread(NULL, 
                                   0, 
                                   (LPTHREAD_START_ROUTINE) SpoolerInitAsync,
                                   (LPVOID) pUser, 0, &dwThreadId);

            if (hThread)
            {
                //
                // We assume that the async thread will succeed.
                //
                CloseHandle(hThread);
                bSuccess = TRUE;
            }
            else
            {
                FreeRegUser(pUser);
                FreeSplMem(pUser);
            }
        }
        else
        {
            if (InitializeRegUser(NULL, pUser))
            {
                bSuccess = SetupRegForUsers(pUser, 1);
            }

            FreeRegUser(pUser);
            FreeSplMem(pUser);
        }
    }

    return bSuccess;
}

BOOL
InitializeRegUser(
    LPWSTR pszSubKey,
    PINIT_REG_USER pUser
    )
/*++

Routine Description:

    Initialize a single users structure based on a HKEY_USERS subkey.

Arguments:

    pszSubKey - if non-NULL initialize hKeyUser to this key

    pUser - structure to initialize

Return Value:

--*/
{
    HKEY                    hKey;
    LPWSTR                  p;
    BOOL                    bSecurityLoaded = FALSE, rc = FALSE;
    DWORD                   cbData, cbSD = 0, dwError, dwDisposition;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    HANDLE hToken = NULL;

    if (pszSubKey) {

        if (RegOpenKeyEx(HKEY_USERS,
                         pszSubKey,
                         0,
                         KEY_READ|KEY_WRITE,
                         &pUser->hKeyUser) != ERROR_SUCCESS) {

            DBGMSG(DBG_WARNING, ("InitializeRegUser: RegOpenKeyEx failed\n"));
            goto Fail;
        }
    }

    //
    // Now attempt to set the security on these two keys to
    // their parent key.
    //
    dwError = RegOpenKeyEx(pUser->hKeyUser,
                           szCurrentVersionPath,
                           0,
                           KEY_READ,
                           &hKey);

    if (!dwError) {

        dwError = RegGetKeySecurity(hKey,
                                    DACL_SECURITY_INFORMATION,
                                    pSD,
                                    &cbSD);

        if (dwError == ERROR_INSUFFICIENT_BUFFER) {

            pSD = AllocSplMem(cbSD);

            if (pSD) {

                if (!RegGetKeySecurity(hKey,
                                       DACL_SECURITY_INFORMATION,
                                       pSD,
                                       &cbSD)){

                    bSecurityLoaded = TRUE;

                } else {

                    DBGMSG(DBG_WARNING, ("InitializeRegUser: RegGetKeySecurity failed %d\n",
                                         GetLastError()));
                }
            }
        } else {

            DBGMSG(DBG_WARNING, ("InitializeRegUser: RegGetKeySecurity failed %d\n",
                                 dwError));
        }
        RegCloseKey(hKey);

    } else {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegOpenKeyEx CurrentVersion failed %d\n",
                             dwError));
    }


    hToken = RevertToPrinterSelf();

    //
    // Open up the right keys.
    //
    if (RegCreateKeyEx(pUser->hKeyUser,
                       szRegDevicesPath,
                       0,
                       szNULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &pUser->hKeyDevices,
                       &dwDisposition) != ERROR_SUCCESS) {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegCreateKeyEx1 failed %d\n",
                             GetLastError()));

        goto Fail;
    }

    if (bSecurityLoaded) {
        RegSetKeySecurity(pUser->hKeyDevices,
                          DACL_SECURITY_INFORMATION,
                          pSD);
    }


    if (RegCreateKeyEx(pUser->hKeyUser,
                       szRegPrinterPortsPath,
                       0,
                       szNULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &pUser->hKeyPrinterPorts,
                       &dwDisposition) != ERROR_SUCCESS) {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegCreateKeyEx2 failed %d\n",
                             GetLastError()));

        goto Fail;
    }

    if (bSecurityLoaded) {
        RegSetKeySecurity(pUser->hKeyPrinterPorts,
                          DACL_SECURITY_INFORMATION,
                          pSD);
    }

    //
    // First, attempt to clear out the keys by deleting them.
    //
    RegClearKey(pUser->hKeyDevices);
    RegClearKey(pUser->hKeyPrinterPorts);

    if (RegOpenKeyEx(pUser->hKeyUser,
                     szRegWindowsPath,
                     0,
                     KEY_READ|KEY_WRITE,
                     &pUser->hKeyWindows) != ERROR_SUCCESS) {

        DBGMSG(DBG_WARNING, ("InitializeRegUser: RegOpenKeyEx failed %d\n",
                             GetLastError()));

        goto Fail;
    }

    pUser->bFoundPrinter = FALSE;
    pUser->bDefaultSearch = FALSE;
    pUser->bDefaultFound = FALSE;
    pUser->bFirstPrinterFound = FALSE;
    pUser->dwNetCounter = 0;


    cbData = sizeof(pUser->szDefaultPrinter);

    if (RegQueryValueEx(pUser->hKeyWindows,
                        szDevice,
                        NULL,
                        NULL,
                        (PBYTE)pUser->szDefaultPrinter,
                        &cbData) == ERROR_SUCCESS) {

        pUser->bDefaultSearch = TRUE;
    }

    //
    // Remove the Device= in [windows]
    //
    RegDeleteValue(pUser->hKeyWindows,
                   szDevice);

    if (!pUser->bDefaultSearch) {

        //
        // Attempt to read from saved location.
        //
        if (RegOpenKeyEx(pUser->hKeyUser,
                         szPrinters,
                         0,
                         KEY_READ,
                         &hKey) == ERROR_SUCCESS) {

            cbData = sizeof(pUser->szDefaultPrinter);

            //
            // Try reading szDeviceOld.
            //
            if (RegQueryValueEx(
                    hKey,
                    szDeviceOld,
                    NULL,
                    NULL,
                    (PBYTE)pUser->szDefaultPrinter,
                    &cbData) == ERROR_SUCCESS) {

                pUser->bDefaultSearch = TRUE;
            }

            RegCloseKey(hKey);
        }
    }

    if ( pUser->bDefaultSearch   &&
         (p = wcschr(pUser->szDefaultPrinter, L',')) )
            *p = 0;

    rc = TRUE;

Fail:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    if (pSD) {
        FreeSplMem(pSD);
    }

    if (!rc)
        FreeRegUser(pUser);

    return rc;
}


VOID
FreeRegUser(
    PINIT_REG_USER pUser)

/*++

Routine Description:

    Free up the INIT_REG_USER structure intialized by InitializeRegUser.

Arguments:

Return Value:

--*/

{
    if (pUser->hKeyUser) {
        RegCloseKey(pUser->hKeyUser);
        pUser->hKeyUser = NULL;
    }

    if (pUser->hKeyDevices) {
        RegCloseKey(pUser->hKeyDevices);
        pUser->hKeyDevices = NULL;
    }

    if (pUser->hKeyPrinterPorts) {
        RegCloseKey(pUser->hKeyPrinterPorts);
        pUser->hKeyPrinterPorts = NULL;
    }

    if (pUser->hKeyWindows) {
        RegCloseKey(pUser->hKeyWindows);
        pUser->hKeyWindows = NULL;
    }
}


VOID
UpdatePrinterRegAll(
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL bDelete
    )
/*++

Routine Description:

    Updates everyone's [devices] and [printerports] sections (for
    local printers only).

Arguments:

    pszPrinterName - printer that has been added/deleted

    pszPort - port name; if NULL, generate NetId

    bDelete - if TRUE, delete entry instead of updating it.

Return Value:

--*/
{
    WCHAR szKey[MAX_PATH];
    DWORD cchKey;
    DWORD i;
    FILETIME ftLastWriteTime;
    DWORD dwError;

    //
    // Go through all keys and fix them up.
    //
    for (i=0; TRUE; i++) {

        cchKey = COUNTOF(szKey);

        dwError = RegEnumKeyEx(HKEY_USERS,
                               i,
                               szKey,
                               &cchKey,
                               NULL,
                               NULL,
                               NULL,
                               &ftLastWriteTime);

        if (dwError != ERROR_SUCCESS)
            break;

        if (!_wcsicmp(szKey, szDotDefault) || wcschr(szKey, L'_'))
            continue;

        UpdatePrinterRegUser(NULL,
                             szKey,
                             pszPrinterName,
                             pszPort,
                             bDelete);
    }
}


DWORD
UpdatePrinterRegUser(
    HKEY hKeyUser,
    LPWSTR pszUserKey,
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL bDelete
    )
/*++

Routine Description:

    Update one user's registry.  The user is specified by either
    hKeyUser or pszUserKey.

Arguments:

    hKeyUser - Clients user key (ignored if pszKey specified)

    pszUserKey - Clients SID (Used if supplied instead of hKeyUser)

    pszPrinterName - name of printe to add

    pszPort - port name; if NULL, generate NetId

    bDelete - if TRUE, delete entry instead of updating.

Return Value:

    NOTE: We never cleanup [ports] since it is per-user
          EITHER hKeyUser or pszUserKey must be valid, but not both.

--*/
{
    HKEY hKeyClose = NULL;
    HKEY hKeyRoot;
    DWORD dwError;
    WCHAR szBuffer[MAX_PATH];
    DWORD dwNetId;

    INIT_REG_USER InitRegUser;

    ZeroMemory(&InitRegUser, sizeof(InitRegUser));

    InitRegUser.hKeyDevices = NULL;
    InitRegUser.hKeyPrinterPorts = NULL;
    InitRegUser.bDefaultSearch = FALSE;
    InitRegUser.bFirstPrinterFound = TRUE;

    //
    // Setup the registry keys.
    //
    if (pszUserKey) {

        dwError = RegOpenKeyEx( HKEY_USERS,
                                pszUserKey,
                                0,
                                KEY_READ|KEY_WRITE,
                                &hKeyRoot );

        if (dwError != ERROR_SUCCESS) {
            goto Done;
        }

        hKeyClose = hKeyRoot;

    } else {

        hKeyRoot = hKeyUser;
    }

    dwError = RegOpenKeyEx(hKeyRoot,
                           szRegDevicesPath,
                           0,
                           KEY_READ|KEY_WRITE,
                           &InitRegUser.hKeyDevices);

    if (dwError != ERROR_SUCCESS)
        goto Done;

    dwError = RegOpenKeyEx(hKeyRoot,
                           szRegWindowsPath,
                           0,
                           KEY_READ|KEY_WRITE,
                           &InitRegUser.hKeyWindows);

    if (dwError != ERROR_SUCCESS)
        goto Done;

    //
    // Setup [PrinterPorts]
    //
    dwError = RegOpenKeyEx(hKeyRoot,
                           szRegPrinterPortsPath,
                           0,
                           KEY_WRITE,
                           &InitRegUser.hKeyPrinterPorts);

    if (dwError != ERROR_SUCCESS)
        goto Done;

    if (!bDelete) {

        pszPort = CheckBadPortName( pszPort );

        if( !pszPort ){
            dwNetId = GetNetworkIdWorker(InitRegUser.hKeyDevices,
                                         pszPrinterName);
        }

        InitRegUser.bFirstPrinterFound = FALSE;

        UpdatePrinterInfo( &InitRegUser,
                           pszPrinterName,
                           pszPort,
                           &dwNetId );

        UpdateUsersDefaultPrinter( &InitRegUser,
                                   TRUE );

    } else {

        HKEY hKeyDevMode;

        //
        // Delete the entries.
        //
        RegDeleteValue(InitRegUser.hKeyDevices, pszPrinterName);
        RegDeleteValue(InitRegUser.hKeyPrinterPorts, pszPrinterName);

        //
        // Check if the printer we are deleting is currently the
        // default printer.
        //
        if (IsUsersDefaultPrinter(&InitRegUser, pszPrinterName) == S_OK) {

            //
            // Remove the default printer from the registry.
            //
            RegDeleteValue(InitRegUser.hKeyWindows, szDevice);
        }

        //
        // Also delete DevModes2 entry from registry
        //
        dwError = RegOpenKeyEx( hKeyRoot,
                                szDevModes2Path,
                                0,
                                KEY_WRITE,
                                &hKeyDevMode );

        if (dwError == ERROR_SUCCESS) {

            //
            //  Delete the devmode value entry for the particular printer
            //
            RegDeleteValue(hKeyDevMode, pszPrinterName);
            RegCloseKey(hKeyDevMode);
        }

        //
        // Remove the per-user DevMode.
        //
        bSetDevModePerUser( hKeyRoot,
                            pszPrinterName,
                            NULL );
    }

Done:

    if( InitRegUser.hKeyDevices ){
        RegCloseKey( InitRegUser.hKeyDevices );
    }

    if( InitRegUser.hKeyWindows ){
        RegCloseKey( InitRegUser.hKeyWindows );
    }

    if( InitRegUser.hKeyPrinterPorts ){
        RegCloseKey( InitRegUser.hKeyPrinterPorts );
    }

    if( hKeyClose ){
        RegCloseKey( hKeyClose );
    }

    return dwError;
}


VOID
RegClearKey(
    HKEY hKey
    )
{
    DWORD dwError;
    WCHAR szValue[MAX_PATH];

    DWORD cchValue;

    while (TRUE) {

        cchValue = COUNTOF(szValue);
        dwError = RegEnumValue(hKey,
                               0,
                               szValue,
                               &cchValue,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (dwError != ERROR_SUCCESS) {

            if( dwError != ERROR_NO_MORE_ITEMS ){
                DBGMSG( DBG_WARN, ( "RegClearKey: RegEnumValue failed %d\n", dwError ));
            }
            break;
        }

        dwError = RegDeleteValue(hKey, szValue);

        if( dwError != ERROR_SUCCESS) {
            DBGMSG( DBG_WARN, ( "RegClearKey: RegDeleteValue failed %d\n", dwError ));
            break;
        }
    }
}


LPWSTR
CheckBadPortName(
    LPWSTR pszPort
    )
/*++

Routine Description:

    This routine checks whether a port name should be converted to
    NeXX:.  Currently if the port is NULL, or "\\*," or has a space,
    we convert to NeXX.

Arguments:

    pszPort - port to check

Return Value:

    pszPort - if port is OK.
    NULL    - if port needs to be converted

--*/

{
    //
    // If we have no pszPort,                          OR
    //     it begins with '\\' (as in \\server\share)  OR
    //     it has a space in it                        OR
    //     it's length is greater than 5 ("LPT1:")
    // Then
    //     use NeXX:
    //
    // Most 16 bit apps can't deal with long port names, since they
    // allocate small buffers.
    //
    if( !pszPort ||
        ( pszPort[0] == L'\\' && pszPort[1] == L'\\' ) ||
        wcschr( pszPort, L' ' )                        ||
        wcslen( pszPort ) > 5 ){

        return NULL;
    }
    return pszPort;
}


BOOL
UpdateLogonTimeStamp(
    void
    )
{
    long lstatus;
    HKEY hProvidersKey  = NULL;
    FILETIME   LogonTime;

    LPWSTR szPrintProviders = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Providers";
    LPWSTR szLogonTime      = L"LogonTime";

    GetSystemTimeAsFileTime (&LogonTime);

    // Create (if not already present) and open Connections subkey
    lstatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             szPrintProviders,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hProvidersKey,
                             NULL);

    if (lstatus == ERROR_SUCCESS) {

        lstatus = RegSetValueEx (hProvidersKey,
                                 szLogonTime,
                                 0,
                                 REG_BINARY,
                                 (LPBYTE) &LogonTime,
                                 sizeof (FILETIME));

        RegCloseKey(hProvidersKey);
    }

    return lstatus == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\spooler.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    spooler.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "winsprlp.h"
//
// RPC Buffer size 64K
//
#define BUFFER_SIZE  0x10000


DWORD
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpStartDocPrinter)
                                                    (pPrintHandle->hPrinter,
                                                     Level, pDocInfo);
}

BOOL
StartPagePrinter(
   HANDLE hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpStartPagePrinter)
                                                    (pPrintHandle->hPrinter);
}

BOOL
SplCommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)

/*++
Function Description: Commits data written into the spool file. creates a new temp
                      file handle for remote printing.

Parameters: hPrinter       - printer handle
            hAppProcess    - application process handle
            cbCommit       - number of bytes to commit (incremental)
            dwLevel        - spoolfileinfo level
            pSpoolFileInfo - pointer to buffer
            cbBuf          - buffer size
            pcbNeeded      - pointer to return required buffer size

Return Values: TRUE if sucessful;
               FALSE otherwise
--*/

{
    BOOL   bReturn = FALSE;
    DWORD  cbTotalWritten, cbWritten, cbRead, cbToRead;
    BYTE   *Buffer = NULL;
    HANDLE hFile, hSpoolerProcess = NULL, hFileApp = INVALID_HANDLE_VALUE;

    PSPOOL_FILE_INFO_1  pSpoolFileInfo1;
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;

    // Check Handle validity
    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return bReturn;
    }

    // Check for valid level and sufficient buffer
    switch (dwLevel) {
    case 1:
       if (cbBuf < sizeof(SPOOL_FILE_INFO_1)) {
           SetLastError(ERROR_INSUFFICIENT_BUFFER);
           *pcbNeeded = sizeof(SPOOL_FILE_INFO_1);
           goto CleanUp;
       }

       pSpoolFileInfo1 = (PSPOOL_FILE_INFO_1)pSpoolFileInfo;
       break;

    default:
       SetLastError(ERROR_INVALID_LEVEL);
       goto CleanUp;
    }

    // Initialize spoolfileinfo1 struct
    pSpoolFileInfo1->dwVersion = 1;
    pSpoolFileInfo1->hSpoolFile = INVALID_HANDLE_VALUE;
    pSpoolFileInfo1->dwAttributes = SPOOL_FILE_PERSISTENT;

    if (pPrintHandle->pProvidor == pLocalProvidor) {

        bReturn  = (pLocalProvidor->PrintProvidor.fpCommitSpoolData)(pPrintHandle->hPrinter,
                                                                     cbCommit);
        return bReturn;
    }

    // For remote printing send the temp file across the wire using WritePrinter
    if (pPrintHandle->hFileSpooler == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return bReturn;
    }

    hFile = pPrintHandle->hFileSpooler;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff) {
        goto CleanUp;
    }

    //
    // Use a Buffer to send Data over RPC.
    //
    Buffer = AllocSplMem(BUFFER_SIZE);
    
    if ( !Buffer ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto CleanUp;
    }
    
    while ((cbToRead = min(cbCommit, BUFFER_SIZE)) &&
           ReadFile(hFile, Buffer, cbToRead, &cbRead, NULL)) {

         cbCommit -= cbRead;

         for (cbTotalWritten = 0;
              cbTotalWritten < cbRead;
              cbTotalWritten += cbWritten) {

            if (!(*pPrintHandle->pProvidor->PrintProvidor.fpWritePrinter)
                                                            (pPrintHandle->hPrinter,
                                                             (LPBYTE)Buffer + cbTotalWritten,
                                                             cbRead - cbTotalWritten,
                                                             &cbWritten)) {
                goto CleanUp;
            }
         }
    }

    if (Buffer) {
        FreeSplMem(Buffer);
        Buffer = NULL;
    }
    
    if ((cbToRead != 0) ||
        (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff)) {

        goto CleanUp;
    }

    if ((hSpoolerProcess = GetCurrentProcess()) &&
        DuplicateHandle(hSpoolerProcess,
                        pPrintHandle->hFileSpooler,
                        hAppProcess,
                        &hFileApp,
                        0,
                        TRUE,
                        DUPLICATE_SAME_ACCESS)) {

        pSpoolFileInfo1->dwVersion = 1;
        pSpoolFileInfo1->hSpoolFile = hFileApp;
        pSpoolFileInfo1->dwAttributes = SPOOL_FILE_TEMPORARY;

        bReturn = TRUE;
    }

CleanUp:

    if (Buffer) {
        FreeSplMem(Buffer);
    }
    if (hSpoolerProcess) {
        CloseHandle(hSpoolerProcess);
    }
    return bReturn;
}

BOOL
SplCloseSpoolFileHandle(
    HANDLE  hPrinter
)

/*++
Function Description: Closes the remote spool file handle for remote printing.

Parameters: hPrinter - printer handle

Return Values: TRUE if sucessful;
               FALSE otherwise
--*/

{
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;

    // Check Handle validity
    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pPrintHandle->pProvidor == pLocalProvidor) {

        return (pLocalProvidor->PrintProvidor.fpCloseSpoolFileHandle)(pPrintHandle->hPrinter);

    } else if ((pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE)) {

        // close temp files for remote printing
        CloseHandle(pPrintHandle->hFileSpooler);
        pPrintHandle->hFileSpooler = INVALID_HANDLE_VALUE;

        if (pPrintHandle->szTempSpoolFile) {

            HANDLE hToken = RevertToPrinterSelf();

            if (!DeleteFile(pPrintHandle->szTempSpoolFile)) {

                MoveFileEx(pPrintHandle->szTempSpoolFile, NULL,
                           MOVEFILE_DELAY_UNTIL_REBOOT);
            }

            if (hToken)
            {
                ImpersonatePrinterClient(hToken);
            }

            FreeSplMem(pPrintHandle->szTempSpoolFile);
            pPrintHandle->szTempSpoolFile = NULL;
        }
    }

    return TRUE;
}


BOOL
SplGetSpoolFileInfo(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)

/*++
Function Description: Get spool file info for the job in hPrinter. For local jobs
                      localspl returns the hFile. For remote jobs a temp file is created
                      by the router. The file handle is dupped into the application.

Parameters: hPrinter       - printer handle
            hAppProcess    - application process handle
            dwLevel        - spool file info level
            pSpoolFileInfo - pointer to buffer
            cbBuf          - buffer size
            pcbNeeded      - pointer to return required buffer size

Return Values: TRUE if sucessful;
               FALSE otherwise
--*/

{
    HANDLE   hFileSpooler = NULL, hFileApp = NULL;
    HANDLE   hSpoolerProcess = NULL;
    BOOL     bReturn = FALSE;
    DWORD    dwSpoolerProcessID;
    LPWSTR   pSpoolDir = NULL;

    PSPOOL_FILE_INFO_1  pSpoolFileInfo1;
    LPPRINTHANDLE       pPrintHandle = (LPPRINTHANDLE)hPrinter;

    // Check Handle validity
    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto CleanUp;
    }

    // Check for valid level and sufficient buffer
    switch (dwLevel) {
    case 1:
       if (cbBuf < sizeof(SPOOL_FILE_INFO_1)) {
           SetLastError(ERROR_INSUFFICIENT_BUFFER);
           *pcbNeeded = sizeof(SPOOL_FILE_INFO_1);
           goto CleanUp;
       }

       pSpoolFileInfo1 = (PSPOOL_FILE_INFO_1)pSpoolFileInfo;
       break;

    default:
       SetLastError(ERROR_INVALID_LEVEL);
       goto CleanUp;
    }

    if (!(hSpoolerProcess = GetCurrentProcess())) {
        // Cant get a pseudo handle to the spooler
        goto CleanUp;
    }

    if ((pPrintHandle->pProvidor != pLocalProvidor) &&
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE)) {

        // Return cached temp file handle.
        bReturn = DuplicateHandle(hSpoolerProcess,
                                  pPrintHandle->hFileSpooler,
                                  hAppProcess,
                                  &hFileApp,
                                  0,
                                  TRUE,
                                  DUPLICATE_SAME_ACCESS);
        if (bReturn) {
            pSpoolFileInfo1->dwVersion = 1;
            pSpoolFileInfo1->hSpoolFile = hFileApp;
            pSpoolFileInfo1->dwAttributes = SPOOL_FILE_TEMPORARY;
        }

        goto CleanUp;
    }

    if (pPrintHandle->pProvidor == pLocalProvidor) {

        bReturn  = (pLocalProvidor->PrintProvidor.fpGetSpoolFileInfo)(pPrintHandle->hPrinter,
                                                                      NULL,
                                                                      &hFileApp,
                                                                      hSpoolerProcess,
                                                                      hAppProcess);

        if (bReturn) {
            pSpoolFileInfo1->dwVersion = 1;
            pSpoolFileInfo1->hSpoolFile = hFileApp;
            pSpoolFileInfo1->dwAttributes = SPOOL_FILE_PERSISTENT;
        }

        goto CleanUp;

    } else {

        bReturn  = (pLocalProvidor->PrintProvidor.fpGetSpoolFileInfo)(NULL, &pSpoolDir,
                                                                      NULL, NULL, NULL);
    }

    // Remote Printing, create a temp file in the spool directory
    if (bReturn) {

        HANDLE hToken;

        //
        // Revert to system context to ensure that we can open the file.
        //
        hToken = RevertToPrinterSelf();

        if ((pPrintHandle->szTempSpoolFile = AllocSplMem(MAX_PATH * sizeof(WCHAR))) &&

            GetTempFileName(pSpoolDir, L"SPL", 0, pPrintHandle->szTempSpoolFile)    &&

            ((pPrintHandle->hFileSpooler = CreateFile(pPrintHandle->szTempSpoolFile,
                                                      GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                      NULL,
                                                      CREATE_ALWAYS,
                                                      0, NULL)) != INVALID_HANDLE_VALUE) &&
            DuplicateHandle(hSpoolerProcess,
                            pPrintHandle->hFileSpooler,
                            hAppProcess,
                            &hFileApp,
                            0,
                            TRUE,
                            DUPLICATE_SAME_ACCESS)) {

            pSpoolFileInfo1->dwVersion = 1;
            pSpoolFileInfo1->hSpoolFile = hFileApp;
            pSpoolFileInfo1->dwAttributes = SPOOL_FILE_TEMPORARY;

        } else {

            bReturn = FALSE;
        }

        if (hToken)
        {
            ImpersonatePrinterClient(hToken);
        }
    }

CleanUp:

    if (hSpoolerProcess) {
        CloseHandle(hSpoolerProcess);
    }
    if (pSpoolDir) {
        FreeSplMem(pSpoolDir);
    }

    return bReturn;
}

BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle ||
        (pPrintHandle->signature != PRINTHANDLE_SIGNATURE) ||
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE)) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpWritePrinter) (pPrintHandle->hPrinter,
                                                    pBuf, cbBuf, pcWritten);
}

BOOL
SeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;
    LARGE_INTEGER   liNewPointer;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Allow a NULL pliNewPointer to be passed in.
    //
    if( !pliNewPointer ){
        pliNewPointer = &liNewPointer;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSeekPrinter) (
               pPrintHandle->hPrinter,
               liDistanceToMove,
               pliNewPointer,
               dwMoveMethod,
               bWritePrinter );
}

BOOL
FlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)

/*++
Function Description: FlushPrinter is typically used by the driver to send a burst of zeros
                      to the printer and introduce a delay in the i/o line to the printer.
                      The spooler does not schedule any job for cSleep milliseconds.

Parameters:  hPrinter  - printer handle
             pBuf      - buffer to be sent to the printer
             cbBuf     - size of the buffer
             pcWritten - pointer to return the number of bytes written
             cSleep    - sleep time in milliseconds.

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    //
    // Check for valid printer handle
    //
    if (!pPrintHandle ||
        (pPrintHandle->signature != PRINTHANDLE_SIGNATURE) ||
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpFlushPrinter) (pPrintHandle->hPrinter,
                                                                     pBuf,
                                                                     cbBuf,
                                                                     pcWritten,
                                                                     cSleep);
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEndPagePrinter) (pPrintHandle->hPrinter);
}

BOOL
AbortPrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpAbortPrinter) (pPrintHandle->hPrinter);
}

BOOL
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pRead
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpReadPrinter)
                          (pPrintHandle->hPrinter, pBuf, cbBuf, pRead);
}

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSplReadPrinter)
                          (pPrintHandle->hPrinter, pBuf, cbBuf);
}

BOOL
EndDocPrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEndDocPrinter) (pPrintHandle->hPrinter);
}

HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW   pDevMode
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;
    HANDLE  ReturnValue;
    PGDIHANDLE  pGdiHandle;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pGdiHandle = AllocSplMem(sizeof(GDIHANDLE));

    if (!pGdiHandle) {

        DBGMSG(DBG_WARN, ("Failed to alloc GDI handle."));
        return FALSE;
    }

    ReturnValue = (HANDLE)(*pPrintHandle->pProvidor->PrintProvidor.fpCreatePrinterIC)
                                              (pPrintHandle->hPrinter,
                                               pDevMode);

    if (ReturnValue) {

        pGdiHandle->signature = GDIHANDLE_SIGNATURE;
        pGdiHandle->pProvidor = pPrintHandle->pProvidor;
        pGdiHandle->hGdi = ReturnValue;

        return pGdiHandle;
    }

    FreeSplMem(pGdiHandle);

    return FALSE;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE pIn,
    DWORD   cIn,
    LPBYTE pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    PGDIHANDLE   pGdiHandle=(PGDIHANDLE)hPrinterIC;

    if (!pGdiHandle || pGdiHandle->signature != GDIHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pGdiHandle->pProvidor->PrintProvidor.fpPlayGdiScriptOnPrinterIC)
                            (pGdiHandle->hGdi, pIn, cIn, pOut, cOut, ul);
}

BOOL
DeletePrinterIC(
    HANDLE hPrinterIC
)
{
    LPGDIHANDLE   pGdiHandle=(LPGDIHANDLE)hPrinterIC;

    if (!pGdiHandle || pGdiHandle->signature != GDIHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((*pGdiHandle->pProvidor->PrintProvidor.fpDeletePrinterIC) (pGdiHandle->hGdi)) {

        FreeSplMem(pGdiHandle);
        return TRUE;
    }

    return FALSE;
}

DWORD
PrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpPrinterMessageBox)
                    (hPrinter, Error, hWnd, pText, pCaption, dwType);

}

DWORD 
SendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    DWORD         dwRet = ERROR_SUCCESS;
    LPPRINTHANDLE pPrintHandle = (LPPRINTHANDLE)hPrinter;
    //
    // Check for valid printer handle
    //
    if (!pPrintHandle ||
        (pPrintHandle->signature != PRINTHANDLE_SIGNATURE) ||
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE))
    {
        dwRet = ERROR_INVALID_HANDLE;
    }
    else
    {
        dwRet = (*pPrintHandle->pProvidor->PrintProvidor.fpSendRecvBidiData)(pPrintHandle->hPrinter,
                                                                             pAction,
                                                                             pReqData,
                                                                             ppResData);
    }
    return (dwRet);
}


/*++


Routine Name: 

    SplPromptUIInUsersSession 

Routine Description: 

    Pops message boxes in the user's session.
    For Whistler this function shows only message boxes in Spoolsv.exe.
    
Arguments:

    hPrinter  -- printer handle
    JobId     -- job ID
    pUIParams -- UI parameters
    pResponse -- user's response

Return Value:

    TRUE if succeeded 

Last Error:
 
    Win32 error

--*/
BOOL
SplPromptUIInUsersSession(
    IN  HANDLE          hPrinter,
    IN  DWORD           JobId,
    IN  PSHOWUIPARAMS   pUIParams,
    OUT DWORD           *pResponse
)
{
    typedef BOOL (*FPPROMPT_UI)(HANDLE, DWORD, PSHOWUIPARAMS, DWORD*);

    FPPROMPT_UI     fpPromptUIPerSessionUser;
    BOOL            bRetValue = FALSE;
    PPRINTHANDLE    pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (pPrintHandle && pPrintHandle->signature == PRINTHANDLE_SIGNATURE) 
    {
        if (pPrintHandle->pProvidor == pLocalProvidor &&
            (fpPromptUIPerSessionUser = (FPPROMPT_UI)GetProcAddress(pLocalProvidor->hModule, 
                                                                   "LclPromptUIPerSessionUser"))) 
        {                
            bRetValue = (*fpPromptUIPerSessionUser)(pPrintHandle->hPrinter, JobId, pUIParams, pResponse);
        }            
        else 
        {
            SetLastError(ERROR_NOT_SUPPORTED);
        }        
    }
    else 
    {
        SetLastError(ERROR_INVALID_HANDLE);
    }

    return bRetValue;
}


/*++


Routine Name: 

    SplIsSessionZero 

Routine Description: 

    Determine is user that submitted a certain job runs in Session 0. 
    It is used by Canon monitor to determine when to show 
    resource template base UI versus calling SplPromptUIInUsersSession.

Arguments:

    hPrinter       -- printer handle
    JobId          -- job ID
    pIsSessionZero -- TRUE if user runs in Session 0

Return Value:

    Win32 last error

Last Error:

--*/
DWORD
SplIsSessionZero(
    IN  HANDLE  hPrinter,
    IN  DWORD   JobId,
    OUT BOOL    *pIsSessionZero
)
{
    typedef DWORD (*FPISSESSIONZERO)(HANDLE, DWORD, BOOL*);

    FPISSESSIONZERO fpIsSessionZero;
    DWORD           dwRetValue = ERROR_SUCCESS;
    PPRINTHANDLE    pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (pPrintHandle && pPrintHandle->signature == PRINTHANDLE_SIGNATURE) 
    {
        if (pPrintHandle->pProvidor == pLocalProvidor && 
            (fpIsSessionZero = (FPISSESSIONZERO)GetProcAddress(pLocalProvidor->hModule, 
                                                              "LclIsSessionZero"))) 
        {                
            dwRetValue = (*fpIsSessionZero)(pPrintHandle->hPrinter, JobId, pIsSessionZero);
        }            
        else 
        {
            dwRetValue = ERROR_NOT_SUPPORTED;
        }        
    }
    else 
    {
        dwRetValue = ERROR_INVALID_HANDLE;
    }

    return dwRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\threadm.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ThreadM.c

Abstract:

    Generic thread manager for spooler.

Author:

    Albert Ting (AlbertT) 13-Feb-1994

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "threadm.h"

#define ENTER_CRITICAL(pTMStateVar) \
    EnterCriticalSection(pTMStateVar->pTMStateStatic->pCritSec)
#define LEAVE_CRITICAL(pTMStateVar) \
    LeaveCriticalSection(pTMStateVar->pTMStateStatic->pCritSec)

//
// Prototypes
//
DWORD
xTMThreadProc(
    LPVOID pVoid);


BOOL
TMCreateStatic(
    PTMSTATESTATIC pTMStateStatic)

/*++

Routine Description:

    Intialize static state.

Arguments:

    pTMStateStatic - static state to initialize

Return Value:

    TRUE = success
    FALSE = fail

--*/

{
    return TRUE;
}




VOID
TMDestroyStatic(
    PTMSTATESTATIC pTMStateStatic)

/*++

Routine Description:

    Destroys static state.

Arguments:

    pTMStateStatic - static state to destroy

Return Value:

    VOID

--*/

{
}




BOOL
TMCreate(
    PTMSTATESTATIC pTMStateStatic,
    PTMSTATEVAR pTMStateVar)

/*++

Routine Description:

    Creates a virtual TM object.

Arguments:

    pTMStateStatic - static portion of the TM object that can be
                     used multiple times for subsequent instantiations.

    pTMStateVar    - variable portion of the structure; 1 per instantiation

Return Value:

    TRUE = success
    FALSE = fail

--*/

{
    pTMStateVar->hTrigger = CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

    if (!pTMStateVar->hTrigger)
        return FALSE;

    pTMStateVar->uIdleThreads   = 0;
    pTMStateVar->uActiveThreads = 0;
    pTMStateVar->Status = TMSTATUS_NULL;
    pTMStateVar->pTMStateStatic = pTMStateStatic;

    return TRUE;
}

BOOL
TMDestroy(
    PTMSTATEVAR pTMStateVar)

/*++

Routine Description:

    Destroy TM object.  If threads are currently processing the object,
    mark it pending and return.

Arguments:

    pTMStateVar - TM Object to destroy

Return Value:

    TRUE = success
    FALSE = fail

--*/

{
    ENTER_CRITICAL(pTMStateVar);

    pTMStateVar->Status |= TMSTATUS_DESTROY_REQ;

    if (!pTMStateVar->uActiveThreads) {

        //
        // Mark as destroyed so that no more jobs are processed.
        //
        pTMStateVar->Status |= TMSTATUS_DESTROYED;

        LEAVE_CRITICAL(pTMStateVar);

        if (pTMStateVar->pTMStateStatic->pfnCloseState)
            (*pTMStateVar->pTMStateStatic->pfnCloseState)(pTMStateVar);

    } else {

        LEAVE_CRITICAL(pTMStateVar);
    }

    return TRUE;
}


BOOL
TMAddJob(
    PTMSTATEVAR pTMStateVar)
{
    DWORD dwThreadId;
    HANDLE hThread;
    BOOL rc = TRUE;

    ENTER_CRITICAL(pTMStateVar);

    if (pTMStateVar->Status & TMSTATUS_DESTROY_REQ) {

        rc = FALSE;

    } else {

        //
        // Check if we can give it to an idle thread.
        //
        if (pTMStateVar->uIdleThreads) {

            pTMStateVar->uIdleThreads--;

            DBGMSG(DBG_NOTIFY, ("Trigger event: uIdleThreads = %d\n",
                                pTMStateVar->uIdleThreads));

            SetEvent(pTMStateVar->hTrigger);

        } else if (pTMStateVar->uActiveThreads <
            pTMStateVar->pTMStateStatic->uMaxThreads) {

            //
            // We have less active threads than the max; create a new one.
            //
            DBGMSG(DBG_NOTIFY, ("Create thread: uActiveThreads = %d\n",
                                pTMStateVar->uActiveThreads));

            hThread = CreateThread(NULL,
                                   0,
                                   xTMThreadProc,
                                   pTMStateVar,
                                   0,
                                   &dwThreadId);
            if (hThread) {

                CloseHandle(hThread);

                //
                // We have successfully created a thread; up the
                // count.
                //
                pTMStateVar->uActiveThreads++;

            } else {

                rc = FALSE;
            }
        }
    }

    LEAVE_CRITICAL(pTMStateVar);

    return rc;
}

DWORD
xTMThreadProc(
    LPVOID pVoid)

/*++

Routine Description:

    Worker thread routine that calls the client to process the jobs.

Arguments:

    pVoid - pTMStateVar

Return Value:

    Ignored.

--*/

{
    PTMSTATEVAR pTMStateVar = (PTMSTATEVAR)pVoid;
    PJOB pJob;
    BOOL bQuit = FALSE;

    pJob = (*pTMStateVar->pTMStateStatic->pfnNextJob)(pTMStateVar);

    do {

        while (pJob) {

            //
            // Call back to client to process the job.
            //
            (*pTMStateVar->pTMStateStatic->pfnProcessJob)(pTMStateVar, pJob);

            //
            // If we are pending shutdown, quit now.
            //
            if (pTMStateVar->Status & TMSTATUS_DESTROY_REQ) {
                bQuit = TRUE;
                break;
            }

            pJob = (*pTMStateVar->pTMStateStatic->pfnNextJob)(pTMStateVar);
        }

        ENTER_CRITICAL(pTMStateVar);

        pTMStateVar->uIdleThreads++;
        pTMStateVar->uActiveThreads--;

        DBGMSG(DBG_NOTIFY, ("Going to sleep: uIdle = %d, uActive = %d\n",
                            pTMStateVar->uIdleThreads,
                            pTMStateVar->uActiveThreads));

        LEAVE_CRITICAL(pTMStateVar);

        if (bQuit)
            break;

        //
        // Done, now relax and go idle for a bit.  We don't care whether
        // we timeout or get triggered; in either case we check for another
        // job.
        //
        WaitForSingleObject(pTMStateVar->hTrigger,
                            pTMStateVar->pTMStateStatic->uIdleLife);

        ENTER_CRITICAL(pTMStateVar);

        if (pTMStateVar->Status & TMSTATUS_DESTROY_REQ) {

            pJob = NULL;

        } else {

            //
            // We must check here instead of relying on the return value
            // of WaitForSingleObject since someone may see uIdleThreads!=0
            // and set the trigger, but we timeout before it gets set.
            //
            pJob = (*pTMStateVar->pTMStateStatic->pfnNextJob)(pTMStateVar);

        }

        if (pJob) {

            pTMStateVar->uActiveThreads++;

            DBGMSG(DBG_NOTIFY, ("Woke and found job: uActiveThreads = %d\n",
                                pTMStateVar->uActiveThreads));
        } else {

            if (!pTMStateVar->uIdleThreads) {

                //
                // We may add a job that already is on the list, so
                // uIdleThreads gets dec'd twice, but only 1 job left.
                //
                DBGMSG(DBG_NOTIFY, ("threadm: No jobs, yet no idle threads\n"));

            } else {

                //
                // No jobs, we are going to exit, so we are no longer idle
                //
                pTMStateVar->uIdleThreads--;
            }
        }

        LEAVE_CRITICAL(pTMStateVar);

    } while (pJob);

    DBGMSG(DBG_NOTIFY, ("No active jobs: uIdleThreads = %d, uActiveThreads = %d\n",
                        pTMStateVar->uIdleThreads,
                        pTMStateVar->uActiveThreads));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\threads.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    threads.c (thread manager)

Abstract:

    Handles the threads used to for notifications (WPC, FFPCN)

Author:

    Albert Ting (AlbertT) 25-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "threadm.h"
#include "ntfytab.h"

#define ENTER_THREAD_LIST() EnterCriticalSection(tmStateStatic.pCritSec)
#define EXIT_THREAD_LIST()  LeaveCriticalSection(tmStateStatic.pCritSec)

extern CRITICAL_SECTION RouterNotifySection;

DWORD
ThreadNotifyProcessJob(
    PTMSTATEVAR pTMStateVar,
    PJOB pJob);

PJOB
ThreadNotifyNextJob(
    PTMSTATEVAR ptmStateVar);


TMSTATESTATIC tmStateStatic = {
    10,
    2500,
    (PFNPROCESSJOB)ThreadNotifyProcessJob,
    (PFNNEXTJOB)ThreadNotifyNextJob,
    NULL,
    NULL,
    &RouterNotifySection
};

TMSTATEVAR tmStateVar;
PCHANGE pChangeList;


WCHAR szThreadMax[] = L"ThreadNotifyMax";
WCHAR szThreadIdleLife[] = L"ThreadNotifyIdleLife";
WCHAR szThreadNotifySleep[] = L"ThreadNotifySleep";

DWORD dwThreadNotifySleep = 1000;


BOOL
ThreadInit()
{
    HKEY hKey;
    DWORD dwType = REG_DWORD;
    DWORD cbData;

    if (!TMCreateStatic(&tmStateStatic))
        return FALSE;

    if (!TMCreate(&tmStateStatic, &tmStateVar))
        return FALSE;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szPrintKey,
                      0,
                      KEY_READ,
                      &hKey)) {

        cbData = sizeof(tmStateStatic.uMaxThreads);

        //
        // Ignore failure case since we default to 10.
        //
        RegQueryValueEx(hKey,
                        szThreadMax,
                        NULL,
                        &dwType,
                        (LPBYTE)&tmStateStatic.uMaxThreads,
                        &cbData);

        cbData = sizeof(tmStateStatic.uIdleLife);

        //
        // Ignore failure case since we default to 1000 (1 sec).
        //
        RegQueryValueEx(hKey,
                        szThreadIdleLife,
                        NULL,
                        &dwType,
                        (LPBYTE)&tmStateStatic.uIdleLife,
                        &cbData);

        cbData = sizeof(dwThreadNotifySleep);

        //
        // Ignore failure case since we default to 2500 (2.5 sec).
        //
        RegQueryValueEx(hKey,
                        szThreadNotifySleep,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwThreadNotifySleep,
                        &cbData);


        RegCloseKey(hKey);
    }

    return TRUE;
}



VOID
ThreadDestroy()
{
    TMDestroy(&tmStateVar);
    TMDestroyStatic(&tmStateStatic);
}


BOOL
LinkChange(
    PCHANGE pChange)

/*++

Routine Description:

    Link up the change to the list of jobs that need to be processed.
    If the call succeeded but there was an overflow at the client,
    then we won't add this to the list until it gets refreshed.

Arguments:

Return Value:

--*/

{
    if (pChange->eStatus & STATUS_CHANGE_DISCARDNOTED) {

        return FALSE;
    }
    pChange->cRef++;
    pChange->eStatus |= STATUS_CHANGE_ACTIVE;
    LinkAdd(&pChange->Link, (PLINK*)&pChangeList);

    return TRUE;
}


BOOL
ThreadNotify(
    LPPRINTHANDLE pPrintHandle)

/*++

Routine Description:

    Handles notifying the remote clients of changes.

Arguments:

    pPrintHandle - printer that requires notification

Return Value:

    TRUE = success, GetLastError() valid on FALSE.

    NOTE: Currenly only supports grouping

--*/

{
    PCHANGE pChange = pPrintHandle->pChange;

    ENTER_THREAD_LIST();

    //
    // Only add if we're not on the linked list already.
    //
    if (!(pChange->eStatus & STATUS_CHANGE_ACTIVE)) {

        DBGMSG(DBG_NOTIFY, ("TMN: link added 0x%x cRef++ %d\n",
                            pChange,
                            pChange->cRef));

        //
        // Only add ourseleves to the linked list and
        // Notify via TMAddJob if we are not on the list.
        //
        if (LinkChange(pChange))
            TMAddJob(&tmStateVar);

    } else {

        pChange->eStatus |= STATUS_CHANGE_ACTIVE_REQ;
        DBGMSG(DBG_NOTIFY, ("TMN: In LL already 0x%x cRef %d\n",
                            pChange,
                            pChange->cRef));
    }


    EXIT_THREAD_LIST();

    return TRUE;
}


PJOB
ThreadNotifyNextJob(
    PTMSTATEVAR ptmStateVar)

/*++

Routine Description:

    Callback to get the next job.

Arguments:

    ptmStateVar - ignored.

Return Value:

    pJob (pChange)

--*/

{
    PCHANGE pChange;

    ENTER_THREAD_LIST();

    //
    // If there are no jobs left, quit.
    //
    pChange = (PCHANGE)pChangeList;

    DBGMSG(DBG_NOTIFY, ("ThreadNotifyNextJob: Removing pChange 0x%x\n",
                        pChange));

    if (pChange) {
        LinkDelete(&pChange->Link, (PLINK*)&pChangeList);
    }

    EXIT_THREAD_LIST();

    return (PJOB)pChange;
}

DWORD
ThreadNotifyProcessJob(
    PTMSTATEVAR pTMStateVar,
    PJOB pJob)

/*++

Routine Description:

    Does the actual RPC call to notify the client.

Arguments:

    pJob = pChange structure

Return Value:

--*/

{
    PCHANGE pChange = (PCHANGE)pJob;
    DWORD fdwChangeFlags;
    HANDLE hNotifyRemote;
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo;
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfoNew;
    RPC_V2_UREPLY_PRINTER Reply;

    DWORD dwReturn;
    DWORD dwResult = 0;
    DWORD dwColor;

    ENTER_THREAD_LIST();

    if (pChange->eStatus & STATUS_CHANGE_CLOSING) {

        //
        // Abort this job
        //
        dwReturn = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    fdwChangeFlags = pChange->fdwChangeFlags;
    pChange->fdwChangeFlags = 0;

    //
    // We must save out this copy in case we have some more info
    // while we are RPCing.  Turn off LL_REQ because we are about
    // to process this batch.
    //
    pPrinterNotifyInfo = pChange->ChangeInfo.pPrinterNotifyInfo;

#if DBG
    if( !pPrinterNotifyInfo && !fdwChangeFlags ){
        DBGMSG( DBG_WARN, ( "ThreadNotifyProcessJob: No change information\n" ));
    }
#endif

    pChange->ChangeInfo.pPrinterNotifyInfo = NULL;
    pChange->eStatus &= ~STATUS_CHANGE_ACTIVE_REQ;
    dwColor = pChange->dwColor;

    //
    // We were already marked in use when the job was added.
    // If another thread wants to delete it, they should OR in
    // STATUS_CHANGE_CLOSING, which we will pickup.
    //

    EXIT_THREAD_LIST();

    if (pChange->hNotifyRemote) {

        DBGMSG(DBG_NOTIFY, (">> Remoting pChange 0x%x hNotifyRemote 0x%x\n",
                            pChange,
                            pChange->hNotifyRemote));

        RpcTryExcept {

            //
            // Note:
            //
            // We should not be impersonating at this stage since
            // we will get a separate session id.
            //
            if (pPrinterNotifyInfo) {

                Reply.pInfo = (PRPC_V2_NOTIFY_INFO)pPrinterNotifyInfo;

                //
                // Remote case; bind and call the remote router.
                //
                dwReturn = RpcRouterReplyPrinterEx(
                               pChange->hNotifyRemote,
                               dwColor,
                               fdwChangeFlags,
                               &dwResult,
                               REPLY_PRINTER_CHANGE,
                               Reply);
            } else {

                dwReturn = RpcRouterReplyPrinter(
                               pChange->hNotifyRemote,
                               fdwChangeFlags,
                               1,
                               (PBYTE)&pPrinterNotifyInfo);
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwReturn = RpcExceptionCode();

        } RpcEndExcept

    } else {

        dwReturn = ERROR_INVALID_HANDLE;
        DBGMSG(DBG_WARNING, ("ThreadNotifyProcessJob: no hNotifyRemote\n"));
    }

    if (dwReturn) {

        DBGMSG(DBG_WARNING, ("ThreadNotifyProcessJob: RPC error %d\npChange 0x%x, hNotifyRemote 0x%x, hPrinterRemote 0x%x\n",
                             dwReturn,
                             pChange,
                             pChange->hNotifyRemote,
                             pChange->dwPrinterRemote));

        //
        // On error, close and retry
        //
        CloseReplyRemote(pChange->hNotifyRemote);

        if (OpenReplyRemote(pChange->pszLocalMachine,
                            &pChange->hNotifyRemote,
                            pChange->dwPrinterRemote,
                            REPLY_TYPE_NOTIFICATION,
                            0,
                            NULL)) {

            pChange->hNotifyRemote = NULL;
        }
    }

    Sleep(dwThreadNotifySleep);

    ENTER_THREAD_LIST();

    pPrinterNotifyInfoNew = pChange->ChangeInfo.pPrinterNotifyInfo;

    //
    // Keep dwResult only if the color is current.
    //
    // The avoids the problem when the server sends a discard (RPC1),
    // then the client refreshes (RPC2).  RPC2 returns first, clearing
    // the client's discard bit.  The server overflows the new
    // buffer.  RPC1 completes, and returns discardnoted, which is
    // incorrect since it is stale.  If the color isn't checked, then
    // the server thinks that the discard has been noted when it really
    // has not.
    //
    if (dwColor != pChange->dwColor) {
        dwResult = 0;
    }

    if (pPrinterNotifyInfo) {

        //
        // Handle different error states from RPC.  Each case/default
        // block must either update or pChange->ChangeInfo.pPrinterNotifyInfo
        // and free the old or the new if both exist.
        //
        switch (dwReturn) {
        case ERROR_SUCCESS:

            //
            // On success, see if the client saw the info but couldn't
            // store it since they overflowed.  In this case, we note
            // this and never RPC to them again until they refresh.
            //
            if (dwResult & PRINTER_NOTIFY_INFO_DISCARDNOTED) {
                pChange->eStatus |= (STATUS_CHANGE_DISCARDED |
                                     STATUS_CHANGE_DISCARDNOTED);
            }

            //
            // If new buffer allocated, free our old one, else reuse buffer.
            //
            if (!pPrinterNotifyInfoNew) {

                //
                // Clear it since we are reusing it.
                //
                ClearPrinterNotifyInfo(pPrinterNotifyInfo, pChange);
                pChange->ChangeInfo.pPrinterNotifyInfo = pPrinterNotifyInfo;

            } else {

                //
                // Free the old one since we are using the new one now.
                //
                RouterFreePrinterNotifyInfo(pPrinterNotifyInfo);
            }

            pChange->ChangeInfo.pPrinterNotifyInfo->Flags |= dwResult;
            break;

        case RPC_S_CALL_FAILED_DNE:

            //
            // On DNE, keep the notification info.  We are guarenteed by
            // rpc that this means no part of the call executed.
            //
            if (pPrinterNotifyInfoNew) {

                //
                // We already have some info.  Merge it in
                // with the exiting data.
                //
                pChange->ChangeInfo.pPrinterNotifyInfo = pPrinterNotifyInfo;

                if (pChange->ChangeInfo.pPrintHandle) {

                    AppendPrinterNotifyInfo(pChange->ChangeInfo.pPrintHandle,
                                            dwColor,
                                            pPrinterNotifyInfoNew);
                }
                RouterFreePrinterNotifyInfo(pPrinterNotifyInfoNew);
            }
            break;

        default:

            //
            // Did it succeed?  Maybe, maybe not.  Fail it by freeing
            // the current one if it exists, then clear the current one
            // and set the discard bit.
            //
            pChange->ChangeInfo.pPrinterNotifyInfo = pPrinterNotifyInfo;
            ClearPrinterNotifyInfo(pPrinterNotifyInfo, pChange);

            SetDiscardPrinterNotifyInfo(pPrinterNotifyInfo, pChange);

            //
            // Free the new buffer since we are reusing the old one.
            //
            if (pPrinterNotifyInfoNew) {

                RouterFreePrinterNotifyInfo(pPrinterNotifyInfoNew);
            }
        }
    }

    pChange->eStatus &= ~STATUS_CHANGE_ACTIVE;

    //
    // STATUS_CHANGE_ACTIVE_REQ set, then some notifications came in
    // while we were out.  Check that we actually do have information
    // (it might have been sent with the last RPC) and we aren't closing.
    //
    if ((pChange->eStatus & STATUS_CHANGE_ACTIVE_REQ) &&
        NotifyNeeded(pChange) &&
        !(pChange->eStatus & STATUS_CHANGE_CLOSING)) {

        DBGMSG(DBG_NOTIFY, ("ThreadNotifyProcessJob: delayed link added 0x%x cRef++ %d\n",
                            pChange,
                            pChange->cRef));

        pChange->eStatus &= ~STATUS_CHANGE_ACTIVE_REQ;

        LinkChange(pChange);

        //
        // No need to call TMAddJob(&tmStateVar) since this
        // thread will pickup the job.  If there is a job already waiting,
        // then that means it already has a thread spawning to pick it up.
        //
    }

Done:
    //
    // Mark ourselves no longer in use.  If we were in use when someone
    // tried to delete the notify, we need to delete it once we're done.
    //
    pChange->cRef--;

    DBGMSG(DBG_NOTIFY, ("ThreadNotifyProcessJob: Done 0x%x cRef-- %d\n",
                        pChange,
                        pChange->cRef));


    if (pChange->eStatus & STATUS_CHANGE_CLOSING) {

        hNotifyRemote = pChange->hNotifyRemote;
        pChange->hNotifyRemote = NULL;

        //
        // Free the Change struct and close the hNotifyRemote
        //
        FreeChange(pChange);

        EXIT_THREAD_LIST();

        CloseReplyRemote(hNotifyRemote);

    } else {

        EXIT_THREAD_LIST();
    }

    return 0;
}


//
// Usually a macro
//
#ifndef LINKADDFAST
VOID
LinkAdd(
    PLINK pLink,
    PLINK* ppLinkHead)

/*++

Routine Description:

    Adds the item to linked list.

Arguments:

    pLink - item to add

    ppLinkHead - linked list head pointer

Return Value:

    VOID

NOTE: This appends to the tail of the list; the macro must be changed also.

--*/

{
    //
    // First check if its in the list
    //
    PLINK pLinkT;
    PLINK pLinkLast = NULL;

    for(pLinkT=*ppLinkHead; pLinkT; pLinkT=pLinkT->pNext) {

        if (pLinkT == pLink) {

            DBGMSG(DBG_ERROR, ("LinkAdd: Duplicate link adding!\n"));
        }
        pLinkLast = pLinkT;
    }

    if (pLinkLast) {
        pLinkLast->pNext = pLink;
    } else {
        pLink->pNext = *ppLinkHead;
        *ppLinkHead = pLink;
    }
}
#endif


VOID
LinkDelete(
    PLINK pLink,
    PLINK* ppLinkHead)

/*++

Routine Description:

    Removes item from list

Arguments:

    pLink - Item to delete

    ppLinkHead - pointer to link head

Return Value:

    VOID

--*/

{
    PLINK pLink2 = *ppLinkHead;

    if (!pLink)
        return;

    //
    // Check head case first
    //
    if (pLink2 == pLink) {

        *ppLinkHead = pLink->pNext;

    } else {

        //
        // Scan list to delete
        //
        for(;
            pLink2;
            pLink2=pLink2->pNext) {

            if (pLink == pLink2->pNext) {

                pLink2->pNext = pLink->pNext;
                break;
            }
        }
    }

    pLink->pNext = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\winsplc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Includes precompiled header and winspl_c.c.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "winspl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\winproc.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    winproc.c

Abstract:

    Spooler window processing code

Author:

    Muhunthan Sivapragasam (MuhuntS) 5-Nov-96 port of win95 code

Environment:

    User Mode - Win32

Notes:

Revision History:

    BabakJ: Jan 1999, Added thread sync code to allow only one thread doing enumeration, and only
            one thread waiting. This helps performance specially when Dynamon has many Hydra ports.

--*/

#include "precomp.h"
#include "local.h"
#pragma hdrstop

#include <cfgmgr32.h>

static  const   GUID USB_PRINTER_GUID      =
    { 0x28d78fad, 0x5a12, 0x11d1,
        { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };
static  const   GUID GUID_DEVCLASS_INFRARED =
    { 0x6bdd1fc5L, 0x810f, 0x11d0,
        { 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f } };

typedef struct _DEVICE_REGISTER_INFO {

    struct _DEVICE_REGISTER_INFO   *pNext;
    HANDLE                          hDevice;
    LPVOID                          pData;
    PFN_QUERYREMOVE_CALLBACK        pfnQueryRemove;
    HDEVNOTIFY                      hNotify;

} DEVICE_REGISTER_INFO, *PDEVICE_REGISTER_INFO;

PDEVICE_REGISTER_INFO   gpDevRegnInfo = NULL;


VOID
ConfigChangeThread(
    )
{
    HINSTANCE   hLib;
    VOID        (*pfnSplConfigChange)();

    WaitForSpoolerInitialization();

    if ( hLib = LoadLibrary(L"localspl.dll") ) {

        if ( pfnSplConfigChange = GetProcAddress(hLib, "SplConfigChange") ) {

            pfnSplConfigChange();
        }

        FreeLibrary(hLib);
    }
}


VOID
ReenumeratePortsThreadWorker(
    )
{
    HINSTANCE   hLib;
    VOID        (*pfnSplReenumeratePorts)();

    WaitForSpoolerInitialization();

    if ( hLib = LoadLibrary(L"localspl.dll") ) {

        if ( pfnSplReenumeratePorts = GetProcAddress(hLib, "SplReenumeratePorts") ) {

            pfnSplReenumeratePorts();
        }

        FreeLibrary(hLib);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
/////
///// To improve performance, and prevent too many unnecessary port enumerations, specially for Hydra/Dynamon:
/////
/////  - We want to allow only one Device Arrival thread to be doing port enumeration.
/////  - If above is happneing, we allow only one more Device Arrival thread be waiting to go in. 
/////  - All other threads will be turned away, as there is no need for them to do port enumeration.   
/////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

CRITICAL_SECTION DeviceArrivalCS;   // Used to synchronize threads bringing device arrival messages.
HANDLE ThdOutEvent;                 // Signalled after a thread is done doing the EnumPort work; not signaled when created.


VOID
ReenumeratePortsThread(
    )
{  
    static BOOL fThdIn;          // TRUE if a thread is doing enum work at the moment
    static BOOL fThdWaiting;     // TRUE if a 2nd thread is waiting behind the thread that is inside.

    EnterCriticalSection( &DeviceArrivalCS );    // Enter the crit section initialized for this at localspl init code
    if( fThdWaiting ) {
        LeaveCriticalSection( &DeviceArrivalCS ); 
        return;                 // A 2nd thread is already waiting to go in. No need for holding more threads.
    }
    else {

       if( fThdIn ) {

            fThdWaiting = TRUE;       // There is a thread inside doing Enum work. Have the current thread wait for it to finish.
            
            LeaveCriticalSection( &DeviceArrivalCS );             
            WaitForSingleObject( ThdOutEvent, INFINITE );
            EnterCriticalSection( &DeviceArrivalCS );

            fThdWaiting = FALSE;
        }

        fThdIn = TRUE;              // The current thread is now going in to do Enum work.
        
        LeaveCriticalSection( &DeviceArrivalCS );                     
        ReenumeratePortsThreadWorker();
        EnterCriticalSection( &DeviceArrivalCS );        
        
        fThdIn = FALSE;
        
        if( fThdWaiting )
            SetEvent( ThdOutEvent );

        LeaveCriticalSection( &DeviceArrivalCS );        
        return;
    }
}
    

DWORD
QueryRemove(
    HANDLE  hDevice
    )
{
    LPVOID                      pData = NULL;
    PFN_QUERYREMOVE_CALLBACK    pfnQueryRemove = NULL;
    PDEVICE_REGISTER_INFO       pDevRegnInfo;

    EnterRouterSem();
    for ( pDevRegnInfo = gpDevRegnInfo ;
          pDevRegnInfo ;
          pDevRegnInfo = pDevRegnInfo->pNext ) {

        if ( pDevRegnInfo->hDevice == hDevice ) {

            pfnQueryRemove  = pDevRegnInfo->pfnQueryRemove;
            pData           = pDevRegnInfo->pData;
            break;
        }
    }
    LeaveRouterSem();

    return pfnQueryRemove ? pfnQueryRemove(pData) : NO_ERROR;
}


DWORD
SplProcessPnPEvent(
    DWORD       dwEventType,
    LPVOID      lpEventData,
    PVOID       pVoid
    )
{
    HANDLE                  hThread;
    DWORD                   dwThread, dwReturn = NO_ERROR;
    PDEV_BROADCAST_HANDLE   pBroadcast;

    DBGMSG(DBG_INFO,
           ("SplProcessPnPEvent: dwEventType: %d\n", dwEventType));

    switch (dwEventType) {

        case DBT_CONFIGCHANGED:
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ConfigChangeThread,
                                   NULL,
                                   0,
                                   &dwThread);

            if ( hThread )
                CloseHandle(hThread);

            break;

        case DBT_DEVICEARRIVAL:
        case DBT_DEVICEREMOVECOMPLETE:
            //
            // In case of device arrival we need to see if there are new ports
            // and in case of device removal monitors might want to mark ports
            // as removed so next reboot they do not have to enumerate them
            // ex. USB does this.
            //
            // We use the default process stack size for this thread. Currently 16KB.
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ReenumeratePortsThread,
                                   NULL,
                                   0,
                                   &dwThread);

            if ( hThread )
                CloseHandle(hThread);

            break;

        case DBT_DEVICEQUERYREMOVE:
            pBroadcast = (PDEV_BROADCAST_HANDLE)lpEventData;

            //
            // These checks are to see if we really care about this
            //
            if ( !pBroadcast    ||
                  pBroadcast->dbch_devicetype != DBT_DEVTYP_HANDLE )
                break;

            dwReturn = QueryRemove(pBroadcast->dbch_handle);
            break;

        case DBT_SHELLLOGGEDON:
        default:
            break;
    }

    return dwReturn;
}


VOID
RegisterForPnPEvents(
    VOID
    )
{
    DEV_BROADCAST_DEVICEINTERFACE  Filter;

    // Init the sync objects needed for device arrival thread management
    InitializeCriticalSection( &DeviceArrivalCS );
    ThdOutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);   // Manual reset, non-signaled state

    
    ZeroMemory(&Filter, sizeof(Filter));

    Filter.dbcc_size        = sizeof(Filter);
    Filter.dbcc_devicetype  = DBT_DEVTYP_DEVICEINTERFACE;
    CopyMemory(&Filter.dbcc_classguid,
               (LPGUID)&USB_PRINTER_GUID,
               sizeof(Filter.dbcc_classguid));
    

    if ( !RegisterDeviceNotification(ghSplHandle,
                                     &Filter,
                                     DEVICE_NOTIFY_SERVICE_HANDLE) ) {

        DBGMSG(DBG_INFO,
               ("RegisterForPnPEvents: RegisterDeviceNotification failed for USB. Error %d\n",
                GetLastError()));
    } else {

        DBGMSG(DBG_WARNING,
               ("RegisterForPnPEvents: RegisterDeviceNotification succesful for USB\n"));
    }

    CopyMemory(&Filter.dbcc_classguid,
               (LPGUID)&GUID_DEVCLASS_INFRARED,
               sizeof(Filter.dbcc_classguid));
    

    if ( !RegisterDeviceNotification(ghSplHandle,
                                     &Filter,
                                     DEVICE_NOTIFY_SERVICE_HANDLE) ) {

        DBGMSG(DBG_INFO,
               ("RegisterForPnPEvents: RegisterDeviceNotification failed for IRDA. Error %d\n",
                GetLastError()));
    } else {

        DBGMSG(DBG_WARNING,

               ("RegisterForPnPEvents: RegisterDeviceNotification succesful for IRDA\n"));
    }

}


BOOL
SplUnregisterForDeviceEvents(
    HANDLE  hNotify
    )
{
    PDEVICE_REGISTER_INFO   pDevRegnInfo, pPrev;

    EnterRouterSem();
    //
    // Find the registration in our list, remove it and then leave CS to
    // call unregister on it
    //
    for ( pDevRegnInfo = gpDevRegnInfo, pPrev = NULL ;
          pDevRegnInfo ;
          pPrev = pDevRegnInfo, pDevRegnInfo = pDevRegnInfo->pNext ) {

        if ( pDevRegnInfo->hNotify == hNotify ) {

            if ( pPrev )
                pPrev->pNext = pDevRegnInfo->pNext;
            else
                gpDevRegnInfo = pDevRegnInfo->pNext;

            break;
        }
    }
    LeaveRouterSem();

    if ( pDevRegnInfo ) {

        UnregisterDeviceNotification(pDevRegnInfo->hNotify);
        FreeSplMem(pDevRegnInfo);
        return TRUE;
    }

    return FALSE;
}


HANDLE
SplRegisterForDeviceEvents(
    HANDLE                      hDevice,
    LPVOID                      pData,
    PFN_QUERYREMOVE_CALLBACK    pfnQueryRemove
    )
{
    DEV_BROADCAST_HANDLE    Filter;
    PDEVICE_REGISTER_INFO   pDevRegnInfo;

    ZeroMemory(&Filter, sizeof(Filter));

    Filter.dbch_size        = sizeof(Filter);
    Filter.dbch_devicetype  = DBT_DEVTYP_HANDLE;
    Filter.dbch_handle      = hDevice;
    
    pDevRegnInfo = (PDEVICE_REGISTER_INFO)
                        AllocSplMem(sizeof(DEVICE_REGISTER_INFO));

    if ( !pDevRegnInfo )
        goto Fail;

    pDevRegnInfo->hDevice           = hDevice;
    pDevRegnInfo->pData             = pData;
    pDevRegnInfo->pfnQueryRemove    = pfnQueryRemove;
    pDevRegnInfo->hNotify           = RegisterDeviceNotification(
                                                ghSplHandle,
                                                &Filter,
                                                DEVICE_NOTIFY_SERVICE_HANDLE);

    if ( pDevRegnInfo->hNotify ) {

        EnterRouterSem();
        pDevRegnInfo->pNext = gpDevRegnInfo;
        gpDevRegnInfo = pDevRegnInfo;
        LeaveRouterSem();

        return pDevRegnInfo->hNotify;
    }

    FreeSplMem(pDevRegnInfo);

Fail:
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\threadm.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    ThreadM.h

Abstract:

    Generic thread manager header.

Author:

    Albert Ting (AlbertT) 13-Feb-1994

Environment:

    User Mode -Win32

Revision History:

--*/

//
// Forward typedefs
//
typedef struct _TMSTATEVAR *PTMSTATEVAR;
typedef enum _TMSTATUS {
    TMSTATUS_NULL = 0,
    TMSTATUS_DESTROY_REQ = 1,
    TMSTATUS_DESTROYED   = 2,
} TMSTATUS, *PTMSTATUS;

/* ----------

Valid TMSTATUS states:

NULL                     --  Normal processing
DESTROY_REQ              --  No new jobs, jobs possibly running
DESTROY_REQ, DESTROYED   --  No new jobs, all jobs completed

  ----------- */


typedef PVOID PJOB;

//
// pfnNextJob must synchronize access on its own
//
typedef PJOB (*PFNNEXTJOB)(PTMSTATEVAR pTMStateVar);
typedef VOID (*PFNPROCESSJOB)(PTMSTATEVAR pTMStateVar, PJOB pJob);
typedef VOID (*PFNNEWSTATE)(PTMSTATEVAR pTMStateVar);
typedef VOID (*PFNCLOSESTATE)(PTMSTATEVAR pTMStateVar);

typedef struct _TMSTATESTATIC {
    UINT   uMaxThreads;
    UINT   uIdleLife;
    PFNPROCESSJOB pfnProcessJob;
    PFNNEXTJOB    pfnNextJob;
    PFNNEWSTATE   pfnNewState;
    PFNCLOSESTATE pfnCloseState;
    PCRITICAL_SECTION pCritSec;
} TMSTATESTATIC, *PTMSTATESTATIC;

typedef struct _TMSTATEVAR {

//  --- Internal --
    PTMSTATESTATIC pTMStateStatic;
    TMSTATUS Status;
    UINT uActiveThreads;
    UINT uIdleThreads;
    HANDLE hTrigger;

//  --- Initialized by user --
    PVOID  pUser;                        // User space

} TMSTATEVAR;


//
// Prototypes
//
BOOL
TMCreateStatic(
    PTMSTATESTATIC pTMStateStatic
    );

VOID
TMDestroyStatic(
    PTMSTATESTATIC pTMStateStatic
    );

BOOL
TMCreate(
    PTMSTATESTATIC pTMStateStatic,
    PTMSTATEVAR pTMStateVar
    );

BOOL
TMDestroy(
    PTMSTATEVAR pTMStateVar
    );

BOOL
TMAddJob(
    PTMSTATEVAR pTMStateVar
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Routing Layer and
    the local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

#include <winddiui.h>
#include <winsock2.h>
#include <wininet.h>


LPWSTR *ppszOtherNames = NULL;  // Contains szMachineName, DNS name, and all other machine name forms
DWORD   cOtherNames = 0;        // Number of other names

WCHAR *gszDrvConvert = L",DrvConvert";


//
// Lowercase, just like win31 for WM_WININICHANGE
//
WCHAR *szDevices=L"devices";
WCHAR *szWindows=L"windows";

#define NUM_INTERACTIVE_RIDS            1

extern DWORD    RouterCacheSize;
extern PROUTERCACHE RouterCacheTable;

typedef struct _DEVMODECHG_INFO {
    DWORD           signature;
    HANDLE          hDrvModule;
    FARPROC         pfnConvertDevMode;
} DEVMODECHG_INFO, *PDEVMODECHG_INFO;

#define DMC_SIGNATURE   'DMC'   /* 'DMC' is the signature value */

DWORD
RouterIsOlderThan(
    DWORD i,
    DWORD j
);

VOID
FreeOtherNames(LPWSTR **ppszMyOtherNames, DWORD *cOtherNames);

LPWSTR
AnsiToUnicodeStringWithAlloc(LPSTR   pAnsi);


BOOL
DeleteSubKeyTree(
    HKEY ParentHandle,
    WCHAR SubKeyName[]
)
{
    LONG        Error;
    DWORD       Index;
    HKEY        KeyHandle;
    BOOL        RetValue;

    WCHAR       ChildKeyName[ MAX_PATH ];
    DWORD       ChildKeyNameLength;

    Error = RegOpenKeyEx(
                   ParentHandle,
                   SubKeyName,
                   0,
                   KEY_READ | KEY_WRITE,
                   &KeyHandle
                   );
    if (Error != ERROR_SUCCESS) {
        SetLastError(Error);
        return(FALSE);
    }

     ChildKeyNameLength = MAX_PATH;
     Index = 0;     // Don't increment this Index

     while ((Error = RegEnumKeyEx(
                    KeyHandle,
                    Index,
                    ChildKeyName,
                    &ChildKeyNameLength,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    )) == ERROR_SUCCESS) {

        RetValue = DeleteSubKeyTree( KeyHandle, ChildKeyName );

        if (RetValue == FALSE) {

            // Error -- couldn't delete the sub key

            RegCloseKey(KeyHandle);
            return(FALSE);

        }

        ChildKeyNameLength = MAX_PATH;

    }

    Error = RegCloseKey(
                    KeyHandle
                    );
    if (Error != ERROR_SUCCESS) {
       return(FALSE);
    }

    Error = RegDeleteKey(
                    ParentHandle,
                    SubKeyName
                    );
   if (Error != ERROR_SUCCESS) {
       return(FALSE);
   }

   // Return Success - the key has successfully been deleted

   return(TRUE);
}

LPWSTR RemoveOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
)
{
    LPWSTR lpMem, psz, temp;

    if (szOrderString == NULL) {
        *pcbBytesReturned = 0;
        return(NULL);
    }
    if (lpMem = AllocSplMem( cbStringSize)) {
        temp = szOrderString;
        psz = lpMem;
        while (*temp) {
            if (!lstrcmpi(temp, szOrderEntry)) {  // we need to remove
                temp += lstrlen(temp)+1;        // this entry in Order
                continue;
            }
            lstrcpy(psz,temp);
            psz += lstrlen(temp)+1;
            temp += lstrlen(temp)+1;
        }
        *psz = L'\0';
        *pcbBytesReturned = (DWORD) ((psz - lpMem)+1)*sizeof(WCHAR);
        return(lpMem);
    }
    *pcbBytesReturned = 0;
    return(lpMem);
}



LPWSTR AppendOrderEntry(
    LPWSTR  szOrderString,
    DWORD   cbStringSize,
    LPWSTR  szOrderEntry,
    LPDWORD pcbBytesReturned
)
{
    LPWSTR  lpMem, temp, psz;
    DWORD   cb = 0;
    BOOL    bExists = FALSE;

    if ((szOrderString == NULL) && (szOrderEntry == NULL)) {
        *pcbBytesReturned = 0;
        return(NULL);
    }
    if (szOrderString == NULL) {
        cb = wcslen(szOrderEntry)*sizeof(WCHAR)+ sizeof(WCHAR) + sizeof(WCHAR);
        if (lpMem = AllocSplMem(cb)){
           wcscpy(lpMem, szOrderEntry);
           *pcbBytesReturned = cb;
        } else {
            *pcbBytesReturned = 0;
        }
        return lpMem;
    }

    if (lpMem = AllocSplMem( cbStringSize + wcslen(szOrderEntry)*sizeof(WCHAR)
                                                 + sizeof(WCHAR))){


         temp = szOrderString;
         psz = lpMem;
         while (*temp) {
             if (!lstrcmpi(temp, szOrderEntry)) {     // Make sure we don't
                 bExists = TRUE;                    // duplicate entries
             }
             lstrcpy(psz, temp);
             psz += lstrlen(temp)+ 1;
             temp += lstrlen(temp)+1;
         }
         if (!bExists) {                            // if it doesn't exist
            lstrcpy(psz, szOrderEntry);             //     add the entry
            psz  += lstrlen(szOrderEntry)+1;
         }
         *psz = L'\0';          // the second null character

         *pcbBytesReturned = (DWORD) ((psz - lpMem) + 1)* sizeof(WCHAR);
     }
     return(lpMem);

}


typedef struct {
    DWORD   dwType;
    DWORD   dwMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} MESSAGE, *PMESSAGE;

VOID
SendMessageThread(
    PMESSAGE    pMessage);


BOOL
BroadcastMessage(
    DWORD   dwType,
    DWORD   dwMessage,
    WPARAM  wParam,
    LPARAM  lParam)
{
    HANDLE  hThread;
    DWORD   ThreadId;
    PMESSAGE   pMessage;
    BOOL bReturn = FALSE;

    pMessage = AllocSplMem(sizeof(MESSAGE));

    if (pMessage) {

        pMessage->dwType = dwType;
        pMessage->dwMessage = dwMessage;
        pMessage->wParam = wParam;
        pMessage->lParam = lParam;

        //
        // We should have a queue of events to broadcast and then have a
        // single thread pulling them off the queue until there is nothing
        // left and then that thread could go away.
        //
        // The current design can lead to a huge number of threads being
        // created and torn down in both this and csrss process.
        //
        hThread = CreateThread(NULL, 0,
                               (LPTHREAD_START_ROUTINE)SendMessageThread,
                               (LPVOID)pMessage,
                               0,
                               &ThreadId);

        if (hThread) {

            CloseHandle(hThread);
            bReturn = TRUE;

        } else {

            FreeSplMem(pMessage);
        }
    }

    return bReturn;
}


//  The Broadcasts are done on a separate thread, the reason it CSRSS
//  will create a server side thread when we call user and we don't want
//  that to be pared up with the RPC thread which is in the spooss server.
//  We want it to go away the moment we have completed the SendMessage.
//  We also call SendNotifyMessage since we don't care if the broadcasts
//  are syncronous this uses less resources since usually we don't have more
//  than one broadcast.

VOID
SendMessageThread(
    PMESSAGE    pMessage)
{
    switch (pMessage->dwType) {

    case BROADCAST_TYPE_MESSAGE:

        SendNotifyMessage(HWND_BROADCAST,
                          pMessage->dwMessage,
                          pMessage->wParam,
                          pMessage->lParam);
        break;

    case BROADCAST_TYPE_CHANGEDEFAULT:

        //
        // Same order and strings as win31.
        //
        SendNotifyMessage(HWND_BROADCAST,
                          WM_WININICHANGE,
                          0,
                          (LPARAM)szDevices);

        SendNotifyMessage(HWND_BROADCAST,
                          WM_WININICHANGE,
                          0,
                          (LPARAM)szWindows);
        break;
    }

    FreeSplMem(pMessage);

    ExitThread(0);
}


BOOL
IsNamedPipeRpcCall(
    VOID
    )
{
    unsigned int    uType;

    //
    //
    //
    return ERROR_SUCCESS == I_RpcBindingInqTransportType(NULL, &uType)  &&
           uType != TRANSPORT_TYPE_LPC;

}


BOOL
IsLocalCall(
    VOID
    )
{
    HANDLE    hToken;
    BOOL      bStatus;
    DWORD     dwError;
    PSID      pTestSid = NULL;
    PSID      pCurSid;
    DWORD     cbSize = 0;
    DWORD     cbRequired = 0;
    DWORD     i;
    BOOL      bRet = FALSE;
    BOOL      bMember;

    DWORD dwSaveLastError = GetLastError();

    SID_IDENTIFIER_AUTHORITY  sia = SECURITY_NT_AUTHORITY;
    unsigned int              uType;

    dwError = I_RpcBindingInqTransportType(NULL, &uType);

    if ( dwError == RPC_S_NO_CALL_ACTIVE ) {

        //
        // KM call
        //
        return TRUE;
    }

    if ( dwError == ERROR_SUCCESS ) {

        if ( uType != TRANSPORT_TYPE_LPC ) {

            //
            // Not LRPC so call is remote
            //
            return FALSE;
        }

    } else {

        //
        // This should not fail. So we'll assert on chk bld and
        // continue looking at SIDS on fre builds
        //
        SPLASSERT( dwError != ERROR_SUCCESS);
    }

    bStatus = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    if (!bStatus) {

        // Couldn't open the thread's token, nothing much we can do
        DBGMSG(DBG_TRACE,("Error: couldn't open the thread's Access token %d\n", GetLastError()));
        return FALSE;
    }

    if ( !AllocateAndInitializeSid(&sia,
                                   1,
                                   SECURITY_NETWORK_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &pTestSid) ) {

        DBGMSG(DBG_TRACE,
               ("Error: could not AllocateAndInitializeSid -%d\n",
               GetLastError()));
        goto Done;
    }

    if( !CheckTokenMembership( hToken,
                               pTestSid,
                               &bMember )){
        DBGMSG(DBG_TRACE,
               ("Error: CheckTokenMembership failed %d\n",
               GetLastError()));
        goto Done;
    }

    if( !bMember ){

        //
        // Not a member, so no match for network sid.  Therefore local.
        //
        bRet = TRUE;
    }

Done:
    if ( pTestSid )
        FreeSid(pTestSid);

    CloseHandle(hToken);

    SetLastError( dwSaveLastError );
    return bRet;
}


LPPROVIDOR
FindEntryinRouterCache(
    LPWSTR pPrinterName
)
{
    DWORD i;

    if (!pPrinterName)
        return NULL;

    DBGMSG(DBG_TRACE, ("FindEntryinRouterCache with %ws\n", pPrinterName));

    if (RouterCacheSize == 0 ) {
        DBGMSG(DBG_TRACE, ("FindEntryInRouterCache with %ws returning -1 (zero cache)\n", pPrinterName));
        return NULL;
    }

    for (i = 0; i < RouterCacheSize; i++ ) {

        if (RouterCacheTable[i].bAvailable) {
            if (!_wcsicmp(RouterCacheTable[i].pPrinterName, pPrinterName)) {

                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&RouterCacheTable[i].st);

                //
                //
                //
                DBGMSG(DBG_TRACE, ("FindEntryinRouterCache returning with %d\n", i));
                return RouterCacheTable[i].pProvidor;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("FindEntryinRouterCache returning with -1\n"));
    return NULL;
}


DWORD
AddEntrytoRouterCache(
    LPWSTR pPrinterName,
    LPPROVIDOR pProvidor
)
{
    DWORD LRUEntry = (DWORD)-1;
    DWORD i;
    DBGMSG(DBG_TRACE, ("AddEntrytoRouterCache with %ws\n", pPrinterName));

    if (RouterCacheSize == 0 ) {
        DBGMSG(DBG_TRACE, ("AddEntrytoRouterCache with %ws returning -1 (zero cache)\n", pPrinterName));
        return (DWORD)-1;
    }

    for (i = 0; i < RouterCacheSize; i++ ) {

        if (!RouterCacheTable[i].bAvailable) {

            //
            // Found an available entry; use it
            // fill in the name of the printer and the providor
            // that supports this printer.
            //
            break;

        } else {

            if ((LRUEntry == -1) || (i == RouterIsOlderThan(i, LRUEntry))){
                LRUEntry = i;
            }
        }

    }

    if (i == RouterCacheSize) {

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //
        FreeSplStr(RouterCacheTable[LRUEntry].pPrinterName);
        RouterCacheTable[LRUEntry].bAvailable = FALSE;

        i = LRUEntry;
    }


    if ((RouterCacheTable[i].pPrinterName = AllocSplStr(pPrinterName)) == NULL){

        //
        // Alloc failed so we're kinda hosed so return -1
        //
        return (DWORD)-1;
    }


    RouterCacheTable[i].bAvailable = TRUE;
    RouterCacheTable[i].pProvidor = pProvidor;

    //
    // update the time stamp so that we know when this entry was made
    //
    GetSystemTime(&RouterCacheTable[i].st);
    DBGMSG(DBG_TRACE, ("AddEntrytoRouterCache returning with %d\n", i));
    return i;
}


VOID
DeleteEntryfromRouterCache(
    LPWSTR pPrinterName
)
{
    DWORD i;

    if (RouterCacheSize == 0) {
        DBGMSG(DBG_TRACE, ("DeleteEntryfromRouterCache with %ws returning -1 (zero cache)\n", pPrinterName));
        return;
    }

    DBGMSG(DBG_TRACE, ("DeleteEntryFromRouterCache with %ws\n", pPrinterName));
    for (i = 0; i < RouterCacheSize; i++ ) {
        if (RouterCacheTable[i].bAvailable) {
            if (!_wcsicmp(RouterCacheTable[i].pPrinterName, pPrinterName)) {
                //
                //  reset the available flag on this node
                //
                FreeSplStr(RouterCacheTable[i].pPrinterName);

                RouterCacheTable[i].pProvidor = NULL;
                RouterCacheTable[i].bAvailable = FALSE;

                DBGMSG(DBG_TRACE, ("DeleteEntryFromRouterCache returning after deleting the %d th entry\n", i));
                return;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("DeleteEntryFromRouterCache returning after not finding an entry to delete\n"));
}



DWORD
RouterIsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    DBGMSG(DBG_TRACE, ("RouterIsOlderThan entering with i %d j %d\n", i, j));
    pi = &(RouterCacheTable[i].st);
    pj = &(RouterCacheTable[j].st);
    DBGMSG(DBG_TRACE, ("Index i %d - %d:%d:%d:%d:%d:%d:%d\n",
        i, pi->wYear, pi->wMonth, pi->wDay, pi->wHour, pi->wMinute, pi->wSecond, pi->wMilliseconds));


    DBGMSG(DBG_TRACE,("Index j %d - %d:%d:%d:%d:%d:%d:%d\n",
        j, pj->wYear, pj->wMonth, pj->wDay, pj->wHour, pj->wMinute, pj->wSecond, pj->wMilliseconds));

    if (pi->wYear < pj->wYear) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", i));
            return(i);
        } else {
            DBGMSG(DBG_TRACE, ("RouterIsOlderThan returns %d\n", j));
            return(j);
        }
    }
}


/*++

Routine Name

    ImpersonationToken

Routine Description:

    This routine checks if a token is a primary token or an impersonation 
    token.    
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the token is an impersonation token
    FALSE, otherwise.
    
--*/
BOOL
ImpersonationToken(
    IN HANDLE hToken
    )
{
    BOOL       bRet = TRUE;
    TOKEN_TYPE eTokenType;
    DWORD      cbNeeded;
    DWORD      LastError;

    //
    // Preserve the last error. Some callers of ImpersonatePrinterClient (which
    // calls ImpersonationToken) rely on the fact that ImpersonatePrinterClient
    // does not alter the last error.
    //
    LastError = GetLastError();
        
    //
    // Get the token type from the thread token.  The token comes 
    // from RevertToPrinterSelf. An impersonation token cannot be 
    // queried, because RevertToPRinterSelf doesn't open it with 
    // TOKEN_QUERY access. That's why we assume that hToken is
    // an impersonation token by default
    //
    if (GetTokenInformation(hToken,
                            TokenType,
                            &eTokenType,
                            sizeof(eTokenType),
                            &cbNeeded))
    {
        bRet = eTokenType == TokenImpersonation;
    }        
    
    SetLastError(LastError);

    return bRet;
}

/*++

Routine Name

    RevertToPrinterSelf

Routine Description:

    This routine will revert to the local system. It returns the token that
    ImpersonatePrinterClient then uses to imersonate the client again. If the
    current thread doesn't impersonate, then the function merely returns the
    primary token of the process. (instead of returning NULL) Thus we honor
    a request for reverting to printer self, even if the thread is not impersonating.
    
Arguments:

    None.
    
Return Value:

    NULL, if the function failed
    HANDLE to token, otherwise.
    
--*/
HANDLE
RevertToPrinterSelf(
    VOID
    )
{
    HANDLE   NewToken, OldToken;
    NTSTATUS Status;

    NewToken = NULL;

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_IMPERSONATE,
                               TRUE,
                               &OldToken);
    
    if (NT_SUCCESS(Status)) 
    {
        //
        // We are currently impersonating
        //
        Status = NtSetInformationThread(NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID)&NewToken,
                                        (ULONG)sizeof(HANDLE));       
    }
    else if (Status == STATUS_NO_TOKEN) 
    {
        //
        // We are not impersonating
        //
        Status = NtOpenProcessToken(NtCurrentProcess(),
                                    TOKEN_QUERY,
                                    &OldToken);

    }
    
    if (!NT_SUCCESS(Status)) 
    {
        SetLastError(Status);
        return NULL;
    }
    
    return OldToken;
}

/*++

Routine Name

    ImpersonatePrinterClient

Routine Description:

    This routine attempts to set the passed in hToken as the token for the
    current thread. If hToken is not an impersonation token, then the routine
    will simply close the token.
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the function succeeds in setting hToken
    FALSE, otherwise.
    
--*/
BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    NTSTATUS    Status;

    //
    // Check if we have an impersonation token
    //
    if (ImpersonationToken(hToken)) 
    {
        Status = NtSetInformationThread(NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID)&hToken,
                                        (ULONG)sizeof(HANDLE));
        if (!NT_SUCCESS(Status)) 
        {
            SetLastError(Status);
            return FALSE;
        }
    }

    NtClose(hToken);

    return TRUE;
}

HANDLE
LoadDriver(
    LPWSTR  pDriverFile)
{
    UINT                uOldErrorMode;
    fnWinSpoolDrv       fnList;
    HANDLE              hReturn = NULL;

    if (!pDriverFile || !*pDriverFile) {
        // Nothing to load
        return hReturn;
    }

    uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    if (SplInitializeWinSpoolDrv(&fnList)) {

        hReturn = (*(fnList.pfnRefCntLoadDriver))(pDriverFile,
                                                  LOAD_WITH_ALTERED_SEARCH_PATH,
                                                  0, FALSE);
    }

    (VOID)SetErrorMode(uOldErrorMode);

    return hReturn;
}

VOID
UnloadDriver(
    HANDLE  hModule
    )
{
    fnWinSpoolDrv       fnList;

    if (SplInitializeWinSpoolDrv(&fnList)) {
        (* (fnList.pfnRefCntUnloadDriver))(hModule, TRUE);
    }
}

VOID
UnloadDriverFile(
    IN OUT HANDLE    hDevModeChgInfo
    )
/*++

Description:
    Does a FreeLibrary on the driver file and frees memory

Arguments:
    hDevModeChgInfo - A handle returned by LoadDriverFiletoConvertDevmode

Return Value:
    None

--*/
{
    PDEVMODECHG_INFO    pDevModeChgInfo = (PDEVMODECHG_INFO) hDevModeChgInfo;

    SPLASSERT(pDevModeChgInfo &&
              pDevModeChgInfo->signature == DMC_SIGNATURE);

    if ( pDevModeChgInfo && pDevModeChgInfo->signature == DMC_SIGNATURE ) {

        if ( pDevModeChgInfo->hDrvModule ) {
            UnloadDriver(pDevModeChgInfo->hDrvModule);
        }
        FreeSplMem((LPVOID)pDevModeChgInfo);
    }
}

HANDLE
LoadDriverFiletoConvertDevmode(
    IN  LPWSTR      pDriverFile
    )
/*++

Description:
    Does a LoadLibrary on the driver file given. This will give a handle
    which can be used to do devmode conversion later using
    CallDrvDevModeConversion.

    Caller should call UnloadDriverFile to do a FreeLibrary and free memory

    Note: Driver will call OpenPrinter to spooler

Arguments:
    pDriverFile - Full path of the driver file to do a LoadLibrary

Return Value:
    A handle value to be used to make calls to CallDrvDevModeConversion,
    NULL on error

--*/
{
    PDEVMODECHG_INFO    pDevModeChgInfo = NULL;
    BOOL                bFail = TRUE;
    DWORD               dwNeeded;

    SPLASSERT(pDriverFile != NULL);

    pDevModeChgInfo = (PDEVMODECHG_INFO) AllocSplMem(sizeof(*pDevModeChgInfo));

    if ( !pDevModeChgInfo ) {

        DBGMSG(DBG_WARNING, ("printer.c: Memory allocation failed for DEVMODECHG_INFO\n"));
        goto Cleanup;
    }

    pDevModeChgInfo->signature = DMC_SIGNATURE;

    pDevModeChgInfo->hDrvModule = LoadDriver(pDriverFile);

    if ( !pDevModeChgInfo->hDrvModule ) {

        DBGMSG(DBG_WARNING,("LoadDriverFiletoConvertDevmode: Can't load driver file %ws\n", pDriverFile));
        goto Cleanup;
    }

    //
    // Some third party driver may not be providing DrvConvertDevMode
    //
    pDevModeChgInfo->pfnConvertDevMode = GetProcAddress(pDevModeChgInfo->hDrvModule,
                                                        "DrvConvertDevMode");
    if ( !pDevModeChgInfo->pfnConvertDevMode )
        goto Cleanup;

    bFail = FALSE;

Cleanup:

    if ( bFail ) {

        if ( pDevModeChgInfo ) {
            UnloadDriverFile((HANDLE)pDevModeChgInfo);
        }
        return (HANDLE) NULL;

    } else {

        return (HANDLE) pDevModeChgInfo;
    }
}

DWORD
CallDrvDevModeConversion(
    IN     HANDLE               hDevModeChgInfo,
    IN     LPWSTR               pszPrinterName,
    IN     LPBYTE               pDevMode1,
    IN OUT LPBYTE              *ppDevMode2,
    IN OUT LPDWORD              pdwOutDevModeSize,
    IN     DWORD                dwConvertMode,
    IN     BOOL                 bAlloc
    )
/*++

Description:
    Does deve mode conversion by calling driver

    If bAlloc is TRUE routine will do the allocation using AllocSplMem

    Note: Driver is going to call OpenPrinter.

Arguments:
    hDevModeChgInfo - Points to DEVMODECHG_INFO

    pszPrinterName  - Printer name

    pInDevMode      - Input devmode (will be NULL for CDM_DRIVER_DEFAULT)

    *pOutDevMode    - Points to output devmode

    pdwOutDevModeSize - Output devmode size on succesful return
                        if !bAlloc this will give input buffer size

    dwConvertMode   - Devmode conversion mode to give to driver

    bAllocate   - Tells the routine to do allocation to *pOutPrinter
                  If bAllocate is TRUE and no devmode conversion is required
                  call will fail.

Return Value:
    Returns last error

--*/
{
    DWORD               dwBufSize, dwSize, dwLastError = ERROR_SUCCESS;
    LPDEVMODE           pInDevMode = (LPDEVMODE)pDevMode1,
                        *ppOutDevMode = (LPDEVMODE *) ppDevMode2;
    PDEVMODECHG_INFO    pDevModeChgInfo = (PDEVMODECHG_INFO) hDevModeChgInfo;
    PWSTR               pszDrvConvert = pszPrinterName;


    if ( !pDevModeChgInfo ||
         pDevModeChgInfo->signature != DMC_SIGNATURE ||
         !pDevModeChgInfo->pfnConvertDevMode ) {

        SPLASSERT(pDevModeChgInfo &&
                  pDevModeChgInfo->signature == DMC_SIGNATURE &&
                  pDevModeChgInfo->pfnConvertDevMode);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // We decorate the pszPrinterName with ",DrvConvert" to prevent drivers from
    // infinitely recursing by calling GetPrinter inside ConvertDevMode
    //
    if (wcsstr(pszPrinterName, gszDrvConvert)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!(pszDrvConvert = AutoCat(pszPrinterName, gszDrvConvert))) {
        return GetLastError();
    }

    DBGMSG(DBG_INFO,("Convert DevMode %d\n", dwConvertMode));


#if DBG
#else
    try {
#endif

        if ( bAlloc ) {

            //
            // If we have to do allocation first find size neeeded
            //
            *pdwOutDevModeSize  = 0;
            *ppOutDevMode        = NULL;

            (*pDevModeChgInfo->pfnConvertDevMode)(pszDrvConvert,
                                                  pInDevMode,
                                                  NULL,
                                                  pdwOutDevModeSize,
                                                  dwConvertMode);

            dwLastError = GetLastError();
            if ( dwLastError != ERROR_INSUFFICIENT_BUFFER ) {

                DBGMSG(DBG_WARNING,
                       ("CallDrvDevModeConversion: Unexpected error %d\n",
                        GetLastError()));

                if (dwLastError == ERROR_SUCCESS) {

                    SPLASSERT(dwLastError != ERROR_SUCCESS);
                    // if driver doesn't fail the above call, it is a broken driver and probably
                    // failed a HeapAlloc, which doesn't SetLastError()
                    SetLastError(dwLastError = ERROR_NOT_ENOUGH_MEMORY);
                }
#if DBG
                goto Cleanup;
#else
                leave;
#endif
            }

            *ppOutDevMode = AllocSplMem(*pdwOutDevModeSize);
            if ( !*ppOutDevMode ) {

                dwLastError = GetLastError();
#if DBG
                goto Cleanup;
#else
                leave;
#endif
            }
        }

        dwBufSize = *pdwOutDevModeSize;

        if ( !(*pDevModeChgInfo->pfnConvertDevMode)(
                                    pszDrvConvert,
                                    pInDevMode,
                                    ppOutDevMode ? *ppOutDevMode
                                                 : NULL,
                                    pdwOutDevModeSize,
                                    dwConvertMode) ) {

            dwLastError = GetLastError();
            if (dwLastError == ERROR_SUCCESS) {

                SPLASSERT(dwLastError != ERROR_SUCCESS);
                // if driver doesn't fail the above call, it is a broken driver and probably
                // failed a HeapAlloc, which doesn't SetLastError()
                SetLastError(dwLastError = ERROR_NOT_ENOUGH_MEMORY);
            }
        } else {

            dwLastError = ERROR_SUCCESS;
        }

#if DBG
    Cleanup:
#else
    } except(1) {

        DBGMSG(DBG_ERROR,
               ("CallDrvDevModeConversion: Exception from driver\n"));
        dwLastError = GetExceptionCode();
        SetLastError(dwLastError);
    }
#endif

    //
    // If we allocated mmeory free it and zero the pointer
    //
    if (  dwLastError != ERROR_SUCCESS && bAlloc && *ppOutDevMode ) {

        FreeSplMem(*ppOutDevMode);
        *ppOutDevMode = 0;
        *pdwOutDevModeSize = 0;
    }

    if ( dwLastError != ERROR_SUCCESS &&
         dwLastError != ERROR_INSUFFICIENT_BUFFER ) {

        DBGMSG(DBG_WARNING, ("DevmodeConvert unexpected error %d\n", dwLastError));
    }

    if ( dwLastError == ERROR_SUCCESS ) {

        dwSize = (*ppOutDevMode)->dmSize + (*ppOutDevMode)->dmDriverExtra;

        //
        // Did the driver return correct size as per the devmode?
        //
        if ( *pdwOutDevModeSize != dwSize ) {

            DBGMSG(DBG_ERROR,
                   ("Driver says outsize is %d, really %d\n",
                      *pdwOutDevModeSize, dwSize));

            *pdwOutDevModeSize = dwSize;
        }

        //
        // Is it a valid devmode which did not overwrite the buffer?
        //
        if ( *pdwOutDevModeSize < MIN_DEVMODE_SIZEW     ||
             *pdwOutDevModeSize > dwBufSize ) {

            DBGMSG(DBG_ERROR,
                   ("Bad devmode from the driver size %d, buffer %d",
                      *pdwOutDevModeSize, dwBufSize));
            dwLastError = ERROR_INVALID_PARAMETER;

            if ( bAlloc ) {

                FreeSplMem(*ppOutDevMode);
                *ppOutDevMode = NULL;
            }
            *pdwOutDevModeSize = 0;
        }
    }

    FreeSplMem(pszDrvConvert);

    return dwLastError;
}

BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszMyOtherNames,
    DWORD   *cOtherNames
    )

/*++

Routine Description:
    This routine builds list of names other than the machine name that
    can be used to call spooler APIs.

--*/
{
    HANDLE              hModule;
    struct hostent     *HostEnt, *(*Fngethostbyname)(LPTSTR);
    struct in_addr     *ptr;
    INT                 (*FnWSAStartup)(WORD, LPWSADATA);
    DWORD               Index, Count;
    WSADATA             WSAData;
    VOID                (*FnWSACleanup)();
    LPSTR               (*Fninet_ntoa)(struct in_addr);
    WORD                wVersion;
    BOOL                bRet = FALSE;
    DWORD               dwRet;


    SPLASSERT(cOtherNames && ppszMyOtherNames);

    *cOtherNames  = 0;

    wVersion = MAKEWORD(1, 1);

    
    dwRet = WSAStartup(wVersion, &WSAData);
    if (dwRet) {
        DBGMSG(DBG_WARNING, ("BuildOtherNamesFromMachineName: WSAStartup failed\n"));
        SetLastError(dwRet);
        return FALSE;
    }

    HostEnt = gethostbyname(NULL);

    if (HostEnt) {

        for (*cOtherNames  = 0 ; HostEnt->h_addr_list[*cOtherNames] ; ++(*cOtherNames))
            ;

        *cOtherNames += 2;   // Add one for DNS and one for machine name

        *ppszMyOtherNames = (LPWSTR *) AllocSplMem(*cOtherNames*sizeof *ppszMyOtherNames);
        if ( !*ppszMyOtherNames ) {
            *cOtherNames = 0;
            goto Cleanup;
        }

        (*ppszMyOtherNames)[0] = AllocSplStr(szMachineName + 2); // Exclude the leading double-backslash
        (*ppszMyOtherNames)[1] = AnsiToUnicodeStringWithAlloc(HostEnt->h_name);

        for (Index = 0 ; HostEnt->h_addr_list[Index] ; ++Index) {
            ptr = (struct in_addr *) HostEnt->h_addr_list[Index];
            (*ppszMyOtherNames)[Index+2] = AnsiToUnicodeStringWithAlloc(inet_ntoa(*ptr));
        }

        // check for allocation failures
        for (Index = 0 ; Index < *cOtherNames ; ++Index) {
            if ( !(*ppszMyOtherNames)[Index] ) {
                FreeOtherNames(ppszMyOtherNames, cOtherNames);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Cleanup;
            }
        }

        bRet = TRUE;

    } else {
        DBGMSG(DBG_WARNING, ("BuildOtherNamesFromMachineName: gethostbyname failed for with %d\n", GetLastError()));
    }


Cleanup:
    WSACleanup();

    return bRet;
}


VOID
FreeOtherNames(LPWSTR **ppszMyOtherNames, DWORD *cOtherNames)
{
    DWORD i;

    for( i = 0 ; i < *cOtherNames ; ++i)
        FreeSplMem((*ppszMyOtherNames)[i]);

    FreeSplMem(*ppszMyOtherNames);
}



LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    )
/*++

Description:
    Convert ANSI string to UNICODE. Routine allocates memory from the heap
    which should be freed by the caller.

Arguments:
    pAnsi    - Points to the ANSI string

Return Vlaue:
    Pointer to UNICODE string

--*/
{
    LPWSTR  pUnicode;
    DWORD   rc;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             NULL,
                             0);

    rc *= sizeof(WCHAR);
    if ( !rc || !(pUnicode = (LPWSTR) AllocSplMem(rc)) )
        return NULL;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             pUnicode,
                             rc);

    if ( rc )
        return pUnicode;
    else {
        FreeSplMem(pUnicode);
        return NULL;
    }
}


/*++

Routine Description

    Determines whether or not a machine name contains the local machine name.

    Localspl enum calls fail if pName != local machine name (\\Machine).
    Remote enum provider is then called.  The remote enum provider must check
    if the UNC name refers to the local machine, and fail if it does to avoid
    endless recursion.

Arguments:

    LPWSTR pName - UNC name.

Return Value:

    TRUE:   pName == \\szMachineName\...
                  - or -
            pName == \\szMachineName

    FALSE:  anything else

Author: swilson

 --*/

BOOL
MyUNCName(
    LPWSTR   pNameStart
)
{
    PWCHAR pMachine = szMachineName;
    LPWSTR pName;
    DWORD i;
    extern LPWSTR *ppszOtherNames;   // Contains szMachineName, DNS name, and all other machine name forms
    extern DWORD cOtherNames;


    if (!pNameStart || !*pNameStart)      // This differs from MyName(), which returns TRUE
        return FALSE;

    if (*pNameStart == L'\\' && *(pNameStart + 1) == L'\\') {
        for (i = 0 , pName = pNameStart + 2 ; i < cOtherNames ; ++i , pName = pNameStart + 2) {
            for(pMachine = ppszOtherNames[i] ;
                *pName && towupper(*pName) == towupper(*pMachine) ;
                ++pName, ++pMachine)
                ;

            if(!*pMachine && (!*pName || *pName == L'\\'))
                return TRUE;
        }
    }

    return FALSE;
}

BOOL
SplIsUpgrade(
    VOID
    )
{
    return dwUpgradeFlag;

}


PWSTR
AutoCat(
    PCWSTR pszInput,
    PCWSTR pszCat
)
{
    PWSTR   pszOut;

    if (!pszCat) {

        pszOut =  AllocSplStr(pszInput);

    } else if (pszInput) {

        pszOut = AllocSplMem((wcslen(pszInput) + wcslen(pszCat) + 1)*sizeof(WCHAR));
        if (pszOut) {
            wcscpy(pszOut, pszInput);
            wcscat(pszOut, pszCat);
        }

    } else {

        pszOut = AllocSplStr(pszCat);

    }

    return pszOut;
}

PBIDI_RESPONSE_CONTAINER
RouterAllocBidiResponseContainer(
    DWORD Count
)
{
    DWORD MemSize = 0;
    //
    // Add the size of the container - the size of the first data element
    //
    MemSize += (sizeof(BIDI_RESPONSE_CONTAINER) - sizeof(BIDI_RESPONSE_DATA));
    //
    // Add the size of all the returned RESPONSE_DATA elements
    //
    MemSize += (Count * sizeof(BIDI_RESPONSE_DATA));

    return((PBIDI_RESPONSE_CONTAINER) MIDL_user_allocate(MemSize));
}

/*++

Routine Name

    GetAPDPolicy

Routine Description:

    This function reads a DWORD value from the location
    HKEY\pszRelPath\pszValueName. We use this function for
    preserving the AddPrinterDrivers policy value when the
    LanMan Print Services print provider is deleted from 
    the system.
        
Arguments:

    hKey         - key tree
    pszRelPath   - relative path of the value to be get
    pszValueName - value name
    pValue       - pointer to memory to store a dword value

Return Value:

    ERROR_SUCCESS    - the value was retrieved
    Win32 error code - an error occured 

--*/
DWORD
GetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN LPDWORD pValue
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (hKey && pszRelPath && pszValueName && pValue) 
    {
        HKEY   hRelKey = NULL;
        
        *pValue = 0;
        
        //
        // Check if we have a value in the new location already
        //
        if ((Error = RegOpenKeyEx(hKey,
                                  pszRelPath,
                                  0,
                                  KEY_READ,
                                  &hRelKey)) == ERROR_SUCCESS)
        {
            DWORD cbData = sizeof(DWORD);

            Error = RegQueryValueEx(hRelKey,
                                    pszValueName,
                                    NULL,
                                    NULL,
                                    (LPBYTE)pValue,
                                    &cbData);
            
            RegCloseKey(hRelKey);
        }        
    }

    return Error;
}

/*++

Routine Name

    SetAPDPolicy

Routine Description:

    This function writes a DWORD value to the location
    HKEY\pszRelPath\pszValueName. We use this function for
    preserving the AddPrinterDrivers policy value when the
    LanMan Print Services print provider is deleted from 
    the system.
        
Arguments:

    hKey         - key tree
    pszRelPath   - relative path of the value to be set
    pszValueName - value name to be set
    Value        - dword value to be set

Return Value:

    ERROR_SUCCESS    - the value was set sucessfully
    Win32 error code - an error occured and the value was not set

--*/
DWORD
SetAPDPolicy(
    IN HKEY    hKey,
    IN LPCWSTR pszRelPath,
    IN LPCWSTR pszValueName,
    IN DWORD   Value
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (hKey && pszRelPath && pszValueName) 
    {
        HKEY   hRelKey = NULL;
        
        //
        // Check if we have a value in the new location already
        //
        if ((Error = RegCreateKeyEx(hKey,
                                    pszRelPath,
                                    0,
                                    NULL,
                                    0,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hRelKey,
                                    NULL)) == ERROR_SUCCESS)
        {
            Error = RegSetValueEx(hRelKey,
                                  pszValueName,
                                  0,
                                  REG_DWORD,
                                  (LPBYTE)&Value,
                                  sizeof(DWORD));
            
            RegCloseKey(hRelKey);
        }        
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\dll\winspool.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    winspool.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

//
// Globals
//

LPPROVIDOR  pLocalProvidor;
MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

LPWSTR szRegistryProvidors = L"System\\CurrentControlSet\\Control\\Print\\Providers";
LPWSTR szPrintKey          = L"System\\CurrentControlSet\\Control\\Print";
LPWSTR szLocalSplDll       = L"localspl.dll";
LPWSTR szOrder             = L"Order";
LPWSTR szEnvironment       = LOCAL_ENVIRONMENT;


//
// Strings for handling the AddPrinterDrivers policy
//
LPWSTR szLanManProvider    = L"LanMan Print Services";
LPWSTR szAPDRelPath        = L"LanMan Print Services\\Servers";
LPWSTR szAPDValueName      = L"AddPrinterDrivers";

BOOL
AddPrinterDriverW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddPrinterDriver) (pName, Level, pDriverInfo)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
AddPrinterDriverExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddPrinterDriverEx) (pName,
                                                              Level,
                                                              pDriverInfo,
                                                              dwFileCopyFlags)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
AddDriverCatalog(
    HANDLE     hPrinter,
    DWORD      dwLevel,
    VOID       *pvDriverInfCatInfo,
    DWORD      dwCatalogCopyFlags
)
{
    HRESULT hRetval = E_FAIL;
    LPPRINTHANDLE   pPrintHandle = (LPPRINTHANDLE)hPrinter;

    hRetval = pPrintHandle && (PRINTHANDLE_SIGNATURE == pPrintHandle->signature) ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = (*pPrintHandle->pProvidor->PrintProvidor.fpAddDriverCatalog) (pPrintHandle->hPrinter,
                                                                                dwLevel, pvDriverInfCatInfo, dwCatalogCopyFlags);
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return hRetval;
}

BOOL
EnumPrinterDriversW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDrivers,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PROVIDOR *pProvidor;

    if ((pDrivers == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!(*pProvidor->PrintProvidor.fpEnumPrinterDrivers) (pName, pEnvironment, Level,
                                                 pDrivers, cbBuf,
                                                 pcbNeeded, pcReturned)) {

            if (GetLastError() != ERROR_INVALID_NAME)
                return FALSE;

        } else

            return TRUE;

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
GetPrinterDriverDirectoryW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    if ((pDriverInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpGetPrinterDriverDirectory)
                                (pName, pEnvironment, Level, pDriverInfo,
                                 cbBuf, pcbNeeded)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
DeletePrinterDriverW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpDeletePrinterDriver)
                                (pName, pEnvironment, pDriverName)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
DeletePrinterDriverExW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName,
    DWORD   dwDeleteFlag,
    DWORD   dwVersionNum
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;
    while (pProvidor) {
       if ((*pProvidor->PrintProvidor.fpDeletePrinterDriverEx)
                (pName, pEnvironment, pDriverName, dwDeleteFlag, dwVersionNum)) {
          return TRUE;
       }
       if (GetLastError() != ERROR_INVALID_NAME) {
          return FALSE;
       }
       pProvidor = pProvidor->pNext;
    }
    return FALSE;
}

BOOL
AddPrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddPrintProcessor) (pName, pEnvironment,
                                               pPathName,
                                               pPrintProcessorName)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
EnumPrintProcessorsW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    LPPROVIDOR  pProvidor;

    if ((pPrintProcessors == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!(*pProvidor->PrintProvidor.fpEnumPrintProcessors) (pName, pEnvironment, Level,
                                                  pPrintProcessors, cbBuf,
                                                  pcbNeeded, pcReturned)) {

            if (GetLastError() != ERROR_INVALID_NAME)
                return FALSE;

        } else

            return TRUE;

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
GetPrintProcessorDirectoryW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    if ((pPrintProcessorInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpGetPrintProcessorDirectory)
                                (pName, pEnvironment, Level,
                                 pPrintProcessorInfo,
                                 cbBuf, pcbNeeded)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);

    return FALSE;
}

BOOL
EnumPrintProcessorDatatypesW(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    LPPROVIDOR  pProvidor;

    if ((pDatatypes == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!(*pProvidor->PrintProvidor.fpEnumPrintProcessorDatatypes)
                                                 (pName, pPrintProcessorName,
                                                  Level, pDatatypes, cbBuf,
                                                  pcbNeeded, pcReturned)) {

            if (GetLastError() != ERROR_INVALID_NAME)
                return FALSE;

        } else

            return TRUE;

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}


BOOL
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpAddForm) (pPrintHandle->hPrinter,
                                                  Level, pForm);
}

BOOL
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeleteForm) (pPrintHandle->hPrinter,
                                                     pFormName);
}

BOOL
GetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD Level,
    LPBYTE pForm,
    DWORD cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pForm == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetForm) (pPrintHandle->hPrinter,
                                               pFormName, Level, pForm,
                                               cbBuf, pcbNeeded);
}

BOOL
SetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetForm) (pPrintHandle->hPrinter,
                                                  pFormName, Level, pForm);
}

BOOL
EnumFormsW(
   HANDLE hPrinter,
   DWORD    Level,
   LPBYTE   pForm,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pForm == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumForms) (pPrintHandle->hPrinter,
                                                 Level, pForm, cbBuf,
                                                 pcbNeeded, pcReturned);
}


BOOL
DeletePrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpDeletePrintProcessor)
                                (pName, pEnvironment, pPrintProcessorName)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

LPPROVIDOR FindProvidor(
    HKEY    hProvidors,
    LPWSTR  pName
)

/*++
Function Description: Retrieves providor struct for a providor name.

Parameters: hProvidors     - handle to the Providors key
            pName          - name of the providor

Return Values: pProvidor if one is found; NULL otherwise
--*/

{
    LPPROVIDOR   pProvidor;
    WCHAR        szDllName[MAX_PATH];
    DWORD        dwError;
    DWORD        cbDllName;
    HKEY         hProvidor = NULL;

    szDllName[0] = L'\0';
    cbDllName = COUNTOF(szDllName);

    // Search the registry for the DLL Name to compare with lpName
    if ((dwError = RegOpenKeyEx(hProvidors, pName, 0, KEY_READ, &hProvidor)) ||

        (dwError = RegQueryValueEx(hProvidor, L"Name", NULL, NULL,
                                   (LPBYTE)szDllName, &cbDllName)))
    {
        SetLastError(dwError);
        if (hProvidor)
        {
            RegCloseKey(hProvidor);
        }
        return NULL;
    }

    RegCloseKey(hProvidor);

    // Loop thru the list of providors for the name of the dll
    for (pProvidor = pLocalProvidor;
         pProvidor;
         pProvidor = pProvidor->pNext)
    {
        if (!_wcsicmp(pProvidor->lpName, szDllName))
        {
            break;
        }
    }

    return pProvidor;
}

// Struct to maintain the new order of the providors
typedef struct _ProvidorList {
   struct _ProvidorList *pNext;
   LPPROVIDOR  pProvidor;
} ProvidorList;

BOOL AddNodeToProvidorList(
     LPPROVIDOR  pProvidor,
     ProvidorList **pStart
)

/*++
Function Description: Adds a node to the list of providors. Avoids duplicate entries in
                      the list

Parameters: pProvidor    -  providor to be added
            pStart       -  pointer to the pointer to the start of the list

Return Values: TRUE if successful; FALSE otherwise
--*/

{
     BOOL  bReturn = FALSE;
     ProvidorList **pTemp, *pNew;

     // No providor found
     if (!pProvidor) {
         goto CleanUp;
     }

     for (pTemp = pStart; *pTemp; pTemp = &((*pTemp)->pNext))
     {
         if ((*pTemp)->pProvidor == pProvidor)
         {
             // Duplicates in the order string is an error
             goto CleanUp;
         }
     }

     // Add new node
     if (pNew = AllocSplMem(sizeof(ProvidorList)))
     {
         pNew->pNext = NULL;
         pNew->pProvidor = pProvidor;
         *pTemp = pNew;
         bReturn = TRUE;
     }

CleanUp:

     return bReturn;
}


BOOL UpdateProvidorOrder(
    HKEY    hProvidors,
    LPWSTR  pOrder
)

/*++
Function Description: Updates the order of the providors in spooler and the registry.

Parameters:  hProvidors    -   handle to Providors registry key
             pOrder        -   multisz order of providors

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL       bReturn = FALSE, bRegChange = FALSE;
    DWORD      dwError, dwRequired, dwBytes, dwOldCount, dwNewCount;
    LPWSTR     pOldOrder = NULL, pStr;
    LPPROVIDOR pProvidor;

    // Maintain a list of the new order, so that error recovery is quick
    ProvidorList *pStart = NULL, *pTemp;

    // Loop thru the providor names in the new order
    for (pStr = pOrder, dwBytes = 0;
         pStr && *pStr;
         pStr += (wcslen(pStr) + 1))
    {
        pProvidor = FindProvidor(hProvidors, pStr);

        if (!AddNodeToProvidorList(pProvidor, &pStart)) {
            goto CleanUp;
        }

        dwBytes += (wcslen(pStr) + 1) * sizeof(WCHAR);
    }
    // Add the sizeof the last NULL char
    dwBytes += sizeof(WCHAR);

    // Make sure that all the providors are present in the list
    for (dwOldCount = 0, pProvidor = pLocalProvidor;
         pProvidor;
         ++dwOldCount, pProvidor = pProvidor->pNext) ;

    // Add 1 for the local providor which does not appear on the list
    for (dwNewCount = 1, pTemp = pStart;
         pTemp;
         ++dwNewCount, pTemp = pTemp->pNext) ;

    if (dwNewCount == dwOldCount) {

        // Update the registry
        if (dwError = RegSetValueEx(hProvidors, szOrder, 0,
                                    REG_MULTI_SZ, (LPBYTE)pOrder, dwBytes))
        {
            SetLastError(dwError);
            goto CleanUp;
        }

        // Change the order in the spooler structure
        for (pTemp = pStart, pProvidor = pLocalProvidor;
             pTemp;
             pTemp = pTemp->pNext, pProvidor = pProvidor->pNext)
        {
            pProvidor->pNext = pTemp->pProvidor;
        }

        pProvidor->pNext = NULL;

        bReturn = TRUE;

    } else {

        // All the providors are not listed in the order
        SetLastError(ERROR_INVALID_PARAMETER);
    }

CleanUp:
    // Free the temp list
    while (pTemp = pStart) {
       pStart = pTemp->pNext;
       FreeSplMem(pTemp);
    }

    return bReturn;
}

BOOL AddNewProvidor(
    HKEY    hProvidors,
    PPROVIDOR_INFO_1W pProvidorInfo
)

/*++
Function Description: This function updates the registry with the new providor info and the
                      new providor order. The new providor is appended to the current order.
                      This order can be changed by calling AddPrintProvidor with
                      Providor_info_2. The providor is immediately used for routing.

Parameters:     hProvidors      -  providors registry key
                pProvidorInfo   -  ProvidorInfo1 struct

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bReturn = FALSE, bOrderUpdated = FALSE, bPresent = FALSE;
    DWORD   dwError, dwRequired, dwReturned, dwOldSize, dwDisposition = 0;
    WCHAR   szProvidorName[MAX_PATH+COUNTOF(szRegistryProvidors)];
    LPWSTR  pOldOrder = NULL, pNewOrder = NULL;
    HKEY    hNewProvidor = NULL;

    LPPROVIDOR pNewProvidor, pProvidor, pLastProvidor;

    if (!pProvidorInfo->pName || !pProvidorInfo->pDLLName || 
        !(*pProvidorInfo->pName) || !(*pProvidorInfo->pDLLName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }
        
    for (pProvidor = pLocalProvidor; // Local Providor is always present
         pProvidor;
         pProvidor = pProvidor->pNext) 
    {
        pLastProvidor = pProvidor;
        if (!lstrcmpi(pProvidor->lpName, pProvidorInfo->pDLLName))
        {
            //
            // This should return error, but it breaks some programs that
            // assume they can always add a provider
            //
            //SetLastError(ERROR_ALREADY_EXISTS);
            bReturn = TRUE;
            goto CleanUp;
        }
    }

    // Update the registry with new providor key
    if ((dwError = RegCreateKeyEx(hProvidors, pProvidorInfo->pName, 0, NULL, 0,
                                  KEY_ALL_ACCESS, NULL, &hNewProvidor, &dwDisposition)) ||

        (dwError = RegSetValueEx(hNewProvidor, L"Name", 0, REG_SZ,
                                 (LPBYTE)pProvidorInfo->pDLLName,
                                 (wcslen(pProvidorInfo->pDLLName)+1) * sizeof(WCHAR))))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    // Close the handle
    RegCloseKey(hNewProvidor);
    hNewProvidor = NULL;

    // Append to the order value
    dwRequired = 0;
    dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL, NULL, &dwRequired);

    switch (dwError) {

    case ERROR_SUCCESS:
        if ((dwOldSize = dwRequired) &&
            (pOldOrder = AllocSplMem(dwRequired)) &&
            !(dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL,
                                        (LPBYTE) pOldOrder, &dwRequired)))
        {
            break;
        }
        else
        {
            if (dwError) {
                SetLastError(dwError);
            }
            goto CleanUp;
        }

    case ERROR_FILE_NOT_FOUND:
        break;

    default:

        SetLastError(dwError);
        goto CleanUp;
    }

    // Append the new providor to the current order
    pNewOrder = (LPWSTR)AppendOrderEntry(pOldOrder, dwRequired,
                                         pProvidorInfo->pName, &dwReturned);
    if (!pNewOrder ||
        (dwError = RegSetValueEx(hProvidors, szOrder, 0,
                                 REG_MULTI_SZ, (LPBYTE)pNewOrder, dwReturned)))
    {
        if (dwError) {
            SetLastError(dwError);
        }
        goto CleanUp;
    }

    bOrderUpdated = TRUE;

    // Initialize the providor and update the spooler structure
    wsprintf(szProvidorName, L"%ws\\%ws", szRegistryProvidors, pProvidorInfo->pName);

    pNewProvidor = InitializeProvidor(pProvidorInfo->pDLLName, szProvidorName);

    if (pNewProvidor)
    {
        pNewProvidor->pNext = NULL;
        pLastProvidor->pNext = pNewProvidor;
        bReturn = TRUE;
    }

CleanUp:

    // Roll back if anything fails
    if (!bReturn)
    {
        // Remove the new providor key if it was created
        if (dwDisposition == REG_CREATED_NEW_KEY) 
        {
            DeleteSubKeyTree(hProvidors, pProvidorInfo->pName);
            RegDeleteKey(hProvidors, pProvidorInfo->pName);
        }

        // Restore the old order if it has been changed
        if (bOrderUpdated) {
            if (pOldOrder)
            {
                RegSetValueEx(hProvidors, szOrder, 0,
                              REG_MULTI_SZ, (LPBYTE)pOldOrder, dwOldSize);
            }
            else
            {
                RegDeleteValue(hProvidors, szOrder);
            }
        }
    }

    // Free allocated memory
    if (pOldOrder) {
        FreeSplMem(pOldOrder);
    }
    if (pNewOrder) {
        FreeSplMem(pNewOrder);
    }
    if (hNewProvidor) {
        RegCloseKey(hNewProvidor);
    }

    return bReturn;
}

BOOL AddPrintProvidorW(
    LPWSTR  pName,
    DWORD   dwLevel,
    LPBYTE  pProvidorInfo
)

/*++
Function Description: This function adds and initializes a print providor. It also updates the
                      registry and the order of print providors.

Parameters:  pName         -   server name for routing (currently ignored)
             dwLevel       -   providor info level
             pProvidorInfo -   providor info buffer

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bReturn = FALSE;
    DWORD   dwError = ERROR_SUCCESS;
    HANDLE  hToken;
    HKEY    hProvidors = NULL;

    WaitForSpoolerInitialization();

    EnterRouterSem();

    // Revert to spooler security context before accessing the registry
    //
    // This is a really bad idea, as it enables any user to get system 
    // priveleges without even trying.
    //
    // hToken = RevertToPrinterSelf();

    // Check for invalid parameters
    if (!pProvidorInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }

    if (dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryProvidors, 0,
                                 NULL, 0, KEY_ALL_ACCESS, NULL, &hProvidors, NULL))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    switch (dwLevel) {
    case 1:
        bReturn = AddNewProvidor(hProvidors,
                                 (PPROVIDOR_INFO_1W) pProvidorInfo);
        break;

    case 2:
        bReturn = UpdateProvidorOrder(hProvidors,
                                      ((PPROVIDOR_INFO_2W) pProvidorInfo)->pOrder);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        break;
    }

CleanUp:

    if (hProvidors) {
        RegCloseKey(hProvidors);
    }

    if (!bReturn && !GetLastError()) {
        // Last error should be set by individual functions. In the event that something
        // is not already set, return a placeholder error code
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    LeaveRouterSem();

    // ImpersonatePrinterClient(hToken);

    return bReturn;
}

BOOL DeletePrintProvidorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pProvidorName
)

/*++
Function Description: Deletes a print providor by updating the registry and the
                      removing it from the list of routing providors.

Parameters: pName          -   server name for routing (currently ignored)
            pEnvironment   -   environment name (currently ignored)
            pProvidorName  -   providor name

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bReturn = FALSE;
    DWORD   dwError = ERROR_SUCCESS, dwRequired, dwReturned;
    LPWSTR  pOldOrder = NULL, pNewOrder = NULL;
    HANDLE  hToken;
    HKEY    hProvidors = NULL;
    BOOL    bSaveAPDPolicy = FALSE;
    DWORD   APDValue;

    LPPROVIDOR   pProvidor, pTemp;

    WaitForSpoolerInitialization();

    EnterRouterSem();

    // Revert to spooler security context before accessing the registry
    //
    // Or rather, Don't.
    //
    //hToken = RevertToPrinterSelf();

    // Check for invalid parameters
    if (!pProvidorName || !*pProvidorName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }

    if (dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryProvidors, 0,
                                 NULL, 0, KEY_ALL_ACCESS, NULL, &hProvidors, NULL))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    // Save the pProvidor before deleting the registry entry
    if (!(pProvidor = FindProvidor(hProvidors, pProvidorName)))
    {
        goto CleanUp;
    }

    // Update the order
    dwRequired = 0;
    if (dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL, NULL, &dwRequired))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    if (!dwRequired ||
        !(pOldOrder = AllocSplMem(dwRequired)) ||
        (dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL,
                                   (LPBYTE) pOldOrder, &dwRequired)))
    {
        if (dwError) {
           SetLastError(dwError);
        }
        goto CleanUp;
    }

    // Remove the providor from the current order
    pNewOrder = (LPWSTR)RemoveOrderEntry(pOldOrder, dwRequired,
                                         pProvidorName, &dwReturned);
    if (!pNewOrder ||
        (dwError = RegSetValueEx(hProvidors, szOrder, 0,
                                 REG_MULTI_SZ, (LPBYTE)pNewOrder, dwReturned)))
    {
        if (dwError) {
            SetLastError(dwError);
        }
        goto CleanUp;
    }

    //
    // The AddPrinterDrivers policy has the registry value in the wrong place
    // under the lanman print services key. The lanman provider is deleted
    // during upgrade from Windows 2000 to XP. We save the AddPrinterDrivers
    // value and restore it after we delete the registry tree for the provider.
    //
    if (!_wcsicmp(szLanManProvider, pProvidorName)) 
    {
        bSaveAPDPolicy = GetAPDPolicy(hProvidors,
                                      szAPDRelPath,
                                      szAPDValueName,
                                      &APDValue) == ERROR_SUCCESS;
    }

    //
    // Delete the registry key
    //
    DeleteSubKeyTree(hProvidors, pProvidorName);

    //
    // Restore the AddPrinterDrivers policy if needed.
    //
    if (bSaveAPDPolicy) 
    {
        SetAPDPolicy(hProvidors,
                     szAPDRelPath,
                     szAPDValueName,
                     APDValue);
    }

    // Remove from the linked list of providors for routing
    for (pTemp = pLocalProvidor;
         pTemp->pNext; // Local Providor is always present and cant be deleted
         pTemp = pTemp->pNext)
    {
        if (pTemp->pNext == pProvidor) {
            // dont release the library and the struct since they may be used in
            // other threads
            pTemp->pNext = pProvidor->pNext;
            break;
        }
    }

    bReturn = TRUE;

CleanUp:

    if (!bReturn && !GetLastError()) {
        // Last error should be set by individual functions. In the event that something
        // is not already set, return a placeholder error code
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Free allocated memory
    if (pOldOrder) {
        FreeSplMem(pOldOrder);
    }
    if (pNewOrder) {
        FreeSplMem(pNewOrder);
    }
    if (hProvidors) {
        RegCloseKey(hProvidors);
    }

    LeaveRouterSem();

    // ImpersonatePrinterClient(hToken);

    return bReturn;
}

BOOL
OldGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pDriverInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriver)
                       (pPrintHandle->hPrinter, pEnvironment,
                        Level, pDriverInfo, cbBuf, pcbNeeded);
}




BOOL
GetPrinterDriverExW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pDriverInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    if (pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriverEx) {

        DBGMSG(DBG_TRACE, ("Calling the fpGetPrinterDriverEx function\n"));

        return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriverEx)
                       (pPrintHandle->hPrinter, pEnvironment,
                        Level, pDriverInfo, cbBuf, pcbNeeded,
                        dwClientMajorVersion, dwClientMinorVersion,
                        pdwServerMajorVersion, pdwServerMinorVersion);
    } else {

        //
        // The print providor does not support versioning of drivers
        //
        DBGMSG(DBG_TRACE, ("Calling the fpGetPrinterDriver function\n"));
        *pdwServerMajorVersion = 0;
        *pdwServerMinorVersion = 0;
        return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriver)
                    (pPrintHandle->hPrinter, pEnvironment,
                     Level, pDriverInfo, cbBuf, pcbNeeded);
    }
}



BOOL
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD dwServerMajorVersion;
    DWORD dwServerMinorVersion;

    return  GetPrinterDriverExW( hPrinter,
                                 pEnvironment,
                                 Level,
                                 pDriverInfo,
                                 cbBuf,
                                 pcbNeeded,
                                 (DWORD)-1,
                                 (DWORD)-1,
                                 &dwServerMajorVersion,
                                 &dwServerMinorVersion );
}




BOOL
XcvDataW(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hXcv;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpXcvData)( pPrintHandle->hPrinter,
                                                                pszDataName,
                                                                pInputData,
                                                                cbInputData,
                                                                pOutputData,
                                                                cbOutputData,
                                                                pcbOutputNeeded,
                                                                pdwStatus);
}



/*++

Routine Name:

    GetJobAttributes 
        
Routine Description:

    GetJobAttributes gets information about the job. 
    This includes nup and reverse printing options.

Arguments:

    pPrinterName      -- name of the printer.
    pDevmode          -- Devmode to be passed to the driver
    pAttributeInfo    -- buffer to place information about the job 

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

BOOL
GetJobAttributes(
    LPWSTR            pPrinterName,
    LPDEVMODEW        pDevmode,
    PATTRIBUTE_INFO_3 pAttributeInfo
    )
{
    HANDLE           hDrvPrinter = NULL;
    BOOL             bReturn = FALSE, bDefault = FALSE;
    FARPROC          pfnDrvQueryJobAttributes;
    HINSTANCE        hDrvLib = NULL;
    fnWinSpoolDrv    fnList;

    // Get the pointer to the client side functions from the router
    if (!SplInitializeWinSpoolDrv(&fnList)) {
        return FALSE;
    }

    // Get a client side printer handle to pass to the driver
    if (!(* (fnList.pfnOpenPrinter))(pPrinterName, &hDrvPrinter, NULL)) {
        //ODS(("Open printer failed\nPrinter %ws\n",pPrinterName));
        goto CleanUp;
    }

    // Load the driver config file
    if (!(hDrvLib = (* (fnList.pfnLoadPrinterDriver))(hDrvPrinter))) {
        //ODS(("DriverDLL could not be loaded\n"));
        goto CleanUp;
    }

    // Call the DrvQueryJobAtributes function in the driver
    if (pfnDrvQueryJobAttributes = GetProcAddress(hDrvLib, "DrvQueryJobAttributes")) {

        if (!(* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                           pDevmode,
                                           3,
                                           (LPBYTE) pAttributeInfo)) {

            if (!(* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                               pDevmode,
                                               2,
                                               (LPBYTE) pAttributeInfo)) {

                if (!(* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                                   pDevmode,
                                                   1,
                                                   (LPBYTE) pAttributeInfo)) {

                    bDefault = TRUE;

                } else {

                    pAttributeInfo->dwColorOptimization = 0;
                }

            } else {
               
                pAttributeInfo->dmPrintQuality = pDevmode->dmPrintQuality;
                pAttributeInfo->dmYResolution = pDevmode->dmYResolution;
            }
        }

    } else {
        
        bDefault = TRUE;
    }

    if (bDefault) {
        // Set default values for old drivers that don't export the function
        pAttributeInfo->dwJobNumberOfPagesPerSide = 1;
        pAttributeInfo->dwDrvNumberOfPagesPerSide = 1;
        pAttributeInfo->dwNupBorderFlags = 0;
        pAttributeInfo->dwJobPageOrderFlags = 0;
        pAttributeInfo->dwDrvPageOrderFlags = 0;
        pAttributeInfo->dwJobNumberOfCopies = pDevmode->dmCopies;
        pAttributeInfo->dwDrvNumberOfCopies = pDevmode->dmCopies;
        pAttributeInfo->dwColorOptimization = 0;       
    }

    bReturn = TRUE;

CleanUp:

    if (hDrvPrinter) {
        (* (fnList.pfnClosePrinter))(hDrvPrinter);
    }
    if (hDrvLib) {
        (* (fnList.pfnRefCntUnloadDriver))(hDrvLib, TRUE);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\idl\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:

    Adina Trufinescu (adinatru) 12-Dec-1999
    Define LPDEVMODEW and PSECURITY_DESCRIPTOR as pointers in order to
    let RPC do the conversion from a 32bit to a 64bit quantity. Make sure 
    these pointers are set on NULL all over the place where use PRINTER_CONTAINER,
    otherwise RPC will get confused when try to marshall.
--*/

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW   ULONG_PTR
#define PSECURITY_DESCRIPTOR ULONG_PTR
#define HANDLE      ULONG_PTR
#define BOOL        DWORD
#endif

#include <winspool.h>
#include <winsplp.h>
#include <..\..\..\..\public\internal\printscan\inc\splapip.h>
#include <..\..\..\..\public\internal\windows\inc\winsprlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\lspldata.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    LsplData.cxx

Abstract:

    Specifies the indicies of the local spooler counters.

Author:

    Albert Ting (AlbertT)  19-Dec-1996
    Based on Gopher perf counter dll.

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsplctr.h"
#include "lspldata.hxx"

#ifdef OFFSETOF
#undef OFFSETOF
#endif

#define OFFSETOF(type, id) ((DWORD)(ULONG_PTR)(&(((type*)0)->id)))

LSPL_DATA_DEFINITION LsplDataDefinition =
{
    {
        sizeof( LSPL_DATA_DEFINITION ) + sizeof( LSPL_COUNTER_DATA ),
        sizeof( LSPL_DATA_DEFINITION ),

        sizeof( PERF_OBJECT_TYPE ),
        LSPL_COUNTER_OBJECT,
        0,
        LSPL_COUNTER_OBJECT,
        0,
        PERF_DETAIL_NOVICE,
        NUMBER_OF_LSPL_COUNTERS,
        3,                          // Default is # jobs in queue.
        0,                          // Place holder for number of instances.
        0,
        { 0, 0 },
        { 0, 0 }
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_TOTAL_JOBS,
        0,
        LSPL_TOTAL_JOBS,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof( LARGE_INTEGER ),
        OFFSETOF( LSPL_COUNTER_DATA, liTotalJobs ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_TOTAL_BYTES,
        0,
        LSPL_TOTAL_BYTES,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof( LARGE_INTEGER ),
        OFFSETOF( LSPL_COUNTER_DATA, liTotalBytes ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_TOTAL_PAGES_PRINTED,
        0,
        LSPL_TOTAL_PAGES_PRINTED,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof( LARGE_INTEGER ),
        OFFSETOF( LSPL_COUNTER_DATA, liTotalPagesPrinted ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_JOBS,
        0,
        LSPL_JOBS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwJobs ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_REF,
        0,
        LSPL_REF,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwRef ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_MAX_REF,
        0,
        LSPL_MAX_REF,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwMaxRef ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_SPOOLING,
        0,
        LSPL_SPOOLING,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwSpooling ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_MAX_SPOOLING,
        0,
        LSPL_MAX_SPOOLING,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwMaxSpooling ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ERROR_OUT_OF_PAPER,
        0,
        LSPL_ERROR_OUT_OF_PAPER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwErrorOutOfPaper ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ERROR_NOT_READY,
        0,
        LSPL_ERROR_NOT_READY,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwErrorNotReady ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_JOB_ERROR,
        0,
        LSPL_JOB_ERROR,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwJobError ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ENUMERATE_NETWORK_PRINTERS,
        0,
        LSPL_ENUMERATE_NETWORK_PRINTERS,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwEnumerateNetworkPrinters ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ADD_NET_PRINTERS,
        0,
        LSPL_ADD_NET_PRINTERS,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwAddNetPrinters ),
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\lsplctr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    LsplCtr.h.hxx

Abstract:

    Specifies the indicies of the local spooler counters.

Author:

    Albert Ting (AlbertT)  19-Dec-1996

Revision History:

--*/

#ifndef LSPLCTR_HXX
#define LSPLCTR_HXX

#define LSPL_COUNTER_OBJECT                 0

//
// Counters must be incremented by 2 each time.
//

#define LSPL_TOTAL_JOBS                     2   // LI
#define LSPL_TOTAL_BYTES                    4   // LI
#define LSPL_TOTAL_PAGES_PRINTED            6   // LI
#define LSPL_JOBS                           8   // DW
#define LSPL_REF                            10  // DW
#define LSPL_MAX_REF                        12  // DW
#define LSPL_SPOOLING                       14  // DW
#define LSPL_MAX_SPOOLING                   16  // DW
#define LSPL_ERROR_OUT_OF_PAPER             18  // DW
#define LSPL_ERROR_NOT_READY                20  // DW
#define LSPL_JOB_ERROR                      22  // DW
#define LSPL_ENUMERATE_NETWORK_PRINTERS     24  // DW
#define LSPL_ADD_NET_PRINTERS               26  // DW

#endif // ifdef LSPLCTR_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\localspl.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    localspl.cxx

Abstract:

    Localspl specific support routines for performance.

Author:

    Albert Ting (AlbertT)  19-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

//
// Define INDEX_FROM_PERFKEY if you want to retrieve the counter/help
// offsets from the registry instead of hardcoded values in ntprfctr.h.
//

#include "perf.hxx"
#include "lspldata.hxx"
#include "splapip.h"
#include "winsprlp.h"

#ifndef INDEX_FROM_PERFKEY
#include "ntprfctr.h"
#endif

/********************************************************************

    Globals

********************************************************************/

LPCTSTR gszAppName = TEXT( "SpoolerCtrs" );

#ifdef INDEX_FROM_PERFKEY
LPCTSTR gszLocalsplPerformanceKey = TEXT( "SYSTEM\\CurrentControlSet\\Services\\spooler\\Performance" );
#endif

BOOL gbInitialized = FALSE;
LPCWSTR gszTotal = L"_Total";

UINT gcbBufferHint = 0x800;
const UINT kBufferHintPad = 0x200;

DWORD
Pfp_dwBuildPrinterInstanceFromInfo(
    PPRINTER_INFO_STRESS pInfo,
    PBYTE* ppData,
    PDWORD pcbDataLeft,
    PLSPL_COUNTER_DATA *pplcd OPTIONAL
    );

DWORD
Pfp_dwBuildPrinterInstanceFromLCD(
    LPCWSTR pszName,
    PLSPL_COUNTER_DATA plcdSource,
    PBYTE* ppData,
    PDWORD pcbDataLeft
    );

/********************************************************************

    Required support routines

********************************************************************/


DWORD
Pf_dwClientOpen(
    LPCWSTR pszDeviceNames,
    PPERF_DATA_DEFINITION *pppdd
    )

/*++

Routine Description:

    Localspl specific intialization of the client data.

Arguments:

    pszDeviceNames - Passed in from performance apis.

Return Value:

    Status code.

--*/

{
    DWORD Status = ERROR_SUCCESS;
    *pppdd = reinterpret_cast<PPERF_DATA_DEFINITION>( &LsplDataDefinition );

    //
    // If not initialized before,
    //
    if( !gbInitialized )
    {
        //
        // Fix up the indicies in our ObjectType and CounterDefinitions.
        //
#ifdef INDEX_FROM_PERFKEY
        Status = Pf_dwFixIndiciesFromPerfKey( gszLocalsplPerformanceKey,
                                   *pppdd );
#else
        Pf_vFixIndiciesFromIndex( LSPL_FIRST_COUNTER_INDEX,
                                  LSPL_FIRST_HELP_INDEX,
                                  *pppdd );
        Status = ERROR_SUCCESS;
#endif
        if( Status == ERROR_SUCCESS )
        {
            gbInitialized = TRUE;
        }
    }


    return Status;
}


DWORD
Pf_dwClientCollect(
    PBYTE *ppData,
    PDWORD pcbDataLeft,
    PDWORD pcNumInstances
    )

/*++

Routine Description:

    Localspl specific collection of data.

Arguments:

Return Value:

    Status code.

--*/

{
    PPRINTER_INFO_STRESS pInfoBase;
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD Error = ERROR_SUCCESS;
    BOOL bStatus;
    PBYTE pData = *ppData;
    DWORD cbDataLeft = *pcbDataLeft;

    pInfoBase = static_cast<PPRINTER_INFO_STRESS>(
                    LocalAlloc( LMEM_FIXED, gcbBufferHint ));

    if( !pInfoBase )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Read the data via EnumPrinters(). We enumerate all the local printers and
    // any cluster printers hosted by the local machine.
    //
    bStatus = EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME | PRINTER_ENUM_CLUSTER,
                            NULL,
                            STRESSINFOLEVEL,
                            reinterpret_cast<PBYTE>( pInfoBase ),
                            gcbBufferHint,
                            &cbNeeded,
                            &cReturned );

    if( !bStatus && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        //
        // Reallocate the buffer and update the hint.
        //
        gcbBufferHint = cbNeeded + kBufferHintPad;
        LocalFree( static_cast<HLOCAL>( pInfoBase ));

        pInfoBase = reinterpret_cast<PPRINTER_INFO_STRESS>(
                        LocalAlloc( LMEM_FIXED, gcbBufferHint ));

        if( !pInfoBase )
        {
            Error = GetLastError();
            goto Cleanup;
        }

        bStatus =  EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME | PRINTER_ENUM_CLUSTER,
                                 NULL,
                                 STRESSINFOLEVEL,
                                 reinterpret_cast<PBYTE>( pInfoBase ),
                                 gcbBufferHint,
                                 &cbNeeded,
                                 &cReturned );
    }

    if( !bStatus )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Update the hint.
    //
    gcbBufferHint = cbNeeded + kBufferHintPad;

    UINT i;
    PPRINTER_INFO_STRESS pInfo;
    LSPL_COUNTER_DATA lcdTotal;
    PLSPL_COUNTER_DATA plcd;

    ZeroMemory( &lcdTotal, sizeof( lcdTotal ));

    for( i=0, pInfo = pInfoBase; i< cReturned; ++i, ++pInfo )
    {
        Error = Pfp_dwBuildPrinterInstanceFromInfo( pInfo,
                                                    &pData,
                                                    &cbDataLeft,
                                                    &plcd );

        if( Error != ERROR_SUCCESS ){
            goto Cleanup;
        }

        //
        // Add up the total.
        //
        lcdTotal.liTotalJobs.QuadPart        += plcd->liTotalJobs.QuadPart;
        lcdTotal.liTotalBytes.QuadPart       += plcd->liTotalBytes.QuadPart;
        lcdTotal.liTotalPagesPrinted.QuadPart+= plcd->liTotalPagesPrinted.QuadPart;
        lcdTotal.dwJobs                      += plcd->dwJobs;
        lcdTotal.dwMaxRef                    += plcd->dwMaxRef;
        lcdTotal.dwSpooling                  += plcd->dwSpooling;
        lcdTotal.dwMaxSpooling               += plcd->dwMaxSpooling;
        lcdTotal.dwRef                       += plcd->dwRef;
        lcdTotal.dwErrorOutOfPaper           += plcd->dwErrorOutOfPaper;
        lcdTotal.dwErrorNotReady             += plcd->dwErrorNotReady;
        lcdTotal.dwJobError                  += plcd->dwJobError;

        //
        // Only include EnumerateNetworkPrinters and dwAddNetPrinters
        // once,d since they are really globals (per-server not per-printer).
        //
        if( i == 0 )
        {
            lcdTotal.dwEnumerateNetworkPrinters = plcd->dwEnumerateNetworkPrinters;
            lcdTotal.dwAddNetPrinters           = plcd->dwAddNetPrinters;
        }
    }

    //
    // Add the last one.
    //
    Error = Pfp_dwBuildPrinterInstanceFromLCD( gszTotal,
                                               &lcdTotal,
                                               &pData,
                                               &cbDataLeft );

Cleanup:

    if( pInfoBase )
    {
        LocalFree( static_cast<HLOCAL>( pInfoBase ));
    }

    if( Error == ERROR_SUCCESS )
    {
        //
        // Update the pointers.  We will return cReturned+1 instances since
        // we built an artifical "_Total" instance.
        //
        *ppData = pData;
        *pcbDataLeft = cbDataLeft;
        *pcNumInstances = cReturned + 1;

        return ERROR_SUCCESS;
    }

    return Error;
}

VOID
Pf_vClientClose(
    VOID
    )

/*++

Routine Description:

    Localspl specific closure of data.

Arguments:

Return Value:

--*/

{
    //
    // Nothing to do since it is name based.
    //
}


/********************************************************************

    Helper functions.

********************************************************************/

DWORD
Pfp_dwBuildPrinterInstanceFromInfo(
    IN     PPRINTER_INFO_STRESS pInfo,
    IN OUT PBYTE* ppData,
    IN OUT PDWORD pcbDataLeft,
       OUT PLSPL_COUNTER_DATA *pplcd OPTIONAL
    )

/*++

Routine Description:

    Add a single pInfo structure to the performance data block.

Arguments:

    pInfo - Input data.

    ppData - On entry, pointer to buffer.  On exit, holds the next
        available space in buffer.  If an error is returned, this
        value is random.

    pcbDataLeft - On entry, size of buffer.  On exit, remaining size
        of buffer.  If an error is returned, this value is random.

    pplcd - Optional; on success returns pointer to lcd.

Return Value:

    ERROR_SUCCESS - Success, else failure code.

--*/

{
    DWORD Error;

    //
    // Add the instance definitions
    //
    Error = Pf_dwBuildInstance( 0,
                                0,
                                static_cast<DWORD>( PERF_NO_UNIQUE_ID ),
                                pInfo->pPrinterName,
                                ppData,
                                pcbDataLeft );

    if( Error != ERROR_SUCCESS )
    {
        goto Fail;
    }

    //
    // Check if there's enough space for our counter data.
    //
    if( *pcbDataLeft < sizeof( LSPL_COUNTER_DATA ))
    {
        Error = ERROR_MORE_DATA;
        goto Fail;
    }

    //
    // Convert ppData to a LSPL_COUNTER_DATA and copy everything over.
    //

    PLSPL_COUNTER_DATA plcd;

    plcd = reinterpret_cast<PLSPL_COUNTER_DATA>( *ppData );
    plcd->CounterBlock.ByteLength = sizeof( LSPL_COUNTER_DATA );

    plcd->liTotalJobs.HighPart = 0;
    plcd->liTotalBytes.HighPart = pInfo->dwHighPartTotalBytes;
    plcd->liTotalPagesPrinted.HighPart = 0;

    plcd->liTotalJobs.LowPart         = pInfo->cTotalJobs;
    plcd->liTotalBytes.LowPart        = pInfo->cTotalBytes;
    plcd->liTotalPagesPrinted.LowPart = pInfo->cTotalPagesPrinted;
    plcd->dwJobs                      = pInfo->cJobs;
    plcd->dwMaxRef                    = pInfo->MaxcRef;
    plcd->dwSpooling                  = pInfo->cSpooling;
    plcd->dwMaxSpooling               = pInfo->cMaxSpooling;
    plcd->dwRef                       = pInfo->cRef;
    plcd->dwErrorOutOfPaper           = pInfo->cErrorOutOfPaper;
    plcd->dwErrorNotReady             = pInfo->cErrorNotReady;
    plcd->dwJobError                  = pInfo->cJobError;
    plcd->dwEnumerateNetworkPrinters  = pInfo->cEnumerateNetworkPrinters;
    plcd->dwAddNetPrinters            = pInfo->cAddNetPrinters;

    //
    // Update the counters.
    //
    *ppData += sizeof( LSPL_COUNTER_DATA );
    *pcbDataLeft -= sizeof( LSPL_COUNTER_DATA );

    if( pplcd )
    {
        *pplcd = plcd;
    }

Fail:

    return Error;
}


DWORD
Pfp_dwBuildPrinterInstanceFromLCD(
    IN     LPCWSTR pszName,
    IN     PLSPL_COUNTER_DATA plcdSource,
    IN OUT PBYTE* ppData,
    IN OUT PDWORD pcbDataLeft
    )

/*++

Routine Description:

    Add a single LCD structure to the performance data block.

Arguments:

    pszName - Name of the block.

    plcd - Pointer to the LCD block to copy.

    ppData - On entry, pointer to buffer.  On exit, holds the next
        available space in buffer.  If an error is returned, this
        value is random.

    pcbDataLeft - On entry, size of buffer.  On exit, remaining size
        of buffer.  If an error is returned, this value is random.

Return Value:

    ERROR_SUCCESS - Success, else failure code.

--*/

{
    DWORD Error;

    //
    // Add the instance definitions
    //
    Error = Pf_dwBuildInstance( 0,
                                0,
                                static_cast<DWORD>( PERF_NO_UNIQUE_ID ),
                                pszName,
                                ppData,
                                pcbDataLeft );

    if( Error != ERROR_SUCCESS )
    {
        goto Fail;
    }

    //
    // Check if there's enough space for our counter data.
    //
    if( *pcbDataLeft < sizeof( LSPL_COUNTER_DATA ))
    {
        Error = ERROR_MORE_DATA;
        goto Fail;
    }

    //
    // Convert ppData to a LSPL_COUNTER_DATA and copy everything over.
    //

    PLSPL_COUNTER_DATA plcd;

    plcd = reinterpret_cast<PLSPL_COUNTER_DATA>( *ppData );

    CopyMemory( plcd, plcdSource, sizeof( LSPL_COUNTER_DATA ));
    plcd->CounterBlock.ByteLength = sizeof( LSPL_COUNTER_DATA );

    //
    // Update the counters.
    //
    *ppData += sizeof( LSPL_COUNTER_DATA );
    *pcbDataLeft -= sizeof( LSPL_COUNTER_DATA );

Fail:

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\perf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    perf.cxx

Abstract:

    Performance counter implementation

    // PerfDataBlock            // Not created here, but this block
                                //     exists before the real one that
                                //     we create.

    _PERF_OBJECT_TYPE           // There is one object type in this counter.
      00 Total size             // Size of entire returned structure
      04 Definition length      // Instance offset

+   _PERF_INSTANCE_DEFINITION
|     00 Total size             // Offset
|     04
|     08
|     0c Unique ID (-1)
|     10 Offset to Name
|     14 Name Length
|   _PERF_COUNTER_BLOCK
|     00 Total size             // Offset to next instance definition
|        <data> variable        // Holds struct of perf data
|                               //     (e.g., LSPL_COUNTER_DATA).
|
+----This entire block repeats, one per printer

Author:

    Albert Ting (AlbertT)  17-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "perf.hxx"
#include "perfp.hxx"
#include "messages.h"

/********************************************************************

    Forward prototypes

********************************************************************/

PM_OPEN_PROC PerfOpen;
PM_COLLECT_PROC PerfCollect;
PM_CLOSE_PROC PerfClose;

GLOBAL_PERF_DATA gpd;

LPCWSTR gszGlobal  = TEXT( "Global" );
LPCWSTR gszForeign = TEXT( "Foreign" );
LPCWSTR gszCostly  = TEXT( "Costly" );
LPCWSTR gszNULL    = TEXT( "" );

LPCTSTR gszLogLevelKeyName = TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib" );
LPCTSTR gszLogLevelValueName = TEXT( "EventLogLevel" );


#define FOREIGN_LENGTH 7

/********************************************************************

    Performance interface functions:

        PerOpen, PerfCollect, PerfClose

********************************************************************/


DWORD
APIENTRY
PerfOpen(
    LPCWSTR pszDeviceNames
    )
{
    DWORD Status = ERROR_SUCCESS;

    if( !gpd.cOpens )
    {
        Status = Pf_dwClientOpen( pszDeviceNames, &gpd.ppdd );

        HKEY        hAppKey;
        DWORD   dwValueType;
        DWORD   dwValueSize;
        UINT    uLogLevel;

        LONG        lStatus;

        gpd.uLogLevel = kUser << kLevelShift;

        lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                gszLogLevelKeyName,
                                0,
                                KEY_READ,
                                &hAppKey );

        dwValueSize = sizeof(uLogLevel);

        if (lStatus == ERROR_SUCCESS)
        {
            lStatus = RegQueryValueEx( hAppKey,
                                       gszLogLevelValueName,
                                       (LPDWORD)NULL,
                                       &dwValueType,
                                       (LPBYTE)&uLogLevel,
                                       &dwValueSize );

            if (lStatus == ERROR_SUCCESS)
            {
                gpd.uLogLevel = uLogLevel;
            }

            RegCloseKey(hAppKey);
        }
    }

    if( Status == ERROR_SUCCESS )
    {
        ++gpd.cOpens;
    }

    Pf_vReportEvent( kInformation | kDebug,
                     MSG_PERF_OPEN_CALLED,
                     sizeof( Status ),
                     &Status,
                     NULL );

    return Status;
}

DWORD
APIENTRY
PerfCollect(
    LPCWSTR pszValue,
    PBYTE *ppData,
    PDWORD pcbData,
    PDWORD pcObjectTypes
    )
{
    DWORD Status = ERROR_SUCCESS;
    DWORD cbObjectType;
    DWORD cbDataLeft;
    PBYTE pData = *ppData;
    DWORD cNumInstances;
    DWORD cbTotalSize;
    PPERF_OBJECT_TYPE ppot;

    //
    // pszValue can be NULL, in this case we consider it gszNULL.
    //
    pszValue = pszValue == NULL ? gszNULL : pszValue;

    //
    // We need to punt if we're:
    //
    //     Not initialized
    //     Foreign
    //     Costly
    //
    if( !gpd.cOpens ||
        !wcsncmp( pszValue, gszForeign, FOREIGN_LENGTH ) ||
        !wcscmp( pszValue, gszCostly ))
    {
        goto Fail;
    }

    //
    // If we're not global, then see if our title index is requested.
    //
    if( wcscmp( pszValue, gszGlobal ))
    {
        if( !Pfp_bNumberInUnicodeList(
                 gpd.ppdd->ObjectType.ObjectNameTitleIndex,
                 pszValue ))
        {
            goto Fail;
        }
    }

    //
    // Add the header information to the buffer if there is space.
    // First check if we have space.
    //
    cbObjectType = gpd.ppdd->ObjectType.DefinitionLength;
    if( *pcbData < cbObjectType )
    {
        //
        // Out of space; fail.
        //
        Status = ERROR_MORE_DATA;
        goto Fail;
    }

    //
    // Copy the data then update the space used.
    //
    CopyMemory( pData, &gpd.ppdd->ObjectType, cbObjectType );

    pData += cbObjectType;
    cbDataLeft = *pcbData - cbObjectType;

    //
    // Call back to the client to collect instance information.
    //
    Status = Pf_dwClientCollect( &pData,
                                 &cbDataLeft,
                                 &cNumInstances );

    if( Status != ERROR_SUCCESS )
    {
        goto Fail;
    }

    //
    // Update header information then return.
    //
    cbTotalSize = *pcbData - cbDataLeft;
    ppot = reinterpret_cast<PPERF_OBJECT_TYPE>(*ppData);
    ppot->NumInstances = cNumInstances;
    ppot->TotalByteLength = cbTotalSize;

    *ppData += cbTotalSize;
    *pcbData = cbTotalSize;
    *pcObjectTypes = 1;

    return ERROR_SUCCESS;

Fail:

    *pcbData = 0;
    *pcObjectTypes = 0;

    return Status;

}

DWORD
PerfClose(
    VOID
    )
{
    --gpd.cOpens;

    if( !gpd.cOpens )
    {
        //
        // Close everything.
        //
        Pf_vClientClose();

        Pf_vReportEvent( kInformation | kDebug,
                         MSG_PERF_CLOSE_CALLED,
                         0,
                         NULL,
                         NULL );

        //
        // If event log was opened, close it.
        //
        Pfp_vCloseEventLog();
    }

    return 0;
}


/********************************************************************

    Utility functions

********************************************************************/


LPCTSTR gszFirstCounter = TEXT( "First Counter" );
LPCTSTR gszFirstHelp = TEXT( "First Help" );

VOID
Pf_vFixIndiciesFromIndex(
    DWORD dwFirstCounter,
    DWORD dwFirstHelp,
    PPERF_DATA_DEFINITION ppdd
    )

/*++

Routine Description:

    Fix the offsets to the localized strings based on indicies.

Arguments:

    dwFirstCounter - Offset for counter text.

    dwFirstHelp - Offset for help text.

Return Value:

--*/

{
    //
    // Update object indicies.
    //
    ppdd->ObjectType.ObjectNameTitleIndex += dwFirstCounter;
    ppdd->ObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    //
    // Update all counter definitions.
    //
    UINT i;
    UINT cCounters = ppdd->ObjectType.NumCounters;
    PPERF_COUNTER_DEFINITION ppcd;

    for( i = 0, ppcd = ppdd->aCounterDefinitions;
         i < cCounters;
         ++i, ++ppcd )
    {
        ppcd->CounterNameTitleIndex += dwFirstCounter;
        ppcd->CounterHelpTitleIndex += dwFirstHelp;
    }
}


DWORD
Pf_dwFixIndiciesFromKey(
    LPCTSTR szPerformanceKey,
    PPERF_DATA_DEFINITION ppdd
    )

/*++

Routine Description:

    Open the performance key so that we can fix up the offsets
    of the localized strings.

Arguments:

    szPerformanceKey - Performance registry key.

Return Value:

    TRUE - Success
    FALSE - Failure

--*/

{
    HKEY    hkey = NULL;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;
    DWORD   cbSize = 0;
    DWORD   dwType;
    DWORD   Error;

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szPerformanceKey,
                          0,
                          KEY_READ,
                          &hkey );

    if( Error == ERROR_SUCCESS )
    {
        //
        //  Read the first counter DWORD.
        //

        cbSize = sizeof(DWORD);

        Error = RegQueryValueEx( hkey,
                                 gszFirstCounter,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>( &dwFirstCounter ),
                                 &cbSize );
    }

    if( Error == ERROR_SUCCESS )
    {
       //
       //  Read the first counter DWORD.
       //

       cbSize = sizeof(DWORD);

       Error = RegQueryValueEx( hkey,
                                gszFirstHelp,
                                NULL,
                                &dwType,
                                reinterpret_cast<LPBYTE>( &dwFirstHelp ),
                                &cbSize );
    }

    if( Error == ERROR_SUCCESS )
    {
        Pf_vFixIndiciesFromIndex( dwFirstCounter, dwFirstHelp, ppdd );
    }

    if ( hkey != NULL)
    {
        RegCloseKey( hkey );
    }

    return Error;
}


DWORD
Pf_dwBuildInstance(
    IN     DWORD dwParentObjectTitleIndex,
    IN     DWORD dwParentObjectInstance,
    IN     DWORD dwUniqueID,
    IN     LPCWSTR pszName,
    IN OUT PBYTE* ppData,
    IN OUT PDWORD pcbDataLeft
    )

/*++

Routine Description:

    Builds and initializes the variable structre PERF_INSTANCE_DEFINITION.

Arguments:

    dwParentObjectTitleIndex - Index of the parent object in the database.

    dwParentObjectInstance - Instance of the parent object (0 or greater).

    dwUniqueID - Id of the object.  May be PERF_NO_UNIQUE_ID.

    pszName - Name of the instance.

    ppData - On entry, holds the pointer to the buffer.  Should be QUADWORD
        aligned.  On exit, holds the next free QUADWORD aligned point in the
        buffer.  If this function fails, this is not modified.

   pcbDataLeft - On entry, holds the size of the buffer.  On exit, holds
        the space remaining (unused) in the buffer.  If this function
        fails, this is not modified.

Return Value:

    ERROR_SUCCESS - Success, else error code.

--*/

{
    //
    // First calculate if we have enough space.  (Assumes that the
    // PERF_INSTANCE_DEFINITION size is WORD aligned.)
    //
    UINT cbName = ( wcslen( pszName ) + 1 ) * sizeof( pszName[0] );
    UINT cbInstanceDefinition = sizeof( PERF_INSTANCE_DEFINITION ) + cbName;

    cbInstanceDefinition = QuadAlignUp( cbInstanceDefinition );

    if( *pcbDataLeft < cbInstanceDefinition )
    {
        return ERROR_MORE_DATA;
    }

    //
    // Build the structure.
    //
    PERF_INSTANCE_DEFINITION *pped;

    pped = reinterpret_cast<PPERF_INSTANCE_DEFINITION>( *ppData );

    pped->ByteLength = cbInstanceDefinition;
    pped->ParentObjectTitleIndex = dwParentObjectTitleIndex;
    pped->ParentObjectInstance = dwParentObjectInstance;
    pped->UniqueID = dwUniqueID;
    pped->NameOffset = sizeof( PERF_INSTANCE_DEFINITION );
    pped->NameLength = cbName;

    //
    // Move the pointer past this structure.
    //
    ++pped;

    //
    // Copy the name right after this structure.
    //
    CopyMemory( pped, pszName, cbName );

    //
    // Update the pointers.
    //
    *ppData += cbInstanceDefinition;
    *pcbDataLeft -= cbInstanceDefinition;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\sharemem.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    sharemem.cxx

Abstract:

    Shared memory implementation.

Author:

    Albert Ting (AlbertT)  17-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sharemem.hxx"

#ifdef COUNTOF
#undef COUNTOF
#endif
#define COUNTOF(x) (sizeof(x)/sizeof(*x))

LPCTSTR szPrefixFile = TEXT( "_ShrMemF" );
LPCTSTR szPrefixMutex = TEXT( "_ShrMemM" );

TShareMem::
TShareMem(
    IN     UINT uSize,
    IN     LPCTSTR pszName,
    IN     UINT uFlags,
    IN     PSECURITY_ATTRIBUTES psa, OPTIONAL
       OUT PUINT puSizeDisposition OPTIONAL
    ) : m_hFile( NULL ), m_hMutex( NULL ), m_pvBase( NULL ),
        m_pvUserData( NULL )

/*++

Routine Description:

    Create a shared memory access object.

Arguments:

    uSize - Size of the buffer requested.

    pszName - Name of shared memory object.

    uFlags - Options

        kCreate     - Create a new file mapping.  If the mapping already
                      exists, it will be used (see puSizeDisposition).  If
                      not specified, an existing one will be opened.
        kReadWrite  - Open with ReadWrite access.  If not specified,
                      Read only access is used.

    psa - Pointer to security attributes.  Used only if kCreate specified.

    puSizeDisposition - If the object already exists, returns its
        size.  If the object did not exist, returns zero.

Return Value:

--*/

{
    UINT cchName;

    //
    // Validate input and determine the size of the name.
    //
    if( !uSize || !pszName || !pszName[0] ||
        ( cchName = lstrlen( pszName )) >= MAX_PATH )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return;
    }

    DWORD dwAccess = ( uFlags & kReadWrite ) ?
                         FILE_MAP_READ | FILE_MAP_WRITE :
                         FILE_MAP_READ;

    //
    // Pre-initialize output variables.
    //

    UINT uSizeDispositionDiscard;

    if( !puSizeDisposition )
    {
        puSizeDisposition = &uSizeDispositionDiscard;
    }
    *puSizeDisposition = 0;

    //
    // Create or shared mutex that will protect the data.  Create
    // the new name.  This needs to be created first to protect
    // against multiple people trying to create the file mapping
    // simultaneously.
    //
    TCHAR szFullName[MAX_PATH + max( COUNTOF( szPrefixFile ),
                                     COUNTOF( szPrefixMutex ))];
    lstrcpy( szFullName, pszName );
    lstrcpy( &szFullName[cchName], szPrefixMutex );
    m_hMutex = CreateMutex( psa,
                            FALSE,
                            szFullName );

    if( !m_hMutex )
    {
        return;
    }

    {
        //
        // Acquire the mutex for use while we're grabbing the resource.
        //
        WaitForSingleObject( m_hMutex, INFINITE );

        BOOL bFileExists = TRUE;

        //
        // Create the name of the mapped file.
        //
        lstrcpy( &szFullName[cchName], szPrefixFile );

        //
        // Either open or create the map file handle.
        //
        if( uFlags & kCreate )
        {
            //
            // Create a new map.
            //
            m_hFile = CreateFileMapping( INVALID_HANDLE_VALUE,
                                         psa,
                                         ( uFlags & kReadWrite ) ?
                                             PAGE_READWRITE :
                                             PAGE_READONLY,
                                         0,
                                         uSize,
                                         szFullName );

            //
            // See if it already exists.
            //
            if( GetLastError() != ERROR_ALREADY_EXISTS )
            {
                bFileExists = FALSE;
            }
        }
        else
        {
            //
            // Open existing map.
            //
            m_hFile = OpenFileMapping( dwAccess,
                                       FALSE,
                                       szFullName );
        }

        if( m_hFile )
        {

            //
            // Map the file into our address space.
            //
            m_pvBase = MapViewOfFile( m_hFile,
                                      dwAccess,
                                      0,
                                      0,
                                      0 );

            if( m_pvBase )
            {
                if( bFileExists )
                {
                    *puSizeDisposition = GetHeader().uSize;
                }
                else
                {
                    GetHeader().uHeaderSize = sizeof( HEADER );
                    GetHeader().uSize = uSize;
                }

                m_pvUserData = reinterpret_cast<PBYTE>( m_pvBase ) +
                               GetHeader().uHeaderSize;
            }
        }

        ReleaseMutex( m_hMutex );
    }

    //
    // m_pvUserData is our valid check.  If this variable is NULL
    // then the object wasn't created correctly.
    //
}

TShareMem::
~TShareMem(
    VOID
    )
{
    if( m_hMutex )
    {
        CloseHandle( m_hMutex );
    }

    if( m_pvBase )
    {
        UnmapViewOfFile( m_pvBase );
    }

    if( m_hFile )
    {
        CloseHandle( m_hFile );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\perfutil.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    perfutil.cxx

Abstract:

    Utility routines copied from sockets\internet\svcs\lib\perfutil.c
    (which were in-turn copied from perfmon interface common code).
    Code reuse from copy & paste instead of fixing the interface.

Author:

    Albert Ting (AlbertT)  17-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "perf.hxx"
#include "perfp.hxx"
#include "messages.h"

/********************************************************************

    Globals

********************************************************************/

//
// Translation table from kEventLogLevel to EVENTLOG_*_TYPE
//
UINT
gauEventLogTable[] = {
    EVENTLOG_INFORMATION_TYPE,  // kSuccess
    EVENTLOG_INFORMATION_TYPE,  // kInformation,
    EVENTLOG_WARNING_TYPE,      // kWarning,
    EVENTLOG_ERROR_TYPE         // kError
};


//
// Test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine.
//
enum CHAR_TYPE {
    kDigit = 1,
    kDelimiter = 2,
    kInvalid = 3
};

inline
CHAR_TYPE
EvalThisChar(
    WCHAR c,
    WCHAR d
    )
{
    if( c == d || c == 0 )
    {
        return kDelimiter;
    }

    if( c < L'0' || c > L'9' )
    {
        return kInvalid;
    }

    return kDigit;
}

BOOL
Pfp_bNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPCWSTR lpwszUnicodeList
    )

/*++

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.
--*/

{
    DWORD   dwThisNumber;
    LPCWSTR pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wckDelimiter;    // could be an argument to be more flexible

    if( !lpwszUnicodeList )
    {
        //
        // NULL pointer, # not found.
        //
        return FALSE;
    }

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wckDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wckDelimiter)) {
            case kDigit:
                // if this is the first kDigit after a kDelimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - L'0');
                }
                break;

            case kDelimiter:
                // a delimter is either the kDelimiter character or the
                // end of the string ('\0') if when the kDelimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case kInvalid:
                // if an kInvalid character was encountered, ignore all
                // characters up to the next kDelimiter and then start fresh.
                // the kInvalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
Pfp_vOpenEventLog (
    VOID
    )

/*++

Routine Description:

   Reads the level of event logging from the registry and opens the channel
   to the event logger for subsequent event log entries.

Arguments:

Return Value:

Revision History:

--*/

{
    if (gpd.hEventLog == NULL)
    {
        gpd.hEventLog = RegisterEventSource( NULL, gszAppName );

        if (gpd.hEventLog != NULL)
        {
            Pf_vReportEvent( kInformation | kDebug,
                             MSG_PERF_LOG_OPEN,
                             0,
                             NULL,
                             NULL );
        }
    }
}


VOID
Pfp_vCloseEventLog(
    VOID
    )

/*++

Routine Description:

    Closes the global event log connection.

Arguments:

Return Value:

--*/

{
    if( gpd.hEventLog )
    {
        Pf_vReportEvent( kInformation | kDebug,
                         MSG_PERF_LOG_CLOSE,
                         0,
                         NULL,
                         NULL );

        DeregisterEventSource( gpd.hEventLog );

        gpd.hEventLog = NULL;
    }
}

VOID
Pf_vReportEvent(
    IN UINT uLevel,
    IN DWORD dwMessage,
    IN DWORD cbData, OPTIONAL
    IN PVOID pvData, OPTIONAL
    IN LPCWSTR pszFirst, OPTIONAL
    ...
    )

/*++

Routine Description:

    Log an event.

Arguments:

    uLevel - Combination of level (e.g., kSuccess, kError) and
        type (e.g., kUser, kVerbose).

    dwMessage - Message number.

    cbData - Size of optional data.

    pvData - Optional data.

    pszFirst - String inserts begin here, optional.

Return Value:

--*/

{
    LPCWSTR apszMergeStrings[kMaxMergeStrings];
    UINT cMergeStrings = 0;
    va_list     vargs;

    //
    // Skip the message if the log level is not high enough.
    //
    if(( uLevel >> kLevelShift ) > gpd.uLogLevel )
    {
        return;
    }

    if( !gpd.hEventLog )
    {
        Pfp_vOpenEventLog();
    }

    if( !gpd.hEventLog )
    {
        return;
    }

    if( pszFirst )
    {
        apszMergeStrings[cMergeStrings++] = pszFirst;

        va_start( vargs, pszFirst );

        while(( cMergeStrings < kMaxMergeStrings ) &&
              ( apszMergeStrings[cMergeStrings] = va_arg( vargs, LPCWSTR )))
        {
            cMergeStrings++;
        }

        va_end( vargs );
    }

    ReportEvent( gpd.hEventLog,
                 (WORD)gauEventLogTable[uLevel & kTypeMask],
                 0,
                 dwMessage,
                 NULL,
                 (WORD)cMergeStrings,
                 cbData,
                 apszMergeStrings,
                 pvData );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\data.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:


Author:

Environment:



Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <splapip.h>
#include <offsets.h>
#include <stddef.h>


#define PRINTER_STRINGS
#define PRINTER_OFFSETS

#define JOB_STRINGS
#define JOB_OFFSETS

#define DRIVER_STRINGS
#define DRIVER_OFFSETS

#define ADDJOB_STRINGS
#define ADDJOB_OFFSETS

#define FORM_STRINGS
#define FORM_OFFSETS

#define PORT_STRINGS
#define PORT_OFFSETS

#define PRINTPROCESSOR_STRINGS
#define PRINTPROCESSOR_OFFSETS

#define MONITOR_STRINGS
#define MONITOR_OFFSETS

#define DOCINFO_STRINGS
#define DOCINFO_OFFSETS

#define DATATYPE_OFFSETS
#define DATATYPE_STRINGS

#define PROVIDOR_STRINGS

#define PRINTER_ENUM_VALUES_OFFSETS

#include <data.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles new WaitForPrinterChange implementation and:

    FindFirstPrinterChangeNotification (client and remote)
    FindNextPrinterChangeNotification
    FindClosePrinterChangeNotification

    ReplyOpenPrinter
    ReplyClosePrinter

    RouterReplyPrinter{Ex}

    RefreshPrinterChangeNotification

Author:

    Albert Ting (AlbertT) 18-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include <rpc.h>
#include <winspool.h>
#include <offsets.h>
#include "server.h"
#include "winspl.h"

BOOL
RouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent);

BOOL
RemoteFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterRemote,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions);

BOOL
RouterFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    LPDWORD pfdwChange,
    PVOID pPrinterNotifyRefresh,
    PVOID* ppPrinterNotifyInfo);

BOOL
RouterReplyPrinter(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    DWORD dwType,
    PVOID pBuffer);

BOOL
RouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PPRINTER_NOTIFY_INFO* ppInfo);


BOOL
ReplyOpenPrinter(
    DWORD dwPrinterRemote,
    PHANDLE phNotify,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer);

BOOL
ReplyClosePrinter(
    HANDLE hNotify);


DWORD
RpcRouterFindFirstPrinterChangeNotificationOld(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterLocal)

/*++

Routine Description:

    This call is only used by beta2 daytona, but we can't remove it
    since this will allow beta2 to crash daytona.  (Someday, when
    beta2 is long gone, we can reuse this slot for something else.)

Arguments:

Return Value:

--*/

{
    return ERROR_INVALID_FUNCTION;
}


//
// Old version for Daytona.
//
DWORD
RpcRemoteFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterLocal,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    

    bRet = RemoteFindFirstPrinterChangeNotification(hPrinter,
                                                    fdwFlags,
                                                    fdwOptions,
                                                    pszLocalMachine,
                                                    dwPrinterLocal,
                                                    NULL);
    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}

DWORD
RpcRemoteFindFirstPrinterChangeNotificationEx(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterLocal,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RemoteFindFirstPrinterChangeNotification(
               hPrinter,
               fdwFlags,
               fdwOptions,
               pszLocalMachine,
               dwPrinterLocal,
               (PPRINTER_NOTIFY_OPTIONS)pRpcV2NotifyOptions);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcClientFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions,
    LPDWORD pdwEvent)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterFindFirstPrinterChangeNotification(
               hPrinter,
               fdwFlags,
               fdwOptions,
               dwPID,
               (PPRINTER_NOTIFY_OPTIONS)pRpcV2NotifyOptions,
               (PHANDLE)pdwEvent);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}



DWORD
RpcFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    LPDWORD pfdwChange,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions,
    PRPC_V2_NOTIFY_INFO* ppInfo)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterFindNextPrinterChangeNotification(
               hPrinter,
               fdwFlags,
               pfdwChange,
               pRpcV2NotifyOptions,
               ppInfo);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcFindClosePrinterChangeNotification(
    HANDLE hPrinter)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = FindClosePrinterChangeNotification(hPrinter);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}




DWORD
RpcReplyOpenPrinter(
    LPWSTR pszLocalMachine,
    PHANDLE phNotify,
    DWORD dwPrinterRemote,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = ReplyOpenPrinter(dwPrinterRemote,
                            phNotify,
                            dwType,
                            cbBuffer,
                            pBuffer);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcReplyClosePrinter(
    PHANDLE phNotify)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = ReplyClosePrinter(*phNotify);

    RpcRevertToSelf();

    if (bRet) {
        *phNotify = NULL;
        return ERROR_SUCCESS;
    }
    else
        return GetLastError();
}


DWORD
RpcRouterReplyPrinter(
    HANDLE hNotify,
    DWORD fdwFlags,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterReplyPrinter(hNotify,
                              0,
                              fdwFlags,
                              NULL,
                              0,
                              NULL);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcRouterReplyPrinterEx(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    DWORD dwReplyType,
    RPC_V2_UREPLY_PRINTER Reply)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterReplyPrinter(hNotify,
                              dwColor,
                              fdwFlags,
                              pdwResult,
                              dwReplyType,
                              Reply.pInfo);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}



DWORD
RpcRouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions,
    PRPC_V2_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Updates info.

Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterRefreshPrinterChangeNotification(
               hPrinter,
               dwColor,
               (PPRINTER_NOTIFY_OPTIONS)pRpcV2NotifyOptions,
               (PPRINTER_NOTIFY_INFO*)ppInfo);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\client.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Client.h

Abstract:

    Holds Client Spooler types and prototypes

Author:


Environment:

    User Mode -Win32

Revision History:

    Steve Wilson (NT) (swilson) 1-Jun-95    Ported from spoolss\client\client.h

--*/

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;


typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    DWORD       Status;
    LONG            cThreads;   // InterlockedDecrement/Increment variable for thread synch
    HANDLE      hModule;        // Driver UM DLL Module Handle
    DWORD       (*pfnWrite)();
    HANDLE      (*pfnStartDoc)();
    VOID        (*pfnEndDoc)();
    VOID        (*pfnClose)();
    BOOL        (*pfnStartPage)();
    BOOL        (*pfnEndPage)();
    VOID        (*pfnAbort)();
    HANDLE      hDriver;        // supplied to us by driver UI dll
    DWORD       JobId;
} SPOOL;

//
// Change the RPC buffer size to 64K
//
#define BUFFER_SIZE 0x10000
#define SP_SIGNATURE    0x6767

#define SPOOL_STATUS_STARTDOC   0x00000001
#define SPOOL_STATUS_ADDJOB     0x00000002
#define SPOOL_STATUS_ANSI       0x00000004


#define SPOOL_FLAG_FFPCN_FAILED     0x1
#define SPOOL_FLAG_LAZY_CLOSE       0x2


DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
);


PNOTIFY
WPCWaitFind(
    HANDLE hFind);

BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    );

VOID
FreeSpool(
    PSPOOL pSpool);

LPVOID
DllAllocSplMem(
    DWORD cb
);


BOOL
DllFreeSplMem(
   LPVOID pMem
);

BOOL
FlushBuffer(
    PSPOOL  pSpool
);

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
);


typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
);


LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    );

LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
);

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
);

LPWSTR
StartDocDlgW(
        HANDLE hPrinter,
        DOCINFO *pDocInfo
        );

LPSTR
StartDocDlgA(
        HANDLE hPrinter,
        DOCINFOA *pDocInfo
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\perf\testsm.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    testsm.cxx

Abstract:

    Test the main perf counters.

Author:

    Albert Ting (AlbertT)  17-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <stdio.h>
#include "sharemem.hxx"

typedef struct DATA {

    INT i;
    INT j;
    INT k;
    BYTE b;

} *PDATA;

VOID
DataUp(
    PDATA pData
    );

INT
__cdecl
main(
    INT argc,
    CHAR* argv[]
    )
{
    UINT uSizeDisposition;
    PDATA pData;
    INT i,j;

    for( i=0; i< 0x1000; ++i )
    {
        TShareMem ShareMem( sizeof( DATA ),
                            TEXT( "TestData" ),
                            TShareMem::kCreate | TShareMem::kReadWrite,
                            NULL,
                            &uSizeDisposition );

        if( ShareMem.bValid( ))
        {
            printf( "uSizeDisposition = 0x%x ( 0x%x )\n",
                    uSizeDisposition,
                    sizeof( DATA ));

            for( j = 0; j< 0x200 ; ++j )
            {
                {
                    TShareMemLock<DATA> SML( ShareMem, &pData );

                    DataUp( pData );
                }
                Sleep( 10 );
            }
        }
    }

    printf( "Done.\n" );
    Sleep( INFINITE );

    return 0;
}

VOID
DataUp(
    PDATA pData
    )
{
    printf( "%x %x %x %x\n",
            pData->i++,
            pData->j++,
            pData->k++,
            pData->b++ );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\dload.h ===
#ifndef _SPLDLOAD_H_
#define _SPLDLOAD_H_

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook(
    IN UINT            unReason,
    IN PDelayLoadInfo  pDelayInfo
    );

FARPROC
LookupHandler(
    IN PDelayLoadInfo  pDelayInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\kmspool.c ===
/*++

Copyright (c) 1990-1996 Microsoft Corporation
All rights reserved

Module Name:

    kmspool.c

Abstract:

    Spooler API entry points for Kernel Clients.

Author:
    Steve Wilson (NT) (swilson) 1-Jun-95  (Ported from client\winspool.c)

Environment:

    User Mode -Win32

Revision History:
    Matthew Felton (mattfe) May-96  Driver Hooks

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddrdr.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include "server.h"
#include "client.h"
#include <change.h>
#include <winspool.h>
#include "yspool.h"
#include "kmspool.h"
#include "splr.h"

extern LPWSTR InterfaceAddress;

//
// Globals
//

#define ENTER_WAIT_LIST() EnterCriticalSection(&ThreadCriticalSection)
#define EXIT_WAIT_LIST()  LeaveCriticalSection(&ThreadCriticalSection)

LPWSTR szEnvironment = LOCAL_ENVIRONMENT;

//
//  Printer Attributes
//

#define     SPLPRINTER_USER_MODE_PRINTER_DRIVER       TEXT("SPLUserModePrinterDriver")


BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
);

BOOL
DriverEndPageHook(
    PSPOOL  pSpool
);


BOOL
DriverStartPageHook(
    PSPOOL  pSpool
);

BOOL
DriverWritePrinterHook(
    PSPOOL pSpool,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

VOID
DriverEndDocHook(
    PSPOOL pSpool
);

DWORD
DriverStartDocHook(
    PSPOOL  pSpool,
    DWORD   JobId
);

VOID
DriverClosePrinterHook(
    PSPOOL pSpool
);

VOID
DriverAbortPrinterHook(
    PSPOOL  pSpool
);



// Simple for Now !!!

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
)
{
    switch (ExceptionCode) {

    case EXCEPTION_ACCESS_VIOLATION:
    case EXCEPTION_DATATYPE_MISALIGNMENT:
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
    case EXCEPTION_INT_OVERFLOW:
    case EXCEPTION_PRIV_INSTRUCTION:
    case ERROR_NOACCESS:
    case RPC_S_INVALID_BOUND:

        return ERROR_INVALID_PARAMETER;
        break;
    default:
        return ExceptionCode;
    }
}


BOOL
KMOpenPrinterW(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    BOOL  ReturnValue;
    DEVMODE_CONTAINER    DevModeContainer;
    HANDLE  hPrinter;
    PSPOOL  pSpool;
    DWORD   dwSize = 0;

    if (pDefault && pDefault->pDevMode)
    {

        dwSize = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;
        if (dwSize) {
            DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
        } else {
            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;
        }
    }
    else
    {
        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }

    try {

        if (ReturnValue = YOpenPrinter(pPrinterName, &hPrinter,
                                         pDefault ? pDefault->pDatatype : NULL,
                                         &DevModeContainer,
                                         pDefault ? pDefault->DesiredAccess : 0,
                                         NATIVE_CALL )) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    if (ReturnValue) {

        pSpool = AllocSplMem(sizeof(SPOOL));

        if (pSpool) {

            memset(pSpool, 0, sizeof(SPOOL));
            pSpool->signature = SP_SIGNATURE;
            pSpool->hPrinter = hPrinter;
            pSpool->cThreads = -1;

            //
            // This is to fix passing a bad pHandle to OpenPrinter!!
            //
            try {
                *phPrinter = pSpool;
            } except(1) {
                YClosePrinter(&hPrinter, NATIVE_CALL);
                FreeSplMem(pSpool);
                SetLastError(TranslateExceptionCode(GetExceptionCode()));
                return FALSE;
            }

        } else {

            YClosePrinter(&hPrinter, NATIVE_CALL);
            ReturnValue = FALSE;
        }
    }

    return ReturnValue;
}


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL      ReturnValue;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }
    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pForm)
            memset(pForm, 0, cbBuf);

        if (ReturnValue = YGetForm(pSpool->hPrinter, pFormName, Level, pForm,
                                     cbBuf, pcbNeeded, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}




BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pForm)
            memset(pForm, 0, cbBuf);

        if (ReturnValue = YEnumForms(pSpool->hPrinter, Level, pForm, cbBuf,
                                     pcbNeeded, pcReturned, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    switch (Level) {

    case 1:
        pOffsets = PrinterInfo1Offsets;
        break;

    case 2:
        pOffsets = PrinterInfo2Offsets;
        break;

    case 3:
        pOffsets = PrinterInfo3Offsets;
        break;

    case 4:
        pOffsets = PrinterInfo4Offsets;
        break;

    case 5:
        pOffsets = PrinterInfo5Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (pPrinter)
        memset(pPrinter, 0, cbBuf);

    try {

        if (ReturnValue = YGetPrinter(pSpool->hPrinter, Level, pPrinter, cbBuf, pcbNeeded, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}




BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD dwServerMajorVersion;
    DWORD dwServerMinorVersion;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    if (Level < 1 || Level > 3) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pDriverInfo)
            memset(pDriverInfo, 0, cbBuf);

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = YGetPrinterDriver2(pSpool->hPrinter, pEnvironment,
                                              Level, pDriverInfo, cbBuf,
                                              pcbNeeded,
                                              (DWORD)-1, (DWORD)-1,
                                              &dwServerMajorVersion,
                                              &dwServerMinorVersion,
                                              NATIVE_CALL
                                              )) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){

        pData = (PBYTE)&ReturnValue;
    }

    try {

        ReturnValue =  YGetPrinterData(pSpool->hPrinter, pValueName, pType,
                                         pData, nSize, pcbNeeded, NATIVE_CALL);

    } except(1) {

        ReturnValue = TranslateExceptionCode(GetExceptionCode());

    }

    return ReturnValue;
}


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return ERROR_INVALID_HANDLE;
    }

    try {

        ReturnValue = YSetPrinterData(pSpool->hPrinter, pValueName, Type,
                                        pData, cbData, NATIVE_CALL);

    } except(1) {

        ReturnValue = TranslateExceptionCode(GetExceptionCode());

    }

    return ReturnValue;
}



DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL ReturnValue;
    DWORD JobId;
    GENERIC_CONTAINER DocInfoContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    try {

        if (!ValidatePrinterHandle(hPrinter)) {
            return(FALSE);
        }

        DBGMSG(DBG_TRACE,("Entered KMStartDocPrinterW side  hPrinter = %x\n", hPrinter));

        if (Level != 1) {
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        DocInfoContainer.Level = Level;
        DocInfoContainer.pData = pDocInfo;

        try {

            if (ReturnValue = YStartDocPrinter(pSpool->hPrinter,
                                       (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                       &JobId, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = JobId;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;
        }


        if (ReturnValue) {

            ReturnValue = DriverStartDocHook( pSpool, JobId );

            if ( ReturnValue )
                pSpool->Status |= SPOOL_STATUS_STARTDOC;

        }

        return ReturnValue;

    } except (1) {
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return(FALSE);
    }
}

BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    try {

        if (!ValidatePrinterHandle(hPrinter)) {
            return(FALSE);
        }

        pSpool->Status &= ~SPOOL_STATUS_STARTDOC;

        DriverEndDocHook( pSpool );

        try {

            if (ReturnValue = YEndDocPrinter(pSpool->hPrinter, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;

        }

        DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));

        return ReturnValue;
   } except (1) {
       SetLastError(ERROR_INVALID_HANDLE);
       return(FALSE);
   }
}




BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    BOOL ReturnValue = TRUE;
    PSPOOL  pSpool   = (PSPOOL)hPrinter;

    DBGMSG(DBG_TRACE, ("WritePrinter - hPrinter %x pBuf %x cbBuf %d pcWritten %x\n",
                        hPrinter, pBuf, cbBuf, pcWritten));

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    *pcWritten = 0;

    if ( !(pSpool->Status & SPOOL_STATUS_STARTDOC) ) {

        SetLastError(ERROR_SPL_NO_STARTDOC);
        return FALSE;
    }


    //
    //  Call Printer Drivers User Mode WritePrinter Hook
    //


    if ( pSpool->hDriver ) {

        return DriverWritePrinterHook( pSpool, pBuf, cbBuf, pcWritten );
    }



    try {

        if (ReturnValue = YWritePrinter(pSpool->hPrinter, (LPBYTE) pBuf, cbBuf, pcWritten, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;
            DBGMSG(DBG_WARNING, ("KMWritePrinter - YWritePrinter Failed Error %d\n",GetLastError() ));

        } else {
            ReturnValue = TRUE;
            DBGMSG(DBG_TRACE, ("KMWritePrinter - YWritePrinter Success hPrinter %x pBuffer %x cbBuffer %x cbWritten %x\n",
                                pSpool->hPrinter, (LPBYTE) pBuf, cbBuf, *pcWritten));

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
        DBGMSG(DBG_WARNING, ("YWritePrinter Exception Error %d\n",GetLastError()));

    }

    // Return the number of bytes written.

    DBGMSG(DBG_TRACE, ("KMWritePrinter cbWritten %d ReturnValue %d\n",*pcWritten, ReturnValue));

    return ReturnValue;
}


BOOL
KMStartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    try {

        ReturnValue = DriverStartPageHook( pSpool );

        if ( ReturnValue ) {

            if (ReturnValue = YStartPagePrinter(pSpool->hPrinter, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    try {

        ReturnValue = DriverEndPageHook( pSpool );

        if ( ReturnValue ) {

            if (ReturnValue = YEndPagePrinter(pSpool->hPrinter, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;
        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMAbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwNumWritten = 0;
    DWORD   dwPointer = 0;

    if (!ValidatePrinterHandle(hPrinter)){
        return(FALSE);
    }

    pSpool->Status &= ~SPOOL_STATUS_STARTDOC;


    try {

        DriverAbortPrinterHook( pSpool );

        if (ReturnValue = YAbortPrinter(pSpool->hPrinter, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMClosePrinter(
    HANDLE  hPrinter)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    HANDLE  hPrinterKM;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    try {

        DriverClosePrinterHook( pSpool );

    } except(1) {
        DBGMSG(DBG_WARNING, ("DrvClosePrinter Exception Error %d\n",TranslateExceptionCode(GetExceptionCode())));
    }

    ENTER_WAIT_LIST();

    hPrinterKM = pSpool->hPrinter;

    FreeSplMem(pSpool);

    EXIT_WAIT_LIST();


    try {

        if (ReturnValue = YClosePrinter(&hPrinterKM, NATIVE_CALL)) {

            SetLastError(ReturnValue);

            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}



BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    )
{
    PSPOOL pSpool = hPrinter;
    BOOL bReturnValue = FALSE;

    try {
        if ( pSpool && (pSpool->signature == SP_SIGNATURE)) {
            bReturnValue = TRUE;
        }
    } except (1) {
    }

    if ( !bReturnValue ) {
        SetLastError( ERROR_INVALID_HANDLE );
    }

    return bReturnValue;
}




BOOL
DriverWritePrinterHook(
    PSPOOL  pSpool,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{

    BOOL    ReturnValue;

    //  Some Printer Drivers want to push functionality out of kernel mode
    //  to achieve that we allow them to hook the calls to writeprinter from
    //  their Kernel Mode DLL to their User Mode Dll


    SPLASSERT( pSpool->hModule &&
               pSpool->pfnWrite &&
               pSpool->hDriver &&
               pSpool->hPrinter );


    try {

        ReturnValue = (*pSpool->pfnWrite)( pSpool->hDriver,
                                           pBuf,
                                           cbBuf,
                                           pcWritten );

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
        DBGMSG(DBG_ERROR, ("DrvWritePrinter Exception Error %d pSpool %x\n",GetLastError(), pSpool));
    }

    if ( !ReturnValue ) {
        SPLASSERT( GetLastError() );
    }

    return ReturnValue;
}


HANDLE
LoadPrinterDriver(
    PSPOOL  pSpool,
    PWCHAR  pUserModeDriverName
)
{
    PDRIVER_INFO_2  pDriverInfo;
    DWORD           cbNeeded;
    HANDLE          hModule = NULL;
    PWCHAR          pFileName;
    fnWinSpoolDrv   fnList; 

    if (!GetPrinterDriver(pSpool->hPrinter, NULL, 2, NULL, 0, &cbNeeded)) {

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            // Allow for the size of the string passed in.

            cbNeeded += ( wcslen( pUserModeDriverName ) + 1 )* sizeof(WCHAR);

            if (pDriverInfo = (PDRIVER_INFO_2)AllocSplMem( cbNeeded )) {

                if (GetPrinterDriver(pSpool->hPrinter, NULL, 2, (LPBYTE)pDriverInfo,
                                     cbNeeded, &cbNeeded)) {


                    //
                    //  Driver Info 2 doesn't have the fully Qualified Path
                    //  to the UserModePrinterDriver.
                    //  So form it by taking replacing the UI DLL name with the
                    //  UseModePrinterDriverName

                    pFileName = wcsrchr( pDriverInfo->pConfigFile, L'\\');
                    pFileName++;

                    wcscpy( pFileName, pUserModeDriverName );

                    pFileName = pDriverInfo->pConfigFile;

                    DBGMSG( DBG_WARNING, ("UserModeDriverPath %ws\n", pFileName ));

                    if (SplInitializeWinSpoolDrv(&fnList)) {

                        hModule = (* (fnList.pfnRefCntLoadDriver))(pFileName,
                                                                   LOAD_WITH_ALTERED_SEARCH_PATH,
                                                                   0, FALSE);
                    }

                    if ( !hModule ) {
                        DBGMSG( DBG_WARNING, ("Failed to load %ws error %d\n", pFileName, GetLastError() ));
                    }

                }
                FreeSplMem(pDriverInfo);
            }
        }
    }

    return hModule;
}



VOID
UnloadPrinterDriver(
    PSPOOL pSpool
)
{
    fnWinSpoolDrv  fnList;

    if ( pSpool->hModule ) {

        SPLASSERT( pSpool->hDriver == NULL );

        if (SplInitializeWinSpoolDrv(&fnList)) {
            (* (fnList.pfnRefCntUnloadDriver))(pSpool->hModule, TRUE);
        }

        pSpool->hModule = NULL;
        pSpool->pfnWrite = NULL;
        pSpool->pfnStartDoc = NULL;
        pSpool->pfnEndDoc = NULL;
        pSpool->pfnClose = NULL;
        pSpool->pfnStartPage = NULL;
        pSpool->pfnEndPage = NULL;
    }
}



DWORD
DriverStartDocHook(
    PSPOOL  pSpool,
    DWORD   JobId
)
{
    DWORD   dwReturn;
    WCHAR   UserModeDriverName[MAX_PATH];
    DWORD   dwNeeded;
    INT     cDriverName;
    BOOL    ReturnValue = FALSE;
    DWORD   Type = 0;


    //
    //  Determine if there is a UserMode Printer Driver
    //

    dwReturn = GetPrinterDataW( pSpool->hPrinter,
                                SPLPRINTER_USER_MODE_PRINTER_DRIVER,
                                &Type,
                                (LPBYTE)&UserModeDriverName,
                                MAX_PATH,
                                &dwNeeded );

    if ( dwReturn != ERROR_SUCCESS ) {

        SPLASSERT( dwReturn != ERROR_INSUFFICIENT_BUFFER );
        ReturnValue = TRUE;
        goto Complete;
    }

    if ( Type != REG_SZ ) {
        SPLASSERT( Type == REG_SZ );
        goto Complete;
    }

    //  No String treat as success

    cDriverName = wcslen( UserModeDriverName );
    if ( !cDriverName ) {
        ReturnValue = TRUE;
        goto Complete;
    }


    //
    //  Load the UM Driver DLL
    //

    if ( pSpool->hModule == NULL ) {

        pSpool->hModule = LoadPrinterDriver( pSpool, UserModeDriverName );

        if ( pSpool->hModule == NULL ) goto Complete;
    }


    //
    //  Get Function Pointers
    //


    //  Required
    //
    pSpool->pfnWrite = (DWORD (*)()) GetProcAddress( pSpool->hModule, "DrvSplWritePrinter" );
    pSpool->pfnStartDoc = (HANDLE (*)()) GetProcAddress( pSpool->hModule, "DrvSplStartDoc" );
    pSpool->pfnClose = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplClose" );
    pSpool->pfnEndDoc = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplEndDoc" );

    //  Optional
    //
    pSpool->pfnEndPage = (BOOL (*)()) GetProcAddress( pSpool->hModule, "DrvSplEndPage" );
    pSpool->pfnStartPage = (BOOL (*)()) GetProcAddress( pSpool->hModule, "DrvSplStartPage" );
    pSpool->pfnAbort = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplAbort" );

    if (!( pSpool->pfnWrite)    ||
        !( pSpool->pfnStartDoc) ||
        !( pSpool->pfnClose)    ||
        !( pSpool->pfnEndDoc)) {

        goto Complete;
    }


    //
    //  Ask the Driver for a Handle for this print job
    //

    SPLASSERT( pSpool->hDriver == NULL );
    SPLASSERT( pSpool->hPrinter );
    SPLASSERT( JobId );

    pSpool->hDriver = (HANDLE)(*pSpool->pfnStartDoc)( pSpool->hPrinter, JobId );

    if ( pSpool->hDriver != NULL ) {
        ReturnValue = TRUE;
    }


Complete:

    if (!ReturnValue) {

        UnloadPrinterDriver( pSpool );

        // Cancel the outstanding job
        //
        // In the direct case
        //    AbortPrinter doesn't work
        //    SetJob _CANCEL doesn't work
        //    EndDocPrinter does work

        EndDocPrinter( pSpool->hPrinter );
        JobId = 0;
    }

    pSpool->JobId = JobId;

    return  JobId;
}


VOID
DriverEndDocHook(
    PSPOOL pSpool
)
{
    if ( pSpool->hDriver ) {

        (*pSpool->pfnEndDoc)( pSpool->hDriver );
        (*pSpool->pfnClose)(pSpool->hDriver );
        pSpool->hDriver = NULL;
    }
}


BOOL
DriverStartPageHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnStartPage ){

        return (*pSpool->pfnStartPage)( pSpool->hDriver );

    } else {

        return  TRUE;
    }
}


BOOL
DriverEndPageHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnEndPage ){

        return (*pSpool->pfnEndPage)( pSpool->hDriver );

    } else {

        return  TRUE;
    }
}


VOID
DriverAbortPrinterHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnAbort )
        (*pSpool->pfnAbort)( pSpool->hDriver );
}



VOID
DriverClosePrinterHook(
    PSPOOL pSpool
)
{
    if ( pSpool->hDriver ) {

        SPLASSERT( pSpool->pfnClose );

        (*pSpool->pfnClose)(pSpool->hDriver);
        pSpool->hDriver = NULL;
    }

    UnloadPrinterDriver( pSpool );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\dload.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    dload.c

Abstract:

    Handles delay load of the router, spoolss.dll

Author:

    Steve Kiraly (SteveKi) 26-Oct-2000

Environment:

    User Mode -Win32

Revision History:

--*/
#include <windows.h>
#include <rpc.h>
#include <winspool.h>
#include <offsets.h>
#include <delayimp.h>
#include "server.h"
#include "winspl.h"
#include "dload.h"

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

FARPROC
LookupHandler(
    IN PDelayLoadInfo  pDelayInfo
    )
/*++

Routine Description:

    This routine handle finding a delay load handler when a delay load library error
    occurrs.  Currently this routine only handles failures for delay loading the router.
    The router is delay loaded for boot performance issues.  When the router cannot be loaded
    it is fatal.  Currently we simply terminate the process, it would be better to log an
    event prior to terminating but this would require event logging code which we only have in
    localspl.dll In the future we should build event logging code for all components.  Server,
    router, and all print providers.

Arguments:

    pDelayInfo - pointer to delay load information, i.e. dll name
                 procedure name etc.

Return Value:

    NULL procedure address

Note:


--*/
{
    //
    // If the router cannot be loaded or a procedure address cannot be found then
    // terminate not much else can be done, the router is a critical comonent of the
    // spooler process it must be available.
    //
    if (!_stricmp(pDelayInfo->szDll, "spoolss.dll"))
    {
#if DBG
        OutputDebugString(L"Delay load module or address not found in spoolss.dll.\n");
        DebugBreak();
#endif
        ExitProcess(-1);
    }

    return NULL;
}

FARPROC
WINAPI
DelayLoadFailureHook(
    IN UINT            unReason,
    IN PDelayLoadInfo  pDelayInfo
    )
/*++

Routine Description:

    Called when a delay loaded library or procedure address fails.

Arguments:

    unReason - reason for delay load failure
    pDelayInfo - pointer to delay load failure information

Return Value:

    The procedure or module handle

Note:


--*/
{
    FARPROC ReturnValue = NULL;

    switch(unReason)
    {
    //
    // For a failed LoadLibrary, we will return the HINSTANCE of this module.
    // This will cause the loader to try a GetProcAddress in this module for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    //
    case dliFailLoadLib:
        ReturnValue = (FARPROC)GetModuleHandle(NULL);
        break;

    //
    // Try to find an error handler for this DLL/procedure.
    //
    case dliFailGetProc:
        ReturnValue = LookupHandler(pDelayInfo);
        break;

    //
    // Unknown reason failure.
    //
    default:
        break;
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\server.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    server.h

Abstract:

    Header file for Spooler server

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#ifndef MODULE
#define MODULE "SPLSRV:"
#define MODULE_DEBUG SplsrvDebug
#endif

#include <splcom.h>

#define offsetof(type, identifier) (DWORD)(&(((type*)0)->identifier))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\kmspool.h ===
BOOL KMOpenPrinterW(LPWSTR   pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTS pDefault);

BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);


BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);
DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
);

BOOL
KMStartPagePrinter(
    HANDLE hPrinter
);

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
);

BOOL
KMClosePrinter(
    HANDLE  hPrinter);

BOOL
KMAbortPrinter(
    HANDLE  hPrinter);

VOID
FreeSpool(
    PSPOOL pSpool);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include <windows.h>
#include <rpc.h>                // rpc prototypes
#include <splcom.h>

PVOID
MIDL_user_allocate (
    IN unsigned long NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return MIDL_user_allocate1(NumBytes);
}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    MIDL_user_free1(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\rpcspool.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    rpcspool.c

Abstract:

    Spooler API entry points for RPC Clients.

Author:

    Steve Wilson (NT) (swilson) 1-Jun-1995

[Notes:]

    optional-notes

Revision History:

--*/

#include <windows.h>
#include <rpc.h>
#include <winspool.h>
#include <winsplp.h>
#include <winspl.h>
#include <offsets.h>
#include "server.h"
#include "client.h"
#include "yspool.h"


VOID
PrinterHandleRundown(
    HANDLE hPrinter);

BOOL
GetPrinterDriverExW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion);

BOOL
SpoolerInit(
    VOID);



DWORD
RpcEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned
)
{
    return YEnumPrinters(   Flags,
                            Name,
                            Level,
                            pPrinterEnum,
                            cbBuf,
                            pcbNeeded,
                            pcReturned,
                            RPC_CALL);
}

DWORD
RpcOpenPrinter(
    LPWSTR  pPrinterName,
    HANDLE *phPrinter,
    LPWSTR  pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD   AccessRequired
)
{
    return YOpenPrinter(pPrinterName,
                        phPrinter,
                        pDatatype,
                        pDevModeContainer,
                        AccessRequired,
                        RPC_CALL);
}

DWORD
RpcOpenPrinterEx(
    LPWSTR                  pPrinterName,
    HANDLE                 *phPrinter,
    LPWSTR                  pDatatype,
    LPDEVMODE_CONTAINER     pDevModeContainer,
    DWORD                   AccessRequired,
    LPSPLCLIENT_CONTAINER   pSplClientContainer
)
{
    return YOpenPrinterEx(pPrinterName,
                          phPrinter,
                          pDatatype,
                          pDevModeContainer,
                          AccessRequired,
                          RPC_CALL,
                          pSplClientContainer);
}

//
// RpcSplOpenPrinter differs from RpcOpenPrinterEx in the SPLCLIENT_CONTAINER buffer type
// It is defined as [in, out] in RpcSplOpenPrinter and just [in] in the latter
//

DWORD
RpcSplOpenPrinter(
    LPWSTR                  pPrinterName,
    HANDLE                 *phPrinter,
    LPWSTR                  pDatatype,
    LPDEVMODE_CONTAINER     pDevModeContainer,
    DWORD                   AccessRequired,
    LPSPLCLIENT_CONTAINER   pSplClientContainer
)
{
    return YOpenPrinterEx(pPrinterName,
                          phPrinter,
                          pDatatype,
                          pDevModeContainer,
                          AccessRequired,
                          RPC_CALL,
                          pSplClientContainer);
}

DWORD
RpcResetPrinter(
    HANDLE  hPrinter,
    LPWSTR  pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer
)
{
    return YResetPrinter(   hPrinter,
                            pDatatype,
                            pDevModeContainer,
                            RPC_CALL);
}

DWORD
RpcSetJob(
    HANDLE hPrinter,
    DWORD   JobId,
    JOB_CONTAINER *pJobContainer,
    DWORD   Command
    )
{
    return YSetJob( hPrinter,
                    JobId,
                    pJobContainer,
                    Command,
                    RPC_CALL);
}


DWORD
RpcGetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
   )


{
    return YGetJob( hPrinter,
                    JobId,
                    Level,
                    pJob,
                    cbBuf,
                    pcbNeeded,
                    RPC_CALL);
}

DWORD
RpcEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumJobs(   hPrinter,
                        FirstJob,
                        NoJobs,
                        Level,
                        pJob,
                        cbBuf,
                        pcbNeeded,
                        pcReturned,
                        RPC_CALL);
}

DWORD
RpcAddPrinter(
    LPWSTR  pName,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    HANDLE *phPrinter
)
{
    return YAddPrinter( pName,
                        pPrinterContainer,
                        pDevModeContainer,
                        pSecurityContainer,
                        phPrinter,
                        RPC_CALL);
}

DWORD
RpcAddPrinterEx(
    LPWSTR  pName,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    PSPLCLIENT_CONTAINER pClientContainer,
    HANDLE *phPrinter
)
{
    return YAddPrinterEx(pName,
                         pPrinterContainer,
                         pDevModeContainer,
                         pSecurityContainer,
                         phPrinter,
                         RPC_CALL,
                         pClientContainer);
}

DWORD
RpcDeletePrinter(
    HANDLE  hPrinter
)
{
    return YDeletePrinter(hPrinter, RPC_CALL);
}

DWORD
RpcAddPrinterConnection(
    LPWSTR  pName
)
{
    return YAddPrinterConnection(pName, RPC_CALL);
}

DWORD
RpcDeletePrinterConnection(
    LPWSTR  pName
)
{
    return YDeletePrinterConnection(pName, RPC_CALL);
}

DWORD
RpcSetPrinter(
    HANDLE  hPrinter,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    DWORD   Command
)
{
    return YSetPrinter(
        hPrinter,
        pPrinterContainer,
        pDevModeContainer,
        pSecurityContainer,
        Command,
        RPC_CALL);
}

DWORD
RpcGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrinter( hPrinter,
                        Level,
                        pPrinter,
                        cbBuf,
                        pcbNeeded,
                        RPC_CALL);
}

DWORD
RpcAddPrinterDriver(
    LPWSTR  pName,
    LPDRIVER_CONTAINER pDriverContainer
)
{
    return YAddPrinterDriver(   pName,
                                pDriverContainer,
                                RPC_CALL);
}

DWORD
RpcAddPrinterDriverEx(
    LPWSTR  pName,
    LPDRIVER_CONTAINER pDriverContainer,
    DWORD   dwFileCopyFlags
)
{
    return YAddPrinterDriverEx( pName,
                                pDriverContainer,
                                dwFileCopyFlags,
                                RPC_CALL);
}

DWORD
RpcAddDriverCatalog(
    HANDLE  hPrinter,
    DRIVER_INFCAT_CONTAINER *pDriverInfCatContainer,
    DWORD   dwCatalogCopyFlags
)
{
    return YAddDriverCatalog(hPrinter,
                             pDriverInfCatContainer,
                             dwCatalogCopyFlags,
                             RPC_CALL);
}

DWORD
RpcEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDrivers,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPrinterDrivers( pName,
                                pEnvironment,
                                Level,
                                pDrivers,
                                cbBuf,
                                pcbNeeded,
                                pcReturned,
                                RPC_CALL);
}

DWORD
RpcGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrinterDriver(   hPrinter,
                                pEnvironment,
                                Level,
                                pDriverInfo,
                                cbBuf,
                                pcbNeeded,
                                RPC_CALL);
}

DWORD
RpcGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrinterDriverDirectory(  pName,
                                        pEnvironment,
                                        Level,
                                        pDriverInfo,
                                        cbBuf,
                                        pcbNeeded,
                                        RPC_CALL);
}

DWORD
RpcDeletePrinterDriver(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName
)
{
    return YDeletePrinterDriver(pName,
                                pEnvironment,
                                pDriverName,
                                RPC_CALL);
}


DWORD
RpcDeletePrinterDriverEx(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName,
    DWORD   dwDeleteFlag,
    DWORD   dwVersionNum
)
{
    return YDeletePrinterDriverEx(pName,
                                 pEnvironment,
                                 pDriverName,
                                 dwDeleteFlag,
                                 dwVersionNum,
                                 RPC_CALL);
}

DWORD
RpcAddPerMachineConnection(
    LPWSTR  pServer,
    LPCWSTR  pPrinterName,
    LPCWSTR  pPrintServer,
    LPCWSTR  pProvider
)
{
    return YAddPerMachineConnection(pServer,
                                    pPrinterName,
                                    pPrintServer,
                                    pProvider,
                                    RPC_CALL);
}

DWORD
RpcDeletePerMachineConnection(
    LPWSTR  pServer,
    LPCWSTR  pPrinterName
)
{
    return YDeletePerMachineConnection(pServer,
                                       pPrinterName,
                                       RPC_CALL);
}

DWORD
RpcEnumPerMachineConnections(
    LPWSTR  pServer,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPerMachineConnections(pServer,
                                      pPrinterEnum,
                                      cbBuf,
                                      pcbNeeded,
                                      pcReturned,
                                      RPC_CALL);
}

DWORD
RpcAddPrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
)
{
    return YAddPrintProcessor(  pName,
                                pEnvironment,
                                pPathName,
                                pPrintProcessorName,
                                RPC_CALL);
}

DWORD
RpcEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPrintProcessors(pName,
                                pEnvironment,
                                Level,
                                pPrintProcessors,
                                cbBuf,
                                pcbNeeded,
                                pcReturned,
                                RPC_CALL);
}

DWORD
RpcGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrintProcessorDirectory( pName,
                                        pEnvironment,
                                        Level,
                                        pPrintProcessorInfo,
                                        cbBuf,
                                        pcbNeeded,
                                        RPC_CALL);
}

DWORD
RpcEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPrintProcessorDatatypes(pName,
                                        pPrintProcessorName,
                                        Level,
                                        pDatatypes,
                                        cbBuf,
                                        pcbNeeded,
                                        pcReturned,
                                        RPC_CALL);
}

DWORD
RpcStartDocPrinter(
    HANDLE  hPrinter,
    LPDOC_INFO_CONTAINER pDocInfoContainer,
    LPDWORD pJobId
)
{
    return YStartDocPrinter(hPrinter,
                            pDocInfoContainer,
                            pJobId,
                            RPC_CALL);
}

DWORD
RpcStartPagePrinter(
   HANDLE hPrinter
)
{
    return YStartPagePrinter(hPrinter, RPC_CALL);
}

DWORD
RpcWritePrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    return YWritePrinter(   hPrinter,
                            pBuf,
                            cbBuf,
                            pcWritten,
                            RPC_CALL);
}

DWORD
RpcSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
)
{
    return YSeekPrinter( hPrinter,
                         liDistanceToMove,
                         pliNewPointer,
                         dwMoveMethod,
                         bWritePrinter,
                         RPC_CALL );
}


DWORD
RpcEndPagePrinter(
    HANDLE  hPrinter
)
{
    return YEndPagePrinter(hPrinter, RPC_CALL);
}

DWORD
RpcAbortPrinter(
    HANDLE  hPrinter
)
{
    return YAbortPrinter(hPrinter, RPC_CALL);
}

DWORD
RpcReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pRead
)
{
    return YReadPrinter(hPrinter,
                        pBuf,
                        cbBuf,
                        pRead,
                        RPC_CALL);
}

DWORD
RpcEndDocPrinter(
    HANDLE  hPrinter
)
{
    return YEndDocPrinter(hPrinter, RPC_CALL);
}

DWORD
RpcAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pAddJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YAddJob( hPrinter,
                    Level,
                    pAddJob,
                    cbBuf,
                    pcbNeeded,
                    RPC_CALL);
}

DWORD
RpcScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
)
{
    return YScheduleJob(hPrinter,
                        JobId,
                        RPC_CALL);
}

DWORD
RpcGetPrinterData(
   HANDLE   hPrinter,
   LPTSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    return YGetPrinterData(hPrinter,
                           pValueName,
                           pType,
                           pData,
                           nSize,
                           pcbNeeded,
                           RPC_CALL);
}

DWORD
RpcGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCTSTR  pKeyName,
   LPCTSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    return YGetPrinterDataEx(hPrinter,
                           pKeyName,
                           pValueName,
                           pType,
                           pData,
                           nSize,
                           pcbNeeded,
                           RPC_CALL);
}


DWORD
RpcEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    return YEnumPrinterData(hPrinter,
                            dwIndex,
                            pValueName,
                            cbValueName,
                            pcbValueName,
                            pType,
                            pData,
                            cbData,
                            pcbData,
                            RPC_CALL);
}

DWORD
RpcEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    return YEnumPrinterDataEx(  hPrinter,
                                pKeyName,
                                pEnumValues,
                                cbEnumValues,
                                pcbEnumValues,
                                pnEnumValues,
                                RPC_CALL);
}


DWORD
RpcEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey       // address for size of value buffer
)
{
    return YEnumPrinterKey( hPrinter,
                            pKeyName,
                            pSubkey,
                            cbSubkey,
                            pcbSubkey,
                            RPC_CALL);
}


DWORD
RpcDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    return YDeletePrinterData(hPrinter, pValueName, RPC_CALL);
}


DWORD
RpcDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    return YDeletePrinterDataEx(hPrinter, pKeyName, pValueName, RPC_CALL);
}


DWORD
RpcDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    return YDeletePrinterKey(hPrinter, pKeyName, RPC_CALL);
}


DWORD
RpcSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    return YSetPrinterData( hPrinter,
                            pValueName,
                            Type,
                            pData,
                            cbData,
                            RPC_CALL);
}

DWORD
RpcSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCTSTR pKeyName,
    LPCTSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    return YSetPrinterDataEx( hPrinter,
                            pKeyName,
                            pValueName,
                            Type,
                            pData,
                            cbData,
                            RPC_CALL);
}

DWORD
RpcWaitForPrinterChange(
   HANDLE   hPrinter,
   DWORD    Flags,
   LPDWORD  pFlags
)
{
    return YWaitForPrinterChange(   hPrinter,
                                    Flags,
                                    pFlags,
                                    RPC_CALL);
}

DWORD
RpcClosePrinter(
   LPHANDLE phPrinter
)
{
    return YClosePrinter(phPrinter, RPC_CALL);
}



DWORD
RpcAddForm(
    HANDLE hPrinter,
    PFORM_CONTAINER pFormInfoContainer
)
{
    return YAddForm(    hPrinter,
                        pFormInfoContainer,
                        RPC_CALL);
}

DWORD
RpcDeleteForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName
)
{
    return YDeleteForm( hPrinter,
                        pFormName,
                        RPC_CALL);
}

DWORD
RpcGetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD Level,
    LPBYTE pForm,
    DWORD cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetForm(hPrinter,
                    pFormName,
                    Level,
                    pForm,
                    cbBuf,
                    pcbNeeded,
                    RPC_CALL);
}

DWORD
RpcSetForm(
    PRINTER_HANDLE hPrinter,
    LPWSTR  pFormName,
    PFORM_CONTAINER pFormInfoContainer
)
{
    return YSetForm(hPrinter,
                    pFormName,
                    pFormInfoContainer,
                    RPC_CALL);
}

DWORD
RpcEnumForms(
   PRINTER_HANDLE hPrinter,
   DWORD    Level,
   LPBYTE   pForm,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    return YEnumForms( hPrinter,
                       Level,
                       pForm,
                       cbBuf,
                       pcbNeeded,
                       pcReturned,
                       RPC_CALL);
}

DWORD
RpcEnumPorts(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pPort,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    return YEnumPorts( pName,
                       Level,
                       pPort,
                       cbBuf,
                       pcbNeeded,
                       pcReturned,
                       RPC_CALL);
}

DWORD
RpcEnumMonitors(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pMonitor,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    return YEnumMonitors(  pName,
                           Level,
                           pMonitor,
                           cbBuf,
                           pcbNeeded,
                           pcReturned,
                           RPC_CALL);
}

DWORD
RpcAddPort(
    LPWSTR      pName,
    ULONG_PTR   hWnd,
    LPWSTR      pMonitorName
)
{
    return YAddPort(  pName,
                      (HWND)hWnd,
                      pMonitorName,
                      RPC_CALL);
}

DWORD
RpcConfigurePort(
    LPWSTR      pName,
    ULONG_PTR   hWnd,
    LPWSTR      pPortName
)
{
    return YConfigurePort(  pName,
                            (HWND)hWnd,
                            pPortName,
                            RPC_CALL);
}

DWORD
RpcDeletePort(
    LPWSTR      pName,
    ULONG_PTR   hWnd,
    LPWSTR      pPortName
)
{
    return YDeletePort( pName,
                        (HWND)hWnd,
                        pPortName,
                        RPC_CALL);
}

DWORD
RpcXcvData(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    return YXcvData(hXcv,
                    pszDataName,
                    pInputData,
                    cbInputData,
                    pOutputData,
                    cbOutputData,
                    pcbOutputNeeded,
                    pdwStatus,
                    RPC_CALL);
}


DWORD
RpcCreatePrinterIC(
    HANDLE  hPrinter,
    HANDLE *pHandle,
    LPDEVMODE_CONTAINER pDevModeContainer
)
{
    return YCreatePrinterIC(hPrinter,
                            pHandle,
                            pDevModeContainer,
                            RPC_CALL);
}

DWORD
RpcPlayGdiScriptOnPrinterIC(
    GDI_HANDLE  hPrinterIC,
    LPBYTE pIn,
    DWORD   cIn,
    LPBYTE pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    return YPlayGdiScriptOnPrinterIC(   hPrinterIC,
                                        pIn,
                                        cIn,
                                        pOut,
                                        cOut,
                                        ul,
                                        RPC_CALL);
}

DWORD
RpcDeletePrinterIC(
    GDI_HANDLE *phPrinterIC
)
{
    return YDeletePrinterIC(phPrinterIC, 1, RPC_CALL);
}


VOID
GDI_HANDLE_rundown(
    HANDLE     hPrinterIC
)
{
    YDeletePrinterIC(&hPrinterIC, 0, RPC_CALL);
}

DWORD
RpcPrinterMessageBox(
   PRINTER_HANDLE hPrinter,
   DWORD          Error,
   ULONG_PTR      hWnd,
   LPWSTR         pText,
   LPWSTR         pCaption,
   DWORD          dwType
)
{
    return YPrinterMessageBox(hPrinter, Error, (HWND)hWnd, pText, pCaption, dwType, RPC_CALL);
}

DWORD
RpcAddMonitor(
   LPWSTR   pName,
   PMONITOR_CONTAINER pMonitorContainer
)
{
    return YAddMonitor( pName,
                        pMonitorContainer,
                        RPC_CALL);
}

DWORD
RpcDeleteMonitor(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pMonitorName
)
{
    return YDeleteMonitor( pName,
                           pEnvironment,
                           pMonitorName,
                           RPC_CALL);
}

DWORD
RpcDeletePrintProcessor(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pPrintProcessorName
)
{
    return YDeletePrintProcessor(pName,
                                 pEnvironment,
                                 pPrintProcessorName,
                                 RPC_CALL);
}

DWORD
RpcAddPrintProvidor(
   LPWSTR   pName,
   PPROVIDOR_CONTAINER pProvidorContainer
)
{
    return YAddPrintProvidor(pName, pProvidorContainer, RPC_CALL);
}

DWORD
RpcDeletePrintProvidor(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pPrintProvidorName
)
{
    return YDeletePrintProvidor(pName,
                                pEnvironment,
                                pPrintProvidorName,
                                RPC_CALL);
}


DWORD
RpcGetPrinterDriver2(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
)
{
    return YGetPrinterDriver2(hPrinter,
                              pEnvironment,
                              Level,
                              pDriverInfo,
                              cbBuf,
                              pcbNeeded,
                              dwClientMajorVersion,
                              dwClientMinorVersion,
                              pdwServerMajorVersion,
                              pdwServerMinorVersion,
                              RPC_CALL);
}

DWORD
RpcAddPortEx(
    LPWSTR pName,
    LPPORT_CONTAINER pPortContainer,
    LPPORT_VAR_CONTAINER pPortVarContainer,
    LPWSTR pMonitorName
    )
{
    return YAddPortEx(  pName,
                        pPortContainer,
                        pPortVarContainer,
                        pMonitorName,
                        RPC_CALL);
}


DWORD
RpcSpoolerInit(
    LPWSTR pName
)
{
    return YSpoolerInit(pName, RPC_CALL);
}



DWORD
RpcResetPrinterEx(
    HANDLE  hPrinter,
    LPWSTR  pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD   dwFlag

)
{
    return YResetPrinterEx( hPrinter,
                            pDatatype,
                            pDevModeContainer,
                            dwFlag,
                            RPC_CALL);
}

DWORD
RpcSetAllocFailCount(
    HANDLE  hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
)
{
    return YSetAllocFailCount(  hPrinter,
                                dwFailCount,
                                lpdwAllocCount,
                                lpdwFreeCount,
                                lpdwFailCountHit,
                                RPC_CALL);
}

DWORD
RpcSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    LPPORT_CONTAINER    pPortContainer
)
{
    return YSetPort(pName,
                    pPortName,
                    pPortContainer,
                    RPC_CALL);
}


DWORD
RpcClusterSplOpen(
    LPWSTR pszServer,
    LPWSTR pszResource,
    PHANDLE phSpooler,
    LPWSTR pszName,
    LPWSTR pszAddress
    )
{
    return YClusterSplOpen( pszServer,
                            pszResource,
                            phSpooler,
                            pszName,
                            pszAddress,
                            RPC_CALL );
}

DWORD
RpcClusterSplClose(
    PHANDLE phSpooler
    )
{
    return YClusterSplClose( phSpooler, RPC_CALL );
}

DWORD
RpcClusterSplIsAlive(
    HANDLE hSpooler
    )
{
    return YClusterSplIsAlive( hSpooler, RPC_CALL );
}

DWORD
RpcGetSpoolFileInfo(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    return YGetSpoolFileInfo(hPrinter, dwAppProcessId,
                             dwLevel, pSpoolFileInfo,
                             cbBuf, pcbNeeded, RPC_CALL);
}

DWORD
RpcGetSpoolFileInfo2(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   dwLevel,
    LPFILE_INFO_CONTAINER  pSplFileInfoContainer
    )
{
    return YGetSpoolFileInfo2(hPrinter, dwAppProcessId,
                             dwLevel, pSplFileInfoContainer,
                             RPC_CALL);
}


DWORD
RpcCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    return YCommitSpoolData(hPrinter, dwAppProcessId, cbCommit,
                            dwLevel, pSpoolFileInfo, cbBuf, pcbNeeded, RPC_CALL);
}

DWORD
RpcCommitSpoolData2(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPFILE_INFO_CONTAINER  pSplFileInfoContainer)
{
    return YCommitSpoolData2(hPrinter, dwAppProcessId, cbCommit,
                             dwLevel, pSplFileInfoContainer, RPC_CALL);
}



DWORD
RpcCloseSpoolFileHandle(
    HANDLE hPrinter)
{
    return YCloseSpoolFileHandle(hPrinter, RPC_CALL);
}

DWORD
RpcFlushPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)
{
    return YFlushPrinter( hPrinter,
                          pBuf,
                          cbBuf,
                          pcWritten,
                          cSleep,
                          RPC_CALL);
}

DWORD
RpcSendRecvBidiData(
    IN  HANDLE  hPrinter,
    IN  LPCWSTR pAction,
    IN  PRPC_BIDI_REQUEST_CONTAINER   pReqData,
    OUT PRPC_BIDI_RESPONSE_CONTAINER* ppRespData
)
{
    return ( YSendRecvBidiData(hPrinter,
                               pAction,
                               (PBIDI_REQUEST_CONTAINER)pReqData,
                               (PBIDI_RESPONSE_CONTAINER*)ppRespData,
                               RPC_CALL) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\spldata.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    spldata.c

Abstract:

    Spooler Service Global Data.


Author:

    Krishna Ganugapati (KrishnaG) 17-Oct-1993

Environment:

    User Mode - Win32

Notes:

    optional-notes

Revision History:

    17-October-1993     KrishnaG
        created.


--*/

#include <windows.h>
#include <rpc.h>
#include <lmsname.h>

#include "server.h"
#include "splsvr.h"

CRITICAL_SECTION ThreadCriticalSection;
SERVICE_STATUS_HANDLE SpoolerStatusHandle;
DWORD SpoolerState;

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

SERVICE_TABLE_ENTRY SpoolerServiceDispatchTable[] = {
    { SERVICE_SPOOLER,        SPOOLER_main      },
    { NULL,                   NULL              }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splctrlh.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    splctrlh.c

Abstract:

    The Spooler Service Control Handling routine. This file contains
    the following functions.

        SpoolerCtrlHandler

Author:

    Krishna Ganugapati      12-Oct-1993

Environment:

    User Mode -Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

    12-Oct-1993     krishnaG

--*/

//
// Includes
//



#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsvc.h> //SERVICE_STOP

#include <rpc.h>
#include "splsvr.h"
#include "splr.h"
#include "server.h"
#include "client.h"
#include "kmspool.h"

extern DWORD dwCallExitProcessOnShutdown;
DWORD
SpoolerCtrlHandler(
    IN  DWORD                   opcode,
    IN  DWORD                   dwEventType,
    IN  PVOID                   pEventData,
    IN  PVOID                   pData
    )

/*++

Routine Description:

    This function receives control requests that come in from the
    Service Controller

Arguments:

    opcode - This is the control code.

Return Value:



--*/

{
    DWORD  dwStatus = NO_ERROR;

    DBGMSG(DBG_TRACE,("Control Request Received\n"));

    switch (opcode) {
    case SERVICE_CONTROL_STOP:
            //
            //
            // When process dies the handle is automatically closed,
            // so no need to keep it.
            //
            (VOID) CreateEvent(NULL, TRUE, TRUE, szSpoolerExitingEvent);
    case SERVICE_CONTROL_SHUTDOWN:

        DBGMSG(DBG_TRACE, ("Control Request = STOP or SHUTDOWN\n"));

        //
        // Start the de-installation.  This call includes the sending of
        // the new status to the Service Controller.
        //

        //
        // Update the Service Status to the pending state.  And wake up
        // all threads so they will read it.
        //

        SpoolerShutdown();
        SetEvent(TerminateEvent);
        

        if ( dwCallExitProcessOnShutdown &&
             opcode == SERVICE_CONTROL_SHUTDOWN ) {

            ExitProcess(0);
        }
        break;


    case SERVICE_CONTROL_INTERROGATE:
        DBGMSG(DBG_TRACE, ("Control Request = INTERROGATE\n"));

        //
        // Send back an UPDATE_ONLY status.
        //

        SpoolerStatusUpdate(UPDATE_ONLY);
        break;

    case SERVICE_CONTROL_DEVICEEVENT:
        dwStatus = SplProcessPnPEvent(dwEventType, pEventData, pData);
        break;

#if 0
    case SERVICE_CONTROL_SYSTEM_IDLE:
        
        //
        // This message from the SCM allows the spooler to complete it's
        // second phase initialization.
        //
        SplStartPhase2Init();
        break;
        
#endif

    case SERVICE_CONTROL_POWEREVENT:

        //
        // If the spooler does not allow the system to be powered down, then
        // we can indicate that by returning any Win32 error.
        //
        dwStatus = SplPowerEvent(dwEventType) ? NO_ERROR : ERROR_INVALID_FUNCTION;
        break;

    default:

        DBGMSG(DBG_TRACE, ("Control Request = OTHER\n"));
        SpoolerStatusUpdate(UPDATE_ONLY);
        dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
        break;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splr.h ===
/*++

Copyright (c) 1106990  Microsoft Corporation

Module Name:

    splr.h

Abstract:

    Header file for Spooler Service.

Author:

    Krishna Ganugapati (KrishnaG) 18-Oct-1993

Notes:

Revision History:


--*/

#include <lmerr.h>
#include <lmcons.h>

extern CRITICAL_SECTION ThreadCriticalSection;


extern SERVICE_STATUS_HANDLE SpoolerStatusHandle;



extern RPC_IF_HANDLE winspool_ServerIfHandle;


extern DWORD SpoolerState;


extern SERVICE_TABLE_ENTRY SpoolerServiceDispatchTable[];

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splmain.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    splmain.c

Abstract:

    This is the main routine for the Windows NT Spooler Service.
    Functions in the file include:

        SPOOLER_main

Author:

    Krishna Ganugapati      (KrishnaG)  12-Oct-1993

Environment:

    User Mode - Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

    12-Oct-1993     krishnaG
    Created

--*/

//
// INCLUDES
//


#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <rpc.h>
#include "splsvr.h"
#include "splr.h"
#include "server.h"

HANDLE TerminateEvent = NULL;                             

VOID
SPOOLER_main (
    IN DWORD    argc,
    IN LPTSTR   *argv
    )

/*++

Routine Description:

    This is the main routine for the Spooler Service

Arguments:


Return Value:

    None.

Note:


--*/
{
    if(TerminateEvent = CreateEvent (0, TRUE, FALSE,0))
    {

        SpoolerState = SpoolerInitializeSpooler(argc, argv);
    
        if (SpoolerState != RUNNING) {
    
            DBGMSG(DBG_WARN,("Spooler Shutdown during initialization\n"));
        }
    
    
        if (SpoolerState == STOPPING) {
            SpoolerShutdown();
        }
    
        DBGMSG(DBG_TRACE,("SPOOLER_main: Exiting Spooler Thread\n"));

        WaitForSingleObject(TerminateEvent,INFINITE);
        CloseHandle(TerminateEvent);

        if(hPhase2Init)
        {
            CloseHandle(hPhase2Init);
        }
        SpoolerStatusUpdate (STOPPED);
    }
    else
    {
        DBGMSG(DBG_WARN,("Spooler unable to create Terminate event"));
    }

    ExitThread(0);
    return;
}





VOID
SpoolerShutdown(VOID)

/*++

Routine Description:


Arguments:

    none

Return Value:

    none

--*/

{
    DBGMSG(DBG_TRACE,(" in SpoolerShutdown\n",0));

    // *** SHUTDOWN HINT ***

    SpoolerStatusUpdate (STOPPING);

    //
    // Shut down the router.
    //

    DBGMSG(DBG_TRACE,("SpoolerShutdown: Shut down router\n"));

    SplShutDownRouter();


    //
    // Shut down the RPC interface.
    //

    DBGMSG(DBG_TRACE,("SpoolerShutdown: Shut down RPC server\n"));

    // SpoolerStopRpcServer( /*nspool_ServerIfHandle*/ );

    // *** SHUTDOWN HINT ***

    // SpoolerStatusUpdate (STOPPING);

    //
    // If we've come here, then we've stopped accepting RPC calls
    //

    DBGMSG(DBG_TRACE, ("SpoolerShutdown: We've serviced all pending requests\n"));

    //
    // Shut down the Spooler


    DBGMSG(DBG_TRACE,("SpoolerShutdown: Done with shutdown\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splrpc.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    splrpc.c

Abstract:

    This file contains routines for starting and stopping RPC servers.

        SpoolerStartRpcServer
        SpoolerStopRpcServer

Author:

    Krishna Ganugapati  krishnaG

Environment:

    User Mode - Win32

Revision History:


    14-Oct-1993 KrishnaG
        Created
    25-May-1999 khaleds
    Added:
    CreateNamedPipeSecurityDescriptor
    BuildNamedPipeProtection
--*/

//
// INCLUDES
//

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <rpc.h>

#include "splsvr.h"
#include "splr.h"
#include "server.h"
#ifndef _SRVRMEM_H_
#include "srvrmem.h"
#endif

WCHAR szSerializeRpc []= L"SerializeRpc";
WCHAR szCallExitProcessOnShutdown []= L"CallExitProcessOnShutdown";
WCHAR szMaxRpcSize []= L"MaxRpcSize";
WCHAR szPrintKey[] = L"System\\CurrentControlSet\\Control\\Print";

#define DEFAULT_MAX_RPC_SIZE    1024*1024   // default maximum rpc data block size in bytes
DWORD dwCallExitProcessOnShutdown = TRUE;

RPC_STATUS
SpoolerStartRpcServer(
    VOID)
/*++

Routine Description:


Arguments:



Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    unsigned char * InterfaceAddress;
    RPC_STATUS status;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    BOOL                Bool;

    HKEY hKey;
    DWORD cbData;
    DWORD dwSerializeRpc = 0;
    DWORD dwType;
    DWORD dwMaxRpcSize;

    InterfaceAddress = "\\pipe\\spoolss";

    // Croft up a security descriptor that will grant everyone
    // all access to the object (basically, no security)
    //
    // We do this by putting in a NULL Dacl.
    //
    // NOTE: rpc should copy the security descriptor,
    // Since it currently doesn't, simply allocate it for now and
    // leave it around forever.
    //


    SecurityDescriptor = CreateNamedPipeSecurityDescriptor();
    if (SecurityDescriptor == 0) {
        DBGMSG(DBG_ERROR, ("Spoolss: out of memory\n"));
        return FALSE;
    }


    //
    // For now, ignore the second argument.
    //

    status = RpcServerUseProtseqEpA("ncacn_np", 10, InterfaceAddress, SecurityDescriptor);

    if (status) {
        DBGMSG(DBG_WARN, ("RpcServerUseProtseqEpA 1 = %u\n",status));
        return FALSE;
    }

    //
    // For now, ignore the second argument.
    //

    status = RpcServerUseProtseqEpA("ncalrpc", 10, "spoolss", SecurityDescriptor);

    if (status) {
        DBGMSG(DBG_WARN, ("RpcServerUseProtseqEpA 2 = %u\n",status));
        return FALSE;
    }

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szPrintKey,
                      0,
                      KEY_READ,
                      &hKey)) {


        //
        // Ignore failure case since we can use the default
        //
        cbData = sizeof(dwSerializeRpc);
        RegQueryValueEx(hKey,
                        szSerializeRpc,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwSerializeRpc,
                        &cbData);


        //
        // This value can be used to control if spooler controls ExitProcess
        // on shutdown
        //
        cbData = sizeof(dwCallExitProcessOnShutdown);
        RegQueryValueEx(hKey,
                        szCallExitProcessOnShutdown,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwCallExitProcessOnShutdown,
                        &cbData);


        //
        // dwMaxRpcSize specifies the maximum size in bytes of incoming RPC data blocks.
        // 
        cbData = sizeof(dwMaxRpcSize);
        if (RegQueryValueEx(hKey,
                        szMaxRpcSize,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwMaxRpcSize,
                        &cbData) != ERROR_SUCCESS) {
            dwMaxRpcSize = DEFAULT_MAX_RPC_SIZE;
        }

        RegCloseKey(hKey);
    }


    //
    // Now we need to add the interface.  We can just use the winspool_ServerIfHandle
    // specified by the MIDL compiler in the stubs (winspl_s.c).
    //
    status = RpcServerRegisterIf2(  winspool_ServerIfHandle, 
                                    0, 
                                    0,
                                    0,
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                    dwMaxRpcSize,
                                    NULL
                                    );

    if (status) {
        DBGMSG(DBG_WARN, ("RpcServerRegisterIf = %u\n",status));
        return FALSE;
    }


    if (dwSerializeRpc) {

        // By default, rpc will serialize access to context handles.  Since
        // the spooler needs to be able to have two threads access a context
        // handle at once, and it knows what it is doing, we will tell rpc
        // not to serialize access to context handles.

        I_RpcSsDontSerializeContext();
    }

    status = RpcMgmtSetServerStackSize(INITIAL_STACK_COMMIT);

    if (status != RPC_S_OK) {
        DBGMSG(DBG_ERROR, ("Spoolss : RpcMgmtSetServerStackSize = %d\n", status));
    }

    // The first argument specifies the minimum number of threads to
    // create to handle calls; the second argument specifies the maximum
    // concurrent calls to handle.  The third argument indicates that
    // the routine should not wait.

    status = RpcServerListen(1,SPL_MAX_RPC_CALLS,1); 

    if ( status != RPC_S_OK ) {
         DBGMSG(DBG_ERROR, ("Spoolss : RpcServerListen = %d\n", status));
    }

    return (status);
}


#define MAX_ACE 7
#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

/*++
    Routine Description:
        This routine adds prepares the required masks and flags required for the 
        DACL on the named pipes used by RPC
    
    Arguments:
        None
        
    Return Value:
        An allocated Security Descriptor        

--*/

PSECURITY_DESCRIPTOR
CreateNamedPipeSecurityDescriptor(
    VOID
    )
{
    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];          
    BYTE InheritFlags[MAX_ACE];   
    DWORD AceCount;
    PSECURITY_DESCRIPTOR ServerSD = NULL;
    
    //
    // For Code optimization we replace 5 individaul 
    // SID_IDENTIFIER_AUTHORITY with an array of 
    // SID_IDENTIFIER_AUTHORITYs
    // where
    // SidAuthority[0] = UserSidAuthority   
    // SidAuthority[1] = PowerSidAuthority  
    // SidAuthority[2] = EveryOneSidAuthority
    // SidAuthority[3] = CreatorSidAuthority
    // SidAuthority[4] = SystemSidAuthority 
    // SidAuthority[5] = AdminSidAuthority  
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority[MAX_ACE] = {
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_WORLD_SID_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_CREATOR_SID_AUTHORITY, 
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_NT_AUTHORITY           
                                                     };
    //
    // For code optimization we replace 6 individual Sids with 
    // an array of Sids; On Whistler,  Anonymous user will no longer 
    // be granted access to resources whose ACLs grant access to Everyone.
    //
    // We need to give access to Anonymous user to access the RPC pipe 
    // for the reverse RPC connection when RPC calls could come as 
    // Anonymous from either NT4 machines, Whistler Personal or Whitler
    // across domains.
    // 
    // Sid[0] = UserSid
    // Sid[1] = PowerSid
    // Sid[2] = EveryOne
    // Sid[3] = Anonymous
    // Sid[4] = CreatorSid
    // Sid[5] = SystemSid
    // Sid[6] = AdminSid
    //
    PSID Sids[MAX_ACE] = {NULL,NULL,NULL,NULL,NULL};

    ACCESS_MASK AceMask[MAX_ACE] = { 
                                     FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE ,
                                     FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE ,
                                     (FILE_GENERIC_READ | FILE_WRITE_DATA | FILE_ALL_ACCESS) & 
                                     ~WRITE_DAC &~WRITE_OWNER & ~DELETE & ~FILE_CREATE_PIPE_INSTANCE,
                                     (FILE_GENERIC_READ | FILE_WRITE_DATA | FILE_ALL_ACCESS) & 
                                     ~WRITE_DAC &~WRITE_OWNER & ~DELETE & ~FILE_CREATE_PIPE_INSTANCE,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS
                                   };

    DWORD SubAuthorities[3*MAX_ACE] = { 
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_USERS ,  
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_POWER_USERS ,
                                       1 , SECURITY_WORLD_RID          , 0 ,
                                       1 , SECURITY_ANONYMOUS_LOGON_RID , 0 ,
                                       1 , SECURITY_CREATOR_OWNER_RID  , 0 ,
                                       1 , SECURITY_LOCAL_SYSTEM_RID   , 0 ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_ADMINS
                                      };
    //
    // Name Pipe SD
    //

    for(AceCount = 0;
        ( (AceCount < MAX_ACE) &&
          AllocateAndInitializeSid(&SidAuthority[AceCount],
                                   (BYTE)SubAuthorities[AceCount*3],
                                   SubAuthorities[AceCount*3+1],
                                   SubAuthorities[AceCount*3+2],
                                   0, 0, 0, 0, 0, 0,
                                   &Sids[AceCount]));
        AceCount++)
    {
        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = Sids[AceCount];
        InheritFlags[AceCount]     = 0;
    }

    if(AceCount == MAX_ACE)
    {
        if(!BuildNamedPipeProtection( AceType,
                                      AceCount,
                                      AceSid,
                                      AceMask,
                                      InheritFlags,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &ServerSD ) )
        {
            DBGMSG( DBG_WARNING,( "Couldn't buidl Named Pipe protection" ) );        
        }
    }
    else
    {
        DBGMSG( DBG_WARNING,( "Couldn't Allocate and initialize SIDs" ) );        
    }

    for(AceCount=0;AceCount<MAX_ACE;AceCount++)
    {
        if(Sids[AceCount])
            FreeSid( Sids[AceCount] );
    }
    return ServerSD;
}


BOOL
BuildNamedPipeProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the print manager objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity)



Arguments:

    AceType - Array of AceTypes.
              Must be ACCESS_ALLOWED_ACE_TYPE or ACCESS_DENIED_ACE_TYPE.

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    InheritFlags - Pointer to an array of inherit flags.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.

    OwnerSid - The SID of the owner to be assigned to the descriptor.

    GroupSid - The SID of the group to be assigned to the descriptor.

    GenericMap - Points to a generic mapping for the target object type.

    ppSecurityDescriptor - Receives a pointer to the security descriptor.
        This will be allcated from the process' heap, not the spooler's,
        and should therefore be freed with LocalFree().


    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor

Return Value:

    TBS.

--*/
{


    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative = NULL;
    PACL                    TmpAcl= NULL;
    PACCESS_ALLOWED_ACE     TmpAce;
    DWORD                   SDLength;
    DWORD                   DaclLength;
    DWORD                   i;
    BOOL                    OK;

    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //

    OK = InitializeSecurityDescriptor( &Absolute,
                                       SECURITY_DESCRIPTOR_REVISION1 );

    DBGCHK( !OK, ( "Failed to initialize security descriptor.  Error %d", GetLastError() ) );

    //
    // Owner
    //

    OK = SetSecurityDescriptorOwner( &Absolute, OwnerSid, FALSE );

    DBGCHK( !OK, ( "Failed to set security descriptor owner.  Error %d", GetLastError() ) );


    //
    // Group
    //

    OK = SetSecurityDescriptorGroup( &Absolute, GroupSid, FALSE );

    DBGCHK( !OK, ( "Failed to set security descriptor group.  Error %d", GetLastError() ) );




    //
    // Discretionary ACL
    //
    //      Calculate its length,
    //      Allocate it,
    //      Initialize it,
    //      Add each ACE
    //      Set ACE as InheritOnly if necessary
    //      Add it to the security descriptor
    //

    DaclLength = (DWORD)sizeof(ACL);
    for (i=0; i<AceCount; i++) {

        DaclLength += GetLengthSid( AceSid[i] ) +
                      (DWORD)sizeof(ACCESS_ALLOWED_ACE) -
                      (DWORD)sizeof(DWORD);  //Subtract out SidStart field length
    }

    TmpAcl = SrvrAllocSplMem( DaclLength );

    if (!TmpAcl) {
        DBGCHK( !TmpAcl, ( "Out of heap space: Can't allocate ACL." ) );
        *ppSecurityDescriptor = NULL;
        return(FALSE);
    }

    OK = InitializeAcl( TmpAcl, DaclLength, ACL_REVISION2 );

    DBGCHK( !OK, ( "Failed to set initialize ACL.  Error %d", GetLastError() ) );

    for (i=0; i<AceCount; i++)
    {
        if( AceType[i] == ACCESS_ALLOWED_ACE_TYPE )
            OK = AddAccessAllowedAce ( TmpAcl, ACL_REVISION2, AceMask[i], AceSid[i] );
        else
            OK = AddAccessDeniedAce ( TmpAcl, ACL_REVISION2, AceMask[i], AceSid[i] );

        DBGCHK( !OK, ( "Failed to add access-allowed ACE.  Error %d", GetLastError() ) );

        if (InheritFlags[i] != 0)
        {
            OK = GetAce( TmpAcl, i, (LPVOID *)&TmpAce );
            DBGCHK( !OK, ( "Failed to get ACE.  Error %d", GetLastError() ) );

            TmpAce->Header.AceFlags = InheritFlags[i];
        }
    }

    OK = SetSecurityDescriptorDacl (&Absolute, TRUE, TmpAcl, FALSE );
    DBGCHK( !OK, ( "Failed to set security descriptor DACL.  Error %d", GetLastError() ) );



    //
    // Convert the Security Descriptor to Self-Relative
    //
    //      Get the length needed
    //      Allocate that much memory
    //      Copy it
    //      Free the generated absolute ACLs
    //

    SDLength = GetSecurityDescriptorLength( &Absolute );

    Relative = LocalAlloc( 0, SDLength );

    if (!Relative) {
        DBGCHK( !Relative, ( "Out of heap space: Can't allocate security descriptor" ) );
        goto Fail;
    }



    OK = MakeSelfRelativeSD(&Absolute, Relative, &SDLength );

    if (!OK) {
        DBGCHK( !OK, ( "Failed to create self-relative security descriptor DACL.  Error %d", GetLastError() ) );
        goto Fail;
    }

    SrvrFreeSplMem( TmpAcl );
    *ppSecurityDescriptor = Relative;
    return( OK );


Fail:

    if (TmpAcl){
        FreeSplMem(TmpAcl);
    }

    if (Relative) {
        LocalFree(Relative);
    }
    *ppSecurityDescriptor = NULL;
    return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splinit.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    splinit.c

Abstract:

    Spooler Service Initialization Routines.
    The following is a list of functions in this file:

        SpoolerInitializeSpooler

Author:

    Krishna Ganugapati (KrishnaG) 17-Oct-1993

Environment:

    User Mode - Win32

Notes:

    optional-notes

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss
     
    17-October-1993     KrishnaG
    Created.


--*/
//
// Includes
//

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <rpc.h>
#include "splsvr.h"
#include "splr.h"
#include "server.h"
#include "client.h"
#include "kmspool.h"

#include <winsvc.h>     // Service control APIs
#include <lmsname.h>
#include <rpc.h>        // DataTypes and runtime APIs


DWORD MessageThreadId;     // message thread ID

extern DWORD GetSpoolMessages(VOID);

HANDLE hPhase2Init = NULL;

//
// Following is to make sure only one spooler process runs at a time.
// When spooler is asked to stop it will tell SCM SERVICE_STOPPED but it may
// be some more time before the spoolsv process dies.
// In the meantime if a SCM starts another spooler process it will not
// initialize. This is because GDI assumes one spooler process at a time.
//
// To fix when spooler is asked to stop it creates a named event Spooler_exiting
// The handle to which will be closed when the process dies.
//
// On spooler startup we will look for this event and wait for it to go away.
// A named event goes away when the last handle is closed.
// 
// 
WCHAR   szSpoolerExitingEvent[] = L"Spooler_exiting";

#define WAITFOR_SPOOLEREXIT_TIMEOUT     3*1000

BOOL
PreInitializeRouter(
    SERVICE_STATUS_HANDLE SpoolerStatusHandle
);

DWORD
SpoolerInitializeSpooler(
    DWORD   argc,
    LPTSTR  *argv
    )

/*++

Routine Description:

    Registers the control handler with the dispatcher thread.  Then it
    performs all initialization including the starting of the RPC server.
    If any of the initialization fails, SpoolerStatusUpdate is called so that the
    status is updated and the thread is terminated.

Arguments:



Return Value:



--*/

{
    RPC_STATUS          rpcStatus;
    DWORD               Win32status;
    HANDLE              hThread, hEvent;
    DWORD               ThreadId;

    //
    // Initialize the ThreadCritical Section which serializes access to
    // the Status database.
    //

    InitializeCriticalSection(&ThreadCriticalSection);

    //
    // Initialize the status structure
    //

    SpoolerStatusInit();

    //
    // Register this service with the ControlHandler.
    // Now we can accept control requests and be requested to UNINSTALL.
    //

    DBGMSG(DBG_TRACE, ("Calling RegisterServiceCtrlHandler\n"));
    if ((SpoolerStatusHandle = RegisterServiceCtrlHandlerEx(
                                SERVICE_SPOOLER,
                                SpoolerCtrlHandler,
                                NULL
                                )) == (SERVICE_STATUS_HANDLE)ERROR_SUCCESS) {

        Win32status = GetLastError();

        DBGMSG(DBG_ERROR,
            ("FAILURE: RegisterServiceCtrlHandler status = %d\n", Win32status));

        return( SpoolerBeginForcedShutdown (
                    IMMEDIATE,
                    Win32status,
                    (DWORD)0
                    ));
    }


    //
    // Notify that installation is pending
    //

    SpoolerState = SpoolerStatusUpdate(STARTING);

    if (SpoolerState != STARTING) {

        //
        // An UNINSTALL control request must have been received
        //
        return(SpoolerState);
    }

    //
    // If there is another spooler process exiting wait for it to die
    // Look at comments in splctrlh.c
    //
    for ( ; ; ) {

        hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, szSpoolerExitingEvent);
        if ( hEvent == NULL )
            break;

        DBGMSG(DBG_WARNING, ("Waiting for previous spooler to exit\n"));
        CloseHandle(hEvent);
        SpoolerState = SpoolerStatusUpdate(STARTING);

        if (SpoolerState != STARTING) {

            //
            // An UNINSTALL control request must have been received
            //
            return(SpoolerState);
        }

        Sleep(WAITFOR_SPOOLEREXIT_TIMEOUT);
    }

    hPhase2Init = CreateEvent( NULL, TRUE, FALSE, L"RouterPreInitEvent" );

    if (hPhase2Init == NULL)
    {
        //
        // Fail if the event is not created
        //
        DBGMSG(DBG_ERROR, ("Failed to create Phase2Init Event, error %d\n", GetLastError()));
        ExitProcess(0);
    }

    DBGMSG(DBG_TRACE,
        ("SpoolerInitializeSpooler:getting ready to start RPC server\n"));

    rpcStatus = SpoolerStartRpcServer();


    if (rpcStatus != RPC_S_OK) {
        DBGMSG(DBG_WARN, ("RPC Initialization Failed %d\n", rpcStatus));
        return (SpoolerBeginForcedShutdown(
                PENDING,
                rpcStatus,
                (DWORD)0
                ));
    }

    SpoolerStatusUpdate(STARTING);


    DBGMSG(DBG_TRACE,
          ("SpoolerInitializeSpooler:Getting ready to kick off the Router\n"));


    hThread = CreateThread(NULL,
                           LARGE_INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE)PreInitializeRouter,
                           (LPVOID)SpoolerStatusHandle,
                           0,
                           &ThreadId);

    if( hThread ){

        CloseHandle(hThread);

        //
        // Create Kernel Spooler Message Thread
        //
        Win32status=GetSpoolMessages();

    } else {

        Win32status = GetLastError();
    }


    if (Win32status != ERROR_SUCCESS) {
        DBGMSG(DBG_WARNING, ("Kernel Spooler Messaging Initialization Failed %d\n", Win32status));
        return SpoolerBeginForcedShutdown(PENDING, Win32status, (DWORD) 0);
    }


    //
    //  Update the status to indicate that installation is complete.
    //  Get the current state back in case the ControlHandling thread has
    //  told us to shutdown.
    //

    DBGMSG(DBG_TRACE, ("Exiting SpoolerInitializeSpooler - Init Done!\n"));

    return (SpoolerStatusUpdate(RUNNING));
}

BOOL
PreInitializeRouter(
    SERVICE_STATUS_HANDLE SpoolerStatusHandle
)
{
    HANDLE              hThread;
    DWORD               ThreadId;
    SECURITY_ATTRIBUTES Sa;
    SECURITY_DESCRIPTOR Sd;
    
    //
    // Wait on hPhase2Init
    //
    WaitForSingleObject( hPhase2Init, SPOOLER_START_PHASE_TWO_INIT );
    hThread = CreateThread(NULL,
                           LARGE_INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE) InitializeRouter,
                           (LPVOID)SpoolerStatusHandle,
                           0,
                           &ThreadId);

    if( hThread )
    {
        CloseHandle(hThread);
    }
    return(hThread?TRUE:FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\spoolss.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    splsvc.c

Abstract:

    This is the main routine for the Spooler Service.

Author:

    Krishna Ganugapati (KrishnaG)    17-October-1992

Environment:

    User Mode - Win32

Revision History:

    17-Oct-1993         KrishnaG
        created

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>

#include "server.h"
#include "splsvr.h"
#include "splr.h"

void __cdecl
main (
    int argc,
    unsigned char * argv[]
    )

/*++

Routine Description:

    This is a main routine for the Windows NT Spooler Services.

    It basically sets up the ControlDispatcher and, on return, exits from
    this main thread. The call to NetServiceStartCtrlDispatcher does
    not return until all services have terminated, and this process can
    go away.

    It will be up to the ControlDispatcher thread to start/stop/pause/continue
    any services. If a service is to be started, it will create a thread
    and then call the main routine of that service.


Arguments:

    Anything passed in from the "command line". Currently, NOTHING.

Return Value:

    NONE

Note:


--*/
{
#if DBG
    //
    // Debugging: if started with "ns" then don't start as service.
    //

    if (argc == 2 && !lstrcmpiA("ns", argv[1])) {

        SpoolerStartRpcServer();
        InitializeRouter((SERVICE_STATUS_HANDLE)0);

        return;
    }
#endif


    //
    // Call NetServiceStartCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (SpoolerServiceDispatchTable)) {

        //
        // It would be good to also log an Event here.
        //
        DBGMSG(DBG_ERROR, ("Fail to start control dispatcher %lu\n",GetLastError()));
    }


    ExitProcess(0);

    DBG_UNREFERENCED_PARAMETER( argc );
    DBG_UNREFERENCED_PARAMETER( argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splstat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    splstat.c

Abstract:

    Routines for managing access to the status information and reporting:

        SpoolerStatusInit
        SpoolerBeginForcedShutdown
        SpoolerStatusUpdate
        GetSpoolerState

Author:

    Krishna Ganugapati (KrishnaG)     17-Oct-1993

Environment:

    User Mode -Win32

Notes:


Revision History:

    17-Oct-1993     KrishnaG
        created

--*/
//
// Includes
//
#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <rpc.h>
#include <winsvc.h>     // Service control APIs
#include <lmsname.h>

#include "splsvr.h"
#include "splr.h"
#include "server.h"

// Static Data
//

    static DWORD            Next;
    static DWORD            InstallState;
    static SERVICE_STATUS   SpoolerStatus;
    static DWORD            HintCount;
    static DWORD            SpoolerUninstallCode;  // reason for uninstalling


VOID
SpoolerStatusInit(VOID)

/*++

Routine Description:

    Initializes the status database.

Arguments:

    none.

Return Value:

    none.

Note:


--*/
{
    EnterCriticalSection(&ThreadCriticalSection);

    SpoolerState=STARTING;

    HintCount = 1;
    SpoolerUninstallCode = 0;

    SpoolerStatus.dwServiceType        = SERVICE_WIN32;
    SpoolerStatus.dwCurrentState       = SERVICE_START_PENDING;
    SpoolerStatus.dwControlsAccepted   = 0;
    SpoolerStatus.dwCheckPoint         = HintCount;
    SpoolerStatus.dwWaitHint           = 20000;  // 20 seconds
    SpoolerStatus.dwWin32ExitCode      = NO_ERROR;
    SpoolerStatus.dwServiceSpecificExitCode = NO_ERROR;

    LeaveCriticalSection(&ThreadCriticalSection);
    return;
}

DWORD
SpoolerBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    Win32ExitCode,
    IN DWORD    ServiceSpecificExitCode
    )

/*++

Routine Description:

    This function is called to set the appropriate status when a shutdown
    is to occur due to an error in the Spooler.  NOTE:  if a shutdown is
    based on a request from the Service Controller, SpoolerStatusUpdate is
    called instead.


Arguments:

    PendingCode - Indicates if the Shutdown is immediate or pending.  If
        PENDING, the shutdown will take some time, so a pending status is
        sent to the ServiceController.

    ExitCode - Indicates the reason for the shutdown.

Return Value:

    CurrentState - Contains the current state that the spooler is in
        upon exit from this routine.  In this case it will be STOPPED
        if the PendingCode is PENDING, or STOPPING if the PendingCode
        is IMMEDIATE.

Note:

    We need to clean this code up!


--*/
{
    DWORD status;

    EnterCriticalSection(&ThreadCriticalSection);

    //
    // See if the Spooler is already stopping for some reason.
    // It could be that the ControlHandler thread received a control to
    // stop the Spooler just as we decided to stop ourselves.
    //

    if ((SpoolerState != STOPPING) && (SpoolerState != STOPPED)) {

        if (PendingCode == PENDING) {
            SpoolerStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SpoolerState = STOPPING;
        }
        else {
            //
            // The shutdown is to take immediate effect.
            //
            SpoolerStatus.dwCurrentState = SERVICE_STOPPED;
            SpoolerStatus.dwControlsAccepted = 0;
            SpoolerStatus.dwCheckPoint = 0;
            SpoolerStatus.dwWaitHint = 0;
            SpoolerState = STOPPED;
        }

        SpoolerUninstallCode = Win32ExitCode;
        SpoolerStatus.dwWin32ExitCode = Win32ExitCode;
        SpoolerStatus.dwServiceSpecificExitCode = ServiceSpecificExitCode;

    }

    //
    // Send the new status to the service controller.
    //
    if (!SpoolerStatusHandle) {
        DBGMSG(DBG_ERROR,
            ("SpoolerBeginForcedShutdown, no handle to call SetServiceStatus\n"));

    }
    else if (! SetServiceStatus( SpoolerStatusHandle, &SpoolerStatus )) {

        status = GetLastError();

        if (status != NERR_Success) {
            DBGMSG(ERROR,
                ("SpoolerBeginForcedShutdown,SetServiceStatus Failed %X\n",
                status));
        }
    }

    status = SpoolerState;
    LeaveCriticalSection(&ThreadCriticalSection);
    return(status);


}


DWORD
SpoolerStatusUpdate(
    IN DWORD    NewState
    )

/*++

Routine Description:

    Sends a status to the Service Controller via SetServiceStatus.

    The contents of the status message is controlled by this routine.
    The caller simply passes in the desired state, and this routine does
    the rest.  For instance, if the Spooler passes in a STARTING state,
    This routine will update the hint count that it maintains, and send
    the appropriate information in the SetServiceStatus call.

    This routine uses transitions in state to send determine which status
    to send.  For instance if the status was STARTING, and has changed
    to RUNNING, this routine sends out an INSTALLED to the Service
    Controller.

Arguments:

    NewState - Can be any of the state flags:
                UPDATE_ONLY - Simply send out the current status
                STARTING - The Spooler is in the process of initializing
                RUNNING - The Spooler has finished with initialization
                STOPPING - The Spooler is in the process of shutting down
                STOPPED - The Spooler has completed the shutdown.

Return Value:

    CurrentState - This may not be the same as the NewState that was
        passed in.  It could be that the main thread is sending in a new
        install state just after the Control Handler set the state to
        STOPPING.  In this case, the STOPPING state will be returned so as
        to inform the main thread that a shut-down is in process.

Note:


--*/

{
    DWORD       status;
    BOOL        inhibit = FALSE;    // Used to inhibit sending the status
                                    // to the service controller.

    EnterCriticalSection(&ThreadCriticalSection);


    if (NewState == STOPPED) {
        if (SpoolerState == STOPPED) {
            //
            // It was already stopped, don't send another SetServiceStatus.
            //
            inhibit = TRUE;
        }
        else {
            //
            // The shut down is complete, indicate that the spooler
            // has stopped.
            //
            SpoolerStatus.dwCurrentState =  SERVICE_STOPPED;
            SpoolerStatus.dwControlsAccepted = 0;
            SpoolerStatus.dwCheckPoint = 0;
            SpoolerStatus.dwWaitHint = 0;
            SpoolerStatus.dwWin32ExitCode = NO_ERROR;
            SpoolerStatus.dwServiceSpecificExitCode = NO_ERROR;
        }
        SpoolerState = NewState;
    }
    else {
        //
        // We are not being asked to change to the STOPPED state.
        //
        switch(SpoolerState) {

        case STARTING:
            if (NewState == STOPPING) {

                SpoolerStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                SpoolerStatus.dwControlsAccepted = 0;
                SpoolerStatus.dwCheckPoint = HintCount++;
                SpoolerStatus.dwWaitHint = 20000;  // 20 seconds
                SpoolerState = NewState;
            }

            else if (NewState == RUNNING) {

                //
                // The Spooler Service has completed installation.
                //
                SpoolerStatus.dwCurrentState =  SERVICE_RUNNING;
                //
                // The Spooler Service cannot be stopped once started
                //
                SpoolerStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                                   SERVICE_ACCEPT_SHUTDOWN |
                                                   SERVICE_ACCEPT_POWEREVENT;
                SpoolerStatus.dwCheckPoint = 0;
                SpoolerStatus.dwWaitHint = 0;

                SpoolerState = NewState;
            }

            else {
                //
                // The NewState must be STARTING.  So update the pending
                // count
                //

                SpoolerStatus.dwCurrentState =  SERVICE_START_PENDING;
                SpoolerStatus.dwControlsAccepted = 0;
                SpoolerStatus.dwCheckPoint = HintCount++;
                SpoolerStatus.dwWaitHint = 20000;  // 20 seconds
            }
            break;

        case RUNNING:
            if (NewState == STOPPING) {

                SpoolerStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                SpoolerStatus.dwControlsAccepted = 0;
                SpoolerStatus.dwCheckPoint = HintCount++;
                SpoolerStatus.dwWaitHint = 20000;  // 20 seconds

                SpoolerState = NewState;
            }
            
            break;

        case STOPPING:
            //
            // No matter what else was passed in, force the status to
            // indicate that a shutdown is pending.
            //
            SpoolerStatus.dwCurrentState =  SERVICE_STOPPED;
            SpoolerStatus.dwControlsAccepted = 0;
            SpoolerStatus.dwCheckPoint = 0;
            SpoolerStatus.dwWaitHint = 0;  // 20 seconds

            break;

        case STOPPED:
            //
            // We're already stopped.  Therefore, an uninstalled status
            // as already been sent.  Do nothing.
            //
            inhibit = TRUE;
            break;
        }
    }

    if (!inhibit) {
        if (!SpoolerStatusHandle) {
            DBGMSG(DBG_ERROR,("SpoolerStatusUpdate, no handle to call SetServiceStatus\n"));

        }
        else if (! SetServiceStatus( SpoolerStatusHandle, &SpoolerStatus )) {

            status = GetLastError();

            if (status != NERR_Success) {
                DBGMSG(DBG_ERROR,
                    ("SpoolerStatusUpdate, SetServiceStatus Failed %d\n",status));
            }
        }
    }

    status = SpoolerState;
    LeaveCriticalSection(&ThreadCriticalSection);
    return(status);
}

DWORD
GetSpoolerState (
    VOID
    )

/*++

Routine Description:

    Obtains the state of the Spooler Service.  This state information
    is protected as a critical section such that only one thread can
    modify or read it at a time.

Arguments:

    none

Return Value:

    The Spooler State is returned as the return value.

--*/
{
    DWORD   status;

    EnterCriticalSection(&ThreadCriticalSection);
    status = SpoolerState;
    LeaveCriticalSection(&ThreadCriticalSection);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splsvr.h ===
/*++

Copyright (c) 1106990  Microsoft Corporation

Module Name:

    splsvr.h

Abstract:

    Header file for Spooler Service.
    Contains all function prototypes

Author:

    Krishna Ganugapati (KrishnaG) 18-Oct-1993

Notes:

Revision History:
     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss
--*/
//
// Spooler Service  States (used as return codes)
//

#define UPDATE_ONLY         0   // no change in state - just send current status.
#define STARTING            1   // the messenger is initializing.
#define RUNNING             2   // initialization completed normally - now running
#define STOPPING            3   // uninstall pending
#define STOPPED             4   // uninstalled

//
// Forced Shutdown PendingCodes
//
#define PENDING     TRUE
#define IMMEDIATE   FALSE

#define SPOOLER_START_PHASE_TWO_INIT 2*60*1000

//
// Based on the data fed back to us from perf devs, 
// the maximum number of threads encountered in their 
// tests was 2385 threads at the rate of ~12000 
// jobs/min. This is at 72% CPU capacity and so the
// following number is suggested as a threshold to 
// be on the safe side with serving i/p concurrent
// RPC client requests
//                              
#define SPL_MAX_RPC_CALLS 6000

extern HANDLE TerminateEvent;
extern HANDLE hPhase2Init;
extern WCHAR  szSpoolerExitingEvent[];


//
// Function Prototypes
//


DWORD
GetSpoolerState (
    VOID
    );

DWORD
SpoolerBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    Win32ExitCode,
    IN DWORD    ServiceSpecificExitCode
    );


DWORD
SpoolerInitializeSpooler(
    DWORD   argc,
    LPTSTR  *argv
    );


VOID
SpoolerShutdown(VOID);


VOID
SpoolerStatusInit(VOID);

DWORD
SpoolerStatusUpdate(
    IN DWORD    NewState
    );


DWORD
SpoolerCtrlHandler(
    IN  DWORD                   opcode,
    IN  DWORD                   dwEventType,
    IN  PVOID                   pEventData,
    IN  PVOID                   pData
    );


BOOL
InitializeRouter(
    SERVICE_STATUS_HANDLE SpoolerStatusHandle
);

DWORD
SplProcessPnPEvent(
    IN  DWORD                   dwEventType,
    IN  PVOID                   pEventData,
    IN  PVOID                   pData
    );

VOID
SplStartPhase2Init(
    VOID);

BOOL
SplPowerEvent(
    DWORD
    );

RPC_STATUS
SpoolerStartRpcServer(
    VOID
    );



RPC_STATUS
SpoolerStopRpcServer(
    VOID
    );

VOID
SPOOLER_main (
    IN DWORD    argc,
    IN LPTSTR   argv[]
    );

PSECURITY_DESCRIPTOR
CreateNamedPipeSecurityDescriptor(
    VOID
    );

BOOL
BuildNamedPipeProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\srvrmem.h ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved.

Module Name:

    srvrmem.h

Abstract:

    Prototypes for Memory Allocation routines for spoolsv.exe.

Author:

    Khaled Sedky (Khaleds)  13-Jan-1999

Revision History:

--*/


#ifndef _SRVRMEM_H_
#define _SRVRMEM_H_

#define DWORD_ALIGN_UP(size) (((size)+3)&~3)

LPVOID
SrvrAllocSplMem(
    DWORD cb
);

BOOL
SrvrFreeSplMem(
   LPVOID pMem
);

LPVOID
SrvrReallocSplMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\srvrmem.c ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved.

Module Name:

    srvrmem.c

Abstract:

    Memory Allocation Routines for spoolsv.exe.

Author:

    Khaled Sedky (khaleds)  13-Jan-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddrdr.h>
#include <stdio.h>
#include <windows.h>
#include <winspool.h>
#include "server.h"
#include "client.h"
#ifndef _SRVRMEM_H_
#include "srvrmem.h"
#endif

LPVOID
SrvrAllocSplMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    LPDWORD  pMem;
    DWORD    cbNew;

    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb+sizeof(DWORD_PTR)+sizeof(DWORD);

    pMem=(LPDWORD)LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        DBGMSG( DBG_WARNING, ("Memory Allocation failed for %d bytes\n", cbNew ));
        return 0;
    }

    *pMem=cb;

    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadbeef;

    return (LPVOID)(pMem+sizeof(DWORD_PTR)/sizeof(DWORD));
}

BOOL
SrvrFreeSplMem(
   LPVOID pMem
)
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if( !pMem ){
        return TRUE;
    }
    pNewMem = pMem;
    pNewMem -= sizeof(DWORD_PTR) / sizeof(DWORD);

    cbNew = *pNewMem;

    if (*(LPDWORD)((LPBYTE)pMem + cbNew) != 0xdeadbeef) {
        DBGMSG(DBG_ERROR, ("DllFreeSplMem Corrupt Memory in winspool : %0lx\n", pNewMem));
        return FALSE;
    }

    memset(pNewMem, 0x65, cbNew);

    LocalFree((LPVOID)pNewMem);

    return TRUE;
}

LPVOID
SrvrReallocSplMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=SrvrAllocSplMem(cbNew);

    if (!pNewMem)
    {

        DBGMSG( DBG_WARNING, ("Memory ReAllocation failed for %d bytes\n", cbNew ));
    }
    else
    {
        if (pOldMem)
        {
            if (cbOld)
            {
                memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
            }
            SrvrFreeSplMem(pOldMem);
       }
    }
    return pNewMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\winspls.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Stub file to allow winspl_c.c to work with precompiled headers.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "winspl_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\splkernl.c ===
/*++
Copyright (c) 1990  Microsoft Corporation
All Rights Reserved

Module Name:

    splkernl.c

Abstract:

    This module contains the Spooler's Kernel mode message router and unmarshalling functions,
    which then call kmxxx().

Author:

    Steve Wilson (NT) (swilson) 1-Jun-1995

[Notes:]

    optional-notes

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddrdr.h>
#include <stdio.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winspl.h>
#include <ntgdispl.h>
#include <offsets.h>
#include "server.h"
#include "client.h"
#include "kmspool.h"
#include "yspool.h"
#include "splr.h"
#include "splsvr.h"
#include "wingdip.h"
#ifndef  _SRVRMEM_H_
#include "srvrmem.h"
#endif

#define IN_BUF_SIZE     8192    // must be at least 4096
#define OUT_BUF_SIZE    1024 

#define DECREMENT       0
#define INCREMENT       1

#define MAX_GRE_STRUCT_SIZE 100     // At least the size of the largest GRExxx struct in ntgdispl.h
#define WAITFOR_SYSTEM_TO_RECOVER   500 

DWORD cGetSpoolMessage(PSPOOLESC psesc, DWORD cjMsg, PDWORD pulOut, DWORD cjOut);
BOOL SpoolerGetSpoolMessage();

BOOL DoOpenPrinter(PSPOOLESC psesc, HANDLE*, DWORD*);
BOOL DoGetPrinter(PSPOOLESC psesc, GREGETPRINTER *pGetPrinterReturn, DWORD *pcjOut);
BOOL DoGetPrinterDriver( PSPOOLESC, GREGETPRINTERDRIVER*, DWORD* );
BOOL DoStartDocPrinter( PSPOOLESC psesc );
BOOL DoWritePrinter(PSPOOLESC psesc, DWORD *pWritten );
BOOL DoGetForm(PSPOOLESC psesc, GREGETFORM *pGetFormReturn, DWORD *pcjOut);
BOOL DoEnumForms(PSPOOLESC psesc, GREENUMFORMS *pEnumFormsReturn, DWORD *pcjOut);
BOOL DoGetPrinterData(PSPOOLESC psesc, GREGETPRINTERDATA *pXReturn, DWORD *pcjOut);
BOOL DoSetPrinterData(PSPOOLESC psesc, GRESETPRINTERDATA *pXReturn, DWORD *pcjOut);
BOOL DoGetPathName( WCHAR  *pwcSrc, WCHAR  *pwcDst, DWORD  *pcjWritten );
BOOL DoDriverUnloadComplete( WCHAR *pDriverFile );

DWORD GetSpoolMessages();
DWORD AddThread();

LONG nIdleThreads = 0;          // Number of idle threads
LONG nThreads = 0;
SYSTEMTIME LastMessageTime;     // Time at which last message was received


// GetSpoolMessages - Manages creation & deletion of spooler message threads
DWORD GetSpoolMessages()
{

    if (!GdiInitSpool()) {
        DBGMSG(DBG_TRACE, ("Error calling GdiInitSpool()\n"));
        return GetLastError();
    }

    return AddThread();
}

DWORD AddThread()
{
    HANDLE  hThread;
    DWORD   MessageThreadId;
    BOOL    dwError;

    try {
        if(hThread = CreateThread(  NULL,
                                    LARGE_INITIAL_STACK_COMMIT,
                                    (LPTHREAD_START_ROUTINE) SpoolerGetSpoolMessage,
                                    0,
                                    0,
                                    &MessageThreadId)) {
            CloseHandle(hThread);
            dwError = ERROR_SUCCESS;
        } else {
            dwError = GetLastError();
        }
    } except(1) {
        dwError = TranslateExceptionCode(GetExceptionCode());
    }

    return dwError;
}


BOOL SpoolerGetSpoolMessage()
{
    DWORD   dwResult;
    PSPOOLESC pInput;                   // Input buffer that receives messages from Kernel
    BYTE    *pOutput;                   // Output buffer that receives data from KMxxx() spooler calls
    BYTE    *pMem;
    DWORD   cbOut = 0;                  // Size of pOutput
    DWORD   cbIn = IN_BUF_SIZE;         // Size of pInput buffer in bytes
    DWORD   cbOutSize;
    DWORD   dwFailureCount = 0;
    

    if(!(pInput = (PSPOOLESC) SrvrAllocSplMem(cbIn))) {
        DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
        return FALSE;
    }

    if(!(pOutput = SrvrAllocSplMem(OUT_BUF_SIZE))) {
        SrvrFreeSplMem(pInput);
        DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
        return FALSE;
    }

    cbOutSize = OUT_BUF_SIZE;

    EnterCriticalSection(&ThreadCriticalSection);

    ++nThreads;

    LeaveCriticalSection(&ThreadCriticalSection);

    while(1) {

        EnterCriticalSection(&ThreadCriticalSection);
        ++nIdleThreads;
        LeaveCriticalSection(&ThreadCriticalSection);

        dwResult = GdiGetSpoolMessage(pInput,cbIn,(PDWORD)pOutput,cbOutSize);

        EnterCriticalSection(&ThreadCriticalSection);
        --nIdleThreads;
        LeaveCriticalSection(&ThreadCriticalSection);


        if(dwResult == 0) {

            dwFailureCount++;
            //
            // We can get into this situation where the machine is out of memory
            // and GdiGetSpoolMessage fails because it cannot probe the memory for the message.
            // Because this thread is to aggressive, it won't give the chance to other threads in the 
            // system to get executed. Put it to sleep for a couple of seconds when that happens.(bug 192434)
            //
            if (dwFailureCount > 1) {

                Sleep(WAITFOR_SYSTEM_TO_RECOVER * dwFailureCount);

                //
                // Note: 4 and WAITFOR_SYSTEM_TO_RECOVER has no significance. 
                // They were arbitrary chosen.
                //
                dwFailureCount %= 4;
            }

        } else {

            dwFailureCount = 0;

            if( (pInput->iMsg != GDISPOOL_TERMINATETHREAD) &&
                (pInput->iMsg != GDISPOOL_INPUT2SMALL)) {

                EnterCriticalSection(&ThreadCriticalSection);

                if(nIdleThreads == 0) {
                    AddThread();
                    DBGMSG(DBG_TRACE, ("Thread Added: nIdle = %d  nThreads = %d\n", nIdleThreads, nThreads));
                }

                LeaveCriticalSection(&ThreadCriticalSection);
            }

            // check if the out buffer needs to be grown or shrunk.

            if ((pInput->cjOut + MAX_GRE_STRUCT_SIZE) > cbOutSize) {

                SrvrFreeSplMem(pOutput);

                pOutput = SrvrAllocSplMem(cbOutSize = pInput->cjOut + MAX_GRE_STRUCT_SIZE);

                if (!pOutput) {

                    DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
                    pInput->ulRet = 0;
                    cbOut = 0;
                    cbOutSize = 0;
                    continue;
                }
            }
            else if ((pInput->cjOut < OUT_BUF_SIZE) &&
                     (cbOutSize > OUT_BUF_SIZE)) {

                // we want to shrink the buffer

                PBYTE pbTmp = SrvrAllocSplMem(OUT_BUF_SIZE);

                if (pbTmp) {

                    SrvrFreeSplMem(pOutput);

                    pOutput = pbTmp;
                    cbOutSize = OUT_BUF_SIZE;
                }
            }


            if (pInput->iMsg & GDISPOOL_API) {

                SPLASSERT(pInput->hSpool || pInput->iMsg == GDISPOOL_OPENPRINTER);

                if (pInput->iMsg != GDISPOOL_OPENPRINTER || pInput->hSpool) {
                    if (InterlockedIncrement(&((PSPOOL)pInput->hSpool)->cThreads) > 0) {

                        // We are already processing a message & have now gotten a ClosePrinter
                        // We should not get here on any other API
                        SPLASSERT(pInput->iMsg == GDISPOOL_CLOSEPRINTER);

                        pInput->ulRet = TRUE;       // Let Client terminate
                        continue;
                    }
                }
            }


            switch (pInput->iMsg) {
                case GDISPOOL_INPUT2SMALL:
                    DBGMSG(DBG_TRACE,(" - buffer not big enough\n"));

                    pMem = SrvrReallocSplMem(pInput, cbIn, pInput->cjOut);

                    if (!pMem) {

                        DBGMSG(DBG_WARNING, ("Error reallocating pInput in SpoolerGetSpoolMessage\n"));
                        pInput->ulRet = 0;
                    }
                    else {
                        pInput = (PSPOOLESC) pMem;
                        cbIn   = pInput->cjOut;
                        pInput->ulRet = 1;
                    }

                    break;

                case GDISPOOL_TERMINATETHREAD:
                    EnterCriticalSection(&ThreadCriticalSection);

                    // There is 1 way to get here: from a 10 minute Kernel Event timeout

                    if(nIdleThreads > 1) {
                        --nThreads;
                        if (nThreads == 0) {
                            DBGMSG(DBG_WARNING, ("SpoolerGetSpoolMessage nThreads is now ZERO\n"));
                        }

                        DBGMSG(DBG_TRACE, ("Thread Deleted: nIdle = %d  nThreads = %d\n", nIdleThreads, nThreads));

                        LeaveCriticalSection(&ThreadCriticalSection);

                        SrvrFreeSplMem(pInput);
                        SrvrFreeSplMem(pOutput);

                        return TRUE;
                    }

                    LeaveCriticalSection(&ThreadCriticalSection);
                    break;

                case GDISPOOL_WRITE:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_WRITE\n"));
                    pInput->ulRet = DoWritePrinter( pInput, (DWORD*) pOutput );
                    cbOut = sizeof(DWORD);
                    break;

                case GDISPOOL_OPENPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_OPENPRINTER\n"));
                    DoOpenPrinter(pInput,(HANDLE*)pOutput,&cbOut);
                    break;

                case GDISPOOL_STARTDOCPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_STARTDOCPRINTER\n"));
                    DoStartDocPrinter(pInput);
                    break;

                case GDISPOOL_STARTPAGEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_STARTPAGEPRINTER\n"));
                    pInput->ulRet = KMStartPagePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENDPAGEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENDPAGEPRINTER\n"));
                    pInput->ulRet = KMEndPagePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENDDOCPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENDDOCPRINTER\n"));
                    pInput->ulRet = KMEndDocPrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENUMFORMS:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENUMFORMS\n"));
                    DoEnumForms(pInput, (GREENUMFORMS *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTER\n"));
                    DoGetPrinter(pInput, (GREGETPRINTER *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETFORM:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETFORM\n"));
                    DoGetForm(pInput, (GREGETFORM *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETPRINTERDRIVER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTERDRIVER\n"));
                    DoGetPrinterDriver(pInput,(GREGETPRINTERDRIVER*)pOutput,&cbOut);
                    break;

                case GDISPOOL_GETPRINTERDATA:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTERDATA\n"));
                    DoGetPrinterData(pInput,(GREGETPRINTERDATA *) pOutput,&cbOut);
                    break;

                case GDISPOOL_SETPRINTERDATA:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_SETPRINTERDATA\n"));
                    DoSetPrinterData(pInput,(GRESETPRINTERDATA *) pOutput,&cbOut);
                    break;

                case GDISPOOL_ABORTPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ABORTPRINTER\n"));
                    pInput->ulRet = KMAbortPrinter( pInput->hSpool );
                    break;

                case GDISPOOL_CLOSEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_CLOSEPRINTER\n"));
                    pInput->ulRet = KMClosePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_GETPATHNAME:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPATHNAME\n"));
                    pInput->ulRet = DoGetPathName((WCHAR*)pInput->ajData,
                                                  (WCHAR*)pOutput,
                                                  &cbOut);
                    break;
                
                case GDISPOOL_UNLOADDRIVER_COMPLETE:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_UNLOADDRIVER_COMPLETE\n"));
                    pInput->ulRet = DoDriverUnloadComplete((LPWSTR)pInput->ajData);
                    break;

                default:
                    DBGMSG(DBG_ERROR,(" - invalid message\n"));
                    break;
            }

            if ((pInput->iMsg & GDISPOOL_API) &&
                 pInput->iMsg != GDISPOOL_CLOSEPRINTER &&
                 pInput->iMsg != GDISPOOL_OPENPRINTER &&
                 pInput->hSpool) {

                if (InterlockedDecrement(&((PSPOOL)pInput->hSpool)->cThreads) == 0) {

                    DBGMSG(DBG_TRACE,(" - GDISPOOL_CLOSEPRINTER\n"));
                    pInput->ulRet = KMClosePrinter( pInput->hSpool );
                }
            }
        }
    }
}



/******************************Public*Routine******************************\
* DoOpenPrinter
*
* History:
*  11-Apr-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/


BOOL DoOpenPrinter(PSPOOLESC psesc, HANDLE* phPrinter, DWORD* pcjOut)
{
    LPWSTR pPrinterName = NULL;
    PRINTER_DEFAULTSW pDefault;
    GREOPENPRINTER *pOpenPrinter;
    PLONG plData;
    ULONG cbSize;  

    //
    // Make a copy of psesc->ajData if unaligned. The size of duplicated buffer
    // is the first LONG in psesc->ajData ( GREOPENPRINTER.cj ).
    //
    cbSize = *(PLONG)psesc->ajData;

    pOpenPrinter = (GREOPENPRINTER *)AlignKMPtr(psesc->ajData, cbSize);

    if (pOpenPrinter)
    {
        plData      = pOpenPrinter->alData;
        pDefault    = pOpenPrinter->pd;

        // see if there is a printer name?

        if (pOpenPrinter->cjName)
        {
            pPrinterName = (PWCHAR)plData;
            plData += pOpenPrinter->cjName/4;
        }

        // now setup the printer defaults

        if (pOpenPrinter->cjDatatype)
        {
            pDefault.pDatatype = (PWCHAR)plData;
            plData += pOpenPrinter->cjDatatype/4;
        }

        if (pOpenPrinter->cjDevMode)
        {
            pDefault.pDevMode = (PDEVMODEW)plData;
        }

        DBGMSG(DBG_TRACE,
                    ("OpenPrinter(%ls,%ls,%lx,%d)\n",
                    pPrinterName,
                    pDefault.pDatatype,
                    pDefault.pDevMode,
                    pDefault.DesiredAccess) );

        psesc->ulRet = KMOpenPrinterW(pPrinterName,phPrinter,&pDefault);

        DBGMSG( DBG_TRACE,("OpenPrinter returned = %lx\n",psesc->ulRet));

        *pcjOut = sizeof(ULONG_PTR);

        UndoAlignKMPtr( (LPBYTE)pOpenPrinter, psesc->ajData );
    } 
    else 
    {
        psesc->ulRet = FALSE;
    }

    if(psesc->ulRet)
        return TRUE;
    else
        return FALSE;
}




/****************************************************************************
*  DoStartDocPrinter()
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL DoStartDocPrinter( PSPOOLESC psesc )
{
    DOC_INFO_1W di;
    GRESTARTDOCPRINTER *pStartDocPrinter = (GRESTARTDOCPRINTER *)psesc->ajData;
    PLONG plData;

    plData = pStartDocPrinter->alData;

    // see if there is a printer name?

    if (pStartDocPrinter->cjDocName)
    {
        di.pDocName = (PWCHAR)plData;
        plData += pStartDocPrinter->cjDocName/4;
    }
    else
    {
        di.pDocName = NULL;
    }

    if (pStartDocPrinter->cjOutputFile)
    {
        di.pOutputFile = (PWCHAR)plData;
        plData += pStartDocPrinter->cjOutputFile/4;
    }
    else
    {
        di.pOutputFile = NULL;
    }

    if (pStartDocPrinter->cjDatatype)
    {
        di.pDatatype = (PWCHAR)plData;
        plData += pStartDocPrinter->cjDatatype/4;
    }
    else
    {
        di.pDatatype = NULL;
    }

    psesc->ulRet = KMStartDocPrinterW(psesc->hSpool, 1, (LPBYTE) &di);

    if(psesc->ulRet)
        return TRUE;
    else
        return FALSE;
}


/*************************************************************************************
    DoEnumForms()

    History:
    25/7/95 by Steve Wilson [swilson]

**************************************************************************************/

BOOL DoEnumForms(
    PSPOOLESC psesc,
    GREENUMFORMS *pEnumFormsReturn,
    DWORD *pcjOut
)
{
    GREENUMFORMS *pEnumForms = (GREENUMFORMS *) psesc->ajData;
    DWORD dwNeeded = 0;
    DWORD dwnForms;

    psesc->ulRet = KMEnumFormsW (   psesc->hSpool,
                                    pEnumForms->dwLevel,
                                    (BYTE *) pEnumFormsReturn->alData,
                                    pEnumForms->cjData,
                                    &dwNeeded,
                                    &pEnumFormsReturn->nForms
                                );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pEnumFormsReturn->cjData = pEnumForms->cjData;
        *pcjOut = pEnumForms->cjData + sizeof(GREENUMFORMS);
    }
    else {
        pEnumFormsReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREENUMFORMS);
    }

    return psesc->ulRet;
}


/*************************************************************************************
    DoGetPrinter()

    History:
    9/30/95 by Steve Wilson [swilson]

**************************************************************************************/

BOOL DoGetPrinter(
    PSPOOLESC psesc,
    GREGETPRINTER *pGetPrinterReturn,
    DWORD *pcjOut
)
{
    GREGETPRINTER *pGetPrinter = (GREGETPRINTER *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetPrinterW (  psesc->hSpool,
                                    pGetPrinter->dwLevel,
                                    (BYTE *) pGetPrinterReturn->alData,
                                    pGetPrinter->cjData,
                                    &dwNeeded
                                  );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pGetPrinterReturn->cjData = pGetPrinter->cjData;
        *pcjOut = pGetPrinter->cjData + sizeof(GREGETPRINTER);
    }
    else {
        pGetPrinterReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREGETPRINTER);
    }

    return psesc->ulRet;
}


/*************************************************************************************
    DoGetForm()

    History:
    25/7/95 by Steve Wilson [swilson]

**************************************************************************************/

BOOL DoGetForm(
    PSPOOLESC psesc,
    GREGETFORM *pGetFormReturn,
    DWORD *pcjOut
)
{
    GREGETFORM *pGetForm = (GREGETFORM *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetFormW (   psesc->hSpool,
                                  pGetForm->cjFormName ? (PWCHAR) pGetForm->alData : NULL,
                                  pGetForm->dwLevel,
                                  (BYTE *) pGetFormReturn->alData,
                                  pGetForm->cjData,
                                  &dwNeeded
                              );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pGetFormReturn->cjData = pGetForm->cjData;
        *pcjOut = pGetForm->cjData + sizeof(GREGETFORM);
    }
    else {
        pGetFormReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREGETFORM);
    }

    return psesc->ulRet;
}




/***************************************************************************************
*  DoGetPrinterDriver()

*  History:
*   4/17/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
**************************************************************************************/


BOOL DoGetPrinterDriver(
    PSPOOLESC psesc,
    GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
    DWORD *pcjOut
    )
{
    GREGETPRINTERDRIVER *pGetPrinterDriver = (GREGETPRINTERDRIVER *)psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetPrinterDriverW(psesc->hSpool,
                                      pGetPrinterDriver->cjEnv ? (PWCHAR)pGetPrinterDriver->alData : NULL,
                                      pGetPrinterDriver->dwLevel,
                                      (BYTE*)pGetPrinterDriverReturn->alData,
                                      pGetPrinterDriver->cjData,
                                      &dwNeeded );

    if (psesc->ulRet)
    {
        pGetPrinterDriverReturn->cjData = pGetPrinterDriver->cjData;  // fix for ValidateStrings in spool.cxx
        *pcjOut = pGetPrinterDriver->cjData + sizeof(GREGETPRINTERDRIVER);
    }
    else
    {
        // we failed so just return the size

        pGetPrinterDriverReturn->cjData = dwNeeded;
        *pcjOut = sizeof(GREGETPRINTERDRIVER);
    }


    if(psesc->ulRet)
        return TRUE;

    return FALSE;
}


/***************************************************************************************
*  DoGetPrinterData()

*  History:
*   Jul-25-95 by Steve Wilson [swilson]
*  Wrote it.
**************************************************************************************/


BOOL DoGetPrinterData(
    PSPOOLESC psesc,
    GREGETPRINTERDATA *pXReturn,
    DWORD *pcjOut
    )
{
    GREGETPRINTERDATA *pX = (GREGETPRINTERDATA *) psesc->ajData;

    DWORD dwNeeded = 0;        // return values
    DWORD dwType;


    psesc->ulRet = KMGetPrinterDataW( psesc->hSpool,
                                      pX->cjValueName ? (PWCHAR) pX->alData : NULL,
                                      &dwType,
                                      (BYTE *) pXReturn->alData,
                                      pX->cjData,
                                      &dwNeeded );

    pXReturn->dwNeeded = dwNeeded;
    pXReturn->cjData = pX->cjData;
    *pcjOut = pX->cjData + sizeof *pX;
    pXReturn->dwType = dwType;

    SetLastError(psesc->ulRet);

    return psesc->ulRet = !psesc->ulRet;
}



/***************************************************************************************
*  DoSetPrinterData()

*  History:
*   Jul-25-95 by Steve Wilson [swilson]
*  Wrote it.
**************************************************************************************/


BOOL DoSetPrinterData(
    PSPOOLESC psesc,
    GRESETPRINTERDATA *pXReturn,
    DWORD *pcjOut
    )
{
    GRESETPRINTERDATA *pX = (GRESETPRINTERDATA *) psesc->ajData;


    psesc->ulRet = KMSetPrinterDataW( psesc->hSpool,
                                      pX->cjType ? (PWCHAR) pX->alData : NULL,
                                      pX->dwType,
                                      pX->cjPrinterData ? (BYTE *) pX->alData + pX->cjType : NULL,
                                      pX->cjPrinterData );

    *pcjOut = sizeof *pX;

    SetLastError(psesc->ulRet);

    return psesc->ulRet = !psesc->ulRet;
}





/****************************************************************************
*  DoWritePrinter()

*  History:
*   5/1/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL DoWritePrinter(PSPOOLESC psesc, DWORD *pWritten )
{
    GREWRITEPRINTER *pWritePrinter;
    BOOL bReturn;
    ULONG  cbSize;  
    
    //
    // Make a copy of psesc->ajData if unaligned. The size of duplicated buffer
    // is the first LONG in psesc->ajData ( GREWRITEPRINTER.cj ).
    //
    cbSize = *(PLONG)psesc->ajData;

    pWritePrinter = (GREWRITEPRINTER *)AlignKMPtr(psesc->ajData, cbSize);

    if ( !pWritePrinter ) {

        return FALSE;
    }

    if (pWritePrinter->pUserModeData) {

        DBGMSG(DBG_TRACE,("WritePrinter UserMode data %0x\n", pWritePrinter->pUserModeData));
        bReturn = KMWritePrinter(   psesc->hSpool,
                                    (PVOID) pWritePrinter->pUserModeData,
                                    pWritePrinter->cjUserModeData,
                                    pWritten);

    } else {

        DBGMSG(DBG_TRACE,("WritePrinter KernelMode data %0x\n", pWritePrinter->alData));
        bReturn = KMWritePrinter( psesc->hSpool,
                                  (PVOID) pWritePrinter->alData,
                                  pWritePrinter->cjData,
                                  pWritten);
    }

    UndoAlignKMPtr((LPBYTE)pWritePrinter, psesc->ajData );

    return bReturn;
}

BOOL DoDriverUnloadComplete( WCHAR *pDriverFile )
{
    BOOL    bRet = TRUE;
    LPWSTR  pDriverFileCopy = NULL;
    WCHAR   szSystemRoot[] =  L"\\SystemRoot\\System32";
    DWORD   dwLength, dwThreadId;
    HANDLE  hThread = NULL;
    WCHAR   szDriverFile[MAX_PATH + 1];

    dwLength = wcslen(szSystemRoot);

    // Check the validity of the driver file name
    if (!pDriverFile || !*pDriverFile) {
        return bRet;
    }

    if (wcslen(pDriverFile) < dwLength) {
        return bRet;
    }

    // Convert kernel mode system relative path to x:\....\system32\spool\...
    if (GetSystemDirectory(szDriverFile, MAX_PATH)) {

        if (!_wcsnicmp(pDriverFile, szSystemRoot, dwLength)) {
            wcscat(szDriverFile, pDriverFile + dwLength);
        } else {
            wcscpy(szDriverFile, pDriverFile);
        }
    
        YDriverUnloadComplete(szDriverFile);
    }

    return bRet;
}


BOOL DoGetPathName( WCHAR  *pwcSrc, WCHAR  *pwcDst, DWORD  *pcjWritten )
{
    BOOL    bRet;
    WCHAR   awcFontsDir[MAX_PATH + sizeof(L"\\DOSDEVICES\\")/sizeof(WCHAR)];

    wcscpy(awcFontsDir,L"\\DOSDEVICES\\");

    bRet = bMakePathNameW (
            &awcFontsDir[sizeof(L"\\DOSDEVICES\\")/sizeof(WCHAR) - 1],
            pwcSrc,
            NULL,
            NULL
            );


    if (bRet)
    {
        wcscpy(pwcDst,awcFontsDir);
        *pcjWritten = sizeof(WCHAR) * (wcslen(awcFontsDir) + 1);
    }

// Buffer large enough and search successfull?

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\yspool.h ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    yspool.h

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

   AdinaTru 02/25/2000 

[Notes:]

    optional-notes

Revision History:

    
--*/

#include "mtype.h"

DWORD
YEnumPrinters(
    DWORD Flags,
    LPWSTR Name,
    DWORD Level,
    LPBYTE pPrinterEnum,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YOpenPrinter(
    LPWSTR pPrinterName,
    HANDLE *phPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD AccessRequired,
    CALL_ROUTE   Route
    );

DWORD
YOpenPrinterEx(
    LPWSTR pPrinterName,
    HANDLE *phPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD AccessRequired,
    CALL_ROUTE   Route,
    PSPLCLIENT_CONTAINER pSplClientContainer
    );

DWORD
YResetPrinter(
    HANDLE hPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    CALL_ROUTE   Route
    );

DWORD
YSetJob(
    HANDLE hPrinter,
    DWORD JobId,
    JOB_CONTAINER *pJobContainer,
    DWORD Command,
    CALL_ROUTE   Route
    );

DWORD
YGetJob(
    HANDLE hPrinter,
    DWORD JobId,
    DWORD Level,
    LPBYTE pJob,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YEnumJobs(
    HANDLE hPrinter,
    DWORD FirstJob,
    DWORD NoJobs,
    DWORD Level,
    LPBYTE pJob,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinter(
    LPWSTR pName,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    HANDLE *phPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterEx(
    LPWSTR                  pName,
    PPRINTER_CONTAINER      pPrinterContainer,
    PDEVMODE_CONTAINER      pDevModeContainer,
    PSECURITY_CONTAINER     pSecurityContainer,
    HANDLE                 *phPrinter,
    CALL_ROUTE              Route,
    PSPLCLIENT_CONTAINER    pSplClientContainer
    );

DWORD
YDeletePrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterConnection(
    LPWSTR pName,
    CALL_ROUTE   Route
    );

DWORD
YDeletePrinterConnection(
    LPWSTR pName,
    CALL_ROUTE   Route
    );

DWORD
YSetPrinter(
    HANDLE hPrinter,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    DWORD Command,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinter(
    HANDLE hPrinter,
    DWORD Level,
    LPBYTE pPrinter,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterDriver(
    LPWSTR pName,
    LPDRIVER_CONTAINER pDriverContainer,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterDriverEx(
    LPWSTR  pName,
    LPDRIVER_CONTAINER pDriverContainer,
    DWORD   dwFileCopyFlags,
    CALL_ROUTE   Route
);

DWORD
YAddDriverCatalog(
    HANDLE  hPrinter,
    DRIVER_INFCAT_CONTAINER *pDriverInfCatContainer,
    DWORD   dwCatalogCopyFlags,
    CALL_ROUTE   Route
);

DWORD
YEnumPrinterDrivers(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDrivers,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDriver(
    HANDLE hPrinter,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDriverDirectory(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YDeletePrinterDriver(
    LPWSTR pName,
    LPWSTR pEnvironment,
    LPWSTR pDriverName,
    CALL_ROUTE   Route
    );


DWORD
YDeletePrinterDriverEx(
    LPWSTR pName,
    LPWSTR pEnvironment,
    LPWSTR pDriverName,
    DWORD  dwDeleteFlag,
    DWORD  dwVersionNum,
    CALL_ROUTE   Route
    );


DWORD
YAddPerMachineConnection(
    LPWSTR pServer,
    LPCWSTR pPrinterName,
    LPCWSTR pPrintServer,
    LPCWSTR pProvider,
    CALL_ROUTE   Route
    );

DWORD
YDeletePerMachineConnection(
    LPWSTR pServer,
    LPCWSTR pPrinterName,
    CALL_ROUTE   Route
    );

DWORD
YEnumPerMachineConnections(
    LPWSTR pServer,
    LPBYTE pPrinterEnum,
    DWORD  cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YAddPrintProcessor(
    LPWSTR pName,
    LPWSTR pEnvironment,
    LPWSTR pPathName,
    LPWSTR pPrintProcessorName,
    CALL_ROUTE   Route
    );

DWORD
YEnumPrintProcessors(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pPrintProcessors,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YGetPrintProcessorDirectory(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pPrintProcessorInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YEnumPrintProcessorDatatypes(
    LPWSTR pName,
    LPWSTR pPrintProcessorName,
    DWORD Level,
    LPBYTE pDatatypes,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YStartDocPrinter(
    HANDLE hPrinter,
    LPDOC_INFO_CONTAINER pDocInfoContainer,
    LPDWORD pJobId,
    CALL_ROUTE   Route
    );

DWORD
YStartPagePrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YWritePrinter(
    HANDLE hPrinter,
    LPBYTE pBuf,
    DWORD cbBuf,
    LPDWORD pcWritten,
    CALL_ROUTE   Route
    );

DWORD
YSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL    bWritePrinter,
    CALL_ROUTE   Route
    );

DWORD
YFlushPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep,
    CALL_ROUTE   Route
    );

DWORD
YEndPagePrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAbortPrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YReadPrinter(
    HANDLE hPrinter,
    LPBYTE pBuf,
    DWORD cbBuf,
    LPDWORD pRead,
    CALL_ROUTE   Route
    );

DWORD
YSplReadPrinter(
    HANDLE hPrinter,
    LPBYTE *pBuf,
    DWORD cbBuf,
    CALL_ROUTE   Route
    );

DWORD
YEndDocPrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAddJob(
    HANDLE hPrinter,
    DWORD Level,
    LPBYTE pAddJob,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YScheduleJob(
    HANDLE hPrinter,
    DWORD JobId,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterData(
    HANDLE hPrinter,
    LPTSTR pValueName,
    LPDWORD pType,
    LPBYTE pData,
    DWORD nSize,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDataEx(
    HANDLE hPrinter,
    LPCTSTR pKeyName,
    LPCTSTR pValueName,
    LPDWORD pType,
    LPBYTE pData,
    DWORD nSize,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData,        // address for size of data buffer
    CALL_ROUTE   Route
);

DWORD
YEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues,
    CALL_ROUTE   Route
);

DWORD
YEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey,      // address for size of value buffer
    CALL_ROUTE   Route
);

DWORD
YDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    CALL_ROUTE   Route
);

DWORD
YDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    CALL_ROUTE   Route
);

DWORD
YDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    CALL_ROUTE   Route
);

DWORD
YSetPrinterData(
    HANDLE hPrinter, 
    LPTSTR pValueName, 
    DWORD Type, 
    LPBYTE pData, 
    DWORD cbData,
    CALL_ROUTE   Route
    );

DWORD
YSetPrinterDataEx(
    HANDLE hPrinter, 
    LPCTSTR pKeyName, 
    LPCTSTR pValueName, 
    DWORD Type, 
    LPBYTE pData, 
    DWORD cbData, 
    CALL_ROUTE   Route
    );

DWORD
YWaitForPrinterChange(
    HANDLE hPrinter, 
    DWORD Flags, 
    LPDWORD pFlags, 
    CALL_ROUTE   Route
    );

DWORD
YClosePrinter(
    LPHANDLE phPrinter, 
    CALL_ROUTE   Route
    );
    
VOID
PRINTER_HANDLE_rundown(
    HANDLE hPrinter
    );

DWORD
YAddForm(
    HANDLE hPrinter, 
    PFORM_CONTAINER pFormInfoContainer, 
    CALL_ROUTE   Route
    );

DWORD
YDeleteForm(
    HANDLE hPrinter, 
    LPWSTR pFormName, 
    CALL_ROUTE   Route
    );

DWORD
YGetForm(   
    PRINTER_HANDLE hPrinter, 
    LPWSTR pFormName, 
    DWORD Level, 
    LPBYTE pForm, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    CALL_ROUTE   Route
    );

DWORD
YSetForm(
    PRINTER_HANDLE hPrinter, 
    LPWSTR pFormName, 
    PFORM_CONTAINER pFormInfoContainer, 
    CALL_ROUTE   Route
    );

DWORD
YEnumForms(
    PRINTER_HANDLE hPrinter, 
    DWORD Level, 
    LPBYTE pForm, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned, 
    CALL_ROUTE   Route
    );

DWORD
YEnumPorts(
    LPWSTR pName, 
    DWORD Level, 
    LPBYTE pPort, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned, 
    CALL_ROUTE   Route
    );

DWORD
YEnumMonitors(
    LPWSTR pName, 
    DWORD Level, 
    LPBYTE pMonitor, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned, 
    CALL_ROUTE   Route
    );
    
DWORD
YAddPort(
    LPWSTR pName, 
    HWND   hWnd, 
    LPWSTR pMonitorName, 
    CALL_ROUTE   Route
    );

DWORD
YConfigurePort(
    LPWSTR pName, 
    HWND   hWnd, 
    LPWSTR pPortName, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePort(
    LPWSTR pName, 
    HWND   hWnd, 
    LPWSTR 
    pPortName, 
    CALL_ROUTE   Route
    );

DWORD
YXcvData(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus,
    CALL_ROUTE   Route
);



DWORD
YCreatePrinterIC(
    HANDLE hPrinter, 
    HANDLE *pHandle, 
    LPDEVMODE_CONTAINER pDevModeContainer, 
    CALL_ROUTE   Route
    );

DWORD
YPlayGdiScriptOnPrinterIC(
    GDI_HANDLE hPrinterIC, 
    LPBYTE pIn, 
    DWORD cIn, 
    LPBYTE pOut, 
    DWORD cOut, 
    DWORD ul, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePrinterIC(
    GDI_HANDLE *phPrinterIC, 
    BOOL bImpersonate, 
    CALL_ROUTE   Route
    );

DWORD
YPrinterMessageBox(
    PRINTER_HANDLE hPrinter, 
    DWORD Error, 
    HWND hWnd, 
    LPWSTR pText, 
    LPWSTR pCaption, 
    DWORD dwType, 
    CALL_ROUTE   Route
    );

DWORD
YAddMonitor(
    LPWSTR pName, 
    PMONITOR_CONTAINER pMonitorContainer, 
    CALL_ROUTE   Route
    );

DWORD
YDeleteMonitor(
    LPWSTR pName, 
    LPWSTR pEnvironment, 
    LPWSTR pMonitorName, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePrintProcessor(
    LPWSTR pName, 
    LPWSTR pEnvironment, 
    LPWSTR pPrintProcessorName, 
    CALL_ROUTE   Route
    );

DWORD
YAddPrintProvidor(
    LPWSTR pName, 
    PPROVIDOR_CONTAINER pProvidorContainer, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePrintProvidor(
    LPWSTR pName, 
    LPWSTR pEnvironment, 
    LPWSTR pPrintProvidorName, 
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDriver2( 
    HANDLE hPrinter,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    DWORD dwClientMajorVersion,
    DWORD dwClientMinorVersion,
    PDWORD pdwServerMajorVersion,
    PDWORD pdwServerMinorVersion,
    CALL_ROUTE   Route
    );

DWORD
YAddPortEx(
    LPWSTR pName, 
    LPPORT_CONTAINER pPortContainer, 
    LPPORT_VAR_CONTAINER pPortVarContainer, 
    LPWSTR pMonitorName, 
    CALL_ROUTE   Route
    );

DWORD
YSpoolerInit(
    LPWSTR pName, 
    CALL_ROUTE   Route
    );

DWORD
YResetPrinterEx(
    HANDLE hPrinter, 
    LPWSTR pDatatype, 
    LPDEVMODE_CONTAINER pDevModeContainer, 
    DWORD dwFlag, 
    CALL_ROUTE   Route
    );

DWORD
YSetAllocFailCount(
    HANDLE hPrinter, 
    DWORD dwFailCount, 
    LPDWORD lpdwAllocCount, 
    LPDWORD lpdwFreeCount, 
    LPDWORD lpdwFailCountHit, 
    CALL_ROUTE   Route
    );

DWORD
YSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    LPPORT_CONTAINER    pPortContainer,
    CALL_ROUTE          Route
    );

DWORD
YClusterSplOpen(
    LPCTSTR     pszServer,
    LPCTSTR     pszResource,
    PHANDLE     phSpooler,
    LPCTSTR     pszName,
    LPCTSTR     pszAddress,
    CALL_ROUTE   Route        
    );

DWORD
YClusterSplClose(
    PHANDLE     phSpooler,
    CALL_ROUTE   Route
    );

DWORD
YClusterSplIsAlive(
    HANDLE      hSpooler,
    CALL_ROUTE   Route
    );

VOID
YDriverUnloadComplete(
    LPWSTR  pDriverFile
    );

DWORD
YGetSpoolFileInfo(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YGetSpoolFileInfo2(
    HANDLE                  hPrinter,
    DWORD                   dwAppProcessId,
    DWORD                   dwLevel,
    LPFILE_INFO_CONTAINER   pSplFileInfoContainer,
    CALL_ROUTE              Route
    );


DWORD
YCommitSpoolData(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       cbCommit,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
    );

DWORD
YCommitSpoolData2(
    HANDLE                  hPrinter,
    DWORD                   dwAppProcessId,
    DWORD                   cbCommit,
    DWORD                   dwLevel,
    LPFILE_INFO_CONTAINER   pSplFileInfoContainer,
    CALL_ROUTE              Route
    );

DWORD
YCloseSpoolFileHandle(
    HANDLE      hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YSendRecvBidiData(
    IN          HANDLE  hPrinter,
    IN          LPCWSTR pAction,
    IN          PBIDI_REQUEST_CONTAINER   pReqData,
    OUT         PBIDI_RESPONSE_CONTAINER* ppRespData,
    CALL_ROUTE  Route
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\basecls.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     basecls.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation of the base classes
     used out by most of the loader and interfaces of the 
     surrogate process. Although these base classes don't contain
     pure virtual functions , they should not be instantiated on
     their own. Their usage is utilized through inheritance mainly.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

/* ------------------------------------ */
/* Implemetation of class TPrinterDriver */
/* ------------------------------------ */

/*++
    Function Name:
        TPrinterDriver :: TPrinterDriver
     
    Description:
        Constructor of base printer driver object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TPrinterDriver ::
TPrinterDriver(
    VOID
    )
{}

/*++
    Function Name:
        TPrinterDriver :: ~TPrinterDriver
     
    Description:
        Destructor of base printer driver object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TPrinterDriver ::
~TPrinterDriver(
    VOID
    )
{}

/*++
    Function Name:
        TPrinterDriver :: LoadPritnerDriver
     
    Description:
        Queries the Printer for the suitable driver and loads
        it
             
    Parameters:
        HANLDE hPrinter  : Handle of Printer to laod driver for
             
     Return Value:
        HMODULE hDriver  : In case of success Handle to driver dll 
                           In case of failure NULL
--*/
HMODULE
TPrinterDriver ::
LoadPrinterDriver(
    IN HANDLE hPrinter
    )
{
     PDRIVER_INFO_5  pDriverInfo;                                              
     DWORD           DriverInfoSize, DriverVersion;                                              
     HANDLE          hDriver = FALSE;                                                    
     BYTE            Buffer[MAX_STATIC_ALLOC];                                       
     BOOL            bAllocBuffer = FALSE, bReturn;                                    
                                                                               
     pDriverInfo = reinterpret_cast<PDRIVER_INFO_5>(Buffer);                                  
                                                                               
     bReturn = GetPrinterDriverW(hPrinter,
                                 NULL,
                                 5,
                                 (LPBYTE)pDriverInfo,       
                                 MAX_STATIC_ALLOC,
                                 &DriverInfoSize);                 
                                                                               
     if (!bReturn &&                                                           
         (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&                      
         (pDriverInfo = (PDRIVER_INFO_5)new byte[DriverInfoSize]))
     {   
          bAllocBuffer = TRUE;                                                 
          bReturn = GetPrinterDriverW(hPrinter,
                                      NULL,
                                      5,
                                      (LPBYTE)pDriverInfo,  
                                      DriverInfoSize,
                                      &DriverInfoSize);                    
     }                                                                         
                                                                               
     if (bReturn)
     {                                                            
         hDriver = LoadLibraryEx(pDriverInfo->pConfigFile,
                                 NULL,
                                 LOAD_WITH_ALTERED_SEARCH_PATH);
     }                                                                         
                                                                               
     if (bAllocBuffer)
     {                                                       
         delete pDriverInfo;                                               
     }                                                                         
                                                                               
     return hDriver;                                                           
}


/* ----------------------------- */
/* Implemetation of class RefCnt */
/* ----------------------------- */

/*++
    Function Name:
        TRefCntMgr :: TRefCntMgr
     
    Description:
        Constructor of base refrence count object. This 
        object keeps track of the number of clients using
        the object;
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TRefCntMgr ::
TRefCntMgr(
    VOID
    ) : 
   m_cRefCnt(0)
{}

/*++
    Function Name:
        TRefCntMgr :: ~TRefCntMgr
     
    Description:
        Destructor of base refrence count object. 
                     
     Parameters:
        None
        
     Return Value:
        None
--*/
TRefCntMgr ::
~TRefCntMgr(
    VOID
    )
{}


/*++
    Function Name:
        TRefCntMgr :: AddRef
     
    Description:
        Increments the ref count on the object
                     
     Parameters:
        None
        
     Return Value:
        DWORD : New Ref Count
--*/
DWORD
TRefCntMgr ::
AddRef(
    VOID
    )
{
    return InterlockedIncrement(&m_cRefCnt);
}

/*++
    Function Name:
        TRefCntMgr :: Release
     
    Description:
        Decrements the ref count on the object 
        and deletes the object , if this is the
        last attached client
                     
     Parameters:
        None
        
     Return Value:
        DWORD : New Ref Count
                0 if object deleted
--*/
DWORD 
TRefCntMgr ::
Release(
    VOID
    )
{
    LONG cRef = InterlockedDecrement(&m_cRefCnt);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\basecls.hpp ===
#ifndef __BASECLS_HPP__
#define __BASECLS_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of some base 
     classes that are utilized by other classes(objects)
     in the surrogate process
     So far we have 2 of these
     o Printer Driver class
     o Ref Count Class
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
--*/


class TRefCntMgr
{
     public:

     TRefCntMgr(
         VOID
         );

     virtual ~TRefCntMgr(
         VOID
         );

     virtual DWORD
     AddRef(
         VOID
         );

     virtual DWORD
     Release(
         VOID
         );

     private:

     LONG    m_cRefCnt;
};


class TClassID
{
    public:
    
    char szClassID[32];

    inline TClassID(char *pszCallerID)
    {
        ZeroMemory(szClassID,32);
        strcpy(szClassID,pszCallerID);
    }
};


class TPrinterDriver
{
    public:

    TPrinterDriver(
        VOID
        );

    virtual ~TPrinterDriver(
        VOID
        );

    protected:

    HMODULE
    LoadPrinterDriver(
         IN HANDLE hPrinter
        );
};

#endif //__BASECLS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\server\yspool.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    yspool.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

[Notes:]

    optional-notes

Revision History:

    swilson    1-Jun-95     Converted winspool.c to yspool: the merging point of KM & RPC paths

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <winspool.h>
#include <winsprlp.h>
#include <winsplp.h>
#include <winspl.h>
#include <offsets.h>
#include "server.h"
#include "client.h"
#include "yspool.h"
#include "clusrout.h"

LPWSTR szNull = L"";

BOOL
OldGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);



#define YRevertToSelf(rpc)      (rpc != NATIVE_CALL ? RpcRevertToSelf() : 0)

DWORD   ServerHandleCount = 0;

BOOL
YImpersonateClient(CALL_ROUTE Route);

VOID
PrinterHandleRundown(
    HANDLE hPrinter);

BOOL
GetPrinterDriverExW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion);

BOOL
OpenPrinterExW(
    LPWSTR                 pPrinterName,
    HANDLE                *pHandle,
    LPPRINTER_DEFAULTS     pDefault,
    PSPLCLIENT_CONTAINER   pSplClientContainer
    );

HANDLE
AddPrinterExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pClientInfo,
    DWORD   dwLevel
    );

BOOL
SpoolerInit(
    VOID); 


BOOL
InvalidDevModeContainer(
    LPDEVMODE_CONTAINER pDevModeContainer
    )
{
    DWORD       dwSize = pDevModeContainer->cbBuf;

    if(pDevModeContainer)
    {
        PDEVMODE    pDevMode = (PDEVMODE) pDevModeContainer->pDevMode;



        if (dwSize < MIN_DEVMODE_SIZEW)
            return dwSize ? TRUE : !!pDevMode;


        if (pDevMode && (pDevMode->dmSize + (DWORD) pDevMode->dmDriverExtra == pDevModeContainer->cbBuf))
            return FALSE;
    }
    return TRUE;
}

BOOL
InvalidSecurityContainer(
    PSECURITY_CONTAINER pSecurityContainer
)
{
    SECURITY_DESCRIPTOR_CONTROL SecurityDescriptorControl;
    DWORD                       dwRevision;

    if(!pSecurityContainer                                                                  ||
       (pSecurityContainer->pSecurity                                                       &&
       !RtlValidRelativeSecurityDescriptor((SECURITY_DESCRIPTOR *)pSecurityContainer->pSecurity,
                                           pSecurityContainer->cbBuf,
                                           0)))
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
ValidatePortVarContainer(
    PPORT_VAR_CONTAINER pPortVarContainer
    )
{
    return !!pPortVarContainer;
}

BOOL
ValidatePortContainer(
    LPPORT_CONTAINER pPortContainer
    )
{
    return pPortContainer && pPortContainer->PortInfo.pPortInfo1;
}

BOOL
ValidatePrinterContainer(
    PPRINTER_CONTAINER  pPrinterContainer
    )
{
    return pPrinterContainer && pPrinterContainer->PrinterInfo.pPrinterInfo1;
}

BOOL
ValidateMonitorContainer(
    LPMONITOR_CONTAINER pMonitorContainer
    )
{
    return pMonitorContainer && pMonitorContainer->MonitorInfo.pMonitorInfo2;
}


DWORD
YEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
)
{   FieldInfo* pFieldInfo;
    DWORD   cReturned, cbStruct;
    DWORD   Error=ERROR_INVALID_NAME;
    DWORD   BufferSize=cbBuf;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrinterEnum, &cbBuf);

    if ( pPrinterEnum && !pAlignedBuff ){
        return GetLastError();
    }

    bRet = EnumPrinters(Flags, Name, Level, pAlignedBuff,
                        cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pPrinterEnum, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
    
}

DWORD
YOpenPrinter(
    LPWSTR              pPrinterName,
    HANDLE             *phPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD               AccessRequired,
    CALL_ROUTE          Route
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    Defaults.DesiredAccess = AccessRequired;

    bRet = OpenPrinterW(pPrinterName, phPrinter, &Defaults);

    YRevertToSelf(Route);

    if (bRet) {
        InterlockedIncrement ( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else {
        *phPrinter = NULL;
        return GetLastError();
    }
}

DWORD
YOpenPrinterEx(
    LPWSTR                  pPrinterName,
    HANDLE                 *phPrinter,
    LPWSTR                  pDatatype,
    LPDEVMODE_CONTAINER     pDevModeContainer,
    DWORD                   AccessRequired,
    CALL_ROUTE              Route,
    PSPLCLIENT_CONTAINER    pSplClientContainer
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    Defaults.DesiredAccess = AccessRequired;

    bRet = OpenPrinterExW(pPrinterName,
                          phPrinter,
                          &Defaults,
                          pSplClientContainer);

    YRevertToSelf(Route);

    if (bRet) {
        InterlockedIncrement ( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else {
        *phPrinter = NULL;
        return GetLastError();
    }
}


DWORD
YResetPrinter(
    HANDLE              hPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    CALL_ROUTE          Route
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    //
    // You cannot change the Access Mask on a Printer Spool Object
    // We will always ignore this parameter and set it to zero
    // We get some random garbage otherwise.
    //

    Defaults.DesiredAccess = 0;

    bRet = ResetPrinter(hPrinter, &Defaults);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSetJob(
    HANDLE      hPrinter,
    DWORD       JobId,
    JOB_CONTAINER *pJobContainer,
    DWORD       Command,
    CALL_ROUTE  Route
    )

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SetJob(hPrinter, JobId, pJobContainer ? pJobContainer->Level : 0,
                  pJobContainer ? (LPBYTE)pJobContainer->JobInfo.Level1 : NULL,
                  Command);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YGetJob(
    HANDLE      hPrinter,
    DWORD       JobId,
    DWORD       Level,
    LPBYTE      pJob,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
   )

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL   bRet;
    SIZE_T cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;


    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    //
    // HACK for 3.51: Catch bad parameters passed across the wire.
    // If the buffer passed is > 1 MEG, fail the call.
    //
    if( cbBuf > 0x100000 ){

        DBGMSG( DBG_ERROR,
                ( "** GetJob: cbBuf is 0x%x !! Contact VibhasC and AlbertT **\n", cbBuf ));

        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }


    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pJob, &cbBuf);

    if (pJob && !pAlignedBuff){
        return GetLastError();
    }

    bRet = GetJob(hPrinter, JobId, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        if (Route) {

            bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
        }
    }
            
    UndoAlignRpcPtr(pJob, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YEnumJobs(
    HANDLE      hPrinter,
    DWORD       FirstJob,
    DWORD       NoJobs,
    DWORD       Level,
    LPBYTE      pJob,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    DWORD   cReturned, cbStruct;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;


    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pJob, &cbBuf);

    if (pJob && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumJobs(hPrinter, FirstJob, NoJobs, Level, pAlignedBuff,
                    cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pJob, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YAddPrinter(
    LPWSTR              pName,
    PPRINTER_CONTAINER  pPrinterContainer,
    PDEVMODE_CONTAINER  pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    HANDLE              *phPrinter,
    CALL_ROUTE           Route
)
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    if(!ValidatePrinterContainer(pPrinterContainer) ||
       InvalidDevModeContainer(pDevModeContainer))
    {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (pPrinterContainer->Level == 2)
    {
        if(!pPrinterContainer->PrinterInfo.pPrinterInfo2 ||
           (pSecurityContainer->pSecurity                &&
            InvalidSecurityContainer(pSecurityContainer)))
        {
           return ERROR_INVALID_PARAMETER;
        }
        pPrinterContainer->PrinterInfo.pPrinterInfo2->pDevMode =
                           (LPDEVMODE)pDevModeContainer->pDevMode;
        pPrinterContainer->PrinterInfo.pPrinterInfo2->pSecurityDescriptor =
                           (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;
    }

    *phPrinter = AddPrinter(pName, pPrinterContainer->Level,
                     (LPBYTE)pPrinterContainer->PrinterInfo.pPrinterInfo1);

    YRevertToSelf(Route);

    if (*phPrinter) {
        InterlockedIncrement( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else
        return GetLastError();
}

DWORD
YAddPrinterEx(
    LPWSTR                  pName,
    PPRINTER_CONTAINER      pPrinterContainer,
    PDEVMODE_CONTAINER      pDevModeContainer,
    PSECURITY_CONTAINER     pSecurityContainer,
    HANDLE                 *phPrinter,
    CALL_ROUTE              Route,
    PSPLCLIENT_CONTAINER    pSplClientContainer
    )
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    if(!ValidatePrinterContainer(pPrinterContainer) || 
       InvalidDevModeContainer(pDevModeContainer))
    {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (pPrinterContainer->Level == 2)
    {
       if(!pPrinterContainer->PrinterInfo.pPrinterInfo2 ||
          (pSecurityContainer->pSecurity                &&
           InvalidSecurityContainer(pSecurityContainer)))
       {
          return ERROR_INVALID_PARAMETER;
       }
       pPrinterContainer->PrinterInfo.pPrinterInfo2->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;
       pPrinterContainer->PrinterInfo.pPrinterInfo2->pSecurityDescriptor =
                          (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;
    }

    *phPrinter = AddPrinterExW(pName,
                               pPrinterContainer->Level,
                               (LPBYTE)pPrinterContainer->PrinterInfo.pPrinterInfo1,
                               (LPBYTE)pSplClientContainer->ClientInfo.pClientInfo1,
                               pSplClientContainer->Level);

    YRevertToSelf(Route);

    if (*phPrinter) {
        InterlockedIncrement( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else
        return GetLastError();
}

DWORD
YDeletePrinter(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddPrinterConnection(
    LPWSTR      pName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPrinterConnection(pName);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePrinterConnection(
    LPWSTR      pName,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinterConnection(pName);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSetPrinter(
    HANDLE              hPrinter,
    PPRINTER_CONTAINER  pPrinterContainer,
    PDEVMODE_CONTAINER  pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    DWORD               Command,
    CALL_ROUTE          Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if(!pPrinterContainer ||
       (pPrinterContainer->Level && !ValidatePrinterContainer(pPrinterContainer)) ||
       InvalidDevModeContainer(pDevModeContainer))
    {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (InvalidSecurityContainer(pSecurityContainer)) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    switch (pPrinterContainer->Level) {

    case 2:

        pPrinterContainer->PrinterInfo.pPrinterInfo2->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;

        pPrinterContainer->PrinterInfo.pPrinterInfo2->pSecurityDescriptor =
                          (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;

        break;

    case 3:

        pPrinterContainer->PrinterInfo.pPrinterInfo3->pSecurityDescriptor =
                          (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;
        break;

    case 8:

        pPrinterContainer->PrinterInfo.pPrinterInfo8->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;
        break;

    case 9:

        pPrinterContainer->PrinterInfo.pPrinterInfo9->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;
        break;

    default:
        break;
    }

    bRet = SetPrinter(hPrinter, pPrinterContainer->Level,
                      (LPBYTE)pPrinterContainer->PrinterInfo.pPrinterInfo1,
                      Command);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YGetPrinter(
    HANDLE      hPrinter,
    DWORD       Level,
    LPBYTE      pPrinter,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{   
    FieldInfo *pFieldInfo;
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    SIZE_T  cbStruct;
    LPBYTE  pAlignedBuff;

    *pcbNeeded = 0;
    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 3:
        pFieldInfo = PrinterInfo3Fields;
        cbStruct = sizeof(PRINTER_INFO_3);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    case 6:
        pFieldInfo = PrinterInfo6Fields;
        cbStruct = sizeof(PRINTER_INFO_6);
        break;

    case 7:
        pFieldInfo = PrinterInfo7Fields;
        cbStruct = sizeof(PRINTER_INFO_7);
        break;

    case 8:
        pFieldInfo = PrinterInfo8Fields;
        cbStruct = sizeof(PRINTER_INFO_8);
        break;

    case 9:
        pFieldInfo = PrinterInfo9Fields;
        cbStruct = sizeof(PRINTER_INFO_9);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrinter, &cbBuf);

    if (pPrinter && !pAlignedBuff){
        return GetLastError();
    }

    ReturnValue = GetPrinter(hPrinter, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (ReturnValue) {

         ReturnValue = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pPrinter, pAlignedBuff, cbBuf, pcbNeeded);

    return ReturnValue ? ERROR_SUCCESS : GetLastError();
}


DWORD
YAddPrinterDriver(
    LPWSTR              pName,
    LPDRIVER_CONTAINER  pDriverContainer,
    CALL_ROUTE          Route
)
{
    PDRIVER_INFO_4 pDriverInfo4 = NULL;
    BOOL           bRet         = FALSE;
    LPRPC_DRIVER_INFO_4W    pRpcDriverInfo4;

    if(!pDriverContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    switch (pDriverContainer->Level) {

        case 2:
            bRet = AddPrinterDriver(pName,
                                   pDriverContainer->Level,
                                   (LPBYTE)pDriverContainer->DriverInfo.Level2);
            break;

        case 3:
        case 4:
            if(!pDriverContainer->DriverInfo.Level4)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Error;
            }

            pDriverInfo4 = (PDRIVER_INFO_4) AllocSplMem(sizeof(DRIVER_INFO_4));

            if ( !pDriverInfo4 ) {
                
                goto Error;
            }

            pRpcDriverInfo4 = (LPRPC_DRIVER_INFO_4W) pDriverContainer->DriverInfo.Level4;

            if (!pRpcDriverInfo4) {
                FreeSplMem(pDriverInfo4);
                SetLastError(ERROR_INVALID_PARAMETER);             
                goto Error;
            }

            pDriverInfo4->cVersion          = pRpcDriverInfo4->cVersion;
            pDriverInfo4->pName             = pRpcDriverInfo4->pName;
            pDriverInfo4->pEnvironment      = pRpcDriverInfo4->pEnvironment;
            pDriverInfo4->pDriverPath       = pRpcDriverInfo4->pDriverPath;
            pDriverInfo4->pDataFile         = pRpcDriverInfo4->pDataFile;
            pDriverInfo4->pConfigFile       = pRpcDriverInfo4->pConfigFile;
            pDriverInfo4->pHelpFile         = pRpcDriverInfo4->pHelpFile;
            pDriverInfo4->pMonitorName      = pRpcDriverInfo4->pMonitorName;
            pDriverInfo4->pDefaultDataType  = pRpcDriverInfo4->pDefaultDataType;

            //
            // Use szNULL if the DependentFiles string contains nothing
            //
            if ((pRpcDriverInfo4->cchDependentFiles == 0) ||
                (pRpcDriverInfo4->cchDependentFiles == 1))  {

                pDriverInfo4->pDependentFiles = szNull;
            } else {
                pDriverInfo4->pDependentFiles = pRpcDriverInfo4->pDependentFiles
;
            }

            if ( pDriverContainer->Level == 4 ) {

                if ( pRpcDriverInfo4->cchPreviousNames == 0 ||
                     pRpcDriverInfo4->cchPreviousNames  == 1 )
                    pDriverInfo4->pszzPreviousNames = szNull;
                else
                    pDriverInfo4->pszzPreviousNames
                                        = pRpcDriverInfo4->pszzPreviousNames;
            }


            bRet = AddPrinterDriver(pName,
                                    pDriverContainer->Level,
                                    (LPBYTE) pDriverInfo4);

            FreeSplMem(pDriverInfo4);
            break;

        default:
            YRevertToSelf(Route);
            return ERROR_INVALID_LEVEL;
    }

Error:
    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddPrinterDriverEx(
    LPWSTR              pName,
    LPDRIVER_CONTAINER  pDriverContainer,
    DWORD               dwFileCopyFlags,
    CALL_ROUTE          Route
)
{
    BOOL                 bRet = FALSE;
    PDRIVER_INFO_6       pDriverInfo6 = NULL;
    LPRPC_DRIVER_INFO_6W pRpcDriverInfo6;

    if(!pDriverContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    switch (pDriverContainer->Level) {

        case 2:
            bRet = AddPrinterDriverEx(pName,
                                      pDriverContainer->Level,
                                      (LPBYTE)pDriverContainer->DriverInfo.Level2,
                                      dwFileCopyFlags);
            break;

        case 3:
        case 4:
        case 6:
            
            if(!pDriverContainer->DriverInfo.Level6)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Error;
            }
            pDriverInfo6 = (PDRIVER_INFO_6) AllocSplMem(sizeof(DRIVER_INFO_6));

            if ( !pDriverInfo6 ) {

                bRet = FALSE;
                goto Error;
            }

            pRpcDriverInfo6 = (LPRPC_DRIVER_INFO_6W) pDriverContainer->DriverInfo.Level6;
            pDriverInfo6->cVersion          = pRpcDriverInfo6->cVersion;
            pDriverInfo6->pName             = pRpcDriverInfo6->pName;
            pDriverInfo6->pEnvironment      = pRpcDriverInfo6->pEnvironment;
            pDriverInfo6->pDriverPath       = pRpcDriverInfo6->pDriverPath;
            pDriverInfo6->pDataFile         = pRpcDriverInfo6->pDataFile;
            pDriverInfo6->pConfigFile       = pRpcDriverInfo6->pConfigFile;
            pDriverInfo6->pHelpFile         = pRpcDriverInfo6->pHelpFile;
            pDriverInfo6->pMonitorName      = pRpcDriverInfo6->pMonitorName;
            pDriverInfo6->pDefaultDataType  = pRpcDriverInfo6->pDefaultDataType;

            //
            // Use szNULL if the DependentFiles string contains nothing
            //
            if ((pRpcDriverInfo6->cchDependentFiles == 0) ||
                (pRpcDriverInfo6->cchDependentFiles == 1))  {

                pDriverInfo6->pDependentFiles = szNull;
            } else {
                pDriverInfo6->pDependentFiles = pRpcDriverInfo6->pDependentFiles;
            }

            if ( pDriverContainer->Level == 4 || pDriverContainer->Level == 6 ) {

                if ( pRpcDriverInfo6->cchPreviousNames == 0 ||
                     pRpcDriverInfo6->cchPreviousNames  == 1 )
                    pDriverInfo6->pszzPreviousNames = szNull;
                else
                    pDriverInfo6->pszzPreviousNames
                                        = pRpcDriverInfo6->pszzPreviousNames;
            }

            if ( pDriverContainer->Level == 6 ) {
                pDriverInfo6->ftDriverDate      = pRpcDriverInfo6->ftDriverDate;
                pDriverInfo6->dwlDriverVersion  = pRpcDriverInfo6->dwlDriverVersion;
                pDriverInfo6->pszMfgName        = pRpcDriverInfo6->pMfgName;
                pDriverInfo6->pszOEMUrl         = pRpcDriverInfo6->pOEMUrl;
                pDriverInfo6->pszHardwareID     = pRpcDriverInfo6->pHardwareID;
                pDriverInfo6->pszProvider       = pRpcDriverInfo6->pProvider;
            }
            
            bRet = AddPrinterDriverEx(pName,
                                      pDriverContainer->Level,
                                      (LPBYTE) pDriverInfo6,
                                      dwFileCopyFlags);

            FreeSplMem(pDriverInfo6);
            break;

        default:
            YRevertToSelf(Route);
            return ERROR_INVALID_LEVEL;
    }

Error:
    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddDriverCatalog(
    HANDLE                   hPrinter,
    DRIVER_INFCAT_CONTAINER  *pDriverInfCatContainer,
    DWORD                    dwCatalogCopyFlags,
    CALL_ROUTE               Route
)
{
    BOOL bRet = FALSE;

    if (!pDriverInfCatContainer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (!YImpersonateClient(Route))
    {
        goto Cleanup;
    }

    switch (pDriverInfCatContainer->dwLevel) 
    {

        case 1:
            bRet = AddDriverCatalog(hPrinter,
                                    pDriverInfCatContainer->dwLevel,
                                    pDriverInfCatContainer->DriverInfCatInfo.pDriverInfCatInfo1,
                                    dwCatalogCopyFlags);
            break;

        case 2:
            bRet = AddDriverCatalog(hPrinter,
                                    pDriverInfCatContainer->dwLevel,
                                    pDriverInfCatContainer->DriverInfCatInfo.pDriverInfCatInfo2,
                                    dwCatalogCopyFlags);
            break;

        default:
                
            SetLastError(ERROR_INVALID_LEVEL);
            break;
    }

    YRevertToSelf(Route);

Cleanup:

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YEnumPrinterDrivers(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDrivers,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    DWORD   cReturned, cbStruct;
    BOOL    bRet;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:   
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDrivers, &cbBuf);

    if (pDrivers && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumPrinterDrivers(pName, pEnvironment, Level, pAlignedBuff,
                              cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pDrivers, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YGetPrinterDriver(
    HANDLE      hPrinter,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    BOOL   bRet;
    DWORD  dwServerMajorVersion;
    DWORD  dwServerMinorVersion;
    SIZE_T cbStruct;
    LPBYTE pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDriverInfo, &cbBuf);

    if (pDriverInfo && !pAlignedBuff){
        return GetLastError();
    }

    if ( Route ) {

        //
        //  If they are Remote using the old api the don't want versioning
        //

        bRet = OldGetPrinterDriverW(hPrinter, pEnvironment, Level, pAlignedBuff,
                                    cbBuf, pcbNeeded);
    } else {

        bRet = GetPrinterDriverExW(hPrinter, pEnvironment, Level, pAlignedBuff,
                                   cbBuf, pcbNeeded, (DWORD)-1, (DWORD)-1,
                                   &dwServerMajorVersion, &dwServerMinorVersion);
    }

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
    }        

    UndoAlignRpcPtr(pDriverInfo, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YGetPrinterDriverDirectory(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = GetPrinterDriverDirectory(pName, pEnvironment, Level,
                                     pDriverInfo, cbBuf, pcbNeeded);
    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeletePrinterDriver(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    LPWSTR      pDriverName,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinterDriverW(pName, pEnvironment, pDriverName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}


DWORD
YDeletePrinterDriverEx(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    LPWSTR      pDriverName,
    DWORD       dwDeleteFlag,
    DWORD       dwVersionNum,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinterDriverExW(pName, pEnvironment, pDriverName,
                                dwDeleteFlag, dwVersionNum);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YAddPerMachineConnection(
    LPWSTR      pServer,
    LPCWSTR     pPrinterName,
    LPCWSTR     pPrintServer,
    LPCWSTR     pProvider,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPerMachineConnection(pServer, pPrinterName, pPrintServer, pProvider);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeletePerMachineConnection(
    LPWSTR      pServer,
    LPCWSTR     pPrinterName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePerMachineConnection(pServer, pPrinterName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YEnumPerMachineConnections(
    LPWSTR      pServer,
    LPBYTE      pPrinterEnum,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    pFieldInfo = PrinterInfo4Fields;
    
    cbStruct = sizeof(PRINTER_INFO_4);
    
    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrinterEnum, &cbBuf);

    if (pPrinterEnum && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumPerMachineConnections(pServer,
                                     pAlignedBuff,
                                     cbBuf,
                                     pcbNeeded,
                                     pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route );
    }

    UndoAlignRpcPtr(pPrinterEnum, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();

}

DWORD
YAddPrintProcessor(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    LPWSTR      pPathName,
    LPWSTR      pPrintProcessorName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPrintProcessor(pName, pEnvironment, pPathName,
                             pPrintProcessorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else {

        return GetLastError();
    }
}

DWORD
YEnumPrintProcessors(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pPrintProcessors,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrintProcessors, &cbBuf);

    if (pPrintProcessors && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumPrintProcessors(pName, pEnvironment, Level,
                               pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct ,Route );
    }

    UndoAlignRpcPtr(pPrintProcessors, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YGetPrintProcessorDirectory(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pPrintProcessorInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = GetPrintProcessorDirectory(pName, pEnvironment, Level,
                                      pPrintProcessorInfo, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YEnumPrintProcessorDatatypes(
    LPWSTR      pName,
    LPWSTR      pPrintProcessorName,
    DWORD       Level,
    LPBYTE      pDatatypes,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE   Route
)
{
    DWORD   cReturned,cbStruct;
    FieldInfo *pFieldInfo;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;
    
    switch (Level) {

    case 1:
        pFieldInfo = DatatypeInfo1Fields;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDatatypes, &cbBuf);

    if (pDatatypes && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumPrintProcessorDatatypes(pName, pPrintProcessorName,
                                       Level, pAlignedBuff, cbBuf,
                                       pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pDatatypes, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YStartDocPrinter(
    HANDLE                  hPrinter,
    LPDOC_INFO_CONTAINER    pDocInfoContainer,
    LPDWORD                 pJobId,
    CALL_ROUTE              Route
)
{
    LPWSTR pChar;

    if( !pDocInfoContainer || pDocInfoContainer->Level != 1 ){
        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    try
    {
        if(pDocInfoContainer->DocInfo.pDocInfo1)
        {
            if( pDocInfoContainer->DocInfo.pDocInfo1->pDocName )
            {
               for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pDocName;
                    *pChar;
                    ++pChar )
                    ;
            }

            if( pDocInfoContainer->DocInfo.pDocInfo1->pOutputFile )
            {

               for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pOutputFile;
                    *pChar;
                    ++pChar )
                   ;
            }

            if( pDocInfoContainer->DocInfo.pDocInfo1->pDatatype )
            {

               for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pDatatype;
                    *pChar;
                    ++pChar )
                   ;
            }
         }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {

        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    *pJobId = StartDocPrinter(hPrinter, pDocInfoContainer->Level,
                              (LPBYTE)pDocInfoContainer->DocInfo.pDocInfo1);

    YRevertToSelf(Route);

    if (*pJobId)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YStartPagePrinter(
   HANDLE       hPrinter,
   CALL_ROUTE    Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = StartPagePrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YWritePrinter(
    HANDLE      hPrinter,
    LPBYTE      pBuf,
    DWORD       cbBuf,
    LPDWORD     pcWritten,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = WritePrinter(hPrinter, pBuf, cbBuf, pcWritten);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


DWORD
YSeekPrinter(
    HANDLE          hPrinter,
    LARGE_INTEGER   liDistanceToMove,
    PLARGE_INTEGER  pliNewPointer,
    DWORD           dwMoveMethod,
    BOOL            bWritePrinter,
    CALL_ROUTE       Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SeekPrinter( hPrinter,
                        liDistanceToMove,
                        pliNewPointer,
                        dwMoveMethod,
                        bWritePrinter );

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


DWORD
YFlushPrinter(
    HANDLE      hPrinter,
    LPBYTE      pBuf,
    DWORD       cbBuf,
    LPDWORD     pcWritten,
    DWORD       cSleep,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = FlushPrinter(hPrinter, pBuf, cbBuf, pcWritten, cSleep);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YEndPagePrinter(
    HANDLE      hPrinter,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = EndPagePrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAbortPrinter(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AbortPrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YReadPrinter(
    HANDLE      hPrinter,
    LPBYTE      pBuf,
    DWORD       cbBuf,
    LPDWORD     pRead,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ReadPrinter(hPrinter, pBuf, cbBuf, pRead);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSplReadPrinter(
    HANDLE      hPrinter,
    LPBYTE      *pBuf,
    DWORD       cbBuf,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    // Currently SplReadPrinter is internal and does not come thru RPC.

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SplReadPrinter(hPrinter, pBuf, cbBuf);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

VOID StartDriverUnload( LPVOID pDriverFile )
{

    SplDriverUnloadComplete((LPWSTR) pDriverFile);

    if (pDriverFile) {
       FreeSplMem(pDriverFile);
    }

    return;
}

VOID
YDriverUnloadComplete(
    LPWSTR  pDriverFile
)
{
    HANDLE  hThread;
    DWORD   dwThreadId;
    LPWSTR  pDriverFileCopy = NULL;

    // Copy the string for passing it to another thread
    if (pDriverFile && *pDriverFile) {
        pDriverFileCopy = AllocSplStr(pDriverFile);
    }

    if (!pDriverFileCopy) {
        return;
    }

    // Create a thread to process driver unload and return ASAP
    hThread = CreateThread(NULL,
                           LARGE_INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE) StartDriverUnload,
                           (LPVOID) pDriverFileCopy,
                           0,
                           &dwThreadId);
    if (hThread) {
        CloseHandle(hThread);
    } else {
        // thread did not spawn, free resources
        FreeSplStr(pDriverFileCopy);
    }

    return;
}

DWORD
YEndDocPrinter(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = EndDocPrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddJob(
    HANDLE      hPrinter,
    DWORD       Level,
    LPBYTE      pAddJob,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE   Route
)
{
    BOOL        bRet;
    LPBYTE      pAlignedBuff;
    DWORD       cbStruct;
    FieldInfo   *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = AddJobFields;
        cbStruct = sizeof(ADDJOB_INFO_1W);
        break;
    case 2:
    case 3:
        pFieldInfo = AddJob2Fields;
        cbStruct = sizeof(ADDJOB_INFO_2W);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pAddJob, &cbBuf);

    if (pAddJob && !pAlignedBuff){
        return GetLastError();
    }

    bRet = AddJob(hPrinter, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        if (Route) {

            bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, sizeof(cbStruct), Route);
        }
    }

    UndoAlignRpcPtr(pAddJob, pAlignedBuff, cbBuf, pcbNeeded);
    
    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YScheduleJob(
    HANDLE      hPrinter,
    DWORD       JobId,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ScheduleJob(hPrinter, JobId);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YGetPrinterData(
   HANDLE       hPrinter,
   LPTSTR       pValueName,
   LPDWORD      pType,
   LPBYTE       pData,
   DWORD        nSize,
   LPDWORD      pcbNeeded,
   CALL_ROUTE    Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = GetPrinterData(hPrinter, pValueName, pType,
                           pData, nSize, pcbNeeded);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YGetPrinterDataEx(
   HANDLE       hPrinter,
   LPCTSTR      pKeyName,
   LPCTSTR      pValueName,
   LPDWORD      pType,
   LPBYTE       pData,
   DWORD        nSize,
   LPDWORD      pcbNeeded,
   CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = GetPrinterDataEx(hPrinter, pKeyName,pValueName, pType,
                                           pData, nSize, pcbNeeded);

    YRevertToSelf(Route);

    return dwRet;
}


DWORD
YEnumPrinterData(
    HANDLE      hPrinter,
    DWORD       dwIndex,        // index of value to query
    LPWSTR      pValueName,     // address of buffer for value string
    DWORD       cbValueName,    // size of value buffer
    LPDWORD     pcbValueName,   // address for size of value buffer
    LPDWORD     pType,          // address of buffer for type code
    LPBYTE      pData,          // address of buffer for value data
    DWORD       cbData,         // size of data buffer
    LPDWORD     pcbData,        // address for size of data buffer
    CALL_ROUTE   Route        // where this call comes from
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = EnumPrinterData(hPrinter,
                            dwIndex,
                            pValueName,
                            cbValueName,
                            pcbValueName,
                            pType,
                            pData,
                            cbData,
                            pcbData);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YEnumPrinterDataEx(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,       // address of key name
    LPBYTE      pEnumValues,
    DWORD       cbEnumValues,
    LPDWORD     pcbEnumValues,
    LPDWORD     pnEnumValues,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;
    DWORD cReturned;
    PPRINTER_ENUM_VALUES pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;
    LPBYTE  pAlignedBuff;

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pEnumValues, &cbEnumValues);

    if (pEnumValues && !pAlignedBuff){
        return GetLastError();
    }

    dwRet = EnumPrinterDataEx(  hPrinter,
                                pKeyName,
                                pAlignedBuff,
                                cbEnumValues,
                                pcbEnumValues,
                                pnEnumValues);

    YRevertToSelf(Route);

    if (dwRet == ERROR_SUCCESS) {

        if (!MarshallDownStructuresArray((LPBYTE) pAlignedBuff, 
                                         *pnEnumValues, 
                                          PrinterEnumValuesFields, 
                                          sizeof(PRINTER_ENUM_VALUES),
                                          Route) ) {
            dwRet = GetLastError();
        }

    }

    UndoAlignRpcPtr(pEnumValues, pAlignedBuff, cbEnumValues, pcbEnumValues);

    return dwRet;
    
}

DWORD
YEnumPrinterKey(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,       // address of key name
    LPWSTR      pSubkey,        // address of buffer for value string
    DWORD       cbSubkey,       // size of value buffer
    LPDWORD     pcbSubkey,      // address for size of value buffer
    CALL_ROUTE   Route        // where this call comes from
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = EnumPrinterKey( hPrinter,
                            pKeyName,
                            pSubkey,
                            cbSubkey,
                            pcbSubkey);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YDeletePrinterData(
    HANDLE      hPrinter,
    LPWSTR      pValueName,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = DeletePrinterData(hPrinter, pValueName);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YDeletePrinterDataEx(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,
    LPCWSTR     pValueName,
    CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = DeletePrinterDataEx(hPrinter, pKeyName, pValueName);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YDeletePrinterKey(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,
    CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = DeletePrinterKey(hPrinter, pKeyName);

    YRevertToSelf(Route);

    return dwRet;
}


DWORD
YSetPrinterData(
    HANDLE      hPrinter,
    LPTSTR      pValueName,
    DWORD       Type,
    LPBYTE      pData,
    DWORD       cbData,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = SetPrinterData(hPrinter, pValueName, Type, pData, cbData);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YSetPrinterDataEx(
    HANDLE      hPrinter,
    LPCTSTR     pKeyName,
    LPCTSTR     pValueName,
    DWORD       Type,
    LPBYTE      pData,
    DWORD       cbData,
    CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = SetPrinterDataEx(hPrinter, pKeyName, pValueName, Type, pData, cbData);

    YRevertToSelf(Route);

    return dwRet;
}


DWORD
YWaitForPrinterChange(
   HANDLE       hPrinter,
   DWORD        Flags,
   LPDWORD      pFlags,
   CALL_ROUTE   Route
)
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    *pFlags = WaitForPrinterChange(hPrinter, Flags);

    YRevertToSelf(Route);

    if (*pFlags) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YClosePrinter(
   LPHANDLE     phPrinter,
   CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClosePrinter(*phPrinter);

    YRevertToSelf(Route);

    *phPrinter = NULL;  // NULL out handle so Route knows to close it down.

    if (bRet) {

        InterlockedDecrement( &ServerHandleCount );
        return ERROR_SUCCESS;

    } else

        return GetLastError();
}



VOID
PRINTER_HANDLE_rundown(
    HANDLE     hPrinter
    )
{
    DBGMSG(DBG_INFO, ("Printer Handle rundown called\n"));

    PrinterHandleRundown(hPrinter);
}

DWORD
YAddForm(
    HANDLE          hPrinter,
    PFORM_CONTAINER pFormInfoContainer,
    CALL_ROUTE      Route
)
{
    BOOL bRet;

    if(!pFormInfoContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddForm(hPrinter, pFormInfoContainer->Level,
                   (LPBYTE)pFormInfoContainer->FormInfo.pFormInfo1);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeleteForm(
    HANDLE      hPrinter,
    LPWSTR      pFormName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeleteForm(hPrinter, pFormName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YGetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR          pFormName,
    DWORD           Level,
    LPBYTE          pForm,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded,
    CALL_ROUTE      Route
)
{
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pForm, &cbBuf);

    if (pForm && !pAlignedBuff){
        return GetLastError();
    }

    bRet = GetForm(hPrinter, pFormName, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructure(pAlignedBuff, FormInfo1Fields, sizeof(FORM_INFO_1), Route);
    }

    UndoAlignRpcPtr(pForm, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YSetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR          pFormName,
    PFORM_CONTAINER pFormInfoContainer,
    CALL_ROUTE       Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SetForm(hPrinter, pFormName, pFormInfoContainer->Level,
                   (LPBYTE)pFormInfoContainer->FormInfo.pFormInfo1);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YEnumForms(
   PRINTER_HANDLE   hPrinter,
   DWORD            Level,
   LPBYTE           pForm,
   DWORD            cbBuf,
   LPDWORD          pcbNeeded,
   LPDWORD          pcReturned,
   CALL_ROUTE        Route
)
{
    BOOL  bRet;
    DWORD cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = FormInfo1Fields;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pForm, &cbBuf);

    if (pForm && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumForms(hPrinter, Level, pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pForm, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YEnumPorts(
   LPWSTR       pName,
   DWORD        Level,
   LPBYTE       pPort,
   DWORD        cbBuf,
   LPDWORD      pcbNeeded,
   LPDWORD      pcReturned,
   CALL_ROUTE   Route
)
{
    BOOL    bRet;
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = PortInfo1Fields;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pFieldInfo = PortInfo2Fields;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPort, &cbBuf);

    if (pPort && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumPorts(pName, Level, pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pPort, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YEnumMonitors(
   LPWSTR       pName,
   DWORD        Level,
   LPBYTE       pMonitor,
   DWORD        cbBuf,
   LPDWORD      pcbNeeded,
   LPDWORD      pcReturned,
   CALL_ROUTE   Route
)
{
    BOOL    bRet;
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = MonitorInfo1Fields;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pFieldInfo = MonitorInfo2Fields;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pMonitor, &cbBuf);

    if (pMonitor && !pAlignedBuff){
        return GetLastError();
    }

    bRet = EnumMonitors(pName, Level, pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pMonitor, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();

}

DWORD
YAddPort(
    LPWSTR      pName,
    HWND        hWnd,
    LPWSTR      pMonitorName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPort(pName, hWnd, pMonitorName);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;

    else

        return GetLastError();
}

DWORD
YConfigurePort(
    LPWSTR      pName,
    HWND        hWnd,
    LPWSTR      pPortName,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ConfigurePort(pName, hWnd, pPortName);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePort(
    LPWSTR      pName,
    HWND        hWnd,
    LPWSTR      pPortName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePort(pName, hWnd, pPortName);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = XcvData( hXcv,
                    pszDataName,
                    pInputData,
                    cbInputData,
                    pOutputData,
                    cbOutputData,
                    pcbOutputNeeded,
                    pdwStatus);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


DWORD
YCreatePrinterIC(
    HANDLE              hPrinter,
    HANDLE              *pHandle,
    LPDEVMODE_CONTAINER pDevModeContainer,
    CALL_ROUTE           Route
)
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    *pHandle = CreatePrinterIC(hPrinter,
                               (LPDEVMODEW)pDevModeContainer->pDevMode);

    YRevertToSelf(Route);

    if (*pHandle)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YPlayGdiScriptOnPrinterIC(
    GDI_HANDLE  hPrinterIC,
    LPBYTE      pIn,
    DWORD       cIn,
    LPBYTE      pOut,
    DWORD       cOut,
    DWORD       ul,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = PlayGdiScriptOnPrinterIC(hPrinterIC, pIn, cIn, pOut, cOut, ul);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePrinterIC(
    GDI_HANDLE *phPrinterIC,
    BOOL        bImpersonate,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (bImpersonate && !YImpersonateClient(Route))
       return GetLastError();

    bRet = DeletePrinterIC(*phPrinterIC);

    if (bImpersonate)
        YRevertToSelf(Route);

    if (bRet) {

        *phPrinterIC = NULL;  // NULL out handle so Route knows to close it down.

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}


DWORD
YPrinterMessageBox(
   PRINTER_HANDLE   hPrinter,
   DWORD            Error,
   HWND             hWnd,
   LPWSTR           pText,
   LPWSTR           pCaption,
   DWORD            dwType,
   CALL_ROUTE       Route
)
{
    return PrinterMessageBox(hPrinter, Error, hWnd, pText, pCaption, dwType);
}

DWORD
YAddMonitor(
   LPWSTR               pName,
   PMONITOR_CONTAINER   pMonitorContainer,
   CALL_ROUTE            Route
)
{
    BOOL bRet;

    if(!ValidateMonitorContainer(pMonitorContainer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddMonitor(pName, pMonitorContainer->Level,
                      (LPBYTE)pMonitorContainer->MonitorInfo.pMonitorInfo1);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeleteMonitor(
   LPWSTR      pName,
   LPWSTR      pEnvironment,
   LPWSTR      pMonitorName,
   CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeleteMonitor(pName, pEnvironment, pMonitorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeletePrintProcessor(
   LPWSTR       pName,
   LPWSTR       pEnvironment,
   LPWSTR       pPrintProcessorName,
   CALL_ROUTE    Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrintProcessor(pName, pEnvironment, pPrintProcessorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YAddPrintProvidor(
    LPWSTR              pName,
    PPROVIDOR_CONTAINER pProvidorContainer,
    CALL_ROUTE          Route
)
{
    BOOL     bRet;
    DWORD    cchOrder;
    LPBYTE   pProvidorInfo;

    PROVIDOR_INFO_2W  ProvidorInfo2;
    LPRPC_PROVIDOR_INFO_2W pRpcProvidorInfo;

    if(!pProvidorContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    switch (pProvidorContainer->Level) {
    case 1:
        pProvidorInfo = (LPBYTE) pProvidorContainer->ProvidorInfo.pProvidorInfo1;
        break;

    case 2:
        pRpcProvidorInfo = (LPRPC_PROVIDOR_INFO_2W)
                                 pProvidorContainer->ProvidorInfo.pRpcProvidorInfo2;
        cchOrder = pRpcProvidorInfo->cchOrder;

        ProvidorInfo2.pOrder = (cchOrder == 0 || cchOrder == 1)
                                 ? szNull
                                 : pRpcProvidorInfo->pOrder;

        pProvidorInfo = (LPBYTE) &ProvidorInfo2;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    bRet = AddPrintProvidor(pName, pProvidorContainer->Level,
                            pProvidorInfo);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePrintProvidor(
   LPWSTR       pName,
   LPWSTR       pEnvironment,
   LPWSTR       pPrintProvidorName,
   CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrintProvidor(pName, pEnvironment, pPrintProvidorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}


DWORD
YGetPrinterDriver2(
    HANDLE      hPrinter,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    DWORD       dwClientMajorVersion,
    DWORD       dwClientMinorVersion,
    PDWORD      pdwServerMajorVersion,
    PDWORD      pdwServerMinorVersion,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    BOOL   bRet;
    SIZE_T cbStruct;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    case DRIVER_INFO_VERSION_LEVEL:
        pFieldInfo = DriverInfoVersionFields;
        cbStruct = sizeof(DRIVER_INFO_VERSION);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Hack-Hack-Hack  to determine if we want the most recent driver
    //


    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDriverInfo, &cbBuf);

    if (pDriverInfo && !pAlignedBuff){
        return GetLastError();
    }

    bRet = GetPrinterDriverExW(hPrinter, pEnvironment, Level, pAlignedBuff,
                               cbBuf, pcbNeeded, dwClientMajorVersion,
                               dwClientMinorVersion, pdwServerMajorVersion,
                               pdwServerMinorVersion);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);        
    }

    UndoAlignRpcPtr(pDriverInfo, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YAddPortEx(
    LPWSTR pName,
    LPPORT_CONTAINER        pPortContainer,
    LPPORT_VAR_CONTAINER    pPortVarContainer,
    LPWSTR                  pMonitorName,
    CALL_ROUTE               Route
    )
{
    BOOL bRet;
    DWORD Level;
    PPORT_INFO_FF pPortInfoFF;
    PPORT_INFO_1 pPortInfo1;

    if(!ValidatePortContainer(pPortContainer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    Level = pPortContainer->Level;

    switch (Level){
    case 1:
        pPortInfo1 = pPortContainer->PortInfo.pPortInfo1;

        if (!YImpersonateClient(Route))
            return GetLastError();
        bRet = AddPortEx(pName, Level, (LPBYTE)pPortInfo1, pMonitorName);
        YRevertToSelf(Route);
        break;

    case (DWORD)-1:

        pPortInfoFF = pPortContainer->PortInfo.pPortInfoFF;
        if(!ValidatePortVarContainer(pPortVarContainer))
        {
            return(ERROR_INVALID_PARAMETER);
        }
        pPortInfoFF->cbMonitorData = pPortVarContainer->cbMonitorData;
        pPortInfoFF->pMonitorData = pPortVarContainer->pMonitorData;

        if (!YImpersonateClient(Route))
            return GetLastError();
        bRet = AddPortEx(pName, Level, (LPBYTE)pPortInfoFF, pMonitorName);
        YRevertToSelf(Route);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return ERROR_INVALID_PARAMETER;

    }
    if (bRet) {
        return ERROR_SUCCESS;
    } else
        return GetLastError();
}


DWORD
YSpoolerInit(
    LPWSTR      pName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SpoolerInit();

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}



DWORD
YResetPrinterEx(
    HANDLE              hPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD               dwFlag,
    CALL_ROUTE          Route

)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (pDatatype) {
        Defaults.pDatatype = pDatatype;
    }else {
        if (dwFlag & RESET_PRINTER_DATATYPE) {
            Defaults.pDatatype = (LPWSTR)-1;
        }else {
            Defaults.pDatatype = NULL;
        }
    }

    if ((LPDEVMODE)pDevModeContainer->pDevMode) {
        Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;
    }else {
        if (dwFlag & RESET_PRINTER_DEVMODE) {
            Defaults.pDevMode = (LPDEVMODE)-1;
        }else{
            Defaults.pDevMode = NULL;
        }
    }

    //
    // You cannot change the Access Mask on a Printer Spool Object
    // We will always ignore this parameter and set it to zero
    // We get some random garbage otherwise.
    //

    Defaults.DesiredAccess = 0;

    bRet = ResetPrinter(hPrinter, &Defaults);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSetAllocFailCount(
    HANDLE      hPrinter,
    DWORD       dwFailCount,
    LPDWORD     lpdwAllocCount,
    LPDWORD     lpdwFreeCount,
    LPDWORD     lpdwFailCountHit,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SetAllocFailCount( hPrinter, dwFailCount, lpdwAllocCount, lpdwFreeCount, lpdwFailCountHit );

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


BOOL
YImpersonateClient( 
    CALL_ROUTE   Route
)
{
    DWORD   Status;

    if (Route != NATIVE_CALL) {

        Status = RpcImpersonateClient(NULL);
        SPLASSERT( Status == RPC_S_OK || Status == RPC_S_NO_CONTEXT_AVAILABLE );

        if ( Status != RPC_S_OK ) {
            SetLastError( Status );
            return FALSE;
        }
    }

    return TRUE;    // If not RPC, then we should continue w/out doing anything
}

DWORD
YSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    LPPORT_CONTAINER    pPortContainer,
    CALL_ROUTE          Route
)
{
    BOOL bRet;

    if(!ValidatePortContainer(pPortContainer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (pPortContainer->Level) {

        case 3:
            if ( !YImpersonateClient(Route) )
                return GetLastError();

            bRet = SetPort(pName,
                           pPortName,
                           pPortContainer->Level,
                           (LPBYTE)pPortContainer->PortInfo.pPortInfo1);
            YRevertToSelf(Route);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return ERROR_INVALID_PARAMETER;
    }

    return bRet ? ERROR_SUCCESS : GetLastError();
}


DWORD
YClusterSplOpen(
    LPCTSTR     pszServer,
    LPCTSTR     pszResource,
    PHANDLE     phSpooler,
    LPCTSTR     pszName,
    LPCTSTR     pszAddress,
    CALL_ROUTE   Route
    )
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClusterSplOpen( pszServer,
                           pszResource,
                           phSpooler,
                           pszName,
                           pszAddress );

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YClusterSplClose(
    PHANDLE     phPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClusterSplClose( *phPrinter );

    YRevertToSelf(Route);

    *phPrinter = NULL;  // NULL out handle so Route knows to close it down.

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YClusterSplIsAlive(
    HANDLE      hSpooler,
    CALL_ROUTE   Route
    )
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClusterSplIsAlive( hSpooler );

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YGetSpoolFileInfo(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;

    // Open the application before impersonating the user
    hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId);

    if (!YImpersonateClient(Route)) {
        goto CleanUp;
    }

    bReturn = SplGetSpoolFileInfo(hPrinter, hAppProcess, dwLevel,
                                  pSpoolFileInfo, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

CleanUp:

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    if (bReturn) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}

DWORD
YGetSpoolFileInfo2(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       dwLevel,
    LPFILE_INFO_CONTAINER pSplFileInfoContainer,
    CALL_ROUTE   Route
    )
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;
    DWORD   cbNeeded = 0;
    LPBYTE  pSpoolFileInfo;
    DWORD   cbSize;
    DWORD   dwLastError = ERROR_SUCCESS;

    switch (dwLevel){
    case 1:

        if(!pSplFileInfoContainer || !pSplFileInfoContainer->FileInfo.Level1)
        {
            return ERROR_INVALID_HANDLE;
        }
        pSpoolFileInfo = (LPBYTE)pSplFileInfoContainer->FileInfo.Level1;
        cbSize = sizeof(SPOOL_FILE_INFO_1);
        break;

    default:        
        return ERROR_INVALID_LEVEL;
    }

    // Open the application before impersonating the user
    if ( hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId) ) {

        if (YImpersonateClient(Route)) {
        
            bReturn = SplGetSpoolFileInfo(hPrinter, hAppProcess, dwLevel,
                                          pSpoolFileInfo,
                                          cbSize, &cbNeeded);

            YRevertToSelf(Route);
        }
    }

    if ( !bReturn ) {

        dwLastError = GetLastError();

        //
        // Ensure that if someone didn't set a last error, but failed the call,
        // we still return an error.
        // 
        if (dwLastError == ERROR_SUCCESS) {

            dwLastError = ERROR_INVALID_HANDLE;
        }
    }

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    return dwLastError;
}

DWORD
YCommitSpoolData(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       cbCommit,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;

    // Open the application before impersonating the user
    hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId);

    if (!YImpersonateClient(Route)) {
        goto CleanUp;
    }

    bReturn = SplCommitSpoolData(hPrinter, hAppProcess, cbCommit,
                                 dwLevel, pSpoolFileInfo, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

CleanUp:

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    if (bReturn) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}

DWORD
YCommitSpoolData2(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       cbCommit,
    DWORD       dwLevel,
    LPFILE_INFO_CONTAINER pSplFileInfoContainer,
    CALL_ROUTE  Route
)
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;
    DWORD   cbNeeded = 0;
    LPBYTE  pSpoolFileInfo;
    DWORD   cbSize;
    DWORD   dwLastError = ERROR_SUCCESS;

    switch (dwLevel){
    case 1:

        if(!pSplFileInfoContainer || !pSplFileInfoContainer->FileInfo.Level1)
        {
            return ERROR_INVALID_HANDLE;
        }
        pSpoolFileInfo = (LPBYTE)pSplFileInfoContainer->FileInfo.Level1;
        cbSize = sizeof(SPOOL_FILE_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    // Open the application before impersonating the user
    if ( hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId) ) {

        if (YImpersonateClient(Route)) {
        
            bReturn = SplCommitSpoolData(hPrinter, hAppProcess, cbCommit,
                                         dwLevel, pSpoolFileInfo, 
                                         cbSize, &cbNeeded);

            YRevertToSelf(Route);
        }
    }

    if ( !bReturn ) {

        dwLastError = GetLastError();

        //
        // Make sure that there is a failure return if there is no last error.
        // 
        if (dwLastError == ERROR_SUCCESS) {

            dwLastError = ERROR_INVALID_HANDLE;
        }
    }

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    return dwLastError;
}



DWORD
YCloseSpoolFileHandle(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL    bReturn = FALSE;

    if (!YImpersonateClient(Route)) {
        goto CleanUp;
    }

    bReturn = SplCloseSpoolFileHandle(hPrinter);

    YRevertToSelf(Route);

CleanUp:

    if (bReturn) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}


DWORD
YSendRecvBidiData(
    IN          HANDLE  hPrinter,
    IN          LPCWSTR pAction,
    IN          PBIDI_REQUEST_CONTAINER   pReqData,
    OUT         PBIDI_RESPONSE_CONTAINER* ppResData,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
    {
        dwRet = GetLastError();
    }
    else
    {
        //
        // Do we need to verify the Data in pReqData ???
        //
        dwRet = SendRecvBidiData(hPrinter,
                                 pAction,
                                 pReqData,
                                 ppResData);
        YRevertToSelf(Route);
    }

    return (dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\idl\idlstub.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/
#ifndef __IMPORT_H__
#define __IMPORT_H__

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW   DWORD
#define PSECURITY_DESCRIPTOR DWORD
#define BOOL        DWORD
#endif

#include <winspool.h>
#include <winsplp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\collmgr.cxx ===
#ifdef __COLLMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     collmgr.cxx                                                             
                                                                              
  Abstract:                                                                   
    This file contains the declaration of a generic
    linked list which could encapsulate any data type
    even if complex ones. The list is defined as a 
    manager and a node. The manager manages the given
    nodes of that type.
                                                                                       
  Author:                                                                     
     Khaled Sedky (khaleds) 21-Jun-2000                                       
     
                                                                             
  Revision History:            
--*/


/**********************************/
/*  List Manager Implementation   */
/**********************************/


template <class E,class C>
TLstMgr<E,C> ::
TLstMgr(
    IN     TLstMgr<E,C>::EEntriesType ThisListEntriesType,
    IN     TLstMgr<E,C>::EListType    ThisListType,
    IN OUT HRESULT                    *hRes
    ) : 
    m_pHead(NULL),
    m_pTail(NULL),
    m_cNumOfNodes(0),
    m_bUnique(ThisListEntriesType==TLstMgr<E,C>::KUniqueEntries ? TRUE : FALSE),
    TClassID("TLstMgr")
{

    HRESULT  hLocalRes = S_OK;

    __try
    {
        if(m_pLockSem = new CRITICAL_SECTION)
        {
            //
            // Do we need an exception handler here
            //
            ::InitializeCriticalSection(m_pLockSem);
            ::SetLastError(ERROR_SUCCESS);
        }
        else 
        {
            hLocalRes = GetLastErrorAsHRESULT();
        }
    }
    __except(1)
    {

              hLocalRes = GetLastErrorAsHRESULT(TranslateExceptionCode(::GetExceptionCode()));
    }

    if(hRes)
    {
         *hRes = hLocalRes;
    }
}


template <class E,class C>
TLstMgr<E,C> ::
~TLstMgr(
    VOID
    )
{
    EnterCriticalSection(m_pLockSem);
    {
        DestructList();
        m_cNumOfNodes = 0;
        m_pHead = m_pTail = NULL;
        LeaveCriticalSection(m_pLockSem);
    }
    DeleteCriticalSection(m_pLockSem);

    delete m_pLockSem;
}


template <class E,class C>
HRESULT
TLstMgr<E,C> ::
DestructList(
    VOID
    )
{
	TLstNd<E,C> *pNode;

    for(pNode=m_pHead;
        pNode;
        pNode = m_pHead)
    {
        SPLASSERT(pNode);
        m_pHead = pNode->m_pNext;
        delete pNode;
    }

	return S_OK;
}


template <class E,class C>
E&
TLstMgr<E,C> ::
operator[](
    IN DWORD Index
    ) const
{
	TLstNd<E,C> *pNode;
	E           *ClonedElement;

    //
    // In case the element is not found
    //
    ClonedElement = NULL;

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes && 
           Index >= 0    && 
           Index <= (m_cNumOfNodes-1))
        {
            DWORD InternalIndex = 0;

            for(pNode = m_pHead;
                (pNode &&
                (InternalIndex <= Index));
                pNode = pNode->m_pNext,
                InternalIndex ++)
            {
                ClonedElement = *pNode;
            }
        }
    }
    LeaveCriticalSection(m_pLockSem);

	return *ClonedElement;
}


template <class E,class C>
TLstNd<E,C> *
TLstMgr<E,C> ::
ElementInList(
    const C &ToCompare
    ) const
{
    TLstNd<E,C> *pNode = NULL;

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes)
        {
            for(pNode = m_pHead;
                (pNode && !(*(*(pNode)) == ToCompare)); 
                pNode = pNode->m_pNext)
            {
                //
                // There is really nothing to do, just
                // return the Node
                //
            }
        }
    }
    LeaveCriticalSection(m_pLockSem);

    return pNode;
}


template <class E,class C>
TLstNd<E,C>* 
TLstMgr<E,C> ::
AppendListByElem(
	IN const E &Element
    )
{
    TLstNd<E,C> *pNode = new TLstNd<E,C>(Element);

	EnterCriticalSection(m_pLockSem);
    {
        if(pNode)
        {
            if(!m_cNumOfNodes)
            {
                //
                // The list is empty
                //
                m_pHead = m_pTail = pNode;
                m_pHead->m_pNext  = NULL;
                m_pTail->m_pPrev  = NULL;
            }
            else
            {
                //
                // The list has one or more Elements
                //
                m_pTail->m_pNext = pNode;
                pNode->m_pPrev   = m_pTail;
                m_pTail	         = pNode;
            }
            m_cNumOfNodes ++;
        }
    }
	LeaveCriticalSection(m_pLockSem);

	return pNode;
}

template <class E,class C>
TLstNd<E,C>* 
TLstMgr<E,C> ::
AppendListByElem(
	IN E *Element
    )
{
    TLstNd<E,C> *pNode = new TLstNd<E,C>(Element);
	
    EnterCriticalSection(m_pLockSem);
    {
        if(pNode)
        {
            if(!m_cNumOfNodes)
            {
                //
                // The list is empty
                //
                m_pHead = m_pTail = pNode;
                m_pHead->m_pNext  = NULL;
                m_pTail->m_pPrev  = NULL;
            }
            else
            {
                //
                // The list has one or more Elements
                //
                m_pTail->m_pNext = pNode;
                pNode->m_pPrev   = m_pTail;
                m_pTail	         = pNode;
            }
            m_cNumOfNodes ++;
        }
        if(pNode)
            (*(*(pNode))).AddRef();
    }
    LeaveCriticalSection(m_pLockSem);

	return pNode;
}



template <class E,class C>
TLstNd<E,C>*
TLstMgr<E,C> ::
AppendListByElem(
	IN const C &ElementMember
    )
{
	TLstNd<E,C> *pNode;

	SetLastError(ERROR_SUCCESS);

	EnterCriticalSection(m_pLockSem);
    {
        if(!m_bUnique ||
           !(pNode = ElementInList(ElementMember)))
        {
            pNode = new TLstNd<E,C>(ElementMember);

            if(pNode)
            {
                if(!m_cNumOfNodes)
                {
                    //
                    // The list is empty
                    //
                    m_pHead = m_pTail = pNode;
                    m_pHead->m_pNext  = NULL;
                    m_pTail->m_pPrev  = NULL;
                }
                else
                {
                    //
                    // The list has one or more Elements
                    //
                    m_pTail->m_pNext = pNode;
                    pNode->m_pPrev   = m_pTail;
                    m_pTail	         = pNode;
                }
                m_cNumOfNodes ++;
            }
        }

        if(pNode)
            (*(*(pNode))).AddRef();
    }
	LeaveCriticalSection(m_pLockSem);

	return pNode;
}


template<class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvElemFromList(
	IN const E &Element
    )
{
    HRESULT     hRes;
	TLstNd<E,C> *pNode = NULL;

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes)
        {
            //
            // Is this the last element in the List
            //
            if(m_pTail && *m_pTail == Element)
            {
                pNode   = m_pTail;
                m_pTail = m_pTail->m_pPrev;
                if(m_pTail)
                {
                    m_pTail->m_pNext = NULL;
                }
            }
            else if(m_pHead && *m_pHead == Element)
            {
                pNode   = m_pHead;
                m_pHead = m_pHead->m_pNext;
                if(m_pHead)
                {
                    m_pHead->m_pPrev = NULL;
                }
            }
            else
            {
                for(pNode = m_pHead->m_pNext;
                    (pNode &&
                    !(*pNode == Element));
                    pNode = pNode->m_pNext)
                {
                    //
                    // Nothing , we just want to find the 
                    // target node.
                    //
                }
                if(pNode)
                {
                    pNode->m_pPrev->m_pNext = pNode->m_pNext;
                    pNode->m_pNext->m_pPrev = pNode->m_pPrev;
                }
            }
        }
        if(pNode)
        {
            if(!--m_cNumOfNodes)
            {
                m_pHead = m_pTail = NULL;
            }

            delete pNode;
            hRes = S_OK;
        }
        else
        {
            //
            // If we reach this stage then the element 
            // in the list { May be a better error code
            // should be returned TBD}
            //
            hRes = E_INVALIDARG; 
        }
    }
    LeaveCriticalSection(m_pLockSem);

	return hRes;
}


template<class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvElemFromList(
	IN const C &ElementMember
    )
{
	HRESULT hRes;
	if(!m_bUnique)
	{
        //
        // In case of nonunique entries, we cann't really
        // perform the operation.
        // Are we going to DecRef only... I guess the way
        // it is now is better.
        //
		hRes = E_NOINTERFACE;
	}
	else
	{
		TLstNd<E,C> *pNode = NULL;

		EnterCriticalSection(m_pLockSem);
        {
            if(m_cNumOfNodes)
            {
                //
                // Is this the last element in the List
                //
                if(m_pTail && *m_pTail == ElementMember)
                {
                    pNode = m_pTail;
                }
                else if(m_pHead && *m_pHead == ElementMember)
                {
                    pNode = m_pHead;
                }
                else
                {
                    for(pNode = m_pHead->m_pNext;
                        (pNode &&
                        !(*pNode == ElementMember));
                        pNode = pNode->m_pNext)
                    {
                        // 
                        // Nothing except detecting the
                        // required node
                        //
                    }
                }
            }
            if(pNode)
            {
                if(!(*(*pNode)).Release())
                {
                    //
                    // We have to do this in order to prevent deleting the
                    // data if it was already deleted in the release;
                    //
                    pNode->SetNodeData(static_cast<E*>(NULL));
                    if(pNode == m_pTail)
                    {
                        m_pTail = m_pTail->m_pPrev;

                        if(m_pTail)
                        {
                            m_pTail->m_pNext = NULL;
                        }
                    }
                    else if(m_pHead == pNode)
                    {
                        m_pHead = m_pHead->m_pNext;

                        if(m_pHead)
                        {
                            m_pHead->m_pPrev = NULL;
                        }
                    }
                    else
                    {
                        pNode->m_pPrev->m_pNext = pNode->m_pNext;
                        pNode->m_pNext->m_pPrev = pNode->m_pPrev;
                    }
                    delete pNode;
                    if(!--m_cNumOfNodes)
                    {
                        m_pHead = m_pTail = NULL;
                    }
                    hRes = S_OK;
                }
            }
            else
            {
                //
                // If we reach this stage then the element 
                // in the list { May be a better error code
                // should be returned TBD}
                //
                hRes = E_INVALIDARG; 
            }
        }
		LeaveCriticalSection(m_pLockSem);
	}
	return hRes;
}


template <class E,class C>
HRESULT 
TLstMgr<E,C> ::
RmvElemAtPosFromList(
    IN DWORD Index
	)
{
	TLstNd<E,C> *pNode = NULL;
    HRESULT     hRes;    

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes && 
           Index >= 0    && 
           Index <= (m_cNumOfNodes-1))
        {
            //
            // Is this the last element in the List
            //
            if(Index == 0)
            {
                pNode   = m_pTail;
                m_pTail = m_pTail->m_pPrev;
                if(m_pTail)
                {
                    m_pTail->m_pNext = NULL;
                }
            }
            else if(Index == (m_cNumOfNodes-1))
            {
                pNode   = m_pHead;
                m_pHead = m_pHead->m_pNext;
                if(m_pHead)
                {
                    m_pHead->m_pPrev = NULL;
                }
            }
            else
            {
                DWORD InternalIndex = 1;

                for(pNode = m_pHead->m_pNext;
                    (pNode &&
                    (InternalIndex < Index));
                    pNode = pNode->m_pNext,
                    InternalIndex ++)
                {
                    //
                    // Nothing but detect the node
                    //
                }
                if(pNode)
                {
                    Temp->m_pPrev->m_pNext = pNode->m_pNext;
                    Temp->m_pNext->m_pPrev = pNode->m_pPrev;
                }
            }
        }
        if(pNode)
        {
            if(!--m_cNumOfNodes)
            {
                m_pHead = m_pTail = NULL;
            }

            delete pNode;
            hRes = S_OK;
        }
        else
        {
            //
            // If we reach this stage then the element 
            // is not in the list { May be a better 
            // error code should be returned TBD}
            //
            hRes = E_INVALIDARG; 
        }
    }
    LeaveCriticalSection(m_pLockSem);
	return hRes;
}


template <class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvHead(
    VOID
    )
{
    return RmvElemAtPosFromList(0);
}


template <class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvTail(
    VOID
    )
{
    return RmvElemAtPosFromList((m_cNumOfNodes-1));
}


template <class E,class C>
BOOL
TLstMgr<E,C> ::
HaveElements(
    VOID
    ) const
{
    return !!m_cNumOfNodes;
}


template <class E,class C>
DWORD
TLstMgr<E,C> ::
GetNumOfListNodes(
    VOID
    ) const
{
    return m_cNumOfNodes;
}


/********************************/
/*   List Node Implementation   */
/********************************/


template <class E,class C>
TLstNd<E,C> ::
TLstNd() :
	m_pPrev(NULL) ,
	m_pNext(NULL) 
{
    m_pD = new E;
}


template <class E,class C>
TLstNd<E,C> ::
TLstNd(
    IN const TLstNd<E,C> &N
    ) :
    m_pPrev(N.m_pPrev),
    m_pNext(N.m_pNext)
{
    m_pD = new E(N.D);
}


template <class E,class C>
TLstNd<E,C> ::
TLstNd(
	IN const E &Element
    ) :
	m_pPrev(NULL),
	m_pNext(NULL)
{
    m_pD = new E(Element);
}

template <class E,class C>
TLstNd<E,C> ::
TLstNd(
	IN E *Element
    ) :
	m_pPrev(NULL),
	m_pNext(NULL)
{
    m_pD = Element;
}



template <class E,class C>
TLstNd<E,C> ::
TLstNd(
	IN const C &ElementMember
    ) :
	m_pPrev(NULL),
	m_pNext(NULL)
{
    m_pD = new E(ElementMember);
}


template <class E,class C>
TLstNd<E,C> ::
~TLstNd()
{
    //
    // Implicitly the destructor for 
    // the maintained element would be 
    // called
    //
	if(m_pD)
    {
		delete m_pD;
    }
}


template <class E,class C>
const E&
TLstNd<E,C> ::
operator=(
    IN const E &Element
    )
{
    if(this->m_pD != &Element)
    {
        *m_pD = Element;
    }

    return *(this->m_pD);
}


template <class E,class C>
BOOL 
TLstNd<E,C> ::
operator==(
    IN const E &Element
    ) const
{
    return *m_pD == Element;
}


template <class E,class C>
BOOL
TLstNd<E,C> ::
operator==(
    const C &ToCompare
    ) const
{
    return *m_pD == ToCompare;
}


template <class E,class C>
E&
TLstNd<E,C> ::
operator*()
{
    return *m_pD;
}


template <class E,class C>
E*
TLstNd<E,C> ::
SetNodeData(
	IN E *pNewD
	)
{
	//
	// In some cases where the data is ref counted
	// it might be a good idea to Nullify this pointer
	// once the data ref reaches 0 (as this implies)
	// that it was deleted. No need to delete it once
	// more. We also return a pointer to the old node
	// data
	//
	E *pOldD = m_pD;

	m_pD = pNewD;

	return pOldD;
}

#endif //__COLLMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\drvevnt.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     drvevnt.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation for the Driver
     Event class                                                                              
     
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __DRVEVNT_HPP__
#include "drvevnt.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


/* -------------------------------------- */
/* Implemetation of class PrinterEvnetMgr */
/* -------------------------------------- */


/*++
    Function Name:
        TPrinterEventMgr :: TPrinterEventMgr
     
    Description:
        Constructor of the Printer(Driver) Event object
     
    Parameters:
        TLoad64BitDllsMgr* : Pointer to the main loader object
                             which manage the process
        
    Return Value:
        None
--*/
TPrinterEventMgr::
TPrinterEventMgr(
    IN TLoad64BitDllsMgr *pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    TClassID("TPrinterEventMgr")
{
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TPrinterEventMgr :: ~TPrinterEventMgr
     
    Description:
        Destructor of the Printer(Driver) Event object    
     
    Parameters:
        None        
        
    Return Value:
        None
--*/
TPrinterEventMgr::
~TPrinterEventMgr(
    VOID
    )
{
    m_pLdrObj->Release();
}


/*++
    Function Name:
        TPrinterEventMgr :: SpoolerPrinterEvent
     
    Description:
        Calls into the driver DrvPrinterEvent entry point
     
    Parameters:
        PrinterName  : The name of the printer involved
        PrinterEvent : What happened
        Flags        : Misc. flag bits
       lParam        : Event specific parameters        
       
    Return Value:
        BOOL         : TRUE  in case of success
                     : FALSE in case of failure
--*/
BOOL
TPrinterEventMgr ::
SpoolerPrinterEvent(
    IN  LPWSTR pszPrinterName,
    IN  int    PrinterEvent,
    IN  DWORD  Flags,
    IN  LPARAM lParam,
    OUT PDWORD pErrorCode
    )
{
     HANDLE             hPrinter, hDriver;
     BOOL               ReturnValue=FALSE;
     PFNDRVPRINTEREVENT pfn;

     SPLASSERT(m_pLdrObj);

     m_pLdrObj->RefreshLifeSpan();

     if (OpenPrinter((LPWSTR)pszPrinterName, &hPrinter, NULL))
     {
          if(hDriver = LoadPrinterDriver(hPrinter))
          {
               if (pfn = (PFNDRVPRINTEREVENT)GetProcAddress(hDriver,
                                                            "DrvPrinterEvent"))
               {
                   __try
                   {
                        ReturnValue = (*pfn)( pszPrinterName, PrinterEvent, Flags, lParam );
                   }
                   __except(1)
                   {
                       *pErrorCode = GetExceptionCode();
                   }
               }
               else
               {
                    *pErrorCode = GetLastError();
               }
               FreeLibrary(hDriver);
          }
          else
          {
               *pErrorCode = GetLastError();
          }
          ClosePrinter(hPrinter);
     }
     else
     {
          *pErrorCode = GetLastError();
     }

     return  ReturnValue;
}


/*++
    Function Name:
        TPrinterEventMgr :: DocumentEvent
     
    Description:
        Calls into the driver DrvDocumentEvent entry point
     
    Parameters:
        PrinterName  : The name of the printer involved
        InDC         : The printer DC. 
        EscapeCode   : Why this function is called 
        InSize,      : Size of the input buffer
        InBuf,       : Pointer to the input buffer
        OutSize,     : Size of the output buffer
        OutBuf,      : Pointer to the output buffer
        ErrorCode    : output Last Error from operation
                    
       
    Return Value:
        DOCUMENTEVENT_SUCCESS     : success
        DOCUMENTEVENT_UNSUPPORTED : EscapeCode is not supported
        DOCUMENTEVENT_FAILURE     : an error occured
--*/
int
TPrinterEventMgr ::
DocumentEvent(
    IN  LPWSTR      pszPrinterName,
    IN  ULONG_PTR   InDC,
    IN  int         EscapeCode,
    IN  DWORD       InSize,
    IN  LPBYTE      pInBuf,
    OUT PDWORD      pOutSize,
    OUT LPBYTE      *ppOutBuf,
    OUT PDWORD      pErrorCode
    )          
{
     HANDLE              hPrinter, hDriver;
     int                 ReturnValue=0;
     PFNDRVDOCUMENTEVENT pfn;
     HDC                 hDC = reinterpret_cast<HDC>(InDC);

     SPLASSERT(m_pLdrObj);

     m_pLdrObj->RefreshLifeSpan();

     if (OpenPrinter((LPWSTR)pszPrinterName, &hPrinter, NULL))
     {
          if(hDriver = LoadPrinterDriver(hPrinter))
          {
               if (pfn = (PFNDRVDOCUMENTEVENT)GetProcAddress(hDriver,
                                                             "DrvDocumentEvent"))
               {
                   __try
                   {
                       ULONG cbOut = sizeof(ULONG);
                       PDEVMODEW pOut = NULL;
                       ReturnValue = (*pfn)( hPrinter,
                                             (HDC)InDC,
                                             EscapeCode,
                                             (ULONG)InSize,
                                             (PVOID)pInBuf,
                                             cbOut,
                                             (PVOID)&pOut);
                       if(ReturnValue != -1 && 
                          pOut)
                       {
                           *pOutSize = pOut->dmSize + pOut->dmDriverExtra;
                           if(*ppOutBuf  = new BYTE[*pOutSize])
                           {
                                memcpy(*ppOutBuf,pOut,*pOutSize);
                           }
                           else
                           {
                                *pErrorCode = ERROR_OUTOFMEMORY;
                           }
                           //
                           // Now what should I do about the memory allocated
                           // for pOut ????
                           //
                       }
                   }
                   __except(1)
                   {
                       SetLastError(GetExceptionCode());
                   }
               }
               FreeLibrary(hDriver);
          }
          else
          {
              *pErrorCode = GetLastError();
          }
          ClosePrinter(hPrinter);
     }
     else
     {
         *pErrorCode = GetLastError();
     }

     return  ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\drvevnt.hpp ===
#ifndef __DRVENVT_HPP__
#define __DRVEVNT_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of the class
     dealing with various Driver Events namely
     o DrvDocumentEvent
     o DrvPrinterEvent
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TPrinterEventMgr : public TClassID,
                         public TLd64BitDllsErrorHndlr,
                         public TRefCntMgr,
                         public TPrinterDriver
{
     public:

     TPrinterEventMgr(
         IN TLoad64BitDllsMgr *pIpLdrObj
         );

     ~TPrinterEventMgr(
         VOID
         );

     BOOL 
     SpoolerPrinterEvent(
         IN  LPWSTR pszPrinterName,
         IN  int    PrinterEvent,
         IN  DWORD  Flags,
         IN  LPARAM lParam,
         OUT PDWORD pErrorCode
         );

     int
     DocumentEvent(
         IN  LPWSTR      pszPrinterName,
         IN  ULONG_PTR   InDC,
         IN  int         EscapeCode,
         IN  DWORD       InSize,
         IN  LPBYTE      pInBuf,
         OUT PDWORD      pOutSize,
         OUT LPBYTE      *ppOutBuf,
         OUT PDWORD      pErrorCode
         );


     private:
     TLoad64BitDllsMgr   *m_pLdrObj;
};

#endif //__DRVENVT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\gdithnk.hpp ===
#ifndef __GDITHNK_HPP__
#define __GDITHNK_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     gdithnk.hpp                                                             
                                                                              
  Abstract:                                                                   
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
--*/

typedef struct PROXYMSG {
    PORT_MESSAGE    h;
    ULONG           cjIn;
} SPROXYMSG, *PSPROXYMSG;

struct PROXYMSGEXTENSION
{
    ULONG  cjIn;
    PVOID  pvIn;
    ULONG  cjOut;
    PVOID  pvOut;
};
typedef struct PROXYMSGEXTENSION SPROXYMSGEXTENSION , *PSPROXYMSGEXTENSION;

struct PROXY_MSG
{
    PORT_MESSAGE Msg;
    CCHAR        MsgData[ sizeof(SPROXYMSGEXTENSION) ];
};
typedef struct PROXY_MSG SPROXY_MSG , *PSPROXY_MSG;

struct  LPCMSGSTHRDDATA
{
    PVOID  pData;
};
typedef LPCMSGSTHRDDATA SLPCMSGSTHRDDATA,*PSLPCMSGSTHRDDATA;

struct REQUESTTHRDDATA
{
    PVOID    p;
    HANDLE   PortHandle;
};
typedef REQUESTTHRDDATA SREQUESTTHRDDATA,*PSREQUESTTHRDDATA;

EXTERN_C
DWORD
LPCRequestsServingThread(
    PVOID pThrdData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\collmgr.hpp ===
#ifndef __COLLMGR_HPP__
#define __COLLMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     collmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
    This file contains the declaration of a generic
    linked list which could encapsulate any data type
    even if complex ones. The list is defined as a 
    manager and a node. The manager manages the given
    nodes of that type.
                                                                                       
  Author:                                                                     
     Khaled Sedky (khaleds) 21-Jun-2000                                        
     
                                                                             
  Revision History:            
--*/

#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


//
// Forward Declarations
//
template <class E,class C> class TLstNd;
template <class E,class C> class TLstMgr;

//
//  E here is the element and C is a major content in this element.
//  or in other words the index of the element . It could be described
//  as the component by which the element is created or by which it
//  is compared against.C is the type used as a key for comparisons.
//

template <class E,class C> class TLstNd
{
    //
    // Public methods of the class
    //
    public:

    friend class TLstMgr<E,C>;

    TLstNd<E,C>(
        VOID
        );

    //
    // Copy Constructor
    //
    TLstNd<E,C>(
        IN CONST TLstNd<E,C>&
        );

    //
    // Copy constructor based on the Element saved 
    // in the list
    //
    TLstNd<E,C>(
        IN const E&
        );

    TLstNd<E,C>(
        IN E*
        );

    //
    // A Copy constructor based on the 
    // component
    //
	TLstNd<E,C>(
		IN const C&
		);

    ~TLstNd<E,C>(
        VOID 
        );

    const E& 
    operator=(
        IN const E&
        );

    BOOL 
    operator==(
        IN const E&
        ) const; 

    BOOL 
    operator==(
        IN const C&
        ) const; 
    
    E&
    operator*(
        VOID
        );

	E*
	SetNodeData(
		IN E*
		);

    //
    // Private members and helper functions (if any)
    //
    private:
    E*            m_pD;
    TLstNd<E,C>   *m_pNext;
    TLstNd<E,C>   *m_pPrev;
};


template <class E,class C> class TLstMgr :  public TClassID,
                                            public TLd64BitDllsErrorHndlr
{
    //
    // Public methods of the class
    //
    public:

    friend TLstNd<E,C>;

    //
    // To optimize the overhead of allocating
    // and Freeing memroy , the user of this
    // class might resort to using the FreeList
    // support which enable him to recycle nodes 
    // when they are not longer required.
    //
    enum EListType
    {
        KFreeListSupport,
        KNoFreeListSupport,
    };

    //
    // Based on the index of the collection, Entries,
    // maybe or may not be unique. Based on this Flag
    // being set in the constructor, the List search
    // criteria is decided and so is the Appending 
    // algorithm
    //
    enum EEntriesType
    {
        KUniqueEntries    = 0,
        KNonUniqueEntries
    };

    TLstMgr<E,C>(
        IN      TLstMgr<E,C>::EEntriesType ThisListEntriesType = TLstMgr<E,C>::KNonUniqueEntries,
        IN      TLstMgr<E,C>::EListType    ThisListType        = TLstMgr<E,C>::KNoFreeListSupport,
        IN OUT  HRESULT*                   hRes                = NULL
        );
    
    ~TLstMgr<E,C>(
        VOID
        );

    TLstNd<E,C>* 
    AppendListByElem(
        IN const E&
        );

    TLstNd<E,C>* 
    AppendListByElem(
        IN E*
        );

    TLstNd<E,C>* 
    AppendListByElem(
	    IN const C &
        );

    HRESULT
    RmvElemFromList(
        IN const E&
        );
	
	HRESULT
	RmvElemFromList(
		IN const C&
		);


	HRESULT 
	RmvElemAtPosFromList(
		IN DWORD 
		);


    HRESULT
    RmvTail(
        VOID
        );

    HRESULT
    RmvHead(
        VOID
        );

    HRESULT
    DestructList(
        VOID
        );

    E&
    GetElementAtPos(
        IN DWORD 
        ) const;

    E*
    GetElementAtPosByRef(
        IN DWORD 
        ) const;

    E&
    operator[](
        IN DWORD
        ) const;

	TLstNd<E,C>*
    ElementInList(
        IN const C&
        ) const;

    BOOL 
    HaveElements(
        VOID
        ) const;

    DWORD
    GetNumOfListNodes(
        VOID
        ) const;

    
    //
    // Private members and helper functions (if any)
    //
    private:

    TLstNd<E,C>      *m_pHead;
    TLstNd<E,C>      *m_pTail;
    DWORD            m_cNumOfNodes;
    BOOL             m_bUnique;
    //
    // To protect the linked list data members
    // in a multithread environment.
    //
    CRITICAL_SECTION *m_pLockSem;
};


template <class E,class C> class TLstItrtr : public TClassID
{
    public:

    TLstItrtr<E,C>(
        IN const TLstMgr<E,C>&
        );

    ~TLstItrtr<E,C>();

    TLstNd<E,C>&
    operator*(
        VOID             
        );

    TLstNd<E,C>&
    operator++(
        VOID             
        );

    const
    TLstNd<E,C>
    operator++(
        int
        );

    TLstNd<E,C>&
    operator--(
        VOID             
        );

    const
    TLstNd<E,C>
    operator--(
        int
        );
    
    private:
    TLstMgr<E,C>    *m_pItrtdMgrPrxy;
    TLstNd<E,C>     *m_pCrntNode;
};


//
// This is an abstract class which never 
// get instantiated. Any Element other than
// primitive Data types , has to inherit from
// this class . There are some mandatory
// methods that need to be implemented
//

class TGenericElement : public TRefCntMgr
{
	public:
    //
    // A BOOL variable indicating Validity
    // of the object should be defined here.
    // This should be set by SetValidity and
    // queried by Validate.
    //
	TGenericElement()
    {};

    //
    // We internally create the elements in
    // the list to be independent of the client
    // and that is when we call the equal operator
    //
/*    virtual const TGenericElement&
    operator=(
        IN const TGenericElement&
	   );

    //
    // Since many of the interfaces supplied by the
    // List Manager rely on comparisons between the
    // internally maintained elements , so we need 
    // an == opoperator and a ! operator.
    //
    virtual BOOL 
    operator==(
        IN const TGenericElement&
	   ) const;

    virtual BOOL
    operator!(
        VOID
        ) const;*/

    //
    // Some times we might return a dummy invalid 
    // element to invalidate the result of a list
    // manager method
    //
    virtual VOID 
    SetValidity(
        IN DWORD
        ) = 0;

    virtual BOOL
    Validate(
        VOID
        ) const = 0;
};

//
// Since our iimplementation of C++ does not have a #pragma implementation , 
// so I am including the implementation file directly in the header file
//
#include "collmgr.cxx"

#endif //__COLLMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\gdithnk.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     gdithnk.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the startup code for the
     surrogate rpc server used to load 64 bit dlls
     in 32 bit apps
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

#ifndef __GDITHNK_HPP__
#include "gdithnk.hpp"
#endif


/*++
    Function Name:
        LPCConnMsgsServingThread
     
    Description:
        This funciton is the main loop for processing LPC requests
        by dispatching them to the LPC handler which takes the proper
        action according to the request.
        This function runs in a Thread of its own.
     
     Parameters:
        pThredData  : The Thread specific data which encapsulates the 
                      pointer to the LPC handler.
        
     Return Value
        Always returns 1
--*/
EXTERN_C
DWORD
LPCConnMsgsServingThread(
    PVOID pThrdData
    )
{
    //
    // Communication Port Handles are unique , i.e. one per 
    // Client Server conversation
    //
    HANDLE       ConnectionPortHandle;
    NTSTATUS     Status                    = STATUS_SUCCESS;
    DWORD        ErrorCode                 = ERROR_SUCCESS;
    PVOID        pCommunicationPortContext = NULL;

    SPROXY_MSG   RequestMsg;
    PSPROXY_MSG  pReplyMsg;

    //
    // reconstruct the Data passed in for the Thread
    //
    TLPCMgr*   pMgrInst  = reinterpret_cast<TLPCMgr*>((reinterpret_cast<PSLPCMSGSTHRDDATA>(pThrdData))->pData);

    SPLASSERT(pMgrInst);

    ConnectionPortHandle  = pMgrInst->GetUMPDLpcConnPortHandle();

    for(pReplyMsg=NULL,memset(&RequestMsg,0,sizeof(SPROXY_MSG));
        pMgrInst;)
    {
        //
        // Data sent back to client and then call blocked until another message
        // comes in
        //
        Status = NtReplyWaitReceivePort( ConnectionPortHandle,
                                         reinterpret_cast<PVOID*>(&pCommunicationPortContext),
                                         reinterpret_cast<PPORT_MESSAGE>(pReplyMsg),
                                         reinterpret_cast<PPORT_MESSAGE>(&RequestMsg)
	                                   );
        
        DBGMSG(DBG_WARN,
               ("LPCConnMsgsServingThread Active \n"));

        ConnectionPortHandle = pMgrInst->GetUMPDLpcConnPortHandle();
		pReplyMsg            = NULL;
        

        if(NT_SUCCESS(Status))
        {
            switch(RequestMsg.Msg.u2.s2.Type)
            {

                //
                // For a Connection Request coming from the Client
                //
                case LPC_CONNECTION_REQUEST:
                {
                    pMgrInst->ProcessConnectionRequest((PPORT_MESSAGE)&RequestMsg);
                    break;
                }
  
                //
                // For a Data Request coming in from the client
                //
                case LPC_REQUEST:
                {

                    if((ErrorCode = pMgrInst->ProcessRequest(&RequestMsg)) == ERROR_SUCCESS)
                    {
                         pReplyMsg = &RequestMsg;
                    }
                    //
                    // We retrieve the coomunication handle from LPC becauce this is how we send data
                    // back to the client. We can't used a connection port
                    //
                    ConnectionPortHandle = (reinterpret_cast<TLPCMgr::TClientInfo*>(pCommunicationPortContext))->GetPort();
                    break;
                }
  
                //
                // When the client close the port.
                //
                case LPC_PORT_CLOSED:
                {
					if(pCommunicationPortContext)
					{
                        HANDLE hPortID = 
                               (reinterpret_cast<TLPCMgr::TClientInfo*>(pCommunicationPortContext))->GetPort();

                        pMgrInst->ProcessPortClosure(&RequestMsg,hPortID);
					}
                    break;
                }
  
                //
                // When the client terminates (Normally or Abnormally)
                //
                case LPC_CLIENT_DIED:
                {
					if(pCommunicationPortContext)
					{
                        pMgrInst->ProcessClientDeath(&RequestMsg);
					}
                    break;
                }
  
                default:
                {
                    //
                    // Basically here we do nothing, we just retrun.
                    //
                    break;
                }
            }
        }
    }
    //
    // Cleaning up the memory allocated before leaving the Thread
    //
    delete pThrdData;
    return 1;
}

EXTERN_C
DWORD
GDIThunkingVIALPCThread(
    PVOID pThrdData
    )
{
    OBJECT_ATTRIBUTES       ObjectAttrib;
    UNICODE_STRING          UString;
    PFNGDIPRINTERTHUNKPROC  pfnThnkFn;
    NTSTATUS                Status                = STATUS_SUCCESS;
    HINSTANCE               hGDI                  = NULL;
    WCHAR                   pszPortName[MAX_PATH] = {0};

    //
    // reconstruct the Data passed in for the Thread
    //
    DWORD   *pErrorCode = &(reinterpret_cast<PSGDIThunkThrdData>(pThrdData))->ErrorCode;
    HANDLE  hSyncEvent  = (reinterpret_cast<PSGDIThunkThrdData>(pThrdData))->hEvent;
    TLPCMgr *pMgrInst   = reinterpret_cast<TLPCMgr*>((reinterpret_cast<PSGDIThunkThrdData>(pThrdData))->pData);

    if(hGDI = LoadLibrary(L"GDI32.DLL"))
    {
        if(pfnThnkFn = reinterpret_cast<PFNGDIPRINTERTHUNKPROC>(GetProcAddress(hGDI,
                                                                               "GdiPrinterThunk")))
        {
            wsprintf(pszPortName,L"%s_%x",GDI_LPC_PORT_NAME,pMgrInst->GetCurrSessionId());

            RtlInitUnicodeString(&UString,
                                 pszPortName);

            InitializeObjectAttributes(&ObjectAttrib,
                                       &UString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtCreatePort(pMgrInst->GetUMPDLPCConnPortHandlePtr(),
                                  &ObjectAttrib,
                                  PORT_MAXIMUM_MESSAGE_LENGTH,
                                  PORT_MAXIMUM_MESSAGE_LENGTH, 
                                  PORT_MAXIMUM_MESSAGE_LENGTH*32
                                 );
            if(NT_SUCCESS(Status))
            {
                //
                // Start processing the LPC messages either in one Thread
                // or multiple Threads
                //
                HANDLE hMsgThrd;
                DWORD  MsgThrdId;

                if(PSLPCMSGSTHRDDATA pLPCMsgData = new SLPCMSGSTHRDDATA)
                {
                    pLPCMsgData->pData = reinterpret_cast<void*>(pMgrInst);

                    pMgrInst->SetPFN(pfnThnkFn);

                    if(hMsgThrd  =  CreateThread(NULL,
                                                 0,
                                                 LPCConnMsgsServingThread,
                                                 (VOID *)pLPCMsgData,
                                                 0,
                                                 &MsgThrdId))
                    {
                        CloseHandle(hMsgThrd);
                    }
                    else
                    {
                        delete pLPCMsgData;
                        *pErrorCode = GetLastError();
                        DBGMSG(DBG_WARN,
                               ("GDIThunkVIALPCThread: Failed to create the messaging thread - %u\n",*pErrorCode));
                    }
                }
                else
                {
                    *pErrorCode = GetLastError();
                    DBGMSG(DBG_WARN,
                           ("GDIThunkVIALPCThread: Failed to allocate memory - %u\n",*pErrorCode));
                }
            }
            else
            {
                *pErrorCode = pMgrInst->MapNtStatusToWin32Error(Status);
                DBGMSG(DBG_WARN,
                       ("GDIThunkVIALPCThread: Failed to create the LPC port - %u\n",Status));
            }
            SetEvent(hSyncEvent);
        }
        else
        {
            *pErrorCode = GetLastError();
            DBGMSG(DBG_WARN,
                   ("GDIThunkVIALPCThread: Failed to get the entry point GdiPrinterThunk - %u\n",*pErrorCode));
        }
    }
    else
    {
        *pErrorCode = GetLastError();
        DBGMSG(DBG_WARN,
               ("GDIThunkVIALPCThread: Failed to load GDI32 - %u\n",*pErrorCode));
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\lderror.hpp ===
#ifndef __LDERROR_HPP__
#define __LDERROR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     lderror.hpp                                                             
                                                                              
  Abstract:                                                                   
     This is a common class declaration which could be used by 
     all classes for translating between differnet Error codes , 
     as those genarated from Win32 , vs those genarated from 
     RPC vesrus those genarated from COM Interfaces
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
--*/

#define HRESULTTOWIN32(hres)                         \
        ((HRESULT_FACILITY(hres) == FACILITY_WIN32)  \
        ? HRESULT_CODE(hres)                         \
        : (hres))



class TLd64BitDllsErrorHndlr
{
     public:

     TLd64BitDllsErrorHndlr(
         VOID
         );

     ~TLd64BitDllsErrorHndlr(
         VOID
         );
 
     HRESULT
     GetLastErrorAsHRESULT(
         VOID
         ) const;
 
     HRESULT
     GetLastErrorAsHRESULT(
         DWORD Error
         ) const;

     DWORD 
     GetLastErrorFromHRESULT(
         IN HRESULT hRes
         ) const;
 
     DWORD
     TranslateExceptionCode(
         IN DWORD ExceptionCode
         ) const;

     DWORD
     MapNtStatusToWin32Error(
         IN NTSTATUS Status
         ) const;
};
      
                 
#endif //__LDERROR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\lddevcap.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation
  All rights reserved.

  Module Name:
     lddevcap.cxx

  Abstract:
     The file contains an array of expected size calculations
     for various DeviceCaps returned by DeviceCapabilites

  Author:
     Khaled Sedky (khaleds) 27 January 2000


  Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include "winddiui.h"

#include <splwow64.h>

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

//
// This array has a length of DC_NUP. If new capabilites
// are introduced , the array has to be appended by these
// values and functions picking up data from this array
// have to be modified. Something important to note, that
// although this array is 0 based , the capabilites are 1
// based and so whenever indexing in this array subtract 1
//
DWORD DeviceCapsReqSize[MAX_CAPVAL] =
{
     0,                         //DC_FIELDS            1
     sizeof(WORD),              //DC_PAPERS            2
     sizeof(POINT),             //DC_PAPERSIZE         3
     0,                         //DC_MINEXTENT         4
     0,                         //DC_MAXEXTENT         5
     sizeof(WORD),              //DC_BINS              6
     0,                         //DC_DUPLEX            7
     0,                         //DC_SIZE              8
     0,                         //DC_EXTRA             9
     0,                         //DC_VERSION           10
     0,                         //DC_DRIVER            11
     24*sizeof(WCHAR),          //DC_BINNAMES          12
     2*sizeof(LONG),            //DC_ENUMRESOLUTIONS   13
     64*sizeof(WCHAR),          //DC_FILEDEPENDENCIES  14
     0,                         //DC_TRUETYPE          15
     64*sizeof(WCHAR),          //DC_PAPERNAMES        16
     0,                         //DC_ORIENTATION       17
     0,                         //DC_COPIES            18
     0,                         //DC_BINADJUST         19
     0,                         //DC_EMF_COMPLIANT     20
     0,                         //DC_DATATYPE_PRODUCED 21
     0,                         //DC_COLLATE           22
     0,                         //DC_MANUFACTURER      23
     0,                         //DC_MODEL             24
     32*sizeof(WCHAR),          //DC_PERSONALITY       25
     0,                         //DC_PRINTRATE         26
     0,                         //DC_PRINTRATEUNIT     27
     0,                         //DC_PRINTERMEM        28
     64*sizeof(WCHAR),          //DC_MEDIAREADY        29
     0,                         //DC_STAPLE            30
     0,                         //DC_PRINTRATEPPM      31
     0,                         //DC_COLORDEVICE       32
     sizeof(DWORD),             //DC_NUP               33
     64*sizeof(WCHAR),          //DC_MEDIATYPENAMES    34
     sizeof(DWORD),             //DC_MEDIATYPES        35
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldfuncs.hpp ===
#ifndef __LDFUNCS_HPP__
#define __LDFUNCS_HPP__

#include <wingdip.h>

typedef 
BOOL 
(WINAPI *PFNMONITORFNS)(
    PCWSTR,
    HWND,
    PCWSTR
    );

typedef 
BOOL 
(WINAPI *PFNMONITORADD)(
    PCWSTR,
    HWND,
    PCWSTR,
    PWSTR*
    );

typedef 
int 
(FAR WINAPI *INT_FARPROC)(
    HANDLE,
    PWSTR,
    WORD,
    PVOID,
    PDEVMODE
    );

typedef 
ULONG 
(*PFNGDIPRINTERTHUNKPROC)(
    UMTHDR*,
    PVOID,
    ULONG
    );

typedef 
VOID 
(FAR WINAPI *PFNPRINTUIMETHOD)(
    HWND,
    LPCWSTR,
    INT,
    LPARAM
    );

typedef 
BOOL 
(FAR WINAPI *PFNDRVPRINTEREVENT)(
    LPWSTR,
    int,
    DWORD,
    LPARAM
    );

typedef 
INT 
(FAR WINAPI *PFNDRVDOCUMENTEVENT)(
    HANDLE,
    HDC,
    INT,
    ULONG,
    PVOID,
    ULONG,
    PVOID
    );

typedef 
LONG 
(FAR WINAPI *PFNDOCPROPSHEETS)(
    PPROPSHEETUI_INFO  pCPSUIInfo,
    LPARAM             lParam
    );

typedef 
LONG 
(FAR WINAPI *PFNDEVICEPROPSHEETS)(
    PPROPSHEETUI_INFO  pCPSUIInfo,
    LPARAM             lParam
    );

typedef 
LONG 
(FAR WINAPI *PFNCALLCOMMONPROPSHEETUI)(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

typedef 
LONG 
(FAR WINAPI *PFNPRINTUIDOCUMENTPROPERTIES)(
    HWND,
    HANDLE,
    LPWSTR,
    PDEVMODE,
    PDEVMODE,
    DWORD,
    DWORD
    );

typedef
BOOL
(FAR WINAPI *PFNPRINTUIPRINTERSETUP)(
    HWND,    
    UINT,    
    UINT,    
    LPWSTR,  
    UINT*,   
    LPCWSTR
    );

LONG
DocumentPropertySheets(
    IN PPROPSHEETUI_INFO   pCPSUIInfo,
    IN LPARAM              lParam
    );

EXTERN_C
DWORD
GDIThunkingVIALPCThread(
    IN PVOID pData
    );

enum EPortOp
{
    KConfigurePortOp = 0,
    KDeletePortOp,
    KAddPortOp
};

struct SGDITHNKTHRDDATA
{
    ULONG_PTR*  pData;
    HANDLE      hEvent;
    DWORD       ErrorCode;
};
typedef struct SGDITHNKTHRDDATA SGDIThnkThrdData,*PSGDIThunkThrdData;

#endif //__LDFUNCS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\lderror.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     lderror.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the methods and class implementation 
     necessary for the RPC surrogate used to load 64 bit dlls from
     within 32 bit apps.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

LONG ErrorMap[] = {
                    STATUS_INVALID_PARAMETER,             ERROR_INVALID_PARAMETER,
                    STATUS_INVALID_PORT_ATTRIBUTES,       ERROR_INVALID_PARAMETER,
                    STATUS_OBJECT_PATH_INVALID,           ERROR_BAD_PATHNAME,
                    STATUS_OBJECT_PATH_NOT_FOUND,         ERROR_PATH_NOT_FOUND,
                    STATUS_OBJECT_PATH_SYNTAX_BAD,        ERROR_BAD_PATHNAME,
                    STATUS_OBJECT_NAME_INVALID,           ERROR_INVALID_NAME,
                    STATUS_OBJECT_NAME_COLLISION,         ERROR_ALREADY_EXISTS,
                    STATUS_NO_MEMORY,                     ERROR_NOT_ENOUGH_MEMORY
                  };


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: TLd64BitDllsErrorHndlr
     
    Description:
        Constructor of Error Handler object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/

TLd64BitDllsErrorHndlr ::
TLd64BitDllsErrorHndlr(
    VOID
    )
{
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: ~TLd64BitDllsErrorHndlr
     
    Description:
        Destructor of Error Handler object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TLd64BitDllsErrorHndlr ::
~TLd64BitDllsErrorHndlr(
    VOID
    )
{
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: GetLastErrorAsHRESULT
     
    Description:
        Converts GetLastError to HRESULT. 
             
     Parameters:
        None
        
     Return Value:
        HRESULT : LastError as HRESULT
--*/
HRESULT
TLd64BitDllsErrorHndlr ::
GetLastErrorAsHRESULT(
    VOID
    ) const
{
    DWORD Error = GetLastError();

    return HRESULT_FROM_WIN32(Error);
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: GetLastErrorAsHRESULT
     
    Description:
        Converts Input Win32 Error Code to HRESULT. 
             
     Parameters:
        DWORD : Win32 ErrorCode
        
     Return Value:
        HRESULT : Win32 ErrorCode as HRESULT
--*/
HRESULT 
TLd64BitDllsErrorHndlr ::
GetLastErrorAsHRESULT(
    IN DWORD Error
    ) const
{
    return HRESULT_FROM_WIN32(Error);
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: GetLastErrorFromHRESULT
     
    Description:
        Converts HRESULT to Win32 Error Code. 
             
     Parameters:
        HRESULT : hResult Code
        
     Return Value:
        DWORD : hResult converted to Win32 ErrorCode
--*/
DWORD 
TLd64BitDllsErrorHndlr ::
GetLastErrorFromHRESULT(
    IN HRESULT hRes
    ) const
{
    return HRESULTTOWIN32(hRes);
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: TranslateExceptionCode
     
    Description:
        Filters Exception Codes 
        
     Parameters:
        None
        
     Return Value:
        DWORD: Filtered Exception Code.
--*/
DWORD
TLd64BitDllsErrorHndlr ::
TranslateExceptionCode(
    IN DWORD ExceptionCode
    ) const
{
    DWORD TranslatedException;

    switch (ExceptionCode)
    {
        case EXCEPTION_ACCESS_VIOLATION:
        case EXCEPTION_DATATYPE_MISALIGNMENT:
        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        case EXCEPTION_FLT_DENORMAL_OPERAND:
        case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        case EXCEPTION_FLT_INEXACT_RESULT:
        case EXCEPTION_FLT_INVALID_OPERATION:
        case EXCEPTION_FLT_OVERFLOW:
        case EXCEPTION_FLT_STACK_CHECK:
        case EXCEPTION_FLT_UNDERFLOW:
        case EXCEPTION_INT_DIVIDE_BY_ZERO:
        case EXCEPTION_INT_OVERFLOW:
        case EXCEPTION_PRIV_INSTRUCTION:
        case ERROR_NOACCESS:
        case RPC_S_INVALID_BOUND:
        {
            TranslatedException = ERROR_INVALID_PARAMETER;
            break;
        }

        default:
        {
            TranslatedException = ExceptionCode;
            break;
        }
    }

    return TranslatedException;
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: MapNtStatusToWin32Error
     
    Description:
        Converts NtStatus results to Win32 Error Codes 
        
     Parameters:
        NTSTATUS: NtStatus result
        
     Return Value:
        DWORD: Win32 Error Code.
--*/
DWORD
TLd64BitDllsErrorHndlr ::
MapNtStatusToWin32Error(
    IN NTSTATUS Status
    ) const
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    for (int cNumOfMapEntries = 0;
         cNumOfMapEntries < sizeof(ErrorMap) / sizeof(ErrorMap[0]); 
         cNumOfMapEntries += 2)
    {
        if (ErrorMap[cNumOfMapEntries] == Status)
        {
            ErrorCode = ErrorMap[cNumOfMapEntries+1];
        }
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldintrfcs.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldintrfcs.cpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the GUIDs of all interfaces supported
     by the main DLL loader
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 10-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

// {59A523A7-8C39-4d5c-B519-62F820E66992}
GUID IID_PRINTEREVENT = {0x59a523a7, 
                         0x8c39,
                         0x4d5c,
                         0xb5,
                         0x19,
                         0x62,
                         0xf8,
                         0x20,
                         0xe6,
                         0x69,
                         0x92};

// {D85AE507-5A73-4de9-AA5E-745946BB9509}
GUID IID_PRINTERCONFIGURATION = {0xd85ae507, 
                                 0x5a73,
                                 0x4de9,
                                 0xaa,
                                 0x5e,
                                 0x74,
                                 0x59,
                                 0x46,
                                 0xbb,
                                 0x95,  
                                 0x9};

// {AE96B291-33AD-48bb-8E24-B5902521E34D}
GUID IID_DEVICECAPABILTIES = {0xae96b291,
                              0x33ad,
                              0x48bb,
                              0x8e,
                              0x24,
                              0xb5,
                              0x90,
                              0x25,
                              0x21,
                              0xe3,
                              0x4d};

// {AC8F3E18-FF99-4019-8403-402D83E23B70}
GUID IID_PORTOPERATIONS = {0xac8f3e18,
                           0xff99,
                           0x4019,
                           0x84,
                           0x3,
                           0x40,
                           0x2d,
                           0x83,
                           0xe2,
                           0x3b,
                           0x70};

// {D027CC13-04DE-4379-B072-EB4F8E59AB7A}
GUID IID_DRIVEREVENT={0xd027cc13,
                      0x4de,
                      0x4379,
                      0xb0,
                      0x72,
                      0xeb,
                      0x4f,
                      0x8e,
                      0x59,
                      0xab,
                      0x7a};

// {DDDE8870-322F-405c-B672-67B55F50377B}
GUID IID_PRINTUIOPERATIONS = {0xddde8870,
                              0x322f,
                              0x405c,
                              0xb6,  
                              0x72,  
                              0x67,  
                              0xb5,  
                              0x5f,  
                              0x50,  
                              0x37,  
                              0x7b}; 

// {A5DF592C-C7B0-4793-82CE-BE96B743B33E}
GUID IID_LPCMGR = {0xa5df592c, 
                   0xc7b0, 
                   0x4793, 
                   0x82, 
                   0xce, 
                   0xbe, 
                   0x96, 
                   0xb7, 
                   0x43, 
                   0xb3,
                   0x3e};

// {91F04F3A-C3F8-4f1b-91E2-6D6411914A2E}
GUID IID_PRINTUIPRINTERSETUP = {0x91f04f3a,
                                0xc3f8,
                                0x4f1b,
                                0x91, 
                                0xe2,
                                0x6d,
                                0x64,
                                0x11,
                                0x91,
                                0x4a,
                                0x2e};

// {91F04F3A-C3F8-4f1b-91E2-6D6411914A2E}
GUID IID_PRINTUISERVERPROPPAGES = {0x91f04f3a,
                                   0xc3f8, 
                                   0x4f1b, 
                                   0x91, 
                                   0xe2, 
                                   0x6d, 
                                   0x64, 
                                   0x11, 
                                   0x91, 
                                   0x4a, 
                                   0x2e};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldintrfcs.hpp ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldintrfcs.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the GUIDs of all the Interfaces supported
     by the surrogate process
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 10-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/


#ifndef __LDINTERFACES_HPP__
#define __LDINTERFACES_HPP__

                             
extern GUID IID_PRINTEREVENT;
extern GUID IID_PRINTERCONFIGURATION;                             
extern GUID IID_DEVICECAPABILTIES;
extern GUID IID_PORTOPERATIONS;
extern GUID IID_DRIVEREVENT;
extern GUID IID_PRINTUIOPERATIONS;
extern GUID IID_LPCMGR;
extern GUID IID_PRINTUIPRINTERSETUP;
extern GUID IID_PRINTUISERVERPROPPAGES;

#endif //__LDINTERFACES_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldfuncs.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldfuncs.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation of all the RPC methods 
     supported by the surrogate process and that can be called from a client app.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

#ifndef __LDINTERFACES_HPP__
#include "ldintrfcs.hpp"
#endif 

extern TLoad64BitDllsMgr *pGLdrObj;

/*++
    Function Name:
        RPCSplWOW64RefreshLifeSpan
     
    Description:
        Closing down the window between a client connecting and the server
        dieing 
        
     
     Parameters:
        None
        
     Return Value
        Always 0
--*/
DWORD
RPCSplWOW64RefreshLifeSpan(
    )
{

    pGLdrObj->RefreshLifeSpan();

    return 0;
}

DWORD
RPCSplWOW64GetProcessID(
    )
{
    return GetCurrentProcessId();
}



/*++
    Function Name:
        RPCSplWOW64GetProcessHndl
     
    Description:
        This function returns the process handle of the surrogate
        process to winspool.drv (client in this case). The handle
        is important for the client to monitor the server process
        and know when it dies
     
     Parameters:
        ProcessId  : The process id of the client
        ErrorCode  : contains the error code in case of failure
        
     Return Value
       return the Server Process Handle relative to the client
       process        
--*/
ULONG_PTR
RPCSplWOW64GetProcessHndl(
    IN  DWORD  ProcessId,
    OUT PDWORD pErrorCode
    )
{
    HANDLE hTargetProcess;
    HANDLE hDup = NULL;

    *pErrorCode = ERROR_SUCCESS;

    pGLdrObj->RefreshLifeSpan();

    if(hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE,
                                    TRUE,
                                    (DWORD)ProcessId))
    {
         if(!DuplicateHandle(GetCurrentProcess(),
                             GetCurrentProcess(),
                             hTargetProcess,
                             &hDup,
                             0,
                             FALSE,
                             DUPLICATE_SAME_ACCESS))
         {
             *pErrorCode = GetLastError();
         }
         CloseHandle(hTargetProcess);
    }
    else
    {
         *pErrorCode = GetLastError();
    }
       
    return (ULONG_PTR)hDup;
}


/*++
    Function Name:
        RPCSplWOW64AddPort
     
    Description:
     
    Parameters:
        
     Return Value
--*/
BOOL 
RPCSplWOW64AddPort(
    IN  ULONG_PTR  hWnd,
    IN  LPWSTR     pszServerName,
    IN  LPWSTR     pszUIDllName,
    IN  LPWSTR     pszMonitorName,
    OUT PDWORD     pErrorCode
    )
{
    return(pGLdrObj->ExecuteMonitorOperation(hWnd,
                                             pszServerName,
                                             pszUIDllName,
                                             pszMonitorName,
                                             KAddPortOp,
                                             pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64ConfigurePort
     
    Description:
     
    Parameters:
        
     Return Value
--*/
BOOL 
RPCSplWOW64ConfigurePort(
    IN  ULONG_PTR  hWnd,
    IN  LPWSTR     pszServerName,
    IN  LPWSTR     pszUIDllName,
    IN  LPWSTR     pszPortName,
    OUT PDWORD     pErrorCode
    )
{
    return(pGLdrObj->ExecuteMonitorOperation(hWnd,
                                             pszServerName,
                                             pszUIDllName,
                                             pszPortName,
                                             KConfigurePortOp,
                                             pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64DeletePort
     
    Description:
     
    Parameters:
        
     Return Value
--*/
BOOL 
RPCSplWOW64DeletePort(
    IN  ULONG_PTR hWnd,      
    IN  LPWSTR    pszServerName,
    IN  LPWSTR    pszUIDllName, 
    IN  LPWSTR    pszPortName,  
    OUT PDWORD    pErrorCode  
    )
{
    return(pGLdrObj->ExecuteMonitorOperation(hWnd,
                                             pszServerName,
                                             pszUIDllName,
                                             pszPortName,
                                             KDeletePortOp,
                                             pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64DeviceCapabilities
     
    Description:
     
    Parameters:
        
     Return Value
--*/
int
RPCSplWOW64DeviceCapabilities(
    IN  LPWSTR  pszDeviceName,
    IN  LPWSTR  pszPortName,
    IN  WORD    Capabilites,
    IN  DWORD   DevModeSize,
    IN  LPBYTE  pDevMode,
    IN  BOOL    bClonedOutputFill,
    OUT PDWORD  pClonedOutputSize,
    OUT LPBYTE  *ppClonedOutput,
    OUT PDWORD  pErrorCode
    )
{

    return(pGLdrObj->DeviceCapabilities(pszDeviceName,
                                        pszPortName,
                                        Capabilites,
                                        DevModeSize,
                                        pDevMode,
                                        bClonedOutputFill,
                                        pClonedOutputSize,
                                        ppClonedOutput,
                                        pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64DocumentProperties
     
    Description:
     
    Parameters:
        
     Return Value
--*/
LONG
RPCSplWOW64DocumentProperties(
    IN  ULONG_PTR   hWnd,                   
    IN  LPWSTR      pszPrinterName,            
    OUT PDWORD      pTouchedDevModeSize,     
    OUT PDWORD      pClonedDevModeOutSize,   
    OUT LPBYTE      *ppClonedDevModeOut,       
    IN  DWORD       DevModeSize,            
    IN  LPBYTE      pDevMode,                
    IN  BOOL        bClonedDevModeOutFill,   
    IN  DWORD       fMode,                  
    IN  PDWORD      pErrorCode               
    )
{
    return(pGLdrObj->DocumentProperties(hWnd,
                                        pszPrinterName,
                                        pTouchedDevModeSize,
                                        pClonedDevModeOutSize,
                                        ppClonedDevModeOut,
                                        DevModeSize,
                                        pDevMode,
                                        bClonedDevModeOutFill,
                                        fMode,
                                        pErrorCode));
}

/*++
    Function Name:
        RPCSplWOW64DocumentProperties
     
    Description:
     
    Parameters:
        
     Return Value
--*/
LONG
RPCSplWOW64PrintUIDocumentProperties(
    IN  ULONG_PTR   hWnd,                   
    IN  LPWSTR      pszPrinterName,            
    OUT PDWORD      pTouchedDevModeSize,     
    OUT PDWORD      pClonedDevModeOutSize,   
    OUT LPBYTE      *ppClonedDevModeOut,       
    IN  DWORD       DevModeSize,            
    IN  LPBYTE      pDevMode,                
    IN  BOOL        bClonedDevModeOutFill,   
    IN  DWORD       fMode,                  
    IN  DWORD       fExclusionFlags,
    IN  PDWORD      pErrorCode               
    )
{
    return(pGLdrObj->PrintUIDocumentProperties(hWnd,
                                               pszPrinterName,
                                               pTouchedDevModeSize,
                                               pClonedDevModeOutSize,
                                               ppClonedDevModeOut,
                                               DevModeSize,
                                               pDevMode,
                                               bClonedDevModeOutFill,
                                               fMode,
                                               fExclusionFlags,
                                               pErrorCode));
}

/*++
    Function Name:
        RPCSplWOW64SPrinterProperties
     
    Description:
        Wrapper for TPrinterCfgMgr :: PrinterProperties
     
    Parameters:
        hWnd        : Parent Window
        Printername : Printer Name
        Flag        : Access permissions
        ErrorCode   : Win32 error in case of failure
        
    Return Value:
        BOOL        : FALSE for failure
                      TRUE  for success
--*/
BOOL
RPCSplWOW64PrinterProperties(
    IN  ULONG_PTR   hWnd,
    IN  LPCWSTR     pszPrinterName,
    IN  DWORD       Flag,
    OUT PDWORD      pErrorCode
    )
{
    TPrinterCfgMgr *pPrntrCfgMgrObj = NULL;
    BOOL           RetVal           = FALSE;
    HRESULT        hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTERCONFIGURATION,
                                        reinterpret_cast<VOID **>(&pPrntrCfgMgrObj))) == S_OK)
    {
        SPLASSERT(pPrntrCfgMgrObj);

        if(pPrntrCfgMgrObj)
        {
            RetVal = pPrntrCfgMgrObj->PrinterProperties(hWnd,
                                                        pszPrinterName,
                                                        Flag,
                                                        pErrorCode);
            if(!RetVal)
            {
                 DBGMSG(DBG_WARN, ("TPrinterEventMgr::SpoolerPrinterEvent failed with %u\n",*pErrorCode));
            }
            pPrntrCfgMgrObj->Release();
        }
        else
        {
            *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(E_NOINTERFACE);
        }
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrinterProperties failed in Instantiating a Print Event Object with %u\n",hRes));
        *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return RetVal;
}



/*++
    Function Name:
        RPCSplWOW64SpoolerPrinterEvent
     
    Description:
        Wrapper for TPrinterEventMgr::SpoolerPrinterEvent
     
    Parameters:
        PrinterName  : The name of the printer involved
        PrinterEvent : What happened
        Flags        : Misc. flag bits
        lParam        : Event specific parameters        
       
    Return Value:
        BOOL         : TRUE  in case of success
                     : FALSE in case of failure
--*/
BOOL
RPCSplWOW64SpoolerPrinterEvent(
    IN  LPWSTR pszPrinterName,
    IN  int    PrinterEvent,
    IN  DWORD  Flags,
    IN  LPARAM lParam,
    OUT PDWORD pErrorCode
    )
{
    TPrinterEventMgr *pPrntrEvntMgrObj = NULL;
    BOOL            RetVal            = FALSE;
    HRESULT         hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTEREVENT,
                                        reinterpret_cast<VOID **>(&pPrntrEvntMgrObj))) == S_OK)
    {
        SPLASSERT(pPrntrEvntMgrObj);

        RetVal = pPrntrEvntMgrObj->SpoolerPrinterEvent(pszPrinterName,
                                                       PrinterEvent,
                                                       Flags,
                                                       lParam,
                                                       pErrorCode);
        if (!RetVal)
        {
            DBGMSG(DBG_WARN, ("TPrinterEventgMgr :: PrinterProperties failed with %u\n",*pErrorCode));
        }
        pPrntrEvntMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64SpoolerPrinterEvent failed in Instantiating a Print Event Object with %u\n",hRes));
        *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return RetVal;
}


/*++
    Function Name:
        RPCSplWOW64DocumentEvent
        
    Description:
        Wrapper for TPrinterEventMgr::DocumentEvent    
     
    Parameters:
        PrinterName  : The name of the printer involved
        InDC         : The printer DC. 
        EscapeCode   : Why this function is called 
        InSize,      : Size of the input buffer
        InBuf,       : Pointer to the input buffer
        OutSize,     : Size of the output buffer
        OutBuf,      : Pointer to the output buffer
        ErrorCode    : output Last Error from operation
                    
       
    Return Value:
        DOCUMENTEVENT_SUCCESS     : success
        DOCUMENTEVENT_UNSUPPORTED : EscapeCode is not supported
        DOCUMENTEVENT_FAILURE     : an error occured
--*/
int
RPCSplWOW64DocumentEvent(
    IN  LPWSTR      pszPrinterName,
    IN  ULONG_PTR   InDC,
    IN  int         EscapeCode,
    IN  DWORD       InSize,
    IN  LPBYTE      pInBuf,
    OUT PDWORD      pOutSize,
    OUT LPBYTE*     ppOutBuf,
    OUT PDWORD      pErrorCode
    )
{
    TPrinterEventMgr* pPrntrEvntMgrObj = NULL;
    int              RetVal          = -1;
    HRESULT          hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTEREVENT,
                                       reinterpret_cast<VOID **>(&pPrntrEvntMgrObj))) == S_OK)
    {
        SPLASSERT(pPrntrEvntMgrObj);

        RetVal = pPrntrEvntMgrObj->DocumentEvent(pszPrinterName,
                                                 InDC,
                                                 EscapeCode,
                                                 InSize,
                                                 pInBuf,
                                                 pOutSize,
                                                 ppOutBuf,
                                                 pErrorCode);
        if (RetVal == -1)
        {
            DBGMSG(DBG_WARN, ("TPrinterEventMgr::DocumentEvent failed with %u\n",*pErrorCode));
        }
        pPrntrEvntMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64DocumentEvent failed in Instantiating a Print Event Object with %u\n",hRes));
        *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return RetVal;
}

/*++
    Function Name:
        RPCSplWOW64PrintUIQueueCreate
     
    Description:
        Wrapper for TPrintUIMgr::QueueCreate
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIQueueCreate(
    IN ULONG_PTR   hWnd,
    IN LPCWSTR     pszPrinterName,
    IN INT         CmdShow,
    IN LPARAM      lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD       ErrorCode = ERROR_SUCCESS;
    HRESULT     hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->QueueCreate(reinterpret_cast<HWND>(hWnd),
                                                pszPrinterName,
                                                CmdShow,
                                                static_cast<LPARAM>(lParam)
                                              );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::QueueCreate failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIQueueCreate failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}

/*++
    Function Name:
        RPCSplWOW64PrintUIPrinterPropPages
     
    Description:
        Wrapper for TPrintUIMgr::PrinterPropPages
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIPrinterPropPages(
    IN ULONG_PTR   hWnd,
    IN LPCWSTR     pszPrinterName,
    IN INT         CmdShow,
    IN LPARAM      lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD       ErrorCode = ERROR_SUCCESS;
    HRESULT     hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->PrinterPropPages(reinterpret_cast<HWND>(hWnd),
                                                     pszPrinterName,
                                                     CmdShow,
                                                     static_cast<LPARAM>(lParam)
                                                    );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::PrinterPropPages failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIPrinterPropPages failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}


/*++
    Function Name:
        RPCSplWOW64PrintUIDocumentDefaults
     
    Description:
        Wrapper for TPrintUIMgr::DocumentDefaults
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIDocumentDefaults(
    IN ULONG_PTR    hWnd,
    IN LPCWSTR      pszPrinterName,
    IN INT          CmdShow,
    IN LPARAM       lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD       ErrorCode = ERROR_SUCCESS;
    HRESULT     hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->DocumentDefaults(reinterpret_cast<HWND>(hWnd),
                                                     pszPrinterName,
                                                     CmdShow,
                                                     static_cast<LPARAM>(lParam)
                                                    );

        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::DocumentDefaults failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIDocumentDefaults failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}

/*++

    Function Name:
        RPCSplWOW64PrintUIPrinterSetup
     
    Description:
        Wrapper for TPrintUIMgr::PrinterSetup.
     
    Parameters:
        hwnd            - Parent window.
        uAction         - Action requested (defined in windows\inc16\msprintx.h)
        cchPrinterName  - Length of pszPrinterName buffer.
        pszPrinterName  - Input setup printer name, Output pointer to new printer name
        pcchPrinterName - New length of pszPrinterName on return.
        pszServerName   - Name of server that printer is on.

    Return Value:

        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIPrinterSetup(
    IN     ULONG_PTR   hWnd,
    IN     UINT        uAction,
    IN     UINT        cchPrinterName,
    IN     DWORD       PrinterNameSize,
    IN OUT byte*       pszPrinterName,
       OUT UINT*       pcchPrinterName,
    IN     LPCWSTR     pszServerName
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD        ErrorCode      = ERROR_SUCCESS;
    HRESULT      hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->PrinterSetup(reinterpret_cast<HWND>(hWnd),
                                                 uAction,
                                                 cchPrinterName,
                                                 reinterpret_cast<LPWSTR>(pszPrinterName),
                                                 pcchPrinterName,
                                                 pszServerName
                                                );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::PritnerSetup failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIPrinterSetup failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}


/*++
    Function Name:
        RPCSplWOW64PrintUIServerPropPages
     
    Description:
        Wrapper for TPrintUIMgr::ServerPropPages
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Server name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIServerPropPages(
    IN ULONG_PTR   hWnd,
    IN LPCWSTR     pszServerName,
    IN INT         CmdShow,
    IN LPARAM      lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD        ErrorCode      = ERROR_SUCCESS;
    HRESULT      hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->ServerPropPages(reinterpret_cast<HWND>(hWnd),
                                                    pszServerName,
                                                    CmdShow,
                                                    static_cast<LPARAM>(lParam)
                                                   );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::ServerPropPages failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIServerPropPages failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldmain.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmain.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the startup code for the
     surrogate rpc server used to load 64 bit dlls
     in 32 bit apps
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

#ifndef __LDINTERFACES_HPP__
#include "ldintrfcs.hpp"
#endif 


//
// The global loader pointer used by Threads and RPC functions
// 
TLoad64BitDllsMgr *pGLdrObj;

//
// Initialize Debug spewing
//
MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

BOOL WINAPI 
LogOffHandler(
    DWORD CtrlType
    )
{
    BOOL bAction;

    if((CtrlType == CTRL_LOGOFF_EVENT) ||
       (CtrlType == CTRL_SHUTDOWN_EVENT))

    {
        //
        //  Proceed with the proper termination routine
        //
        bAction = TRUE;
    }
    else
    {
        bAction = FALSE;
    }
    return(bAction);
}



/*++
    Function Name:
        main
     
    Description:
        This function instantiates the main loader object.
     
     Parameters:
        None
        
     Return Value
        None
--*/
void __cdecl main()
{
     HRESULT           hRes = S_FALSE;
     DWORD             RetVal = ERROR_SUCCESS;
     TLoad64BitDllsMgr *NewLdrObj = NULL;

     //
     // Adding our defined HandlerRoutine to deal with 
     // LOGOFF requests. This is inactive at this time. If required
     // remove the comment below.
     //
     /* BOOL bCtrlHndlr = SetConsoleCtrlHandler(LogOffHandler,TRUE);*/

     if((NewLdrObj = new TLoad64BitDllsMgr(&hRes)) && 
        (hRes == S_OK))
     {    
          pGLdrObj = NewLdrObj;

          TLPCMgr*   LPCMgrObj = NULL;

          if((hRes = NewLdrObj->QueryInterface(IID_LPCMGR,
                                               reinterpret_cast<VOID **>(&LPCMgrObj))) == S_OK)
          {
              SPLASSERT(LPCMgrObj);

              LPCMgrObj->SetCurrSessionId(NewLdrObj->GetCurrSessionId());

              if((RetVal = LPCMgrObj->InitUMPDLPCServer()) != ERROR_SUCCESS) 
              {
                  DBGMSG(DBG_WARN, ("InitUMPDLPCServer failed with %u\n",RetVal));
              }
              else
              {
                  if((RetVal = NewLdrObj->Run()) != ERROR_SUCCESS)
                  {
                      DBGMSG(DBG_WARN, ("Failed to run the RPC server with  %u\n",RetVal));
                  }
                  LPCMgrObj->Release();
                  NewLdrObj->Release();
              }
          }
          else
          {
              DBGMSG(DBG_WARN, ("main failed in Instantiating an TLPCMgr object %u\n",hRes));
              RetVal = NewLdrObj->GetLastErrorFromHRESULT(hRes);
          }
     }
     else
     {
          DBGMSG(DBG_WARN, ("SplWOW64 main() failed with %u\n",(hRes == S_OK) ? E_OUTOFMEMORY : hRes));
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldmemmgr.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmemmgr.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the memory management functions for both
     RPC and all objects instantiated within the application
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <rpc.h>
#include <splcom.h>
#include <time.h>
#include "winddiui.h"

#include <splwow64.h>

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t len)
{
     return(new(unsigned char[len]));
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
     delete(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldmgr.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the methods and class implementation 
     necessary for the RPC surrogate used to load 64 bit dlls from
     within 32 bit apps.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop


#ifndef __LDINTERFACES_HPP__
#include "ldintrfcs.hpp"
#endif  __LDINTERFACES_HPP__

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

extern TLoad64BitDllsMgr* pGLdrObj;
extern DWORD              DeviceCapsReqSize[MAX_CAPVAL];

/*++
    Function Name:
        TLoad64BitDllsMgr :: TLoad64BitDllsMgr
     
    Description:
        Constructor of the main Loader Object. Mainly initializes
        the private data of the class and creates whatever resources
        are required
     
     Parameters:
        HRESULT *hRes: Returns result of constructing the object
        
     Return Value:
        None
--*/
TLoad64BitDllsMgr ::
TLoad64BitDllsMgr(
    OUT HRESULT *phRes
    ) :
    m_UIRefCnt(0),
    TClassID("TLoad64BitDllsMgr")
{
    HRESULT hLocalRes   = S_OK;
    HKEY    hPrintKey   = NULL;
    DWORD   ValueSize   = sizeof(DWORD);
    
    //
    // Initializing the time structure before any time
    // calculations
    //
    ZeroMemory(&m_LastTransactionTime,sizeof(SYSTEMTIME));

    //
    // Read the expiration time from the registry
    //
    if((ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    L"System\\CurrentControlSet\\Control\\Print",
                                    &hPrintKey))                                     ||
       (ERROR_SUCCESS != RegQueryValueEx(hPrintKey,
                                         L"SplWOW64TimeOut",
                                         NULL,
                                         NULL,
                                         (LPBYTE) &m_ExpirationTime,
                                         &ValueSize)))
    {
         m_ExpirationTime = KTwoMinutes;
    }
    else
    {
         m_ExpirationTime = m_ExpirationTime * KOneMinute;
    }

    if(hPrintKey)
    {
        RegCloseKey(hPrintKey);
    }

    __try
    {
         DWORD  CurrProcessId = GetCurrentProcessId();
         //
         // Initializing the Critical Section
         //
         InitializeCriticalSection(&m_LdMgrLock);
         //
         // Setting the initial time to that of the process 
         // first instantiation
         //
         GetSystemTime(&m_LastTransactionTime);
         //
         // The Session ID uniquely identifies each process for 
         // both the RPC end point and the LPC port name
         //
         ProcessIdToSessionId(CurrProcessId,&m_CurrSessionId);

         AddRef();
    }
    __except(1)
    {
              hLocalRes = GetLastErrorAsHRESULT(TranslateExceptionCode(GetExceptionCode()));
    }

    if(phRes)
    {
         *phRes = hLocalRes;
    }
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ~TLoad64BitDllsMgr
     
    Description:
        Destructor of the main Loader Object. Mainly fress up any
        allocated resources
     
     Parameters:
        None
        
     Return Value:
        None
--*/
TLoad64BitDllsMgr ::
~TLoad64BitDllsMgr()
{
     DeleteCriticalSection(&m_LdMgrLock);
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: QueryInterface
     
    Description:
        Returned the correct object for each set of simillar functions
     
    Parameters:
        None
        
    Return Value:
        HRESULT hREs = S_OK in case of a suitable Interface
                       E_NOINTERFACE in case of none
--*/
HRESULT 
TLoad64BitDllsMgr ::
QueryInterface(
    IN  REFIID InterfaceID,
    OUT PVOID  *ppInterface
    )
{
    HRESULT hRes = S_OK;

    if(!ppInterface)
    {
         hRes = E_INVALIDARG;
    }
    else
    {
         *ppInterface = NULL;
         if(InterfaceID == IID_PRINTEREVENT)
         {
             *ppInterface = reinterpret_cast<TPrinterEventMgr *>(new TPrinterEventMgr(this));
         }
         else if(InterfaceID == IID_PRINTUIOPERATIONS)
         {
             *ppInterface = reinterpret_cast<TPrintUIMgr *>(new TPrintUIMgr(this));
         }
         else if(InterfaceID == IID_PRINTERCONFIGURATION)
         {
              *ppInterface = reinterpret_cast<TPrinterCfgMgr *>(new TPrinterCfgMgr(this));
         }
         else if(InterfaceID == IID_LPCMGR)
         {
             *ppInterface = reinterpret_cast<TLPCMgr *>(new TLPCMgr(this));
         }
         else
         {
              hRes = E_NOINTERFACE;
         }

         if(*ppInterface)
         {
             (reinterpret_cast<TRefCntMgr *>(*ppInterface))->AddRef();
         }
         else
         {
             hRes = E_OUTOFMEMORY;
         }
    }
    return hRes;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: Run
     
    Description:
        Creates the object expiration monitoring Thread and starts the 
        RPC server listening process
     
     Parameters:
        None
        
     Return Value:
        DWORD RetVal : ERROR_SUCCESS in case of success
                       ErrorCode     in case of failure
--*/
DWORD
TLoad64BitDllsMgr ::
Run(
    VOID
)
{
    DWORD   RetVal        = ERROR_SUCCESS;
    HANDLE  hMonSrvrThrd  = NULL;
    DWORD   MonSrvrThrdId = 0; 
    //
    // Create a Thread which monitors the expiration of this
    // process. Expiration means that more than a given amount
    // of time , no one requested a service from this surrogate.
    //
    if(hMonSrvrThrd = CreateThread(NULL,
                                   0,
                                   MonitorSrvrLifeExpiration,
                                   (PVOID)this,             
                                   0,
                                   &MonSrvrThrdId))
    {
         //
         // SetUp the RPC server and start listening
         //
         if((RetVal = StartLdrRPCServer()) == RPC_S_OK)
         {
              WaitForSingleObject(hMonSrvrThrd,INFINITE);
         }
         CloseHandle(hMonSrvrThrd);
    }
    else
    {
         RetVal = GetLastError();
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: StartldrRPCServer
     
    Description:
        This function encapsulates specifying the EndPoints,
        the RPC protocol and the Bindings. It also has the 
        main listening loop for the RPC server.
     
     Parameters:
        None
        
     Return Value
        DWORD RetVal : ERROR_SUCCESS in case of success
                       ErrorCode     in case of failure
--*/
DWORD
TLoad64BitDllsMgr ::
StartLdrRPCServer(
    VOID
    )
{
     RPC_BINDING_VECTOR  *pBindingVector;
     RPC_STATUS          RpcStatus;
     WCHAR               szSessionEndPoint[50];
     DWORD               CurrProcessId = GetCurrentProcessId();

     //
     // The EndPointName would be the concatenation of
     // both the app name and the session ID. Session 
     // ID is a dword and hence needs max. 10 wchars , 
     // App name is "splwow64" which is 8 wchars. So 
     // the max we might need is 18 whcars. I might
     // adjust the buffer size later. This is done 
     // specially for terminal server because a Window
     // handle is not shared between differnet sessions, 
     // hence we need a process/session
     //
     wsprintf(szSessionEndPoint,L"%s_%x",APPNAME,m_CurrSessionId);


     if(!(((RpcStatus = RpcServerUseProtseqEp((WCHAR *)L"ncalrpc",
                                              RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                              (WCHAR *)szSessionEndPoint,
                                              NULL)) == RPC_S_OK)                &&
          ((RpcStatus = RpcServerRegisterIf(Lding64BitDlls_ServerIfHandle,
                                            NULL,
                                            NULL)) == RPC_S_OK)                  &&
          ((RpcStatus = RpcServerInqBindings(&pBindingVector)) == RPC_S_OK)      &&
          ((RpcStatus = RpcBindingVectorFree(&pBindingVector)) == RPC_S_OK)      &&
          ((RpcStatus = RpcServerListen(1,
                                        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                        FALSE)) == RPC_S_OK)))           
     {
          DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: StartLdrRPCServer failed with %u\n",RpcStatus));
     }
     return (DWORD)RpcStatus;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: LockSelf
     
    Description:
        Locks the object from other threads for 
        internal data update.
     
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID 
TLoad64BitDllsMgr ::
LockSelf(
    VOID
    ) 
{
    EnterCriticalSection(&m_LdMgrLock);
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ReleaseSelf
     
    Description:
        Release the object for use by other Threads
     
     Parameters:
        None
        
     Return Value
        None
--*/
VOID 
TLoad64BitDllsMgr ::
ReleaseSelf(
    VOID
    )
{
    LeaveCriticalSection(&m_LdMgrLock);
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: RefreshLifeSpan
     
    Description:
        Updates the last time @ which the object 
        was accessed
     
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID
TLoad64BitDllsMgr ::
RefreshLifeSpan(
    VOID
    )
{
    LockSelf();
    {
        GetSystemTime(&m_LastTransactionTime);
    }
    ReleaseSelf();
}
/*++
    Function Name:
        TLoad64BitDllsMgr :: StillAlive
     
    Description:
        This function calculates the difference of
        time  between the last time the object was
        accessed by any connected client and the 
        current system time
     
     Parameters:
        None
        
     Return Value:
        BOOL RetVal : TRUE if  time delta is <= server expiration time
                      FALSE if time delta is >  server expiration time
--*/
BOOL
TLoad64BitDllsMgr ::
StillAlive(
    VOID
    )
{
    FILETIME   FileTime;
    FILETIME   LocalFileTime;
    SYSTEMTIME LocalSystemTime;
    BOOL       bRetVal = TRUE;

     LockSelf();
     {
          GetSystemTime(&LocalSystemTime);
          SystemTimeToFileTime(&LocalSystemTime,&LocalFileTime);
          SystemTimeToFileTime(&m_LastTransactionTime,&FileTime);
          ULONGLONG TimeDiff = ((ULARGE_INTEGER *)&LocalFileTime)->QuadPart -
                               ((ULARGE_INTEGER *)&FileTime)->QuadPart;
          //
          // Since FileTime is calculated as a 100 nanosecond interval
          // we have to divide by 10**4 to get the value in meli seconds
          //
          if((TimeDiff/10000) > m_ExpirationTime)
          {
               if(GetUIRefCnt())
               {
                    GetSystemTime(&m_LastTransactionTime);
               }
               else
               {
                    bRetVal = FALSE;
                    //
                    // Here we should terminate the Listen loop and kill the 
                    // process, by releasing the listen loop.
                    //
                    RpcMgmtStopServerListening(NULL);
               }
          }
     }
     ReleaseSelf();
     return bRetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: StillAlive
     
    Description:
        Monitors the expiration of the server and in case of 
        expiration terminations the RPC server listening loop.
             
     Parameters:
        PVOID pData : Pointer to the Loader Object
        
     Return Value:
        Always returns 0
--*/
DWORD 
TLoad64BitDllsMgr ::
MonitorSrvrLifeExpiration(
    IN PVOID pData
    )
{
     TLoad64BitDllsMgr *pMgrInstance = reinterpret_cast<TLoad64BitDllsMgr *>(pData);

     while(pMgrInstance->StillAlive())
     {
          Sleep(pMgrInstance->m_ExpirationTime);
     }
     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: IncUIRefCnt
     
    Description:
        While poping other components UI , the server process
        should never expire and that's why we incerement ref cnt
        on UI objects.
             
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID 
TLoad64BitDllsMgr ::
IncUIRefCnt(
    VOID
    )
{
     LockSelf();
     {
          //
          // Since I am already in the critical section,
          // I don't need to use InterLocked operations
          //
          m_UIRefCnt++;
     }
     ReleaseSelf();
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: DecUIRefCnt
     
    Description:
        We have to dec the ref cnt once the UI returns, in order
        to be able to release the process once time expires
             
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID
TLoad64BitDllsMgr ::
DecUIRefCnt(
    VOID
    )
{
    LockSelf();
    {
         SPLASSERT(m_UIRefCnt);
         //
         // Since I am already in the critical section,
         // I don't need to use InterLocked operations
         //
         m_UIRefCnt--;
    }
    ReleaseSelf();
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetUIRefCnt
     
    Description:
        Returns the current number of poped UIs
             
     Parameters:
        None
        
     Return Value:
        Number of poped UIs
--*/
DWORD
TLoad64BitDllsMgr ::
GetUIRefCnt(
    VOID
    ) const
{
    return m_UIRefCnt;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ExecuteMonitorOperation
     
    Description:
        Loads the monitor UI Dll , Initializes the monitor UI , 
        determines the required Monitor Operation , and start 
        the function whcih spins off this operation in a 
        separate Thread
             
     Parameters:
        DWORD  hWnd       : Windows Handle for parent windows
        LPWSTR ServerName : Server Name 
        LPWSTR UIDllName  : The Monitor UI Dll name
        LPWSTR Name       : Port Name or Monitor Name
        PortOp Index      : Required Operation
        
     Return Value:
        DWORD  RetVal     : ERROR_SUCCESS in case of success
                            ErrorCode     in case of failure
--*/
BOOL
TLoad64BitDllsMgr ::
ExecuteMonitorOperation(
    IN  ULONG_PTR  hWnd,
    IN  LPWSTR     pszServerName,
    IN  LPWSTR     pszUIDllName,
    IN  LPWSTR     pszName,
    IN  EPortOp    Index,
    OUT PDWORD     pErrorCode
    )
{   
     PMONITORUI (*pfnInitializePrintMonitorUI)(VOID) = NULL;
     HMODULE    hLib    = NULL;
     HANDLE     hActCtx = NULL;
     ULONG_PTR  lActCtx = 0;
     BOOL       bActivated = FALSE;

     *pErrorCode = ERROR_SUCCESS;

     RefreshLifeSpan();

     //
     // For Fusion, we run the code the gets us the 
     // monitor UI activation context
     //
     if((*pErrorCode = this->GetMonitorUIActivationContext(pszUIDllName,&hActCtx,&lActCtx,&bActivated)) == ERROR_SUCCESS)
     {
         if(hLib = LoadLibrary(pszUIDllName))
         {
              if(pfnInitializePrintMonitorUI = (PMONITORUI (*)(VOID))
                                               GetProcAddress(hLib, "InitializePrintMonitorUI"))
              {
                   PMONITORUI pMonitorUI;

                   if(pMonitorUI = (pfnInitializePrintMonitorUI)())
                   {
                       LPTHREAD_START_ROUTINE pThrdFn = NULL;
                       switch (Index)
                       {
                           case KAddPortOp:
                           {
                                pThrdFn = AddPortUI;
                                break;
                           }

                           case KConfigurePortOp:
                           case KDeletePortOp:
                           {
                                pThrdFn = (Index == KConfigurePortOp) ? ConfigurePortUI : DeletePortUI;
                                break;
                           }
                       }

                       SPLASSERT(pThrdFn);
                       *pErrorCode = SpinPortOperationThread((HWND)hWnd,
                                                             pszServerName,
                                                             pszName,
                                                             pMonitorUI,
                                                             Index,
                                                             pThrdFn,
                                                             hLib,
                                                             hActCtx,
                                                             lActCtx,
                                                             bActivated
                                                             );
                   }
                   else
                   {
                       *pErrorCode = GetLastError();
                   }
              }
              else
              {
                   *pErrorCode = GetLastError();
                   DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: ExecuteMonitorOperation failed to Load Monitor Initializaiton fn. with  %u\n",
                                     *pErrorCode));
              }
         }
         else
         {
              *pErrorCode = GetLastError();
              DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: ExecuteMonitorOperation failed to load Monitor UI Dll with  %u\n",
                                *pErrorCode));
         }
     }
     if(*pErrorCode != ERROR_SUCCESS)
     {
         ReleaseMonitorActivationContext(hLib,hActCtx,lActCtx,bActivated);
     }
     return *pErrorCode == ERROR_SUCCESS;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: SpinPortOperationThread
     
    Description:
        Spins the appropriate monitor operation in a separate thread
             
     Parameters:
        HWND                   hWnd       : Windows Handle for parent windows
        LPWSTR                 ServerName : Server Name 
        LPWSTR                 UIDllName  : The Monitor UI Dll name
        LPWSTR                 Name       : Port Name or Monitor Name
        PortOp                 Index      : Required Operation
        PMONITORUI             pMonitorUI : Port Monitor Functions
        LPTHREAD_START_ROUTINE pThrdFn    : Internal Thread to be executed
        
     Return Value:
        DWORD  RetVal  : ERROR_SUCCESS in case of success
                         ErrorCode     in case of failure
--*/
DWORD 
TLoad64BitDllsMgr ::
SpinPortOperationThread(
    IN HWND                   hWnd,
    IN LPWSTR                 pszServerName,
    IN LPWSTR                 pszName,
    IN PMONITORUI             pMonitorUI,
    IN EPortOp                Index,
    IN LPTHREAD_START_ROUTINE pThrdFn,
    IN HMODULE                hLib,
    IN HANDLE                 hActCtx,
    IN ULONG_PTR              lActCtx,
    IN BOOL                   bActivated
    ) const
{
    DWORD               UIThrdId        = 0;
    HANDLE              hUIThrd         = NULL; 
    DWORD               RetVal          = ERROR_SUCCESS;
    SPortAddThreadData  *pNewThreadData = NULL;

    if(pNewThreadData = new SPortAddThreadData)
    {
         switch (Index)
         {
             case KAddPortOp:
             {
                 pNewThreadData->pMonFnAdd       = pMonitorUI->pfnAddPortUI;
                 pNewThreadData->pMonFns         = NULL;
                 pNewThreadData->pszMonitorName  = pszName;
                 pNewThreadData->pszPortName     = NULL;
                 break;
             }

             case KConfigurePortOp:
             case KDeletePortOp:
             {
                 PFNMONITORFNS pfnMonitorsFns[2];

                 pfnMonitorsFns[0] = pMonitorUI->pfnConfigurePortUI;
                 pfnMonitorsFns[1] = pMonitorUI->pfnDeletePortUI;

                 pNewThreadData->pMonFnAdd        = NULL;
                 pNewThreadData->pMonFns          = pfnMonitorsFns[Index];
                 pNewThreadData->pszMonitorName   = NULL;
                 pNewThreadData->pszPortName      = pszName;
                 break;
             }
         }
         pNewThreadData->hWnd              = hWnd;
         pNewThreadData->pszServerName     = pszServerName;
         pNewThreadData->ppszRetPortName   = NULL;
         pNewThreadData->hLib              = hLib;
         pNewThreadData->hActCtx           = hActCtx;
         pNewThreadData->lActCtx           = lActCtx;
         pNewThreadData->bActivated        = bActivated;

         if(!(hUIThrd = CreateThread(NULL,
                                     0,
                                     pThrdFn,
                                     (PVOID)pNewThreadData,             
                                     0,
                                     &UIThrdId)))
         {
              RetVal = GetLastError();
              delete pNewThreadData;
              DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: SpinPortOperationThread failed to create Port Operation fn. with  %u\n",
                                RetVal));
         }
         else
         {
              CloseHandle(hUIThrd);
         }
    }
    else
    {
         RetVal = ERROR_OUTOFMEMORY;
         DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: SpinPortOperationThread failed to allocate required memory with %u\n",
                           RetVal));
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: AddPortUI
     
    Description:
        Calls the monitor AddPort
             
     Parameters:
        PVOID  InThrdData : Thread Data for Adding a Port
             
     Return Value:
        Always 0
--*/
DWORD
TLoad64BitDllsMgr ::
AddPortUI(
    IN PVOID pInThrdData
    )
{
     DWORD   RetVal = ERROR_SUCCESS;
     HANDLE  hMsgThrd;
     DWORD   MsgThrdId;

     SPortAddThreadData *pNewThreadData = reinterpret_cast<SPortAddThreadData *>(pInThrdData);

     pGLdrObj->IncUIRefCnt();
     {
         RetVal =  (DWORD) pNewThreadData->pMonFnAdd(pNewThreadData->pszServerName,
                                                     pNewThreadData->hWnd,
                                                     pNewThreadData->pszMonitorName,
                                                     NULL);
     }
     pGLdrObj->DecUIRefCnt();
     //
     // Here we should post a message to the caller client window to inform 
     // it that the operation was completed and also whether it was succesful 
     // or not
     //
     PostMessage(pNewThreadData->hWnd,WM_ENDADDPORT,
                 (WPARAM)RetVal,
                 (RetVal != ERROR_SUCCESS) ? ERROR_SUCCESS : (DWORD)GetLastError());

     pGLdrObj->ReleaseMonitorActivationContext(pNewThreadData->hLib,
                                               pNewThreadData->hActCtx,
                                               pNewThreadData->lActCtx,
                                               pNewThreadData->bActivated);

     delete pInThrdData;

     return 0;
}

/*++
    Function Name:
        TLoad64BitDllsMgr :: DeletePortUI
     
    Description:
        Calls the monitor DeletePort
             
     Parameters:
        PVOID  InThrdData : Thread Data for Adding a Port
             
     Return Value:
        Always 0
--*/
DWORD
TLoad64BitDllsMgr ::
DeletePortUI(
    IN PVOID pInThrdData
    )
{
     DWORD  RetVal = ERROR_SUCCESS;

     SPortAddThreadData *pNewThreadData = reinterpret_cast<SPortAddThreadData *>(pInThrdData);

     pGLdrObj->IncUIRefCnt();
     {
         RetVal =  (DWORD) pNewThreadData->pMonFns(pNewThreadData->pszServerName,
                                                   pNewThreadData->hWnd,
                                                   pNewThreadData->pszPortName);
     }
     pGLdrObj->DecUIRefCnt();
     //
     // Here we should post a message to the caller window to inform them
     // the operation was completed and also whether it was succesful or 
     // not
     //
     PostMessage(pNewThreadData->hWnd,WM_ENDDELPORT,
                 (WPARAM)RetVal,
                 (RetVal != ERROR_SUCCESS) ? ERROR_SUCCESS : (DWORD)GetLastError());

     pGLdrObj->ReleaseMonitorActivationContext(pNewThreadData->hLib,
                                               pNewThreadData->hActCtx,
                                               pNewThreadData->lActCtx,
                                               pNewThreadData->bActivated);

     delete pInThrdData;

     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ConfigurePortUI
     
    Description:
        Calls the monitor ConfigurePort
             
     Parameters:
        PVOID  InThrdData : Thread Data for Adding a Port
             
     Return Value:
        Always 0
--*/
DWORD
TLoad64BitDllsMgr ::
ConfigurePortUI(
    IN PVOID pInThrdData
    )
{
     DWORD  RetVal = ERROR_SUCCESS;

     SPortAddThreadData *pNewThreadData = reinterpret_cast<SPortAddThreadData *>(pInThrdData);

     pGLdrObj->IncUIRefCnt();
     {
         RetVal =  (DWORD) pNewThreadData->pMonFns(pNewThreadData->pszServerName,
                                                   pNewThreadData->hWnd,
                                                   pNewThreadData->pszPortName);
     }
     pGLdrObj->DecUIRefCnt();
     //
     // Here we should post a message to the caller window to inform them
     // the operation was completed and also whether it was succesful or 
     // not
     //
     PostMessage(pNewThreadData->hWnd,WM_ENDCFGPORT,
                 (WPARAM)RetVal,
                 (RetVal != ERROR_SUCCESS) ? ERROR_SUCCESS : (DWORD)GetLastError());

     pGLdrObj->ReleaseMonitorActivationContext(pNewThreadData->hLib,
                                               pNewThreadData->hActCtx,
                                               pNewThreadData->lActCtx,
                                               pNewThreadData->bActivated);

     delete pInThrdData;

     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: DeviceCapabilities
     
    Description:
        Queries the Device capabilities , by calling into
        the driver
             
    Parameters:
        LPWSTR  DeviceName       : Device Name
        LPWSTR  PortName         : Port Name
        WORD    Capabilities     : Required Capabilites to Query for
        DWORD   DevModeSize      : Input DevMode Size
        LPBYTE  DevMode          : Input DevMode
        BOOL    ClonedOutputFill : Required To fill output DevMode
        PDWORD  ClonedOutputSize : Output DevMode size
        LPBYTE* ClonedOutput     : Output DevMode
             
     Return Value:
        int RetVal : -1 in case of Failure
                   : Some value depending on Capabilities flag in case 
                     of Success
--*/
int 
TLoad64BitDllsMgr ::
DeviceCapabilities(
    IN  LPWSTR  pszDeviceName,
    IN  LPWSTR  pszPortName,
    IN  WORD    Capabilities,
    IN  DWORD   DevModeSize,
    IN  LPBYTE  pDevMode,
    IN  BOOL    bClonedOutputFill,
    OUT PDWORD  pClonedOutputSize,
    OUT LPBYTE  *ppClonedOutput,
    OUT PDWORD  pErrorCode
    )
{
     HANDLE      hPrinter    = NULL;
     HANDLE      hDriver     = NULL;
     INT         ReturnValue = -1;
     INT_FARPROC pfn;
     LPWSTR      pszDriverFileName;

     RefreshLifeSpan();

     if (OpenPrinter((LPWSTR)pszDeviceName, &hPrinter, NULL))
     {
          if(hDriver = LoadPrinterDriver(hPrinter))
          {
               if (pfn = (INT_FARPROC)GetProcAddress(hDriver,
                                                     "DrvDeviceCapabilities"))
               {
                   __try
                   {
                       *ppClonedOutput = NULL;

                       ReturnValue = (*pfn)(hPrinter,
                                            pszDeviceName,
                                            Capabilities,
                                            (PVOID)*ppClonedOutput,
                                            (PDEVMODE)pDevMode);
                       if(ReturnValue != -1 &&
                          ReturnValue != 0  &&
                          bClonedOutputFill &&
                          DevCapFillsOutput(Capabilities))
                       {
                           if(*ppClonedOutput = new BYTE[*pClonedOutputSize = CalcReqSizeForDevCaps(ReturnValue,
                                                                                                    Capabilities)])
                           {
                               ZeroMemory(*ppClonedOutput,*pClonedOutputSize);
                               if((ReturnValue = (*pfn)(hPrinter, 
                                                        pszDeviceName, 
                                                        Capabilities,
                                                        (PVOID)*ppClonedOutput, 
                                                        (PDEVMODE)pDevMode)) == -1)
                               {
                                   *pErrorCode = GetLastError();
                               }
                           }
                           else
                           {
                               ReturnValue = -1;
                               *pErrorCode = ERROR_OUTOFMEMORY;
                           }
                       }
                       if(!ReturnValue)
                       {
                           *pErrorCode = GetLastError();
                       }
                   }
                   __except(1)
                   {
                       SetLastError(GetExceptionCode());
                       ReturnValue = -1;
                       DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: DeviceCapabilities failed to allocate memory"));
                   }
               }
               FreeLibrary(hDriver);
          }
          else
          {   *pErrorCode = GetLastError();
              DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: DeviceCapabilities failed to load driver with %u\n",
                     *pErrorCode));
          }
          ClosePrinter(hPrinter);
     }
     else
     {
         *pErrorCode = GetLastError();
         DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: DeviceCapabilities failed to open printer with %u\n",
                *pErrorCode));
     }
     return  ReturnValue;
}

/*++
    Function Name:
        TLoad64BitDllsMgr :: DevCapFillsOutput
     
    Description:
        Does the capability fill out an out buffer or not
             
    Parameters:
        DWORD Capabilites : The required Capability
        
             
     Return Value:
        BOOL  : 1 OR 0
--*/
BOOL
TLoad64BitDllsMgr ::
DevCapFillsOutput(
    IN DWORD Capabilities
    ) const
{
     SPLASSERT(Capabilities>0 && Capabilities<= DC_NUP);

     return(!!DeviceCapsReqSize[Capabilities-1]);
}



/*++
    Function Name:
        TLoad64BitDllsMgr :: CalcReqSizeForDevCaps
     
    Description:
        Given the required capability returns the size required
        for all enumerated values of it
             
    Parameters:
        DWORD CapNum      : Num Of Items for given Capability
        DWORD Capabilites : The required Capability
        
             
     Return Value:
        DWORD  : Required size to store all items of capability
--*/
DWORD
TLoad64BitDllsMgr ::
CalcReqSizeForDevCaps(
    IN DWORD CapNum,
    IN DWORD Capabilities
    ) const
{
     SPLASSERT(Capabilities>0 && Capabilities<= DC_NUP);

     return((Capabilities && DeviceCapsReqSize[Capabilities-1]) ?
            (CapNum * DeviceCapsReqSize[Capabilities-1])        :
            CapNum);

}

/*++
    Function Name:
        TLoad64BitDllsMgr :: DocumentProperties
     
    Description:
        Displays the driver specific properties
                     
    Parameters:
        HWND    hWnd                 : Parent Window Handle
        LPWSTR  PrinterName          : Printer Name
        PDWORD  ClonedDevModeOutSize : Output DevMode size
        LPBYTE* ClonedDevModeOut     : Output DevMode
        DWORD   DevModeSize          : Input DevMode Size
        LPBYTE  DevMode              : Input DevMode
        WORD    Capabilities         : Required Capabilites to Query for
        BOOL    ClonedDevModeOutFill : Required To fill output DevMode
        DWORD   fMode                : Mode Options
             
     Return Value:
        int RetVal : -1 in case of Failure
                   : Some value depending on fMode flag  and DevModes
                     and this might be posted to the client window in
                     case of running asynchronously
--*/
LONG                                            
TLoad64BitDllsMgr ::
DocumentProperties(                     
    IN  ULONG_PTR  hWnd,                               
    IN  LPWSTR     pszPrinterName, 
    OUT PDWORD     pTouchedDevModeSize,
    OUT PDWORD     pClonedDevModeOutSize,               
    OUT LPBYTE     *ppClonedDevModeOut,
    IN  DWORD      DevModeSize,                        
    IN  LPBYTE     pDevMode,                            
    IN  BOOL       bClonedDevModeOutFill,               
    IN  DWORD      fMode,
    OUT PDWORD     pErrorCode
    )
{

    LONG                RetVal        = -1;
    SDocPropsThreadData *pNewThrdData = NULL;

    RefreshLifeSpan();
    
    if(pNewThrdData = new SDocPropsThreadData)
    {
         pNewThrdData->hWnd                    = (HWND)hWnd;                   
         pNewThrdData->pszPrinterName          = pszPrinterName;            
         pNewThrdData->pClonedDevModeOutSize   = pClonedDevModeOutSize;   
         pNewThrdData->pTouchedDevModeSize     = pTouchedDevModeSize;
         pNewThrdData->ppClonedDevModeOut      = ppClonedDevModeOut;
         pNewThrdData->DevModeSize             = DevModeSize;            
         pNewThrdData->pDevMode                = pDevMode;                
         pNewThrdData->bClonedDevModeOutFill   = bClonedDevModeOutFill;   
         pNewThrdData->fMode                   = fMode;         
         pNewThrdData->fExclusionFlags         = 0;         
         pNewThrdData->ErrorCode               = ERROR_SUCCESS;
         pNewThrdData->RetVal                  = -1;
         InternalDocumentProperties((PVOID)pNewThrdData);

         RetVal      = pNewThrdData->RetVal;
         *pErrorCode = pNewThrdData->ErrorCode;

         delete pNewThrdData;
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: AsyncDocumentProperties
             
    Description:
        Displays the driver specific UI in a separate sheet
                     
    Parameters:
        PVOID : Thread Data
                     
     Return Value:
        Always returns 0
--*/
DWORD 
TLoad64BitDllsMgr ::
InternalDocumentProperties(
    PVOID pInThrdData
    )
{
                         
     DOCUMENTPROPERTYHEADER     DPHdr;
     HANDLE                     hPrinter              = NULL;
     SDocPropsThreadData        *pNewThreadData       = reinterpret_cast<SDocPropsThreadData *>(pInThrdData);    
     TLoad64BitDllsMgr          *pMgrInstance         = pNewThreadData->pMgrInstance;                       
     HWND                       hWnd                  = pNewThreadData->hWnd;                              
     LPWSTR                     pszPrinterName        = pNewThreadData->pszPrinterName;                       
     PDWORD                     pClonedDevModeOutSize = pNewThreadData->pClonedDevModeOutSize;              
     PDWORD                     pTouchedDevModeSize   = pNewThreadData->pTouchedDevModeSize;
     LPBYTE*                    ppClonedDevModeOut    = pNewThreadData->ppClonedDevModeOut;                  
     DWORD                      DevModeSize           = pNewThreadData->DevModeSize;                       
     LPBYTE                     pDevMode              = pNewThreadData->pDevMode;                           
     BOOL                       bClonedDevModeOutFill = pNewThreadData->bClonedDevModeOutFill;              
     DWORD                      fMode                 = pNewThreadData->fMode;                             
     HMODULE                    hWinSpool             = NULL;
     PFNDOCPROPSHEETS           pfnDocPropSheets      = NULL;
     LONG                       Result                = -1;
     LONG                       cbOut                 = 0;

     if(hWinSpool = LoadLibrary(L"winspool.drv"))
     {
          if(pfnDocPropSheets = reinterpret_cast<PFNDOCPROPSHEETS>(GetProcAddress(hWinSpool,
                                                                                  "DocumentPropertySheets")))
          {
               if(OpenPrinter(pszPrinterName,&hPrinter,NULL))
               {
                    //
                    // Do I need to protect the printer handle ?????
                    //
                    DPHdr.cbSize         = sizeof(DPHdr);
                    DPHdr.Reserved       = 0;
                    DPHdr.hPrinter       = hPrinter;
                    DPHdr.pszPrinterName = pszPrinterName;

                    if(bClonedDevModeOutFill)
                    {
                        DPHdr.pdmIn  = NULL;
                        DPHdr.pdmOut = NULL;
                        DPHdr.fMode  = 0;
          
                        cbOut = pfnDocPropSheets(NULL, (LPARAM)&DPHdr);
                        
                        //
                        // The function returns zero or a negative number when it fails.
                        // 
                        if (cbOut > 0)
                        {
                            DPHdr.cbOut = cbOut;
                            if(*ppClonedDevModeOut = new BYTE[DPHdr.cbOut])
                            {
                                ZeroMemory(*ppClonedDevModeOut, DPHdr.cbOut);
                            }
                        }
                        else
                        {
                            DPHdr.cbOut           = 0;
                            *ppClonedDevModeOut   = NULL;
                        }
                    }
                    else
                    {
                        DPHdr.cbOut           = 0;
                        *ppClonedDevModeOut     = NULL;
                    }
          
                    *pClonedDevModeOutSize = DPHdr.cbOut;
          
                    DPHdr.pdmIn  = (PDEVMODE)pDevMode;
                    DPHdr.pdmOut = (PDEVMODE)*ppClonedDevModeOut;
                    DPHdr.fMode  = fMode;

                    if (fMode & DM_PROMPT)
                    {
                        PFNCALLCOMMONPROPSHEETUI  pfnCallCommonPropSheeUI = NULL;
                        Result = CPSUI_CANCEL;

                        if(pfnCallCommonPropSheeUI= reinterpret_cast<PFNCALLCOMMONPROPSHEETUI>(GetProcAddress(hWinSpool,
                                                                                                             (LPCSTR) MAKELPARAM(218, 0))))
                        {
                            pGLdrObj->IncUIRefCnt();
                            if(pfnCallCommonPropSheeUI(hWnd,
                                                       pfnDocPropSheets,
                                                       (LPARAM)&DPHdr,
                                                       (LPDWORD)&Result) < 0)
                            {
                                 Result = -1;
                                 pNewThreadData->ErrorCode = GetLastError();
                            }
                            else
                            {
                                 Result = (Result == CPSUI_OK) ? IDOK : IDCANCEL;
                            }
                            pGLdrObj->DecUIRefCnt();
                        }
                        else
                        {
                             Result = -1;
                             pNewThreadData->ErrorCode = GetLastError();
                        }
            
                    }
                    else 
                    {
                        Result = pfnDocPropSheets(NULL, (LPARAM)&DPHdr);
                        if(Result<0)
                        {
                            pNewThreadData->ErrorCode = GetLastError();
                        }
                    }

                    //
                    // Here we try to adjust the required memory . Sometimes it is less
                    //
                    if((PDEVMODE)*ppClonedDevModeOut)
                    {
                         if((DWORD)(((PDEVMODE)*ppClonedDevModeOut)->dmSize + 
                                    ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra) < 
                            *pClonedDevModeOutSize)
                         {
                              *pTouchedDevModeSize = (((PDEVMODE)*ppClonedDevModeOut)->dmSize +
                                                     ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra);
                         }
                         else
                         {
                              *pTouchedDevModeSize = *pClonedDevModeOutSize;
                         }
                    }

                    if(hPrinter)
                    {
                         ClosePrinter(hPrinter);
                    }
               }
               else
               {
                    pNewThreadData->ErrorCode = GetLastError();
               }
          }
          else
          {
               pNewThreadData->ErrorCode = GetLastError();
          }
          FreeLibrary(hWinSpool);
     }
     else
     {
          pNewThreadData->ErrorCode = GetLastError();
     }
     if(hWnd && (fMode & DM_PROMPT))
     {
          PostMessage(pNewThreadData->hWnd,WM_ENDDOCUMENTPROPERTIES,
                      (WPARAM)Result,
                      (LPARAM)pNewThreadData->ErrorCode);
     }
     pNewThreadData->RetVal = Result;
     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: DocumentProperties
     
    Description:
        Displays the driver specific properties
                     
    Parameters:
        HWND    hWnd                 : Parent Window Handle
        LPWSTR  PrinterName          : Printer Name
        PDWORD  ClonedDevModeOutSize : Output DevMode size
        LPBYTE* ClonedDevModeOut     : Output DevMode
        DWORD   DevModeSize          : Input DevMode Size
        LPBYTE  DevMode              : Input DevMode
        WORD    Capabilities         : Required Capabilites to Query for
        BOOL    ClonedDevModeOutFill : Required To fill output DevMode
        DWORD   fMode                : Mode Options
             
     Return Value:
        int RetVal : -1 in case of Failure
                   : Some value depending on fMode flag  and DevModes
                     and this might be posted to the client window in
                     case of running asynchronously
--*/
LONG                                            
TLoad64BitDllsMgr ::
PrintUIDocumentProperties(                     
    IN  ULONG_PTR  hWnd,                               
    IN  LPWSTR     pszPrinterName, 
    OUT PDWORD     pTouchedDevModeSize,
    OUT PDWORD     pClonedDevModeOutSize,               
    OUT LPBYTE     *ppClonedDevModeOut,
    IN  DWORD      DevModeSize,                        
    IN  LPBYTE     pDevMode,                            
    IN  BOOL       bClonedDevModeOutFill,               
    IN  DWORD      fMode,
    IN  DWORD      fExclusionFlags,
    OUT PDWORD     pErrorCode
    )
{

    LONG                RetVal        = -1;
    SDocPropsThreadData *pNewThrdData = NULL;

    RefreshLifeSpan();
    
    if(pNewThrdData = new SDocPropsThreadData)
    {
         pNewThrdData->hWnd                    = (HWND)hWnd;                   
         pNewThrdData->pszPrinterName          = pszPrinterName;            
         pNewThrdData->pClonedDevModeOutSize   = pClonedDevModeOutSize;   
         pNewThrdData->pTouchedDevModeSize     = pTouchedDevModeSize;
         pNewThrdData->ppClonedDevModeOut      = ppClonedDevModeOut;
         pNewThrdData->DevModeSize             = DevModeSize;            
         pNewThrdData->pDevMode                = pDevMode;                
         pNewThrdData->bClonedDevModeOutFill   = bClonedDevModeOutFill;   
         pNewThrdData->fMode                   = fMode;        
         pNewThrdData->fExclusionFlags         = fExclusionFlags;
         pNewThrdData->ErrorCode               = ERROR_SUCCESS;
         pNewThrdData->RetVal                  = -1;
         InternalPrintUIDocumentProperties((PVOID)pNewThrdData);

         RetVal      = pNewThrdData->RetVal;
         *pErrorCode = pNewThrdData->ErrorCode;

         delete pNewThrdData;
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: AsyncDocumentProperties
             
    Description:
        Displays the driver specific UI in a separate sheet
                     
    Parameters:
        PVOID : Thread Data
                     
     Return Value:
        Always returns 0
--*/
DWORD 
TLoad64BitDllsMgr ::
InternalPrintUIDocumentProperties(
    PVOID pInThrdData
    )
{
                         
     DOCUMENTPROPERTYHEADER     DPHdr;
     HANDLE                     hPrinter              = NULL;
     SDocPropsThreadData        *pNewThreadData       = reinterpret_cast<SDocPropsThreadData *>(pInThrdData);    
     TLoad64BitDllsMgr          *pMgrInstance         = pNewThreadData->pMgrInstance;                       
     HWND                       hWnd                  = pNewThreadData->hWnd;                              
     LPWSTR                     pszPrinterName        = pNewThreadData->pszPrinterName;                       
     PDWORD                     pClonedDevModeOutSize = pNewThreadData->pClonedDevModeOutSize;              
     PDWORD                     pTouchedDevModeSize   = pNewThreadData->pTouchedDevModeSize;
     LPBYTE*                    ppClonedDevModeOut    = pNewThreadData->ppClonedDevModeOut;                  
     DWORD                      DevModeSize           = pNewThreadData->DevModeSize;                       
     LPBYTE                     pDevMode              = pNewThreadData->pDevMode;                           
     BOOL                       bClonedDevModeOutFill = pNewThreadData->bClonedDevModeOutFill;              
     DWORD                      fMode                 = pNewThreadData->fMode;                             
     DWORD                      fExclusionFlags       = pNewThreadData->fExclusionFlags;
     HMODULE                    hWinSpool             = NULL;
     PFNDOCPROPSHEETS           pfnDocPropSheets      = NULL;
     LONG                       Result                = -1;

     if(hWinSpool = LoadLibrary(L"winspool.drv"))
     {
          if(pfnDocPropSheets = reinterpret_cast<PFNDOCPROPSHEETS>(GetProcAddress(hWinSpool,
                                                                                  "DocumentPropertySheets")))
          {
               if(OpenPrinter(pszPrinterName,&hPrinter,NULL))
               {
                    DPHdr.cbSize         = sizeof(DPHdr);
                    DPHdr.Reserved       = 0;
                    DPHdr.hPrinter       = hPrinter;
                    DPHdr.pszPrinterName = pszPrinterName;

                    if(bClonedDevModeOutFill)
                    {
                        DPHdr.pdmIn  = NULL;
                        DPHdr.pdmOut = NULL;
                        DPHdr.fMode  = 0;
          
                        DPHdr.cbOut = pfnDocPropSheets(NULL,
                                                       (LPARAM)&DPHdr);

                        *ppClonedDevModeOut = new BYTE[DPHdr.cbOut];
                    }
                    else
                    {
                        DPHdr.cbOut           = 0;
                        *ppClonedDevModeOut   = NULL;
                    }
          
                    *pClonedDevModeOutSize = DPHdr.cbOut;
          
                    PFNPRINTUIDOCUMENTPROPERTIES     pfnPrintUIDocumentProperties = NULL;
                    HMODULE                          hPrintUI                     = NULL;

                    if(hPrintUI = LoadLibrary(L"printui.dll"))
                    {
                        if(pfnPrintUIDocumentProperties = reinterpret_cast<PFNPRINTUIDOCUMENTPROPERTIES>(GetProcAddress(hPrintUI,
                                                                                                                        "DocumentPropertiesWrap")))
                        {
                            pGLdrObj->IncUIRefCnt();
                            Result = pfnPrintUIDocumentProperties(hWnd,
                                                                  hPrinter,
                                                                  pszPrinterName,
                                                                  (PDEVMODE)*ppClonedDevModeOut,
                                                                  (PDEVMODE)pDevMode,
                                                                  fMode,
                                                                  fExclusionFlags
                                                                 );

                            pNewThreadData->ErrorCode = GetLastError();

                            pGLdrObj->DecUIRefCnt();
                            //
                            // Here we try to adjust the required memory . Sometimes it is less
                            //
                            if((PDEVMODE)*ppClonedDevModeOut)
                            {
                                 if((DWORD)(((PDEVMODE)*ppClonedDevModeOut)->dmSize + 
                                            ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra) < 
                                    *pClonedDevModeOutSize)
                                 {
                                      *pTouchedDevModeSize = (((PDEVMODE)*ppClonedDevModeOut)->dmSize +
                                                             ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra);
                                 }
                                 else
                                 {
                                      *pTouchedDevModeSize = *pClonedDevModeOutSize;
                                 }
                            }
                        }
                        FreeLibrary(hPrintUI);
                    }

                    if(hPrinter)
                    {
                         ClosePrinter(hPrinter);
                    }
               }
               else
               {
                    pNewThreadData->ErrorCode = GetLastError();
               }
          }
          else
          {
               pNewThreadData->ErrorCode = GetLastError();
          }
          FreeLibrary(hWinSpool);
     }
     else
     {
          pNewThreadData->ErrorCode = GetLastError();
     }
     if(hWnd)
     {
          PostMessage(pNewThreadData->hWnd,WM_ENDPRINTUIDOCUMENTPROPERTIES,
                      (WPARAM)Result,
                      (LPARAM)pNewThreadData->ErrorCode);
     }
     pNewThreadData->RetVal = Result;
     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetCurrSeesionId
             
    Description:
        returns the Current Session ID for terminal server 
        sessions
                     
    Parameters:
        None
                             
     Return Value:
        DWORD: Session ID     
--*/
DWORD
TLoad64BitDllsMgr ::
GetCurrSessionId() const
{   
    return m_CurrSessionId;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetMonitorUIActivationContext
             
    Description:
        This routine gets the monitor UI activation context and then
        activates the context.  If the monitor does not have an activation
        context in it's resource file it will activate the empty context
        for compatiblity with previous version of common control.
                     
    Parameters:
        pszUIDllName  - The name of the monitor ui DLL.
        phActCtx      - Pointer to the activation context handle
                             
     Return Value:
        DWORD: Error Code if any else ERROR_SUCCESS     

--*/

DWORD
TLoad64BitDllsMgr :: 
GetMonitorUIActivationContext(
    IN     LPWSTR    pszUIDllName,
    IN OUT HANDLE    *phActCtx,
    IN OUT ULONG_PTR *plActCtx,
    IN OUT BOOL      *pbActivated
    ) const
{
    DWORD  ErrorCode    = ERROR_SUCCESS;
    LPWSTR pszFullPath = NULL;

    if(!pszUIDllName)
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if(pszFullPath = new WCHAR[MAX_PATH])
        {
            ZeroMemory(pszFullPath,MAX_PATH*sizeof(WCHAR));
            if((ErrorCode = this->GetMonitorUIFullPath(pszUIDllName,pszFullPath)) == ERROR_SUCCESS)
            {
                ACTCTX  ActCtx;
        
                ZeroMemory(&ActCtx, sizeof(ActCtx));
        
                ActCtx.cbSize          = sizeof(ActCtx);
                ActCtx.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
                ActCtx.lpSource        = pszFullPath;
                ActCtx.lpResourceName  = MAKEINTRESOURCE(ACTIVATION_CONTEXT_RESOURCE_ID);
        
                if((*phActCtx = CreateActCtx(&ActCtx)) == INVALID_HANDLE_VALUE)
                {
                    *phActCtx = ACTCTX_EMPTY;
                    if(!ActivateActCtx(*phActCtx,plActCtx))
                    {
                        ErrorCode = GetLastError();
                    }
                    else
                    {
                        *pbActivated = TRUE;
                    }
                }
            }
            delete [] pszFullPath;
        }
        else
        {
            ErrorCode = ERROR_OUTOFMEMORY;
        }
    }
    return ErrorCode;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetMonitorUIFullPath
             
    Description:
        Functioning returning the full path to create an activation context.  
        We have at this stage the monitor name not the full path.
                     
    Parameters:
        pszUIDllName  - The name of the monitor ui DLL.
        pszFullPath   - The FullPath 
                             
     Return Value:
        DWORD: Error Code if any else ERROR_SUCCESS     

--*/
DWORD
TLoad64BitDllsMgr :: 
GetMonitorUIFullPath(
    IN     LPWSTR pszUIDllName,
    IN OUT LPWSTR pszFullPath
    ) const
{
    DWORD ErrorCode = ERROR_SUCCESS;
    
    if( !pszFullPath && !pszUIDllName)
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        DWORD FullPathLen;

        if((FullPathLen = GetSystemDirectory(pszFullPath, MAX_PATH)))
        {
            // 
            // The fulle name is Directory + \ + Name + Null
            //
            if((FullPathLen + wcslen(pszUIDllName) + 2) <= MAX_PATH)
            {
                wcscat(pszFullPath,L"\\");
                wcscat(pszFullPath,pszUIDllName);

                //
                // Check to see if this is a valid name
                //
                if(GetFileAttributes(pszFullPath) == -1)
                {
                    wcscpy(pszFullPath,pszUIDllName);
                }
            }
            else
            {
                ErrorCode = ERROR_BUFFER_OVERFLOW;
            }
        }
        else
        {
            ErrorCode = GetLastError();
        }
    }

    return ErrorCode;
}

/*++
    Function Name:
        TLoad64BitDllsMgr :: ReleaseMonitorActivationContext
             
    Description:
        This function releases data relative to activating the monitor UI 
        context. It is responsible of releasing the monitor library as well 
        the monitor fusion activation context.  Note this function is called 
        in error cases when GetMonitorUI fails so all the parameters must be 
        checked for validity before use.
                     
    Parameters:
        hLib      - The handle of the monitor ui DLL.
        hActCtx   - The Activation context
        lActCtx   = The Activation Cookie 
                             
    Return Value:
        VOID     

--*/
VOID
TLoad64BitDllsMgr :: 
ReleaseMonitorActivationContext(
    IN HINSTANCE hLib    ,
    IN HANDLE    hActCtx ,
    IN ULONG_PTR lActCtx ,
    IN BOOL      bActivated
    ) const
{
    //
    // Release the monitor library.
    //
    if (hLib)
    {
        FreeLibrary(hLib);
    }

    //
    // If we have an activation cookie then deactivate this context
    //
    if (bActivated)
    {
        DeactivateActCtx(0 , lActCtx);
    }

    //
    // If we have created an activation context then release it.
    //
    if (hActCtx != INVALID_HANDLE_VALUE && hActCtx != ACTCTX_EMPTY)
    {
        ReleaseActCtx(hActCtx);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\precomp.h ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     precomp.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the startup code for the
     surrogate rpc server used to load 64 bit dlls
     in 32 bit apps
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#define MAX_STATIC_ALLOC     1024

#define NOMINMAX

#ifndef MODULE
#define MODULE "LD32IN64:"
#define MODULE_DEBUG Ld64In32Debug
#endif

#ifdef __cplusplus
extern "C"
{
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#ifdef __cplusplus
}
#endif
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winddi.h>
#include <rpc.h>
#include <splcom.h>
#include <time.h>
#include "winddiui.h"

#include <splwow64.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\lpcmgr.hpp ===
#ifndef __LPCMGR_HPP__
#define __LPCMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     TLPCMgr.hpp                                                             
                                                                              
  Abstract:                                                                   
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __GDITHNK_HPP__
#include "gdithnk.hpp"
#endif

#ifndef __GOLLMGR_HPP__
#include "collmgr.hpp"
#endif

//
// "UMPD"
//
#define UMPD_SIGNATURE 0X554D5044

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TLPCMgr : public TClassID,
                public TLd64BitDllsErrorHndlr,
                public TRefCntMgr
{
    public:

    //
    // Forward declaration of embedded classes
    //
    class TClientInfo;
    class TConnectedClientsInfo;

    TLPCMgr(
        IN TLoad64BitDllsMgr* pIpLdrObj
        );

    ~TLPCMgr(
        VOID
        );

    HANDLE*
    GetUMPDLPCConnPortHandlePtr(
        VOID
        );

    HANDLE
    GetUMPDLpcConnPortHandle(
        VOID
        )const;

    VOID
    SetCurrSessionId(
        DWORD InID
        );

    DWORD
    GetCurrSessionId(
        VOID
        ) const;

    DWORD
    InitUMPDLPCServer(
        VOID
        );

    VOID
    SetPFN(
        PFNGDIPRINTERTHUNKPROC pFN
        );

    PFNGDIPRINTERTHUNKPROC
    GetPFN(
        VOID
        ) const;

    TLoad64BitDllsMgr* 
    GetLdrObj(
        VOID
        ) const;

    DWORD
    ProcessConnectionRequest(
        IN PPORT_MESSAGE pMsg
        );

    DWORD
    ProcessRequest(
        IN PSPROXY_MSG pMsg
        ) const;

    DWORD
    ProcessClientDeath(
        IN PSPROXY_MSG pMsg
        );

    DWORD
    ProcessPortClosure(
        IN PSPROXY_MSG pMsg,
        IN HANDLE     hPort
        );
    
    TLstMgr<TLPCMgr::TConnectedClientsInfo,ULONG_PTR>* 
    GetConnectedClients(
        VOID
        ) const;



    //
    // We define here 2 classes which encapsulate the connection
    // information for all Clients and those specific/client
    //
    class TClientInfo : public TGenericElement
    {
        //
        // Public methods
        //
        public:

        TClientInfo(
            VOID
            );

        TClientInfo(
            IN const HANDLE&
            );

        TClientInfo(
            IN const ULONG_PTR&
            );

        TClientInfo(
            IN const TLPCMgr::TClientInfo&
            );
        
        ~TClientInfo(
            VOID
            );

        const TClientInfo&
        operator=(
            IN const TLPCMgr::TClientInfo&
            );

        BOOL
        operator==(
            IN const TLPCMgr::TClientInfo&
            ) const;

        BOOL
        operator==(
            IN const HANDLE&
            ) const;

        BOOL
        operator!(
            VOID
            ) const;

        VOID
        SetValidity(
            DWORD 
            );

        BOOL
        Validate(
            VOID
            ) const;

        VOID
        SetPort(
            IN HANDLE InPort
            );

        HANDLE
        GetPort(
            VOID
            ) const;

        //
        // Private members and helper functions (if any)
        //
        private:

        ULONG_PTR  m_UniqueThreadID;
        HANDLE     m_hPort;
        DWORD      m_SanityChkMagic;
    };

    
    class TConnectedClientsInfo : public TGenericElement  
    {
        //
        // Public methods
        //
        public:

        enum EClientState
        {
            KClientDead  = 0,
            KClientAlive = 1
        };

        TConnectedClientsInfo(
            VOID
            );

        TConnectedClientsInfo(
            IN const ULONG_PTR&
            );

        TConnectedClientsInfo(
            IN const TClientInfo&
            );

        ~TConnectedClientsInfo(
            VOID
            );

        const TConnectedClientsInfo&
        operator=(
            IN const TConnectedClientsInfo&
            );

        BOOL
        operator==(
            IN const TConnectedClientsInfo&
            ) const;

        BOOL
        operator==(
            IN const ULONG_PTR&
            ) const;

        BOOL
        operator!(
            VOID
            ) const;

        VOID
        SetValidity(
            DWORD 
            );

        BOOL
        Validate(
            VOID
            ) const;

        TLstMgr<TLPCMgr::TClientInfo,HANDLE>*
        GetPerClientPorts(
            VOID
            ) const;

        ULONG_PTR
        GetUniqueProcessID(
            VOID
            ) const;

        VOID
        SetCurrentState(
            TConnectedClientsInfo::EClientState
            );

        TConnectedClientsInfo::EClientState 
        GetCurrentState(
            VOID
            ) const;

        //
        // Private members and helper functions (if any)
        //
        private:

        TConnectedClientsInfo::EClientState m_CurrentState;
        ULONG_PTR                           m_UniqueProcessID;
        TLstMgr<TClientInfo,HANDLE>         *m_pPerClientPorts;
    };


    private:
    TLoad64BitDllsMgr                        *m_pLdrObj;
    DWORD                                    m_CurrSessionId;
    HANDLE                                   m_UMPDLPCConnPortHandle;
    PFNGDIPRINTERTHUNKPROC                   m_pfn;
    TLstMgr<TConnectedClientsInfo,ULONG_PTR> *m_pCnctdClients;
};

#endif //__LPCMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\ldmgr.hpp ===
#ifndef __LDMGR_HPP__
#define __LDMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of classes necessary to 
     encapsulate the declarations and defintions and prototypes 
     required for the RPC surrogate used to load 64 bit dlls from
     within 32 bit apps.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:
--*/

#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

#ifndef __PRTCFG_HPP__
#include "prtcfg.hpp"
#endif

#ifndef __DRVEVNT_HPP__
#include "drvevnt.hpp"
#endif

#ifndef __PRNTUIFN_HPP__
#include "prntuifn.hpp"
#endif

#ifndef __LPCMGR_HPP__
#include "lpcmgr.hpp"
#endif


#define MAX_CAPVAL         DC_MEDIATYPES

#define APPNAME            L"splwow64"
#define GDI_LPC_PORT_NAME  L"\\RPC Control\\UmpdProxy"

#define ACTIVATION_CONTEXT_RESOURCE_ID  123

class TLoad64BitDllsMgr : public TClassID, 
                          public TRefCntMgr , 
                          public TLd64BitDllsErrorHndlr,
                          public TPrinterDriver
{
    public:

    friend DWORD 
    TLoad64BitDllsMgr::
    MonitorSrvrLifeExpiration(
        IN PVOID pData
        );

    TLoad64BitDllsMgr(
        OUT HRESULT *phRes = NULL
        );

    ~TLoad64BitDllsMgr(
        VOID
        );

    HRESULT 
    QueryInterface(
        IN  REFIID InterfaceID,
        OUT PVOID  *ppInterface
        );

    DWORD
    Run();

    VOID
    RefreshLifeSpan(
        VOID
        );
    

    BOOL
    ExecuteMonitorOperation(
        IN  ULONG_PTR  hWnd,
        IN  LPWSTR     pszServerName,
        IN  LPWSTR     pszUIDllName,
        IN  LPWSTR     pszPortName,
        IN  EPortOp    Index,
        OUT PDWORD     pErrorCode
        );

    int 
    DeviceCapabilities(
        IN  LPWSTR  pszDeviceName,
        IN  LPWSTR  pszPortName,
        IN  WORD    Capabilites,
        IN  DWORD   DevModeSize,
        IN  LPBYTE  pDevMode,
        IN  BOOL    bClonedOutputFill,
        OUT PDWORD  pClonedOutputSize,
        OUT LPBYTE  *ppClonedOutput,
        OUT PDWORD  pErrorCode
        );

    LONG
    DocumentProperties(
        IN  ULONG_PTR   hWnd,                     
        IN  LPWSTR      pszPrinterName,               
        OUT PDWORD      pTouchedDevModeSize,
        OUT PDWORD      pClonedDevModeOutSize,      
        OUT LPBYTE      *ppClonedDevModeOut,          
        IN  DWORD       DevModeSize,               
        IN  LPBYTE      pDevMode,                   
        IN  BOOL        bClonedDevModeOutFill,      
        IN  DWORD       fMode,                      
        OUT PDWORD      pErrorCode
        );

    LONG
    PrintUIDocumentProperties(
        IN  ULONG_PTR   hWnd,                     
        IN  LPWSTR      pszPrinterName,               
        OUT PDWORD      pTouchedDevModeSize,
        OUT PDWORD      pClonedDevModeOutSize,      
        OUT LPBYTE      *ppClonedDevModeOut,          
        IN  DWORD       DevModeSize,               
        IN  LPBYTE      pDevMode,                   
        IN  BOOL        bClonedDevModeOutFill,      
        IN  DWORD       fMode,                      
        IN  DWORD       fExclusionFlags,
        OUT PDWORD      pErrorCode
        );

    VOID 
    IncUIRefCnt(
        VOID
        );

    VOID 
    DecUIRefCnt(
        VOID
        );

    DWORD 
    GetUIRefCnt(
        VOID
        )const;

    DWORD
    GetCurrSessionId(
        VOID
        ) const;
    
    struct SPORTADDTHREADDATA
    {
        PFNMONITORADD    pMonFnAdd;
        PFNMONITORFNS    pMonFns;
        HWND             hWnd;
        PCWSTR           pszServerName;
        PCWSTR           pszMonitorName;
        PCWSTR           pszPortName;
        PWSTR            *ppszRetPortName;
        HMODULE          hLib;
        HANDLE           hActCtx;
        ULONG_PTR        lActCtx;
        BOOL             bActivated;
    };
    typedef struct SPORTADDTHREADDATA SPortAddThreadData;

    struct SDOCPROPSTHREADDATA
    {
        HWND              hWnd;                               
        LPWSTR            pszPrinterName;         
        PDWORD            pTouchedDevModeSize;
        PDWORD            pClonedDevModeOutSize;
        LPBYTE            *ppClonedDevModeOut;          
        DWORD             DevModeSize;               
        LPBYTE            pDevMode;                   
        TLoad64BitDllsMgr *pMgrInstance;
        DWORD             fMode;                               
        DWORD             fExclusionFlags;
        DWORD             ErrorCode;
        LONG              RetVal;
        BOOL              bClonedDevModeOutFill;
    };
    typedef struct SDOCPROPSTHREADDATA SDocPropsThreadData;

    enum ETime
    {
        KOneMinute  = 60000,
        KTwoMinutes = 120000
    };

    protected:

    DWORD
    StartLdrRPCServer(
        VOID
        );
    
    DWORD
    StopLdrRPCServer(
        VOID
        );

    static DWORD 
    MonitorSrvrLifeExpiration(
        IN PVOID pData
        );

    static DWORD
    AddPortUI(
        IN PVOID pInThrdData
        );

    static DWORD
    DeletePortUI(
        IN PVOID pInThrdData
        );
    
    static DWORD
    ConfigurePortUI(
        IN PVOID pInThrdData
        );

    DWORD
    InternalDocumentProperties(
        IN PVOID pInThrdData
        );

    DWORD
    InternalPrintUIDocumentProperties(
        IN PVOID pInThrdData
        );

    BOOL
    DevCapFillsOutput(
        IN DWORD Capabilities
        ) const;

    DWORD
    CalcReqSizeForDevCaps(
        IN DWORD CapNum,
        IN DWORD Capabilites
        ) const;

    DWORD 
    SpinPortOperationThread(
        IN HWND                   hWnd,
        IN LPWSTR                 pszServerName,
        IN LPWSTR                 pszName,
        IN PMONITORUI             pMonitorUI,
        IN EPortOp                Index,
        IN LPTHREAD_START_ROUTINE pThrdFn,
        IN HMODULE                hLib,
        IN HANDLE                 hActCtx,
        IN ULONG_PTR              lActCtx,
        IN BOOL                   bActivated
        ) const;

    DWORD
    GetMonitorUIActivationContext(
        IN     LPWSTR    pszUIDllName,
        IN OUT HANDLE    *phActCtx,
        IN OUT ULONG_PTR *plActCtx,
        IN OUT BOOL      *pActivated
        ) const;

    DWORD
    GetMonitorUIFullPath(
        IN     LPWSTR pszUIDllName,
        IN OUT LPWSTR pszFullPath
        ) const;


    VOID
    ReleaseMonitorActivationContext(
        IN HINSTANCE hLib    ,
        IN HANDLE    hActCtx ,
        IN ULONG_PTR lActCtx,
        IN BOOL      bActivated
        ) const;


    private:

    //
    // Some helper functions internal to the class
    //
    VOID 
    LockSelf(
        VOID
        );

    VOID 
    ReleaseSelf(
        VOID
        );

    BOOL
    StillAlive(
        VOID
        );

    //
    // The data encapsulated by the control.
    // This control has no data pertinent to itself. It only
    // encapsulates data pertinent to the synchronization of
    // of the requesting clients and timing out the whole 
    // control . It also has a session ID which identifies its
    // instantion across different sessions for Terminal Server.
    // Added to it also is a Port connection handle for GDI UMPD
    // thunking
    //
    DWORD                m_CurrSessionId;
    DWORD                m_UIRefCnt;
    DWORD                m_ExpirationTime;
    SYSTEMTIME           m_LastTransactionTime;
    CRITICAL_SECTION     m_LdMgrLock;
};

#endif //__LDMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\prntuifn.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prntuifn.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation for the Print UI
     class                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 31-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __PRNTUIFN_HPP__
#include "prntuifn.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


/* --------------------------------- */
/* Implemetation of class TPrintUIMgr */
/* --------------------------------- */


/*++
    Function Name:
        TPrintUIMgr :: TPrintUIMgr
     
    Description:
        Contructor of Print UI functions intstatiation 
        object
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrintUIMgr ::
TPrintUIMgr(
    IN TLoad64BitDllsMgr* pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    TClassID("TPrintUIMgr")
{
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TPrintUIMgr :: ~TPrintUIMgr
     
    Description:
        Destructor of Print UI functions intstatiation 
        object
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrintUIMgr ::
~TPrintUIMgr()
{
    m_pLdrObj->Release();
}


/*++
    Function Name:
        TPrintUIMgr :: QueueCreate
     
    Description:
        Creates a printer queue
            
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
QueueCreate(
    IN HWND    hWnd,
    IN LPCWSTR pszPrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vQueueCreate",
                         hWnd,
                         pszPrinterName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KQueueCreateOp);

}


/*++
    Function Name:
        TPrintUIMgr :: PrinterPropPages
     
    Description:
        This function opens the property sheet of specified printer.            
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
PrinterPropPages(
    IN HWND    hWnd,
    IN LPCWSTR pszPrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vPrinterPropPages",
                         hWnd,
                         pszPrinterName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KPrinterPropPagesOp);

}


/*++
    Function Name:
        TPrintUIMgr :: DocumentDefaults
     
    Description:
        Bring up document defaults
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
DocumentDefaults(
    IN HWND    hWnd,
    IN LPCWSTR pszPrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vDocumentDefaults",
                         hWnd,
                         pszPrinterName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KDocumentDefaultsOp);
}


/*++
    Function Name:
        TPrintUIMgr :: PrintUIMethod
     
    Description:
        Disptach the appropriate print UI method in
        a separate thread
            
    Parameters:
        Method      : Name of Method to be instantiated
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        pThrdFn     : Pointer to the Print UI method
        Op          : requested Print UI operation
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
PrintUIMethod(
    IN LPCSTR                  Method,
    IN HWND                    hWnd,
    IN LPCWSTR                 pszName,
    IN INT                     CmdShow,
    IN LPARAM                  lParam,
    IN LPTHREAD_START_ROUTINE  pThrdFn,
    IN TPrintUIMgr::EPrintUIOp Op
    )
{
    DWORD            ErrorCode = ERROR_SUCCESS;
    HANDLE           hPrintUI  = NULL;
    PFNPRINTUIMETHOD pfn;

    SPLASSERT(m_pLdrObj);

    m_pLdrObj->RefreshLifeSpan();

    if(hPrintUI = LoadLibrary(L"printui.dll"))
    {
        if(pfn = reinterpret_cast<PFNPRINTUIMETHOD>(GetProcAddress(hPrintUI,Method)))
        {
            SPrintUIThreadData* pNewThrdData = new SPrintUIThreadData;
            if(pNewThrdData)
            {
                HANDLE hPrintUIMethodThrd;
                DWORD  PrintUIThrdId;

                pNewThrdData->hWnd           = hWnd;
                pNewThrdData->pszName        = pszName;
                pNewThrdData->CmdShow        = CmdShow;
                pNewThrdData->lParam         = lParam;
                pNewThrdData->hLib           = hPrintUI;
                pNewThrdData->pLdrObj        = m_pLdrObj;
                pNewThrdData->pfn            = pfn;
                pNewThrdData->Op             = Op;

                if(hPrintUIMethodThrd = CreateThread(NULL,
                                                     0,
                                                     pThrdFn,
                                                     (PVOID)pNewThrdData,             
                                                     0,
                                                     &PrintUIThrdId))
                {
                    CloseHandle(hPrintUIMethodThrd);
                }
                else
                {
                    ErrorCode = GetLastError();
                    delete pNewThrdData;
                }

            }
            else
            {
                ErrorCode = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            ErrorCode = GetLastError();
        }
    }
    else
    {
        ErrorCode = GetLastError();
    }

    return ErrorCode;
}


/*++
    Function Name:
        TPrintUIMgr :: AsyncPrintUIMethod
     
    Description:
        The PrintUI method running in a separate thread
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        Always 0
--*/
DWORD
TPrintUIMgr ::
AsyncPrintUIMethod(
    IN PVOID pInThrdData
    )
{
     UINT msg;

     SPrintUIThreadData* pNewThreadData = reinterpret_cast<SPrintUIThreadData *>(pInThrdData);

     pNewThreadData->pLdrObj->IncUIRefCnt();
     {
         __try
         {
             pNewThreadData->pfn(pNewThreadData->hWnd,
                                 pNewThreadData->pszName,
                                 pNewThreadData->CmdShow,
                                 pNewThreadData->lParam);
         }
         __except(1)
         {
             DWORD ExcpVal = pNewThreadData->pLdrObj->TranslateExceptionCode(RpcExceptionCode());
             DBGMSG(DBG_WARN,
                    ("TPrintUIMgr::AsyncPrintUIMethod failed in calling printui with an exception %u",ExcpVal));
             SetLastError(ExcpVal);
         }
     }
     pNewThreadData->pLdrObj->DecUIRefCnt();

     //
     // Here we should post a message to the caller client window to inform 
     // it that the operation was completed and also whether it was succesful 
     // or not
     //
     switch(pNewThreadData->Op)
     {
         case TPrintUIMgr::KQueueCreateOp:
         {
             msg = WM_ENDQUEUECREATE;
             break;
         }
     
         case TPrintUIMgr::KPrinterPropPagesOp:
         {
             msg = WM_ENDPRINTERPROPPAGES;
             break;
         }
     
         case TPrintUIMgr::KDocumentDefaultsOp:
         {
             msg = WM_ENDDOCUMENTDEFAULTS;
             break;
         }

         case TPrintUIMgr::KServerPropPagesOp:
         {
             msg = WM_ENDSERVERPROPPAGES;
             break;
         }
     }
     PostMessage(pNewThreadData->hWnd,msg,
                 (WPARAM)0,
                 (LPARAM)0);

     //
     // Cleanup code
     //
     FreeLibrary(pNewThreadData->hLib);
     delete pInThrdData;

     return 0;
}

/*++
    Function Name:
        TPrintUIMgr :: PrinterSetup
     
    Description:
        Brings up the install printer wizard.
            
    Parameters:        
        hwnd            - Parent window.
        uAction         - Action requested (defined in windows\inc16\msprintx.h)
        cchPrinterName  - Length of pszPrinterName buffer.
        pszPrinterName  - Input setup printer name, Output pointer to new printer name
        pcchPrinterName - New length of pszPrinterName on return.
        pszServerName   - Name of server that printer is on.

    Return Value:

        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
PrinterSetup(
    IN     HWND    hWnd,
    IN     UINT    uAction,
    IN     UINT    cchPrinterName,
    IN OUT LPWSTR  pszPrinterName,
       OUT UINT*   pcchPrinterName,
    IN     LPCWSTR pszServerName
    )
{
    DWORD                   ErrorCode = ERROR_SUCCESS;
    HANDLE                  hPrintUI  = NULL;
    BOOL                    bRetVal   = FALSE;
    PFNPRINTUIPRINTERSETUP  pfn       = NULL;    
    UINT                    msg;

    SPLASSERT(m_pLdrObj);
    m_pLdrObj->RefreshLifeSpan();

    if(hPrintUI = LoadLibrary(L"printui.dll"))
    {
        if(pfn = reinterpret_cast<PFNPRINTUIPRINTERSETUP>(GetProcAddress(hPrintUI,"bPrinterSetup")))
        {
            m_pLdrObj->IncUIRefCnt();
            {
                __try
                {
                    bRetVal = pfn(hWnd,
                                  uAction,
                                  cchPrinterName,
                                  pszPrinterName,
                                  pcchPrinterName,
                                  pszServerName);
                    ErrorCode = GetLastError();
                }
                __except(1)
                {
                    DWORD ExcpVal = m_pLdrObj->TranslateExceptionCode(RpcExceptionCode());
                    DBGMSG(DBG_WARN,
                           ("TPrintUIMgr::PrinterSetup failed in calling printui with an exception %u",ExcpVal));
                    SetLastError(ExcpVal);
                    ErrorCode = ExcpVal;
                }
            }
            m_pLdrObj->DecUIRefCnt();
        }
        else
        {
            ErrorCode = GetLastError();
        }
        FreeLibrary(hPrintUI);
    }
    else
    {
        ErrorCode = GetLastError();
    }

    //
    // Here we should post a message to the caller client window to inform 
    // it that the operation was completed and also whether it was succesful 
    // or not
    //
    PostMessage(hWnd,WM_ENDPRINTERSETUP,
                (WPARAM)bRetVal,
                (LPARAM)ErrorCode);

    return ErrorCode;
}

/*++
    Function Name:
        TPrintUIMgr :: ServerPropPages
     
    Description:
        This function opens the property sheet of specified server.            
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Server name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
ServerPropPages(
    IN HWND    hWnd,
    IN LPCWSTR pszServerName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vServerPropPages",
                         hWnd,
                         pszServerName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KServerPropPagesOp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\lpcmgr.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     TLPCMgr.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file inlcuded the implementation of the class
     that processes both Connection and Communication Requests
     for the LPC port managing the Thunking between 32-bit and
     64-bit processes.        
  
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

/* ------------------------------------ */
/* Implemetation of class TLPCMgr        */
/* ------------------------------------ */


/*++
    Function Name:
        TLPCMgr :: TLPCMgr
     
    Description:
        Constructor of the LPC Thunking management object
     
    Parameters:
        TLoad64BitDllsMgr* : Pointer to the main loader object
                             which manage the process
        
    Return Value:
        None
--*/
TLPCMgr ::
TLPCMgr(
    IN TLoad64BitDllsMgr* pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    m_UMPDLPCConnPortHandle(NULL),
    TClassID("TLPCMgr")

{
    //
    // If we cann't create the list here. It would be a better idea
    // if we just continue for this session with leaks other than
    // failing the wow64 printing for this session
    //
    m_pCnctdClients = NULL;

    if(!(m_pCnctdClients = 
         new TLstMgr<TConnectedClientsInfo,ULONG_PTR>(TLstMgr<TConnectedClientsInfo,ULONG_PTR>::KUniqueEntries)))
    {
        DBGMSG(DBG_WARN, ("TLPCMgr ctor failer to create the list of connected Clients\n",GetLastError()));
    }
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TLPCMgr :: ~TLPCMgr
     
    Description:
        Destructor of the Printer(Driver) Event object    
     
    Parameters:
        None        
        
    Return Value:
        None
--*/
TLPCMgr ::
~TLPCMgr(
    VOID
    )
{
    if(m_pCnctdClients)
    {
        delete m_pCnctdClients;
    }

    m_pLdrObj->Release();
}


DWORD
TLPCMgr ::
GetCurrSessionId(
    VOID
    ) const
{
    return m_CurrSessionId;
}


VOID
TLPCMgr ::
SetCurrSessionId(
    DWORD InID
    )
{
    m_CurrSessionId = InID;
}


VOID
TLPCMgr ::
SetPFN(
    PFNGDIPRINTERTHUNKPROC InPFN
    )
{
    m_pfn = InPFN;
}

PFNGDIPRINTERTHUNKPROC
TLPCMgr ::
GetPFN(
    VOID
    )const
{
    return m_pfn;
}

    
/*++
    Function Name:
        TLPCMgr :: GetUMPDLPCConnPortHandlePtr
             
    Description:
        returns the address of the LPC port
                     
    Parameters:
        None
                             
     Return Value:
        Handle* : LPC Port Handle     
--*/
HANDLE*
TLPCMgr ::
GetUMPDLPCConnPortHandlePtr() 
{   
    return reinterpret_cast<HANDLE*>(&m_UMPDLPCConnPortHandle);
}


TLoad64BitDllsMgr* 
TLPCMgr ::
GetLdrObj(
    VOID
    ) const
{
    return m_pLdrObj;
}


HANDLE
TLPCMgr ::
GetUMPDLpcConnPortHandle(
    VOID
    )const
{
    return m_UMPDLPCConnPortHandle;
}


/*++
    Function Name:
        TLPCMgr :: InitUMPDLPCServer
             
    Description:
        Creates the Thread handling LPC operations for 
        GDI thunking 
                     
    Parameters:
        None
                             
     Return Value:
        DWORD ErrorCode : ERROR_SUCCESS in case of success
                          LastError in case of failure     
--*/
DWORD
TLPCMgr ::
InitUMPDLPCServer(
    VOID
    )
{
    DWORD             ThnkThreadId   = 0;
    HANDLE            hThnkThrd      = NULL;
    SGDIThnkThrdData  SThrdData      = {0};
    HANDLE            hThnkSyncEvent = NULL;
    DWORD             ErrorCode      = ERROR_SUCCESS;

    if(hThnkSyncEvent = CreateEvent(NULL,FALSE,FALSE,NULL))
    {
        SThrdData.hEvent    = hThnkSyncEvent;
        SThrdData.pData     = reinterpret_cast<ULONG_PTR*>(this);
        SThrdData.ErrorCode = ERROR_SUCCESS;

        //
        // At this stage we spin a new Thread which creates the LPC
        // port and starts waiting on both connection and communication
        // requests
        // 
        if(hThnkThrd  =  CreateThread(NULL,0,
                                      GDIThunkingVIALPCThread,
                                      &SThrdData,
                                      0,
                                      &ThnkThreadId))
        {
            CloseHandle(hThnkThrd);
            WaitForSingleObject(hThnkSyncEvent,INFINITE);

            if(!*(GetUMPDLPCConnPortHandlePtr()))
            {
                //
                // If here then we failed to create the LPC port
                //
                ErrorCode = SThrdData.ErrorCode;
                DBGMSG(DBG_WARN, ("Failed to create the LPC port with error %u\n",ErrorCode));
            }
        }
        else
        {
            ErrorCode = GetLastError();
            DBGMSG(DBG_WARN, ("Failed to spin the GDI Thunking thread with Error %u\n",ErrorCode));
        }
        CloseHandle(hThnkSyncEvent);
    }
    else
    {
        ErrorCode = GetLastError();
        DBGMSG(DBG_WARN, ("Failed to create the synchronization event with Error %u\n",ErrorCode));
    }

    return ErrorCode;
}

DWORD
TLPCMgr ::
ProcessConnectionRequest(
    IN PPORT_MESSAGE pMsg
    )
{
    NTSTATUS Status;
    HANDLE   CommunicationPortHandle;

    DBGMSG(DBG_WARN,
           ("Processing Connection Request\n"));

    //
    // Since this is a new connection then we carry out 2 work items
    // 1. Add the Client to the list of connected clients
    // 2. Allocate a Port Context to be used by LPC for consecutive 
    // operations on this port.
    //
    if(TClientInfo *pClientInfoInstant = new TClientInfo(pMsg->ClientId.UniqueThread))
    {
        //
        // While Accepting the connection we also set in the communication Port
        // context used for communication with this particular client, the refrence
        // to the clients info which saves the communication port handle and other
        // data
        //
        Status = NtAcceptConnectPort(&CommunicationPortHandle,
                                     (PVOID)pClientInfoInstant,
                                     pMsg,
                                     1,
                                     NULL,
                                     NULL);
        if(NT_SUCCESS(Status))
        {
            pClientInfoInstant->SetPort(CommunicationPortHandle);

            Status = NtCompleteConnectPort(CommunicationPortHandle);

            if(!NT_SUCCESS(Status))
            {
                DBGMSG(DBG_WARN,
                       ("TLPCMgr::ProcessConnectionRequest failed to complete port connection - %u \n",Status));

            }
            else
            {
                if(m_pCnctdClients)
                {
                    //
                    // We maintain an internal list of all connected clients based on their Thread and 
                    // Process ID . So things look like
                    //
                    //
                    //                                    -----            -----            -----
                    //     List of Processes (Apps)----> |    | ----------|    | ----------|    |
                    //                                   |    |           |    |           |    |
                    //                                    -----            -----            ----- 
                    //                                     |
                    //                                     |
                    //                                     |
                    //                                 ---------
                    //                                |        |
                    //                                 ---------
                    //                                    |
                    //                                    |
                    //                                    |
                    //                                ---------
                    //             Thread/App -----> |        |
                    //                                ---------
                    //
                    TLstNd<TConnectedClientsInfo,ULONG_PTR> *pNode = NULL;

                    if((pNode = m_pCnctdClients->ElementInList((ULONG_PTR)pMsg->ClientId.UniqueProcess)) ||
                       (pNode = m_pCnctdClients->AppendListByElem((ULONG_PTR)pMsg->ClientId.UniqueProcess)))
                    {
                        ((*(*pNode)).GetPerClientPorts())->AppendListByElem(pClientInfoInstant);
                    }
                    else
                    {
                        Status = STATUS_NO_MEMORY;
                    }
                }
                m_pLdrObj->IncUIRefCnt();
            }
        }
        else
        {
            DBGMSG(DBG_WARN,
                   ("TLPCMgr :: ProcessConnectionRequest failed to accept port connection - %u \n",Status));
        }
    }
    else
    {
        Status = STATUS_NO_MEMORY;
        DBGMSG(DBG_WARN,
               ("TLPCMgr :: ProcessConnectionRequest failed to create the CleintInfo for Port Context - %u \n",Status));

    }

    return !!Status;
}

DWORD
TLPCMgr ::
ProcessRequest(
    IN PSPROXY_MSG pMsg
    ) const
{
    ULONG DataSize;
    DWORD ErrorCode = ERROR_SUCCESS;

    DBGMSG(DBG_WARN,
           ("Processing Request\n"));


    if (((DataSize = pMsg->Msg.u1.s1.DataLength) == (sizeof(*pMsg) - sizeof(pMsg->Msg))) &&
         m_pfn)
    {
        UMTHDR*  pUmHdr = reinterpret_cast<UMTHDR*>(reinterpret_cast<PSPROXYMSGEXTENSION>(pMsg->MsgData)->pvIn);
        PVOID    pvOut  = reinterpret_cast<PSPROXYMSGEXTENSION>(pMsg->MsgData)->pvOut;
        ULONG    cjOut  = reinterpret_cast<PSPROXYMSGEXTENSION>(pMsg->MsgData)->cjOut;

        DBGMSG(DBG_WARN,("ProcessRequest handling thunk %d \n",pUmHdr->ulType));

        m_pfn(pUmHdr,
              pvOut, 
              cjOut);
    }
    else
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        DBGMSG(DBG_WARN,
               ("Failed to process the client request %u\n",ErrorCode));
    }

    return ErrorCode;
}

DWORD
TLPCMgr ::
ProcessClientDeath(
    IN PSPROXY_MSG pMsg
    )
{
    DWORD                                    ErrorCode = ERROR_SUCCESS;
    TLstNd<TConnectedClientsInfo,ULONG_PTR>  *pNode     = NULL;

    DBGMSG(DBG_WARN,
           ("Processing Client Death \n"));


    if(pNode = 
       (GetConnectedClients())->ElementInList((ULONG_PTR)pMsg->Msg.ClientId.UniqueProcess))
    {
        if(((*(*pNode)).GetCurrentState()) == TConnectedClientsInfo::KClientAlive)
        {
            ((*(*pNode)).SetCurrentState(TConnectedClientsInfo::KClientDead));
        }
    }
    else
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        DBGMSG(DBG_WARN,
               ("Failed to Process Client Death \n",ErrorCode));
    }

    return(ErrorCode);
}


DWORD
TLPCMgr ::
ProcessPortClosure(
    IN PSPROXY_MSG pMsg,
    IN HANDLE      hPort
    )
{
    DWORD                                    ErrorCode = ERROR_SUCCESS;
    TLstNd<TConnectedClientsInfo,ULONG_PTR>  *pNode      = NULL;

    DBGMSG(DBG_WARN,
           ("Processing Port Closure \n"));


    if(pNode = 
       (GetConnectedClients())->ElementInList((ULONG_PTR)pMsg->Msg.ClientId.UniqueProcess))
    {
        ((*(*pNode)).GetPerClientPorts())->RmvElemFromList((HANDLE)hPort);

        if(!((*(*pNode)).GetPerClientPorts())->GetNumOfListNodes() &&
           (((*(*pNode)).GetCurrentState()) == TConnectedClientsInfo::KClientDead))
        {
            m_pCnctdClients->RmvElemFromList((ULONG_PTR)pMsg->Msg.ClientId.UniqueProcess);
        }
        m_pLdrObj->DecUIRefCnt();
    }
    else
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        {
            DBGMSG(DBG_WARN,
                   ("Failed to Process Port Closure \n",ErrorCode));

        }
    }

    return(ErrorCode);
}


TLstMgr<TLPCMgr::TConnectedClientsInfo,ULONG_PTR>* 
TLPCMgr::
GetConnectedClients(
    VOID
    ) const
{
    return m_pCnctdClients;
}



TLPCMgr::
TClientInfo::
TClientInfo() :
    m_UniqueThreadID(NULL),    
    m_hPort(NULL),         
    m_SanityChkMagic(UMPD_SIGNATURE)
{
}


TLPCMgr::
TClientInfo::
TClientInfo(
    IN const HANDLE& InPort
    ) :
    m_UniqueThreadID(NULL),
    m_hPort(InPort),
    m_SanityChkMagic(UMPD_SIGNATURE)
{

}


TLPCMgr::
TClientInfo::
TClientInfo(
    IN const ULONG_PTR& InThreadID
    ) :
    m_UniqueThreadID(InThreadID),
    m_hPort(NULL),
    m_SanityChkMagic(UMPD_SIGNATURE)
{

}


TLPCMgr::
TClientInfo::
TClientInfo(
     IN const TClientInfo& InInfo
     ) :
    m_UniqueThreadID(InInfo.m_UniqueThreadID),
    m_hPort(InInfo.m_hPort),
    m_SanityChkMagic(InInfo.m_SanityChkMagic)
{

}


TLPCMgr::
TClientInfo::
~TClientInfo(
    VOID
    )
{

}


const TLPCMgr::TClientInfo&
TLPCMgr::
TClientInfo::
operator=(
    IN const TClientInfo& InInfo
    )
{
    if(&InInfo != this)
    {
        m_UniqueThreadID   = InInfo.m_UniqueThreadID;
        m_hPort            = InInfo.m_hPort;
        m_SanityChkMagic   = InInfo.m_SanityChkMagic;
    }

    return *this;
}


BOOL
TLPCMgr::
TClientInfo::
operator==(
    IN const TClientInfo& InInfo
    ) const
{
    return m_hPort == InInfo.m_hPort;
}


BOOL
TLPCMgr::
TClientInfo::
operator==(
    IN const HANDLE& InPort
    ) const
{
    return m_hPort == InPort;
}


BOOL
TLPCMgr::
TClientInfo::
operator!(
    VOID
    ) const
{
    return (m_hPort && m_SanityChkMagic == UMPD_SIGNATURE);        
}


VOID
TLPCMgr::
TClientInfo::
SetValidity(
    DWORD 
    )
{

}

BOOL
TLPCMgr::
TClientInfo::
Validate(
    VOID
    ) const
{
    return (m_hPort && m_SanityChkMagic == UMPD_SIGNATURE);
}

VOID
TLPCMgr::
TClientInfo::
SetPort(
    IN HANDLE InPort
    )
{
    m_hPort = InPort;
}

HANDLE
TLPCMgr::
TClientInfo::
GetPort(
    VOID
    ) const
{
    return m_hPort;
}



TLPCMgr::
TConnectedClientsInfo::
TConnectedClientsInfo() :
    m_UniqueProcessID(NULL),
    m_CurrentState(KClientAlive)
{
    m_pPerClientPorts = new TLstMgr<TClientInfo,HANDLE>(TLstMgr<TClientInfo,HANDLE>::KUniqueEntries);
}


TLPCMgr::
TConnectedClientsInfo::
TConnectedClientsInfo(
    IN const ULONG_PTR& InProcess
    ) :
    m_UniqueProcessID(InProcess),
    m_CurrentState(KClientAlive)
{
    m_pPerClientPorts = new TLstMgr<TClientInfo,HANDLE>(TLstMgr<TClientInfo,HANDLE>::KUniqueEntries);
}


TLPCMgr::
TConnectedClientsInfo::
TConnectedClientsInfo(
     IN const TClientInfo& InInfo
     )
{
    //
    // I am not sure if I want this at this stage or not
    // especially with the required deep copy for the list
    // of ports.
    //
}


TLPCMgr::
TConnectedClientsInfo::
~TConnectedClientsInfo()
{
    if(m_pPerClientPorts)
    {
        delete m_pPerClientPorts;
    }
}


const TLPCMgr::TConnectedClientsInfo&
TLPCMgr::
TConnectedClientsInfo::
operator=(
    IN const TConnectedClientsInfo& InInfo
    )
{
    if(&InInfo != this)
    {
        //
        // Also here I am not sure whether I want to implement a deep copy for the
        // list or not
        // (TO BE IMPLEMENTED LATER)
        //
    }
    return *this;
}


BOOL
TLPCMgr::
TConnectedClientsInfo::
operator==(
    IN const TConnectedClientsInfo& InInfo
    ) const
{
    return (m_UniqueProcessID == InInfo.m_UniqueProcessID);
}


BOOL
TLPCMgr::
TConnectedClientsInfo::
operator==(
    IN const ULONG_PTR& InProcess
    ) const
{
    return m_UniqueProcessID == InProcess;
}


BOOL
TLPCMgr::
TConnectedClientsInfo::
operator!(
    VOID
    ) const
{
    return !!m_UniqueProcessID;        
}


VOID
TLPCMgr::
TConnectedClientsInfo::
SetValidity(
    DWORD 
    )
{

}

BOOL
TLPCMgr::
TConnectedClientsInfo::
Validate(
    VOID
    ) const
{
    //
    // Still (TO BE IMPLEMENTED)
    // never being called
    //
    return FALSE;
}


TLstMgr<TLPCMgr::TClientInfo,HANDLE>*
TLPCMgr::
TConnectedClientsInfo::
GetPerClientPorts(
    VOID
    ) const
{
    return m_pPerClientPorts;
}

ULONG_PTR
TLPCMgr::
TConnectedClientsInfo::
GetUniqueProcessID(
    VOID
    ) const
{
    return m_UniqueProcessID;
}

VOID
TLPCMgr::
TConnectedClientsInfo::
SetCurrentState(
    TLPCMgr::TConnectedClientsInfo::EClientState InState
    )
{
    m_CurrentState = InState;
}

TLPCMgr::
TConnectedClientsInfo::
EClientState
TLPCMgr::
TConnectedClientsInfo::
GetCurrentState(
    VOID
    ) const
{
    return m_CurrentState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\prntuifn.hpp ===
#ifndef __PRNTUIFN_HPP__
#define __PRNTUIFN_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prntuifn.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of the class
     dealing printui functionality and it currently contains
     the following interfaces
     o QueueCreate
     o PrinterPropPages
     o DocumentDefaults
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 31-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TPrintUIMgr : public TClassID,
                    public TLd64BitDllsErrorHndlr,
                    public TRefCntMgr
{
    public:

    TPrintUIMgr(
        IN TLoad64BitDllsMgr *pIpLdrObj
        );

    ~TPrintUIMgr(
        VOID
        );

    DWORD 
    QueueCreate(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    DWORD 
    PrinterPropPages(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    DWORD 
    DocumentDefaults(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    DWORD 
    PrinterSetup(
        IN     HWND    hWnd,
        IN     UINT    uAction,
        IN     UINT    cchPrinterName,
        IN OUT LPWSTR  pszPrinterName,
           OUT UINT*   pcchPrinterName,
        IN     LPCWSTR pszServerName
        );

    DWORD 
    ServerPropPages(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    static DWORD
    AsyncPrintUIMethod(
        IN PVOID InThrdData
        );

    enum EPrintUIOp
    {
        KQueueCreateOp = 0,
        KPrinterPropPagesOp,
        KDocumentDefaultsOp,
        KServerPropPagesOp
    };

    struct SPRINTUITHREADDATA
    {
        HWND                    hWnd;
        LPCWSTR                 pszName;
        LPARAM                  lParam;
        HANDLE                  hLib;
        TLoad64BitDllsMgr       *pLdrObj;
        PFNPRINTUIMETHOD        pfn;  
        TPrintUIMgr::EPrintUIOp Op;
        int                     CmdShow;
    };
    typedef struct SPRINTUITHREADDATA SPrintUIThreadData;

    struct SPRINTERSETUPTHRDDATA
    {
        HWND                    hWnd;
        LPWSTR                  pszPrinterName;
        LPCWSTR                 pszServerName;
        HANDLE                  hLib;
        TLoad64BitDllsMgr       *pLdrObj;
        UINT*                   pcchPrinterName;
        PFNPRINTUIPRINTERSETUP  pfn;  
        UINT                    uAction;
        UINT                    cchPrinterName;
    };
    typedef struct SPRINTERSETUPTHRDDATA SPrinterSetupThrdData;

    protected:
    DWORD 
    PrintUIMethod(
        IN LPCSTR                  Method,
        IN HWND                    hWnd,
        IN LPCWSTR                 pszName,
        IN INT                     CmdShow,
        IN LPARAM                  lParam,
        IN LPTHREAD_START_ROUTINE  pThrdFn,
        IN TPrintUIMgr::EPrintUIOp Op
        );

    private:
    
    HWND
    GetForeGroundWindow(
        VOID
        );

    TLoad64BitDllsMgr   *m_pLdrObj;
};

#endif //__PRNTUIFN_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\prtcfg.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prtcfg.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation for the Printer
     and Document Property class                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop


#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


/* ------------------------------------ */
/* Implemetation of class TPrinterCfgMgr */
/* ------------------------------------ */


/*++
    Function Name:
        TPrintUIMgr :: TPrintUIMgr
     
    Description:
        Contructor of the Printer (Driver) configuration  
        manager 
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrinterCfgMgr::
TPrinterCfgMgr(
    TLoad64BitDllsMgr *pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    TClassID("TPrinterCfgMgr")
{
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TPrintUIMgr :: TPrintUIMgr
     
    Description:
        Destructor of the Printer (Driver) configuration  
        manager 
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrinterCfgMgr::
~TPrinterCfgMgr(
    VOID
    )
{
    m_pLdrObj->Release();
}


/*++
    Function Name:
        TPrintUIMgr :: PrinterProperties
     
    Description:
        Displays a Printer-properties property sheet
        for the specific printer
     
    Parameters:
        hWnd        : Parent Window
        Printername : Printer Name
        Flag        : Access permissions
        ErrorCode   : Win32 error in case of failure
        
    Return Value:
        BOOL        : FALSE for failure
                      TRUE  for success
--*/
BOOL
TPrinterCfgMgr ::
PrinterProperties(
    IN  ULONG_PTR   hWnd,
    IN  LPCWSTR     pszPrinterName,
    IN  DWORD       Flag,
    OUT PDWORD      pErrorCode
    )
{
     DEVICEPROPERTYHEADER  DPHdr;
     DWORD                 Result;
     PFNDEVICEPROPSHEETS   pfnDevicePropSheets;
     HANDLE                hPrinter  = NULL;
     HMODULE               hWinSpool = NULL;
     BOOL                  RetVal    = FALSE;

     if(hWinSpool = LoadLibrary(L"winspool.drv"))
     {
          if(pfnDevicePropSheets = reinterpret_cast<PFNDEVICEPROPSHEETS>(GetProcAddress(hWinSpool,
                                                                                        "DevicePropertySheets")))
          {
               if(OpenPrinter(const_cast<LPWSTR>(pszPrinterName),
                              &hPrinter,NULL))
               {
                    PFNCALLCOMMONPROPSHEETUI  pfnCallCommonPropSheeUI = NULL;

                    DPHdr.cbSize         = sizeof(DPHdr);
                    DPHdr.hPrinter       = hPrinter;
                    DPHdr.Flags          = (WORD)Flag;
                    DPHdr.pszPrinterName = const_cast<LPWSTR>(pszPrinterName);

                    if(pfnCallCommonPropSheeUI= reinterpret_cast<PFNCALLCOMMONPROPSHEETUI>(GetProcAddress(hWinSpool,
                                                                                                          (LPCSTR) MAKELPARAM(218, 0))))
                    {
                        m_pLdrObj->IncUIRefCnt();
                        {
                             if(pfnCallCommonPropSheeUI(reinterpret_cast<HWND>(hWnd),
                                                        pfnDevicePropSheets,
                                                        (LPARAM)&DPHdr,
                                                        (LPDWORD)&Result) < 0)
                             {
                                  RetVal = FALSE;
                                  *pErrorCode = GetLastError();
                             }
                             else
                             {
                                  RetVal = TRUE;
                             }
                             PostMessage(reinterpret_cast<HWND>(hWnd),
                                         WM_ENDPRINTERPROPERTIES,
                                         (WPARAM)RetVal,
                                         (LPARAM)*pErrorCode);
                        }
                        m_pLdrObj->DecUIRefCnt();
                    }
                    else
                    {
                         *pErrorCode = GetLastError();
                    }
                    CloseHandle(hPrinter);
               }
               else
               {
                    *pErrorCode = GetLastError();
               }
          }
          else
          {
               *pErrorCode = GetLastError();
          }
          FreeLibrary(hWinSpool);
     }
     else
     {
          *pErrorCode = GetLastError();
     }

     return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\splwow64s.c ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     splwow64.cxx                                                             
                                                                              
  Abstract:                                                                   
    Stub file to allow splwow64_s.c to be included easily in 
    the sources directory from the idl directory
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "splwow64_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\splwow64\server\prtcfg.hpp ===
#ifndef __PRTDRV_HPP__
#define __PRTDRV_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prtdrv.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of the class
     dealing Printer and Documet properties
     o DocumentProperties
     o PrinterProperties
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TPrinterCfgMgr : public TClassID,
                       public TLd64BitDllsErrorHndlr,
                       public TRefCntMgr
{
     public:

     TPrinterCfgMgr(
         IN TLoad64BitDllsMgr *pIpLdrObj
         );

     ~TPrinterCfgMgr(
         VOID
         );

     BOOL 
     PrinterProperties(
         IN  ULONG_PTR   hWnd,
         IN  LPCWSTR     pszPrinterName,
         IN  DWORD       Flag,
         OUT PDWORD      pErrorCode
         );

     private:
     TLoad64BitDllsMgr *m_pLdrObj;
};

#endif //__PRTCFG_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines

Author:

    Dave Snipp (davesn)     01-Jun-1991

Environment:

    User Mode -Win32

Revision History:

--*/

//
// INCLUDES
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <excpt.h>
#include <rpc.h>    // DataTypes and runtime APIs
#include <winspl.h> // generated by the MIDL complier
#include <string.h>
#include <splcom.h>

LPWSTR InterfaceAddress = L"\\pipe\\spoolss";
handle_t GlobalBindHandle;

#ifdef DEBUG_BIND_CREF
#include "spllib.hxx"

//
// This code can be used to track down any bind leaks.
//

HANDLE gpbtHandleBind;
HANDLE gpbtStringBind;

PDBG_POINTERS gpDbgPointers;

UINT gcHandleBind;
UINT gcStringBind;

CRITICAL_SECTION csBind;

VOID
InitDebug(
    VOID
    )
{
    InitializeCriticalSection( &csBind );
    gpDbgPointers = DbgGetPointers();

    if( gpDbgPointers ){

        gpbtHandleBind = gpDbgPointers->pfnAllocBackTraceMem();;
        gpbtStringBind = gpDbgPointers->pfnAllocBackTraceMem();;
    }
}

VOID
DbgBindIncRef(
    HANDLE hBackTrace,
    PUINT pcBind
    )
{
    EnterCriticalSection( &csBind );

    ++(*pcBind);

    gpDbgPointers->pfnCaptureBackTrace( hBackTrace,
                                        *pcBind-1,
                                        *pcBind,
                                        0 );

    LeaveCriticalSection( &csBind );
}


VOID
DbgBindDecRef(
    HANDLE hBackTrace,
    PUINT pcBind
    )
{
    EnterCriticalSection( &csBind );

    --(*pcBind);

    gpDbgPointers->pfnCaptureBackTrace( hBackTrace,
                                        *pcBind+1,
                                        *pcBind,
                                        0 );

    LeaveCriticalSection( &csBind );
}
#endif


handle_t
PRINTER_HANDLE_bind (
    PRINTER_HANDLE   hPrinter)

/*++

Routine Description:

    This routine is used to obtain a binding to the printer spooler.

Arguments:

    Server - Supplies the name of the server where the printer spooler
        should be binded with.

Return Value:

    A binding to the server will be returned, unless an error occurs,
    in which case zero will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", 0, InterfaceAddress,
                       L"Security=Impersonation Static False", &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

#ifdef DEBUG_BIND_CREF
    DbgBindIncRef( gpbtHandleBind,
                   &gcHandleBind );
#endif

    return(BindingHandle);
}



void
PRINTER_HANDLE_unbind (
    PRINTER_HANDLE hPrinter,
    handle_t       BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);


#ifdef DEBUG_BIND_CREF
    DbgBindDecRef( gpbtHandleBind,
                   &gcHandleBind );
#endif

    return;
}


handle_t
STRING_HANDLE_bind (
    STRING_HANDLE  lpStr)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    lpStr - \\ServerName\PrinterName

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;
    WCHAR   ServerName[MAX_PATH + 2];
    DWORD   i;


    if (lpStr && lpStr[0] == L'\\' && lpStr[1] == L'\\') {

        // We have a servername
        for (i = 2 ; lpStr[i] && lpStr[i] != L'\\' ; ++i)
            ;

        if (i >= COUNTOF(ServerName))
            return FALSE;
        
        wcsncpy(ServerName, lpStr, i);
        ServerName[i] = L'\0';

    } else

        return FALSE;

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", ServerName,
                                         InterfaceAddress,
                                         L"Security=Impersonation Dynamic True",
                                         &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

#ifdef DEBUG_BIND_CREF
    DbgBindIncRef( gpbtStringBind,
                   &gcStringBind );
#endif

    return(BindingHandle);
}



void
STRING_HANDLE_unbind (
    STRING_HANDLE  lpStr,
    handle_t    BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus != RPC_S_INVALID_BINDING);

#ifdef DEBUG_BIND_CREF
    DbgBindDecRef( gpbtStringBind,
                   &gcStringBind );
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\data.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <splapip.h>
#include <offsets.h>
#include <stddef.h>


#define PRINTER_STRINGS
#define PRINTER_OFFSETS

#define JOB_STRINGS
#define JOB_OFFSETS

#define DRIVER_STRINGS
#define DRIVER_OFFSETS

#define ADDJOB_STRINGS
#define ADDJOB_OFFSETS

#define FORM_STRINGS
#define FORM_OFFSETS

#define PORT_STRINGS
#define PORT_OFFSETS

#define PRINTPROCESSOR_STRINGS
#define PRINTPROCESSOR_OFFSETS

#define MONITOR_STRINGS
#define MONITOR_OFFSETS

#define DOCINFO_STRINGS
#define DOCINFO_OFFSETS

#define DATATYPE_OFFSETS
#define DATATYPE_STRINGS

#define PROVIDOR_STRINGS

#define PRINTER_ENUM_VALUES_OFFSETS

#include <data.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\cachemon.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachemon.c

Abstract:

    This module contains the Cache Port handling for Win32Spl
    true connected printers.

Author:

    Matthew A Felton ( MattFe ) July 23 1994

Revision History:
    July 23 1994 - Created.

Notes:

    We shold collapse the LM Ports and the Win32 ports so they have use common
    ports.

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <wchar.h>
#include "splapip.h"
#include <w32types.h>
#include "local.h"
#include "splcom.h"



PWINIPORT pW32FirstPort = NULL;


BOOL
OpenPort(
    LPWSTR   pName,
    PHANDLE pHandle
)
{
    DBGMSG(DBG_TRACE, ("OpenPort %ws %x\n", pName, pHandle));
    *pHandle = NULL;
    return  TRUE;
}

BOOL
StartDocPort(
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    DBGMSG(DBG_TRACE, ("StartDocPort %x %ws %d %d %x\n", hPort, pPrinterName, JobId, Level, pDocInfo));
    return  TRUE;
}

BOOL
ReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuf,
    LPDWORD pcbRead
)
{
    DBGMSG(DBG_TRACE, ("ReadPort %x %x %d %x\n", hPort, pBuffer, cbBuf, pcbRead));
    return  TRUE;
}


BOOL
WritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
)
{
    DBGMSG(DBG_TRACE, ("WritePort %x %x %d %x\n", hPort, pBuffer, cbBuf, pcbWritten));
    return  TRUE;
}

BOOL
EndDocPort(
   HANDLE   hPort
)
{
    DBGMSG(DBG_TRACE, ("EndDocPort %x\n", hPort ));
    return  TRUE;
}

BOOL
XcvOpenPort(
    PCWSTR  pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
)
{
    DBGMSG(DBG_TRACE, ("XcvOpenPort\n"));
    return TRUE;
}

DWORD
XcvDataPort(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
)
{
    DBGMSG(DBG_TRACE, ("XcvDataPort\n"));
    return TRUE;
}


BOOL
XcvClosePort(
    HANDLE  hXcv
)
{
    DBGMSG(DBG_TRACE, ("XcvClosePort\n"));
    return TRUE;
}


BOOL
ClosePort(
    HANDLE  hPort
)
{
    DBGMSG(DBG_TRACE, ("ClosePort %x\n", hPort ));
    return  TRUE;
}

BOOL
DeletePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    DBGMSG(DBG_TRACE, ("DeletePortW %ws %x %ws\n", pName, hWnd, pPortName));
    return  TRUE;
}

BOOL
AddPortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
)
{
    BOOL    ReturnValue = FALSE;

    DBGMSG(DBG_TRACE, ("AddPortW %ws %x %ws\n", pName, hWnd, pMonitorName));

    if ( _wcsicmp( pMonitorName, pszMonitorName ) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto    AddPortWErrorReturn;
    }

    SetLastError( ERROR_NOT_SUPPORTED );

AddPortWErrorReturn:
    return  ReturnValue;
}

BOOL
ConfigurePortW(
    LPWSTR   pName,
    HWND  hWnd,
    LPWSTR pPortName
)
{
    DBGMSG(DBG_TRACE, ("ConfigurePortW %ws %x %ws\n", pName, hWnd, pPortName));
    return  TRUE;
}




BOOL
AddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   LastError = ERROR_SUCCESS;
    PPORT_INFO_1 pPortInfo = (PPORT_INFO_1)pBuffer;

    EnterSplSem();

    DBGMSG(DBG_TRACE, ("AddPortEx %x %d %x %ws %ws\n", pName, Level, pBuffer, pPortInfo->pName, pMonitorName));

    if ( _wcsicmp( pMonitorName, pszMonitorName ) ) {
        LastError = ERROR_INVALID_PARAMETER;
        goto    AddPortExErrorReturn;
    }

    //
    //  Make Sure Port doesn't already exist
    //


    if ( FindPort( pPortInfo->pName, pW32FirstPort ) ) {
        LastError = ERROR_INVALID_NAME;
        goto    AddPortExErrorReturn;

    }

    if ( CreatePortEntry( pPortInfo->pName, &pW32FirstPort ) )
        ReturnValue = TRUE;


AddPortExErrorReturn:
    LeaveSplSem();

    if  (LastError != ERROR_SUCCESS) {
        SetLastError( LastError );
        ReturnValue = FALSE;
    }

    return  ReturnValue;
}






BOOL
EnumPortsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PWINIPORT pIniPort;
    DWORD   cb;
    LPBYTE  pEnd;
    DWORD   LastError=0;

    switch (Level) {

        case 1:
        case 2:
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

   EnterSplSem();

    DBGMSG(DBG_TRACE, ("EnumPortW %x %d %x %d %x %x\n", pName, Level, pPorts, cbBuf, pcbNeeded, pcReturned));

    cb=0;

    pIniPort = pW32FirstPort;

    while (pIniPort) {

        cb += GetPortSize(pIniPort, Level);
        pIniPort = pIniPort->pNext;
    }

    *pcbNeeded=cb;

    if (cb <= cbBuf) {

        pEnd=pPorts+cbBuf;
        *pcReturned=0;

        pIniPort = pW32FirstPort;

        while (pIniPort) {

            pEnd = CopyIniPortToPort(pIniPort, Level, pPorts, pEnd);

            switch (Level) {

                case 1:
                    pPorts+=sizeof(PORT_INFO_1);
                    break;

                case 2:
                    pPorts+=sizeof(PORT_INFO_2);
                    break;
            }

            pIniPort=pIniPort->pNext;
            (*pcReturned)++;
        }

    } else {
        *pcReturned = 0;
        LastError = ERROR_INSUFFICIENT_BUFFER;

    }

   LeaveSplSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;

    } else

        return TRUE;
}

MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        EnumPortsW,
        OpenPort,
        NULL,           // OpenPortEx is not supported
        StartDocPort,
        WritePort,
        ReadPort,
        EndDocPort,
        ClosePort,
        AddPort,
        AddPortEx,
        ConfigurePortW,
        DeletePortW,
        NULL,           // GetPrinterDataFromPort not supported
        NULL,           // SetPortTimeouts not supported
        XcvOpenPort,
        XcvDataPort,
        XcvClosePort        
    }                                       
};


LPMONITOREX
InitializePrintMonitor(
    LPWSTR  pRegistryRoot
    )
{
    BOOL    bRet = TRUE;

    DBGMSG(DBG_TRACE, ("InitializeMonitor %ws\n", pRegistryRoot));

    EnterSplSem();

    if (!FindPort(L"NExx:", pW32FirstPort ) ) {
        if ( !CreatePortEntry( L"NExx:", &pW32FirstPort ) ) {

            DBGMSG( DBG_WARNING,("InitializeMonitor Failed to CreatePortEntry\n"));
            bRet = FALSE;
        }
    }
    LeaveSplSem();

    return  bRet ? &MonitorEx : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include <windows.h>
#include <rpc.h>                // rpc prototypes
#include <splcom.h>

PVOID
MIDL_user_allocate (
    IN unsigned long NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return MIDL_user_allocate1(NumBytes);
}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    MIDL_user_free1(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\files.c ===
/*++


Copyright (c) 1994 - 1996 Microsoft Corporation

Module Name:

    Files.c

Abstract:

    This module contains routines for copying files specified under the
    CopyFiles key of a print queue

Author:

    Muhunthan Sivapragasam (Muhunthan Sivapragasam)     Nov-27-96

Revision History:

--*/

#include <precomp.h>

WCHAR *szSpoolDirectory   = L"\\spool";

extern SPLCLIENT_INFO_1   gSplClientInfo1;

#define     PRINTER_ENUM_KEY_SIZE        400


BOOL
ProcessACopyFileKey(
    PWSPOOL             pSpool,
    LPWSTR              pszKey,
    LPWSTR              pszModule,
    LPWSTR              pszDir,
    LPWSTR              ppszFiles,
    LPWSTR              pszSourceDir,
    LPWSTR              pszTargetDir,
    PSPLCLIENT_INFO_1   pSplClientInfo1
    )
{
    BOOL        bRet = FALSE, bFilesUpdated;
    DWORD       dwLen, dwCount, dwTemp, dwSourceDirSize, dwTargetDirSize;
    LPWSTR      *ppszFileNames = NULL, pszBuf = NULL, p1, p2;
    HINSTANCE   hModule = NULL;
    DWORD       (*pfn)(LPWSTR       pszPrinterName,
                       LPCWSTR      pszDirectory,
                       LPBYTE       pSplClientInfo,
                       DWORD        dwLevel,
                       LPWSTR       pszSourceDir,
                       LPDWORD      pcchSourceDirSize,
                       LPWSTR       pszTargetDir,
                       LPDWORD      pcchTargetDirSize,
                       DWORD        dwFlags
                      );

    //
    // If a module is given we need to call into to "correct" the path
    // We will first try LoadLibrary on the module, if we can't find the module
    // we will look in the driver directory for it
    //
    if ( pszModule && *pszModule ) {

        if ( !(hModule = SplLoadLibraryTheCopyFileModule(pSpool, pszModule)) ||
             !((FARPROC)pfn = GetProcAddress(hModule, "GenerateCopyFilePaths")) )
        goto Cleanup;

        dwSourceDirSize = dwTargetDirSize = MAX_PATH;

#if DBG
#else
        try {
#endif

            //
            // On free builds we do not want spooler to crash
            //
            if ( ERROR_SUCCESS != pfn(pSpool->pName,
                                      pszDir,
                                      (LPVOID)pSplClientInfo1,
                                      1,
                                      pszSourceDir,
                                      &dwSourceDirSize,
                                      pszTargetDir,
                                      &dwTargetDirSize,
                                      COPYFILE_FLAG_CLIENT_SPOOLER) )
#if DBG
                goto Cleanup;
#else
                leave;
#endif

            bRet = TRUE;
#if DBG
#else
        } except(1) {
        }
#endif

        if ( !bRet )
            goto Cleanup;

    } else {

        bRet = TRUE;
    }

    dwSourceDirSize = wcslen(pszSourceDir);
    dwTargetDirSize = wcslen(pszTargetDir);

    pszSourceDir[dwSourceDirSize] = L'\\';

    pszSourceDir[++dwSourceDirSize] = L'\0';
    pszTargetDir[dwTargetDirSize]   = L'\0';


    //
    // First find out number of files and size of one long buffer to put
    // all filenames. We need to build fully qualified filenames in the source
    // directory
    //
    for ( dwCount = dwLen = 0, p1 = ppszFiles ; *p1 ; p1 += dwTemp, ++dwCount ) {

        dwTemp = wcslen(p1) + 1;
        dwLen += dwTemp + dwSourceDirSize;
    }

    pszBuf          = (LPWSTR) AllocSplMem(dwLen * sizeof(WCHAR));
    ppszFileNames   = (LPWSTR *) AllocSplMem(dwCount * sizeof(LPWSTR));

    if ( !pszBuf || !ppszFileNames )
        goto Cleanup;

    for ( p1 = ppszFiles, p2 = pszBuf, dwCount = dwTemp = 0 ;
         *p1 ; p1 += wcslen(p1) + 1, ++dwCount ) {

        wcscpy(p2, pszSourceDir);
        wcscpy(p2 + dwSourceDirSize, p1);

        ppszFileNames[dwCount]  = p2;

        dwTemp                 += dwSourceDirSize + wcslen(p1) + 1;
        p2                      = pszBuf + dwTemp;
    }

    SPLASSERT(dwTemp == dwLen);

    bRet = SplCopyNumberOfFiles(pSpool->pName,
                                ppszFileNames,
                                dwCount,
                                pszTargetDir,
                                &bFilesUpdated);

    if ( bFilesUpdated )
        (VOID) SplCopyFileEvent(pSpool->hSplPrinter,
                                pszKey,
                                COPYFILE_EVENT_FILES_CHANGED);
Cleanup:
    if ( hModule )
        FreeLibrary(hModule);

    FreeSplMem(pszBuf);
    FreeSplMem(ppszFileNames);

    return bRet;
}


BOOL
CopyFilesUnderAKey(
    PWSPOOL             pSpool,
    LPWSTR              pszSubKey,
    PSPLCLIENT_INFO_1   pSplClientInfo1
    )
{
    BOOL        bRet = FALSE;
    DWORD       dwSize, dwLen, dwType, dwNeeded;
    WCHAR       szSourceDir[MAX_PATH], szTargetDir[MAX_PATH];
    LPWSTR      pszDir, ppszFiles, pszModule;

    pszDir = ppszFiles = pszModule = NULL;

    dwSize = sizeof(szSourceDir);

    if ( SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"Directory",
                             &dwType,
                             (LPBYTE)szSourceDir,
                             dwSize,
                             &dwNeeded)                     ||
         dwType != REG_SZ                                   ||
         !(pszDir = AllocSplStr(szSourceDir))               ||
         SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"SourceDir",
                             &dwType,
                             (LPBYTE)szSourceDir,
                             dwSize,
                             &dwNeeded)                     ||
         dwType != REG_SZ                                   ||
         dwNeeded + sizeof(WCHAR) > dwSize                  ||
         SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"Files",
                             &dwType,
                             (LPBYTE)szTargetDir,       // Can't pass NULL
                             0,
                             &dwNeeded) != ERROR_MORE_DATA  ||
         !(ppszFiles = (LPWSTR) AllocSplMem(dwNeeded))      ||
         SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"Files",
                             &dwType,
                             (LPBYTE)ppszFiles,
                             dwNeeded,
                             &dwNeeded)                     ||
         dwType != REG_MULTI_SZ ) {

        goto Cleanup;
    }

    //
    // Module name is optional
    //
    dwLen = SplGetPrinterDataEx(pSpool->hSplPrinter,
                                pszSubKey,
                                L"Module",
                                &dwType,
                                (LPBYTE)szTargetDir,
                                dwSize,
                                &dwNeeded);

    if ( dwLen == ERROR_SUCCESS ) {

        if ( dwType != REG_SZ   ||
             !(pszModule = AllocSplStr(szTargetDir)) ) {

            goto Cleanup;
        }
    } else if ( dwLen != ERROR_FILE_NOT_FOUND ) {

        goto Cleanup;
    }

    dwLen = dwSize;
    //
    // Target directory we got from the server is relative to print$.
    // We need to convert it to a fully qualified path now
    //
    if ( !SplGetDriverDir(pSpool->hIniSpooler, szTargetDir, &dwLen) )
        goto Cleanup;

    szTargetDir[dwLen-1] = L'\\';

    dwSize -= dwLen * sizeof(WCHAR);
    if ( SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"TargetDir",
                             &dwType,
                             (LPBYTE)(szTargetDir + dwLen),
                             dwSize,
                             &dwNeeded)                     ||
         dwType != REG_SZ ) {

        goto Cleanup;
    }

    bRet = ProcessACopyFileKey(pSpool,
                               pszSubKey,
                               pszModule,
                               pszDir,
                               ppszFiles,
                               szSourceDir,
                               szTargetDir,
                               pSplClientInfo1);

Cleanup:
    FreeSplStr(pszDir);
    FreeSplStr(ppszFiles);
    FreeSplStr(pszModule);

    return bRet;
}


BOOL
RefreshPrinterCopyFiles(
    PWSPOOL     pSpool
    )
{
    DWORD                   dwNeeded, dwSize = 0, dwLastError;
    LPWSTR                  pszBuf = NULL, pszSubKey;
    WCHAR                   szUserName[MAX_PATH+1], szKey[MAX_PATH];
    SPLCLIENT_INFO_1        SplClientInfo;

    if ( pSpool->Type != SJ_WIN32HANDLE )
        return TRUE;

    SYNCRPCHANDLE(pSpool);

    SPLASSERT(pSpool->Status & WSPOOL_STATUS_USE_CACHE);

    //
    // If it is a 3x server it is not going to support the rpc calls we need
    // so there is nothing to copy
    //
    if ( pSpool->bNt3xServer )
        return TRUE;

Retry:

    dwLastError = SplEnumPrinterKey(pSpool->hSplPrinter,
                                    L"CopyFiles",
                                    pszBuf,
                                    dwSize,
                                    &dwNeeded);

    //
    // If first time size was not enough we will try once more with dwNeeded
    //
    if ( dwLastError == ERROR_MORE_DATA &&
         dwSize == 0                    &&
         dwNeeded != 0 ) {

        dwSize  = dwNeeded;
        pszBuf  = AllocSplMem(dwSize);

        if ( !pszBuf )
            goto Cleanup;

        goto Retry;
    }

    //
    // If the call failed, or there was no sub key we are done
    //
    if ( dwLastError != ERROR_SUCCESS )
        goto Cleanup;

    CopyMemory((LPBYTE)&SplClientInfo,
               (LPBYTE)&gSplClientInfo1,
               sizeof(SplClientInfo));

    SplClientInfo.pMachineName = SplClientInfo.pUserName = NULL;

    for ( pszSubKey = pszBuf ; *pszSubKey ; pszSubKey += wcslen(pszSubKey) + 1 ) {

        if ( sizeof(szKey)/sizeof(szKey[0])
                > wcslen(L"CopyFiles") + wcslen(pszSubKey) ) {

            wsprintf(szKey, L"%ws\\%ws", L"CopyFiles", pszSubKey);
            CopyFilesUnderAKey(pSpool, szKey, &SplClientInfo);
        } else {

            SPLASSERT(sizeof(szKey)/sizeof(szKey[0]) >
                        wcslen(L"CopyFiles") + wcslen(pszSubKey));
        }
    }

Cleanup:
    FreeSplMem(pszBuf);

    return dwLastError == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles implementation for WaitForPrinterChange and related apis.

    FindFirstPrinterChangeNotification
    FindClosePrinterChangeNotification

    RefreshPrinterChangeNotification

Author:

    Albert Ting (AlbertT) 24-Apr-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop



BOOL
RemoteFindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID pvReserved0,
   PVOID pvReserved1);

BOOL
RemoteFindClosePrinterChangeNotification(
   HANDLE hPrinter);

BOOL
RemoteFindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID pvReserved0,
   PVOID pvReserved1)
{
    BOOL bReturnValue = TRUE;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SPLASSERT( !*pfdwStatus );

    if( pSpool->Status & WSPOOL_STATUS_NOTIFY ){
        DBGMSG( DBG_WARNING, ( "RemoteFFPCN: Already waiting.\n" ));
        SetLastError( ERROR_ALREADY_WAITING );
        return FALSE;
    }

    if( pSpool->Type == SJ_WIN32HANDLE ){

        DWORD dwStatus;

        SYNCRPCHANDLE( pSpool );

        dwStatus = CallRouterFindFirstPrinterChangeNotification(
                       pSpool->RpcHandle,
                       fdwFlags,
                       fdwOptions,
                       hNotify,
                       pvReserved0);

        switch( dwStatus ){
        case RPC_S_SERVER_UNAVAILABLE:

            //
            // Drop into polling mode.  This can happen if the
            // server service on the client is disabled.
            //
            *pfdwStatus = PRINTER_NOTIFY_STATUS_ENDPOINT |
                          PRINTER_NOTIFY_STATUS_POLL;

            pSpool->Status |= WSPOOL_STATUS_NOTIFY_POLL;

            DBGMSG( DBG_WARNING, ( "RemoteFFPCN: Dropping into poll mode.\n" ));
            break;

        case ERROR_SUCCESS:

            //
            // Using regular notification system; not polling.
            //
            pSpool->Status &= ~WSPOOL_STATUS_NOTIFY_POLL;
            break;

        default:

            SetLastError(dwStatus);
            bReturnValue = FALSE;
            break;
        }

    } else {

        bReturnValue = LMFindFirstPrinterChangeNotification(
                           hPrinter,
                           fdwFlags,
                           fdwOptions,
                           hNotify,
                           pfdwStatus);
    }

    if( bReturnValue ){
        pSpool->Status |= WSPOOL_STATUS_NOTIFY;
    }

    return bReturnValue;
}


BOOL
RemoteFindClosePrinterChangeNotification(
   HANDLE hPrinter)
{
    DWORD  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    pSpool->Status &= ~WSPOOL_STATUS_NOTIFY;

    if( pSpool->Status & WSPOOL_STATUS_NOTIFY_POLL ){

        //
        // In the polling case, there's no cleanup.
        //
        return TRUE;
    }

    if (pSpool->Type == SJ_WIN32HANDLE) {

        SYNCRPCHANDLE( pSpool );

        RpcTryExcept {

            if (ReturnValue = RpcFindClosePrinterChangeNotification(
                                  pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        EnterSplSem();
        ReturnValue = LMFindClosePrinterChangeNotification(hPrinter);
        LeaveSplSem();
    }

    return ReturnValue;
}

BOOL
RemoteRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyOptions,
    PVOID* ppPrinterNotifyInfo)
{
    DWORD  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (ppPrinterNotifyInfo)
        *ppPrinterNotifyInfo = NULL;

    if (pSpool->Type != SJ_WIN32HANDLE) {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    SYNCRPCHANDLE( pSpool );

    RpcTryExcept {

        if (ReturnValue = RpcRouterRefreshPrinterChangeNotification(
                              pSpool->RpcHandle,
                              dwColor,
                              pPrinterNotifyOptions,
                              (PRPC_V2_NOTIFY_INFO*)ppPrinterNotifyInfo)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\lmjob.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    local.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.

--*/

#include <windows.h>
#include <winspool.h>
#include <lm.h>

#include <w32types.h>
#include <local.h>
#include <offsets.h>

#include <string.h>
#include <splcom.h>



BOOL
LMSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    DWORD   uRetCode;
    LPWSTR  pszDocument;
    LPWSTR  pszDatatype;

    VALIDATEW32HANDLE( pSpool );

    switch (Command) {

    case 0:
        break;

    case JOB_CONTROL_PAUSE:
        if (uRetCode = RxPrintJobPause(pSpool->pServer, JobId)) {
            SetLastError(uRetCode);
            return(FALSE);
        }
        break;

    case JOB_CONTROL_RESUME:
        if (uRetCode = RxPrintJobContinue(pSpool->pServer, JobId)) {
            SetLastError(uRetCode);
            return(FALSE);
        }
        break;

    case JOB_CONTROL_CANCEL:
    case JOB_CONTROL_DELETE:
        if (uRetCode = RxPrintJobDel(pSpool->pServer, JobId)) {
            SetLastError(uRetCode);
            return(FALSE);
        }
        break;

    case JOB_CONTROL_RESTART:
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // We only support setting of the document name on SetJob to OS/2.

    switch (Level) {

    case 0:
        break;
    case 1:
    case 2:
        switch (Level) {

        case 1:
            pszDatatype = ((JOB_INFO_1 *)pJob)->pDatatype;
            pszDocument = ((JOB_INFO_1 *)pJob)->pDocument;
            break;
        case 2:
            pszDatatype = ((JOB_INFO_2 *)pJob)->pDatatype;
            pszDocument = ((JOB_INFO_2 *)pJob)->pDocument;
            break;
        }

        //
        // If the datatype is non-NULL and anything other than
        // a RAW datatype, then fail.
        //
        if( pszDatatype && !ValidRawDatatype( pszDatatype )){
            SetLastError( ERROR_INVALID_DATATYPE );
            return FALSE;
        }

        //
        // Special handling for pszDocument == NULL
        // if pszDocument == NULL, set it to a pointer to ""
        //
        if (pszDocument == NULL)
            pszDocument = L"";
        else
        {
            if(wcslen(pszDocument) > (MAX_PATH-1))
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                return (FALSE);
            }
        }


        if (uRetCode = RxPrintJobSetInfo(pSpool->pServer,
                                         JobId,
                                         3,
                                         (PBYTE)pszDocument,
                                         wcslen(pszDocument)*sizeof(WCHAR) +
                                            sizeof(WCHAR),
                                         PRJ_COMMENT_PARMNUM)) {
            SetLastError(uRetCode);
            return FALSE;
        }
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // We successfully performed a 'LMSetJob' - pulse the ChangeEvent
    // or send the notification.
    //

    LMSetSpoolChange(pSpool);

    return TRUE;
}

#define Nullstrlen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

DWORD
GetPrjInfoSize(
    PWSPOOL  pSpool,
    DWORD   Level,
    PRJINFO *pPrjInfo
)
{
    DWORD   cb;

    switch (Level) {

    case 1:
        cb = sizeof(JOB_INFO_1) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrjInfo->szUserName) +
             Nullstrlen(pPrjInfo->pszComment) +
             Nullstrlen(pPrjInfo->pszStatus);
        break;

    case 2:
        cb = sizeof(JOB_INFO_2) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrjInfo->szUserName) +
             Nullstrlen(pPrjInfo->pszComment) +
             Nullstrlen(pPrjInfo->szNotifyName) +
             Nullstrlen(pPrjInfo->szDataType) +
             Nullstrlen(pPrjInfo->pszParms) +
             Nullstrlen(pPrjInfo->pszStatus);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}

BOOL
ConvertDosTimeToSystemTime(
    ULONG Time,
    PSYSTEMTIME pst
    )
{
    LARGE_INTEGER li;
    FILETIME ft;

    li.QuadPart = Time;

    li.QuadPart += 11644473600;
    li.QuadPart *= 10000000;

    ft.dwLowDateTime = li.LowPart;
    ft.dwHighDateTime = li.HighPart;

    return FileTimeToSystemTime( &ft, pst );
}


LPBYTE
CopyPrjInfoToJob(
    PWSPOOL  pSpool,
    PRJINFO *pPrjInfo,
    DWORD   Level,
    LPBYTE  pJobInfo,
    LPBYTE  pEnd
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    LPJOB_INFO_2 pJob  = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_2 pJob2 = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_1 pJob1 = (PJOB_INFO_1)pJobInfo;
    DWORD   i, Status;
    DWORD   *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        break;

    default:
        return pEnd;
    }

    switch (pPrjInfo->fsStatus) {

    case PRJ_QS_PAUSED:
        Status = JOB_STATUS_PAUSED;
        break;

    case PRJ_QS_SPOOLING:
        Status = JOB_STATUS_SPOOLING;
        break;

    case PRJ_QS_PRINTING:
        Status = JOB_STATUS_PRINTING;
        break;

    default:
        Status = 0;
        break;
    }

    for (i=0; pOffsets[i] != -1; i++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(i * sizeof(LPWSTR));

    if (!SourceStrings)
        return NULL;

    switch (Level) {

    case 1:
        *pSourceStrings++=pSpool->pShare;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrjInfo->szUserName;
        *pSourceStrings++=pPrjInfo->pszComment;
        *pSourceStrings++=NULL;
        if (pPrjInfo->pszStatus && *pPrjInfo->pszStatus)
            *pSourceStrings++=pPrjInfo->pszStatus;
        else
            *pSourceStrings++=NULL;

        /* PRJINFO doesn't contain uPriority.
         * PRJINFO2 does, but doesn't contain some of the things
         * that PRJINFO has.
         * We'd need to pass a PRJINFO3 structure to get everything we need,
         * but DosPrintJobEnum doesn't support level 3.
         * (see comment in \nt\private\net\rpcxlate\rxapi\prtjob.c.)
         * For now, set it to 0.  Print Manager will display nothing for this.
         */
        pJob1->Priority=0;
        pJob1->Position=pPrjInfo->uPosition;
        pJob1->Status=Status;
        pJob1->JobId = pPrjInfo->uJobId;
        break;

    case 2:
        *pSourceStrings++=pSpool->pShare;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrjInfo->szUserName;
        *pSourceStrings++=pPrjInfo->pszComment;
        *pSourceStrings++=pPrjInfo->szNotifyName;
        *pSourceStrings++=pPrjInfo->szDataType;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrjInfo->pszParms;
        *pSourceStrings++=NULL;
        if (pPrjInfo->pszStatus && *pPrjInfo->pszStatus)
            *pSourceStrings++=pPrjInfo->pszStatus;
        else
            *pSourceStrings++=NULL;

        pJob2->pDevMode=0;
        pJob2->Priority=0;
        pJob2->Position=pPrjInfo->uPosition;
        pJob2->StartTime=0;
        pJob2->UntilTime=0;
        pJob2->TotalPages=0;
        pJob2->Size=pPrjInfo->ulSize;
        ConvertDosTimeToSystemTime(pPrjInfo->ulSubmitted, &pJob2->Submitted);
        memset((LPBYTE)&pJob2->Time, 0, sizeof(pJob2->Time));
        pJob2->Status=Status;
        pJob2->JobId = pPrjInfo->uJobId;
        break;

    default:
        return pEnd;
    }

    pEnd = PackStrings(SourceStrings, pJobInfo, pOffsets, pEnd);

    FreeSplMem(SourceStrings);

    return pEnd;
}

BOOL
LMGetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PWSPOOL      pSpool = (PWSPOOL)hPrinter;
    PPRJINFO    pPrjInfo;
    PPRQINFO    pPrqInfo;
    DWORD       cbBuffer;
    DWORD       rc;
    DWORD       cbNeeded;
    DWORD       cb;
    DWORD       cJobs;

    VALIDATEW32HANDLE( pSpool );

    //
    // Fail if out of range.
    //
    if (JobId > (WORD)-1) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cbBuffer = 100;

    if (!(pPrjInfo = AllocSplMem(cbBuffer)))
        return FALSE;

    rc = RxPrintJobGetInfo(pSpool->pServer,
                           (WORD)JobId,
                           1,
                           (PBYTE)pPrjInfo,
                           cbBuffer,
                           &cbNeeded);

    if (rc == ERROR_MORE_DATA || rc == NERR_BufTooSmall) {

        if (!(pPrjInfo=ReallocSplMem(pPrjInfo, 0, cbNeeded)))
            return FALSE;

        cbBuffer=cbNeeded;

        if (rc = RxPrintJobGetInfo(pSpool->pServer,
                                   (WORD)JobId,
                                   1,
                                   (PBYTE)pPrjInfo,
                                   cbBuffer,
                                   &cbNeeded)) {

            FreeSplMem(pPrjInfo);
            SetLastError(rc);
            return FALSE;
        }

    } else {

        //
        // Free the buffer.
        //
        FreeSplMem(pPrjInfo);

        if (rc == ERROR_NOT_SUPPORTED) {

            cbBuffer = 64*1024;

            if (!(pPrqInfo = AllocSplMem(cbBuffer)))
                return FALSE;

            if (!(rc = RxPrintQGetInfo(pSpool->pServer,
                                       pSpool->pShare,
                                       2,
                                       (PBYTE)pPrqInfo,
                                       cbBuffer,
                                       &cbNeeded))) {

                rc = ERROR_INVALID_PARAMETER;

                cJobs = (DWORD)pPrqInfo->cJobs;

                for (pPrjInfo = (PRJINFO *)(pPrqInfo+1);
                    cJobs;
                    cJobs--, pPrjInfo++) {

                    if (JobId == (DWORD)pPrjInfo->uJobId) {

                        cb = GetPrjInfoSize(pSpool, Level, pPrjInfo);

                        if (cb <= cbBuf) {

                            CopyPrjInfoToJob(pSpool,
                                             pPrjInfo,
                                             Level,
                                             pJob,
                                             pJob + cbBuf);

                            rc = ERROR_SUCCESS;

                        } else {

                            *pcbNeeded=cb;
                            rc = ERROR_INSUFFICIENT_BUFFER;
                        }
                    }
                }
            }

            FreeSplMem(pPrqInfo);
        }

        if (rc) {
            SetLastError(rc);
            return FALSE;
        }
        return TRUE;
    }

    cb=GetPrjInfoSize(pSpool, Level, pPrjInfo);

    *pcbNeeded=cb;

    if (cb > cbBuf) {
        FreeSplMem(pPrjInfo);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    if (CopyPrjInfoToJob(pSpool, pPrjInfo, Level, pJob, (LPBYTE)pJob+cbBuf)) {
        FreeSplMem(pPrjInfo);
        return TRUE;
    } else {
        FreeSplMem(pPrjInfo);
        return FALSE;
    }
}

/* Get all the Job Ids first, then get individual info on each */

BOOL
LMEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PPRJINFO    pPrjInfo;
    PPRQINFO    pPrqInfo;
    DWORD       rc=0;
    DWORD       cb=0;
    DWORD       cJobs;
    DWORD       cbNeeded;
    LPBYTE      pEnd;
    PWSPOOL      pSpool = (PWSPOOL)hPrinter;
    DWORD       cbBuffer = 100;

    VALIDATEW32HANDLE( pSpool );

    cbBuffer = 64*1024;

    pEnd = pJob + cbBuf;

    if (!(pPrqInfo = AllocSplMem(cbBuffer)))
        return FALSE;

    *pcReturned=0;

    if (!(rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 2,
                               (PBYTE)pPrqInfo, cbBuffer, &cbNeeded))) {

        pPrjInfo = (PRJINFO *)(pPrqInfo+1);

        if (FirstJob > pPrqInfo->cJobs) {

            FreeSplMem(pPrqInfo);
            return TRUE;

        }

        cJobs = (DWORD)min(NoJobs, pPrqInfo->cJobs - FirstJob);

        for (pPrjInfo=pPrjInfo+FirstJob; cJobs; cJobs--, pPrjInfo++) {

            cb+=GetPrjInfoSize(pSpool, Level, pPrjInfo);

            if (cb <= cbBuf) {

                pEnd = CopyPrjInfoToJob(pSpool, pPrjInfo, Level, pJob, pEnd);

                (*pcReturned)++;
                switch (Level) {
                case 1:
                    pJob+=sizeof(JOB_INFO_1);
                    break;
                case 2:
                    pJob+=sizeof(JOB_INFO_2);
                    break;
                }

            } else

                rc=ERROR_INSUFFICIENT_BUFFER;
        }
    }

    FreeSplMem(pPrqInfo);

    *pcbNeeded=cb;

    if (rc) {
        SetLastError(rc);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\lmspl.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    local.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo net print vs. UNICODE.
    July 1994   MattFe Caching

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddrdr.h>
#include <windows.h>
#include <winspool.h>
#include <lm.h>
#include <w32types.h>
#include <local.h>
#include <winsplp.h>
#include <splcom.h>                     // DBGMSG
#include <winerror.h>

#include <string.h>

#define NOTIFY_TIMEOUT 10000

DWORD
LMStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    PWSPOOL      pSpool=(PWSPOOL)hPrinter;
    WCHAR       szFileName[MAX_PATH];
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    QUERY_PRINT_JOB_INFO JobInfo;
    IO_STATUS_BLOCK Iosb;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pSpool->Status |= WSPOOL_STATUS_STARTDOC;

    if(StrNCatBuff(szFileName,
                   COUNTOF(szFileName),
                   pSpool->pServer,
                   L"\\",
                   pSpool->pShare,
                   NULL) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    pSpool->hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL |
                               FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (pSpool->hFile == INVALID_HANDLE_VALUE) {


        EnterSplSem();
        DeleteEntryfromLMCache(pSpool->pServer, pSpool->pShare);
        LeaveSplSem();

        DBGMSG( DBG_WARNING, ("Failed to open %ws\n", szFileName));
        pSpool->Status &= ~WSPOOL_STATUS_STARTDOC;
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;

    }

    if (pDocInfo1 && pDocInfo1->pDocName && (wcslen(pDocInfo1->pDocName) < MAX_PATH)) {

        if (NtFsControlFile(pSpool->hFile,
                            NULL,
                            NULL,
                            NULL,
                            &Iosb,
                            FSCTL_GET_PRINT_ID,
                            NULL, 0,
                            &JobInfo, sizeof(JobInfo)) == ERROR_SUCCESS){

            RxPrintJobSetInfo(pSpool->pServer,
                              JobInfo.JobId,
                              3,
                              (LPBYTE)pDocInfo1->pDocName,
                              wcslen(pDocInfo1->pDocName)*sizeof(WCHAR) + sizeof(WCHAR),
                              PRJ_COMMENT_PARMNUM);
        }
        else
        {
            DBGMSG( DBG_WARN, ("NtFsControlFile failed %ws\n", szFileName));
        }
    }

    return TRUE;
}

BOOL
LMStartPagePrinter(
    HANDLE  hPrinter
)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

BOOL
LMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    PWSPOOL  pSpool=(PWSPOOL)hPrinter;
    DWORD   cWritten, cTotal;
    DWORD   rc;
    LPBYTE  pByte=pBuf;

    VALIDATEW32HANDLE( pSpool );

    if (!(pSpool->Status & WSPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pSpool->hFile == INVALID_HANDLE_VALUE) {
        *pcWritten = 0;
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    cWritten = cTotal = 0;

    while (cbBuf) {

        rc = WriteFile(pSpool->hFile, pByte, cbBuf, &cWritten, NULL);

        if (!rc) {

            rc = GetLastError();

            DBGMSG(DBG_WARNING, ("Win32 Spooler: Error writing to server, Error %d\n", rc));
            cTotal+=cWritten;
            *pcWritten=cTotal;
            return FALSE;

        } else if (!cWritten) {
            DBGMSG(DBG_ERROR, ("Spooler: Amount written is zero !!!\n"));
        }

        cTotal+=cWritten;
        cbBuf-=cWritten;
        pByte+=cWritten;
    }

    *pcWritten = cTotal;
    return TRUE;
}

BOOL
LMEndPagePrinter(
    HANDLE  hPrinter
)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

BOOL
LMAbortPrinter(
   HANDLE hPrinter
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

// Abort Printer remoteley won't work until we maintain state information
// on a per handle basis. For PDK, this is good enough

#ifdef LATER
   WORD parm = 0;
   PRIDINFO   PridInfo;

   DosDevIOCtl(&PridInfo, (LPSTR)&parm, SPOOL_LMGetPrintId, SPOOL_LMCAT,
                                        hSpooler);

   RxPrintJobDel(NULL, PridInfo.uJobId);
#endif

   return TRUE;
}

BOOL
LMReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPDWORD  pNoBytesRead
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return 0;

    UNREFERENCED_PARAMETER(pBuf);
    UNREFERENCED_PARAMETER(pNoBytesRead);
}

BOOL
LMEndDocPrinter(
   HANDLE hPrinter
)
{
    PWSPOOL  pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (!(pSpool->Status & WSPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pSpool->Status &= ~WSPOOL_STATUS_STARTDOC;

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {

        CloseHandle(pSpool->hFile);
        pSpool->hFile = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

BOOL
LMAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL      pSpool=(PWSPOOL)hPrinter;
    DWORD       cb;
    WCHAR       szFileName[MAX_PATH];
    LPBYTE      pEnd;
    LPADDJOB_INFO_1 pAddJob=(LPADDJOB_INFO_1)pData;

    VALIDATEW32HANDLE( pSpool );
    if(StrNCatBuff(szFileName,
                   COUNTOF(szFileName),
                   pSpool->pServer,
                   L"\\",
                   pSpool->pShare,
                   NULL) != ERROR_SUCCESS)
    {
        return(FALSE);
    }


    cb = wcslen(szFileName)*sizeof(WCHAR) + sizeof(WCHAR) + sizeof(ADDJOB_INFO_1);

    if (cb > cbBuf) {
        *pcbNeeded=cb;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    pEnd = (LPBYTE)pAddJob+cbBuf;
    pEnd -= wcslen(szFileName)*sizeof(WCHAR)+sizeof(WCHAR);
    pAddJob->Path = wcscpy((LPWSTR)pEnd, szFileName);
    pAddJob->JobId = (DWORD)-1;

    return TRUE;
}

BOOL
LMScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
)
{
    PWSPOOL      pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    JobId = JobId;

    return TRUE;
}

DWORD
LMGetPrinterData(
    HANDLE   hPrinter,
    LPTSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

DWORD
LMSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

BOOL
LMClosePrinter(
   HANDLE hPrinter
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;
    BOOL bReturnValue = FALSE;

    VALIDATEW32HANDLE( pSpool );

   EnterSplSem();

    if (pSpool->Status & WSPOOL_STATUS_STARTDOC)
        EndDocPrinter(hPrinter);

    if (pLMNotify->ChangeEvent) {

        if (pLMNotify->ChangeEvent != INVALID_HANDLE_VALUE) {

            CloseHandle(pLMNotify->ChangeEvent);

        } else {

            LMFindClosePrinterChangeNotification(hPrinter);
        }
    }

    FreepSpool( pSpool );
    bReturnValue = TRUE;

   LeaveSplSem();

    return bReturnValue;
}

DWORD
LMWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;
    HANDLE  ChangeEvent;
    DWORD bReturnValue = FALSE;

   EnterSplSem();
    //
    // !! LATER !!
    //
    // We have no synchronization code in win32spl.  This opens us
    // up to AVs if same handle is used (ResetPrinter validates;
    // Close closes; ResetPrinter tries to use handle boom.)
    // Here's one more case:
    //
    if (pLMNotify->ChangeEvent) {

        SetLastError(ERROR_ALREADY_WAITING);
        goto Error;
    }

    // Allocate memory for ChangeEvent for LanMan Printers
    // This event is pulsed by LMSetJob and any othe LM
    // function that modifies the printer/job status
    // LMWaitForPrinterChange waits on this event
    // being pulsed.

    ChangeEvent = CreateEvent(NULL,
                              FALSE,
                              FALSE,
                              NULL);

    if (!ChangeEvent) {
        DBGMSG(DBG_WARNING, ("CreateEvent( ChangeEvent ) failed: Error %d\n",
                            GetLastError()));

        goto Error;
    }

    pLMNotify->ChangeEvent = ChangeEvent;

   LeaveSplSem();

    WaitForSingleObject(pLMNotify->ChangeEvent, NOTIFY_TIMEOUT);

    CloseHandle(ChangeEvent);

    //
    //  !! LATER !!
    //
    // We shouldn't return that everything changed; we should
    // return what did.
    //
    return Flags;

Error:
   LeaveSplSem();
    return 0;
}


BOOL
LMFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;

   EnterSplSem();

    pLMNotify->hNotify = hNotify;
    pLMNotify->fdwChangeFlags = fdwFlags;
    pLMNotify->ChangeEvent = INVALID_HANDLE_VALUE;

    *pfdwStatus = PRINTER_NOTIFY_STATUS_ENDPOINT | PRINTER_NOTIFY_STATUS_POLL;

   LeaveSplSem();

    return TRUE;
}

BOOL
LMFindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;

    SplInSem();

    if (pLMNotify->ChangeEvent != INVALID_HANDLE_VALUE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pLMNotify->hNotify = NULL;
    pLMNotify->ChangeEvent = NULL;

    return TRUE;
}

VOID
LMSetSpoolChange(
    PWSPOOL pSpool)
{
    PLMNOTIFY pLMNotify;

    pLMNotify = &pSpool->LMNotify;

    EnterSplSem();
    if (pLMNotify->ChangeEvent) {

        if (pLMNotify->ChangeEvent == INVALID_HANDLE_VALUE) {

            //
            // FindFirstPrinterChangeNotification used.
            //
            ReplyPrinterChangeNotification(pLMNotify->hNotify,
                                           pLMNotify->fdwChangeFlags,
                                           NULL,
                                           NULL);
        } else {

            SetEvent(pLMNotify->ChangeEvent);
        }
    }
    LeaveSplSem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\lmprn.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    local.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo net print vs. UNICODE.
    July 1994   MattFe Caching

--*/
#include <winerror.h>
#include <windows.h>
#include <winspool.h>
#include <lm.h>
#include <w32types.h>
#include <local.h>
#include <splcom.h>             // DBGMSG

#include <wininet.h>
#include <offsets.h>


#include <string.h>


char szPMRaw[]="PM_Q_RAW";

WCHAR *szAdmin  =   L"ADMIN$";

extern HANDLE  hNetApi;
extern NET_API_STATUS (*pfnNetServerGetInfo)();
extern NET_API_STATUS (*pfnNetApiBufferFree)();

HMODULE hSpoolssDll = NULL;
FARPROC pfnSpoolssEnumPorts = NULL;

DWORD
GetPortSize(
    PWINIPORT pIniPort,
    DWORD   Level
)
{
    DWORD   cb;
    WCHAR   szMonitor[MAX_PATH+1], szPort[MAX_PATH+1];

    switch (Level) {

    case 1:

        cb=sizeof(PORT_INFO_1) +
           wcslen(pIniPort->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    case 2:
        LoadString(hInst, IDS_MONITOR_NAME, szMonitor, sizeof(szMonitor)/sizeof(szMonitor[0])-1);
        LoadString(hInst, IDS_PORT_NAME, szPort, sizeof(szPort)/sizeof(szPort[0])-1);
        cb = wcslen(pIniPort->pName) + 1 +
             wcslen(szMonitor) + 1 +
             wcslen(szPort) + 1;
        cb *= sizeof(WCHAR);
        cb += sizeof(PORT_INFO_2);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}


LPBYTE
CopyIniPortToPort(
    PWINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
)
{
    LPWSTR         *SourceStrings, *pSourceStrings;
    DWORD          *pOffsets;
    WCHAR           szMonitor[MAX_PATH+1], szPort[MAX_PATH+1];
    DWORD           Count;
    LPPORT_INFO_2   pPort2 = (LPPORT_INFO_2) pPortInfo;

    switch (Level) {

    case 1:
        pOffsets = PortInfo1Strings;
        break;

    case 2:
        pOffsets = PortInfo2Strings;
        break;

    default:
        DBGMSG(DBG_ERROR, ("CopyIniPortToPort: invalid level %d", Level));
        return pEnd;
    }

    for ( Count = 0 ; pOffsets[Count] != -1 ; ++Count ) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(Count * sizeof(LPWSTR));

    if ( !SourceStrings ) {
        DBGMSG(DBG_WARNING,
               ("CopyIniPortToPort: Failed to alloc port source strings.\n"));
        return NULL;
    }

    switch (Level) {

    case 1:

        *pSourceStrings++=pIniPort->pName;
        break;

    case 2:
        *pSourceStrings++=pIniPort->pName;
        LoadString(hInst, IDS_MONITOR_NAME, szMonitor, sizeof(szMonitor)/sizeof(szMonitor[0])-1);
        LoadString(hInst, IDS_PORT_NAME, szPort, sizeof(szPort)/sizeof(szPort[0])-1);
        *pSourceStrings++   = szMonitor;
        *pSourceStrings++   = szPort;
        pPort2->fPortType   = PORT_TYPE_WRITE;
        pPort2->Reserved    = 0;
        break;

    default:
        return pEnd;
        DBGMSG(DBG_ERROR,
               ("CopyIniPortToPort: invalid level %d", Level));
    }

    pEnd = PackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
    FreeSplMem(SourceStrings);
    return pEnd;
}


/* PortExists
 *
 * Calls EnumPorts to check whether the port name already exists.
 * This asks every monitor, rather than just this one.
 * The function will return TRUE if the specified port is in the list.
 * If an error occurs, the return is FALSE and the variable pointed
 * to by pError contains the return from GetLastError().
 * The caller must therefore always check that *pError == NO_ERROR.
 */
BOOL
PortExists(
    LPWSTR pName,
    LPWSTR pPortName,
    PDWORD pError
)
{
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD cbPorts;
    LPPORT_INFO_1 pPorts;
    DWORD i;
    BOOL  Found = TRUE;

    *pError = NO_ERROR;

    if (!hSpoolssDll) {

        hSpoolssDll = LoadLibrary(L"SPOOLSS.DLL");

        if (hSpoolssDll) {
            pfnSpoolssEnumPorts = GetProcAddress(hSpoolssDll,
                                                 "EnumPortsW");
            if (!pfnSpoolssEnumPorts) {

                *pError = GetLastError();
                FreeLibrary(hSpoolssDll);
                hSpoolssDll = NULL;
            }

        } else {

            *pError = GetLastError();
        }
    }

    if (!pfnSpoolssEnumPorts)
        return FALSE;


    if (!(*pfnSpoolssEnumPorts)(pName, 1, NULL, 0, &cbNeeded, &cReturned))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            cbPorts = cbNeeded;

            pPorts = AllocSplMem(cbPorts);

            if (pPorts)
            {
                if ((*pfnSpoolssEnumPorts)(pName, 1, (LPBYTE)pPorts, cbPorts,
                                           &cbNeeded, &cReturned))
                {
                    Found = FALSE;

                    for (i = 0; i < cReturned; i++)
                    {
                        if (!lstrcmpi(pPorts[i].pName, pPortName))
                            Found = TRUE;
                    }
                }
            }

            FreeSplMem(pPorts);
        }
    }

    else
        Found = FALSE;


    return Found;
}



BOOL
LMOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
)
{
    PWINIPORT pIniPort;
    PWSPOOL  pSpool;
    DWORD   cb;
    PUSE_INFO_0 pUseInfo;
    LPWSTR  pShare;
    WCHAR   PrinterName[MAX_UNC_PRINTER_NAME];
    DWORD   cbNeeded;
    DWORD   rc;
    BYTE    Buffer[4];
    DWORD   Error = NO_ERROR;
    DWORD   dwEntry = 0xffffffff;
    PSERVER_INFO_101 pserver_info_101 = NULL;


    /* If we already have an INI port entry by this name, don't worry
     * about hitting the network.  This ensures that we don't try to
     * make a network call when we're not impersonating - like on
     * bootup.
     */
    if (!(pIniPort = FindPort(pPrinterName, pIniFirstPort))) {

        if (!NetUseGetInfo(NULL, pPrinterName, 0, (LPBYTE *)&pUseInfo))
            pPrinterName = AllocSplStr(pUseInfo->ui0_remote);

        NetApiBufferFree( (LPVOID) pUseInfo );
    }

    if ( !pPrinterName ||
         *pPrinterName != L'\\' ||
         *(pPrinterName+1) != L'\\' ||
         wcslen(pPrinterName) + 1 > MAX_UNC_PRINTER_NAME ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    wcscpy(PrinterName, pPrinterName);
    pShare=wcschr(PrinterName+2, L'\\');

    if ( !pShare ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    *pShare++=0;


    if (!pIniPort) {

        /* Verify that this guy actually exists.
         * Call it with a zero-length buffer,
         * and see if the error is that the buffer isn't big enough.
         * If we make Buffer = NULL, it fails with
         * ERROR_INVALID_PARAMETER, which is pretty abysmal,
         * so we must pass a Buffer address.
         * (Actually, it seems to accept any non-NULL value,
         * regardless of whether it's a valid address.)
         */

        EnterSplSem();
        dwEntry = FindEntryinLMCache(PrinterName, pShare);
        LeaveSplSem();

        if (dwEntry == -1) {

            DBGMSG(DBG_TRACE, ("We haven't cached this entry so  we have to hit the net\n"));

            rc = RxPrintQGetInfo(PrinterName,   /* e.g. \\msprint07                 */
                                 pShare,        /* e.g. l07corpa                    */
                                 0,             /* Level 0                          */
                                 Buffer,        /* Dummy - won't get filled in      */
                                 0,             /* Length of buffer                 */
                                 &cbNeeded);    /* How much we need - we'll ignore  */

            DBGMSG(DBG_INFO, ("LMOpenPrinter!RxPrintQGetInfo returned %d\n", rc));

            if (rc == ERROR_ACCESS_DENIED) {

                /* The print share exists; we just don't have access to it.
                 */
                SetLastError(ERROR_ACCESS_DENIED);
                return FALSE;
            }

            if (!((rc == ERROR_MORE_DATA)
                ||(rc == NERR_BufTooSmall)
                ||(rc == ERROR_INSUFFICIENT_BUFFER))) {
                SetLastError(ERROR_INVALID_NAME);
                return FALSE;
            }

            //
            // Be sure that we are connecting to a downlevel server.
            // If the server is Windows NT Machine, then fail the call:
            // downlevel NT connections won't work properly because
            // "\\Server\Printer Name" will get past RxPrintQGetInfo, but
            // we can't do CreateFile on it (we need to user the share
            // name).  Downlevel connects also lose admin functionality.
            //
            if (pfnNetServerGetInfo) {

                rc = pfnNetServerGetInfo(PrinterName, 101, &pserver_info_101);

                //
                // Advanced Server for Unix (ASU) by AT&T reports that
                // they are TYPE_NT even though they don't support the
                // rpc interface.  They also set TYPE_XENIX_SERVER.
                // Since the need lm connections, allow them when
                // TYPE_XENIX_SERVER is specified.
                //
                // Also make this change for SERVER_VMS and SERVER_OSF.
                // These changes are for AT&T also.
                //
                // Note: this will also allow accidental downlevel
                // connections to any servers that set TYPE_XENIX_SERVER,
                // TYPE_SERVER_VMS, or TYPE_SERVER_OSF.
                //

                if (!rc &&
                    (pserver_info_101->sv101_type & SV_TYPE_NT) &&
                    !(pserver_info_101->sv101_type &
                          ( SV_TYPE_XENIX_SERVER |
                            SV_TYPE_SERVER_VMS   |
                            SV_TYPE_SERVER_OSF))) {

                    DBGMSG(DBG_WARNING, ("NetServerGetInfo indicates %ws is a WinNT\n", PrinterName));
                    pfnNetApiBufferFree((LPVOID)pserver_info_101);

                    SetLastError(ERROR_INVALID_NAME);
                    return FALSE;
                }

                //
                // Now free the buffer
                //
                if (pserver_info_101) {
                    pfnNetApiBufferFree((LPVOID)pserver_info_101);
                }
            }

            //
            // Add entry to the cache
            //
            EnterSplSem();
            AddEntrytoLMCache(PrinterName, pShare);
            LeaveSplSem();
        }
    }

    /* Make sure we can write to the print share.
     * This will fail if there's an invalid password.
     */
    /* hTest = CreateFile(pPrinterName, GENERIC_WRITE, 0, NULL,
                       OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hTest == INVALID_HANDLE_VALUE) {

        DBGMSG(DBG_WARNING, ("Can't write to %ws: Error %d\n",
                             pPrinterName, GetLastError()));
        return FALSE;
    }


    CloseHandle(hTest); */

    /* Make sure there's a port of this name so that
     * EnumPorts will return it:
     */
    if (!PortExists(NULL, pPrinterName, &Error) && (Error == NO_ERROR)) {
        if (CreatePortEntry(pPrinterName, &pIniFirstPort)) {
            CreateRegistryEntry(pPrinterName);
        }
    }

    if (Error != NO_ERROR)
        return FALSE;

    cb = sizeof(WSPOOL);

   EnterSplSem();
    pSpool = AllocWSpool();
   LeaveSplSem();

    if ( pSpool != NULL ) {

        pSpool->pServer = AllocSplStr(PrinterName);
        pSpool->pShare = AllocSplStr(pShare);
        pSpool->Status = 0;
        pSpool->Type = LM_HANDLE;

    } else {

        DBGMSG(DBG_TRACE,("Error: LMOpenPrinter to return ERROR_NOT_ENOUGH_MEMORY\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
    }

    *phPrinter = (HANDLE)pSpool;

    return TRUE;
}

BOOL
LMSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    PWSPOOL          pSpool = (PWSPOOL)hPrinter;

    API_RET_TYPE    uReturnCode;
    DWORD           dwParmError;
    USE_INFO_1      UseInfo1;
    PUSE_INFO_1     pUseInfo1 = &UseInfo1;
    WCHAR           szRemoteShare[MAX_PATH];
    DWORD           dwRet;


    if (!pSpool ||
        pSpool->signature != WSJ_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if( (dwRet = StrNCatBuff(szRemoteShare, COUNTOF(szRemoteShare), pSpool->pServer, L"\\", szAdmin, NULL )) != ERROR_SUCCESS ) {

        SetLastError(dwRet);
        return FALSE;
    }

    pUseInfo1->ui1_local = NULL;
    pUseInfo1->ui1_remote =   szRemoteShare;
    pUseInfo1->ui1_password = NULL;
    pUseInfo1->ui1_asg_type = 0;
    dwParmError = 0;

    switch (Command) {

    case 0:
        break;

    case PRINTER_CONTROL_PURGE:
        uReturnCode = RxPrintQPurge(pSpool->pServer, pSpool->pShare);
        if (uReturnCode) {

            uReturnCode = NetUseAdd(NULL, 1,
                               (LPBYTE)pUseInfo1,
                               &dwParmError);
            if (uReturnCode == ERROR_ACCESS_DENIED) {
                SetLastError(ERROR_ACCESS_DENIED);
                return(FALSE);

            } else {

                uReturnCode = RxPrintQPurge(pSpool->pServer, pSpool->pShare);
                if (uReturnCode == ERROR_ACCESS_DENIED) {
                    NetUseDel(NULL,
                                pUseInfo1->ui1_remote, USE_FORCE);
                    SetLastError(ERROR_ACCESS_DENIED);
                    return(FALSE);
                }
                NetUseDel(NULL,
                                pUseInfo1->ui1_remote, USE_FORCE);
            }
        }
        break;

    case PRINTER_CONTROL_RESUME:
        uReturnCode = RxPrintQContinue(pSpool->pServer, pSpool->pShare);
        if (uReturnCode) {

            uReturnCode = NetUseAdd(NULL, 1,
                                    (LPBYTE)pUseInfo1,
                                    &dwParmError);
            if (uReturnCode == ERROR_ACCESS_DENIED) {
                SetLastError(ERROR_ACCESS_DENIED);
                return(FALSE);

            } else {
                uReturnCode = RxPrintQContinue(pSpool->pServer, pSpool->pShare);
                if (uReturnCode == ERROR_ACCESS_DENIED) {
                    NetUseDel(NULL,
                                    pUseInfo1->ui1_remote, USE_FORCE);
                    SetLastError(ERROR_ACCESS_DENIED);
                    return(FALSE);
                }
                NetUseDel(NULL,
                                    pUseInfo1->ui1_remote, USE_FORCE);
            }
        }
        break;

    case PRINTER_CONTROL_PAUSE:
        uReturnCode = RxPrintQPause(pSpool->pServer, pSpool->pShare);
        if (uReturnCode) {

            uReturnCode = NetUseAdd(NULL, 1,
                                    (LPBYTE)pUseInfo1,
                                    &dwParmError);
            if (uReturnCode == ERROR_ACCESS_DENIED) {
                SetLastError(ERROR_ACCESS_DENIED);
                return(FALSE);

            } else {
                uReturnCode = RxPrintQPause(pSpool->pServer, pSpool->pShare);
                if (uReturnCode) {
                    NetUseDel(NULL,
                                        pUseInfo1->ui1_remote, USE_FORCE);
                    SetLastError(ERROR_ACCESS_DENIED);
                    return(FALSE);
                }
                NetUseDel(NULL,
                                    pUseInfo1->ui1_remote, USE_FORCE);
            }

        }
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        break;
    }

    //
    // SetPrinter successful - so pulse here if event set,
    // or reply to spooler.
    //
    LMSetSpoolChange(pSpool);

    return TRUE;
}

#define Nullstrlen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

DWORD
GetPrqInfo3Size(
    PWSPOOL  pSpool,
    PRQINFO3 *pPrqInfo3,
    DWORD   Level
)
{
    DWORD   cb;

    switch (Level) {

    case 1:

        //
        // 3 extra chars
        // (2 NULL terminators, 1 for '\' (server/share separator)
        //
        cb=sizeof(PRINTER_INFO_1) +
           wcslen(pSpool->pServer)*sizeof(WCHAR)*2 +
           wcslen(pSpool->pShare)*sizeof(WCHAR) +
           sizeof(WCHAR)*3 +
           Nullstrlen(pPrqInfo3->pszComment);
        break;

    case 2:

        cb = sizeof(PRINTER_INFO_2) +
             wcslen(pSpool->pServer)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(pSpool->pServer)*sizeof(WCHAR) +
             sizeof(WCHAR) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrqInfo3->pszPrinters) +
             Nullstrlen(pPrqInfo3->pszDriverName) +
             Nullstrlen(pPrqInfo3->pszComment) +
             Nullstrlen(pPrqInfo3->pszSepFile) +
             Nullstrlen(pPrqInfo3->pszPrProc) +
             wcslen(L"RAW")*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrqInfo3->pszParms);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

// This can be radically tidied up
// We should probably use the stack for the
// array of string pointers rather than dynamically allocating it !

LPBYTE
CopyPrqInfo3ToPrinter(
    PWSPOOL  pSpool,
    PRQINFO3 *pPrqInfo3,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    LPBYTE  pEnd
)
{
    LPWSTR  *pSourceStrings, *SourceStrings;
    PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_1 pPrinter1 = (PPRINTER_INFO_1)pPrinterInfo;
    DWORD   i;
    DWORD   *pOffsets;
    DWORD   RetVal = ERROR_SUCCESS;
    WCHAR   szFileName[MAX_PATH];

    switch (Level) {

    case 1:
        pOffsets = PrinterInfo1Strings;
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        break;

    default:
        return pEnd;
    }

    for (i=0; pOffsets[i] != -1; i++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(i * sizeof(LPWSTR));

    if (!SourceStrings)
        return NULL;

    switch (Level) {

    case 1:
        *pSourceStrings++=pSpool->pServer;

        RetVal = StrNCatBuff( szFileName, 
                              COUNTOF(szFileName),
                              pSpool->pServer,
                              L"\\",
                              pSpool->pShare,
                              NULL );
        if ( RetVal != ERROR_SUCCESS )
        {
          break;
        }

        *pSourceStrings++=szFileName;
        *pSourceStrings++=pPrqInfo3->pszComment;

        pEnd = PackStrings(SourceStrings, pPrinterInfo, pOffsets, pEnd);

        pPrinter1->Flags = PRINTER_ENUM_REMOTE | PRINTER_ENUM_NAME;
        break;

    case 2:

        RetVal = StrNCatBuff( szFileName, 
                              COUNTOF(szFileName),
                              pSpool->pServer,
                              L"\\",
                              pSpool->pShare,
                              NULL );
        if ( RetVal != ERROR_SUCCESS )
        {
          break;
        }


        *pSourceStrings++=pSpool->pServer;

        *pSourceStrings++=szFileName;

        *pSourceStrings++=pSpool->pShare;
        *pSourceStrings++=pPrqInfo3->pszPrinters;
        *pSourceStrings++=pPrqInfo3->pszDriverName ? pPrqInfo3->pszDriverName : L"";
        *pSourceStrings++=pPrqInfo3->pszComment;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrqInfo3->pszSepFile;
        *pSourceStrings++=pPrqInfo3->pszPrProc;
        *pSourceStrings++=L"RAW";
        *pSourceStrings++=pPrqInfo3->pszParms;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter2, pOffsets, pEnd);

        pPrinter2->pDevMode=0;
        pPrinter2->Attributes=PRINTER_ATTRIBUTE_QUEUED;
        pPrinter2->Priority=pPrqInfo3->uPriority;
        pPrinter2->DefaultPriority=pPrqInfo3->uPriority;
        pPrinter2->StartTime=pPrqInfo3->uStartTime;
        pPrinter2->UntilTime=pPrqInfo3->uUntilTime;

        pPrinter2->Status=0;

        if (pPrqInfo3->fsStatus & PRQ3_PAUSED)
            pPrinter2->Status|=PRINTER_STATUS_PAUSED;

        if (pPrqInfo3->fsStatus & PRQ3_PENDING)
            pPrinter2->Status|=PRINTER_STATUS_PENDING_DELETION;

        pPrinter2->cJobs=pPrqInfo3->cJobs;
        pPrinter2->AveragePPM=0;
        break;

    default:
        return pEnd;
    }

    FreeSplMem(SourceStrings);

    if ( RetVal == ERROR_SUCCESS )
    {
        return pEnd;
    }
    else
    {
        return NULL;
    }
}

BOOL
LMGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    PRQINFO3 *pPrqInfo3;
    PRQINFO3 PrqInfo3;
    PRQINFO *pPrqInfo=NULL;
    DWORD   cb = 0x400;
    DWORD   rc;
    DWORD   cbNeeded;
    LPBYTE  pInfo = NULL;
    BOOL    bWFW = FALSE;


    if (Level >= 7) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!pSpool ||
        pSpool->signature != WSJ_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pPrqInfo3 = AllocSplMem(cb);

    if ( !pPrqInfo3 )
        goto Cleanup;

    if ( rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 3,
                              (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

        if (rc == ERROR_MORE_DATA || rc == NERR_BufTooSmall) {

            pPrqInfo3=ReallocSplMem(pPrqInfo3, 0, cbNeeded);

            if ( !pPrqInfo3 )
                goto Cleanup;

            cb=cbNeeded;

            if (rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare,
                                     3, (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

                SetLastError(rc);
                goto Cleanup;
            }

        } else if (rc == ERROR_INVALID_LEVEL) {

            // Must be WFW

            if (rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 1,
                                     (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

                if (rc == ERROR_MORE_DATA || rc == NERR_BufTooSmall) {

                    pPrqInfo3 = ReallocSplMem(pPrqInfo3, 0, cbNeeded);

                    if ( !pPrqInfo3 )
                        goto Cleanup;

                    cb=cbNeeded;

                    if (rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 1,
                                             (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

                        SetLastError(rc);
                        goto Cleanup;
                    }

                } else {

                    SetLastError(rc);
                    goto Cleanup;
                }
            }

            pPrqInfo = (PRQINFO *)pPrqInfo3;

            PrqInfo3.pszName = pPrqInfo->szName;
            PrqInfo3.uPriority = pPrqInfo->uPriority;
            PrqInfo3.uStartTime = pPrqInfo->uStartTime;
            PrqInfo3.uUntilTime = pPrqInfo->uUntilTime;
            PrqInfo3.pad1 = 0;
            PrqInfo3.pszSepFile = pPrqInfo->pszSepFile;
            PrqInfo3.pszPrProc = pPrqInfo->pszPrProc;
            PrqInfo3.pszParms = pPrqInfo->pszDestinations;
            PrqInfo3.pszComment = pPrqInfo->pszComment;
            PrqInfo3.fsStatus = pPrqInfo->fsStatus;
            PrqInfo3.cJobs = pPrqInfo->cJobs;
            PrqInfo3.pszPrinters = pPrqInfo->pszDestinations;
            PrqInfo3.pszDriverName = L"";
            PrqInfo3.pDriverData = NULL;

            bWFW = TRUE;

        } else {

            SetLastError(rc);
            goto Cleanup;
        }
    }

    cbNeeded=GetPrqInfo3Size(pSpool,
                             bWFW ? &PrqInfo3 : pPrqInfo3,
                             Level);

    *pcbNeeded=cbNeeded;

    if (cbNeeded > cbBuf) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    pInfo = CopyPrqInfo3ToPrinter(pSpool,
                                  bWFW ? &PrqInfo3 : pPrqInfo3,
                                  Level,
                                  pPrinter,
                                  (LPBYTE)pPrinter+cbBuf);

Cleanup:
    if (pPrqInfo3)
        FreeSplMem(pPrqInfo3);

    return pInfo != NULL;
}

BOOL
LMEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    rc=TRUE;
    DWORD   cb;
    PWINIPORT pIniPort;
    LPBYTE  pEnd;


    switch (Level) {

    case 1:
        break;

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

   EnterSplSem();

    cb=0;

    pIniPort = pIniFirstPort;

    while (pIniPort) {
        cb+=GetPortSize(pIniPort, Level);
        pIniPort=pIniPort->pNext;
    }

    *pcbNeeded=cb;


    if (cb <= cbBuf) {

        pEnd=pPorts+cbBuf;
        *pcReturned=0;

        pIniPort = pIniFirstPort;
        while (pIniPort) {
            pEnd = CopyIniPortToPort(pIniPort, Level, pPorts, pEnd);
            switch (Level) {
            case 1:
                pPorts+=sizeof(PORT_INFO_1);
                break;

            case 2:
                pPorts+=sizeof(PORT_INFO_2);
                break;
            }
            pIniPort=pIniPort->pNext;
            (*pcReturned)++;
        }

    } else {

        *pcReturned = 0;

        rc = FALSE;

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

   LeaveSplSem();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\local.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Header file for Remote Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo net print vs. UNICODE.

    July 12 1994 Matthew Felton (MattFe) Caching

--*/

#include <dosprint.h>

// ID in the PRINTMAN.HLP file for the Browse Network dialog.
// This must not clash with IDs used in other places.

#define ID_HELP_LM_BROWSE_NETWORK_PRINTER   4000
#define OVERWRITE_EXISTING_FILE             FALSE
#define CALL_LM_OPEN                        TRUE
#define DO_NOT_CALL_LM_OPEN                 FALSE
#define GET_SECURITY_DESCRIPTOR             3
#define DO_NOT_USE_SCRATCH_DIR              FALSE
#define STRINGS_ARE_EQUAL                   0

//
// These define the values we fake out for a GetPrinter level 5 and EnumPrinter
// level 5 for the port Timeouts.
//
enum
{
    kDefaultDnsTimeout = 15000,
    kDefaultTxTimeout  = 45000
};

typedef enum
{
    kCheckPnPPolicy,
    kDownloadDriver,
    kDontDownloadDriver

} EDriverDownload;

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

typedef int (FAR WINAPI *INT_FARPROC)();

extern HANDLE  hInst;
extern CRITICAL_SECTION    SpoolerSection;

extern WCHAR *szRegistryPath;
extern WCHAR *szRegistryPortNames;
extern PWCHAR pszRaw;

extern HANDLE  hNetApi;
extern NET_API_STATUS (*pfnNetServerEnum)();
extern NET_API_STATUS (*pfnNetWkstaUserGetInfo)();
extern NET_API_STATUS (*pfnNetApiBufferFree)();

extern WCHAR szPrintProvidorName[];
extern WCHAR szPrintProvidorDescription[];
extern WCHAR szPrintProvidorComment[];
extern WCHAR *szLoggedOnDomain;
extern WCHAR *szRegistryConnections;
extern WCHAR szRegistryWin32Root[];
extern WCHAR szOldLocationOfServersKey[];
extern PWCHAR szWin32SplDirectory;

extern PWINIPORT pIniFirstPort;
extern PWSPOOL   pFirstWSpool;

extern WCHAR szMachineName[];
extern PWCHAR pszMonitorName;
extern PWCHAR gpSystemDir;
extern PWCHAR gpWin32SplDir;

extern LPWSTR *gppszOtherNames;   // Contains szMachineName, DNS name, and all other machine name forms
extern DWORD  gcOtherNames;

extern LPCWSTR pszCnvrtdmToken;
extern LPCWSTR pszDrvConvert;

extern BOOL  gbMachineInDomain;

#define IDS_LANMAN_PRINT_SHARE          100
#define IDS_NOTHING_TO_CONFIGURE        101
#define IDS_WINDOWS_NT_REMOTE_PRINTERS  102
#define IDS_MICROSOFT_WINDOWS_NETWORK   103
#define IDS_REMOTE_PRINTERS             104
#define IDS_MONITOR_NAME                105
#define IDS_PORT_NAME                   106

#define MSG_ERROR   MB_OK | MB_ICONSTOP
#define MSG_YESNO   MB_YESNO | MB_ICONQUESTION
#define MSG_INFORMATION     MB_OK | MB_ICONINFORMATION

#define MAX_PRINTER_INFO0   2*MAX_PATH*sizeof(WCHAR) + sizeof( PRINTER_INFO_STRESSW)


BOOL
MyName(
    LPWSTR   pName
);

BOOL
MyUNCName(
    LPWSTR   pName
);

BOOL
Initialize(
   VOID
);

VOID
SplInSem(
   VOID
);

VOID
SplOutSem(
   VOID
);

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

PWINIPORT
FindPort(
   LPWSTR pName,
   PWINIPORT pFirstPort
);

BOOL
LMSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);

BOOL
LMGetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);

BOOL
LMEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LMOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
);

BOOL
LMSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);

BOOL
LMGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LMEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

DWORD
LMStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);

BOOL
LMStartPagePrinter(
    HANDLE  hPrinter
);

BOOL
LMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
LMEndPagePrinter(
    HANDLE  hPrinter
);

BOOL
LMAbortPrinter(
   HANDLE hPrinter
);

BOOL
LMReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPDWORD  pNoBytesRead
);

BOOL
LMEndDocPrinter(
   HANDLE hPrinter
);

BOOL
LMAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LMScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

DWORD
LMGetPrinterData(
    HANDLE   hPrinter,
    LPTSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

DWORD
LMSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

BOOL
LMClosePrinter(
   HANDLE hPrinter
);

DWORD
LMWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

VOID
LMSetSpoolChange(
    PWSPOOL pSpool
);

BOOL
LMFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hPrinterLocal,
    PDWORD pfdwStatus);

BOOL
LMFindClosePrinterChangeNotification(
    HANDLE hPrinter);

VOID
LMSetSpoolerChange(
    PWSPOOL pSpool);

BOOL
LMDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
LMEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

PWINIPORT
CreatePortEntry(
    LPWSTR   pPortName,
    PPWINIPORT  ppFirstPort
);

BOOL
DeletePortEntry(
    LPWSTR   pPortName,
    PPWINIPORT  ppFirstPort
);

DWORD
CreateRegistryEntry(
    LPWSTR pPortName
);

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
);


DWORD
IsOlderThan(
    DWORD i,
    DWORD j
    );


DWORD
AddEntrytoLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    );


DWORD
FindEntryinLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    );


VOID
DeleteEntryfromLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    );


DWORD
FindEntryinWin32LMCache(
    LPWSTR pServerName
    );


VOID
DeleteEntryfromWin32LMCache(
    LPWSTR pServerName
    );


DWORD
AddEntrytoWin32LMCache(
    LPWSTR pServerName
    );

HANDLE
AddPrinterConnectionToCache(
    LPWSTR   pName,
    HANDLE  hPrinter,
    LPDRIVER_INFO_2W pDriverInfo
);

VOID
RefreshFormsCache(
    PWSPOOL pSpool
);

VOID
RefreshDriverDataCache(
    PWSPOOL pSpool
);

VOID
RefreshPrinterDataCache(
    PWSPOOL pSpool
);


DWORD
EnumerateAndCopyKey(
    PWSPOOL pSpool,
    LPWSTR  pKeyName
);


BOOL
CacheGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
RemoteGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
CacheEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
RemoteEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);


DWORD
CacheGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
CacheGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);

DWORD
RemoteGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
RemoteGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);

DWORD
RemoteEnumPrinterData(
    HANDLE   hPrinter,
    DWORD    dwIndex,
    LPWSTR   pValueName,
    DWORD    cbValueName,
    LPDWORD  pcbValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    cbData,
    LPDWORD  pcbData
);

DWORD
RemoteEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
);

DWORD
CacheEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
);

DWORD
RemoteEnumPrinterKey(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPWSTR   pSubkey,
    DWORD    cbSubkey,
    LPDWORD  pcbSubkey
);

DWORD
CacheEnumPrinterKey(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPWSTR   pSubkey,
    DWORD    cbSubkey,
    LPDWORD  pcbSubkey
);

DWORD
RemoteDeletePrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName
);

DWORD
RemoteDeletePrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName
);

DWORD
RemoteDeletePrinterKey(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName
);

DWORD
RemoteSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCTSTR pKeyName,
    LPCTSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

BOOL
RemoteXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus
);

LPWSTR
RemoveBackslashesForRegistryKey(
    LPWSTR pSource,
    const LPWSTR pScratch
);

LPBYTE
CopyPrinterNameToPrinterInfo(
    LPWSTR pServerName,
    LPWSTR pPrinterName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pEnd
);

BOOL
GetPrintSystemVersion(
);

BOOL Win32IsGoingToFile(
    HANDLE hPrinter,
    LPWSTR pOutputFile
);

LPWSTR
FormatPrinterForRegistryKey(
    LPWSTR PrinterName,
    LPWSTR KeyName);

LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR Keyname,
    LPWSTR PrinterName);

DWORD
InitializePortNames(
);

BOOL
WIN32FindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID  pvReserved0,
   PVOID  pvReserved1);

BOOL
WIN32FindClosePrinterChangeNotification(
   HANDLE hPrinter);


/* VALIDATE_NAME macro:
 *
 * pName is valid if:
 *
 *     pName is non-null
 *
 *     AND  first 2 characters of pName are "\\"
 *
 *          OR first 3 characters of pName are "LPT"
 *
 */
#define VALIDATE_NAME(pName) \
    ((pName) && *(pName) == L'\\' && *((pName)+1) == L'\\')

#define BYTE_STRING_LENGTH(UnicodeString)   \
    (wcslen(UnicodeString) * sizeof(WCHAR) + sizeof(WCHAR))

#define SET_REG_VAL_SZ(hKey, pValueName, pValueSz)  \
    (RegSetValueEx(hKey, pValueName, REG_OPTION_RESERVED,  \
                   REG_SZ, (LPBYTE)pValueSz, BYTE_STRING_LENGTH(pValueSz)) \
     == NO_ERROR)

#define SET_REG_VAL_DWORD(hKey, pValueName, Value)  \
    (RegSetValueEx(hKey, pValueName, REG_OPTION_RESERVED,  \
                   REG_DWORD, (LPBYTE)&Value, sizeof(DWORD))    \
     == NO_ERROR)

#define GET_REG_VAL_SZ(hKey, pValueName, awchValueSz, cbValueSz)    \
    cbValueSz = sizeof(awchValueSz), *awchValueSz = (WCHAR)0,       \
    (RegQueryValueEx(hKey, pValueName, REG_OPTION_RESERVED,          \
                     NULL, (LPBYTE)awchValueSz, &cbValueSz)         \
     == NO_ERROR)




typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;

BOOL
RemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault,
   BOOL     CallLMOpenPrinter
);

BOOL
RemoteClosePrinter(
    HANDLE hPrinter
);

BOOL
RemoteGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
RemoteGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
CacheGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
PrinterConnectionExists(
    LPWSTR pPrinterName
);

BOOL
AddPrinterConnectionPrivate(
    LPWSTR pName
);

BOOL
CacheOpenPrinter(
   LPWSTR   pName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
);

BOOL
GetSid(
    PHANDLE phToken
);

BOOL
SetCurrentSid(
    HANDLE  hToken
);

BOOL
DoAsyncRemoteOpenPrinter(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTS pDefault
);

DWORD
RemoteOpenPrinterThread(
    PWSPOOL  pSpool
);

BOOL
CacheClosePrinter(
    HANDLE  hPrinter
);


VOID
FreepSpool(
    PWSPOOL  pSpool
);

BOOL
DoRemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPPRINTER_DEFAULTS pDefault,
   PWSPOOL   pSpool
);

PWSPOOL
AllocWSpool(
    VOID
);

BOOL
CacheSyncRpcHandle(
    PWSPOOL pSpool
);

BOOL
ValidateW32SpoolHandle(
    PWSPOOL pSpool
);

#define SYNCRPCHANDLE( pSpool )     if ( !CacheSyncRpcHandle( pSpool ) ) { SplOutSem();  return FALSE; }
#define VALIDATEW32HANDLE( pSpool ) if ( !ValidateW32SpoolHandle( pSpool ) ) return FALSE;


BOOL
CacheResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
);

BOOL
RemoteResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
);

BOOL
CopypDefaultTopSpool(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTSW pDefault
);

HANDLE
MySplCreateSpooler(
    LPWSTR  pMachineName
);

VOID
RefreshCompletePrinterCache(
    IN      PWSPOOL             pSpool,
    IN      EDriverDownload     eDriverDownload
    );

VOID
ConvertRemoteInfoToLocalInfo(
    PPRINTER_INFO_2 pRemoteInfo
);

VOID
RefreshPrinter(
    PWSPOOL pSpool
);

VOID
RefreshPrinterInfo7(
    PWSPOOL pSpool
);

BOOL
CacheWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);


BOOL
RemoteEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
RemoteAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);


BOOL
RemoteConfigurePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
RemoteDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
RemoteAddPortEx(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
);

LPBYTE
CopyIniPortToPort(
    PWINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
);


DWORD
GetPortSize(
    PWINIPORT pIniPort,
    DWORD   Level
);

BOOL
CacheWriteRegistryExtra(
    LPWSTR  pName,
    HKEY    hPrinterKey,
    PWCACHEINIPRINTEREXTRA pExtraData
);


PWCACHEINIPRINTEREXTRA
CacheReadRegistryExtra(
    HKEY    hPrinterKey
);

PWCACHEINIPRINTEREXTRA
AllocExtraData(
    PPRINTER_INFO_2W pPrinterInfo2,
    DWORD cbPrinterInfo2
);

VOID
CacheFreeExtraData(
    PWCACHEINIPRINTEREXTRA pExtraData
);


BOOL
RemoteGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
CacheGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

DWORD
GetCachePrinterInfoSize(
    PWCACHEINIPRINTEREXTRA pExtraData
);

VOID
DownAndMarshallUpStructure(
   LPBYTE       lpStructure,
   LPBYTE       lpSource,
   LPDWORD      lpOffsets
);

VOID
CacheCopyPrinterInfo(
    PPRINTER_INFO_2W    pDestination,
    PPRINTER_INFO_2W    pPrinterInfo2,
    DWORD   cbPrinterInfo2
);


VOID
ConsistencyCheckCache(
    IN      PWSPOOL             pSpool,
    IN      EDriverDownload     eDriverDownload
    );

BOOL
CopyFileWithoutImpersonation(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists,
    BOOL bImpersonateOnCreate
);

BOOL
InternalDeletePrinterConnection(
    LPWSTR  pName,
    BOOL    bNotifyDriver
);

BOOL
RefreshPrinterDriver(
    IN  PWSPOOL             pSpool,
    IN  LPWSTR              pszDriverName,
    IN  EDriverDownload     eDriverDownload
    );

BOOL
RefreshPrinterCopyFiles(
    PWSPOOL pSpool
    );

BOOL
SavePrinterConnectionInRegistry(
    LPWSTR           pRealName,
    LPBYTE           pDriverInfo,
    DWORD            dwLevel
);


BOOL
OpenCachePrinterOnly(
   LPWSTR               pName,
   LPHANDLE             phSplPrinter,
   LPHANDLE             phIniSpooler,
   LPPRINTER_DEFAULTS   pDefault,
   BOOL                 bOpenOnly
);

BOOL
RemoteEndDocPrinter(
   HANDLE   hPrinter
);


BOOL
RemoteAddPrinterDriver(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   pDriverInfo
);


BOOL
DownloadDriverFiles(
    PWSPOOL pSpool,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel
);

PWSTR
StripString(
        PWSTR pszString,
        PCWSTR pszStrip,
        PCWSTR pszTerminator
);

BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszOtherNames,
    DWORD   *cOtherNames
);

VOID
FreeOtherNames(
    LPWSTR **ppszMyOtherNames,
    DWORD *cOtherNames
);


BOOL
CopyDriversLocally(
    PWSPOOL  pSpool,
    LPWSTR  pEnvironment,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel,
    DWORD   cbDriverInfo,
    LPDWORD pcbNeeded
    );

VOID
QueryTrustedDriverInformation(
    VOID
    );

BOOL
ValidRawDatatype(
    LPCWSTR pszDatatype
    );

BOOL
DoDevModeConversionAndBuildNewPrinterInfo2(
    IN     LPPRINTER_INFO_2 pInPrinter2,
    IN     DWORD            dwInSize,
    IN OUT LPBYTE           pOutBuf,
    IN     DWORD            dwOutSize,
    IN OUT LPDWORD          pcbNeeded,
    IN     PWSPOOL          pSpool
    );

HANDLE
LoadDriverFiletoConvertDevmodeFromPSpool(
    HANDLE  hSplPrinter
    );

DWORD
GetPolicy();

BOOL
AddDriverFromLocalCab(
    LPTSTR   pszDriverName,
    LPHANDLE pIniSpooler
    );

BOOL
IsTrustedPathConfigured(
    VOID
    );

BOOL
IsAdminAccess(
    IN  PRINTER_DEFAULTS    *pDefaults
    );

HRESULT
DoesPolicyAllowPrinterConnectionsToServer(
    IN      PCWSTR              pszQueue,
        OUT BOOL                *pbAllowPointAndPrint
    );

HRESULT
AreWeOnADomain(
        OUT BOOL                *pbDomain
    );

HRESULT
GetServerNameFromPrinterName(
    IN      PCWSTR              pszQueue,
        OUT PWSTR               *ppszServerName
    );

HRESULT
IsServerExplicitlyTrusted(
    IN      HKEY                hKeyPolicy,
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerTrusted
    );

HRESULT
IsServerInSameForest(
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerInSameForest
    );

HRESULT
GetDNSNameFromServerName(
    IN      PCWSTR              pszServerName,
        OUT PWSTR               *ppszFullyQualified
    );

HRESULT
UnicodeToAnsiString(
    IN      PCWSTR              pszUnicode,
        OUT PSTR                *ppszAnsi
    );

LPWSTR
AnsiToUnicodeStringWithAlloc(
    IN      LPSTR               pAnsi
    );

HRESULT
CheckSamePhysicalAddress(
    IN      PCWSTR              pszServer1,
    IN      PCWSTR              pszServer2,
        OUT BOOL                *pbSameAddress
    );

HRESULT
CheckUserPrintAdmin(
        OUT BOOL                *pbUserAdmin
    );

HRESULT
GetFullyQualifiedDomainName(
    IN      PCWSTR      pszServerName,
        OUT PWSTR       *ppszFullyQualified
    );

//
// The defines are used for policy install of printer drivers
// for point and print.  Currently the policy is hardcoded to
// only be SERVER_INF_INSTALL
//
#define SERVER_INSTALL_ONLY 1
#define INF_INSTALL_ONLY    2
#define SERVER_INF_INSTALL  4
#define INF_SERVER_INSTALL  8


extern DWORD cThisMajorVersion;
extern DWORD cThisMinorVersion;
extern DWORD gdwThisGetVersion;
extern WCHAR *szVersion;
extern WCHAR *szName;
extern WCHAR *szConfigurationFile;
extern WCHAR *szDataFile;
extern WCHAR *szDriver;

extern WCHAR *szEnvironment;
extern DWORD dwSyncOpenPrinter;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\precomp.h ===
/*++


Copyright (c) 1994 - 1996 Microsoft Corporation

Abstract:

    Header file for the win32spl

Author:

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <winsplp.h>
#include <lm.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <rpcasync.h>
#include "winspl.h"
#include <offsets.h>
#include <w32types.h>
#include <local.h>
#include <splcom.h>

#include <winsprlp.h>
#include <winddiui.h>
#include <wininet.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\port.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module contains the code for port handling

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <lm.h>
#include <lmuse.h>
#include <lmapibuf.h>
#include <w32types.h>
#include <local.h>
#include <offsets.h>
#include <wchar.h>
#include <mpr.h> /* for WNetBrowsePrinterDialog */
#include <splcom.h>             // DBGMSG
#include <winerror.h>

LPWSTR  pMonitorName = L"LAN Manager Print Share";
PWINIPORT pIniFirstPort = NULL;

PWINIPORT
CreatePortEntry(
    LPWSTR      pPortName,
    PPWINIPORT  ppFirstPort
)
{
    DWORD       cb;
    PWINIPORT    pIniPort, pPort, pFirstPort;

    pFirstPort = *ppFirstPort;

    cb = sizeof(WINIPORT);

   EnterSplSem();

    if (pIniPort = AllocSplMem(cb)) {

        pIniPort->pName = AllocSplStr( pPortName );
        pIniPort->cb = cb;
        pIniPort->pNext = 0;
        pIniPort->signature = WIPO_SIGNATURE;

        if (pPort = pFirstPort) {

            while (pPort->pNext)
                pPort = pPort->pNext;

            pPort->pNext = pIniPort;

        } else

            *ppFirstPort = pIniPort;
    }

   LeaveSplSem();

    return pIniPort;
}


BOOL
DeletePortEntry(
    LPWSTR   pPortName,
    PPWINIPORT ppFirstPort
)
{
    DWORD       cb;
    BOOL        rc;
    PWINIPORT    pPort, pPrevPort, pFirstPort;

    pFirstPort = *ppFirstPort;

    cb = sizeof(WINIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

   EnterSplSem();

    pPort = pFirstPort;
    while (pPort && lstrcmpi(pPort->pName, pPortName)) {
        pPrevPort = pPort;
        pPort = pPort->pNext;
    }

    if (pPort) {
        if ( pPort == pFirstPort ) {
            *ppFirstPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }
        FreeSplStr( pPort->pName );
        FreeSplMem(pPort);

        rc = TRUE;
    }
    else
        rc = FALSE;

   LeaveSplSem();

   return rc;
}


DWORD
CreateRegistryEntry(
    LPWSTR pPortName
)
{
    LONG  Status;
    HKEY  hkeyPath;
    HKEY  hkeyPortNames;
    HANDLE hToken;

    hToken = RevertToPrinterSelf();

    Status = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szRegistryPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyPath, NULL );

    if( Status == NO_ERROR ) {

        Status = RegCreateKeyEx( hkeyPath, szRegistryPortNames, 0,
                                 NULL, 0, KEY_WRITE, NULL, &hkeyPortNames, NULL );

        if( Status == NO_ERROR ) {

            Status = RegSetValueEx( hkeyPortNames,
                                    pPortName,
                                    0,
                                    REG_SZ,
                                    (LPBYTE)L"",
                                    0 );

            RegCloseKey( hkeyPortNames );

        } else {

            DBGMSG( DBG_ERROR, ( "RegCreateKeyEx (%ws) failed: Error = %d\n",
                                 szRegistryPortNames, Status ) );
        }

        RegCloseKey( hkeyPath );

    } else {

        DBGMSG( DBG_ERROR, ( "RegCreateKeyEx (%ws) failed: Error = %d\n",
                             szRegistryPath, Status ) );
    }

    ImpersonatePrinterClient(hToken);

    return Status;
}


DWORD
DeleteRegistryEntry(
    LPWSTR pPortName
)
{
    LONG   Status;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;
    HANDLE hToken;

    hToken = RevertToPrinterSelf();

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegistryPath, 0,
                           KEY_WRITE, &hkeyPath );

    if( Status == NO_ERROR ) {

        Status = RegOpenKeyEx( hkeyPath, szRegistryPortNames, 0,
                               KEY_WRITE, &hkeyPortNames );

        if( Status == NO_ERROR ) {

            RegDeleteValue( hkeyPortNames, pPortName );

            RegCloseKey( hkeyPortNames );

        } else {

            DBGMSG( DBG_WARNING, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                                   szRegistryPortNames, Status ) );
        }

        RegCloseKey( hkeyPath );

    } else {

        DBGMSG( DBG_WARNING, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                               szRegistryPath, Status ) );
    }

    ImpersonatePrinterClient(hToken);

    return Status;
}


BOOL
LMDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    BOOL rc;

    if (!MyName(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    rc = DeletePortEntry( pPortName, &pIniFirstPort );

    if(rc)
        DeleteRegistryEntry(pPortName);
    else
        SetLastError(ERROR_UNKNOWN_PORT);

    return rc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\prnfile.c ===
/*++

Copyright (c) 1994 - 1995  Microsoft Corporation

Module Name:

    prnfile.c

Abstract:

    This module contains all the code necessary for testing printing"
    to file to remote printers. There are two criteria based on which
    we will print to a file.

    Case 1:

     This is the true NT style print to file. One of the ports of the
     printer is a file port denoted as FILE: We will disregard any other
     port and straight away dump this job to file.


    Case 2:

    This is the "PiggyBacking" case. Apps such as WinWord, Publisher

Author:

    Krishna Ganugapati (Krishna Ganugapati) 6-June-1994

Revision History:
    6-June-1994 - Created.

--*/
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <lm.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <w32types.h>
#include <local.h>
#include <splcom.h>

typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;


WCHAR *szFilePort = L"FILE:";
WCHAR  *szNetPort = L"Net:";

//
// Function prototypes
//

PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
);

PKEYDATA
GetPrinterPortList(
    HANDLE hPrinter
    );

BOOL
IsaFileName(
    LPWSTR pOutputFile
    );

BOOL
IsaPortName(
        PKEYDATA pKeyData,
        LPWSTR pOutputFile
        );

BOOL
Win32IsGoingToFile(
    HANDLE hPrinter,
    LPWSTR pOutputFile
    )
{
    PKEYDATA pKeyData = NULL;
    BOOL   bErrorCode = FALSE;

    if (!pOutputFile || !*pOutputFile) {
        return FALSE;
    }

    pKeyData = GetPrinterPortList(hPrinter);

    if (pKeyData) {

        //
        // If it's not a port and it is a file name,
        // then it is going to file.
        //
        if (!IsaPortName(pKeyData, pOutputFile) && IsaFileName(pOutputFile)) {
            bErrorCode = TRUE;
        }

        FreeSplMem(pKeyData);
    }

    return bErrorCode;
}


BOOL
IsaFileName(
    LPWSTR pOutputFile
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR pFileName=NULL;

    //
    // Hack for Word20c.Win
    //

    if (!_wcsicmp(pOutputFile, L"FILE")) {
        return(FALSE);
    }

    if (wcslen(pOutputFile) < MAX_PATH && 
        GetFullPathName(pOutputFile, COUNTOF(FullPathName), FullPathName, &pFileName)) {
        if ((hFile = CreateFile(pOutputFile,
                                GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) != INVALID_HANDLE_VALUE) {
            if (GetFileType(hFile) == FILE_TYPE_DISK) {
                CloseHandle(hFile);
                return(TRUE);
            }else {
                CloseHandle(hFile);
                return(FALSE);
            }
        }
    }
    return(FALSE);
}

BOOL
IsaPortName(
        PKEYDATA pKeyData,
        LPWSTR pOutputFile
        )
{
    DWORD i = 0;
    UINT uStrLen;

    if (!pKeyData) {
        return(FALSE);
    }
    for (i=0; i < pKeyData->cTokens; i++) {
        if (!lstrcmpi(pKeyData->pTokens[i], pOutputFile)) {
            return(TRUE);
        }
    }

    //
    // Hack for NeXY: ports
    //
    if (!_wcsnicmp(pOutputFile, L"Ne", 2)) {

        uStrLen = wcslen( pOutputFile );

        //
        // Ne00: or Ne00 if app truncates it
        //
        if ( ( uStrLen == 5 ) || ( uStrLen == 4 ) )  {

            // Check for two Digits

            if (( pOutputFile[2] >= L'0' ) && ( pOutputFile[2] <= L'9' ) &&
                ( pOutputFile[3] >= L'0' ) && ( pOutputFile[3] <= L'9' )) {

                //
                // Check for the final : as in Ne01:,
                // note some apps will truncate it.
                //
                if (( uStrLen == 5 ) && (pOutputFile[4] != L':')) {
                    return FALSE;
                }
                return TRUE;
            }
        }
    }

    return(FALSE);
}

PKEYDATA
GetPrinterPortList(
    HANDLE hPrinter
    )
{
    LPBYTE pMem;
    LPTSTR pPort;
    DWORD  dwPassed = 1024; //Try 1K to start with
    LPPRINTER_INFO_2 pPrinter;
    DWORD dwLevel = 2;
    DWORD dwNeeded;
    PKEYDATA pKeyData;
    DWORD i = 0;


    pMem = AllocSplMem(dwPassed);
    if (pMem == NULL) {
        return FALSE;
    }
    if (!CacheGetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
        DBGMSG(DBG_TRACE, ("GetPrinterPortList GetPrinter error is %d\n", GetLastError()));
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            return NULL;
        }
        pMem = ReallocSplMem(pMem, 0, dwNeeded);
        dwPassed = dwNeeded;
        if (!CacheGetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
            FreeSplMem(pMem);
            return (NULL);
        }
    }
    pPrinter = (LPPRINTER_INFO_2)pMem;

    //
    // Fixes the null pPrinter->pPortName problem where
    // downlevel may return null
    //

    if (!pPrinter->pPortName) {
        FreeSplMem(pMem);
        return(NULL);
    }

    pKeyData = CreateTokenList(pPrinter->pPortName);
    FreeSplMem(pMem);

    return(pKeyData);
}


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    /* Scan through the string looking for commas,
     * ensuring that each is followed by a non-NULL character:
     */
    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +

         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocSplMem(cb)))
        return NULL;

    pResult->cb = cb;

    /* Initialise pDest to point beyond the token pointers:
     */
    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    /* Then copy the key data buffer there:
     */
    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;

    psz = pDest;

    do {

        *ppToken++ = psz;

        if ( psz = wcschr(psz, L',') )
            *psz++ = L'\0';

    } while (psz);

    pResult->cTokens = cTokens;

    return( pResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\sources.inc ===
NTPROFILEINPUT=yes

TARGETNAME=win32spl
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS = \
           $(PROJECT_ROOT)\lib\*\spoolss.lib \
           $(PROJECT_ROOT)\lib\*\localspl.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib   \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\rxapi.lib \
           $(SDK_LIB_PATH)\rxcommon.lib \
           $(SDK_LIB_PATH)\netrap.lib \
           $(SDK_LIB_PATH)\netlib.lib \
           $(SDK_LIB_PATH)\ws2_32.lib \
           $(DS_LIB_PATH)\netapi32p.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(PROJECT_ROOT)\lib\*\spllib.lib

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

INCLUDES=..\;..\..;                     \
         ..\..\..\inc;                  \
         ..\..\idl;                     \
         ..\..\..\..\..\inc;            \
         ..\..\..\..\inc;               \
         $(BASEDIR)\public\oak\inc;     \
         $(PRINTSCAN_INC_PATH);         \
         $(WINDOWS_INC_PATH);           \
         $(SHELL_INC_PATH);             \
         $(DS_INC_PATH);                \
         $(NET_INC_PATH);

USE_MSVCRT=1

SOURCES=..\winsplc.c ..\win32.c ..\trueconn.c ..\files.c \
        ..\bind.c ..\midluser.c ..\data.c ..\prnfile.c \
        ..\win32spl.rc ..\lmprn.c ..\util.c ..\lmjob.c ..\lmspl.c ..\port.c ..\change.c \
        ..\cache.c ..\cachemon.c

UMTEST=
UMTYPE=console

UMLIBS=$(O)\win32spl.lib
UMRES=$(O)\win32spl.res

C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -DNO_STRICT -DSPOOLKM -D_HYDRA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\w32types.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    w32types.h

Abstract:

    win32 spooler definitions

Author:

Revision History:

--*/

#ifndef MODULE
#define MODULE "WIN32SPL:"
#define MODULE_DEBUG Win32splDebug
#endif

typedef struct _LMNOTIFY *PLMNOTIFY;

typedef struct _LMNOTIFY {
    HANDLE          ChangeEvent;    // Notifies LanMan Printers status
    HANDLE          hNotify;        // LanMan notification structure
    DWORD           fdwChangeFlags; // LanMan notification watch flags
} LMNOTIFY;

// WARNING
// If you add anything here, initialize it in AllocWSpool and free it in FreepSpool

typedef struct _WSPOOL {
    DWORD           signature;
    struct _WSPOOL  *pNext;
    struct _WSPOOL  *pPrev;
    UINT            cRef;           // Reference Count
    LPWSTR          pName;
    DWORD           Type;
    HANDLE          RpcHandle;
    LPWSTR          pServer;
    LPWSTR          pShare;
    HANDLE          hFile;
    DWORD           Status;
    DWORD           RpcError;       // If Status & WSPOOL_STATUS_OPEN_ERROR
    LMNOTIFY        LMNotify;
    HANDLE          hIniSpooler;    // Machine Handle returned by Cache
    HANDLE          hSplPrinter;    // Local Spl Printer Handle
    HANDLE          hToken;             // Users Token
    PRINTER_DEFAULTSW PrinterDefaults;    // From the CacheOpenPrinter
    HANDLE          hWaitValidHandle;   // Wait on till RpcHandle becomes valid
    BOOL            bNt3xServer;
} WSPOOL;

typedef WSPOOL *PWSPOOL;

#define WSJ_SIGNATURE    0x474E  /* 'NG' is the signature value */

#define SJ_WIN32HANDLE  0x00000001
#define LM_HANDLE       0x00000002

//  WARNING
//  If you add anything here add code to the debugger extentions to display it

#define WSPOOL_STATUS_STARTDOC                   0x00000001
#define WSPOOL_STATUS_BEGINPAGE                  0x00000002
#define WSPOOL_STATUS_TEMP_CONNECTION            0x00000004
#define WSPOOL_STATUS_OPEN_ERROR                 0x00000008
#define WSPOOL_STATUS_PRINT_FILE                 0x00000010
#define WSPOOL_STATUS_USE_CACHE                  0x00000020
#define WSPOOL_STATUS_NO_RPC_HANDLE              0x00000040
#define WSPOOL_STATUS_PENDING_DELETE             0x00000080
#define WSPOOL_STATUS_RESETPRINTER_PENDING       0x00000100
#define WSPOOL_STATUS_NOTIFY                     0x00000200
#define WSPOOL_STATUS_NOTIFY_POLL                0x00000400
#define WSPOOL_STATUS_CNVRTDEVMODE               0x00000800

//  If you add to this structure also add code to CacheReadRegistryExtra
//  and CacheWriteRegistryExtra to make sure the cache items are persistant
//  Also See RefreshPrinter where data must be copied

typedef struct _WCACHEINIPRINTEREXTRA {
    DWORD   signature;
    DWORD   cb;
    LPPRINTER_INFO_2  pPI2;
    DWORD   cbPI2;
    DWORD   cCacheID;
    DWORD   cRef;
    DWORD   dwServerVersion;
    DWORD   dwTickCount;
    DWORD   Status;
} WCACHEINIPRINTEREXTRA, *PWCACHEINIPRINTEREXTRA;

#define WCIP_SIGNATURE  'WCIP'

#define EXTRA_STATUS_PENDING_FFPCN              0x00000001
#define EXTRA_STATUS_DOING_REFRESH              0x00000002

// Used in SplGetPrinterExtraEx to prevent recursion in AddPrinterConnection

#define EXTRAEX_STATUS_CREATING_CONNECTION      0x00000001

typedef struct _WINIPORT {       /* ipo */
    DWORD   signature;
    DWORD   cb;
    struct  _WINIPORT *pNext;
    LPWSTR  pName;
} WINIPORT, *PWINIPORT, **PPWINIPORT;

#define WIPO_SIGNATURE  'WIPO'

typedef struct _lmcache {
    WCHAR   szServerName[MAX_PATH];
    WCHAR   szShareName[MAX_PATH];
    BOOL    bAvailable;
    SYSTEMTIME st;
}LMCACHE, *PLMCACHE;


typedef struct _win32lmcache {
    WCHAR   szServerName[MAX_PATH];
    BOOL    bAvailable;
    SYSTEMTIME st;
}WIN32LMCACHE, *PWIN32LMCACHE;

// Define some constants to make parameters to CreateEvent a tad less obscure:

#define EVENT_RESET_MANUAL                  TRUE
#define EVENT_RESET_AUTOMATIC               FALSE
#define EVENT_INITIAL_STATE_SIGNALED        TRUE
#define EVENT_INITIAL_STATE_NOT_SIGNALED    FALSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\trueconn.c ===
/*++


Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    trueconn.c

Abstract:

    This module contains routines for copying drivers from the Server to the
    Workstation for Point and Print or "True Connections."

Author:

    Krishna Ganugapati (Krishna Ganugapati) 21-Apr-1994

Revision History:
    21-Apr-1994 - Created.

    21-Apr-1994 - There are actually two code modules in this file. Both deal
                  with true connections

    27-Oct-1994 - Matthew Felton (mattfe) rewrite updatefile routine to allow
                  non power users to point and print, for caching.   Removed
                  old Caching code.

    23-Feb-1995 - Matthew Felton (mattfe) removed more code by allowing spladdprinterdriver
                  to do all file copying.

    24-Mar-1999 - Felix Maxa (AMaxa) AddPrinterDriver key must be read from the old location
                  of the Servers key in System hive

    19-Oct-2000 - Steve Kiraly (SteveKi) Read the AddPrinterDrivers key every time, group
                  policy modifies this key while the spooler is running, we don't want require
                  the customer to restart the spooler when this policy changes.
--*/

#include "precomp.h"

DWORD dwLoadTrustedDrivers = 0;
WCHAR TrustedDriverPath[MAX_PATH];
DWORD dwSyncOpenPrinter = 0;

BOOL
ReadImpersonateOnCreate(
    VOID
    )
{
    BOOL            bImpersonateOnCreate    = FALSE;
    HKEY            hKey                    = NULL;
    NT_PRODUCT_TYPE NtProductType           = {0};
    DWORD           dwRetval                = ERROR_SUCCESS;
    DWORD           cbData                  = sizeof(bImpersonateOnCreate);
    DWORD           dwType                  = REG_DWORD;

    //
    // Open the providers registry key
    //
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            szOldLocationOfServersKey,
                            0,
                            KEY_READ, &hKey);

    if (dwRetval == ERROR_SUCCESS)
    {
        //
        // Attempt to read the AddPrinterDrivers policy.
        //
        dwRetval = RegQueryValueEx(hKey,
                                   L"AddPrinterDrivers",
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&bImpersonateOnCreate,
                                   &cbData);
    }

    //
    // If we did not read the AddPrinterDrivers policy then set the default
    // based on the product type.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        bImpersonateOnCreate = FALSE;

        // Server Default       Always Impersonate on AddPrinterConnection
        // WorkStation Default  Do Not Impersonate on AddPrinterConnection

        if (RtlGetNtProductType(&NtProductType))
        {
            if (NtProductType != NtProductWinNt)
            {
                bImpersonateOnCreate = TRUE;
            }
        }
    }

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return bImpersonateOnCreate;
}

BOOL
CopyDriversLocally(
    PWSPOOL  pSpool,
    LPWSTR  pEnvironment,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel,
    DWORD   cbDriverInfo,
    LPDWORD pcbNeeded)
{
    DWORD  ReturnValue=FALSE;
    DWORD  RpcError;
    DWORD  dwServerMajorVersion = 0;
    DWORD  dwServerMinorVersion = 0;
    BOOL   DaytonaServer = TRUE;
    BOOL   bReturn = FALSE;


    if (pSpool->Type != SJ_WIN32HANDLE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    //
    // Test RPC call to determine if we're talking to Daytona or Product 1
    //

    SYNCRPCHANDLE( pSpool );

    RpcTryExcept {

        ReturnValue = RpcGetPrinterDriver2(pSpool->RpcHandle,
                                           pEnvironment, dwLevel,
                                           pDriverInfo,
                                           cbDriverInfo,
                                           pcbNeeded,
                                           cThisMajorVersion,
                                           cThisMinorVersion,
                                           &dwServerMajorVersion,
                                           &dwServerMinorVersion);
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        RpcError = RpcExceptionCode();
        ReturnValue = RpcError;

        if (RpcError == RPC_S_PROCNUM_OUT_OF_RANGE) {

            //
            // Product 1 server
            //
            DaytonaServer = FALSE;
        }

    } RpcEndExcept

    if ( DaytonaServer ) {

        if (ReturnValue) {

            SetLastError(ReturnValue);
            goto FreeDone;
        }

    } else {

        RpcTryExcept {

            //
            // I am talking to a Product 1.0/511/528
            //

                        ReturnValue = RpcGetPrinterDriver( pSpool->RpcHandle,
                                               pEnvironment,
                                               dwLevel,
                                               pDriverInfo,
                                               cbDriverInfo,
                                               pcbNeeded );
        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            RpcError = RpcExceptionCode();

        } RpcEndExcept

        if (ReturnValue) {

            SetLastError(ReturnValue);
            goto FreeDone;
        }
    }

    switch (dwLevel) {

        case 2:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo2Fields, sizeof(DRIVER_INFO_2), RPC_CALL);
            break;

        case 3:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo3Fields, sizeof(DRIVER_INFO_3), RPC_CALL);
            break;

        case 4:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo4Fields, sizeof(DRIVER_INFO_4), RPC_CALL);
             break;

        case 6:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo6Fields, sizeof(DRIVER_INFO_6), RPC_CALL);
            break;

        case DRIVER_INFO_VERSION_LEVEL:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfoVersionFields, sizeof(DRIVER_INFO_VERSION), RPC_CALL);
            break;

        default:
            DBGMSG(DBG_ERROR,
                   ("CopyDriversLocally: Invalid level %d", dwLevel));

            SetLastError(ERROR_INVALID_LEVEL);
            bReturn =  FALSE;
            goto FreeDone;
    }

    if (bReturn)
    {
        bReturn = DownloadDriverFiles(pSpool, pDriverInfo, dwLevel);
    }

FreeDone:
    return bReturn;
}


BOOL
ConvertDependentFilesToTrustedPath(
    LPWSTR *pNewDependentFiles,
    LPWSTR  pOldDependentFiles,
    DWORD   dwVersion)
{
    //
    // Assuming version is single digit
    // we need space for \ and the version digit
    //
    DWORD   dwVersionPathLen = wcslen(TrustedDriverPath) + 2;

    DWORD   dwFilenameLen, cchSize;
    LPWSTR  pStr1, pStr2, pStr3;

    if ( !pOldDependentFiles || !*pOldDependentFiles ) {

        *pNewDependentFiles = NULL;
        return TRUE;
    }

    pStr1 = pOldDependentFiles;
    cchSize = 0;

    while ( *pStr1 ) {

        pStr2              = wcsrchr( pStr1, L'\\' );
        dwFilenameLen      = wcslen(pStr2) + 1;
        cchSize           += dwVersionPathLen + dwFilenameLen;
        pStr1              = pStr2 + dwFilenameLen;
    }

    // For the last \0
    ++cchSize;

    *pNewDependentFiles = AllocSplMem(cchSize*sizeof(WCHAR));

    if ( !*pNewDependentFiles ) {

        return FALSE;
    }

    pStr1 = pOldDependentFiles;
    pStr3 = *pNewDependentFiles;

    while ( *pStr1 ) {

        pStr2              = wcsrchr( pStr1, L'\\' );
        dwFilenameLen      = wcslen(pStr2) + 1;

        wsprintf( pStr3, L"%ws\\%d%ws", TrustedDriverPath, dwVersion, pStr2 );

        pStr1  = pStr2 + dwFilenameLen;
        pStr3 += dwVersionPathLen + dwFilenameLen;
    }


    *pStr3 = '\0';
    return TRUE;
}


LPWSTR
ConvertToTrustedPath(
    PWCHAR  pScratchBuffer,
    LPWSTR pDriverPath,
    DWORD   cVersion

)
{
    PWSTR  pData;
    SPLASSERT( pScratchBuffer != NULL && pDriverPath != NULL );

    pData = wcsrchr( pDriverPath, L'\\' );

    wsprintf( pScratchBuffer, L"%ws\\%d%ws", TrustedDriverPath, cVersion, pData );

    return ( AllocSplStr( pScratchBuffer ) );
}

//
// GetPolicy()
//
// We are hard coding the policy to try the server first and then
// to try the inf install if this installation failed.
//
// This function may be used in the future to leverage different policies.
//
DWORD
GetPolicy()
{
    return (SERVER_INF_INSTALL);
}


//
// If there is a language monitor associated with the driver and it is
// not installed on this machine NULL the pMonitorName field.
// We do not want to download the monitor from thr server since there 
// is no version associated with them
//
BOOL
NullMonitorName (
    LPBYTE  pDriverInfo,
    DWORD   dwLevel
    )
{
    LPWSTR  *ppMonitorName = NULL;
    BOOL    bReturn = FALSE;

    switch (dwLevel) {
        case 3:
        case 4:
        case 6:
        {
            ppMonitorName = &((LPDRIVER_INFO_6)pDriverInfo)->pMonitorName;
            break;
        }
        case DRIVER_INFO_VERSION_LEVEL:
        {
            ppMonitorName = &((LPDRIVER_INFO_VERSION)pDriverInfo)->pMonitorName;
            break;
        }
        default:
        {
            break;
        }
    }

    if (ppMonitorName && *ppMonitorName && **ppMonitorName  &&
        !SplMonitorIsInstalled(*ppMonitorName))
    {
        *ppMonitorName = NULL;
        bReturn = TRUE;
    }

    return bReturn;
}

BOOL
DownloadDriverFiles(
    PWSPOOL pSpool,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel
)
{
    PWCHAR  pScratchBuffer  = NULL;
    BOOL    bReturnValue    = FALSE;
    LPBYTE  pTempDriverInfo = NULL;
    DWORD   dwVersion;
    DWORD   dwInstallPolicy = GetPolicy();
    LPDRIVER_INFO_6 pTempDriverInfo6, pDriverInfo6;

    //
    // If there is a language monitor associated with the driver and it is
    // not installed on this machine NULL the pMonitorName field.
    // We do not want to pull down the monitor since there is no version
    // associated with them
    //
    NullMonitorName(pDriverInfo, dwLevel);

    //
    // If LoadTrustedDrivers is FALSE
    // then we don't care, we load the files from
    // server itself because he has the files
    //

    if ( !IsTrustedPathConfigured() ) {
        //
        //  At this point dwInstallPolicy will always be SERVER_INF_INSTALL
        //  as this is hardcoded in the GetPolicy() call.
        //  This will always be executed in the current GetPolicy() implementation.
        //
        //  If this is only a server install or we're doing a server install first.
        //
        if( dwInstallPolicy & SERVER_INSTALL_ONLY || dwInstallPolicy & SERVER_INF_INSTALL )
        {
            //
            // SplAddPrinterDriverEx will do the copying of the Driver files if the
            // date and time are newer than the drivers it already has
            //
            bReturnValue =  SplAddPrinterDriverEx( NULL,
                                                   dwLevel,
                                                   pDriverInfo,
                                                   APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                   pSpool->hIniSpooler,
                                                   DO_NOT_USE_SCRATCH_DIR,
                                                   ReadImpersonateOnCreate() );

            if (!bReturnValue && dwLevel == 6 && GetLastError() == ERROR_INVALID_LEVEL)
            {
                //
                // If a call with level 6 failed, then try with level 4
                //
                bReturnValue = SplAddPrinterDriverEx( NULL,
                                                      4,
                                                      pDriverInfo,
                                                      APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                      pSpool->hIniSpooler,
                                                      DO_NOT_USE_SCRATCH_DIR,
                                                      ReadImpersonateOnCreate() );
            }
        }

        //
        //  dwInstallPolicy will be SERVER_INF_INSTALL at this point due to the
        //  current implementation of GetPolicy().  The below code will only be
        //  executed if the SplAddPrinterDriverEx calls above failed.
        //
        //  Do this only if we haven't tried a previous install or the previous attempt failed.
        //  Policy:  If this is an INF install only,
        //           or we're doing and INF install first,
        //           or the INF install is happening after the server install.
        //
        if( !bReturnValue && (ERROR_PRINTER_DRIVER_BLOCKED != GetLastError()) && !(dwInstallPolicy & SERVER_INSTALL_ONLY) )
        {
            LPDRIVER_INFO_2 pDriverInfo2 = (LPDRIVER_INFO_2)pDriverInfo;
            LPDRIVER_INFO_1 pDriverInfo1 = (LPDRIVER_INFO_1)pDriverInfo;

            //
            // Assume if info2 is valid, info1 is too.
            //
            if( pDriverInfo2 ) {
                //
                // Paranoid code.  We should never receive a call with a level
                // one, but if we did, the driver info struct for level 1 is
                // different to that in a level 2, so we could AV if we don't
                // do this.
                //
                bReturnValue = AddDriverFromLocalCab( dwLevel == 1 ? pDriverInfo1->pName : pDriverInfo2->pName,
                                                      pSpool->hIniSpooler );
            }
            else if( dwInstallPolicy & INF_INSTALL_ONLY )
            {
                //
                //  If this isn't an inf only install, then we should not overwrite the
                //  last error that will occur with AddPrinterDriver calls.
                //  If this is an inf install only, pDriverInfo2 was NULL
                //  so we need to set some last error for this install.
                //
                SetLastError( ERROR_INVALID_PARAMETER );
            }
        }

        //
        //  Due to the current implemenation of GetPolicy() the below section
        //  of code will never be executed.  If the GetPolicy() call changes from
        //  being hardcoded into something actually policy driven, then could be used.
        //
        //  If the inf install is followed by a server install.
        //  Do this only if the previous install has failed.
        //
        if( !bReturnValue && dwInstallPolicy & INF_SERVER_INSTALL )
        {
            //
            // SplAddPrinterDriverEx will do the copying of the Driver files if the
            // date and time are newer than the drivers it already has
            //
            bReturnValue =  SplAddPrinterDriverEx( NULL,
                                                   dwLevel,
                                                   pDriverInfo,
                                                   APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                   pSpool->hIniSpooler,
                                                   DO_NOT_USE_SCRATCH_DIR,
                                                   ReadImpersonateOnCreate() );

            if (!bReturnValue && dwLevel == 6 && GetLastError() == ERROR_INVALID_LEVEL)
            {
                //
                // If a call with level 6 failed, then try with level 4
                //
                bReturnValue = SplAddPrinterDriverEx( NULL,
                                                      4,
                                                      pDriverInfo,
                                                      APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                      pSpool->hIniSpooler,
                                                      DO_NOT_USE_SCRATCH_DIR,
                                                      ReadImpersonateOnCreate() );
            }
        }

        return bReturnValue;
    }

    //
    // check if we have a valid path to retrieve the files from
    //
    if ( !TrustedDriverPath || !*TrustedDriverPath ) {

        DBGMSG( DBG_WARNING, ( "DownloadDriverFiles Bad Trusted Driver Path\n" ));
        SetLastError( ERROR_FILE_NOT_FOUND );
        return(FALSE);
    }

    DBGMSG( DBG_TRACE, ( "Retrieving Files from Trusted Driver Path\n" ) );
    DBGMSG( DBG_TRACE, ( "Trusted Driver Path is %ws\n", TrustedDriverPath ) );

    //
    // In the code below the if statement we make the assumption that the caller 
    // passed in a pointer to a DRIVER_INFO_6 structure or to a DRIVER_INFO_6 
    // compatible structure, we need to check the level 
    //
    if (dwLevel == DRIVER_INFO_VERSION_LEVEL) 
    {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

 try {

    pScratchBuffer = AllocSplMem( MAX_PATH );
    if ( pScratchBuffer == NULL )
        leave;

    pDriverInfo6   = (LPDRIVER_INFO_6) pDriverInfo;
    pTempDriverInfo = AllocSplMem(sizeof(DRIVER_INFO_6));

    if ( pTempDriverInfo == NULL )
        leave;

    pTempDriverInfo6 = (LPDRIVER_INFO_6) pTempDriverInfo;

    pTempDriverInfo6->cVersion     = pDriverInfo6->cVersion;
    pTempDriverInfo6->pName        = pDriverInfo6->pName;
    pTempDriverInfo6->pEnvironment = pDriverInfo6->pEnvironment;

    pTempDriverInfo6->pDriverPath = ConvertToTrustedPath(pScratchBuffer,
                                                         pDriverInfo6->pDriverPath,
                                                         pDriverInfo6->cVersion);

    pTempDriverInfo6->pConfigFile = ConvertToTrustedPath(pScratchBuffer,
                                                         pDriverInfo6->pConfigFile,
                                                         pDriverInfo6->cVersion);

    pTempDriverInfo6->pDataFile = ConvertToTrustedPath(pScratchBuffer,
                                                       pDriverInfo6->pDataFile,
                                                       pDriverInfo6->cVersion);


    if ( pTempDriverInfo6->pDataFile == NULL        ||
         pTempDriverInfo6->pDriverPath == NULL      ||
         pTempDriverInfo6->pConfigFile == NULL  ) {

        leave;
    }

    if ( dwLevel == 2 )
        goto Call;

    pTempDriverInfo6->pMonitorName      = pDriverInfo6->pMonitorName;
    pTempDriverInfo6->pDefaultDataType  = pDriverInfo6->pDefaultDataType;

    if ( pDriverInfo6->pHelpFile && *pDriverInfo6->pHelpFile ) {

        pTempDriverInfo6->pHelpFile = ConvertToTrustedPath(pScratchBuffer,
                                                           pDriverInfo6->pHelpFile,
                                                           pDriverInfo6->cVersion);

        if ( !pTempDriverInfo6->pHelpFile )
            leave;
    }

    if ( !ConvertDependentFilesToTrustedPath(&pTempDriverInfo6->pDependentFiles,
                                             pDriverInfo6->pDependentFiles,
                                             pDriverInfo6->cVersion) )
        leave;

    if ( dwLevel == 3 )
        goto Call;

    SPLASSERT(dwLevel == 4 || dwLevel == 6);

    pTempDriverInfo6->pszzPreviousNames = pDriverInfo6->pszzPreviousNames;

Call:
    //
    //  At this point dwInstallPolicy will always be SERVER_INF_INSTALL
    //  as this is hardcoded in the GetPolicy() call.
    //  This will always be executed in the current GetPolicy() implementation
    //
    //  If this is only a server install or we're doing a server install first.
    //
    if( dwInstallPolicy & SERVER_INSTALL_ONLY || dwInstallPolicy & SERVER_INF_INSTALL )
    {
        //
        // SplAddPrinterDriverEx will do the copying of the Driver files if the
        // date and time are newer than the drivers it already has
        //
        bReturnValue =  SplAddPrinterDriverEx( NULL,
                                               dwLevel,
                                               pTempDriverInfo,
                                               APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                               pSpool->hIniSpooler,
                                               DO_NOT_USE_SCRATCH_DIR,
                                               ReadImpersonateOnCreate() );

        if (!bReturnValue && dwLevel == 6 && GetLastError() == ERROR_INVALID_LEVEL)
        {
            //
            // If a call with level 6 failed, then try with level 4
            //
            bReturnValue = SplAddPrinterDriverEx( NULL,
                                                  4,
                                                  pDriverInfo,
                                                  APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                  pSpool->hIniSpooler,
                                                  DO_NOT_USE_SCRATCH_DIR,
                                                  ReadImpersonateOnCreate() );
        }
    }

    //
    //  dwInstallPolicy will be SERVER_INF_INSTALL at this point due to the
    //  current implementation of GetPolicy().  The below code will only be
    //  executed if the SplAddPrinterDriverEx calls above failed.
    //
    //  Do this only if we haven't tried a previous install or the previous attempt failed.
    //  Policy:  If this is an INF install only,
    //           or we're doing and INF install first,
    //           or the INF install is happening after the server install.
    //
    if( !bReturnValue && (ERROR_PRINTER_DRIVER_BLOCKED != GetLastError()) && !(dwInstallPolicy & SERVER_INSTALL_ONLY) ) {

        LPDRIVER_INFO_2 pDriverInfo2 = (LPDRIVER_INFO_2)pDriverInfo;
        LPDRIVER_INFO_1 pDriverInfo1 = (LPDRIVER_INFO_1)pDriverInfo;

        //
        // Set up the info structures first... (assume if info2 is valid, info1 is too)
        //
        if( pDriverInfo2 ) {
            //
            // Paranoid code.  We should never receive a call with a level
            // one, but if we did, the driver info struct for level 1 is
            // different to that in a level 2, so we could AV if we don't
            // treat them differently.
            //
            bReturnValue = AddDriverFromLocalCab( dwLevel == 1 ? pDriverInfo1->pName : pDriverInfo2->pName,
                                                  pSpool->hIniSpooler );
        }
        else if( dwInstallPolicy & INF_INSTALL_ONLY ) {
            //
            //  If this isn't an inf only install, then we should not overwrite the
            //  last error that will occur with AddPrinterDriver calls.
            //  If this install was only an inf install, pDriverInfo2 was NULL
            //  so we need to set some last error for this install.
            //
            SetLastError( ERROR_INVALID_PARAMETER );
        }
    }

    //
    //  Due to the current implemenation of GetPolicy() the below section
    //  of code will never be executed.  If the GetPolicy() call changes from
    //  being hardcoded into something actually policy driven, then could be used.
    //
    //  If the inf install is followed by a server install.
    //  Do this only if the previous install has failed.
    //
    if( !bReturnValue && dwInstallPolicy & INF_SERVER_INSTALL )
    {
        //
        // SplAddPrinterDriverEx will do the copying of the Driver files if the
        // date and time are newer than the drivers it already has
        //
        bReturnValue =  SplAddPrinterDriverEx( NULL,
                                               dwLevel,
                                               pTempDriverInfo,
                                               APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                               pSpool->hIniSpooler,
                                               DO_NOT_USE_SCRATCH_DIR,
                                               ReadImpersonateOnCreate() );

        if (!bReturnValue && dwLevel == 6 && GetLastError() == ERROR_INVALID_LEVEL)
        {
            //
            // If a call with level 6 failed, then try with level 4
            //
            bReturnValue = SplAddPrinterDriverEx( NULL,
                                                  4,
                                                  pDriverInfo,
                                                  APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                  pSpool->hIniSpooler,
                                                  DO_NOT_USE_SCRATCH_DIR,
                                                  ReadImpersonateOnCreate() );
        }
    }

 } finally {

    FreeSplMem( pScratchBuffer );

    if ( pTempDriverInfo != NULL ) {

        FreeSplStr(pTempDriverInfo6->pDriverPath);
        FreeSplStr(pTempDriverInfo6->pConfigFile);
        FreeSplStr(pTempDriverInfo6->pDataFile);
        FreeSplStr(pTempDriverInfo6->pDependentFiles);

        FreeSplMem(pTempDriverInfo);
    }

 }

    return bReturnValue;

}




VOID
QueryTrustedDriverInformation(
    VOID
    )
{
    DWORD dwRet;
    DWORD cbData;
    DWORD dwType = 0;
    HKEY hKey;

    //
    // There was a migration of printer connections cache from System
    // to sftware. The Servers key and the AddPrinterDrivers values
    // remain at the old location, though.
    //
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldLocationOfServersKey,
                                0, KEY_ALL_ACCESS, &hKey);
    if (dwRet != ERROR_SUCCESS) {
        return;
    }

    cbData = sizeof(DWORD);
    dwRet = RegQueryValueEx(hKey, L"LoadTrustedDrivers", NULL, &dwType, (LPBYTE)&dwLoadTrustedDrivers, &cbData);

    if (dwRet != ERROR_SUCCESS) {
        dwLoadTrustedDrivers = 0;
    }

    //
    //  By Default we don't wait for the RemoteOpenPrinter to succeed if we have a cache ( Connection )
    //  Users might want to have Syncronous opens
    //
    cbData = sizeof(DWORD);
    dwRet = RegQueryValueEx(hKey, L"SyncOpenPrinter", NULL, &dwType, (LPBYTE)&dwSyncOpenPrinter, &cbData);

    if (dwRet != ERROR_SUCCESS) {
        dwSyncOpenPrinter = 0;
    }

    //
    // if  !dwLoadedTrustedDrivers then just return
    // we won't be using the driver path at all
    //
    if (!dwLoadTrustedDrivers) {
        DBGMSG(DBG_TRACE, ("dwLoadTrustedDrivers is %d\n", dwLoadTrustedDrivers));
        RegCloseKey(hKey);
        return;
    }

    cbData = sizeof(TrustedDriverPath);
    dwRet = RegQueryValueEx(hKey, L"TrustedDriverPath", NULL, &dwType, (LPBYTE)TrustedDriverPath, &cbData);
    if (dwRet != ERROR_SUCCESS) {
      dwLoadTrustedDrivers = 0;
      DBGMSG(DBG_TRACE, ("dwLoadTrustedDrivers is %d\n", dwLoadTrustedDrivers));
      RegCloseKey(hKey);
      return;
    }
    DBGMSG(DBG_TRACE, ("dwLoadTrustedDrivers is %d\n", dwLoadTrustedDrivers));
    DBGMSG(DBG_TRACE, ("TrustedPath is %ws\n", TrustedDriverPath));
    RegCloseKey(hKey);
    return;
}

BOOL
IsTrustedPathConfigured(
    IN VOID
    )
{
    return !!dwLoadTrustedDrivers; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\cache.c ===
/*++

Copyright (c) 1994 - 2000  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module contains all the Cache Printer Connection for
    true Connected Printers.

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsprlp.h>
#include <dsgetdc.h>
#include <lm.h>

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <offsets.h>
#include <w32types.h>
#include <splcom.h>
#include <local.h>
#include <search.h>
#include <splapip.h>
#include <winerror.h>
#include <gdispool.h>
#include <messages.h>

PWCHAR pszRaw                = L"RAW";
PWCHAR szWin32SplDirectory   = L"\\spool";
WCHAR  szRegistryWin32Root[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Providers\\LanMan Print Services\\Servers";
WCHAR  szOldLocationOfServersKey[] = L"System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers";
WCHAR  szPrinters[]          = L"\\Printers";
PWCHAR pszRegistryMonitors   = L"\\System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Monitors";
PWCHAR pszRegistryEnvironments = L"System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Environments";
PWCHAR pszRegistryEventLog   = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\Print";
PWCHAR pszRegistryProviders  = L"Providers";
PWCHAR pszEventLogMsgFile    = L"%SystemRoot%\\System32\\Win32Spl.dll";
PWCHAR pszDriversShareName   = L"wn32prt$";
WCHAR szForms[]              = L"\\Forms";
PWCHAR pszMyDllName          = L"win32spl.dll";
PWCHAR pszMonitorName        = L"LanMan Print Services Port";

const WCHAR gszPointAndPrintPolicies[] = L"Software\\Policies\\Microsoft\\Windows NT\\Printers\\PointAndPrint";
const WCHAR gszPointAndPrintRestricted[] = L"Restricted";
const WCHAR gszPointAndPrintInForest[] = L"InForest";
const WCHAR gszPointAndPrintTrustedServers[] = L"TrustedServers";
const WCHAR gszPointAndPrintServerList[] = L"ServerList";

PWSPOOL pFirstWSpool = NULL;

WCHAR *szCachePrinterInfo2   = L"CachePrinterInfo2";
WCHAR *szCacheTimeLastChange = L"CacheChangeID";
WCHAR *szServerVersion       = L"ServerVersion";
WCHAR *szcRef                = L"CacheReferenceCount";

WCHAR CacheTimeoutString[]   = L"CacheTimeout";

DWORD CacheTimeout           = 0;

//
// If we have an rpc handle created recently don't hit the net
//
#define     REFRESH_TIMEOUT     15000        // 15 seconds
#define     CACHE_TIMEOUT       5000        // Default to 5 seconds.


VOID
RefreshDriverEvent(
    PWSPOOL pSpool
)
/*++

Routine Description:

    Call out to the Printer Driver UI DLL to allow it to do any caching it might want to do.
    For example there might be a large FONT metric file on the print server which is too large
    to be written to the registry using SetPrinterData().   This callout will allow the printer
    driver to copy this font file to the workstation when the cache is established and will
    allow it to periodically check that the file is still valid.

Arguments:

    pSpool - Handle to remote printer.

Return Value:

    None

--*/
{

    SplOutSem();

    SplDriverEvent( pSpool->pName, PRINTER_EVENT_CACHE_REFRESH, (LPARAM)NULL );


}


/*++

 -- GetCacheTimeout --

Routine Description:

    Read the registry to see if anyone has changed the Timeout on the Cache. Default
    to CACHE_TIMEOUT if not.

Arguments:

    None

Return Value:

    Cache Timeout in Milliseconds.

--*/

DWORD GetCacheTimeout(
    VOID
)
{
    DWORD   Value = CACHE_TIMEOUT;
    DWORD   RegValue = 0;
    DWORD   RegValueSize = sizeof(RegValue);
    HKEY    RegKey = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;

    //
    // This will only read the timeout from the registry once, after that, it will use
    // the stored value. This is not ideal and could be fixed to be per-server,
    // depending on the connection speed to the server.
    //

    if ( CacheTimeout )
    {
        Value = CacheTimeout;
    }
    else
    {
        dwReturn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 szRegistryWin32Root,
                                 0,
                                 KEY_READ,
                                 &RegKey );

        if (dwReturn == ERROR_SUCCESS)
        {
            dwReturn = RegQueryValueEx( RegKey,
                                        CacheTimeoutString,
                                        NULL,
                                        NULL,
                                        (LPBYTE) &RegValue,
                                        &RegValueSize );

            if ( dwReturn == ERROR_SUCCESS )
            {
                Value = RegValue;
            }

            dwReturn = RegCloseKey( RegKey );
        }

        CacheTimeout = Value;
    }

    return Value;
}

HANDLE
CacheCreateSpooler(
    LPWSTR  pMachineName,
    BOOL    bOpenOnly
)
{
    PWCHAR pScratch = NULL;
    PWCHAR pRegistryRoot = NULL;
    PWCHAR pRegistryPrinters = NULL;
    SPOOLER_INFO_1 SpoolInfo1;
    HANDLE  hIniSpooler = INVALID_HANDLE_VALUE;
    PWCHAR pMachineOneSlash;
    MONITOR_INFO_2 MonitorInfo;
    DWORD   dwNeeded, cb;
    DWORD   Returned;

 try {

    // get size of szRegistryWin32Root (incl NULL) + (pMachineName + 1)
    cb =    (DWORD)(sizeof szRegistryWin32Root +
            MAX(sizeof szPrinters, sizeof szForms) +
            wcslen(pMachineName + 1)*sizeof *pMachineName);

    if (!(pScratch = AllocSplMem(cb)))
        leave;

    pMachineOneSlash = pMachineName;
    pMachineOneSlash++;

    //
    //  Create a "Machine" for this Printer
    //

    SpoolInfo1.pDir = gpWin32SplDir;            // %systemroot%\system32\win32spl
    SpoolInfo1.pDefaultSpoolDir = NULL;         // Default %systemroot%\system32\win32spl\PRINTERS

    wcscpy( pScratch, szRegistryWin32Root);
    wcscat( pScratch, pMachineOneSlash  );

    if (!(pRegistryRoot = AllocSplStr( pScratch )))
        leave;

    SpoolInfo1.pszRegistryRoot = pRegistryRoot;

    wcscat( pScratch, szPrinters );

    if (!(pRegistryPrinters = AllocSplStr( pScratch )))
        leave;

    SpoolInfo1.pszRegistryPrinters     = pRegistryPrinters;
    SpoolInfo1.pszRegistryMonitors     = pszRegistryMonitors;
    SpoolInfo1.pszRegistryEnvironments = pszRegistryEnvironments;
    SpoolInfo1.pszRegistryEventLog     = pszRegistryEventLog;
    SpoolInfo1.pszRegistryProviders    = pszRegistryProviders;
    SpoolInfo1.pszEventLogMsgFile      = pszEventLogMsgFile;
    SpoolInfo1.pszDriversShare         = pszDriversShareName;

    wcscpy( pScratch, szRegistryWin32Root);
    wcscat( pScratch, pMachineOneSlash );
    wcscat( pScratch, szForms );

    SpoolInfo1.pszRegistryForms = pScratch;

    // The router graciously does the WIN.INI devices update so let have
    // Spl not also create a printer for us.

    //
    // CLS
    //
    SpoolInfo1.SpoolerFlags          = SPL_BROADCAST_CHANGE |
                                       SPL_TYPE_CACHE |
                                       (bOpenOnly ? SPL_OPEN_EXISTING_ONLY : 0);

    SpoolInfo1.pfnReadRegistryExtra  = (FARPROC) &CacheReadRegistryExtra;
    SpoolInfo1.pfnWriteRegistryExtra = (FARPROC) &CacheWriteRegistryExtra;
    SpoolInfo1.pfnFreePrinterExtra   = (FARPROC) &CacheFreeExtraData;

    SplOutSem();

    hIniSpooler = SplCreateSpooler( pMachineName,
                                    1,
                                    (PBYTE)&SpoolInfo1,
                                    NULL );

    //
    // CLS
    //
    if ( hIniSpooler == INVALID_HANDLE_VALUE ) {

        if (!bOpenOnly)
        {
            SetLastError( ERROR_INVALID_PRINTER_NAME );
        }

    } else {

        // Add WIN32SPL.DLL as the Monitor

        MonitorInfo.pName = pszMonitorName;
        MonitorInfo.pEnvironment = szEnvironment;
        MonitorInfo.pDLLName = pszMyDllName;

        if ( (!SplAddMonitor( NULL, 2, (LPBYTE)&MonitorInfo, hIniSpooler)) &&
             ( GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED ) ) {

            DBGMSG( DBG_WARNING, ("CacheCreateSpooler failed SplAddMonitor %d\n", GetLastError()));

            SplCloseSpooler( hIniSpooler );

            hIniSpooler = INVALID_HANDLE_VALUE;

        }
    }

 } finally {

    FreeSplStr ( pScratch );
    FreeSplStr ( pRegistryRoot );
    FreeSplStr ( pRegistryPrinters );

 }

    return hIniSpooler;

}

VOID
RefreshCompletePrinterCache(
    IN      PWSPOOL         pSpool,
    IN      EDriverDownload eDriverDownload
    )
    {

    DBGMSG( DBG_TRACE, ("RefreshCompletePrinterCache %x\n", pSpool));

    if (eDriverDownload == kCheckPnPPolicy)
    {
        BOOL        bAllowPointAndPrint = FALSE;

        if (BoolFromHResult(DoesPolicyAllowPrinterConnectionsToServer(pSpool->pName, &bAllowPointAndPrint)) &&
            bAllowPointAndPrint)
        {
             eDriverDownload = kDownloadDriver;
        }
        else
        {
             eDriverDownload = kDontDownloadDriver;
        }
    }

    //
    // Note the order is important.
    // Refreshing the printer might require that the new driver has
    // been installed on the system. If policy doesn't allow us to
    // fetch the driver, you are just out of luck.
    //
    RefreshPrinterDriver(pSpool, NULL, eDriverDownload);
    RefreshFormsCache( pSpool );
    RefreshPrinterDataCache(pSpool);
    RefreshPrinterCopyFiles(pSpool);
    RefreshDriverEvent( pSpool );
    SplBroadcastChange(pSpool->hSplPrinter, WM_DEVMODECHANGE, 0, (LPARAM) pSpool->pName);
}


PPRINTER_INFO_2
GetRemotePrinterInfo(
    PWSPOOL pSpool,
    LPDWORD pReturnCount
)
{
    PPRINTER_INFO_2 pRemoteInfo = NULL;
    HANDLE  hPrinter = (HANDLE) pSpool;
    DWORD   cbRemoteInfo = 0;
    DWORD   dwBytesNeeded = 0;
    DWORD   dwLastError = 0;
    BOOL    bReturnValue = FALSE;

    *pReturnCount = 0;

    do {

        if ( pRemoteInfo != NULL ) {

            FreeSplMem( pRemoteInfo );
            pRemoteInfo = NULL;
            cbRemoteInfo = 0;
        }

        if ( dwBytesNeeded != 0 ) {

            pRemoteInfo = AllocSplMem( dwBytesNeeded );

            if ( pRemoteInfo == NULL )
                break;
        }

        cbRemoteInfo = dwBytesNeeded;

        bReturnValue = RemoteGetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pRemoteInfo,
                                         cbRemoteInfo,
                                         &dwBytesNeeded );

        dwLastError = GetLastError();

    } while ( !bReturnValue && dwLastError == ERROR_INSUFFICIENT_BUFFER );

    if ( !bReturnValue && pRemoteInfo != NULL ) {

        FreeSplMem( pRemoteInfo );
        pRemoteInfo = NULL;
        cbRemoteInfo = 0;

    }

    *pReturnCount = cbRemoteInfo;

    return pRemoteInfo;
}



//
//  This routine Clones the Printer_Info_2 structure from the Remote machine
//
//


PWCACHEINIPRINTEREXTRA
AllocExtraData(
    PPRINTER_INFO_2W pPrinterInfo2,
    DWORD cbPrinterInfo2
)
{
    PWCACHEINIPRINTEREXTRA  pExtraData = NULL;
    DWORD    cbSize;

    SPLASSERT( cbPrinterInfo2 != 0);
    SPLASSERT( pPrinterInfo2 != NULL );

    cbSize = sizeof( WCACHEINIPRINTEREXTRA );

    pExtraData = AllocSplMem( cbSize );

    if ( pExtraData != NULL ) {

        pExtraData->signature = WCIP_SIGNATURE;
        pExtraData->cb = cbSize;
        pExtraData->cRef = 0;
        pExtraData->cbPI2 = cbPrinterInfo2;
        pExtraData->dwTickCount  = GetTickCount();
        pExtraData->pPI2 = AllocSplMem( cbPrinterInfo2 );

        if ( pExtraData->pPI2 != NULL ) {

            CacheCopyPrinterInfo( pExtraData->pPI2, pPrinterInfo2, cbPrinterInfo2 );

        } else {

            FreeSplMem( pExtraData );
            pExtraData = NULL;

        }

    }

    return pExtraData;

}


VOID
CacheFreeExtraData(
    PWCACHEINIPRINTEREXTRA pExtraData
)
{
    PWCACHEINIPRINTEREXTRA pPrev = NULL;
    PWCACHEINIPRINTEREXTRA pCur  = NULL;

    if ( pExtraData != NULL ) {

        SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

        if ( pExtraData->cRef != 0 ) {

            DBGMSG( DBG_TRACE, ("CacheFreeExtraData pExtraData %x cRef %d != 0 freeing anyway\n",
                                  pExtraData,
                                  pExtraData->cRef ));
        }

        if ( pExtraData->pPI2 != NULL ) {

            FreeSplMem( pExtraData->pPI2 );
        }

        FreeSplMem( pExtraData );

    }

}

VOID
DownAndMarshallUpStructure(
   LPBYTE       lpStructure,
   LPBYTE       lpSource,
   LPDWORD      lpOffsets
)
{
   register DWORD       i=0;

   while (lpOffsets[i] != -1) {

      if ((*(LPBYTE *)(lpStructure+lpOffsets[i]))) {
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))-=(UINT_PTR)lpSource;
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))+=(UINT_PTR)lpStructure;
      }

      i++;
   }
}


VOID
CacheCopyPrinterInfo(
    PPRINTER_INFO_2W    pDestination,
    PPRINTER_INFO_2W    pPrinterInfo2,
    DWORD   cbPrinterInfo2
)
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings = SourceStrings;

    //
    //  Copy the lot then fix up the pointers
    //

    CopyMemory( pDestination, pPrinterInfo2, cbPrinterInfo2 );
    DownAndMarshallUpStructure( (LPBYTE)pDestination, (LPBYTE)pPrinterInfo2, PrinterInfo2Offsets );
}



VOID
ConvertRemoteInfoToLocalInfo(
    PPRINTER_INFO_2 pPrinterInfo2
)
{

    SPLASSERT( pPrinterInfo2 != NULL );

    DBGMSG(DBG_TRACE,("%ws %ws ShareName %x %ws pSecurityDesc %x Attributes %x StartTime %d UntilTime %d Status %x\n",
                       pPrinterInfo2->pServerName,
                       pPrinterInfo2->pPrinterName,
                       pPrinterInfo2->pShareName,
                       pPrinterInfo2->pPortName,
                       pPrinterInfo2->pSecurityDescriptor,
                       pPrinterInfo2->Attributes,
                       pPrinterInfo2->StartTime,
                       pPrinterInfo2->UntilTime,
                       pPrinterInfo2->Status));

    //
    //  GetPrinter returns the name \\server\printername we only want the printer name
    //

    pPrinterInfo2->pPrinterName = wcschr( pPrinterInfo2->pPrinterName + 2, L'\\' );
    if( !pPrinterInfo2->pPrinterName ){
        SPLASSERT( FALSE );
        pPrinterInfo2->pPrinterName = pPrinterInfo2->pPrinterName;
    } else {
        pPrinterInfo2->pPrinterName++;
    }

    //
    //  LATER this should be a Win32Spl Port
    //

    pPrinterInfo2->pPortName = L"NExx:";
    pPrinterInfo2->pSepFile = NULL;
    pPrinterInfo2->pSecurityDescriptor = NULL;
    pPrinterInfo2->pPrintProcessor = L"winprint";
    pPrinterInfo2->pDatatype = pszRaw;
    pPrinterInfo2->pParameters = NULL;

    pPrinterInfo2->Attributes &= ~( PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_DIRECT | PRINTER_ATTRIBUTE_SHARED );

    pPrinterInfo2->StartTime = 0;
    pPrinterInfo2->UntilTime = 0;

    //
    // ConvertRemoteInfoToLocalInfo is called once before an SplAddPrinter
    // and once before an SplSetPrinter, both level 2. Neither SplAddPrinter, nor
    // SplSetPrinter look at the Status field in the printer info. So the
    // value below is artificial. We just give it an initial state.
    //
    pPrinterInfo2->Status = 0;
    pPrinterInfo2->cJobs = 0;
    pPrinterInfo2->AveragePPM = 0;

}



VOID
RefreshPrinter(
    PWSPOOL pSpool
)
{

    PPRINTER_INFO_2 pRemoteInfo = NULL;
    DWORD   cbRemoteInfo = 0;
    BOOL    ReturnValue;
    PWCACHEINIPRINTEREXTRA pExtraData       = NULL;
    PWCACHEINIPRINTEREXTRA pNewExtraData    = NULL;
    PPRINTER_INFO_2 pTempPI2                = NULL;
    PPRINTER_INFO_2 pCopyExtraPI2ToFree     = NULL;
    DWORD   dwLastError;

    //
    //  Get the Remote Printer Info
    //
    pRemoteInfo = GetRemotePrinterInfo( pSpool, &cbRemoteInfo );

    if ( pRemoteInfo != NULL ) {

        //  LATER
        //          Optimization could be to only update the cache if something
        //          actually changed.
        //          IE Compare every field.

       EnterSplSem();

        ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

        if ( ReturnValue == FALSE ) {

            DBGMSG( DBG_WARNING, ("RefreshPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
            SPLASSERT( ReturnValue );

        }

        if ( pExtraData == NULL ) {

            pExtraData = AllocExtraData( pRemoteInfo, cbRemoteInfo );

            if ( pExtraData != NULL ) {

                pExtraData->cRef++;

            }

        } else {

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            pTempPI2 = AllocSplMem( cbRemoteInfo );

            if ( pTempPI2 != NULL ) {

                SplInSem();

                CacheCopyPrinterInfo( pTempPI2, pRemoteInfo, cbRemoteInfo );

                pCopyExtraPI2ToFree = pExtraData->pPI2;

                pExtraData->pPI2  = pTempPI2;
                pExtraData->cbPI2 = cbRemoteInfo;

            }

        }

       LeaveSplSem();

        if ( pExtraData != NULL ) {
            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );
        }

        ConvertRemoteInfoToLocalInfo( pRemoteInfo );

        ReturnValue = SplSetPrinter( pSpool->hSplPrinter, 2, (LPBYTE)pRemoteInfo, 0 );

        if ( !ReturnValue ) {

            //
            // If the driver is blocked and the driver has changed, we want to log
            // an event.
            //
            dwLastError = GetLastError();

            if (ERROR_KM_DRIVER_BLOCKED == dwLastError &&
                pCopyExtraPI2ToFree                       &&
                pCopyExtraPI2ToFree->pDriverName          &&
                pRemoteInfo->pDriverName                  &&
                _wcsicmp(pCopyExtraPI2ToFree->pDriverName, pRemoteInfo->pDriverName)) {

                //
                // We have entered a mismatched case through someone admin'ing a
                // remote server. Log an error message, we cannot throw UI at this
                // point.
                //
                SplLogEventExternal(LOG_ERROR,
                                    MSG_DRIVER_MISMATCHED_WITH_SERVER,
                                    pSpool->pName,
                                    pRemoteInfo->pDriverName,
                                    NULL);
            }
            else if(dwLastError == ERROR_UNKNOWN_PRINTER_DRIVER)
            {
                if (ReturnValue = AddDriverFromLocalCab(pRemoteInfo->pDriverName, pSpool->hIniSpooler))
                {
                    ReturnValue = SplSetPrinter(pSpool->hSplPrinter, 2, (LPBYTE)pRemoteInfo, 0);
                }
            }

            DBGMSG( DBG_WARNING, ("RefreshPrinter Failed SplSetPrinter %d\n", GetLastError() ));
        }

        ReturnValue = SplSetPrinterExtra( pSpool->hSplPrinter, (LPBYTE)pExtraData );

        if (!ReturnValue) {

            DBGMSG(DBG_ERROR, ("RefreshPrinter SplSetPrinterExtra failed %x\n", GetLastError()));
        }

    } else {

        DBGMSG( DBG_WARNING, ("RefreshPrinter failed GetRemotePrinterInfo %x\n", GetLastError() ));
    }

    if ( pRemoteInfo != NULL )
        FreeSplMem( pRemoteInfo );

    if (pCopyExtraPI2ToFree != NULL) {

        FreeSplMem(pCopyExtraPI2ToFree);
    }
}

VOID
RefreshPrinterInfo7(
    PWSPOOL pSpool
)
{
    PPRINTER_INFO_7 pInfo = NULL;
    DWORD   cbNeeded = 0;
    BOOL    bRet;


    bRet = RemoteGetPrinter((HANDLE) pSpool, 7, (PBYTE) pInfo, 0, &cbNeeded);

    if (bRet) {
        DBGMSG( DBG_ERROR, ("RefreshPrinterInfo7 Illegally succeeded RemoteGetPrinter %d\n"));
        goto done;
    } else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteGetPrinter %d\n", GetLastError()));
        goto done;
    }

    if (!(pInfo = (PPRINTER_INFO_7) AllocSplMem(cbNeeded))) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteGetPrinter %d\n", GetLastError()));
        goto done;
    }

    if (!RemoteGetPrinter((HANDLE) pSpool, 7, (PBYTE) pInfo, cbNeeded, &cbNeeded)) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteGetPrinter %d\n", GetLastError()));
        goto done;
    }

    if (!SplSetPrinter( pSpool->hSplPrinter, 7, (PBYTE) pInfo, 0)) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteSetPrinter %d\n", GetLastError()));
        goto done;
    }

done:

    FreeSplMem(pInfo);
}


//
// TESTING
//
DWORD dwAddPrinterConnection = 0;

PWSPOOL
InternalAddPrinterConnection(
    LPWSTR   pName
)

/*++

Function Description: InternalAddPrinterConnection creates a printer connection.

Parameters: pName - name of the printer connection

Return Values: pSpool if successful;
               NULL otherwise

--*/

{
    PWSPOOL pSpool = NULL;
    BOOL    bReturnValue = FALSE;
    HANDLE  hIniSpooler = INVALID_HANDLE_VALUE;
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    DWORD   cbPrinterInfo2 = 0;
    HANDLE  hSplPrinter = INVALID_HANDLE_VALUE;
    PWCACHEINIPRINTEREXTRA pExtraData  = NULL;
    PWCACHEINIPRINTEREXTRA pExtraData2 = NULL;
    BOOL    bSuccess = FALSE;
    LPPRINTER_INFO_STRESSW pPrinter0 = NULL;
    DWORD   dwNeeded;
    DWORD   LastError = ERROR_SUCCESS;
    BOOL    bLoopDetected = FALSE;
    BOOL    bAllowPointAndPrint = FALSE;
    BOOL    bAllowDriverDownload  = FALSE;


//
// TESTING
//
    ++dwAddPrinterConnection;

  try {

    if (!VALIDATE_NAME(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        leave;
    }

    if (!RemoteOpenPrinter(pName, &pSpool, NULL, DO_NOT_CALL_LM_OPEN)) {
        leave;
    }

    pPrinter0 = AllocSplMem( MAX_PRINTER_INFO0 );
    if ( pPrinter0 == NULL )
        leave;

    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->Type == SJ_WIN32HANDLE );

    DBGMSG( DBG_TRACE, ("AddPrinterConnection pName %ws pSpool %x\n",pName, pSpool ));

    //
    //  Get Remote ChangeID to be certain nothing changes on the Server
    //  whilst we are establishing our Cache.
    //

    bReturnValue = RemoteGetPrinter( pSpool, STRESSINFOLEVEL, (LPBYTE)pPrinter0, MAX_PRINTER_INFO0, &dwNeeded );

    if ( !bReturnValue ) {

        SPLASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
        DBGMSG(DBG_TRACE, ("AddPrinterConnection failed RemoteGetPrinter %d\n", GetLastError()));
        pPrinter0->cChangeID = 0;
    }

    DBGMSG( DBG_TRACE, ("AddPrinterConnection << Server cCacheID %x >>\n", pPrinter0->cChangeID ));

    //
    //  See If the Printer is already in the Cache
    //

APC_OpenCache:

    bReturnValue = OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, NULL, FALSE);


    if ( hIniSpooler == INVALID_HANDLE_VALUE ) {

        DBGMSG( DBG_WARNING, ("AddPrinterConnection - CacheCreateSpooler Failed %x\n",GetLastError()));
        leave;
    }

    pSpool->hIniSpooler = hIniSpooler;

    if ( bReturnValue ) {

        //
        //  Printer Exists in Cache
        //
        DBGMSG( DBG_TRACE,("AddPrinterConnection hIniSpooler %x hSplPrinter%x\n", hIniSpooler, hSplPrinter) );


        pSpool->hSplPrinter = hSplPrinter;
        pSpool->Status |= WSPOOL_STATUS_USE_CACHE;

        //
        //  Update Connection Reference Count
        //

       EnterSplSem();


        bReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

        if ( bReturnValue == FALSE ) {

            DBGMSG( DBG_WARNING, ("AddPrinterConnection SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
            SPLASSERT( bReturnValue );

        }

        if ( pExtraData != NULL ) {

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );
            pExtraData->cRef++;

        }

       LeaveSplSem();

        // Make Sure Reference Count Gets Updated in Registry

        if ( !SplSetPrinterExtra( hSplPrinter, (LPBYTE)pExtraData ) ) {
            DBGMSG( DBG_ERROR, ("AddPrinterConnection SplSetPrinterExtra failed %x\n", GetLastError() ));
        }

        //  Refresh Cache
        //  It could be that the remote machine is old NT Daytona 3.5 or before
        //  which doesn't support the ChangeID, that would mean the only
        //  way for a user to force an update is to do a connection.

        if ( pPrinter0->cChangeID == 0 ) {

            // Old NT

            RefreshCompletePrinterCache(pSpool, kCheckPnPPolicy);

        } else {

            //
            // Since we have this in the cache anyway, we might as well sync
            // settings, we only sync settings if we are allowed to download
            // the driver.
            //
            ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
        }

        pExtraData = NULL;

        bSuccess = TRUE;
        leave;

    } else if ( GetLastError() != ERROR_INVALID_PRINTER_NAME &&
                GetLastError() != ERROR_INVALID_NAME ) {

        DBGMSG( DBG_WARNING, ("AddPrinterConnection failed OpenCachePrinterOnly %d\n", GetLastError() ));
        leave;

    }

    //
    //  There is NO Cache Entry for This Printer
    //
    DBGMSG( DBG_TRACE, ("AddPrinterConnection failed SplOpenPrinter %ws %d\n", pName, GetLastError() ));

    //
    //  Get PRINTER Info from Remote Machine
    //

    pPrinterInfo2 = GetRemotePrinterInfo( pSpool, &cbPrinterInfo2 );

    if ( pPrinterInfo2 == NULL ) {
        DBGMSG( DBG_WARNING, ("AddPrinterConnection failed GetRemotePrinterInfo %x\n", GetLastError() ));
        leave;
    }

    if (BoolFromHResult(DoesPolicyAllowPrinterConnectionsToServer(pSpool->pName, &bAllowPointAndPrint)) &&
        bAllowPointAndPrint)
    {
        bAllowDriverDownload = TRUE;
    }

    if (!RefreshPrinterDriver( pSpool, pPrinterInfo2->pDriverName, bAllowDriverDownload ? kDownloadDriver : kDontDownloadDriver) && (ERROR_PRINTER_DRIVER_BLOCKED == GetLastError()))
    {
        leave;
    }

    //
    //  Allocate My Extra Data for this Printer
    //  ( from RemoteGetPrinter )
    //  We need a pExtraData2 - if this is blocked by KM blocking we need to have a copy to
    //  retry the install.
    //

    pExtraData = AllocExtraData( pPrinterInfo2, cbPrinterInfo2 );

    if ( pExtraData == NULL )
        leave;

    pExtraData2 = AllocExtraData( pPrinterInfo2, cbPrinterInfo2 );

    if ( pExtraData2 == NULL )
        leave;

    pExtraData->cRef++;
    pExtraData2->cRef++;

    pExtraData2->cCacheID = pExtraData->cCacheID = pPrinter0->cChangeID;
    pExtraData2->dwServerVersion = pExtraData->dwServerVersion = pPrinter0->dwGetVersion;

    //
    //  Convert Remote Printer_Info_2 to Local Version for Cache
    //

    ConvertRemoteInfoToLocalInfo( pPrinterInfo2 );

    //
    //  Add Printer to Cache
    //

    hSplPrinter = SplAddPrinter(NULL, 2, (LPBYTE)pPrinterInfo2,
                                hIniSpooler, (LPBYTE)pExtraData,
                                NULL, 0);

    pExtraData = NULL;

    if ( (hSplPrinter == NULL || hSplPrinter == INVALID_HANDLE_VALUE) &&
         GetLastError() == ERROR_KM_DRIVER_BLOCKED                        ) {

        //
        // Failed due to KM Blocking
        //     - lets try add a driver from the local cab as this should fix this.
        //
        if( !AddDriverFromLocalCab( pPrinterInfo2->pDriverName, hIniSpooler ) ) {
            //
            // Set the old last error back as we don't really care that this failed.
            //
            SetLastError( ERROR_KM_DRIVER_BLOCKED );
        } else {

           hSplPrinter = SplAddPrinter(NULL, 2, (LPBYTE)pPrinterInfo2,
                                       hIniSpooler, (LPBYTE)pExtraData2,
                                       NULL, 0);
           pExtraData2 = NULL;
        }
    }

    if ( hSplPrinter == NULL ||
         hSplPrinter == INVALID_HANDLE_VALUE ) {

        LastError = GetLastError();

        if ( LastError == ERROR_PRINTER_ALREADY_EXISTS ) {

            SplCloseSpooler( pSpool->hIniSpooler );
            hIniSpooler = INVALID_HANDLE_VALUE;

            if ( bLoopDetected == FALSE ) {

                bLoopDetected = TRUE;
                goto    APC_OpenCache;

            } else {

                DBGMSG( DBG_WARNING, ("AddPrinterConnection APC_OpenCache Loop Detected << Should Never Happen >>\n"));
                leave;
            }
        }
        //
        // If we could not add the printer, and it wasn't because it is already
        // there, and we weren't able to download the driver because of policy,
        // then we need to return an appropriate error code so that the UI can
        // inform the user about it.
        //
        else if (!bAllowDriverDownload && LastError == ERROR_UNKNOWN_PRINTER_DRIVER)
        {
            LastError = ERROR_ACCESS_DISABLED_BY_POLICY;
        }

        // If we failed to Create the printer above, we should NOT be able to Open it now.

        DBGMSG( DBG_WARNING, ("AddPrinterConnection Failed SplAddPrinter error %d\n", LastError ));

        hSplPrinter = INVALID_HANDLE_VALUE;
        bSuccess    = FALSE;
        leave;

    }

    DBGMSG( DBG_TRACE, ("AddPrinterConnection SplAddPrinter SUCCESS hSplPrinter %x\n", hSplPrinter));

    pSpool->hSplPrinter = hSplPrinter;
    pSpool->Status |= WSPOOL_STATUS_USE_CACHE;

    RefreshFormsCache(pSpool);
    RefreshPrinterDataCache(pSpool);
    RefreshPrinterCopyFiles(pSpool);
    RefreshDriverEvent(pSpool);

    //
    // Just In Case something change whilst we were initializing the cache
    // go check it again now. Don't check policy again since we have recently
    // verified that we can comunicate with this server.
    //
    ConsistencyCheckCache(pSpool, bAllowDriverDownload ? kDownloadDriver : kDontDownloadDriver);

    bSuccess = TRUE;

 } finally {

    if ( !bSuccess ) {
        if ( LastError == ERROR_SUCCESS )
            LastError = GetLastError();

        InternalDeletePrinterConnection( pName, FALSE );

        if ( pSpool != NULL && pSpool != INVALID_HANDLE_VALUE ) {
            pSpool->Status &= ~WSPOOL_STATUS_TEMP_CONNECTION;
            CacheClosePrinter( pSpool );
        }

        SetLastError( LastError );
        DBGMSG( DBG_TRACE, ("AddPrinterConnection %ws Failed %d\n", pName, GetLastError() ));

        pSpool = NULL;
    }

    if ( pPrinterInfo2 != NULL )
        FreeSplMem( pPrinterInfo2 );

    if ( pPrinter0 != NULL )
        FreeSplMem( pPrinter0 );

    if ( pExtraData != NULL )
        CacheFreeExtraData( pExtraData );

    if ( pExtraData2 != NULL )
        CacheFreeExtraData( pExtraData2 );

 }

    return pSpool;
}

/*++

Function Name:

    AddPrinterConnectionPrivate

Function Description:

    AddPrinterConnectionPrivate creates a printer connection. It does
    not check to see if the printer connection already exists in the
    users registry.

Parameters:

    pName - name of the printer connection

Return Values:

    TRUE if successful;
    FALSE otherwise

--*/
BOOL
AddPrinterConnectionPrivate(
    LPWSTR pName
)
{
    PWSPOOL  pSpool;
    BOOL    bReturn;

    pSpool = InternalAddPrinterConnection(pName);

    if (pSpool != NULL)
    {
        //
        // We have a valid handle. The connection has been created. Succeed after
        // closing the handle
        //
        CacheClosePrinter(pSpool);
        bReturn = TRUE;
    }
    else
    {
        //
        // Failed to create the connection.
        //
        bReturn = FALSE;
    }

    return bReturn;
}

/*++

Function Name:

    AddPrinterConnection

Function Description:

    AddPrinterConnection creates a printer connection. We check to see
    whether the printer connection already exists in the user registry.
    This works because an OpenPrinter will always occur from the router
    before an AddPrinter Connection. So, this will always create a
    printer connection from the registry in CacheOpenPrinter(). If we see
    this state, we simpy return TRUE.

Parameters:

    pName - name of the printer connection

Return Values:

    TRUE if successful;
    FALSE otherwise

--*/
BOOL
AddPrinterConnection(
    LPWSTR pName
)
{
    BOOL bRet = FALSE;

    if (PrinterConnectionExists(pName))
    {
        bRet = TRUE;
    }
    else
    {
        //
        // Make sure that this call is local, otherwise a remote caller could
        // come in and trick us into connection to him and downloading the
        // driver.
        //
        bRet = IsLocalCall();

        if (bRet)
        {
            bRet = AddPrinterConnectionPrivate(pName);
        }
        else
        {
            SetLastError(ERROR_ACCESS_DENIED);
        }
    }

    return bRet;
}

//
// TESTING
//
DWORD dwRefreshFormsCache = 0;
DWORD dwNoMatch = 0;
DWORD dwDeleteForm = 0;
DWORD dwAddForm = 0;

VOID
RefreshFormsCache(
    PWSPOOL pSpool
)
/*++

Routine Description:

    This routine will check to see if any forms have changed.   If anything changed it adds
    or deletes forms from the cache so that it matches the server.

    Note it is very important that the order of the forms on the workstation matches those
    on the Server.

    Implementation:

        EnumRemoteForms
        EnumLocalForms
        If there is any difference
            Delete All LocalForms
            Add All the Remote Forms

    The code is optimized for the typical case

        Forms are added at the end only.
        Forms are hardly ever deleted.

Arguments:

    pSpool - Handle to remote printer.

Return Value:

    None

--*/

{
    PFORM_INFO_1 pRemoteForms = NULL , pSaveRemoteForms = NULL;
    PFORM_INFO_1 pLocalCacheForms = NULL,  pSaveLocalCacheForms = NULL;
    PFORM_INFO_1 pRemote = NULL, pLocal = NULL;
    DWORD   dwBuf = 0;
    DWORD   dwSplBuf = 0;
    DWORD   dwNeeded = 0;
    DWORD   dwSplNeeded = 0;
    DWORD   dwRemoteFormsReturned = 0;
    DWORD   dwSplReturned = 0;
    BOOL    bReturnValue = FALSE;
    DWORD   LastError = ERROR_INSUFFICIENT_BUFFER;
    INT     iCompRes = 0;
    DWORD   LoopCount;
    BOOL    bCacheMatchesRemoteMachine = FALSE;


    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );

    //
    //  Get Remote Machine Forms Data
    //

//
// TESTING
//
    ++dwRefreshFormsCache;

    do {

        bReturnValue = RemoteEnumForms( (HANDLE)pSpool, 1, (LPBYTE)pRemoteForms, dwBuf, &dwNeeded, &dwRemoteFormsReturned);

        if ( bReturnValue )
            break;

        LastError = GetLastError();

        if ( LastError != ERROR_INSUFFICIENT_BUFFER ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed RemoteEnumForms error %d\n", GetLastError()));
            goto RefreshFormsCacheErrorReturn;

        }

        if ( pRemoteForms != NULL )
            FreeSplMem( pRemoteForms );


        pRemoteForms = AllocSplMem( dwNeeded );
        pSaveRemoteForms = pRemoteForms;

        dwBuf = dwNeeded;

        if ( pRemoteForms == NULL ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed AllocSplMem Error %d dwNeeded %d\n", GetLastError(), dwNeeded));
            goto RefreshFormsCacheErrorReturn;

        }

    } while ( !bReturnValue && LastError == ERROR_INSUFFICIENT_BUFFER );

    if( pRemoteForms == NULL ) {

        DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed pRemoteForms == NULL\n"));
        goto RefreshFormsCacheErrorReturn;
    }




    //
    //  Get LocalCachedForms Data
    //

    do {

        bReturnValue = SplEnumForms( pSpool->hSplPrinter, 1, (LPBYTE)pLocalCacheForms, dwSplBuf, &dwSplNeeded, &dwSplReturned);

        if ( bReturnValue )
            break;

        LastError = GetLastError();

        if ( LastError != ERROR_INSUFFICIENT_BUFFER ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed SplEnumForms hSplPrinter %x error %d\n", pSpool->hSplPrinter, GetLastError()));
            goto RefreshFormsCacheErrorReturn;

        }

        if ( pLocalCacheForms != NULL )
            FreeSplMem( pLocalCacheForms );


        pLocalCacheForms = AllocSplMem( dwSplNeeded );
        pSaveLocalCacheForms = pLocalCacheForms;
        dwSplBuf = dwSplNeeded;

        if ( pLocalCacheForms == NULL ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed AllocSplMem ( %d )\n",dwSplNeeded));
            goto RefreshFormsCacheErrorReturn;

        }

    } while ( !bReturnValue && LastError == ERROR_INSUFFICIENT_BUFFER );


    //
    //  Optimization Check Local vs Remote
    //  If nothing has changed no need to do anything
    //

    
    SPLASSERT( pRemoteForms != NULL );

    for ( LoopCount = 0, pRemote = pRemoteForms, pLocal = pLocalCacheForms, bCacheMatchesRemoteMachine = TRUE;
          LoopCount < dwSplReturned && LoopCount < dwRemoteFormsReturned && bCacheMatchesRemoteMachine;
          LoopCount++, pRemote++, pLocal++ ) {


        //
        // If the form name is different, or the dimensions are different,
        // then refresh the forms cache.
        //
        // Note: if the forms are both built-in, then bypass the string
        // match since built in forms are standardized.  We actually
        // should be able to bypass all checks.
        //
        if (( wcscmp( pRemote->pName, pLocal->pName ) != STRINGS_ARE_EQUAL ) ||
            ( pRemote->Size.cx              != pLocal->Size.cx )             ||
            ( pRemote->Size.cy              != pLocal->Size.cy )             ||
            ( pRemote->ImageableArea.left   != pLocal->ImageableArea.left )  ||
            ( pRemote->ImageableArea.top    != pLocal->ImageableArea.top )   ||
            ( pRemote->ImageableArea.right  != pLocal->ImageableArea.right ) ||
            ( pRemote->ImageableArea.bottom != pLocal->ImageableArea.bottom ) ) {


            DBGMSG( DBG_TRACE, ("RefreshFormsCache Remote cx %d cy %d left %d right %d top %d bottom %d %ws\n",
                                 pRemote->Size.cx, pRemote->Size.cy,
                                 pRemote->ImageableArea.left,
                                 pRemote->ImageableArea.right,
                                 pRemote->ImageableArea.top,
                                 pRemote->ImageableArea.bottom,
                                 pRemote->pName));



            DBGMSG( DBG_TRACE, ("RefreshFormsCache Local  cx %d cy %d left %d right %d top %d bottom %d %ws - Does Not Match\n",
                                 pLocal->Size.cx, pLocal->Size.cy,
                                 pLocal->ImageableArea.left,
                                 pLocal->ImageableArea.right,
                                 pLocal->ImageableArea.top,
                                 pLocal->ImageableArea.bottom,
                                 pLocal->pName));

            bCacheMatchesRemoteMachine = FALSE;
        }
    }

    //
    //  If Everything matches we're done.
    //

    if ( bCacheMatchesRemoteMachine ) {


        if ( dwRemoteFormsReturned == dwSplReturned ) {

            DBGMSG( DBG_TRACE, ("RefreshFormsCache << Cache Forms Match Remote Forms - Nothing to do >>\n"));
            goto RefreshFormsCacheReturn;

        } else if (dwRemoteFormsReturned > dwSplReturned){

            //
            //  All the forms we have in the cache match
            //  Now add the Extra Remote Forms.

            dwRemoteFormsReturned -= dwSplReturned;
            pRemoteForms = pRemote;

            //  dwSplReturned == 0 will skip the delete loop

            dwSplReturned = 0;
        }
    }


//
// TESTING
//
    ++dwNoMatch;

    DBGMSG( DBG_TRACE, ("RefreshFormsCache - Something Doesn't Match, Delete all the Cache and Refresh it\n"));

    //
    //  Delete all the forms in the Cache
    //

    for ( LoopCount = dwSplReturned, pLocal = pLocalCacheForms;
          LoopCount != 0;
          pLocal++, LoopCount-- ) {

//
// TESTING
//
        ++dwDeleteForm;

        bReturnValue = SplDeleteForm( pSpool->hSplPrinter, pLocal->pName );

        DBGMSG( DBG_TRACE, ("RefreshFormsCache %x SplDeleteForm( %x, %ws)\n",bReturnValue, pSpool->hSplPrinter, pLocal->pName));
    }


    //
    //  Add all the Remote Forms to the Cache
    //

    for ( LoopCount = dwRemoteFormsReturned, pRemote = pRemoteForms;
          LoopCount != 0;
          LoopCount--, pRemote++ ) {

//
// TESTING
//
        ++dwAddForm;

        SPLASSERT( pRemote != NULL );

        bReturnValue = SplAddForm( pSpool->hSplPrinter, 1, (LPBYTE)pRemote );

        DBGMSG( DBG_TRACE, ("RefreshFormsCache %x SplAddForm( %x, 1, %ws)\n",bReturnValue, pSpool->hSplPrinter, pRemote->pName));

    }

RefreshFormsCacheReturn:
RefreshFormsCacheErrorReturn:

    if ( pSaveRemoteForms != NULL )
        FreeSplMem( pSaveRemoteForms );

    if ( pSaveLocalCacheForms != NULL )
        FreeSplMem( pSaveLocalCacheForms );

}

VOID
RefreshDriverDataCache(
    PWSPOOL pSpool
)
{
    DWORD   iCount = 0;
    DWORD   dwType = 0;
    DWORD   ReturnValue = 0;

    LPBYTE  lpbData = NULL;
    DWORD   dwSizeData;
    DWORD   dwMaxSizeData;

    LPWSTR  pValueString = NULL;
    DWORD   dwSizeValueString;
    DWORD   dwMaxSizeValueString;


    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->signature == WSJ_SIGNATURE );
    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->pName != NULL );


    // Get the required sizes
    ReturnValue = RemoteEnumPrinterData(pSpool,
                                        iCount,
                                        pValueString,
                                        0,
                                        &dwMaxSizeValueString,
                                        &dwType,
                                        lpbData,
                                        0,
                                        &dwMaxSizeData);

    if (ReturnValue != ERROR_SUCCESS) {

        DBGMSG( DBG_TRACE, ("RefreshDriverDataCache Failed first RemoteEnumPrinterData %d\n", GetLastError()));
        goto RefreshDriverDataCacheError;
    }

    // Allocate
    if ((pValueString = AllocSplMem(dwMaxSizeValueString)) == NULL) {

        DBGMSG( DBG_WARNING, ("RefreshDriverDataCache Failed to allocate enough memory\n"));
        goto RefreshDriverDataCacheError;
    }

    if ((lpbData = AllocSplMem(dwMaxSizeData)) == NULL) {

        DBGMSG( DBG_WARNING, ("RefreshDriverDataCache Failed to allocate enough memory\n"));
        goto RefreshDriverDataCacheError;
    }


    // Enumerate
    for (iCount = 0 ;
         RemoteEnumPrinterData( pSpool,
                                iCount,
                                pValueString,
                                dwMaxSizeValueString,
                                &dwSizeValueString,
                                &dwType,
                                lpbData,
                                dwMaxSizeData,
                                &dwSizeData) == ERROR_SUCCESS ;
         ++iCount) {

        //
        //  Optimization - Do NOT write the data if it is the same
        //

        if ((ReturnValue = SplSetPrinterData(pSpool->hSplPrinter,
                                            (LPWSTR)pValueString,
                                            dwType,
                                            lpbData,
                                            dwSizeData )) != ERROR_SUCCESS) {

            DBGMSG( DBG_WARNING, ("RefreshDriverDataCache Failed SplSetPrinterData %d\n",ReturnValue ));
            goto    RefreshDriverDataCacheError;

        }
    }


RefreshDriverDataCacheError:

    FreeSplMem( lpbData );
    FreeSplStr( pValueString );
}


VOID
RefreshPrinterDataCache(
    PWSPOOL pSpool
)
{
    DWORD   ReturnValue = 0;
    DWORD   cbSubKeys;
    DWORD   dwResult;

    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->signature == WSJ_SIGNATURE );
    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->pName != NULL );


    // This call to RemoteEnumPrinterKey is here so we can find out
    // if the server exists and supports EnumPrinterKey
    dwResult = RemoteEnumPrinterKey(pSpool,
                                    L"",
                                    NULL,
                                    0,
                                    &cbSubKeys);

    DBGMSG(DBG_TRACE, ("RefreshPrinterDataCache: EnumPrinterKey Return: %0x\n", dwResult));

    if (dwResult == ERROR_MORE_DATA) {    // Server exists and supports EnumPrinterKey

        // Clean out old data
        SplDeletePrinterKey(pSpool->hSplPrinter, L"");

        // Enumerate and copy keys
        ReturnValue = EnumerateAndCopyKey(pSpool, L"");

    }
    else if (dwResult == RPC_S_PROCNUM_OUT_OF_RANGE) { // Server exists but doesn't support EnumPrinterKey

        // we still call refreshdriverdatacache so downlevel gets cached
        // Optimize: Only call for downlevel since EnumerateAndCopyKey copies Driver Data
        RefreshDriverDataCache(pSpool);

    }
    else if (dwResult == ERROR_INVALID_HANDLE || dwResult == RPC_S_CALL_FAILED) { // Server does not exist
        DBGMSG(DBG_TRACE, ("RefreshPrinterDataCache: Server \"%ws\" absent\n", pSpool->pName));
    }

    // Refresh PrinterInfo2
    RefreshPrinter(pSpool);

    // Refresh PrinterInfo7
    RefreshPrinterInfo7(pSpool);
}


DWORD
EnumerateAndCopyKey(
    PWSPOOL pSpool,
    LPWSTR  pKeyName
)
{
    DWORD   i;
    DWORD   dwResult = ERROR_SUCCESS;
    LPWSTR  pSubKeys = NULL;
    LPWSTR  pSubKey  = NULL;
    LPWSTR  pFullSubKey = NULL;
    DWORD   cbSubKey;
    DWORD   cbSubKeys;
    LPBYTE  pEnumValues = NULL;
    DWORD   cbEnumValues;
    DWORD   nEnumValues;
    PPRINTER_ENUM_VALUES pEnumValue = NULL;


    // Get SubKey size
    dwResult = RemoteEnumPrinterKey(pSpool,
                                    pKeyName,
                                    pSubKeys,
                                    0,
                                    &cbSubKeys);
    if (dwResult != ERROR_MORE_DATA)
        goto Cleanup;

    // Allocate SubKey buffer
    pSubKeys = AllocSplMem(cbSubKeys);
    if(!pSubKeys) {
        dwResult = GetLastError();
        goto Cleanup;
    }

    // Get SubKeys
    dwResult = RemoteEnumPrinterKey(pSpool,
                                    pKeyName,
                                    pSubKeys,
                                    cbSubKeys,
                                    &cbSubKeys);

    if (dwResult == ERROR_SUCCESS) {    // Found subkeys

        // Enumerate and copy Keys

        if (*pKeyName && *pSubKeys) {  // Allocate buffer for L"pKeyName\pSubKey"
            pFullSubKey = AllocSplMem(cbSubKeys + (wcslen(pKeyName) + 2)*sizeof(WCHAR));
            if(!pFullSubKey) {
                dwResult = GetLastError();
                goto Cleanup;
            }
        }

        for(pSubKey = pSubKeys ; *pSubKey ; pSubKey += wcslen(pSubKey) + 1) {

            if (*pKeyName) {
                wsprintf(pFullSubKey, L"%ws\\%ws", pKeyName, pSubKey);
                dwResult = EnumerateAndCopyKey(pSpool, pFullSubKey);
            } else {
                dwResult = EnumerateAndCopyKey(pSpool, pSubKey);
            }

            if (dwResult != ERROR_SUCCESS)
                goto Cleanup;
        }
    }

    dwResult = RemoteEnumPrinterDataEx( pSpool,
                                        pKeyName,
                                        pEnumValues,
                                        0,
                                        &cbEnumValues,
                                        &nEnumValues);

    // We quit here if *pKeyName == NULL so we don't copy root key values
    if (dwResult != ERROR_MORE_DATA || !*pKeyName)
        goto Cleanup;

    // Allocate EnumValues buffer
    pEnumValues = AllocSplMem(cbEnumValues);
    if(!pEnumValues) {
        dwResult = GetLastError();
        goto Cleanup;
    }

    // Get Values
    dwResult = RemoteEnumPrinterDataEx( pSpool,
                                        pKeyName,
                                        pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues);

    // Did we get any data, this could fail.
    if (dwResult == ERROR_SUCCESS)
    {
        // Set Values for current key
        for (i = 0, pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues ; i < nEnumValues ; ++i, ++pEnumValue)
        {
            dwResult = SplSetPrinterDataEx( pSpool->hSplPrinter,
                                            pKeyName,
                                            pEnumValue->pValueName,
                                            pEnumValue->dwType,
                                            pEnumValue->pData,
                                            pEnumValue->cbData);
            if (dwResult != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }


Cleanup:

    FreeSplMem(pSubKeys);

    FreeSplMem(pEnumValues);

    FreeSplMem(pFullSubKey);

    return dwResult;
}



BOOL
CacheEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );


        ReturnValue = SplEnumForms( pSpool->hSplPrinter,
                                    Level,
                                    pForm,
                                    cbBuf,
                                    pcbNeeded,
                                    pcReturned );

    } else {

        ReturnValue = RemoteEnumForms( hPrinter,
                                       Level,
                                       pForm,
                                       cbBuf,
                                       pcbNeeded,
                                       pcReturned );

    }

    return ReturnValue;

}





BOOL
CacheGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );



        ReturnValue = SplGetForm( pSpool->hSplPrinter,
                                    pFormName,
                                    Level,
                                    pForm,
                                    cbBuf,
                                    pcbNeeded );

    } else {

        ReturnValue = RemoteGetForm( hPrinter,
                                     pFormName,
                                     Level,
                                     pForm,
                                     cbBuf,
                                     pcbNeeded );

    }

    return ReturnValue;

}


DWORD
CacheGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD    ReturnValue;
    BOOL     bPrintProc = FALSE;
    WCHAR    szPrintProcKey[] = L"PrintProcCaps_";

    VALIDATEW32HANDLE( pSpool );

    //
    // If the pValueName is "PrintProcCaps_[datatype]" call the remote print processor which
    // supports that datatype and return the options that it supports.
    //
    if (pValueName && wcsstr(pValueName, szPrintProcKey)) {

        bPrintProc = TRUE;
    }

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !bPrintProc && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );



        ReturnValue = SplGetPrinterData( pSpool->hSplPrinter,
                                         pValueName,
                                         pType,
                                         pData,
                                         nSize,
                                         pcbNeeded );

    } else {

        ReturnValue = RemoteGetPrinterData( hPrinter,
                                            pValueName,
                                            pType,
                                            pData,
                                            nSize,
                                            pcbNeeded );

    }

    return  ReturnValue;

}


DWORD
CacheGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD   ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );



        ReturnValue = SplGetPrinterDataEx(  pSpool->hSplPrinter,
                                            pKeyName,
                                            pValueName,
                                            pType,
                                            pData,
                                            nSize,
                                            pcbNeeded );

    } else {

        ReturnValue = RemoteGetPrinterDataEx( hPrinter,
                                              pKeyName,
                                              pValueName,
                                              pType,
                                              pData,
                                              nSize,
                                              pcbNeeded );

    }

    return  ReturnValue;

}



DWORD
CacheEnumPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPBYTE   pEnumValues,
   DWORD    cbEnumValues,
   LPDWORD  pcbEnumValues,
   LPDWORD  pnEnumValues
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD   ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );


        ReturnValue = SplEnumPrinterDataEx( pSpool->hSplPrinter,
                                            pKeyName,
                                            pEnumValues,
                                            cbEnumValues,
                                            pcbEnumValues,
                                            pnEnumValues );

    } else {

        ReturnValue = RemoteEnumPrinterDataEx(  hPrinter,
                                                pKeyName,
                                                pEnumValues,
                                                cbEnumValues,
                                                pcbEnumValues,
                                                pnEnumValues );

    }

    return  ReturnValue;

}



DWORD
CacheEnumPrinterKey(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPWSTR   pSubkey,
   DWORD    cbSubkey,
   LPDWORD  pcbSubkey
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD   ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );

        ReturnValue = SplEnumPrinterKey(pSpool->hSplPrinter,
                                        pKeyName,
                                        pSubkey,
                                        cbSubkey,
                                        pcbSubkey);

    } else {

        ReturnValue = RemoteEnumPrinterKey( hPrinter,
                                            pKeyName,
                                            pSubkey,
                                            cbSubkey,
                                            pcbSubkey);

    }

    return  ReturnValue;

}


BOOL
CacheOpenPrinter(
   LPWSTR   pName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    PWSPOOL pSpool                  = NULL;
    PWSPOOL pRemoteSpool            = NULL;
    HANDLE  hSplPrinter             = INVALID_HANDLE_VALUE;
    BOOL    ReturnValue             = FALSE;
    HANDLE  hIniSpooler             = INVALID_HANDLE_VALUE;
    BOOL    DoOpenOnError           = TRUE;
    DWORD   LastError               = ERROR_SUCCESS;
    BOOL    bSync                   = FALSE;
    BOOL    bCreateCacheAfterCheck  = FALSE;

    LPWSTR pCommastr, pFixname = NULL;

    if (!VALIDATE_NAME(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    //
    // search for pszCnvrtdmToken on the end of pName
    // note that pszCnvrtdmToken must begin with a ','
    //
    SPLASSERT(pszCnvrtdmToken[0] == L',');

    pFixname = AllocSplStr( pName );
    if ( pFixname == NULL )
    {
        EnterSplSem();
        goto OpenPrinterError;
    }


    StripString(pFixname, pszCnvrtdmToken, L",");
    StripString(pFixname, pszDrvConvert, L",");
    pName = pFixname;

    ReturnValue = OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, pDefault , TRUE);

    if ( hIniSpooler == INVALID_HANDLE_VALUE ) {

        //
        // This means that the inispooler does not exist yet. Only create it
        // after some more confirmation.
        //
        hSplPrinter = INVALID_HANDLE_VALUE;
        bCreateCacheAfterCheck = TRUE;
    }

    if ( ReturnValue == FALSE ) {

        // Printer Not Found in Cache

        DBGMSG(DBG_TRACE, ("CacheOpenPrinter SplOpenPrinter %ws error %d\n",
                              pName,
                              GetLastError() ));

        // FLOATING PROFILE
        // If this is a Floating Profile then the following condition applies
        // there is an entry in HKEY_CURRENT_USER but not entry in
        // HKEY_LOCAL_MACHINE for the cache.
        // If this is the case then we need to establish the Cache now

        if (PrinterConnectionExists( pName )) {

            //
            // The printer connection exists in the registry. See if the inispooler
            // did not exist yet. If it does not, create it. This is to prevent us
            // hitting the wire on a default printer when some apps start up.
            //
            if (bCreateCacheAfterCheck) {

                bCreateCacheAfterCheck = FALSE;

                ReturnValue = OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, pDefault, FALSE);

                if (hIniSpooler == INVALID_HANDLE_VALUE) {
                    EnterSplSem();
                    hSplPrinter = INVALID_HANDLE_VALUE;
                    goto    OpenPrinterError;
                }
            }

            if ( ReturnValue == FALSE ) {

                if ( !AddPrinterConnectionPrivate( pName ) ||
                     SplOpenPrinter( pName ,
                                     &hSplPrinter,
                                     pDefault,
                                     hIniSpooler,
                                     NULL,
                                     0) != ROUTER_SUCCESS ) {

                    DBGMSG( DBG_TRACE, ("CacheOpenPrinter Failed to establish Floating Profile into Cache %d\n",
                                            GetLastError() ));

                    DoOpenOnError = FALSE;
                    EnterSplSem();
                    goto    OpenPrinterError;
                }

                DBGMSG( DBG_TRACE, ("CacheOpenPrinter Floating Profile Added to Cache\n"));
            }
        }
        else {

            //
            // This is just a remote open printer, just hit the wire.
            //
            EnterSplSem();
            goto    OpenPrinterError;
        }
    }

    EnterSplSem();

    SplInSem();

    //
    //  Create a pSpool Object for this Cached Printer
    //

    pSpool = AllocWSpool();

    if ( pSpool == NULL ) {

        DBGMSG(DBG_WARNING, ("CacheOpenPrinter AllocWSpool error %d\n", GetLastError() ));

        ReturnValue = FALSE;
        goto    OpenPrinterError;

    }

    pSpool->pName = AllocSplStr( pName );

    if ( pSpool->pName == NULL ) {

        DBGMSG(DBG_WARNING, ("CacheOpenPrinter AllocSplStr error %d\n", GetLastError() ));

        ReturnValue = FALSE;
        goto    OpenPrinterError;

    }

    pSpool->Status = WSPOOL_STATUS_USE_CACHE | WSPOOL_STATUS_NO_RPC_HANDLE;

    if (pFixname)
        pSpool->Status |=  WSPOOL_STATUS_CNVRTDEVMODE;
    pSpool->hIniSpooler = hIniSpooler;
    pSpool->hSplPrinter = hSplPrinter;

    SPLASSERT( hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( hSplPrinter != INVALID_HANDLE_VALUE );

    //
    // We want to hit the network if:
    // 1. The dwSyncOpenPrinter is non-zero, OR
    // 2. A default is specified AND:
    //    a. A datatype is specified, and it's not RAW OR
    //    b. Administrative access is requested.
    //
    // For admin, we want to get the true status of the printer, since
    // they will be administering it.
    //
    // If a non-default and non-RAW datatype is specified, we need to
    // be synchronous, since the remote machine may refuse the datatype
    // (e.g., connecting to 1057 with EMF).
    //
    if( pDefault ){

        if( ( pDefault->pDatatype && ( _wcsicmp( pDefault->pDatatype, pszRaw ) != STRINGS_ARE_EQUAL )) ||
            IsAdminAccess(pDefault)){

            bSync = TRUE;
        }
    }

    if( dwSyncOpenPrinter != 0 || bSync ){

       LeaveSplSem();

        ReturnValue = RemoteOpenPrinter( pName, &pRemoteSpool, pDefault, DO_NOT_CALL_LM_OPEN );

       EnterSplSem();

        if ( ReturnValue ) {

            DBGMSG( DBG_TRACE, ( "CacheOpenPrinter Synchronous Open OK pRemoteSpool %x pSpool %x\n", pRemoteSpool, pSpool ));
            SPLASSERT( pRemoteSpool->Type == SJ_WIN32HANDLE );

            pSpool->RpcHandle = pRemoteSpool->RpcHandle;
            pSpool->Status   |= pRemoteSpool->Status;
            pSpool->RpcError  = pRemoteSpool->RpcError;
            pSpool->bNt3xServer = pRemoteSpool->bNt3xServer;

            pRemoteSpool->RpcHandle = INVALID_HANDLE_VALUE;
            FreepSpool( pRemoteSpool );
            pRemoteSpool = NULL;

            CopypDefaultTopSpool( pSpool, pDefault );
            pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;

            LeaveSplSem();
            ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
            EnterSplSem();
        } else {

            DBGMSG( DBG_TRACE, ( "CacheOpenPrinter Synchronous Open Failed  pSpool %x LastError %d\n", pSpool, GetLastError() ));
            DoOpenOnError = FALSE;
        }

    } else {

        ReturnValue = DoAsyncRemoteOpenPrinter( pSpool, pDefault );
    }


OpenPrinterError:

    SplInSem();

    if ( !ReturnValue ) {

        // Failure

       LeaveSplSem();

        LastError = GetLastError();

        if (( hSplPrinter != INVALID_HANDLE_VALUE ) &&
            ( hSplPrinter != NULL ) ) {
            SplClosePrinter( hSplPrinter );
        }

        if ( hIniSpooler != INVALID_HANDLE_VALUE ) {
            SplCloseSpooler( hIniSpooler );
        }

       EnterSplSem();

        if ( pSpool != NULL ) {

            pSpool->hSplPrinter = INVALID_HANDLE_VALUE;
            pSpool->hIniSpooler = INVALID_HANDLE_VALUE;

            SPLASSERT( pSpool->cRef == 0 );

            FreepSpool( pSpool );
            pSpool = NULL;

        }

       LeaveSplSem();

        SetLastError( LastError );


        if ( DoOpenOnError ) {

            ReturnValue = RemoteOpenPrinter( pName, phPrinter, pDefault, CALL_LM_OPEN );

        }

    } else {

        //  Success, pass back Handle

        *phPrinter = (HANDLE)pSpool;

        LeaveSplSem();

    }

    SplOutSem();

    if ( ReturnValue == FALSE ) {
        DBGMSG(DBG_TRACE,("CacheOpenPrinter %ws failed %d *phPrinter %x\n", pName, GetLastError(), *phPrinter ));
    }

    if (pFixname)
        FreeSplStr(pFixname);

    return ( ReturnValue );

}

BOOL
CopypDefaultTopSpool(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTSW pDefault
)
{
    DWORD   cbDevMode = 0;
    BOOL    ReturnValue = FALSE;

    //
    //  Copy the pDefaults so we can use them later
    //

 try {

    if ( ( pDefault != NULL ) &&
         ( pDefault != &pSpool->PrinterDefaults ) ) {

        if (!ReallocSplStr( &pSpool->PrinterDefaults.pDatatype , pDefault->pDatatype )) {
            leave;
        }

        if ( pSpool->PrinterDefaults.pDevMode != NULL ) {

            cbDevMode = pSpool->PrinterDefaults.pDevMode->dmSize +
                        pSpool->PrinterDefaults.pDevMode->dmDriverExtra;

            FreeSplMem( pSpool->PrinterDefaults.pDevMode );

            pSpool->PrinterDefaults.pDevMode = NULL;

        }

        if ( pDefault->pDevMode != NULL ) {

            cbDevMode = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;

            pSpool->PrinterDefaults.pDevMode = AllocSplMem( cbDevMode );

            if ( pSpool->PrinterDefaults.pDevMode != NULL ) {
                CopyMemory( pSpool->PrinterDefaults.pDevMode, pDefault->pDevMode, cbDevMode );
            } else {
                leave;
            }


        } else pSpool->PrinterDefaults.pDevMode = NULL;

        pSpool->PrinterDefaults.DesiredAccess = pDefault->DesiredAccess;

    }

    ReturnValue = TRUE;

 } finally {
 }
    return ReturnValue;

}






BOOL
DoAsyncRemoteOpenPrinter(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTS pDefault
)
{
    BOOL    ReturnValue = FALSE;
    HANDLE  hThread = NULL;
    DWORD   IDThread;

    SplInSem();

    SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

    CopypDefaultTopSpool( pSpool, pDefault );

    pSpool->hWaitValidHandle = CreateEvent( NULL,
                                            EVENT_RESET_MANUAL,
                                            EVENT_INITIAL_STATE_NOT_SIGNALED,
                                            NULL );

    if ( pSpool->hWaitValidHandle != NULL ) {

        ReturnValue = GetSid( &pSpool->hToken );

        if ( ReturnValue ) {

            pSpool->cRef++;

            hThread = CreateThread( NULL, 0, RemoteOpenPrinterThread, pSpool, 0, &IDThread );

            if ( hThread != NULL ) {

                CloseHandle( hThread );
                ReturnValue = TRUE;
            } else {

                pSpool->cRef--;
                SPLASSERT( pSpool->cRef == 0 );
                ReturnValue = FALSE;
            }
        }
    }

    return ReturnValue;

}

BOOL
DoRemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPPRINTER_DEFAULTS pDefault,
   PWSPOOL   pSpool
)
{
    PWSPOOL pRemoteSpool = NULL;
    BOOL    bReturnValue;
    DWORD   dwLastError;

    SplOutSem();

    bReturnValue = RemoteOpenPrinter( pPrinterName, &pRemoteSpool, pDefault, DO_NOT_CALL_LM_OPEN );
    dwLastError = GetLastError();

    //
    // Copy useful values to our CacheHandle and discard the new handle
    //

   EnterSplSem();

    if ( bReturnValue ) {

        DBGMSG(DBG_TRACE, ("DoRemoteOpenPrinter RemoteOpenPrinter OK hRpcHandle %x\n", pRemoteSpool->RpcHandle ));

        SPLASSERT( WSJ_SIGNATURE == pSpool->signature );
        SPLASSERT( WSJ_SIGNATURE == pRemoteSpool->signature );
        SPLASSERT( pRemoteSpool->Type == SJ_WIN32HANDLE );
        SPLASSERT( pSpool->Type  == pRemoteSpool->Type );
        SPLASSERT( pRemoteSpool->pServer == NULL );
        SPLASSERT( pRemoteSpool->pShare  == NULL );
        SPLASSERT( pRemoteSpool->cRef == 0 );

        pSpool->RpcHandle = pRemoteSpool->RpcHandle;
        pSpool->Status   |= pRemoteSpool->Status;
        pSpool->RpcError  = pRemoteSpool->RpcError;
        pSpool->bNt3xServer = pRemoteSpool->bNt3xServer;

        pRemoteSpool->RpcHandle = INVALID_HANDLE_VALUE;
        FreepSpool( pRemoteSpool );
        pRemoteSpool = NULL;

        if ( pSpool->RpcHandle != INVALID_HANDLE_VALUE ) {
            pSpool->Status &= ~WSPOOL_STATUS_OPEN_ERROR;
        }

    } else {

        DBGMSG(DBG_WARNING, ("DoRemoteOpenPrinter RemoteOpenPrinter %ws failed %d\n", pPrinterName, dwLastError ));

        pSpool->RpcHandle = INVALID_HANDLE_VALUE;
        pSpool->Status |= WSPOOL_STATUS_OPEN_ERROR;
        pSpool->RpcError = dwLastError;

    }

    pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;

    if ( !SetEvent( pSpool->hWaitValidHandle )) {
        DBGMSG(DBG_ERROR, ("DoRemoteOpenPrinter failed SetEvent pSpool %x pSpool->hWaitValidHandle %x\n",
                pSpool, pSpool->hWaitValidHandle ));
    }

   LeaveSplSem();

    //  Check Cache Consistency
    //  The Workstation and the Server have a version ID
    //  If the version number has changed on the server then update the
    //  workstation Cache.

    ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    SplOutSem();

    return ( bReturnValue );
}



DWORD
RemoteOpenPrinterThread(
    PWSPOOL  pSpool
)
{
    DWORD   Status;
    PRINTER_DEFAULTS Defaults;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cbDevMode;

    SplOutSem();
    SPLASSERT( pSpool->signature == WSJ_SIGNATURE );

    SetCurrentSid( pSpool->hToken );

    EnterSplSem();

    // Before calling DoRemoteOpenPrinter, we need to make a copy of pSpool->PrinterDefaults
    // because another thread doing ResetPrinter (or anything calling CopypDefaultsTopSpool)
    // may free & realloc the PrinterDefaults contents.

    if (pSpool->PrinterDefaults.pDatatype) {
        if (!(Defaults.pDatatype = AllocSplStr(pSpool->PrinterDefaults.pDatatype))) {
            dwError = GetLastError();
        }
    } else {
        Defaults.pDatatype = NULL;
    }

    if (dwError == ERROR_SUCCESS && pSpool->PrinterDefaults.pDevMode) {
        cbDevMode = pSpool->PrinterDefaults.pDevMode->dmSize +
                    pSpool->PrinterDefaults.pDevMode->dmDriverExtra;

        Defaults.pDevMode = AllocSplMem(cbDevMode);

        if (Defaults.pDevMode)
            CopyMemory(Defaults.pDevMode, pSpool->PrinterDefaults.pDevMode, cbDevMode );
        else
            dwError = GetLastError();
    } else {
        Defaults.pDevMode = NULL;
    }

    Defaults.DesiredAccess = pSpool->PrinterDefaults.DesiredAccess;

    LeaveSplSem();


    if (dwError == ERROR_SUCCESS) {

        DoRemoteOpenPrinter( pSpool->pName,  &Defaults, pSpool );

    } else {

        pSpool->RpcHandle = INVALID_HANDLE_VALUE;
        pSpool->Status |= WSPOOL_STATUS_OPEN_ERROR;
        pSpool->RpcError = dwError;
        pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;
    }


   SplOutSem();
   EnterSplSem();

    SPLASSERT( pSpool->cRef != 0 );
    pSpool->cRef--;
    Status = pSpool->Status;

   LeaveSplSem();

    if ( Status & WSPOOL_STATUS_PENDING_DELETE ) {

        DBGMSG(DBG_TRACE,
             ("RemoteOpenPrinterThread - WSPOOL_STATUS_PENDING_DELETE closing handle %x\n",
              pSpool ));

        SPLASSERT( pSpool->cRef == 0 );

        CacheClosePrinter( pSpool );

        pSpool = NULL;

    }

    SetCurrentSid( NULL );

    FreeSplMem(Defaults.pDevMode);
    FreeSplStr(Defaults.pDatatype);

    SplOutSem();
    ExitThread( 0 );
    return ( 0 );
}

PWSPOOL
AllocWSpool(
    VOID
)
{
    PWSPOOL pSpool = NULL;

    SplInSem();

    if (pSpool = AllocSplMem(sizeof(WSPOOL))) {

        pSpool->signature = WSJ_SIGNATURE;
        pSpool->Type = SJ_WIN32HANDLE;
        pSpool->RpcHandle        = INVALID_HANDLE_VALUE;
        pSpool->hFile            = INVALID_HANDLE_VALUE;
        pSpool->hIniSpooler      = INVALID_HANDLE_VALUE;
        pSpool->hSplPrinter      = INVALID_HANDLE_VALUE;
        pSpool->hToken           = INVALID_HANDLE_VALUE;
        pSpool->hWaitValidHandle = INVALID_HANDLE_VALUE;

        // Add to List

        pSpool->pNext = pFirstWSpool;
        pSpool->pPrev = NULL;

        if ( pFirstWSpool != NULL ) {

            pFirstWSpool->pPrev = pSpool;

        }

        pFirstWSpool = pSpool;

    } else {

        DBGMSG( DBG_WARNING, ("AllocWSpool failed %d\n", GetLastError() ));

    }

    return ( pSpool );

}



VOID
FreepSpool(
    PWSPOOL  pSpool
)
{

    SplInSem();

    if ( pSpool->cRef == 0 ) {

        SPLASSERT( pSpool->hSplPrinter == INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hIniSpooler == INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->RpcHandle   == INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hFile       == INVALID_HANDLE_VALUE );

        if( pSpool->hWaitValidHandle != INVALID_HANDLE_VALUE ) {

            SetEvent( pSpool->hWaitValidHandle );
            CloseHandle( pSpool->hWaitValidHandle );
            pSpool->hWaitValidHandle = INVALID_HANDLE_VALUE;

        }

        if( pSpool->hToken != INVALID_HANDLE_VALUE ) {

            CloseHandle( pSpool->hToken );
            pSpool->hToken = INVALID_HANDLE_VALUE;

        }

        // Remove form linked List

        if ( pSpool->pNext != NULL ) {
            SPLASSERT( pSpool->pNext->pPrev == pSpool);
            pSpool->pNext->pPrev = pSpool->pPrev;
        }

        if  ( pSpool->pPrev == NULL ) {

            SPLASSERT( pFirstWSpool == pSpool );
            pFirstWSpool = pSpool->pNext;

        } else {

            SPLASSERT( pSpool->pPrev->pNext == pSpool );
            pSpool->pPrev->pNext = pSpool->pNext;

        }

        FreeSplStr( pSpool->pName );
        FreeSplStr( pSpool->PrinterDefaults.pDatatype );

        if ( pSpool->PrinterDefaults.pDevMode != NULL ) {
            FreeSplMem( pSpool->PrinterDefaults.pDevMode );
        }

        FreeSplMem(pSpool);

       // DbgDelHandle( pSpool );


    } else {

        pSpool->Status |= WSPOOL_STATUS_PENDING_DELETE;

    }

}



BOOL
CacheClosePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue = TRUE;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        RemoteEndDocPrinter( pSpool );
    }

    SplOutSem();
   EnterSplSem();

    if ( pSpool->Status & WSPOOL_STATUS_TEMP_CONNECTION ) {

        pSpool->Status &= ~WSPOOL_STATUS_TEMP_CONNECTION;

       LeaveSplSem();
        if (!DeletePrinterConnection( pSpool->pName )) {
            DBGMSG( DBG_TRACE, ("CacheClosePrinter failed DeletePrinterConnection %ws %d\n",
                    pSpool->pName, GetLastError() ));
        }
       EnterSplSem();

        SPLASSERT( pSpool->signature == WSJ_SIGNATURE );

    }

    SplInSem();

    if ( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) {

        if ( pSpool->cRef == 0 ) {

            pSpool->cRef++;

            if ( pSpool->RpcHandle != INVALID_HANDLE_VALUE ) {

                DBGMSG(DBG_TRACE, ("CacheClosePrinter pSpool %x RpcHandle %x Status %x cRef %d\n",
                                     pSpool, pSpool->RpcHandle, pSpool->Status, pSpool->cRef));

               LeaveSplSem();
                SplOutSem();

                ReturnValue = RemoteClosePrinter( hPrinter );

               EnterSplSem();
            }

           SplInSem();

            SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
            SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );

           LeaveSplSem();
            SplOutSem();

            SplClosePrinter( pSpool->hSplPrinter );
            SplCloseSpooler( pSpool->hIniSpooler );

           EnterSplSem();

            pSpool->hSplPrinter = INVALID_HANDLE_VALUE;
            pSpool->hIniSpooler = INVALID_HANDLE_VALUE;

            pSpool->Status &= ~WSPOOL_STATUS_USE_CACHE;
            pSpool->cRef--;

            SPLASSERT( pSpool->cRef == 0 );

        }

        FreepSpool( pSpool );

       LeaveSplSem();

    } else {

       LeaveSplSem();
        SplOutSem();

        if ( pSpool->hIniSpooler != INVALID_HANDLE_VALUE ) {
            SplCloseSpooler( pSpool->hIniSpooler );
            pSpool->hIniSpooler = INVALID_HANDLE_VALUE;
        }

        ReturnValue = RemoteClosePrinter( hPrinter );
    }

   SplOutSem();
    return ( ReturnValue );

}





BOOL
CacheSyncRpcHandle(
    PWSPOOL pSpool
)
{
    DWORD   dwLastError;

   EnterSplSem();

    if ( pSpool->Status & WSPOOL_STATUS_NO_RPC_HANDLE ) {

       LeaveSplSem();

        DBGMSG(DBG_TRACE,("CacheSyncRpcHandle Status WSPOOL_STATUS_NO_RPC_HANDLE waiting for RpcHandle....\n"));

        SplOutSem();

        WaitForSingleObject( pSpool->hWaitValidHandle, INFINITE );

       EnterSplSem();

    }

    if ( pSpool->Status & WSPOOL_STATUS_OPEN_ERROR ) {

        DBGMSG(DBG_WARNING, ("CacheSyncRpcHandle pSpool %x Status %x; setting last error = %d\n",
                             pSpool,
                             pSpool->Status,
                             pSpool->RpcError));

        dwLastError = pSpool->RpcError;

        //  If we failed to open the Server because it was unavailable
    //  then try and open it again ( provded the asynchronous thread is not active ).


        if (!( pSpool->Status & WSPOOL_STATUS_PENDING_DELETE ) &&
         ( pSpool->RpcHandle == INVALID_HANDLE_VALUE )     &&
         ( pSpool->RpcError  != ERROR_ACCESS_DENIED )      &&
         ( pSpool->cRef == 0 )                   ) {

        CloseHandle( pSpool->hWaitValidHandle );
        pSpool->hWaitValidHandle = INVALID_HANDLE_VALUE;

            pSpool->Status |= WSPOOL_STATUS_NO_RPC_HANDLE;

            DBGMSG( DBG_WARNING, ("CacheSyncRpcHandle retrying Async OpenPrinter\n"));

            if ( !DoAsyncRemoteOpenPrinter( pSpool, &pSpool->PrinterDefaults ) ) {
                pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;
                SetEvent( pSpool->hWaitValidHandle );
            }

        }

       LeaveSplSem();

        SPLASSERT( dwLastError );
        SetLastError( dwLastError );

        return FALSE;
    }

   LeaveSplSem();

    if ( pSpool->RpcHandle != INVALID_HANDLE_VALUE &&
         pSpool->Status & WSPOOL_STATUS_RESETPRINTER_PENDING ) {

        DBGMSG(DBG_TRACE, ("CacheSyncRpcHandle calling RemoteResetPrinter\n"));

        pSpool->Status &= ~ WSPOOL_STATUS_RESETPRINTER_PENDING;

        if ( ! RemoteResetPrinter( pSpool, &pSpool->PrinterDefaults ) ) {
            pSpool->Status |= WSPOOL_STATUS_RESETPRINTER_PENDING;
        }

    }

    return TRUE;
}



BOOL
CacheGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   dwServerMajorVersion = 0, dwServerMinorVersion = 0, dwPrivateFlag = 0;
    PWSPOOL pSpool = (PWSPOOL) hPrinter, pTempSpool = NULL;
    DWORD   dwLastError;

    VALIDATEW32HANDLE( pSpool );

    try {

        if (pSpool->Type != SJ_WIN32HANDLE) {
            SetLastError(ERROR_INVALID_FUNCTION);
            leave;
        }

        if ( !(pSpool->Status & WSPOOL_STATUS_USE_CACHE) ) {

            // Someone is calling GetPrinterDriver without a connection
            // we must NEVER EVER pass the caller a UNC name since they
            // will LoadLibrary accross the network, which might lead
            // to InPageIOErrors ( if the net goes down).
            // The solution is to establish a Temporary Connection for the life
            // of the pSpool handle, the connection will be removed
            // in CacheClosePrinter.    The connection will ensure that the
            // drivers are copied locally and a local cache is established
            // for this printer.

            pSpool->Status |= WSPOOL_STATUS_TEMP_CONNECTION;

            pTempSpool = InternalAddPrinterConnection( pSpool->pName );

            if ( !pTempSpool )
            {
                pSpool->Status &= ~WSPOOL_STATUS_TEMP_CONNECTION;

                DBGMSG( DBG_TRACE, ("CacheGetPrinterDriver failed AddPrinterConnection %d\n",
                                       GetLastError() ));
                leave;
            }

            ReturnValue = OpenCachePrinterOnly( pSpool->pName, &pSpool->hSplPrinter,
                                                &pSpool->hIniSpooler, NULL, FALSE);

            if ( !ReturnValue )
            {
                SplCloseSpooler( pSpool->hIniSpooler );

                DBGMSG( DBG_WARNING,
                        ("CacheGetPrinterDriver Connection OK Failed CacheOpenPrinter %d\n",
                          GetLastError() ));
                leave;
            }

            pSpool->Status |= WSPOOL_STATUS_USE_CACHE;
        }

        SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        ReturnValue = SplGetPrinterDriverEx( pSpool->hSplPrinter,
                                             pEnvironment,
                                             Level,
                                             pDriverInfo,
                                             cbBuf,
                                             pcbNeeded,
                                             cThisMajorVersion,
                                             cThisMinorVersion,
                                             &dwServerMajorVersion,
                                             &dwServerMinorVersion);


    } finally {

        if (pTempSpool) {
            dwLastError = GetLastError();
            CacheClosePrinter(pTempSpool);
            SetLastError(dwLastError);
        }
    }

    return ReturnValue;
}


BOOL
CacheResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    PWSPOOL pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue =  FALSE;

    VALIDATEW32HANDLE(pSpool);

    if (pSpool->Status & WSPOOL_STATUS_USE_CACHE)
    {
        EnterSplSem();

        ReturnValue = SplResetPrinter(pSpool->hSplPrinter, pDefault);

        if (ReturnValue)
        {
            CopypDefaultTopSpool(pSpool, pDefault);

            if (pSpool->RpcHandle != INVALID_HANDLE_VALUE)
            {
                //
                //  Have RPC Handle
                //
                LeaveSplSem();

                ReturnValue = RemoteResetPrinter(hPrinter, pDefault);
            }
            else
            {
                //
                //  No RpcHandle
                //
                DBGMSG( DBG_TRACE, ("CacheResetPrinter %x NO_RPC_HANDLE Status Pending\n",
                                     pSpool ));

                pSpool->Status |= WSPOOL_STATUS_RESETPRINTER_PENDING;

                LeaveSplSem();
            }
        }
        else
        {
            LeaveSplSem();
        }
    }
    else
    {
        ReturnValue = RemoteResetPrinter(hPrinter, pDefault);
    }

    return ReturnValue;
}


BOOL
CacheGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue =  FALSE;
    PWCACHEINIPRINTEREXTRA pExtraData = NULL;
    DWORD   LastError = ERROR_SUCCESS;
    DWORD   cbSize = 0;
    DWORD   cbDevMode;
    DWORD   cbSecDesc;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR  *pSourceStrings=SourceStrings;
    LPBYTE  pEnd;
    DWORD   *pOffsets;
    PPRINTER_INFO_2W    pPrinter2 = (PPRINTER_INFO_2)pPrinter;
    PPRINTER_INFO_4W    pPrinter4 = (PPRINTER_INFO_4)pPrinter;
    PPRINTER_INFO_5W    pPrinter5 = (PPRINTER_INFO_5)pPrinter;
    BOOL                bCallRemote = TRUE;

    VALIDATEW32HANDLE( pSpool );

 try {

    if ( (Level == 2 || Level == 5) &&
         (pSpool->Status & WSPOOL_STATUS_USE_CACHE) ) {

        ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );
        if ( ReturnValue ) {

            if ( (GetTickCount() - pExtraData->dwTickCount) < REFRESH_TIMEOUT )
                bCallRemote = FALSE;
        }
        pExtraData = NULL;
    }

    if (( Level != 4) &&
        ( ((pSpool->RpcHandle != INVALID_HANDLE_VALUE ) && bCallRemote ) ||

        IsAdminAccess(&pSpool->PrinterDefaults) ||

        !( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) ||

        ( Level == GET_SECURITY_DESCRIPTOR ) ||

        ( Level == STRESSINFOLEVEL ))) {


        ReturnValue = RemoteGetPrinter( hPrinter,
                                        Level,
                                        pPrinter,
                                        cbBuf,
                                        pcbNeeded );

        if ( ReturnValue ) {
            leave;
        }


        LastError = GetLastError();


        if (IsAdminAccess(&pSpool->PrinterDefaults) ||

            !( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) ||

            ( Level == GET_SECURITY_DESCRIPTOR ) ||

            ( Level == STRESSINFOLEVEL )) {

            leave;

        }

        SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        if (( LastError != RPC_S_SERVER_UNAVAILABLE ) &&
            ( LastError != RPC_S_CALL_FAILED )        &&
            ( LastError != RPC_S_CALL_FAILED_DNE )    &&
            ( LastError != RPC_S_SERVER_TOO_BUSY )) {

            // Valid Error like ERROR_INSUFFICIENT_BUFFER or ERROR_INVALID_HANDLE.

            leave;

        }
    }

    //
    // If it is level 4, we must check if we have the information in the cache
    // If not, we return ERROR_INVALID_LEVEL.
    //

    if (Level == 4 && (! (pSpool->Status & WSPOOL_STATUS_USE_CACHE))) {
        LastError = ERROR_INVALID_LEVEL;
        ReturnValue = FALSE;

    }
    else {

        //
        // Assert to make sure the data is in the cache.
        //

        SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        switch ( Level ) {

        case    1:
        case    7:

            ReturnValue = SplGetPrinter( pSpool->hSplPrinter,
                                         Level,
                                         pPrinter,
                                         cbBuf,
                                         pcbNeeded );

            if ( ReturnValue == FALSE ) {

                LastError = GetLastError();

            }

            break;

        case    4:

           EnterSplSem();

            ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

            if ( ReturnValue == FALSE ) {

                DBGMSG( DBG_WARNING, ("CacheGetPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
                SPLASSERT( ReturnValue );

            }

            if ( pExtraData == NULL ) {
                LeaveSplSem();
                break;
            }

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            cbSize = pExtraData->cbPI2;
            *pcbNeeded = cbSize;

            if ( cbSize > cbBuf ) {
                LastError = ERROR_INSUFFICIENT_BUFFER;
                ReturnValue = FALSE;
                LeaveSplSem();
                break;
            }

            *pSourceStrings++ = pExtraData->pPI2->pPrinterName;
            *pSourceStrings++ = pExtraData->pPI2->pServerName;

            pOffsets = PrinterInfo4Strings;
            pEnd = pPrinter + cbBuf;

            pEnd = PackStrings(SourceStrings, pPrinter, pOffsets, pEnd);

            pPrinter4->Attributes      = pExtraData->pPI2->Attributes;

            ReturnValue = TRUE;

           LeaveSplSem();

            break;

        case    2:

           EnterSplSem();

            ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

            if ( ReturnValue == FALSE ) {

                DBGMSG( DBG_WARNING, ("CacheGetPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
                SPLASSERT( ReturnValue );

            }

            if ( pExtraData == NULL ) {
                LeaveSplSem();
                break;
            }

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            cbSize = pExtraData->cbPI2;
            *pcbNeeded = cbSize;

            if ( cbSize > cbBuf ) {
                LastError = ERROR_INSUFFICIENT_BUFFER;
                ReturnValue = FALSE;
                LeaveSplSem();
                break;
            }

            // NOTE
            // In the case of EnumerateFavoritePrinters it expects us to pack our
            // strings at the end of the structure not just following it.
            // You might wrongly assume that you could just copy the complete structure
            // inluding strings but you would be wrong.

            *pSourceStrings++ = pExtraData->pPI2->pServerName;
            *pSourceStrings++ = pExtraData->pPI2->pPrinterName;
            *pSourceStrings++ = pExtraData->pPI2->pShareName;
            *pSourceStrings++ = pExtraData->pPI2->pPortName;
            *pSourceStrings++ = pExtraData->pPI2->pDriverName;
            *pSourceStrings++ = pExtraData->pPI2->pComment;
            *pSourceStrings++ = pExtraData->pPI2->pLocation;
            *pSourceStrings++ = pExtraData->pPI2->pSepFile;
            *pSourceStrings++ = pExtraData->pPI2->pPrintProcessor;
            *pSourceStrings++ = pExtraData->pPI2->pDatatype;
            *pSourceStrings++ = pExtraData->pPI2->pParameters;

            pOffsets = PrinterInfo2Strings;
            pEnd = pPrinter + cbBuf;

            pEnd = PackStrings(SourceStrings, pPrinter, pOffsets, pEnd);

            if ( pExtraData->pPI2->pDevMode != NULL ) {

                cbDevMode = ( pExtraData->pPI2->pDevMode->dmSize + pExtraData->pPI2->pDevMode->dmDriverExtra );
                pEnd -= cbDevMode;

                pEnd = (LPBYTE)ALIGN_PTR_DOWN(pEnd);

                pPrinter2->pDevMode = (LPDEVMODE)pEnd;

                CopyMemory(pPrinter2->pDevMode, pExtraData->pPI2->pDevMode, cbDevMode );

            } else {

                pPrinter2->pDevMode = NULL;

            }

            if ( pExtraData->pPI2->pSecurityDescriptor != NULL ) {

                cbSecDesc = GetSecurityDescriptorLength( pExtraData->pPI2->pSecurityDescriptor );

                pEnd -= cbSecDesc;
                pEnd = (LPBYTE)ALIGN_PTR_DOWN(pEnd);

                pPrinter2->pSecurityDescriptor = pEnd;

                CopyMemory( pPrinter2->pSecurityDescriptor, pExtraData->pPI2->pSecurityDescriptor, cbSecDesc );


            } else {

                pPrinter2->pSecurityDescriptor = NULL;

            }


            pPrinter2->Attributes      = pExtraData->pPI2->Attributes;
            pPrinter2->Priority        = pExtraData->pPI2->Priority;
            pPrinter2->DefaultPriority = pExtraData->pPI2->DefaultPriority;
            pPrinter2->StartTime       = pExtraData->pPI2->StartTime;
            pPrinter2->UntilTime       = pExtraData->pPI2->UntilTime;
            pPrinter2->Status          = pExtraData->pPI2->Status;
            pPrinter2->cJobs           = pExtraData->pPI2->cJobs;
            pPrinter2->AveragePPM      = pExtraData->pPI2->AveragePPM;

            ReturnValue = TRUE;

            LeaveSplSem();
            break;

        case 5:

            //
            // We need to support a cached level 5 get, the printer, the port
            // name and the attributes we get from the Cached PI2. For the port
            // attributes, we just return the default.
            //
            EnterSplSem();

            ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

            if ( ReturnValue == FALSE ) {

                DBGMSG( DBG_WARNING, ("CacheGetPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
                SPLASSERT( ReturnValue );
            }

            if ( pExtraData == NULL ) {
                LeaveSplSem();
                break;
            }

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            //
            // The size is the size of the printer name, the port name, their NULL
            // terminating characters and the size of the PRINTER_INFO_5 structure
            // itself.
            //
            cbSize = (pExtraData->pPI2->pPrinterName ? (wcslen(pExtraData->pPI2->pPrinterName) + 1) : 0) * sizeof(WCHAR) +
                     (pExtraData->pPI2->pPortName    ? (wcslen(pExtraData->pPI2->pPortName)    + 1) : 0) * sizeof(WCHAR) +
                     sizeof(PRINTER_INFO_5);

            *pcbNeeded = cbSize;

            if ( cbSize > cbBuf ) {
                LastError = ERROR_INSUFFICIENT_BUFFER;
                ReturnValue = FALSE;
                LeaveSplSem();
                break;
            }

            *pSourceStrings++ = pExtraData->pPI2->pPrinterName;
            *pSourceStrings++ = pExtraData->pPI2->pPortName;

            pOffsets = PrinterInfo5Strings;
            pEnd = pPrinter + cbBuf;

            pEnd = PackStrings(SourceStrings, pPrinter, pOffsets, pEnd);

            pPrinter5->Attributes               = pExtraData->pPI2->Attributes;
            pPrinter5->DeviceNotSelectedTimeout = kDefaultDnsTimeout;
            pPrinter5->TransmissionRetryTimeout = kDefaultTxTimeout;

            ReturnValue = TRUE;

            LeaveSplSem();

            break;

        case    3:
            DBGMSG( DBG_ERROR, ("CacheGetPrinter Level 3 impossible\n"));

        default:
            LastError = ERROR_INVALID_LEVEL;
            ReturnValue = FALSE;
            break;

        }
    }

 } finally {

    if ( !ReturnValue ) {

        SetLastError( LastError );

    }

 }

 return ReturnValue;

}


//
//  Called When the Printer is read back from the registry
//


PWCACHEINIPRINTEREXTRA
CacheReadRegistryExtra(
    HKEY    hPrinterKey
)
{
    PWCACHEINIPRINTEREXTRA pExtraData = NULL;
    LONG    ReturnValue;
    PPRINTER_INFO_2W    pPrinterInfo2 = NULL;
    DWORD   cbSizeRequested = 0;
    DWORD   cbSizeInfo2 = 0;



    ReturnValue = RegQueryValueEx( hPrinterKey, szCachePrinterInfo2, NULL, NULL, NULL, &cbSizeRequested );

    if ((ReturnValue == ERROR_MORE_DATA) || (ReturnValue == ERROR_SUCCESS)) {

        cbSizeInfo2 = cbSizeRequested;
        pPrinterInfo2 = AllocSplMem( cbSizeInfo2 );

        if ( pPrinterInfo2 != NULL ) {

            ReturnValue = RegQueryValueEx( hPrinterKey,
                                           szCachePrinterInfo2,
                                           NULL, NULL, (LPBYTE)pPrinterInfo2,
                                           &cbSizeRequested );

            if ( ReturnValue == ERROR_SUCCESS ) {

                //
                //  Cached Structures on Disk have offsets for pointers
                //

                if (MarshallUpStructure((LPBYTE)pPrinterInfo2, PrinterInfo2Fields,
                                         sizeof(PRINTER_INFO_2), NATIVE_CALL))
                {
                    pExtraData = AllocExtraData( pPrinterInfo2, cbSizeInfo2 );
                }
            }

            FreeSplMem( pPrinterInfo2 );
        }

    }

    //
    //  Read the timestamp for the Cached Printer Data
    //

    if ( pExtraData != NULL ) {

        cbSizeRequested = sizeof( pExtraData->cCacheID );

        ReturnValue = RegQueryValueEx(hPrinterKey,
                                      szCacheTimeLastChange,
                                      NULL, NULL,
                                      (LPBYTE)&pExtraData->cCacheID, &cbSizeRequested );

        // Read the Connection Reference Count

        cbSizeRequested = sizeof( pExtraData->cRef );

        ReturnValue = RegQueryValueEx(hPrinterKey,
                                      szcRef,
                                      NULL, NULL,
                      (LPBYTE)&pExtraData->cRef, &cbSizeRequested );

        cbSizeRequested = sizeof(pExtraData->dwServerVersion);
        ReturnValue = RegQueryValueEx(hPrinterKey,
                                      szServerVersion,
                                      NULL, NULL,
                                      (LPBYTE)&pExtraData->dwServerVersion,
                                      &cbSizeRequested);

    }

    return pExtraData;

}


BOOL
CacheWriteRegistryExtra(
    LPWSTR  pName,
    HKEY    hPrinterKey,
    PWCACHEINIPRINTEREXTRA pExtraData
)
{
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    DWORD   cbSize = 0;
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   Status;

    if ( pExtraData == NULL ) return FALSE;

    SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

    cbSize = pExtraData->cbPI2;

    if ( cbSize != 0 ) {

        pPrinterInfo2 = AllocSplMem( cbSize );

        if ( pPrinterInfo2 != NULL ) {

            CacheCopyPrinterInfo( pPrinterInfo2, pExtraData->pPI2, cbSize );

            //
            //  Before writing it to the registry make all pointers offsets
            //
            if (MarshallDownStructure((LPBYTE)pPrinterInfo2, PrinterInfo2Fields,
                                      sizeof(PRINTER_INFO_2), NATIVE_CALL))
            {
                dwLastError = RegSetValueEx( hPrinterKey, szCachePrinterInfo2, 0,
                                             REG_BINARY, (LPBYTE)pPrinterInfo2, cbSize );
            }
            else
            {
                dwLastError = GetLastError();
            }

            FreeSplMem( pPrinterInfo2 );

        } else {

            dwLastError = GetLastError();

        }
    }


    //
    //  Write Cache TimeStamp to Registry
    //

    cbSize = sizeof ( pExtraData->cCacheID );
    Status = RegSetValueEx( hPrinterKey, szCacheTimeLastChange, 0, REG_DWORD, (LPBYTE)&pExtraData->cCacheID, cbSize );
    if ( Status != ERROR_SUCCESS ) dwLastError = Status;

    cbSize = sizeof(pExtraData->dwServerVersion);
    Status = RegSetValueEx( hPrinterKey, szServerVersion, 0, REG_DWORD, (LPBYTE)&pExtraData->dwServerVersion, cbSize );
    if ( Status != ERROR_SUCCESS ) dwLastError = Status;

    cbSize = sizeof ( pExtraData->cRef );
    Status = RegSetValueEx( hPrinterKey, szcRef, 0, REG_DWORD, (LPBYTE)&pExtraData->cRef, cbSize );
    if ( Status != ERROR_SUCCESS ) dwLastError = Status;

    if ( dwLastError == ERROR_SUCCESS ) {

        return TRUE;

    } else {

        SetLastError( dwLastError );

        return FALSE;
    }


}

/*++

-- ConsistencyCheckCache --

Routine Description:

    This will determine if the Printer cache needs updating, and update it if necessary.
    It has a timeout value so as to reduce traffic and have less calls going across the wire.
    Checks the remote printer's ChangeID, and if the value differs from one stored in the cache
    it triggers an update.

Arguments:

    pSpool          - Handle to remote printer.
    bCheckPolicy    - If TRUE, we should check to policy to see if we are
                      allowed to download the driver.

Return Value:

    None

--*/

VOID
ConsistencyCheckCache(
    IN      PWSPOOL             pSpool,
    IN      EDriverDownload     eDriverDownload
)
{
    BOOL    ReturnValue = FALSE;
    BOOL    bGotID = TRUE;
    BOOL    RefreshNeeded = TRUE;
    DWORD   cbBuf = MAX_PRINTER_INFO0;
    BYTE    PrinterInfoW0[ MAX_PRINTER_INFO0 ];
    LPPRINTER_INFO_STRESSW pPrinter0 = (LPPRINTER_INFO_STRESSW)&PrinterInfoW0;
    DWORD   dwNeeded;
    PWCACHEINIPRINTEREXTRA pExtraData;
    BOOL    bGetPrinterExtra = TRUE;
    DWORD   NewTick;
    DWORD   RemoteChangeID = 0, DataType = 0, SizeNeeded = 0;
    DWORD   dwRetVal = ERROR_SUCCESS;

    if ( ( pSpool->RpcHandle == INVALID_HANDLE_VALUE ) ||
        !( pSpool->Status & WSPOOL_STATUS_USE_CACHE )) {
        return;
    }

    SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

    //
    // Get the Printer ExtraData from the cache Printer. This is used for the copmparisons
    // of the ChangeID and TickCount
    //

    bGetPrinterExtra = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

    if ( bGetPrinterExtra && (pExtraData != NULL))
    {
        SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );
        SPLASSERT( pExtraData->pPI2 != NULL );

        NewTick = GetTickCount();

        //
        // Make sure an appropriate amount of time has elapsed before hitting
        // the network again.
        //

        //
        // This takes care of the rollover case too, although you may get an extra refresh
        // before the timeout is over.
        //
        if ( (NewTick > ( pExtraData->dwTickCount + GetCacheTimeout()))
             || (NewTick < pExtraData->dwTickCount))
        {
            //
            // Get the new ChangeID from the Server. Try the GetPrinterData call
            // first to reduce network usage. If that fails, fall back to the old way.
            //

            RefreshNeeded = TRUE;

            //
            //  Keep Updating our Cache until we match the Server
            //

            while ( RefreshNeeded )
            {
                dwRetVal = RemoteGetPrinterData(
                                      pSpool,
                                      L"ChangeId",
                                      &DataType,
                                      (PBYTE) &RemoteChangeID,
                                      sizeof(RemoteChangeID),
                                      &SizeNeeded );

                if ((dwRetVal == ERROR_INVALID_PARAMETER) ||
                    (dwRetVal == ERROR_FILE_NOT_FOUND) )
                {
                    //
                    // Fall back to the old STRESSINFOLEVEL call.
                    //

                    ReturnValue = RemoteGetPrinter( pSpool, STRESSINFOLEVEL, (LPBYTE)&PrinterInfoW0, cbBuf, &dwNeeded );

                    if ( ReturnValue )
                    {
                        RemoteChangeID = pPrinter0->cChangeID;
                        bGotID = TRUE;
                    }
                    else
                    {
                        SPLASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                        DBGMSG( DBG_TRACE, ("ConsistencyCheckCache failed RemoteGetPrinter %d\n", GetLastError() ));
                        bGotID = FALSE;
                    }

                }
                else if (dwRetVal != ERROR_SUCCESS)
                {
                    //
                    // Something went badly wrong here.
                    //

                    DBGMSG( DBG_TRACE, ("ConsistencyCheckCache failed RemoteGetPrinterData %d\n", GetLastError() ));
                    bGotID = FALSE;
                }
                else
                {
                    bGotID = TRUE;
                }

                if ( bGotID && (pExtraData->cCacheID != RemoteChangeID) )
                {
                    DBGMSG( DBG_TRACE, ("ConsistencyCheckCache << Server cCacheID %x Workstation cChangeID %x >>\n",
                                         RemoteChangeID,
                                         pExtraData->cCacheID ));

                    //
                    // Now we want to change the info, since we need to update
                    //
                    if ( !ReturnValue )
                    {
                        ReturnValue = RemoteGetPrinter(pSpool, STRESSINFOLEVEL, (LPBYTE)&PrinterInfoW0, cbBuf, &dwNeeded);
                    }

                    if ( ReturnValue )
                    {
                        //
                        // Update Data we can't get from GetPrinterData.
                        // We might be able to leave this out. Not sure yet.
                        //
                        pExtraData->dwServerVersion = pPrinter0->dwGetVersion;
                        pExtraData->pPI2->cJobs  = pPrinter0->cJobs;
                        pExtraData->pPI2->Status = pPrinter0->Status;

                    }
                    else
                    {
                        SPLASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                        DBGMSG( DBG_TRACE, ("ConsistencyCheckCache failed RemoteGetPrinter %d\n", GetLastError() ));
                    }


                    //
                    //  Don't have tons of threads doing a refresh at the same time
                    //  In stress when there are lots of folks changing printer settings
                    //  so the cChangeId changes a lot, but we don't want multiple threads
                    //  all doing a refresh since you get a LOT, it doesn't buy anything
                    //

                    EnterSplSem();

                    if ( !(pExtraData->Status & EXTRA_STATUS_DOING_REFRESH) ) {

                        pExtraData->Status |= EXTRA_STATUS_DOING_REFRESH;
                        pExtraData->cCacheID = RemoteChangeID;
                        pExtraData->dwTickCount = GetTickCount();

                        LeaveSplSem();

                        RefreshCompletePrinterCache(pSpool, eDriverDownload);

                        EnterSplSem();

                        SPLASSERT( pExtraData->Status & EXTRA_STATUS_DOING_REFRESH );

                        pExtraData->Status &= ~EXTRA_STATUS_DOING_REFRESH;
                    }

                    LeaveSplSem();
                }
                else
                {
                    if ( bGotID )
                    {
                        //
                        // We need to Update the TickCount anyway
                        //
                        pExtraData->dwTickCount = GetTickCount();
                    }
                    //
                    // We either failed the GetPrinterData's or the ChangeID's were
                    // the same. Either way, we don't want to try again.
                    //

                    RefreshNeeded = FALSE;

                } // if gotid

            } // while RefreshNeeded

        } // if newtick > timeout

    } // if SplGetPrinterExtra
    else
    {
        DBGMSG( DBG_WARNING, ("ConsistencyCheckCache SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
        SPLASSERT( bGetPrinterExtra );
    }
}

BOOL
RefreshPrinterDriver(
    IN  PWSPOOL             pSpool,
    IN  LPWSTR              pszDriverName,
    IN  EDriverDownload     eDriverDownload
)
{
    LPBYTE pDriverInfo = NULL;
    DWORD  cbDriverInfo = MAX_DRIVER_INFO_VERSION;
    DWORD  cbNeeded, Level, dwLastError = ERROR_SUCCESS;
    BOOL   bReturnValue     = FALSE;
    BOOL   bAttemptDownload = FALSE;
    DWORD  LevelArray[] = { DRIVER_INFO_VERSION_LEVEL, 6 , 4 , 3 , 2 , 1 , -1 };
    DWORD  dwIndex;

    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );

try {

    if ( !(pDriverInfo = AllocSplMem(cbDriverInfo)) )
        leave;

    //
    // Only download a driver from the remote server if we are allowed to by
    // policy, or, if the trusted path is set up, in which case we might try.
    //
    bAttemptDownload = eDriverDownload == kDownloadDriver || IsTrustedPathConfigured();

    if (bAttemptDownload) {
        //
        // When the trusted path is configured, we do not try the first level
        // (DRIVER_INFO_VERSION_LEVEL) in the LeveLArray, because the code in
        // DownloadDriverFiles doesnt know how to handle it. DownloadDriverFiles
        // fails and returns error invalid level, if the level is
        // DRIVER_INFO_VERSION_LEVEL. We are saving 2 RPC calls to the remote
        // server by checking ahead if the trusted path is configured and passing
        // the right level.
        //
        for (dwIndex = IsTrustedPathConfigured() ? 1 : 0;
             LevelArray[dwIndex] != -1                              &&
             !(bReturnValue = CopyDriversLocally(pSpool,
                                                 szEnvironment,
                                                 pDriverInfo,
                                                 LevelArray[dwIndex],
                                                 cbDriverInfo,
                                                 &cbNeeded))       &&
             (dwLastError = GetLastError()) == ERROR_INVALID_LEVEL ;
             dwIndex++ );

        Level = LevelArray[dwIndex];

        if ( !bReturnValue && dwLastError == ERROR_INSUFFICIENT_BUFFER ) {

            FreeSplMem( pDriverInfo );

            if ( pDriverInfo = AllocSplMem(cbNeeded) ) {

                cbDriverInfo = cbNeeded;
                bReturnValue = CopyDriversLocally(pSpool,
                                                  szEnvironment,
                                                  pDriverInfo,
                                                  Level,
                                                  cbDriverInfo,
                                                  &cbNeeded);
            }
        }
    }

    //
    // We could be looking at a remote environment that is different from ours
    // and doesn't have a relevant driver installed in my environment (eg no IA64 driver on x86)
    // or my environment didn't exist on the remote machine (e.g. w2K gold for IA64).
    // Try the local install on the driver name that is being used by the remote printer.
    // Only do this if we don't have SERVER_INSTALL_ONLY as the policy.
    //
    dwLastError = GetLastError();

    if( !bReturnValue                        &&
        pszDriverName                        &&
            (dwLastError == ERROR_UNKNOWN_PRINTER_DRIVER ||
             dwLastError == ERROR_INVALID_ENVIRONMENT    ||
             !bAttemptDownload) ) {

        bReturnValue = AddDriverFromLocalCab(pszDriverName, pSpool->hIniSpooler);
    }

    if ( bReturnValue ) {

        //
        // Do Not add to KHKEY_CURRENT_USER for Temp connections
        //
        if ( !pSpool->Status & WSPOOL_STATUS_TEMP_CONNECTION ) {
            bReturnValue = SavePrinterConnectionInRegistry(pSpool->pName,
                                                           pDriverInfo,
                                                           Level);
        }
    }

 } finally {

    FreeSplMem(pDriverInfo);
 }

    if ( !bReturnValue )
        DBGMSG(DBG_WARNING,
               ("RefreshPrinterDriver Failed SplAddPrinterDriver %d\n",
                GetLastError() ));

    return bReturnValue;
}

BOOL
OpenCachePrinterOnly(
   LPWSTR               pName,
   LPHANDLE             phSplPrinter,
   LPHANDLE             phIniSpooler,
   LPPRINTER_DEFAULTS   pDefault,
   BOOL                 bOpenOnly
)
{
    PWCHAR  pMachineName = NULL;
    PWCHAR  pPrinterName;
    BOOL    ReturnValue = FALSE;
    PWSTR   psz;

    if (!VALIDATE_NAME(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }


 try {

    //
    //  See if we already known about this server in the cache
    //

    DBGMSG(DBG_TRACE, ("OpenCachePrinterOnly pName %ws \n",pName));

    //
    //  Find the Machine Name
    //

    SPLASSERT ( 0 == _wcsnicmp( pName, L"\\\\", 2 ) ) ;

    pMachineName = AllocSplStr( pName );

    if ( pMachineName == NULL )
        leave;

    // Get Past leading \\ or \\server\printer

    pPrinterName = pMachineName + 2;

    pPrinterName = wcschr( pPrinterName, L'\\' );

    //
    //  If this is a \\ServerName or contains ,XcvPort or ,XcvMonitor then don't bother with Cache
    //
    if ( pPrinterName == NULL ||
         wcsstr(pPrinterName, L",XcvPort") ||
         wcsstr(pPrinterName, L",XcvMonitor")) {

        leave;

    } else {

        psz = wcsstr(pName, L",NoCache");

        if (psz) {
            *psz = L'\0';
            leave;
        }
    }

    *pPrinterName = L'\0';

    DBGMSG(DBG_TRACE,("MachineName %ws pName %ws\n", pMachineName, pName));

    //
    //  Does this Machine Exist in the Cache ?
    //

    *phIniSpooler = CacheCreateSpooler( pMachineName , bOpenOnly);

    if ( *phIniSpooler == INVALID_HANDLE_VALUE ) {
        SPLASSERT( GetLastError( ));
        leave;
    }

    //
    // Try to Open the Cached Printer
    //

    ReturnValue = ( SplOpenPrinter( pName ,
                                    phSplPrinter,
                                    pDefault,
                                    *phIniSpooler,
                                    NULL,
                                    0) == ROUTER_SUCCESS );

 } finally {

    FreeSplStr( pMachineName );

 }

    return  ReturnValue;

}

/*++

Routine Name:

    DoesPolicyAllowPrinterConnectionsToServer

Description:

    Check to see whether policy allows us to connect to the server. The policy
    might allow unrestricted access to point and print, or it might only allow
    us to only point and print within our domain or it might allow us to only
    point and print to a restricted subset of print servers.

Arguments:

    pszQueue                - The queue we are considering allowing point and
                              print on.
    pbAllowPointAndPrint    - If TRUE, we can point and print to the server.

Return Value:

    An HRESULT.

--*/
HRESULT
DoesPolicyAllowPrinterConnectionsToServer(
    IN      PCWSTR              pszQueue,
        OUT BOOL                *pbAllowPointAndPrint
    )
{
    HRESULT hr = pszQueue && pbAllowPointAndPrint ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    BOOL    bAllowPointAndPrint = FALSE;
    HKEY    hKeyUser    = NULL;
    HKEY    hKeyPolicy  = NULL;

    //
    // First, are we on a domain? The policies only apply to domain joined machines.
    //
    if (SUCCEEDED(hr) && gbMachineInDomain)
    {
        DWORD   dwPointAndPrintRestricted       = 0;
        DWORD   dwPointAndPrintInForest         = 1;
        DWORD   dwPointAndPrintTrustedServers   = 0;
        DWORD   Type;
        DWORD   cbData = 0;
        PWSTR   pszServerName = NULL;

        cbData = sizeof(dwPointAndPrintRestricted);

        hr = HResultFromWin32(RegOpenCurrentUser(KEY_READ, &hKeyUser));

        //
        // Next, is the policy on.
        //
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(RegOpenKeyEx(hKeyUser, gszPointAndPrintPolicies, 0, KEY_READ, &hKeyPolicy));
        }

        //
        // Read the value.
        //
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy,
                                                  gszPointAndPrintRestricted,
                                                  NULL,
                                                  &Type,
                                                  (BYTE *)&dwPointAndPrintRestricted,
                                                  &cbData));

            hr = SUCCEEDED(hr) ? (Type == REG_DWORD ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
        }

        if (SUCCEEDED(hr))
        {
            bAllowPointAndPrint = dwPointAndPrintRestricted == 0;

            if (!bAllowPointAndPrint)
            {
                cbData = sizeof(dwPointAndPrintInForest);

                hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy,
                                                      gszPointAndPrintInForest,
                                                      NULL,
                                                      &Type,
                                                      (BYTE *)(&dwPointAndPrintInForest),
                                                      &cbData));

                hr = SUCCEEDED(hr) ? (Type == REG_DWORD ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;

                if (SUCCEEDED(hr))
                {
                    cbData = sizeof(dwPointAndPrintTrustedServers);

                    hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy,
                                                          gszPointAndPrintTrustedServers,
                                                          NULL,
                                                          &Type,
                                                          (BYTE *)(&dwPointAndPrintTrustedServers),
                                                          &cbData));

                    hr = SUCCEEDED(hr) ? (Type == REG_DWORD ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
                }
            }
        }
        else
        {
            //
            // If the policy is unconfigured, we only allow point and print to
            // a machine within the forst.
            //
            hr = S_OK;
        }

        if (SUCCEEDED(hr) && !bAllowPointAndPrint)
        {
            hr = CheckUserPrintAdmin(&bAllowPointAndPrint);
        }

        //
        // If we are still not allowed to point and print we need to get the
        // server name from the queue name.
        //
        if (SUCCEEDED(hr) && !bAllowPointAndPrint)
        {
            hr = GetServerNameFromPrinterName(pszQueue, &pszServerName);
        }

        //
        // If the policy suggests checking against a set of trusted servers,
        // then let's try that. We do this first because it is the faster
        // check.
        //
        if (SUCCEEDED(hr) && dwPointAndPrintTrustedServers && !bAllowPointAndPrint)
        {
            hr = IsServerExplicitlyTrusted(hKeyPolicy, pszServerName, &bAllowPointAndPrint);
        }

        if (SUCCEEDED(hr) && dwPointAndPrintInForest && !bAllowPointAndPrint)
        {
            hr = IsServerInSameForest(pszServerName, &bAllowPointAndPrint);
        }

        FreeSplMem(pszServerName);
    }

    if (SUCCEEDED(hr) && !gbMachineInDomain)
    {
        bAllowPointAndPrint = TRUE;
    }

    if (pbAllowPointAndPrint)
    {
        *pbAllowPointAndPrint = bAllowPointAndPrint;
    }

    if (hKeyPolicy)
    {
        RegCloseKey(hKeyPolicy);
    }

    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }

    return hr;
}

/*++

Routine Name:

    IsServerExplicitlyTrusted

Description:

    Returns whether the server is in the semi-colon separated list of explicitely
    trusted servers as read from the policy key. We always use fully qualified
    DNS names for two reasons:

    1. It prevents the admin having to type in all the possible variants that a
       user might type.
    2. It prevents the user getting away with specifying another name that maps
       within their DNS search path.

Arguments:

    hKeyPolicy      -   The key under which the policy is located.
    pszServerName   -   The server name. We fully qualify
    pbServerTrusted -   If TRUE, then the server is trusted.

Return Value:

    An HRESULT.

--*/
HRESULT
IsServerExplicitlyTrusted(
    IN      HKEY                hKeyPolicy,
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerTrusted
    )
{
    HRESULT hr = hKeyPolicy && pszServerName && pbServerTrusted ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    PWSTR   pszServerList = NULL;
    PWSTR   pszFullyQualified = NULL;
    BOOL    bServerTrusted = FALSE;
    DWORD   cbData = 0;
    DWORD   Type;

    //
    // Get the list of servers, if this is empty, then no point and print.
    //
    if (SUCCEEDED(hr))
    {
        hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy, gszPointAndPrintServerList, 0, &Type, NULL, &cbData));

        hr = SUCCEEDED(hr) ? (Type == REG_SZ ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
    }

    if (SUCCEEDED(hr))
    {
        pszServerList = AllocSplMem(cbData);

        hr = pszServerList ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    if (SUCCEEDED(hr))
    {
        hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy, gszPointAndPrintServerList, 0, &Type, (BYTE *)pszServerList, &cbData));
    }

    //
    // See if we can get the actual DNS name, this is done through reverse
    // address lookup and is gauranteed to be singular to the machine (of
    // course, the DNS has to have the mapping).
    //
    if (SUCCEEDED(hr))
    {
        hr = GetFullyQualifiedDomainName(pszServerName, &pszFullyQualified);

        //
        // If full reverse lookup failed, just do the best be can with the host
        // name.
        //
        if (hr == HRESULT_FROM_WIN32(WSANO_DATA))
        {
            hr = GetDNSNameFromServerName(pszServerName, &pszFullyQualified);
        }

        //
        // OK, we could not get the fully qualified name, just use whatever
        // name is specified.
        //
        if (FAILED(hr))
        {
            pszFullyQualified = AllocSplStr(pszServerName);

            hr = pszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }
    }

    //
    // Run the fully qualified server name against the list in the registry.
    //
    if (SUCCEEDED(hr))
    {
        PWSTR   pszServerStart      = pszServerList;
        PWSTR   pszServerEnd        = NULL;
        SIZE_T  cchFullyQualified   = 0;

        cchFullyQualified = wcslen(pszFullyQualified);

        for(pszServerEnd = wcschr(pszServerStart, L';'); !bServerTrusted;
            pszServerStart = pszServerEnd, pszServerEnd = wcschr(pszServerStart, L';'))
        {
            if (pszServerEnd)
            {
                //
                // Are the names exactly the same? (Case insensitive comparison).
                //
                if (pszServerEnd - pszServerStart == cchFullyQualified)
                {
                    bServerTrusted = !_wcsnicmp(pszFullyQualified, pszServerStart, cchFullyQualified);
                }

                //
                // Skip past the ; to the next server name.
                //
                pszServerEnd++;
            }
            else
            {
                bServerTrusted = !_wcsicmp(pszFullyQualified, pszServerStart);

                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *pbServerTrusted = bServerTrusted;
    }

    FreeSplMem(pszServerList);
    FreeSplMem(pszFullyQualified);

    return hr;
}

/*++

Routine Name:

    IsServerInSameForest

Description:

    This routine determines whether the given server is in the same forest as we
    are.

Arguments:

    pszServerName           -   The server name.
    pbServerInSameForest    -   If TRUE, then the server is in the same forest.

Return Value:

    An HRESULT.

--*/
HRESULT
IsServerInSameForest(
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerInSameForest
    )
{
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD   cchComputerName = COUNTOF(ComputerName) - 1;
    PSID    pSid            = NULL;
    PWSTR   pszDomainName   = NULL;
    DWORD   cbSid           = 0;
    DWORD   cchDomainName   = 0;
    PWSTR   pszFullName     = NULL;
    BOOL    bServerInForest = FALSE;
    BOOL    bSameAddress    = FALSE;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    PUSER_INFO_1            pUserInfo1            = NULL;
    SID_NAME_USE            SidType;
    HRESULT hr = pszServerName && pbServerInSameForest ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // Use the fully qualified DNS name if we can get it. This is to handle
    // dotted notation resolution to the names. If we can't get it, then we
    // just use the passed in name. This requires reverse domain lookup, which
    // might not be available.
    //
    hr = GetFullyQualifiedDomainName(pszServerName, &pszFullName);

    if (SUCCEEDED(hr))
    {
        hr = DnsHostnameToComputerName(pszFullName, ComputerName, &cchComputerName) ? S_OK : GetLastErrorAsHResultAndFail();
    }
    else if (hr == HRESULT_FROM_WIN32(WSANO_DATA))
    {
        hr = DnsHostnameToComputerName(pszServerName, ComputerName, &cchComputerName) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    //
    // Check to see whether the truncated computer name and the server name are
    // the same machine. This is to prevent printserver.hack3rz.org being confused
    // with printserver.mydomain.com.
    //
    if (SUCCEEDED(hr))
    {
        hr = CheckSamePhysicalAddress(pszServerName, ComputerName, &bSameAddress);
    }

    if (SUCCEEDED(hr) && bSameAddress)
    {
        //
        // This is OK, because we subtract 1 from the buffer size when we query,
        // thus, we know we can fit the NULL. The function return the number of
        // characters copied, minus the NULL.
        //
        if (SUCCEEDED(hr))
        {
            ComputerName[cchComputerName++] = L'$';
            ComputerName[cchComputerName] = L'\0';
        }

        if (SUCCEEDED(hr))
        {
            hr = LookupAccountName(NULL, ComputerName, NULL, &cbSid, NULL, &cchDomainName, &SidType) ? S_OK : GetLastErrorAsHResultAndFail();

            //
            // This should only return ERROR_INSUFFICIENT_BUFFER, any other return
            // or a success is a failure.
            //
            hr = hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) ? S_OK : (SUCCEEDED(hr) ? E_FAIL : hr);
        }

        if (SUCCEEDED(hr))
        {
            pszDomainName = AllocSplMem(cchDomainName * sizeof(WCHAR));
            pSid          = AllocSplMem(cbSid);

            hr = pszDomainName && pSid ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        if (SUCCEEDED(hr))
        {
            hr = LookupAccountName(NULL, ComputerName, pSid, &cbSid, pszDomainName, &cchDomainName, &SidType) ? S_OK : GetLastErrorAsHResultAndFail();
        }

        //
        // COMPUTER$ accounts are returned as user accounts when looked up, we don't
        // want a disabled or inactive account.
        //
        if (SUCCEEDED(hr) && SidType == SidTypeUser)
        {
            //
            // The account must be active. Otherwise I could create a workgroup machine
            // with the same name as an inactive account and fox the system that way.
            //
            hr = HResultFromWin32(DsGetDcName(NULL, pszDomainName, NULL, NULL, DS_IS_FLAT_NAME | DS_RETURN_DNS_NAME, &pDomainControllerInfo));

            if (SUCCEEDED(hr))
            {
                hr = HResultFromWin32(NetUserGetInfo(pDomainControllerInfo->DomainControllerName, ComputerName, 1, (BYTE **)(&pUserInfo1)));
            }

            //
            // The account cannot be locked out or disabled.
            //
            if (SUCCEEDED(hr))
            {
                bServerInForest = !(pUserInfo1->usri1_flags & (UF_LOCKOUT | UF_ACCOUNTDISABLE));
            }
        }
    }

    if (pbServerInSameForest)
    {
        *pbServerInSameForest = bServerInForest;
    }

    if (pUserInfo1)
    {
        NetApiBufferFree(pUserInfo1);
    }

    if (pDomainControllerInfo)
    {
        NetApiBufferFree(pDomainControllerInfo);
    }

    FreeSplMem(pszDomainName);
    FreeSplMem(pSid);
    FreeSplMem(pszFullName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\util.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Routing Layer and
    the local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/
#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <dsrole.h>
#include <commctrl.h>
#include <winddiui.h>
#include <winspool.h>
#include <w32types.h>
#include <local.h>
#include <string.h>
#include <stdlib.h>
#include <splcom.h>
#include <splapip.h>
#include <offsets.h>

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

// used to break infinite loop in ConvertDevMode
LPCWSTR pszCnvrtdmToken = L",DEVMODE";
LPCWSTR pszDrvConvert = L",DrvConvert";

DWORD
Win32IsOlderThan(
    DWORD i,
    DWORD j
    );


VOID
SplInSem(
   VOID
)
{
    if (SpoolerSection.OwningThread != (HANDLE) ULongToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Not in spooler semaphore\n"));
    }
}

VOID
SplOutSem(
   VOID
)
{
    if (SpoolerSection.OwningThread == (HANDLE) ULongToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Inside spooler semaphore !!\n"));
    }
}


#if DBG
DWORD   dwLeave = 0;
DWORD   dwEnter = 0;
#endif

VOID
EnterSplSem(
   VOID
)
{
#if DBG
    LPDWORD  pRetAddr;
#endif
    EnterCriticalSection(&SpoolerSection);
#if i386
#if DBG
    pRetAddr = (LPDWORD)&pRetAddr;
    pRetAddr++;
    pRetAddr++;
    dwEnter = *pRetAddr;
#endif
#endif
}

VOID
LeaveSplSem(
   VOID
)
{
#if i386
#if DBG
    LPDWORD  pRetAddr;
    pRetAddr = (LPDWORD)&pRetAddr;
    pRetAddr++;
    pRetAddr++;
    dwLeave = *pRetAddr;
#endif
#endif
    SplInSem();
    LeaveCriticalSection(&SpoolerSection);
}


PWINIPORT
FindPort(
   LPWSTR pName,
   PWINIPORT pFirstPort
)
{
   PWINIPORT pIniPort;

   pIniPort = pFirstPort;

   if (pName) {
      while (pIniPort) {

         if (!lstrcmpi( pIniPort->pName, pName )) {
            return pIniPort;
         }

      pIniPort=pIniPort->pNext;
      }
   }

   return FALSE;
}


BOOL
MyName(
    LPWSTR   pName
)
{
    if (!pName || !*pName)
        return TRUE;

    if (*pName == L'\\' && *(pName+1) == L'\\')
        if (!lstrcmpi(pName, szMachineName))
            return TRUE;

    return FALSE;
}


/*++

Routine Description

    Determines whether or not a machine name contains the local machine name.

    Localspl enum calls fail if pName != local machine name (\\Machine).
    Remote enum provider is then called.  The remote enum provider must check
    if the UNC name refers to the local machine, and fail if it does to avoid
    endless recursion.

Arguments:

    LPWSTR pName - UNC name.

Return Value:

    TRUE:   pName == \\szMachineName\...
                  - or -
            pName == \\szMachineName

    FALSE:  anything else

Author: swilson

 --*/

BOOL
CheckMyName(
    PWSTR   pNameStart
)
{
    PWCHAR pMachine;
    LPWSTR pName;
    DWORD i;

    SplInSem();

    if (VALIDATE_NAME(pNameStart)) {
        for (i = 0 , pName = pNameStart + 2 ; i < gcOtherNames ; ++i , pName = pNameStart + 2) {
            for(pMachine = gppszOtherNames[i] ;
                *pName && towupper(*pName) == towupper(*pMachine) ;
                ++pName, ++pMachine)
                ;

            if(!*pMachine && (!*pName || *pName == L'\\'))
                return TRUE;
        }
    }

    return FALSE;
}

BOOL
RefreshMachineNamesCache(
)
{
    PWSTR   *ppszOtherNames;
    DWORD   cOtherNames;

    SplInSem();

    //
    // Get other machine names first.  Only if it succeeds do we replace the cache.
    //
    if (!BuildOtherNamesFromMachineName(&ppszOtherNames, &cOtherNames))
        return FALSE;

    FreeOtherNames(&gppszOtherNames, &gcOtherNames);
    gppszOtherNames = ppszOtherNames;
    gcOtherNames = cOtherNames;

    return TRUE;
}


BOOL
MachineNameHasDot(
    PWSTR pName
)
{
    PWSTR psz;

    if (!VALIDATE_NAME(pName))
        return FALSE;

    //
    // pName may be \\Server or \\Server\Printer and we only care about the Server
    //
    for (psz = pName + 2 ; *psz && *psz != L'\\' ; ++psz)
    {
        if (*psz == L'.')
            return TRUE;
    }

    return FALSE;
}


BOOL
MyUNCName(
    PWSTR   pName
)
{
    BOOL bRet;

    EnterSplSem();

    if (!(bRet = CheckMyName(pName)) && MachineNameHasDot(pName) && RefreshMachineNamesCache())
    {
        bRet = CheckMyName(pName);
    }

    LeaveSplSem();

    return bRet;
}



#define MAX_CACHE_ENTRIES       20

LMCACHE LMCacheTable[MAX_CACHE_ENTRIES];


DWORD
FindEntryinLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    )
{
    DWORD i;

    DBGMSG(DBG_TRACE, ("FindEntryinLMCache with %ws and %ws\n", pServerName, pShareName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(LMCacheTable[i].szServerName, pServerName)
                        && !_wcsicmp(LMCacheTable[i].szShareName, pShareName)) {
                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&LMCacheTable[i].st);

                //
                //
                //
                DBGMSG(DBG_TRACE, ("FindEntryinLMCache returning with %d\n", i));
                return(i);
            }
        }
    }

    DBGMSG(DBG_TRACE, ("FindEntryinLMCache returning with -1\n"));
    return((DWORD)-1);
}


DWORD
AddEntrytoLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    )
{

    DWORD LRUEntry = (DWORD)-1;
    DWORD i;
    DBGMSG(DBG_TRACE, ("AddEntrytoLMCache with %ws and %ws\n", pServerName, pShareName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (!LMCacheTable[i].bAvailable) {
            LMCacheTable[i].bAvailable = TRUE;
            wcscpy(LMCacheTable[i].szServerName, pServerName);
            wcscpy(LMCacheTable[i]. szShareName, pShareName);
            //
            // update the time stamp so that we know when this entry was made
            //
            GetSystemTime(&LMCacheTable[i].st);
            DBGMSG(DBG_TRACE, ("AddEntrytoLMCache returning with %d\n", i));
            return(i);
        } else {
            if ((LRUEntry == (DWORD)-1) ||
                    (i == IsOlderThan(i, LRUEntry))){
                        LRUEntry = i;
            }
        }

    }
    //
    // We have no available entries, replace with the
    // LRU Entry

    LMCacheTable[LRUEntry].bAvailable = TRUE;
    wcscpy(LMCacheTable[LRUEntry].szServerName, pServerName);
    wcscpy(LMCacheTable[LRUEntry].szShareName, pShareName);
    DBGMSG(DBG_TRACE, ("AddEntrytoLMCache returning with %d\n", LRUEntry));
    return(LRUEntry);
}


VOID
DeleteEntryfromLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    )
{
    DWORD i;
    DBGMSG(DBG_TRACE, ("DeleteEntryFromLMCache with %ws and %ws\n", pServerName, pShareName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {
        if (LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(LMCacheTable[i].szServerName, pServerName)
                        && !_wcsicmp(LMCacheTable[i].szShareName, pShareName)) {
                //
                //  reset the available flag on this node
                //

                LMCacheTable[i].bAvailable = FALSE;
                DBGMSG(DBG_TRACE, ("DeleteEntryFromLMCache returning after deleting the %d th entry\n", i));
                return;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("DeleteEntryFromLMCache returning after not finding an entry to delete\n"));
}



DWORD
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;

    DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));
    pi = &(LMCacheTable[i].st);
    pj = &(LMCacheTable[j].st);
    DBGMSG(DBG_TRACE, ("Index i %d - %d:%d:%d:%d:%d:%d:%d\n",
        i, pi->wYear, pi->wMonth, pi->wDay, pi->wHour, pi->wMinute, pi->wSecond, pi->wMilliseconds));


    DBGMSG(DBG_TRACE,("Index j %d - %d:%d:%d:%d:%d:%d:%d\n",
        j, pj->wYear, pj->wMonth, pj->wDay, pj->wHour, pj->wMinute, pj->wSecond, pj->wMilliseconds));

    if (pi->wYear < pj->wYear) {
        DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
        return(j);
    } else if (pi->wMonth < pj->wMonth) {
        DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
            return(j);
        }
    }
}



WIN32LMCACHE  Win32LMCacheTable[MAX_CACHE_ENTRIES];

DWORD
FindEntryinWin32LMCache(
    LPWSTR pServerName
    )
{
    DWORD i;
    DBGMSG(DBG_TRACE, ("FindEntryinWin32LMCache with %ws\n", pServerName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (Win32LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(Win32LMCacheTable[i].szServerName, pServerName)) {
                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&Win32LMCacheTable[i].st);

                //
                //
                //
                DBGMSG(DBG_TRACE, ("FindEntryinWin32LMCache returning with %d\n", i));
                return(i);
            }
        }
    }
    DBGMSG(DBG_TRACE, ("FindEntryinWin32LMCache returning with -1\n"));
    return((DWORD)-1);
}


DWORD
AddEntrytoWin32LMCache(
    LPWSTR pServerName
    )
{

    DWORD LRUEntry = (DWORD)-1;
    DWORD i;
    DBGMSG(DBG_TRACE, ("AddEntrytoWin32LMCache with %ws\n", pServerName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (!Win32LMCacheTable[i].bAvailable) {
            Win32LMCacheTable[i].bAvailable = TRUE;
            wcscpy(Win32LMCacheTable[i].szServerName, pServerName);
            //
            // update the time stamp so that we know when this entry was made
            //
            GetSystemTime(&Win32LMCacheTable[i].st);
            DBGMSG(DBG_TRACE, ("AddEntrytoWin32LMCache returning with %d\n", i));
            return(i);
        } else {
            if ((LRUEntry == -1) ||
                    (i == Win32IsOlderThan(i, LRUEntry))){
                        LRUEntry = i;
            }
        }

    }
    //
    // We have no available entries, replace with the
    // LRU Entry

    Win32LMCacheTable[LRUEntry].bAvailable = TRUE;
    wcscpy(Win32LMCacheTable[LRUEntry].szServerName, pServerName);
    DBGMSG(DBG_TRACE, ("AddEntrytoWin32LMCache returning with %d\n", LRUEntry));
    return(LRUEntry);
}


VOID
DeleteEntryfromWin32LMCache(
    LPWSTR pServerName
    )
{
    DWORD i;

    DBGMSG(DBG_TRACE, ("DeleteEntryFromWin32LMCache with %ws\n", pServerName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {
        if (Win32LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(Win32LMCacheTable[i].szServerName, pServerName)) {
                //
                //  reset the available flag on this node
                //

                Win32LMCacheTable[i].bAvailable = FALSE;
                DBGMSG(DBG_TRACE, ("DeleteEntryFromWin32LMCache returning after deleting the %d th entry\n", i));
                return;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("DeleteEntryFromWin32LMCache returning after not finding an entry to delete\n"));
}



DWORD
Win32IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    DBGMSG(DBG_TRACE, ("Win32IsOlderThan entering with i %d j %d\n", i, j));
    pi = &(Win32LMCacheTable[i].st);
    pj = &(Win32LMCacheTable[j].st);
    DBGMSG(DBG_TRACE, ("Index i %d - %d:%d:%d:%d:%d:%d:%d\n",
        i, pi->wYear, pi->wMonth, pi->wDay, pi->wHour, pi->wMinute, pi->wSecond, pi->wMilliseconds));


    DBGMSG(DBG_TRACE,("Index j %d - %d:%d:%d:%d:%d:%d:%d\n",
        j, pj->wYear, pj->wMonth, pj->wDay, pj->wHour, pj->wMinute, pj->wSecond, pj->wMilliseconds));

    if (pi->wYear < pj->wYear) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wMonth < pj->wMonth) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
            return(i);
        } else {
            DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}


BOOL
GetSid(
    PHANDLE phToken
)
{
    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken)) {

        DBGMSG(DBG_WARNING, ("OpenThreadToken failed: %d\n", GetLastError()));
        return FALSE;

    } else {

        return TRUE;
    }
}



BOOL
SetCurrentSid(
    HANDLE  hToken
)
{
#if DBG
    WCHAR UserName[256];
    DWORD cbUserName=256;

    if( MODULE_DEBUG & DBG_TRACE )
            GetUserName(UserName, &cbUserName);

    DBGMSG(DBG_TRACE, ("SetCurrentSid BEFORE: user name is %ws\n", UserName));
#endif

    NtSetInformationThread(NtCurrentThread(), ThreadImpersonationToken,
                               &hToken, sizeof(hToken));

#if DBG
    cbUserName = 256;

    if( MODULE_DEBUG & DBG_TRACE )
            GetUserName(UserName, &cbUserName);

    DBGMSG(DBG_TRACE, ("SetCurrentSid AFTER: user name is %ws\n", UserName));
#endif

    return TRUE;
}

BOOL
ValidateW32SpoolHandle(
    PWSPOOL pSpool
)
{
    SplOutSem();
    try {
        if (!pSpool || (pSpool->signature != WSJ_SIGNATURE)) {

            DBGMSG( DBG_TRACE, ("ValidateW32SpoolHandle error invalid handle %x\n", pSpool));

            SetLastError(ERROR_INVALID_HANDLE);
            return(FALSE);
        }
        return(TRUE);
    } except (1) {
        DBGMSG( DBG_TRACE, ("ValidateW32SpoolHandle error invalid handle %x\n", pSpool));
        return(FALSE);
    }
}

BOOL
ValidRawDatatype(
    LPCWSTR pszDatatype
    )
{
    if( !pszDatatype || _wcsnicmp( pszDatatype, pszRaw, 3 )){
        return FALSE;
    }
    return TRUE;
}

HANDLE
LoadDriverFiletoConvertDevmodeFromPSpool(
    HANDLE  hSplPrinter
    )
/*++
    Finds out full path to the driver file and creates a DEVMODECHG_INFO
    (which does a LoadLibrary)

Arguments:
    h   : A cache handle

Return Value:
    On succes a valid pointer, else NULL
--*/
{
    LPBYTE              pDriver = NULL;
    LPWSTR              pConfigFile;
    HANDLE              hDevModeChgInfo = NULL;
    DWORD               dwNeeded;
    DWORD               dwServerMajorVersion = 0, dwServerMinorVersion = 0;

    if ( hSplPrinter == INVALID_HANDLE_VALUE ) {

        SPLASSERT(hSplPrinter != INVALID_HANDLE_VALUE);
        return NULL;
    }


    SplGetPrinterDriverEx(hSplPrinter,
                          szEnvironment,
                          2,
                          NULL,
                          0,
                          &dwNeeded,
                          cThisMajorVersion,
                          cThisMinorVersion,
                          &dwServerMajorVersion,
                          &dwServerMinorVersion);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Cleanup;

    pDriver = AllocSplMem(dwNeeded);

    if ( !pDriver ||
         !SplGetPrinterDriverEx(hSplPrinter,
                                szEnvironment,
                                2,
                                (LPBYTE)pDriver,
                                dwNeeded,
                                &dwNeeded,
                                cThisMajorVersion,
                                cThisMinorVersion,
                                &dwServerMajorVersion,
                                &dwServerMinorVersion) )
        goto Cleanup;

    pConfigFile = ((LPDRIVER_INFO_2)pDriver)->pConfigFile;
    hDevModeChgInfo = LoadDriverFiletoConvertDevmode(pConfigFile);

Cleanup:

    if ( pDriver )
        FreeSplMem(pDriver);

    return hDevModeChgInfo;
}

BOOL
DoDevModeConversionAndBuildNewPrinterInfo2(
    IN     LPPRINTER_INFO_2 pInPrinter2,
    IN     DWORD            dwInSize,
    IN OUT LPBYTE           pOutBuf,
    IN     DWORD            dwOutSize,
    IN OUT LPDWORD          pcbNeeded,
    IN     PWSPOOL          pSpool
    )
/*++
    Calls driver to do a devmode conversion and builds a new printer info 2.

    Devmode is put at the end and then strings are packed from there.


Arguments:

    pInPrinter2 - Printer Info2 structure with devmode info

    dwInSize    - Number of characters needed to pack info in pInPrinter
                  (not necessarily the size of the input buffer)

    dwOutSize   - buffer size

    pOutBuf    - Buffer to do the operation

    pcbNeeded   - Amount of memory copied (in characters)

    pSpool      - Points to w32 handle


Return Value:
    TRUE    on success, FALSE on error

--*/
{
    BOOL                bReturn = FALSE;
    LPDEVMODE           pNewDevMode = NULL, pCacheDevMode, pInDevMode;
    DWORD               dwDevModeSize, dwSecuritySize, dwNeeded = 0;
    HANDLE              hDevModeChgInfo = NULL;

    LPWSTR              SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR             *pSourceStrings=SourceStrings;
    LPDWORD             pOffsets;
    LPBYTE              pEnd;
    PWCACHEINIPRINTEREXTRA  pExtraData;

    LPWSTR              pPrinterName = NULL;

    VALIDATEW32HANDLE(pSpool);

    pInDevMode = pInPrinter2->pDevMode;

    if ( !pInDevMode || pSpool->hSplPrinter == INVALID_HANDLE_VALUE ) {

        goto AfterDevModeConversion;
    }

    if ( !SplGetPrinterExtra(pSpool->hSplPrinter,
                             &(PBYTE)pExtraData) ) {

        DBGMSG(DBG_ERROR,
                ("DoDevModeConversionAndBuildNewPrinterInfo2: SplGetPrinterExtra error %d\n",
                 GetLastError()));
        goto AfterDevModeConversion;
    }

    //
    // Only time we do not have to convert devmode is if the server is running
    // same version NT and also we have a devmode which matches the server
    // devmode in dmSize, dmDriverExtra, dmSpecVersion, and dmDriverVersion
    //
    pCacheDevMode = pExtraData->pPI2 ? pExtraData->pPI2->pDevMode : NULL;
    if ( (pExtraData->dwServerVersion == gdwThisGetVersion ||
          (pSpool->Status & WSPOOL_STATUS_CNVRTDEVMODE))                     &&
         pCacheDevMode                                                      &&
         pInDevMode->dmSize             == pCacheDevMode->dmSize            &&
         pInDevMode->dmDriverExtra      == pCacheDevMode->dmDriverExtra     &&
         pInDevMode->dmSpecVersion      == pCacheDevMode->dmSpecVersion     &&
         pInDevMode->dmDriverVersion    == pCacheDevMode->dmDriverVersion ) {

        dwDevModeSize = pInDevMode->dmSize + pInDevMode->dmDriverExtra;
        dwNeeded = dwInSize;
        if ( dwOutSize < dwNeeded ) {

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Cleanup;
        }

        //
        // Put DevMode at the end
        //
        pNewDevMode = (LPDEVMODE)(pOutBuf + dwOutSize - dwDevModeSize);
        CopyMemory((LPBYTE)pNewDevMode,
                   (LPBYTE)pInDevMode,
                   dwDevModeSize);
        goto AfterDevModeConversion;
    }


    hDevModeChgInfo = LoadDriverFiletoConvertDevmodeFromPSpool(pSpool->hSplPrinter);

    if ( !hDevModeChgInfo )
        goto AfterDevModeConversion;

    dwDevModeSize = 0;

    SPLASSERT( pSpool->pName != NULL );

    //
    // Append ,DEVMODE to end of pSpool->pName
    //
    pPrinterName = AllocSplMem((lstrlen(pSpool->pName) + lstrlen(pszCnvrtdmToken) + 1) * sizeof pPrinterName[0]);
    if ( !pPrinterName )
        goto Cleanup;

    wcscpy(pPrinterName,pSpool->pName);
    wcscat(pPrinterName,pszCnvrtdmToken);

    //
    // Findout size of default devmode
    //
    if ( ERROR_INSUFFICIENT_BUFFER != CallDrvDevModeConversion(hDevModeChgInfo,
                                                               pPrinterName,
                                                               NULL,
                                                               (LPBYTE *)&pNewDevMode,
                                                               &dwDevModeSize,
                                                               CDM_DRIVER_DEFAULT,
                                                               FALSE)  )
        goto AfterDevModeConversion;

    //
    // Findout size needed to have current version devmode
    //
    dwNeeded = dwInSize + dwDevModeSize - pInDevMode->dmSize
                                        - pInDevMode->dmDriverExtra;

    if ( dwOutSize < dwNeeded ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    //
    // Put DevMode at the end
    //
    pNewDevMode = (LPDEVMODE)(pOutBuf + dwOutSize - dwDevModeSize);

    //
    // Get default devmode and then convert remote devmode to that format
    //
    if ( ERROR_SUCCESS != CallDrvDevModeConversion(hDevModeChgInfo,
                                                   pPrinterName,
                                                   NULL,
                                                   (LPBYTE *)&pNewDevMode,
                                                   &dwDevModeSize,
                                                   CDM_DRIVER_DEFAULT,
                                                   FALSE) ||
         ERROR_SUCCESS != CallDrvDevModeConversion(hDevModeChgInfo,
                                                   pPrinterName,
                                                   (LPBYTE)pInDevMode,
                                                   (LPBYTE *)&pNewDevMode,
                                                   &dwDevModeSize,
                                                   CDM_CONVERT,
                                                   FALSE) ) {

        pNewDevMode = NULL;
        goto AfterDevModeConversion;
    }


AfterDevModeConversion:
    //
    // At this point if pNewDevMode != NULL dev mode conversion has been done
    // by the driver. If not either we did not get a devmode or conversion failed
    // In either case set devmode to NULL
    //
    if ( !pNewDevMode ) {

        dwNeeded = dwInSize;

        if ( dwOutSize < dwNeeded ) {

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Cleanup;
        }
    }

    bReturn = TRUE;

    CopyMemory(pOutBuf, (LPBYTE)pInPrinter2, sizeof(PRINTER_INFO_2));
    ((LPPRINTER_INFO_2)pOutBuf)->pDevMode = pNewDevMode;

    pEnd = (pNewDevMode ? (LPBYTE) pNewDevMode
                        : (LPBYTE) (pOutBuf + dwOutSize));


    if ( pInPrinter2->pSecurityDescriptor ) {

        dwSecuritySize = GetSecurityDescriptorLength(
                                pInPrinter2->pSecurityDescriptor);
        pEnd -= dwSecuritySize;
        CopyMemory(pEnd, pInPrinter2->pSecurityDescriptor, dwSecuritySize);
        ((LPPRINTER_INFO_2)pOutBuf)->pSecurityDescriptor =
                                (PSECURITY_DESCRIPTOR) pEnd;
    } else {

        ((LPPRINTER_INFO_2)pOutBuf)->pSecurityDescriptor = NULL;

    }

    pOffsets = PrinterInfo2Strings;

    *pSourceStrings++ = pInPrinter2->pServerName;
    *pSourceStrings++ = pInPrinter2->pPrinterName;
    *pSourceStrings++ = pInPrinter2->pShareName;
    *pSourceStrings++ = pInPrinter2->pPortName;
    *pSourceStrings++ = pInPrinter2->pDriverName;
    *pSourceStrings++ = pInPrinter2->pComment;
    *pSourceStrings++ = pInPrinter2->pLocation;
    *pSourceStrings++ = pInPrinter2->pSepFile;
    *pSourceStrings++ = pInPrinter2->pPrintProcessor;
    *pSourceStrings++ = pInPrinter2->pDatatype;
    *pSourceStrings++ = pInPrinter2->pParameters;

    pEnd = PackStrings(SourceStrings, (LPBYTE)pOutBuf, pOffsets, pEnd);

    SPLASSERT(pEnd > pOutBuf && pEnd < pOutBuf + dwOutSize);

    bReturn = TRUE;

Cleanup:

    *pcbNeeded = dwNeeded;

    if ( hDevModeChgInfo )
        UnloadDriverFile(hDevModeChgInfo);

    if (pPrinterName)
        FreeSplMem(pPrinterName);

    return bReturn;
}



PWSTR
StripString(
    PWSTR pszString,
    PCWSTR pszStrip,
    PCWSTR pszTerminator
)
{
    //
    // Strips the first occurence of pszStrip from pszString if
    // the next character after pszStrip is one of the characters
    // in pszTerminator.  NULL is an implicit terminator, so if you
    // want to strip pszStrip only at the end of pszString, just pass
    // in an empty string for pszTerminator.
    //
    // Returns: Pointer to pszString if pszStrip was found
    //          NULL is pszStrip was not found
    //


    PWSTR    psz;
    DWORD    dwStripLength;

    if (!pszStrip || !pszString || !pszTerminator)
        return NULL;

    dwStripLength = wcslen(pszStrip);

    for(psz = pszString ; psz ;) {

        // find pszStrip in pszString
        if ((psz = wcsstr(psz, pszStrip))) {

            // check for the terminator & strip pszStrip
            if (!*(psz + dwStripLength) || wcschr(pszTerminator, *(psz + dwStripLength))) {
                wcscpy(psz, psz + dwStripLength);
                return pszString;
            } else {
                ++psz;
            }
        }
    }
    return NULL;
}

BOOL
AddDriverFromLocalCab(
    LPTSTR   pszDriverName,
    LPHANDLE pIniSpooler
    )
{
    DRIVER_INFO_7 DriverInfo7;

    if( GetPolicy() & SERVER_INSTALL_ONLY ) {

        return FALSE;
    }

    DriverInfo7.cbSize               = sizeof( DriverInfo7 );
    DriverInfo7.cVersion             = 0;
    DriverInfo7.pszDriverName        = pszDriverName;
    DriverInfo7.pszInfName           = NULL;
    DriverInfo7.pszInstallSourceRoot = NULL;

    return ( SplAddPrinterDriverEx( NULL,
                                    7,
                                    (LPBYTE)&DriverInfo7,
                                    APD_COPY_NEW_FILES,
                                    pIniSpooler,
                                    DO_NOT_USE_SCRATCH_DIR,
                                    FALSE ) );
}

/*++

Routine Name:

    IsAdminAccess

Description:

    This returns whether the given printer defaults are asking for admin access,
    we consider the request to be admin access if the printer defaults are
    non-NULL and have PRINTER_ACCESS_ADMINISTER or WRITE_DAC specified.

Arguments:

    pDefaults   -   The printer defaults, may be NULL.

Return Value:

    None.

--*/
BOOL
IsAdminAccess(
    IN  PRINTER_DEFAULTS    *pDefaults
    )
{
    return pDefaults && (pDefaults->DesiredAccess & (PRINTER_ACCESS_ADMINISTER | WRITE_DAC));
}

/*++

Routine Name:

    AreWeOnADomain

Description:

    This returns whether this machine is a domain joined machine or not.

Arguments:

    pbDomain        -   If TRUE, we are on a domain.

Return Value:

    An HRESULT.

--*/
HRESULT
AreWeOnADomain(
        OUT BOOL                *pbDomain
    )
{
    HRESULT hr = pbDomain ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pRoleInfo = NULL;
    BOOL    bOnDomain = FALSE;

    if (SUCCEEDED(hr))
    {
        hr = HResultFromWin32(DsRoleGetPrimaryDomainInformation(NULL,
                                                                DsRolePrimaryDomainInfoBasic,
                                                                (BYTE **)(&pRoleInfo)));
    }

    if (SUCCEEDED(hr))
    {
        bOnDomain = pRoleInfo->MachineRole == DsRole_RoleMemberWorkstation      ||
                    pRoleInfo->MachineRole == DsRole_RoleMemberServer           ||
                    pRoleInfo->MachineRole == DsRole_RoleBackupDomainController ||
                    pRoleInfo->MachineRole == DsRole_RolePrimaryDomainController;
    }

    if (pRoleInfo)
    {
        DsRoleFreeMemory((VOID *)pRoleInfo);
    }

    if (pbDomain)
    {
        *pbDomain = bOnDomain;
    }

    return hr;
}

/*++

Routine Name:

    GetServerNameFromQueue

Description:

    This returns the server name from the given queue name.

Arguments:

    pszQueue        -   The queue name,
    ppszServerName  -   The server name.

Return Value:

    An HRESULT.

--*/
HRESULT
GetServerNameFromPrinterName(
    IN      PCWSTR              pszQueue,
        OUT PWSTR               *ppszServerName
    )
{
    HRESULT hr = pszQueue && ppszServerName ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    PWSTR   pszServer = NULL;

    if (SUCCEEDED(hr))
    {
        hr = *pszQueue++ == L'\\' && *pszQueue++ == L'\\' ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PRINTER_NAME);
    }

    if (SUCCEEDED(hr))
    {
        pszServer = AllocSplStr(pszQueue);

        hr = pszServer ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    if (SUCCEEDED(hr))
    {
        PWSTR pszSlash = wcschr(&pszServer[2], L'\\');

        //
        // If there was no second slash, then what we have is the server name.
        //
        if (pszSlash)
        {
            *pszSlash = L'\0';
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppszServerName = pszServer;
        pszServer = NULL;
    }

    FreeSplMem(pszServer);

    return hr;
}


/*++

Routine Name:

    GetDNSNameFromServerName

Description:

    This returns a fully qualified DNS name from the server name. It is
    basically copied from localspl because this is dead-end code. In CSR,
    we will fix this properly.

Arguments:

    pszServerName       -   The server name whose fully qualified name we are obtaining.
    ppszFullyQualified  -

Return Value:

    An HRESULT.

--*/
HRESULT
GetDNSNameFromServerName(
    IN      PCWSTR       pszServerName,
        OUT PWSTR        *ppszFullyQualified
    )
{
    PSTR    pszAnsiMachineName = NULL;
    struct  hostent  *pHostEnt;
    WORD    wVersion;
    WSADATA WSAData;
    HRESULT hr =  pszServerName && *pszServerName && ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);


    PWSTR   pszDummy = NULL;
    GetFullyQualifiedDomainName(pszServerName, &pszDummy);

    if (SUCCEEDED(hr))
    {
        wVersion = MAKEWORD(1, 1);

        hr = HResultFromWin32(WSAStartup(wVersion, &WSAData));
    }

    if (SUCCEEDED(hr))
    {
        hr = UnicodeToAnsiString(pszServerName, &pszAnsiMachineName);

        if (SUCCEEDED(hr))
        {
            pHostEnt = gethostbyname(pszAnsiMachineName);

            hr = pHostEnt ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        if (SUCCEEDED(hr))
        {
            *ppszFullyQualified = AnsiToUnicodeStringWithAlloc(pHostEnt->h_name);

            hr = *ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        WSACleanup();
    }

    FreeSplMem(pszAnsiMachineName);

    return hr;
}

/*++

Routine Name:

    UnicodeToAnsiString

Routine Description:

    This allocates an ANSI string and converts it using the thread's codepage.

Arguments:

    pszUnicode      -   The incoming, non-NULL, NULL terminated unicode string.
    ppszAnsi        -   The returned ANSI string.

Return Value:

    An HRESULT

--*/
HRESULT
UnicodeToAnsiString(
    IN      PCWSTR          pszUnicode,
        OUT PSTR            *ppszAnsi
    )
{
    HRESULT hRetval          = E_FAIL;
    PSTR    pszAnsi          = NULL;
    INT     AnsiStringLength = 0;

    hRetval = pszUnicode && ppszAnsi ? S_OK : E_INVALIDARG;

    if (ppszAnsi)
    {
        *ppszAnsi = NULL;
    }

    if (SUCCEEDED(hRetval))
    {
        AnsiStringLength = WideCharToMultiByte(CP_THREAD_ACP, 0, pszUnicode, -1, NULL, 0, NULL, NULL);

        hRetval = AnsiStringLength != 0 ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        pszAnsi = AllocSplMem(AnsiStringLength);

        hRetval = pszAnsi ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = WideCharToMultiByte(CP_THREAD_ACP, 0, pszUnicode, -1, pszAnsi, AnsiStringLength, NULL, NULL) != 0 ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        *ppszAnsi = pszAnsi;
        pszAnsi = NULL;
    }

    FreeSplMem(pszAnsi);

    return hRetval;
}

/*++

Routine Name:

    AnsiToUnicodeStringWithAlloc

Description:

    Convert ANSI string to UNICODE. Routine allocates memory from the heap
    which should be freed by the caller.

Arguments:

    pAnsi    - Points to the ANSI string

Return Value:

    Pointer to UNICODE string

--*/
LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    )
{
    LPWSTR  pUnicode;
    DWORD   rc;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             NULL,
                             0);

    rc *= sizeof(WCHAR);
    if ( !rc || !(pUnicode = (LPWSTR) AllocSplMem(rc)) )
        return NULL;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             pUnicode,
                             rc);

    if ( rc )
        return pUnicode;
    else {
        FreeSplMem(pUnicode);
        return NULL;
    }
}

/*++

Routine Name:

    CheckSamePhysicalAddress

Description:

    This checks to see whether two servers share a same network address. What it
    does is check to see whether the first physical network address of the first
    print server can be found in the list of addresses supported by the second
    print server.

Arguments:

    pszServer1      - The first server in the list.
    pszServer2      - The second server in the list.
    pbSameAddress   - If TRUE, the first physical address of server1 can be found
                      in server2.

Return Value:

    An HRESULT.

--*/
HRESULT
CheckSamePhysicalAddress(
    IN      PCWSTR              pszServer1,
    IN      PCWSTR              pszServer2,
        OUT BOOL                *pbSameAddress
    )
{
    BOOL        bSameAddress    = FALSE;
    PSTR        pszAnsiServer1  = NULL;
    PSTR        pszAnsiServer2  = NULL;
    ADDRINFO    *pAddrInfo1     = NULL;
    ADDRINFO    *pAddrInfo2     = NULL;
    WSADATA     WSAData;
    WORD        wVersion;
    HRESULT     hr = pszServer1 && pszServer2 && pbSameAddress ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        wVersion = MAKEWORD(1, 1);

        hr = HResultFromWin32(WSAStartup(wVersion, &WSAData));
    }

    if (SUCCEEDED(hr))
    {
        ADDRINFO    *pAddrInfoScan = NULL;

        hr = UnicodeToAnsiString(pszServer1, &pszAnsiServer1);

        if (SUCCEEDED(hr))
        {
            hr = UnicodeToAnsiString(pszServer2, &pszAnsiServer2);
        }

        if (SUCCEEDED(hr))
        {
            hr = getaddrinfo(pszAnsiServer1, NULL, NULL, &pAddrInfo1) == 0 ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        if (SUCCEEDED(hr))
        {
            hr = getaddrinfo(pszAnsiServer2, NULL, NULL, &pAddrInfo2) == 0 ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        //
        // OK, now for the hokey bit, we check to see whether we can exactly
        // match the first element in pAddrInfo1 anywhere in pAddrInfo2.
        //
        for(pAddrInfoScan =  pAddrInfo2; pAddrInfo2 && !bSameAddress; pAddrInfo2 = pAddrInfo2->ai_next)
        {
            //
            // If the lengths of the addresses are the same, then compare the
            // actual addresses.
            //
            if (pAddrInfoScan->ai_addrlen == pAddrInfo1->ai_addrlen &&
                !memcmp(pAddrInfoScan->ai_addr, pAddrInfo1->ai_addr, pAddrInfoScan->ai_addrlen))
            {
                bSameAddress = TRUE;
            }
        }

        freeaddrinfo(pAddrInfo1);
        freeaddrinfo(pAddrInfo2);

        WSACleanup();
    }

    if (pbSameAddress)
    {
        *pbSameAddress = bSameAddress;
    }

    FreeSplMem(pszAnsiServer1);
    FreeSplMem(pszAnsiServer2);

    return hr;
}

/*++

Routine Name:

    CheckUserPrintAdmin

Description:

    This checks to see whether the given user is a print admin.

Arguments:

    pbUserAdmin     -   If TRUE, the user is a print admin.

Return Value:

    An HRESULT.

--*/
HRESULT
CheckUserPrintAdmin(
        OUT BOOL                *pbUserAdmin
    )
{
    //
    // Check to see whether the caller has access to the local print
    // server, if we do have access, then we allow point and print.
    //
    HANDLE              hServer = NULL;
    PRINTER_DEFAULTS    Defaults = {NULL, NULL, SERVER_ACCESS_ADMINISTER };
    HRESULT             hr       = pbUserAdmin ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // This actually calls into the router and not into winspool.drv.
    //
    if (SUCCEEDED(hr))
    {
    }
    hr = OpenPrinterW(NULL, &hServer, &Defaults) ? S_OK : GetLastErrorAsHResultAndFail();

    if (SUCCEEDED(hr))
    {
         *pbUserAdmin = TRUE;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
    {
        *pbUserAdmin = FALSE;

        hr = S_OK;
    }

    if (hServer)
    {
        ClosePrinter(hServer);
    }

    return hr;
}

/*++

Routine Name:

    GetFullyQualifiedDomainName

Description:

    This returns a truly fully qualified name, being the name that the endpoint
    expects to use, or

Arguments:

    pszServerName       -   The server name whose fully qualified name we are obtaining.
    ppszFullyQualified  -   The returned fully qualified name.

Return Value:

    An HRESULT.

--*/
HRESULT
GetFullyQualifiedDomainName(
    IN      PCWSTR      pszServerName,
        OUT PWSTR       *ppszFullyQualified
    )
{
    WORD    wVersion;
    WSADATA WSAData;
    PSTR    pszAnsiMachineName = NULL;
    HRESULT hr =  pszServerName && *pszServerName && ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        wVersion = MAKEWORD(1, 1);

        hr = HResultFromWin32(WSAStartup(wVersion, &WSAData));
    }

    if (SUCCEEDED(hr))
    {
        ADDRINFO    *pAddrInfo = NULL;
        CHAR        HostName[NI_MAXHOST];

        hr = UnicodeToAnsiString(pszServerName, &pszAnsiMachineName);

        if (SUCCEEDED(hr))
        {
            hr = getaddrinfo(pszAnsiMachineName, NULL, NULL, &pAddrInfo) == 0 ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        //
        // Now the we have a socket addr, do a reverse name lookup on the name.
        //
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(getnameinfo(pAddrInfo->ai_addr, pAddrInfo->ai_addrlen, HostName, sizeof(HostName), NULL, 0, NI_NAMEREQD));
        }

        if (SUCCEEDED(hr))
        {
            *ppszFullyQualified = AnsiToUnicodeStringWithAlloc(HostName);

            hr = *ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        if (pAddrInfo)
        {
            freeaddrinfo(pAddrInfo);
        }

        WSACleanup();
    }

    FreeSplMem(pszAnsiMachineName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\winsplc.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Stub file to allow winspl_c.c to work with precompiled headers.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "winspl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\cab\sources.inc ===
!IF 0
/*---------------------------------------------------------------------------*\
| MODULE: sources
|
|
| history:
|   15-Dec-1997 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
!ENDIF

TARGETNAME      =
TARGETTYPE      = NOTARGET
TARGETPATH      =
SOURCES_OPTIONS = -c0
SOURCES         =

SOURCES_USED    = ..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\wtoa.c ===
/*++

 Copyright (c) 1990-2000  Microsoft Corporation

 Module Name:

     wtoa.c

 Abstract:

     This module provides all the public exported APIs relating to Printer
     and Job management for the Local Print Providor

 --*/

#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>


#define NULL_TERMINATED 0

/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 */
INT AnsiToUnicodeString( LPSTR pAnsi, LPWSTR pUnicode, DWORD StringLength )
{
    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    return MultiByteToWideChar( CP_ACP,
                                MB_PRECOMPOSED,
                                pAnsi,
                                StringLength + 1,
                                pUnicode,
                                StringLength + 1 );
}

LPWSTR
AllocateUnicodeString(
    LPSTR   pPrinterName
)
{
    LPWSTR  pUnicodeString;

    if (!pPrinterName)
        return NULL;

    pUnicodeString = LocalAlloc(LPTR, strlen(pPrinterName)*sizeof(WCHAR) +
                                      sizeof(WCHAR));

    if (pUnicodeString)
        AnsiToUnicodeString(pPrinterName, pUnicodeString, NULL_TERMINATED);

    return pUnicodeString;
}


LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
)
{
    if (!pUnicodeString)
        return NULL;

    return LocalFree(pUnicodeString);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\cab\win95\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
#***************************************************************************/

buildall:
    cd..   
    nmake /f makefile.inc
    cd $(ALT_PROJECT_TARGET)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\win32\win32.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation
All rights reserved

Module Name:

    win32 provider (win32spl)

Abstract:

Author:
    DaveSn

Environment:

    User Mode -Win32

Revision History:

    Matthew A Felton (Mattfe) July 16 1994
    Added Caching for remote NT printers
    MattFe Jan 1995 CleanUp DeletePrinterConnection ( for memory allocation errors )
    SWilson May 1996 Added RemoteEnumPrinterData & RemoteDeletePrinterData
    SWilson Dec 1996 Added RemoteDeletePrinterDataEx, RemoteGetPrinterDataEx,
                           RemoteSetPrinterDataEx, RemoteEnumPrinterDataEx,
                           RemoteEnumPrinterKey, RemoteDeletePrinterKey

--*/

#include <precomp.h>
#pragma hdrstop


DWORD
RpcValidate(
    );

BOOL
RemoteFindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID pvReserved0,
   PVOID pvReserved1);

BOOL
RemoteFindClosePrinterChangeNotification(
   HANDLE hPrinter);

BOOL
RemoteRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PVOID* ppPrinterNotifyInfo);

DWORD
RemoteSendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
);

LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    );



HANDLE  hInst;  /* DLL instance handle, used for resources */

#define MAX_PRINTER_INFO2 1000

HANDLE  hNetApi;
NET_API_STATUS (*pfnNetServerEnum)();
NET_API_STATUS (*pfnNetShareEnum)();
NET_API_STATUS (*pfnNetWkstaUserGetInfo)();
NET_API_STATUS (*pfnNetWkstaGetInfo)();
NET_API_STATUS (*pfnNetServerGetInfo)();
NET_API_STATUS (*pfnNetApiBufferFree)();

WCHAR szPrintProvidorName[80];
WCHAR szPrintProvidorDescription[80];
WCHAR szPrintProvidorComment[80];

WCHAR *szLoggedOnDomain=L"Logged on Domain";
WCHAR *szRegistryConnections=L"Printers\\Connections";
WCHAR *szRegistryPath=NULL;
WCHAR *szRegistryPortNames=L"PortNames";
PWCHAR pszRemoteRegistryPrinters = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Printers\\%ws\\PrinterDriverData";
WCHAR  szMachineName[MAX_COMPUTERNAME_LENGTH+3];
LPWSTR *gppszOtherNames;   // Contains szMachineName, DNS name, and all other machine name forms
DWORD  gcOtherNames;

WCHAR *szVersion=L"Version";
WCHAR *szName=L"Name";
WCHAR *szConfigurationFile=L"Configuration File";
WCHAR *szDataFile=L"Data File";
WCHAR *szDriver=L"Driver";
WCHAR *szDevices=L"Devices";
WCHAR *szPrinterPorts=L"PrinterPorts";
WCHAR *szPorts=L"Ports";
WCHAR *szComma = L",";
WCHAR *szRegistryRoot     = L"System\\CurrentControlSet\\Control\\Print";
WCHAR *szMajorVersion     = L"MajorVersion";
WCHAR *szMinorVersion     = L"MinorVersion";

// kernel mode is 2.
DWORD cThisMajorVersion = SPOOLER_VERSION;

DWORD cThisMinorVersion = 0;

BOOL    bRpcPipeCleanup   = FALSE;
BOOL    gbMachineInDomain = FALSE;

SPLCLIENT_INFO_1   gSplClientInfo1;
DWORD              gdwThisGetVersion;

LPWSTR szEnvironment = LOCAL_ENVIRONMENT;

CRITICAL_SECTION SpoolerSection;

//
//  Note indented calls have some Cache Effect.
//

PRINTPROVIDOR PrintProvidor = { CacheOpenPrinter,
                               SetJob,
                               GetJob,
                               EnumJobs,
                               AddPrinter,
                               DeletePrinter,
                                SetPrinter,
                                CacheGetPrinter,
                               EnumPrinters,
                               RemoteAddPrinterDriver,
                               EnumPrinterDrivers,
                                CacheGetPrinterDriver,
                               RemoteGetPrinterDriverDirectory,
                               DeletePrinterDriver,
                               AddPrintProcessor,
                               EnumPrintProcessors,
                               GetPrintProcessorDirectory,
                               DeletePrintProcessor,
                               EnumPrintProcessorDatatypes,
                               StartDocPrinter,
                               StartPagePrinter,
                               WritePrinter,
                               EndPagePrinter,
                               AbortPrinter,
                               ReadPrinter,
                               RemoteEndDocPrinter,
                               AddJob,
                               ScheduleJob,
                                CacheGetPrinterData,
                                SetPrinterData,
                               WaitForPrinterChange,
                                CacheClosePrinter,
                                AddForm,
                                DeleteForm,
                                CacheGetForm,
                                SetForm,
                                CacheEnumForms,
                               EnumMonitors,
                               RemoteEnumPorts,
                               RemoteAddPort,
                               RemoteConfigurePort,
                               RemoteDeletePort,
                               CreatePrinterIC,
                               PlayGdiScriptOnPrinterIC,
                               DeletePrinterIC,
                                AddPrinterConnection,
                                DeletePrinterConnection,
                               PrinterMessageBox,
                               AddMonitor,
                               DeleteMonitor,
                                CacheResetPrinter,
                               NULL,
                               RemoteFindFirstPrinterChangeNotification,
                               RemoteFindClosePrinterChangeNotification,
                               RemoteAddPortEx,
                               NULL,
                               RemoteRefreshPrinterChangeNotification,
                               NULL,
                               NULL,
                               SetPort,
                               RemoteEnumPrinterData,
                               RemoteDeletePrinterData,
                               NULL, // Clustering
                               NULL, // Clustering
                               NULL, // Clustering
                               RemoteSetPrinterDataEx,
                                CacheGetPrinterDataEx,
                                CacheEnumPrinterDataEx,
                                CacheEnumPrinterKey,
                               RemoteDeletePrinterDataEx,
                               RemoteDeletePrinterKey,
                               SeekPrinter,
                               DeletePrinterDriverEx,
                               AddPerMachineConnection,
                               DeletePerMachineConnection,
                               EnumPerMachineConnections,
                               RemoteXcvData,
                               AddPrinterDriverEx,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               RemoteSendRecvBidiData,
                               NULL,
                              };

#ifdef DEBUG_BIND_CREF
VOID InitDebug( VOID );
#endif

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
    )
{
    if (dwReason != DLL_PROCESS_ATTACH)
        return TRUE;

#ifdef DEBUG_BIND_CREF
    InitDebug();
#endif

    hInst = hModule;

    InitializeCriticalSection(&SpoolerSection);
    DisableThreadLibraryCalls(hModule);

    return TRUE;

    UNREFERENCED_PARAMETER( lpRes );
}

PWCHAR gpSystemDir = NULL;
PWCHAR gpWin32SplDir = NULL;


BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
)
{
    DWORD           i;
    WCHAR           SystemDir[MAX_PATH];
    DWORD           ReturnValue = TRUE;
    UINT            Index;
    OSVERSIONINFO   OSVersionInfo;
    SYSTEM_INFO     SystemInfo;


    if (!pFullRegistryPath || !*pFullRegistryPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    // DbgInit();

    if ( !GetPrintSystemVersion() ) {

        DBGMSG( DBG_WARNING, ("GetPrintSystemVersion ERROR %d\n", GetLastError() ));
        return FALSE;
    }

    if (!(szRegistryPath = AllocSplStr(pFullRegistryPath)))
        return FALSE;

    szPrintProvidorName[0] = L'\0';
    szPrintProvidorDescription[0] = L'\0';
    szPrintProvidorComment[0] = L'\0';

    if (!LoadString(hInst,  IDS_WINDOWS_NT_REMOTE_PRINTERS,
               szPrintProvidorName,
               sizeof(szPrintProvidorName) / sizeof(*szPrintProvidorName)))

        return FALSE;

    if (!LoadString(hInst,  IDS_MICROSOFT_WINDOWS_NETWORK,
               szPrintProvidorDescription,
               sizeof(szPrintProvidorDescription) / sizeof(*szPrintProvidorDescription)))

        return FALSE;

    if (!LoadString(hInst,  IDS_REMOTE_PRINTERS,
               szPrintProvidorComment,
               sizeof(szPrintProvidorComment) / sizeof(*szPrintProvidorComment)))

        return FALSE;

    if ((hNetApi = LoadLibrary(L"netapi32.dll"))) {

        pfnNetServerEnum = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetServerEnum");
        pfnNetShareEnum = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetShareEnum");
        pfnNetWkstaUserGetInfo = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetWkstaUserGetInfo");
        pfnNetWkstaGetInfo = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetWkstaGetInfo");
        pfnNetApiBufferFree = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetApiBufferFree");
        pfnNetServerGetInfo = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetServerGetInfo");

        if ( pfnNetServerEnum       == NULL ||
             pfnNetShareEnum        == NULL ||
             pfnNetWkstaUserGetInfo == NULL ||
             pfnNetWkstaGetInfo     == NULL ||
             pfnNetApiBufferFree    == NULL ||
             pfnNetServerGetInfo    == NULL ) {

            DBGMSG( DBG_WARNING, ("Failed GetProcAddres on Net Api's %d\n", GetLastError() ));
            return FALSE;

        }

    } else {

        DBGMSG(DBG_WARNING,
               ("Failed LoadLibrary( netapi32.dll ) %d\n", GetLastError() ));
        return FALSE;

    }

    if (!BoolFromHResult(AreWeOnADomain(&gbMachineInDomain))) {

        DBGMSG(DBG_WARNING, ("Failed to determine if we are on a domain (%d).\n", GetLastError()));
        return FALSE;
    }

    memcpy(pPrintProvidor, &PrintProvidor, min(sizeof(PRINTPROVIDOR),
                                               cbPrintProvidor));

    QueryTrustedDriverInformation();

    szMachineName[0] = szMachineName[1] = L'\\';

    i = MAX_COMPUTERNAME_LENGTH + 1;

    gdwThisGetVersion = GetVersion();
    GetSystemInfo(&SystemInfo);
    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);

    if (!GetComputerName(szMachineName+2, &i)   ||
        !GetVersionEx(&OSVersionInfo)           ||
        !(gSplClientInfo1.pMachineName = AllocSplStr(szMachineName)) )
        return FALSE;

    BuildOtherNamesFromMachineName(&gppszOtherNames, &gcOtherNames);

    gSplClientInfo1.dwSize          = sizeof(gSplClientInfo1);
    gSplClientInfo1.dwBuildNum      = OSVersionInfo.dwBuildNumber;
    gSplClientInfo1.dwMajorVersion  = cThisMajorVersion;
    gSplClientInfo1.dwMinorVersion  = cThisMinorVersion;
    gSplClientInfo1.pUserName       = NULL;

    gSplClientInfo1.wProcessorArchitecture = SystemInfo.wProcessorArchitecture;


    if ( InitializePortNames() != NO_ERROR )
        return FALSE;

    Index = GetSystemDirectory(SystemDir, COUNTOF(SystemDir));

    if ( Index == 0 ) {

        return FALSE;
    }

    gpSystemDir = AllocSplStr( SystemDir );
    if ( gpSystemDir == NULL ) {
        return FALSE;
    }

    wcscpy( &SystemDir[Index], szWin32SplDirectory );

    gpWin32SplDir = AllocSplStr( SystemDir );

    if ( gpWin32SplDir == NULL ) {
        return FALSE;
    }

    return  TRUE;
}


DWORD
InitializePortNames(
)
{
    LONG     Status;
    HKEY     hkeyPath;
    HKEY     hkeyPortNames;
    WCHAR    Buffer[MAX_PATH];
    DWORD    cchBuffer;
    DWORD    i;
    DWORD    dwReturnValue;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegistryPath, 0,
                           KEY_READ, &hkeyPath );

    dwReturnValue = Status;

    if( Status == NO_ERROR ) {

        Status = RegOpenKeyEx( hkeyPath, szRegistryPortNames, 0,
                               KEY_READ, &hkeyPortNames );

        if( Status == NO_ERROR ) {

            i = 0;

            while( Status == NO_ERROR ) {

                cchBuffer = COUNTOF( Buffer );

                Status = RegEnumValue( hkeyPortNames, i, Buffer, &cchBuffer,
                                       NULL, NULL, NULL, NULL );

                if( Status == NO_ERROR )
                    CreatePortEntry( Buffer, &pIniFirstPort );

                i++;
            }

            /* We expect RegEnumKeyEx to return ERROR_NO_MORE_ITEMS
             * when it gets to the end of the keys, so reset the status:
             */
            if( Status == ERROR_NO_MORE_ITEMS )
                Status = NO_ERROR;

            RegCloseKey( hkeyPortNames );

        } else {

            DBGMSG( DBG_INFO, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                                szRegistryPortNames, Status ) );
        }

        RegCloseKey( hkeyPath );

    } else {

        DBGMSG( DBG_WARNING, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                               szRegistryPath, Status ) );
    }

    if ( dwReturnValue != NO_ERROR ) {
        SetLastError( dwReturnValue );
    }

    return dwReturnValue;
}

BOOL
EnumerateFavouritePrinters(
    LPWSTR  pDomain,
    DWORD   Level,
    DWORD   cbStruct,
    LPDWORD pOffsets,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    HKEY    hClientKey = NULL;
    HKEY    hKey1=NULL;
    DWORD   cPrinters, cbData;
    WCHAR   PrinterName[ MAX_UNC_PRINTER_NAME ];
    DWORD   cReturned, TotalcbNeeded, cbNeeded, cTotalReturned;
    DWORD   Error=0;
    DWORD   BufferSize=cbBuf;
    HANDLE  hPrinter;
    DWORD   Status;
    WCHAR   szBuffer[MAX_PATH];
    HKEY    hPrinterConnectionsKey;

    DBGMSG( DBG_TRACE, ("EnumerateFavouritePrinters called\n"));

    *pcbNeeded = 0;
    *pcReturned = 0;

    hClientKey = GetClientUserHandle(KEY_READ);

    if ( hClientKey == NULL ) {

        DBGMSG( DBG_WARNING, ("EnumerateFavouritePrinters GetClientUserHandle failed error %d\n", GetLastError() ));
        return FALSE;
    }

    Status = RegOpenKeyEx(hClientKey, szRegistryConnections, 0,
                 KEY_READ, &hKey1);

    if ( Status != ERROR_SUCCESS ) {

        RegCloseKey(hClientKey);
        SetLastError( Status );
        DBGMSG( DBG_WARNING, ("EnumerateFavouritePrinters RegOpenKeyEx failed error %d\n", GetLastError() ));
        return FALSE;
    }

    cReturned = cbNeeded = TotalcbNeeded = cTotalReturned = 0;

    for( cPrinters = 0;

         cbData = COUNTOF( PrinterName ),
         RegEnumKeyEx(hKey1,
                      cPrinters,
                      PrinterName,
                      &cbData,
                      NULL, NULL, NULL, NULL) == ERROR_SUCCESS;

         ++cPrinters ){

        //
        // Check if the key belongs to us.
        //
        Status = RegOpenKeyEx( hKey1,
                               PrinterName,
                               0,
                               KEY_READ,
                               &hPrinterConnectionsKey );

        if( Status != ERROR_SUCCESS ){
            continue;
        }

        cbData = sizeof(szBuffer);

        //
        // If there is a Provider value, and it doesn't match win32spl.dll,
        // then fail the call.
        //
        // If the provider value isn't there, succeed for backward
        // compatibility.
        //
        Status = RegQueryValueEx( hPrinterConnectionsKey,
                                  L"Provider",
                                  NULL,
                                  NULL,
                                  (LPBYTE)szBuffer,
                                  &cbData );

        RegCloseKey( hPrinterConnectionsKey );

        //
        // If the key exists but we failed to read it, or the
        // provider entry is incorrect, then don't enumerate it back.
        //
        // For backward compatibility, if the key doesn't exist,
        // we assume it belongs to win32spl.dll.
        //
        if( Status != ERROR_SUCCESS ){
            if( Status != ERROR_FILE_NOT_FOUND ){
                continue;
            }
        } else {
            if( _wcsicmp( szBuffer, L"win32spl.dll" )){
                continue;
            }
        }


        FormatRegistryKeyForPrinter(PrinterName, PrinterName);

        // Do not fail if any of these calls fails, because we want
        // to return whatever we can find.

        if (MyUNCName(PrinterName))  // Roaming profiles can create connections to local printers
            continue;

        if (CacheOpenPrinter(PrinterName, &hPrinter, NULL)) {

            if (CacheGetPrinter(hPrinter, Level, pPrinter, BufferSize, &cbNeeded)) {

                if (Level == 2) {
                    ((PPRINTER_INFO_2)pPrinter)->Attributes |= PRINTER_ATTRIBUTE_NETWORK;
                    ((PPRINTER_INFO_2)pPrinter)->Attributes &= ~PRINTER_ATTRIBUTE_LOCAL;
                }
                else if (Level == 5) {
                    ((PPRINTER_INFO_5)pPrinter)->Attributes |= PRINTER_ATTRIBUTE_NETWORK;
                    ((PPRINTER_INFO_5)pPrinter)->Attributes &= ~PRINTER_ATTRIBUTE_LOCAL;
                }

                cTotalReturned++;

                pPrinter += cbStruct;

                if (cbNeeded <= BufferSize)
                    BufferSize -= cbNeeded;

                TotalcbNeeded += cbNeeded;

            } else {

                DWORD Error;

                if ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

                    if (cbNeeded <= BufferSize)
                        BufferSize -= cbNeeded;

                    TotalcbNeeded += cbNeeded;

                } else {

                    DBGMSG( DBG_WARNING, ( "GetPrinter( %ws ) failed: Error %d\n",
                                           PrinterName, Error ) );
                }
            }

            CacheClosePrinter(hPrinter);

        } else {

            DBGMSG( DBG_WARNING, ( "CacheOpenPrinter( %ws ) failed: Error %d\n",
                                   PrinterName, GetLastError( ) ) );
        }
    }

    RegCloseKey(hKey1);

    if (hClientKey) {
        RegCloseKey(hClientKey);
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cTotalReturned;

    if (TotalcbNeeded > cbBuf) {

        DBGMSG( DBG_TRACE, ("EnumerateFavouritePrinters returns ERROR_INSUFFICIENT_BUFFER\n"));
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;

    }

    return TRUE;

}

DWORD
RpcValidate(
    VOID
    )

/*++

Routine Description:

    Validates that the call came from local machine. We do not want this function
    to call IsLocalCall in spoolss. IsLocalCall does a CheckTokenMembership to
    look at the network sid. This breaks scenarios like the following:
    W2k client prints to W2k server. The port monitor is Intel Network.
    Port Monitor. The start doc call originating from the client (thread token
    has the network bit set) will try to do OpenPrinter on the port name:
    \\intel-box\port in the spooler on the server. The call gets routed
    to win32spl. The line below will allow the call to get through.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS           - Call was local and we should RPC out.

    ERROR_INVALID_PARAMETER - Call was not local and shouldn't RPC out
                              since we may get into an infinite loop.

--*/

{
    return IsNamedPipeRpcCall() ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS;
}


#define SIZEOFPARAM1    1
#define SIZEOFPARAM2    3
#define SIZEOFASCIIZ    1
#define SAFECOUNT               (SIZEOFPARAM1 + SIZEOFPARAM2 + SIZEOFASCIIZ)

BOOL
EnumerateDomainPrinters(
    LPWSTR  pDomain,
    DWORD   Level,
    DWORD   cbStruct,
    LPDWORD pOffsets,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, j, NoReturned, Total, OuterLoopCount;
    DWORD   rc = 0;
    PSERVER_INFO_101 pserver_info_101;
    DWORD   ReturnValue=FALSE;
    WCHAR   string[3*MAX_PATH];
    PPRINTER_INFO_1    pPrinterInfo1;
    DWORD   cb=cbBuf;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    LPBYTE  pEnd;
    DWORD   ServerType;
    BOOL    bServerFound = FALSE, bMarshall;

    DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters called\n"));

    string[0] = string[1] = '\\';

    *pcbNeeded = *pcReturned = 0;

    if (!(*pfnNetServerEnum)(NULL, 101, (LPBYTE *)&pserver_info_101, -1,
                             &NoReturned, &Total,
                             SV_TYPE_PRINTQ_SERVER | SV_TYPE_WFW,
                             pDomain, NULL)) {

        DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters NetServerEnum returned %d\n", NoReturned));

        //
        //  First Look try NT Servers, then if that Fails Look at the WorkStations
        //

        for ( ServerType = ( SV_TYPE_SERVER_NT | SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ), OuterLoopCount = 0;
              bServerFound == FALSE && OuterLoopCount < 2;
              ServerType = SV_TYPE_NT, OuterLoopCount++ ) {

            //
            //  Loop Through looking for a print server that will return a good browse list
            //

            for ( i = 0; i < NoReturned; i++ ) {

                if ( pserver_info_101[i].sv101_type & ServerType ) {

                    wcscpy( &string[2], pserver_info_101[i].sv101_name );

                    RpcTryExcept {

                        DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters Trying %ws ENUM_NETWORK type %x\n", string, ServerType ));

                        if ( !(rc = RpcValidate()) &&

                             !(rc = RpcEnumPrinters(PRINTER_ENUM_NETWORK,
                                                    string,
                                                    1, pPrinter,
                                                    cbBuf, pcbNeeded,
                                                    pcReturned) ,
                               rc = UpdateBufferSize(PrinterInfo1Fields,
                                                     sizeof(PRINTER_INFO_1),
                                                     pcbNeeded,
                                                     cbBuf,
                                                     rc,
                                                     pcReturned)) ) {

                            if ( bMarshall =  MarshallUpStructuresArray(pPrinter, *pcReturned, PrinterInfo1Fields,
                                                                        sizeof(PRINTER_INFO_1), RPC_CALL)) {

                                //
                                // pPrinter must point after lats structure in array.
                                // More structures needs to be added by the other providers.
                                //
                                pPrinter += (*pcReturned) * cbStruct;
                            }

                            if (!bMarshall) {
                                bServerFound = TRUE;
                                break;
                            }

                            //
                            //  Only return success if we found some data.
                            //

                            if ( *pcReturned != 0 ) {

                                DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters %ws ENUM_NETWORK Success %d returned\n", string, *pcReturned ));

                                bServerFound = TRUE;
                                break;
                            }

                        } else if (rc == ERROR_INSUFFICIENT_BUFFER) {

                            DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters %ws ENUM_NETWORK ERROR_INSUFFICIENT_BUFFER\n", string ));

                            bServerFound = TRUE;
                            break;
                        }

                    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
                        DBGMSG( DBG_TRACE,( "Failed to connect to Print Server%ws\n",
                                pserver_info_101[i].sv101_name ) );
                    } RpcEndExcept

                } else {

                    DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters %ws type %x not type %x\n", pserver_info_101[i].sv101_name, pserver_info_101[i].sv101_type, ServerType));
                }
            }
        }

        pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

        pEnd = (LPBYTE)pPrinterInfo1 + cb - *pcbNeeded;

        for ( i = 0; i < NoReturned; i++ ) {

            wcscpy( string, szPrintProvidorName );
            wcscat( string, L"!" ); //SIZEOFPARAM1
            if ( pDomain )
                wcsncat(string,pDomain,sizeof(string)/sizeof(WCHAR)-wcslen(pserver_info_101[i].sv101_name)-SAFECOUNT);
            wcscat( string, L"!\\\\" );                 //SIZEOFPARAM2
            wcscat( string, pserver_info_101[i].sv101_name );

            cb = wcslen(pserver_info_101[i].sv101_name)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(string)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szLoggedOnDomain)*sizeof(WCHAR) + sizeof(WCHAR) +
                 sizeof(PRINTER_INFO_1);

            (*pcbNeeded) += cb;

            if ( cbBuf >= *pcbNeeded ) {

                (*pcReturned)++;

                pPrinterInfo1->Flags = PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON3;

                SourceStrings[0] = pserver_info_101[i].sv101_name;
                SourceStrings[1] = string;
                SourceStrings[2] = szLoggedOnDomain;

                pEnd = PackStrings( SourceStrings, (LPBYTE)pPrinterInfo1,
                                    PrinterInfo1Strings, pEnd );

                pPrinterInfo1++;
            }
        }

        (*pfnNetApiBufferFree)((LPVOID)pserver_info_101);

        if ( cbBuf < *pcbNeeded ) {

            DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters returns ERROR_INSUFFICIENT_BUFFER\n"));
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
EnumerateDomains(
    PRINTER_INFO_1 *pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    LPBYTE  pEnd
)
{
    DWORD   i, NoReturned, Total;
    DWORD   cb;
    SERVER_INFO_100 *pNames;
    PWKSTA_INFO_100 pWkstaInfo = NULL;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    WCHAR   string[3*MAX_PATH];

    DBGMSG( DBG_TRACE, ("EnumerateDomains pPrinter %x cbBuf %d pcbNeeded %x pcReturned %x pEnd %x\n",
                         pPrinter, cbBuf, pcbNeeded, pcReturned, pEnd ));

    *pcReturned = 0;
    *pcbNeeded = 0;

    if (!(*pfnNetServerEnum)(NULL, 100, (LPBYTE *)&pNames, -1,
                             &NoReturned, &Total, SV_TYPE_DOMAIN_ENUM,
                             NULL, NULL)) {

        DBGMSG( DBG_TRACE, ("EnumerateDomains - NetServerEnum returned %d\n", NoReturned));

        (*pfnNetWkstaGetInfo)(NULL, 100, (LPBYTE *)&pWkstaInfo);

        DBGMSG( DBG_TRACE, ("EnumerateDomains - NetWkstaGetInfo returned pWkstaInfo %x\n", pWkstaInfo));

        for (i=0; i<NoReturned; i++) {

            wcscpy(string, szPrintProvidorName);
            wcscat(string, L"!");
            wcscat(string, pNames[i].sv100_name);

            cb = wcslen(pNames[i].sv100_name)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(string)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szLoggedOnDomain)*sizeof(WCHAR) + sizeof(WCHAR) +
                 sizeof(PRINTER_INFO_1);

            (*pcbNeeded)+=cb;

            if (cbBuf >= *pcbNeeded) {

                (*pcReturned)++;

                pPrinter->Flags = PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON2;

                /* Set the PRINTER_ENUM_EXPAND flag for the user's logon domain
                 */
                if (!lstrcmpi(pNames[i].sv100_name,
                             pWkstaInfo->wki100_langroup))
                    pPrinter->Flags |= PRINTER_ENUM_EXPAND;

                SourceStrings[0]=pNames[i].sv100_name;
                SourceStrings[1]=string;
                SourceStrings[2]=szLoggedOnDomain;

                pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter,
                                   PrinterInfo1Strings, pEnd);

                pPrinter++;
            }
        }

        (*pfnNetApiBufferFree)((LPVOID)pNames);
        (*pfnNetApiBufferFree)((LPVOID)pWkstaInfo);

        if (cbBuf < *pcbNeeded) {

            DBGMSG( DBG_TRACE, ("EnumerateDomains returns ERROR_INSUFFICIENT_BUFFER\n"));
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }

        return TRUE;
    }

    return TRUE;
}

BOOL
EnumeratePrintShares(
    LPWSTR  pDomain,
    LPWSTR  pServer,
    DWORD   Level,
    DWORD   cbStruct,
    LPDWORD pOffsets,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, NoReturned, Total;
    DWORD   cb;
    SHARE_INFO_1 *pNames;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    WCHAR   string[MAX_UNC_PRINTER_NAME] = {0};
    PRINTER_INFO_1 *pPrinterInfo1 = (PRINTER_INFO_1 *)pPrinter;
    LPBYTE  pEnd=pPrinter+cbBuf;
    WCHAR   FullName[MAX_UNC_PRINTER_NAME] = {0};

    DBGMSG( DBG_TRACE, ("EnumeratePrintShares\n"));

    *pcReturned = 0;
    *pcbNeeded = 0;

    if (!(*pfnNetShareEnum)(pServer, 1, (LPBYTE *)&pNames, -1,
                             &NoReturned, &Total, NULL)) {

        DBGMSG( DBG_TRACE, ("EnumeratePrintShares NetShareEnum returned %d\n", NoReturned));

        for (i=0; i<NoReturned; i++) {

            if (pNames[i].shi1_type == STYPE_PRINTQ) {

                DWORD dwRet;

                if(((dwRet = StrNCatBuff(string ,
                                         MAX_UNC_PRINTER_NAME,
                                         pNames[i].shi1_netname,
                                         L",",
                                         pNames[i].shi1_remark,
                                         NULL
                                        )) != ERROR_SUCCESS) ||
                    ((dwRet = StrNCatBuff(FullName,
                                          MAX_UNC_PRINTER_NAME,
                                          pServer,
                                          L"\\",
                                          pNames[i].shi1_netname,
                                          NULL
                                         )) != ERROR_SUCCESS))
                {
                    SetLastError(dwRet);
                    return(FALSE);
                }

                cb = wcslen(FullName)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(string)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(szLoggedOnDomain)*sizeof(WCHAR) + sizeof(WCHAR) +
                     sizeof(PRINTER_INFO_1);

                (*pcbNeeded)+=cb;

                if (cbBuf >= *pcbNeeded) {

                    (*pcReturned)++;

                    pPrinterInfo1->Flags = PRINTER_ENUM_ICON8;

                    SourceStrings[0]=string;
                    SourceStrings[1]=FullName;
                    SourceStrings[2]=szLoggedOnDomain;

                    pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinterInfo1,
                                       PrinterInfo1Strings, pEnd);

                    pPrinterInfo1++;
                }
            }
        }

        (*pfnNetApiBufferFree)((LPVOID)pNames);

        if ( cbBuf < *pcbNeeded ) {

            DBGMSG( DBG_TRACE, ("EnumeratePrintShares returns ERROR_INSUFFICIENT_BUFFER\n"));
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }

        return TRUE;
    }

    return TRUE;
}

BOOL
EnumPrinters(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   cbStruct, cb;
    DWORD   *pOffsets;
    FieldInfo *pFieldInfo;
    DWORD   NoReturned=0, i, rc;
    LPBYTE  pKeepPrinter = pPrinter;
    BOOL    OutOfMemory = FALSE;
    PPRINTER_INFO_1 pPrinter1=(PPRINTER_INFO_1)pPrinter;
    PWSTR   pszFullName = NULL;
    WCHAR   *pDomain, *pServer;


    DBGMSG( DBG_TRACE, ("EnumPrinters Flags %x pName %x Level %d pPrinter %x cbBuf %d pcbNeeded %x pcReturned %x\n",
                         Flags, Name, Level, pPrinter, cbBuf, pcbNeeded, pcReturned ));

    *pcReturned = 0;
    *pcbNeeded = 0;

    switch (Level) {

    case STRESSINFOLEVEL:
        pOffsets = PrinterInfoStressOffsets;
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pOffsets = PrinterInfo1Offsets;
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pOffsets = PrinterInfo2Offsets;
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:

        //
        // There are no local printers in win32spl, and connections
        // are handled by the router.
        //
        return TRUE;

    case 5:
        pOffsets = PrinterInfo5Offsets;
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        DBGMSG( DBG_TRACE, ("EnumPrinters failed ERROR_INVALID_LEVEL\n"));
        return FALSE;
    }

    if ( Flags & PRINTER_ENUM_NAME ) {

        if (!Name && (Level == 1)) {

            LPWSTR   SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
            LPWSTR   *pSourceStrings=SourceStrings;

            cb = wcslen(szPrintProvidorName)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szPrintProvidorDescription)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szPrintProvidorComment)*sizeof(WCHAR) + sizeof(WCHAR) +
                 sizeof(PRINTER_INFO_1);

            *pcbNeeded=cb;

            if ( cb > cbBuf ) {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                DBGMSG( DBG_TRACE, ("EnumPrinters returns ERROR_INSUFFICIENT_BUFFER\n"));
                return FALSE;
            }

            *pcReturned = 1;

            pPrinter1->Flags = PRINTER_ENUM_CONTAINER |
                               PRINTER_ENUM_ICON1 |
                               PRINTER_ENUM_EXPAND;

            *pSourceStrings++=szPrintProvidorDescription;
            *pSourceStrings++=szPrintProvidorName;
            *pSourceStrings++=szPrintProvidorComment;

            PackStrings( SourceStrings, pPrinter, PrinterInfo1Strings,
                         pPrinter+cbBuf );

            DBGMSG( DBG_TRACE, ("EnumPrinters returns Success just Provider Info\n"));

            return TRUE;
        }

        if (Name && *Name && (Level == 1)) {

            if (!(pszFullName = AllocSplStr(Name)))
                return FALSE;

            pServer = NULL;
            pDomain = wcschr(pszFullName, L'!');

            if (pDomain) {
                *pDomain++ = 0;

                pServer = wcschr(pDomain, L'!');

                if (pServer)
                    *pServer++ = 0;
            }

            if (!lstrcmpi(pszFullName, szPrintProvidorName)) {
                ReturnValue = !pServer ? !pDomain ?  EnumerateDomains((PRINTER_INFO_1 *)pPrinter,
                                                                       cbBuf, pcbNeeded,
                                                                       pcReturned, pPrinter+cbBuf)
                                                  :  EnumerateDomainPrinters(pDomain,
                                                                             Level, cbStruct,
                                                                             pOffsets, pPrinter, cbBuf,
                                                                             pcbNeeded, pcReturned)
                                       : EnumeratePrintShares(pDomain, pServer, Level,
                                                              cbStruct, pOffsets, pPrinter,
                                                              cbBuf, pcbNeeded, pcReturned);
               FreeSplMem(pszFullName);
               return(ReturnValue);
            }
            FreeSplMem(pszFullName);
        }

        if ( !VALIDATE_NAME(Name) || MyUNCName(Name)) {
            SetLastError(ERROR_INVALID_NAME);
            return FALSE;
        }

        if (pPrinter)
            memset(pPrinter, 0, cbBuf);

        RpcTryExcept {

            if ( (rc = RpcValidate()) ||

                 (rc = RpcEnumPrinters(Flags,
                                        Name,
                                        Level, pPrinter,
                                        cbBuf, pcbNeeded,
                                        pcReturned),
                  rc = UpdateBufferSize(pFieldInfo,
                                        cbStruct,
                                        pcbNeeded,
                                        cbBuf,
                                        rc,
                                        pcReturned)) ) {

                SetLastError(rc);
                // ReturnValue = FALSE;
                return FALSE;

            } else {

                ReturnValue = TRUE;

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            DBGMSG( DBG_TRACE, ( "Failed to connect to Print Server%ws\n", Name ) );

            *pcbNeeded = 0;
            *pcReturned = 0;
            SetLastError(RpcExceptionCode());
            // ReturnValue = FALSE;
            return FALSE;

        } RpcEndExcept


        if(! MarshallUpStructuresArray(pPrinter, *pcReturned, pFieldInfo, cbStruct, RPC_CALL) ) {
            return FALSE;
        }

         i = *pcReturned;

        while (i--) {

            if (Level == 2) {
                ((PPRINTER_INFO_2)pPrinter)->Attributes |=
                                            PRINTER_ATTRIBUTE_NETWORK;
                ((PPRINTER_INFO_2)pPrinter)->Attributes &=
                                                ~PRINTER_ATTRIBUTE_LOCAL;
            }

            if (Level == 5) {
                ((PPRINTER_INFO_5)pPrinter)->Attributes |=
                                            PRINTER_ATTRIBUTE_NETWORK;
                ((PPRINTER_INFO_5)pPrinter)->Attributes &=
                                                ~PRINTER_ATTRIBUTE_LOCAL;
            }
            pPrinter += cbStruct;
        }


    } else if (Flags & PRINTER_ENUM_REMOTE) {

        if (Level != 1) {

            SetLastError(ERROR_INVALID_LEVEL);
            ReturnValue = FALSE;

        } else {

            ReturnValue = EnumerateDomainPrinters(NULL, Level,
                                                  cbStruct, pOffsets,
                                                  pPrinter, cbBuf,
                                                  pcbNeeded, pcReturned);
        }

    } else if (Flags & PRINTER_ENUM_CONNECTIONS) {

        ReturnValue = EnumerateFavouritePrinters(NULL, Level,
                                                 cbStruct, pOffsets,
                                                 pPrinter, cbBuf,
                                                 pcbNeeded, pcReturned);
    }

    return ReturnValue;
}


BOOL
RemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault,
   BOOL     CallLMOpenPrinter
)
{
    DWORD               RpcReturnValue;
    BOOL                ReturnValue = FALSE;
    DEVMODE_CONTAINER   DevModeContainer;
    SPLCLIENT_CONTAINER SplClientContainer;
    SPLCLIENT_INFO_1    SplClientInfo;
    HANDLE              hPrinter;
    PWSPOOL             pSpool;
    DWORD               Status = 0;
    DWORD               RpcError = 0;
    DWORD               dwIndex;
    WCHAR               UserName[MAX_PATH+1];
    HANDLE              hSplPrinter, hIniSpooler, hDevModeChgInfo;

    if ( !VALIDATE_NAME(pPrinterName)   ||
         MyUNCName(pPrinterName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    // enable named pipe timeouts

    if (bRpcPipeCleanup == FALSE) {
        EnterSplSem();
        if (bRpcPipeCleanup == FALSE) {
            bRpcPipeCleanup = TRUE;
            LeaveSplSem();
            (VOID)RpcMgmtEnableIdleCleanup();
        } else {
            LeaveSplSem();
        }
    }

    if (pDefault && pDefault->pDevMode) {

        DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;

    } else {

        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }


    if ( CallLMOpenPrinter ) {

        //
        // Now check if we have an entry in the
        // downlevel cache. We don't want to hit the wire, search the whole net
        // and fail if we know that the printer is LM. if the printer is LM
        // try and succeed
        //

        EnterSplSem();

        dwIndex = FindEntryinWin32LMCache(pPrinterName);

        LeaveSplSem();

        if (dwIndex != -1) {
            ReturnValue = LMOpenPrinter(pPrinterName, phPrinter, pDefault);
            if (ReturnValue) {
                return  TRUE ;
            }
            //
            // Delete Entry in Cache

            EnterSplSem();
            DeleteEntryfromWin32LMCache(pPrinterName);
            LeaveSplSem();
        }
    }

    CopyMemory((LPBYTE)&SplClientInfo,
               (LPBYTE)&gSplClientInfo1,
               sizeof(SplClientInfo));

    dwIndex  = sizeof(UserName)/sizeof(UserName[0]) - 1;
    if ( !GetUserName(UserName, &dwIndex) ) {

        goto Cleanup;
    }

    SplClientInfo.pUserName = UserName;
    SplClientContainer.ClientInfo.pClientInfo1  = &SplClientInfo;
    SplClientContainer.Level                    = 1;

    RpcTryExcept {

        EnterSplSem();
        pSpool = AllocWSpool();
        LeaveSplSem();

        if ( pSpool != NULL ) {

            pSpool->pName = AllocSplStr( pPrinterName );

            if ( pSpool->pName != NULL ) {

                pSpool->Status = Status;

                if ( CopypDefaultTopSpool( pSpool, pDefault ) ) {

                    RpcReturnValue = RpcValidate();

                    if ( RpcReturnValue == ERROR_SUCCESS )
                        RpcReturnValue = RpcOpenPrinterEx(
                                            pPrinterName,
                                            &hPrinter,
                                            pDefault ? pDefault->pDatatype
                                                     : NULL,
                                            &DevModeContainer,
                                            pDefault ? pDefault->DesiredAccess
                                                     : 0,
                                            &SplClientContainer);

                    if (RpcReturnValue) {

                        SetLastError(RpcReturnValue);

                    } else {

                        pSpool->RpcHandle = hPrinter;
                        *phPrinter = (HANDLE)pSpool;
                        ReturnValue = TRUE;
                    }
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        RpcError = RpcExceptionCode();
    } RpcEndExcept;

    if ( RpcError == RPC_S_PROCNUM_OUT_OF_RANGE ) {

        RpcError = 0;

        if ( pDefault && pDefault->pDevMode ) {

            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;

            if ( OpenCachePrinterOnly(pPrinterName, &hPrinter, &hIniSpooler, NULL, FALSE) ) {

                hDevModeChgInfo = LoadDriverFiletoConvertDevmodeFromPSpool(hPrinter);
                if ( hDevModeChgInfo ) {

                    (VOID)CallDrvDevModeConversion(hDevModeChgInfo,
                                                   pPrinterName,
                                                   (LPBYTE)pDefault->pDevMode,
                                                   &DevModeContainer.pDevMode,
                                                   &DevModeContainer.cbBuf,
                                                   CDM_CONVERT351,
                                                   TRUE);

                    UnloadDriverFile(hDevModeChgInfo);
                }

                CacheClosePrinter(hPrinter);
            }
        }

        RpcTryExcept {

            RpcReturnValue = RpcOpenPrinter(pPrinterName,
                                            &hPrinter,
                                            pDefault ? pDefault->pDatatype
                                                     : NULL,
                                            &DevModeContainer,
                                            pDefault ? pDefault->DesiredAccess
                                                     : 0);

            if (RpcReturnValue) {

                SetLastError(RpcReturnValue);
            } else {

                pSpool->RpcHandle = hPrinter;
                pSpool->bNt3xServer = TRUE;
                *phPrinter = (HANDLE)pSpool;
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            RpcError = RpcExceptionCode();
            DBGMSG(DBG_WARNING,("RpcOpenPrinter exception %d\n", RpcError));
        } RpcEndExcept;
    }

    if ( RpcError ) {

        SetLastError(RpcError);
    }

    if ( ReturnValue == FALSE && pSpool != NULL ) {

        EnterSplSem();
        FreepSpool( pSpool );
        LeaveSplSem();
    }

    if ( (RpcError == RPC_S_SERVER_UNAVAILABLE) && CallLMOpenPrinter ) {

        ReturnValue = LMOpenPrinter(pPrinterName, phPrinter, pDefault);

        if (ReturnValue) {

            EnterSplSem();
            AddEntrytoWin32LMCache(pPrinterName);
            LeaveSplSem();
        }
    }

    if ( !ReturnValue ) {

        DBGMSG(DBG_TRACE,
               ("RemoteOpenPrinter %ws failed %d\n",
                pPrinterName, GetLastError() ));


    }

Cleanup:

    if ( DevModeContainer.pDevMode &&
         DevModeContainer.pDevMode != (LPBYTE)pDefault->pDevMode ) {

        FreeSplMem(DevModeContainer.pDevMode);
    }

    return ReturnValue;
}


BOOL PrinterConnectionExists(
    LPWSTR pPrinterName
)
{
    HKEY    hClientKey      = NULL;
    HKEY    hKeyConnections = NULL;
    HKEY    hKeyPrinter     = NULL;
    BOOL    ConnectionFound = FALSE;
    DWORD   Status;

    if (pPrinterName &&
        (hClientKey = GetClientUserHandle(KEY_READ)))
    {
        if ((Status = RegOpenKeyEx(hClientKey,
                                   szRegistryConnections,
                                   0,
                                   KEY_READ,
                                   &hKeyConnections)) == ERROR_SUCCESS)
        {
             LPWSTR pszBuffer = NULL;
             LPWSTR pKeyName  = NULL;

             if (pszBuffer = AllocSplMem((wcslen(pPrinterName) + 1) * sizeof(WCHAR)))
             {
                 pKeyName = FormatPrinterForRegistryKey(pPrinterName, pszBuffer);

                 if (RegOpenKeyEx(hKeyConnections,
                                  pKeyName,
                                  REG_OPTION_RESERVED,
                                  KEY_READ,
                                  &hKeyPrinter) == ERROR_SUCCESS)
                 {
                    RegCloseKey(hKeyPrinter);
                    ConnectionFound = TRUE;
                 }

                 FreeSplMem(pszBuffer);
             }
             else
             {
                 DBGMSG(DBG_WARNING, ("PrinterConnectionExists AllocMem failed Error %d\n", GetLastError()));
             }

             RegCloseKey(hKeyConnections);
        }
        else
        {
            DBGMSG(DBG_WARNING, ("RegOpenKeyEx failed: %ws Error %d\n", szRegistryConnections ,Status));
        }

        RegCloseKey(hClientKey);
    }

    return ConnectionFound;
}


BOOL
RemoteResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    BOOL  ReturnValue;
    DEVMODE_CONTAINER    DevModeContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    DBGMSG(DBG_TRACE, ("ResetPrinter\n"));

    SYNCRPCHANDLE( pSpool );

    if (pDefault && pDefault->pDevMode)
    {
        DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
    }
    else
    {
        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }

    RpcTryExcept {

        if ( ReturnValue = RpcResetPrinter(pSpool->RpcHandle,
                                           pDefault ? pDefault->pDatatype : NULL,
                                           &DevModeContainer) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(ERROR_NOT_SUPPORTED);
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
SetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER   GenericContainer;
    GENERIC_CONTAINER *pGenericContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (pJob) {

                GenericContainer.Level = Level;
                GenericContainer.pData = pJob;
                pGenericContainer = &GenericContainer;

            } else

                pGenericContainer = NULL;

            //
            // JOB_CONTROL_DELETE was added in NT 4.0
            //
            if ( pSpool->bNt3xServer && Command == JOB_CONTROL_DELETE )
                Command = JOB_CONTROL_CANCEL;

            if ( ReturnValue = RpcSetJob(pSpool->RpcHandle, JobId,
                                         (JOB_CONTAINER *)pGenericContainer,
                                          Command) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMSetJob(hPrinter, JobId, Level, pJob, Command);

    return ReturnValue;
}

BOOL
GetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    SIZE_T cbStruct;
    DWORD  cReturned = 1;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = JobInfo1Fields;
            cbStruct = sizeof(JOB_INFO_1);
            break;

        case 2:
            pFieldInfo = JobInfo2Fields;
            cbStruct = sizeof(JOB_INFO_2);
            break;

        case 3:
            pFieldInfo = JobInfo3Fields;
            cbStruct = sizeof(JOB_INFO_3);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if ( ReturnValue = RpcGetJob(pSpool->RpcHandle, JobId, Level, pJob,
                                         cbBuf, pcbNeeded),

                 ReturnValue = UpdateBufferSize(pFieldInfo,
                                                 cbStruct,
                                                 pcbNeeded,
                                                 cbBuf,
                                                 ReturnValue,
                                                 &cReturned)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                if (pJob) {
                    ReturnValue =  MarshallUpStructure(pJob, pFieldInfo, cbStruct, RPC_CALL);
                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());

            //
            // This will be thrown by the server if a cbBuf > 1 Meg is
            // passed across the wire.
            //
            SPLASSERT( GetLastError() != ERROR_INVALID_USER_BUFFER );
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMGetJob(hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded);

    return ReturnValue;
}

BOOL
EnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD    ReturnValue, i, cbStruct;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = JobInfo1Fields;
            cbStruct = sizeof(JOB_INFO_1);
            break;

        case 2:
            pFieldInfo = JobInfo2Fields;
            cbStruct = sizeof(JOB_INFO_2);
            break;

        case 3:
            pFieldInfo = JobInfo3Fields;
            cbStruct = sizeof(JOB_INFO_3);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if (ReturnValue = RpcEnumJobs(pSpool->RpcHandle,
                                          FirstJob, NoJobs,
                                          Level, pJob,
                                          cbBuf, pcbNeeded,
                                          pcReturned) ,

                ReturnValue = UpdateBufferSize(pFieldInfo,
                                               cbStruct,
                                               pcbNeeded,
                                               cbBuf,
                                               ReturnValue,
                                               pcReturned))
            {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            }
            else
            {
                ReturnValue = TRUE;

                if(! MarshallUpStructuresArray(pJob, *pcReturned, pFieldInfo, cbStruct, RPC_CALL) ) {
                    return FALSE;
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMEnumJobs(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf,
                          pcbNeeded, pcReturned);

    return (BOOL)ReturnValue;
}

HANDLE
AddPrinter(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
)
{
    DWORD               ReturnValue;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    HANDLE              hPrinter = INVALID_HANDLE_VALUE;
    PWSPOOL             pSpool = NULL;
    PWSTR               pScratchBuffer = NULL;
    PWSTR               pCopyPrinterName = NULL;
    SPLCLIENT_CONTAINER SplClientContainer;
    SPLCLIENT_INFO_1    SplClientInfo;
    WCHAR               UserName[MAX_PATH+1];
    DWORD               dwRpcError = 0;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }


    CopyMemory((LPBYTE)&SplClientInfo,
               (LPBYTE)&gSplClientInfo1,
               sizeof(SplClientInfo));

    //
    // Don't pass in user name for browsing level because this
    // causes LSA to chew up a lot of CPU.  This isn't needed anyway
    // because an AddPrinter( LEVEL_1 ) call never returns a print
    // handle.
    //
    if( Level == 1 ){

        UserName[0] = 0;

    } else {

        DWORD dwSize = sizeof(UserName)/sizeof(UserName[0]) - 1;

        if ( !GetUserName(UserName, &dwSize) ) {
            return FALSE;
        }
    }

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    SplClientInfo.pUserName                     = UserName;
    SplClientContainer.Level                    = 1;
    SplClientContainer.ClientInfo.pClientInfo1  = &SplClientInfo;

    if (Level == 2) {

        PPRINTER_INFO_2 pPrinterInfo = (PPRINTER_INFO_2)pPrinter;

        if (pPrinterInfo->pDevMode) {

            DevModeContainer.cbBuf = pPrinterInfo->pDevMode->dmSize +
                                      pPrinterInfo->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo->pDevMode;

            //
            // Set pDevMode to NULL. Import.h defines pDevMode and pSecurityDescriptor as pointers now.
            // pDevMode and pSecurityDescriptor used to be defined as DWORD, but this doesn't work
            // across 32b and 64b.
            // These pointers must be set on NULL, otherwise RPC will marshall them as strings.
            //
            pPrinterInfo->pDevMode = NULL;

        } else {

            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;
        }

        if (pPrinterInfo->pSecurityDescriptor) {

            SecurityContainer.cbBuf = GetSecurityDescriptorLength(pPrinterInfo->pSecurityDescriptor);
            SecurityContainer.pSecurity = pPrinterInfo->pSecurityDescriptor;

            //
            // Set pSecurityDescriptor to NULL.
            //
            pPrinterInfo->pSecurityDescriptor = NULL;

        } else {

            SecurityContainer.cbBuf = 0;
            SecurityContainer.pSecurity = NULL;
        }

        if (!pPrinterInfo->pPrinterName) {
            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }

        if ( pScratchBuffer = AllocSplMem( MAX_UNC_PRINTER_NAME )) {

            wsprintf( pScratchBuffer, L"%ws\\%ws", pName, pPrinterInfo->pPrinterName );
            pCopyPrinterName = AllocSplStr( pScratchBuffer );
            FreeSplMem( pScratchBuffer );
        }

    } else {

        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;

        SecurityContainer.cbBuf = 0;
        SecurityContainer.pSecurity = NULL;
    }

   EnterSplSem();


        pSpool = AllocWSpool();

   LeaveSplSem();

    if ( pSpool != NULL ) {

        pSpool->pName = pCopyPrinterName;

        pCopyPrinterName = NULL;

        RpcTryExcept {

            if ( (ReturnValue = RpcValidate()) ||
                 (ReturnValue = RpcAddPrinterEx(pName,
                                        (PPRINTER_CONTAINER)&PrinterContainer,
                                        (PDEVMODE_CONTAINER)&DevModeContainer,
                                        (PSECURITY_CONTAINER)&SecurityContainer,
                                        &SplClientContainer,
                                        &hPrinter)) ) {

                SetLastError(ReturnValue);
                hPrinter = INVALID_HANDLE_VALUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwRpcError = RpcExceptionCode();

        } RpcEndExcept

        if ( dwRpcError == RPC_S_PROCNUM_OUT_OF_RANGE ) {

            dwRpcError = ERROR_SUCCESS;
            RpcTryExcept {

                if ( ReturnValue = RpcAddPrinter
                                        (pName,
                                         (PPRINTER_CONTAINER)&PrinterContainer,
                                         (PDEVMODE_CONTAINER)&DevModeContainer,
                                         (PSECURITY_CONTAINER)&SecurityContainer,
                                         &hPrinter) ) {

                    SetLastError(ReturnValue);
                    hPrinter = INVALID_HANDLE_VALUE;
                }

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                dwRpcError = RpcExceptionCode();

            } RpcEndExcept

        }

        if ( dwRpcError ) {

            SetLastError(dwRpcError);
            hPrinter = INVALID_HANDLE_VALUE;
        }


       EnterSplSem();

        if ( hPrinter != INVALID_HANDLE_VALUE ) {

            pSpool->RpcHandle = hPrinter;

        } else {

            FreepSpool( pSpool );
            pSpool = NULL;

        }

       LeaveSplSem();


    } else {

        // Failed to allocate Printer Handle

        FreeSplStr( pCopyPrinterName );
    }

    if( Level == 2 ) {

        //
        // Restore pSecurityDescriptor and pDevMode. They were set to NULL to avoid RPC marshalling.
        //
        (LPBYTE)((PPRINTER_INFO_2)pPrinter)->pSecurityDescriptor = SecurityContainer.pSecurity;

        (LPBYTE)((PPRINTER_INFO_2)pPrinter)->pDevMode = DevModeContainer.pDevMode;
    }

    SplOutSem();

    return (HANDLE)pSpool;
}

BOOL
DeletePrinter(
   HANDLE   hPrinter
)
{
    BOOL  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if ( ReturnValue = RpcDeletePrinter(pSpool->RpcHandle) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return ReturnValue;
}


/* SavePrinterConnectionInRegistry
 *
 * Saves data in the registry for a printer connection.
 * Creates a key under the current impersonation client's key
 * in the registry under \Printers\Connections.
 * The printer name is stripped of backslashes, since the registry
 * API does not permit the creation of keys with backslashes.
 * They are replaced by commas, which are invalid characters
 * in printer names, so we should never get one passed in.
 *
 *
 * *** WARNING ***
 *
 * IF YOU MAKE CHANGES TO THE LOCATION IN THE REGISTRY
 * WHERE PRINTER CONNECTIONS ARE STORED, YOU MUST MAKE
 * CORRESPONDING CHANGES IN USER\USERINIT\USERINIT.C.
 *
 */
BOOL
SavePrinterConnectionInRegistry(
    LPWSTR           pRealName,
    LPBYTE           pDriverInfo,
    DWORD            dwLevel
)
{
    TCHAR  string[ MAX_UNC_PRINTER_NAME ];
    HKEY   hClientKey = NULL;
    HKEY   hConnectionsKey;
    HKEY   hPrinterKey;
    LPWSTR pKeyName = NULL;
    LPWSTR pData;
    DWORD Status = NO_ERROR;
    BOOL   rc = TRUE;
    LPDRIVER_INFO_2 pDriverInfo2 = (LPDRIVER_INFO_2) pDriverInfo;

    hClientKey = GetClientUserHandle(KEY_READ);

    if ( hClientKey == NULL ) {

        DBGMSG( DBG_WARNING, ("SavePrinterConnectionInRegistry failed %d\n", GetLastError() ));
        return FALSE;
    }


    Status = RegCreateKeyEx( hClientKey, szRegistryConnections,
                             REG_OPTION_RESERVED, NULL, REG_OPTION_NON_VOLATILE,
                             KEY_WRITE, NULL, &hConnectionsKey, NULL );

    if (Status == NO_ERROR) {

        pKeyName = FormatPrinterForRegistryKey( pRealName, string );

        Status = RegCreateKeyEx( hConnectionsKey, pKeyName, REG_OPTION_RESERVED,
                                 NULL, 0, KEY_WRITE, NULL, &hPrinterKey, NULL);

        if (Status == NO_ERROR) {

            switch ( dwLevel ) {

                case 2:
                case 3:
                case 4:
                    //
                    // DRIVER_INFO_3,4 are supersets of 2 with DRIVER_INFO_2
                    // at the beginning
                    //
                    if (!SET_REG_VAL_DWORD(hPrinterKey, szVersion, pDriverInfo2->cVersion))
                        rc = FALSE;

                    if (!SET_REG_VAL_SZ(hPrinterKey, szName, pDriverInfo2->pName))
                        rc = FALSE;

                    //  Note - None of the following values are required for NT 3.51 release or there after.
                    //  We continue to write them incase someone has floating profiles and thus
                    //  needs this stuff on 3.5 - 3.1 Daytona or before machine.
                    //  Consider removing it in CAIRO ie assume that everyone has upgraded to 3.51 release

                    // Now write the driver files minus path:

                    if (!(pData = wcsrchr(pDriverInfo2->pConfigFile, '\\')))
                        pData = pDriverInfo2->pConfigFile;
                    else
                        pData++;

                    if (!SET_REG_VAL_SZ(hPrinterKey, szConfigurationFile, pData))
                        rc = FALSE;

                    if (!(pData = wcsrchr(pDriverInfo2->pDataFile, '\\')))
                        pData = pDriverInfo2->pDataFile;
                    else
                        pData++;

                    if (!SET_REG_VAL_SZ(hPrinterKey, szDataFile, pData))
                        rc = FALSE;

                    if (!(pData = wcsrchr(pDriverInfo2->pDriverPath, '\\')))
                        pData = pDriverInfo2->pDriverPath;
                    else
                        pData++;

                     if (!SET_REG_VAL_SZ(hPrinterKey, szDriver, pData))
                        rc = FALSE;

                    break;

                default:
                    DBGMSG(DBG_ERROR, ("SavePrinterConnectionInRegistry: invalid level %d", dwLevel));
                    SetLastError(ERROR_INVALID_LEVEL);
                    rc = FALSE;
            }

            RegCloseKey(hPrinterKey);

        } else {

            DBGMSG(DBG_WARNING, ("RegCreateKeyEx(%ws) failed: Error %d\n",
                                 pKeyName, Status ));
            SetLastError( Status );
            rc = FALSE;
        }

        // Now close the hConnectionsKey, we are done with it

        RegCloseKey( hConnectionsKey );

    } else {

        DBGMSG( DBG_WARNING, ("RegCreateKeyEx(%ws) failed: Error %d\n",
                               szRegistryConnections, Status ));
        SetLastError( Status );
        rc = FALSE;
    }


    if (!rc) {

        DBGMSG( DBG_WARNING, ("Error updating registry: %d\n",
                               GetLastError()));    // This may not be the error

        if ( pKeyName )
            RegDeleteKey( hClientKey, pKeyName );
    }

    RegCloseKey( hClientKey );

    return rc;
}

BOOL
InternalDeletePrinterConnection(
    LPWSTR   pName,
    BOOL     bNotifyDriver
    )

/*++

Routine Description:

    Delete a printer connection (printer name or share name) that
    belongs to win32spl.dll.

    Note: The Router takes care of updating win.ini and per user connections
          section based on returning True / False.

Arguments:

    pName - Either a printer or share name.
    bNotifyDriver - flag to notify the driver

Return Value:

    TRUE - success, FALSE - fail.  LastError set.

--*/

{
    BOOL  bReturnValue = FALSE;
    HKEY  hClientKey = NULL;
    HKEY  hPrinterConnectionsKey = NULL;
    DWORD i;
    WCHAR szBuffer[MAX_UNC_PRINTER_NAME + 30]; // space for szRegistryConnections
    DWORD cbBuffer;
    PWCACHEINIPRINTEREXTRA pExtraData;
    HANDLE  hSplPrinter = NULL;
    HANDLE  hIniSpooler = NULL;
    DWORD   cRef;

    WCHAR   PrinterInfo1[ MAX_PRINTER_INFO1 ];
    LPPRINTER_INFO_1W pPrinter1 = (LPPRINTER_INFO_1W)&PrinterInfo1;

    LPWSTR  pConnectionName = pName;

#if DBG
    SetLastError( 0 );
#endif

 try {

    if ( !VALIDATE_NAME( pName ) ) {
        SetLastError( ERROR_INVALID_NAME );
        leave;
    }

    //
    // If the Printer is in the Cache then Decrement its connection
    // reference count.
    //

    if( !OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, NULL, FALSE)){

        DWORD dwLastError;

        hSplPrinter = NULL;
        hIniSpooler = NULL;

        dwLastError = GetLastError();

        if (( dwLastError != ERROR_INVALID_PRINTER_NAME ) &&
            ( dwLastError != ERROR_INVALID_NAME )) {

            DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed OpenCachePrinterOnly %ws error %d\n", pName, dwLastError ));
            leave;
        }

        //
        // Printer Is NOT in Cache,
        //
        // Continue to remove from HKEY_CURRENT_USER
        // Can happen with Floating Profiles
        //

    } else {

        //
        // Printer is in Cache
        // Support for DeletetPrinterConnection( \\server\share );
        //

        if( !SplGetPrinter( hSplPrinter,
                            1,
                            (LPBYTE)pPrinter1,
                            sizeof( PrinterInfo1),
                            &cbBuffer )){

            DBGMSG( DBG_WARNING, ("DeletePrinterConenction failed SplGetPrinter %d hSplPrinter %x\n", GetLastError(), hSplPrinter ));
            SPLASSERT( pConnectionName == pName );

        } else {
            pConnectionName = pPrinter1->pName;
        }

        //
        //  Update Connection Reference Count
        //

       EnterSplSem();

        if( !SplGetPrinterExtra( hSplPrinter, &(PBYTE)pExtraData )){

            DBGMSG( DBG_WARNING,
                    ("DeletePrinterConnection SplGetPrinterExtra pSplPrinter %x error %d\n",
                    hSplPrinter, GetLastError() ));

            pExtraData = NULL;
        }

        if (( pExtraData != NULL ) &&
            ( pExtraData->cRef != 0 )) {

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            pExtraData->cRef--;
            cRef = pExtraData->cRef;

        } else {

            cRef = 0;
        }


       LeaveSplSem();


        if ( cRef == 0 ) {

            //
            //  Allow the Driver to do Per Cache Connection Cleanup
            //

            if (bNotifyDriver) {
                SplDriverEvent( pConnectionName, PRINTER_EVENT_CACHE_DELETE, (LPARAM)NULL );
            }

            //
            //  Remove Cache for this printer
            //

            if ( !SplDeletePrinter( hSplPrinter )) {

                DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed SplDeletePrinter %d\n", GetLastError() ));
                leave;
            }

        } else {

            if ( !SplSetPrinterExtra( hSplPrinter, (LPBYTE)pExtraData ) ) {

                DBGMSG( DBG_ERROR, ("DeletePrinterConnection SplSetPrinterExtra failed %x\n", GetLastError() ));
                leave;
            }
        }

        SplOutSem();
    }

    //
    //  Note pConnectionName will either be the name passed in
    //  or if the Printer was in the Cache, would be the printer
    //  name from the cache.
    //  This will allow somone to call DeleteprinterConnection
    //  with a UNC Share name.
    //

    hClientKey = GetClientUserHandle(KEY_READ);

    if ( hClientKey == NULL ) {

        DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed %d\n", GetLastError() ));
        leave;
    }


    wcscpy( szBuffer, szRegistryConnections );

    i = wcslen(szBuffer);
    szBuffer[i++] = L'\\';

    FormatPrinterForRegistryKey( pConnectionName, szBuffer + i );

    if( ERROR_SUCCESS != RegOpenKeyEx( hClientKey,
                                       szBuffer,
                                       0,
                                       KEY_READ,
                                       &hPrinterConnectionsKey )){

        if ( pConnectionName == pName ) {

            SetLastError( ERROR_INVALID_PRINTER_NAME );
            leave;
        }

        //
        // If we have a printer on the server whose sharename is the same
        // as a previously deleted printers printername then CacheOpenPrinter
        // would have succeded but you are not going to find the share name in
        // the registry
        //
        FormatPrinterForRegistryKey( pName, szBuffer + i );

        if ( ERROR_SUCCESS != RegOpenKeyEx(hClientKey,
                                           szBuffer,
                                           0,
                                           KEY_READ,
                                           &hPrinterConnectionsKey) ) {

            SetLastError( ERROR_INVALID_PRINTER_NAME );
            leave;
        }
    }

    //
    // Common case is success, so set the return value here.
    // Only if we fail will we set it to FALSE now.
    //
    bReturnValue = TRUE;

    cbBuffer = sizeof(szBuffer);

    //
    // If there is a Provider value, and it doesn't match win32spl.dll,
    // then fail the call.
    //
    // If the provider value isn't there, succeed for backward
    // compatibility.
    //
    if( ERROR_SUCCESS == RegQueryValueEx( hPrinterConnectionsKey,
                                          L"Provider",
                                          NULL,
                                          NULL,
                                          (LPBYTE)szBuffer,
                                          &cbBuffer) &&
        _wcsicmp( szBuffer, L"win32spl.dll" )){

        bReturnValue = FALSE;
        SetLastError( ERROR_INVALID_PRINTER_NAME );
    }

    RegCloseKey( hPrinterConnectionsKey );

 } finally {

    if( hClientKey ){
        RegCloseKey( hClientKey );
    }

    if( hSplPrinter ){
        if (!SplClosePrinter( hSplPrinter )){
            DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed to close hSplPrinter %x error %d\n", hSplPrinter, GetLastError() ));
        }
    }

    if( hIniSpooler ){
        if( !SplCloseSpooler( hIniSpooler )){
            DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed to close hSplSpooler %x error %d\n", hIniSpooler, GetLastError() ));
        }
    }
 }

    if( !bReturnValue ){
        SPLASSERT( GetLastError( ));
    }

    return bReturnValue;
}

BOOL
DeletePrinterConnection(
    LPWSTR   pName
    )
{
    return InternalDeletePrinterConnection(pName, TRUE);
}

BOOL
SetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    BOOL                ReturnValue;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    PPRINTER_INFO_2     pPrinterInfo2;
    PPRINTER_INFO_3     pPrinterInfo3;
    PPRINTER_INFO_5     pPrinterInfo5;
    PPRINTER_INFO_6     pPrinterInfo6;
    PPRINTER_INFO_7     pPrinterInfo7;
    PWSPOOL             pSpool = (PWSPOOL)hPrinter;
    BOOL                bNeedToFreeDevMode = FALSE;
    HANDLE              hDevModeChgInfo = NULL;
    LPDEVMODE           pOldDevMode = NULL;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Type != SJ_WIN32HANDLE) {

        return LMSetPrinter(hPrinter, Level, pPrinter, Command);

    }

    SYNCRPCHANDLE( pSpool );

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SecurityContainer.cbBuf = 0;
    SecurityContainer.pSecurity = NULL;

    switch (Level) {

    case 0:
    case 1:

        break;


    case 2:

        pPrinterInfo2 = (PPRINTER_INFO_2)pPrinter;

        if (pPrinterInfo2->pDevMode) {

            if ( pSpool->bNt3xServer ) {

                //
                // If Nt 3xserver we will set devmode only if we can convert
                //
                if ( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) {

                    hDevModeChgInfo = LoadDriverFiletoConvertDevmodeFromPSpool(pSpool->hSplPrinter);
                    if ( hDevModeChgInfo ) {

                        SPLASSERT( pSpool->pName != NULL );

                        if ( ERROR_SUCCESS == CallDrvDevModeConversion(
                                                hDevModeChgInfo,
                                                pSpool->pName,
                                                (LPBYTE)pPrinterInfo2->pDevMode,
                                                (LPBYTE *)&DevModeContainer.pDevMode,
                                                &DevModeContainer.cbBuf,
                                                CDM_CONVERT351,
                                                TRUE) ) {

                            bNeedToFreeDevMode = TRUE;
                        }
                    }
                }
            } else {

                DevModeContainer.cbBuf = pPrinterInfo2->pDevMode->dmSize +
                                         pPrinterInfo2->pDevMode->dmDriverExtra;
                DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo2->pDevMode;
            }

            //
            // Set pDevMode to NULL. Import.h defines pDevMode and pSecurityDescriptor as pointers now.
            // pDevMode and pSecurityDescriptor used to be defined as DWORD, but this doesn't work
            // across 32b and 64b.
            // These pointers must be set on NULL, otherwise RPC will marshall them as strings.
            //
            pOldDevMode = pPrinterInfo2->pDevMode;
            pPrinterInfo2->pDevMode = NULL;

        }

        if (pPrinterInfo2->pSecurityDescriptor) {

            SecurityContainer.cbBuf = GetSecurityDescriptorLength(pPrinterInfo2->pSecurityDescriptor);
            SecurityContainer.pSecurity = pPrinterInfo2->pSecurityDescriptor;
            //
            // Set pSecurityDescriptor to NULL.
            //
            pPrinterInfo2->pSecurityDescriptor = NULL;

        }
        break;

    case 3:

        pPrinterInfo3 = (PPRINTER_INFO_3)pPrinter;

        //
        // If this is NULL, should we even rpc out?
        //

        if (pPrinterInfo3->pSecurityDescriptor) {

            SecurityContainer.cbBuf = GetSecurityDescriptorLength(pPrinterInfo3->pSecurityDescriptor);
            SecurityContainer.pSecurity = pPrinterInfo3->pSecurityDescriptor;
        }

        break;

    case 5:

        pPrinterInfo5 = (PPRINTER_INFO_5)pPrinter;
        break;

    case 6:

        pPrinterInfo6 = (PPRINTER_INFO_6)pPrinter;
        break;

    case 7:

        pPrinterInfo7 = (PPRINTER_INFO_7)pPrinter;
        break;

    default:

        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    RpcTryExcept {

        if ( ReturnValue = RpcSetPrinter(pSpool->RpcHandle,
                                    (PPRINTER_CONTAINER)&PrinterContainer,
                                    (PDEVMODE_CONTAINER)&DevModeContainer,
                                    (PSECURITY_CONTAINER)&SecurityContainer,
                                    Command) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    if( Level == 2 ) {

        //
        // Restore pSecurityDescriptor and pDevMode. They were set to NULL to avoid RPC marshalling.
        //
        (LPBYTE)pPrinterInfo2->pSecurityDescriptor = SecurityContainer.pSecurity;

        pPrinterInfo2->pDevMode = pOldDevMode;
    }

    if ( bNeedToFreeDevMode )
        FreeSplMem(DevModeContainer.pDevMode);

    if ( hDevModeChgInfo )
        UnloadDriverFile(hDevModeChgInfo);

    return ReturnValue;
}

BOOL
RemoteGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL        ReturnValue = FALSE;
    DWORD       dwReturnValue = 0;
    FieldInfo   *pFieldInfo;
    PWSPOOL     pSpool = (PWSPOOL)hPrinter;
    LPBYTE      pNewPrinter = NULL;
    DWORD       dwNewSize;
    SIZE_T      cbStruct;
    DWORD       cReturned = 1;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case STRESSINFOLEVEL:
            pFieldInfo = PrinterInfoStressFields;
            cbStruct = sizeof(PRINTER_INFO_STRESS);
            break;

        case 1:
            pFieldInfo = PrinterInfo1Fields;
            cbStruct = sizeof(PRINTER_INFO_1);
            break;

        case 2:
            pFieldInfo = PrinterInfo2Fields;
            cbStruct = sizeof(PRINTER_INFO_2);
            break;

        case 3:
            pFieldInfo = PrinterInfo3Fields;
            cbStruct = sizeof(PRINTER_INFO_3);
            break;

        case 5:
            pFieldInfo = PrinterInfo5Fields;
            cbStruct = sizeof(PRINTER_INFO_5);
            break;

        case 6:
            pFieldInfo = PrinterInfo6Fields;
            cbStruct = sizeof(PRINTER_INFO_6);
            break;

        case 7:
            pFieldInfo = PrinterInfo7Fields;
            cbStruct = sizeof(PRINTER_INFO_7);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        if (pPrinter)
            memset(pPrinter, 0, cbBuf);

        //
        // If going to different version and we have localspl handle want
        // to do devmode conversion
        //
        if ( Level == 2 &&
             (pSpool->Status & WSPOOL_STATUS_USE_CACHE) ) {

            dwNewSize       = cbBuf + MAX_PRINTER_INFO2;
            pNewPrinter = AllocSplMem(dwNewSize);

            if ( !pNewPrinter )
                goto Cleanup;
        } else {

            dwNewSize       = cbBuf;
            pNewPrinter     = pPrinter;
        }

        do {

            RpcTryExcept {

                dwReturnValue = RpcGetPrinter(   pSpool->RpcHandle,
                                                 Level,
                                                 pNewPrinter,
                                                 dwNewSize,
                                                 pcbNeeded);

                dwReturnValue = UpdateBufferSize(    pFieldInfo,
                                                     cbStruct,
                                                     pcbNeeded,
                                                     dwNewSize,
                                                     dwReturnValue,
                                                     &cReturned);

                if ( dwReturnValue ){

                    if ( Level == 2 &&
                         pNewPrinter != pPrinter &&
                         dwReturnValue == ERROR_INSUFFICIENT_BUFFER ) {

                        FreeSplMem(pNewPrinter);

                        dwNewSize = *pcbNeeded;
                        pNewPrinter = AllocSplMem(dwNewSize);
                        // do loop if pNewPrinter != NULL
                    } else {

                        SetLastError(dwReturnValue);
                        ReturnValue = FALSE;
                    }

                } else {

                    ReturnValue = TRUE;


                    if (pNewPrinter &&
                        (ReturnValue = MarshallUpStructure(pNewPrinter, pFieldInfo, cbStruct, RPC_CALL))) {

                        if (Level == 2 ) {

                            //
                            //  In the Cache && Different OS Level
                            //

                            if ( pNewPrinter != pPrinter ) {

                                SPLASSERT(pSpool->Status & WSPOOL_STATUS_USE_CACHE);
                                SPLASSERT(pSpool->pName != NULL );

                                ReturnValue = DoDevModeConversionAndBuildNewPrinterInfo2(
                                                (LPPRINTER_INFO_2)pNewPrinter,
                                                *pcbNeeded,
                                                pPrinter,
                                                cbBuf,
                                                pcbNeeded,
                                                pSpool);
                            }

                            if ( ReturnValue ) {

                                ((PPRINTER_INFO_2)pPrinter)->Attributes |=
                                                    PRINTER_ATTRIBUTE_NETWORK;
                                ((PPRINTER_INFO_2)pPrinter)->Attributes &=
                                                    ~PRINTER_ATTRIBUTE_LOCAL;
                            }
                        }

                        if (Level == 5) {
                            ((PPRINTER_INFO_5)pPrinter)->Attributes |=
                                                    PRINTER_ATTRIBUTE_NETWORK;
                            ((PPRINTER_INFO_5)pPrinter)->Attributes &=
                                                    ~PRINTER_ATTRIBUTE_LOCAL;
                        }
                    }

                }

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(RpcExceptionCode());

                //
                // This will be thrown by the server if a cbBuf > 1 Meg is
                // passed across the wire.
                //
                SPLASSERT( GetLastError() != ERROR_INVALID_USER_BUFFER );
                ReturnValue = FALSE;

            } RpcEndExcept

        } while ( Level == 2 &&
                  dwReturnValue == ERROR_INSUFFICIENT_BUFFER &&
                  pNewPrinter != pPrinter &&
                  pNewPrinter );

    } else {
        return LMGetPrinter(hPrinter, Level, pPrinter, cbBuf, pcbNeeded);
    }

Cleanup:

    if ( pNewPrinter != pPrinter )
        FreeSplMem(pNewPrinter );

    return ReturnValue;
}


BOOL
AddPrinterDriverEx(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   pDriverInfo,
    DWORD   dwFileCopyFlags
)
{
    BOOL                   bReturnValue;
    DWORD                  dwRpcError = 0, dwReturnValue;
    DRIVER_CONTAINER       DriverContainer;
    PDRIVER_INFO_2W        pDriverInfo2 = (PDRIVER_INFO_2W) pDriverInfo;
    PDRIVER_INFO_3W        pDriverInfo3 = (PDRIVER_INFO_3W) pDriverInfo;
    PDRIVER_INFO_6W        pDriverInfo6 = (PDRIVER_INFO_6W) pDriverInfo;
    LPRPC_DRIVER_INFO_6W   pRpcDriverInfo6 = NULL;
    LPWSTR                 pBase, pStr;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    //
    // The dwFileCopyFlags don't send the APD_DRIVER_SIGNATURE_VALID to the remote
    // machine. This is because for now we only support check-pointing on the local
    // machine only. Maybe in the future when this is supported on all skus we could
    // do a version check here and support check-pointing remote.
    //
    dwFileCopyFlags &= ~APD_DONT_SET_CHECKPOINT;

    //
    // ClientSide should have set a default environment if one was not
    // specified.
    //
    switch (Level) {
        case 2:
            SPLASSERT( ( pDriverInfo2->pEnvironment != NULL ) &&
                       (*pDriverInfo2->pEnvironment != L'\0') );
            break;

        case 3:
        case 4:
            SPLASSERT( ( pDriverInfo3->pEnvironment != NULL ) &&
                       (*pDriverInfo3->pEnvironment != L'\0') );
            break;

        case 6:
            SPLASSERT( ( pDriverInfo6->pEnvironment != NULL ) &&
                       (*pDriverInfo6->pEnvironment != L'\0') );
            break;

        default:
            DBGMSG(DBG_ERROR, ("RemoteAddPrinterDriver: invalid level %d", Level));
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    DriverContainer.Level = Level;
    if ( Level == 2 ) {

        DriverContainer.DriverInfo.Level2 = (DRIVER_INFO_2 *)pDriverInfo;

    } else {

        //
        // Level == 3 || Level == 4 || Level == 6
        //
        if( !( pRpcDriverInfo6 = AllocSplMem( sizeof( *pRpcDriverInfo6 )))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;

        } else {

            pRpcDriverInfo6->cVersion         = pDriverInfo3->cVersion;
            pRpcDriverInfo6->pName            = pDriverInfo3->pName;
            pRpcDriverInfo6->pEnvironment     = pDriverInfo3->pEnvironment;
            pRpcDriverInfo6->pDriverPath      = pDriverInfo3->pDriverPath;
            pRpcDriverInfo6->pDataFile        = pDriverInfo3->pDataFile;
            pRpcDriverInfo6->pConfigFile      = pDriverInfo3->pConfigFile;
            pRpcDriverInfo6->pHelpFile        = pDriverInfo3->pHelpFile;
            pRpcDriverInfo6->pMonitorName     = pDriverInfo3->pMonitorName;
            pRpcDriverInfo6->pDefaultDataType = pDriverInfo3->pDefaultDataType;

            //
            // Set the char count of the mz string.
            // NULL   --- 0
            // szNULL --- 1
            // string --- number of characters in the string including the last '\0'
            //
            if ( pBase = pDriverInfo3->pDependentFiles ) {

                for ( pStr = pBase ; *pStr; pStr += wcslen(pStr) + 1 )
                ;
                pRpcDriverInfo6->cchDependentFiles = (DWORD) (pStr - pBase + 1);

                if ( pRpcDriverInfo6->cchDependentFiles )
                    pRpcDriverInfo6->pDependentFiles = pBase;
            } else {

                pRpcDriverInfo6->cchDependentFiles = 0;
            }

            if ( (Level == 4 || Level==6)    &&
                 (pBase = ((LPDRIVER_INFO_4W)pDriverInfo)->pszzPreviousNames) ) {

                pRpcDriverInfo6->pszzPreviousNames = pBase;

                for ( pStr = pBase; *pStr ; pStr += wcslen(pStr) + 1 )
                ;

                pRpcDriverInfo6->cchPreviousNames = (DWORD) (pStr - pBase + 1);
            } else {

                pRpcDriverInfo6->cchPreviousNames = 0;
            }

            if (Level==6) {
                pRpcDriverInfo6->pMfgName          = pDriverInfo6->pszMfgName;
                pRpcDriverInfo6->pOEMUrl           = pDriverInfo6->pszOEMUrl;
                pRpcDriverInfo6->pHardwareID       = pDriverInfo6->pszHardwareID;
                pRpcDriverInfo6->pProvider         = pDriverInfo6->pszProvider;
                pRpcDriverInfo6->ftDriverDate      = pDriverInfo6->ftDriverDate;
                pRpcDriverInfo6->dwlDriverVersion  = pDriverInfo6->dwlDriverVersion;
            }

            DriverContainer.DriverInfo.Level6 = pRpcDriverInfo6;
        }

    }

    RpcTryExcept {

        if ( (dwReturnValue = RpcValidate()) ||
             (dwReturnValue = RpcAddPrinterDriverEx(pName,
                                                    &DriverContainer,
                                                    dwFileCopyFlags)) ) {

            SetLastError(dwReturnValue);
            bReturnValue = FALSE;
        } else {
            bReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwRpcError = RpcExceptionCode();
        bReturnValue = FALSE;

    } RpcEndExcept

    if ((dwRpcError == RPC_S_PROCNUM_OUT_OF_RANGE) &&
        (dwFileCopyFlags == APD_COPY_NEW_FILES)) {

        bReturnValue = TRUE;
        dwRpcError = ERROR_SUCCESS;

        RpcTryExcept {

            if ( dwReturnValue = RpcAddPrinterDriver(pName,
                                                     &DriverContainer) ) {
                SetLastError(dwReturnValue);
                bReturnValue = FALSE;
            } else {
                bReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwRpcError = RpcExceptionCode();
            bReturnValue = FALSE;

        } RpcEndExcept

    }

    if ( dwRpcError ) {

        if (dwRpcError == RPC_S_INVALID_TAG ) {
           dwRpcError = ERROR_INVALID_LEVEL;
        }

        SetLastError(dwRpcError);
    }

    FreeSplMem(pRpcDriverInfo6);

    return bReturnValue;
}


BOOL
RemoteAddPrinterDriver(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   pDriverInfo
    )
{
    return AddPrinterDriverEx(pName, Level, pDriverInfo, APD_COPY_NEW_FILES);
}


BOOL
EnumPrinterDrivers(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, ReturnValue;
    FieldInfo *pFieldInfo;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPrinterDrivers(pName, pEnvironment, Level,
                                                  pDriverInfo, cbBuf,
                                                  pcbNeeded, pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) )
        {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        }
        else
        {
            ReturnValue = TRUE;

            if (pDriverInfo) {

                if(! MarshallUpStructuresArray( pDriverInfo, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL)ReturnValue;
}

BOOL
RemoteGetPrinterDriverDirectory(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcGetPrinterDriverDirectory(pName, pEnvironment,
                                                         Level,
                                                         pDriverDirectory,
                                                         cbBuf, pcbNeeded)) ) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
DeletePrinterDriver(
    LPWSTR    pName,
    LPWSTR    pEnvironment,
    LPWSTR    pDriverName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrinterDriver(pName,
                                                   pEnvironment,
                                                   pDriverName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;

}


BOOL
DeletePrinterDriverEx(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName,
   DWORD     dwDeleteFlag,
   DWORD     dwVersionNum
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrinterDriverEx(pName,
                                                     pEnvironment,
                                                     pDriverName,
                                                     dwDeleteFlag,
                                                     dwVersionNum)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
AddPerMachineConnection(
   LPCWSTR    pServer,
   LPCWSTR    pPrinterName,
   LPCWSTR    pPrintServer,
   LPCWSTR    pProvider
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME((LPWSTR)pServer) || MyUNCName((LPWSTR)pServer) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddPerMachineConnection((LPWSTR) pServer,
                                                       pPrinterName,
                                                       pPrintServer,
                                                       pProvider)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePerMachineConnection(
   LPCWSTR    pServer,
   LPCWSTR    pPrinterName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME((LPWSTR) pServer) || MyUNCName((LPWSTR) pServer) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePerMachineConnection((LPWSTR) pServer,
                                                          pPrinterName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPerMachineConnections(
   LPCWSTR    pServer,
   LPBYTE     pPrinterEnum,
   DWORD      cbBuf,
   LPDWORD    pcbNeeded,
   LPDWORD    pcReturned
)
{
    BOOL  ReturnValue;
    FieldInfo *pFieldInfo = PrinterInfo4Fields;
    DWORD cbStruct = sizeof(PRINTER_INFO_4),index;

    if ( !VALIDATE_NAME((LPWSTR) pServer) || MyUNCName((LPWSTR) pServer) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPerMachineConnections((LPWSTR) pServer,
                                                         pPrinterEnum,
                                                         cbBuf,
                                                         pcbNeeded,
                                                         pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
            if (pPrinterEnum) {

                if(! MarshallUpStructuresArray(pPrinterEnum, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL)ReturnValue;
}

BOOL
AddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
)
{
    BOOL ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddPrintProcessor(pName , pEnvironment,pPathName,
                                                 pPrintProcessorName)) ) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPrintProcessors(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, ReturnValue;
    FieldInfo *pFieldInfo;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPrintProcessors(pName, pEnvironment, Level,
                                                   pPrintProcessorInfo, cbBuf,
                                                   pcbNeeded, pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPrintProcessorInfo) {

                if(! MarshallUpStructuresArray( pPrintProcessorInfo, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
EnumPrintProcessorDatatypes(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, i, cbStruct;
    FieldInfo *pFieldInfo;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = DatatypeInfo1Fields;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPrintProcessorDatatypes(pName,
                                                           pPrintProcessorName,
                                                           Level,
                                                           pDatatypes,
                                                           cbBuf,
                                                           pcbNeeded,
                                                           pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pDatatypes) {

                if(! MarshallUpStructuresArray( pDatatypes, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
GetPrintProcessorDirectory(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcGetPrintProcessorDirectory(pName, pEnvironment,
                                                          Level,
                                                          pPrintProcessorDirectory,
                                                          cbBuf, pcbNeeded)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}
DWORD
StartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL ReturnValue;
    GENERIC_CONTAINER DocInfoContainer;
    DWORD   JobId;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;

    VALIDATEW32HANDLE( pSpool );


    if (Win32IsGoingToFile(pSpool, pDocInfo1->pOutputFile)) {

        HANDLE hFile;

        //
        // POLICY?
        //
        // If no datatype is specified, and the default is non-raw,
        // should we fail?
        //
        if( pDocInfo1 &&
            pDocInfo1->pDatatype &&
            !ValidRawDatatype( pDocInfo1->pDatatype )){

            SetLastError( ERROR_INVALID_DATATYPE );
            return FALSE;
        }

        pSpool->Status |= WSPOOL_STATUS_PRINT_FILE;
        hFile = CreateFile( pDocInfo1->pOutputFile, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL );
        if (hFile == INVALID_HANDLE_VALUE) {
            return FALSE;
        } else {
            pSpool->hFile = hFile;
            return TRUE;
        }
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        DocInfoContainer.Level = Level;
        DocInfoContainer.pData = pDocInfo;

        RpcTryExcept {

            if ( ReturnValue = RpcStartDocPrinter(pSpool->RpcHandle,
                                                  (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                                   &JobId) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = JobId;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMStartDocPrinter(hPrinter, Level, pDocInfo);

    return ReturnValue;
}

BOOL
StartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );


    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        return TRUE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if ( ReturnValue = RpcStartPagePrinter(pSpool->RpcHandle) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMStartPagePrinter(hPrinter);

    return ReturnValue;
}

BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    BOOL ReturnValue=TRUE;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    *pcWritten = 0;

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {

        ReturnValue = WriteFile(pSpool->hFile, pBuf, cbBuf, pcWritten, NULL);
        return ReturnValue;

    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            // Note this code used chop the request into 4k chunks which were
            // the prefered size for Rpc.   However the client dll batches all
            // data into 4k chunks so no need to duplcate that code here.

            if (ReturnValue = RpcWritePrinter(pSpool->RpcHandle, pBuf, cbBuf, pcWritten)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept


    } else {

        return LMWritePrinter(hPrinter, pBuf, cbBuf, pcWritten);

    }

    return ReturnValue;
}

BOOL
SeekPrinter(
    HANDLE  hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWrite
)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
FlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)
{
    BOOL     bReturn = TRUE;
    DWORD    dwError;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    RpcTryExcept {

        if ((dwError = RpcValidate()) ||
            (dwError = RpcFlushPrinter(pSpool->RpcHandle,
                                       pBuf,
                                       cbBuf,
                                       pcWritten,
                                       cSleep)))
        {
            SetLastError( dwError );
            bReturn = FALSE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError( RpcExceptionCode() );
        bReturn = FALSE;

    } RpcEndExcept

    return bReturn;
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        return TRUE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcEndPagePrinter(pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMEndPagePrinter(hPrinter);

    return ReturnValue;
}

BOOL
AbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcAbortPrinter(pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMAbortPrinter(hPrinter);

    return ReturnValue;
}

BOOL
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
)
{
    BOOL ReturnValue=TRUE;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );


    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE ) {
        return FALSE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcReadPrinter(pSpool->RpcHandle, pBuf, cbBuf, pNoBytesRead)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMReadPrinter(hPrinter, pBuf, cbBuf, pNoBytesRead);

    return ReturnValue;
}

BOOL
RemoteEndDocPrinter(
   HANDLE   hPrinter
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        CloseHandle( pSpool->hFile );
        pSpool->hFile = INVALID_HANDLE_VALUE;
        pSpool->Status &= ~WSPOOL_STATUS_PRINT_FILE;
        return TRUE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcEndDocPrinter(pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMEndDocPrinter(hPrinter);

   return ReturnValue;
}

BOOL
AddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL     ReturnValue = FALSE;
    DWORD    dwRet = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    DWORD    cReturned = 1;
    FieldInfo *pFieldInfo;
    SIZE_T   cbStruct;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = AddJobFields;
            cbStruct = sizeof(ADDJOB_INFO_1W);
            break;
        case 2:
        case 3:
            //
            // Block level 2 & 3 calls across the network.
            //
        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (dwRet = RpcAddJob(pSpool->RpcHandle, Level, pData,cbBuf, pcbNeeded) ) {

                dwRet = UpdateBufferSize(pFieldInfo, cbStruct, pcbNeeded, cbBuf, dwRet, &cReturned);

                SetLastError(dwRet);
                ReturnValue = FALSE;

            } else {

                ReturnValue = MarshallUpStructure(pData, AddJobFields, cbStruct, RPC_CALL);
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMAddJob(hPrinter, Level, pData, cbBuf, pcbNeeded);

    return ReturnValue;
}

BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcScheduleJob(pSpool->RpcHandle, JobId)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMScheduleJob(hPrinter, JobId);

    return ReturnValue;
}

DWORD
RemoteGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcGetPrinterData(pSpool->RpcHandle, pValueName, pType,
                                             pData, nSize, pcbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    return ReturnValue;
}

DWORD
RemoteGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcGetPrinterDataEx( pSpool->RpcHandle,
                                                pKeyName,
                                                pValueName,
                                                pType,
                                                pData,
                                                nSize,
                                                pcbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    return ReturnValue;
}


DWORD
RemoteEnumPrinterData(
   HANDLE   hPrinter,
   DWORD    dwIndex,
   LPWSTR   pValueName,
   DWORD    cbValueName,
   LPDWORD  pcbValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    cbData,
   LPDWORD  pcbData
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    // Downlevel variables
    LPWSTR  pKeyName = NULL;
    PWCHAR  pPrinterName = NULL;
    PWCHAR  pScratch = NULL;
    PWCHAR  pBuffer = NULL;
    LPPRINTER_INFO_1W pPrinter1 = NULL;
    PWCHAR  pMachineName = NULL;
    HKEY    hkMachine = INVALID_HANDLE_VALUE;
    HKEY    hkDownlevel = INVALID_HANDLE_VALUE;
    DWORD   dwNeeded;


    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pValueName && !cbValueName)
            pValueName = (LPWSTR) &ReturnValue;

        if( !pData && !cbData )
            pData = (PBYTE)&ReturnValue;

        if (!pType)
            pType = (PDWORD) &ReturnType;


        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterData(  pSpool->RpcHandle,
                                                dwIndex,
                                                pValueName,
                                                cbValueName,
                                                pcbValueName,
                                                pType,
                                                pData,
                                                cbData,
                                                pcbData
                                              );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    // If the remote spooler doesn't support EnumPrinterData, do it the old way
    if (ReturnValue == RPC_S_PROCNUM_OUT_OF_RANGE) {

        pBuffer    = AllocSplMem((wcslen(pszRemoteRegistryPrinters) + MAX_UNC_PRINTER_NAME)*sizeof(WCHAR));
        pScratch   = AllocSplMem(MAX_UNC_PRINTER_NAME*sizeof(WCHAR));
        pPrinter1  = AllocSplMem(MAX_PRINTER_INFO1);

        if (pBuffer == NULL || pScratch == NULL || pPrinter1 == NULL) {
            ReturnValue = GetLastError();
            goto DownlevelDone;
        }

        SPLASSERT ( 0 == _wcsnicmp( pSpool->pName, L"\\\\", 2 ) ) ;
        SPLASSERT ( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        wcscpy( pBuffer, pSpool->pName);
        pPrinterName = wcschr( pBuffer+2, L'\\' );
        *pPrinterName = L'\0';
        pMachineName = AllocSplStr( pBuffer );

        if (pMachineName == NULL) {
            ReturnValue = GetLastError();
            goto DownlevelDone;
        }

        //  We cannot use pSpool->pName since this might be the share name which will
        //  fail if we try to use it as a registry key on the remote machine
        //  Get the full friendly name from the cache

        if ( !SplGetPrinter( pSpool->hSplPrinter, 1, (LPBYTE)pPrinter1, MAX_PRINTER_INFO1, &dwNeeded )) {
            DBGMSG( DBG_ERROR, ("RemoteEnumPrinterData failed SplGetPrinter %d pSpool %x\n", GetLastError(), pSpool ));
            ReturnValue = GetLastError();
            goto    DownlevelDone;
        }

        pPrinterName = wcschr( pPrinter1->pName+2, L'\\' );

        if ( pPrinterName++ == NULL ) {
            ReturnValue = ERROR_INVALID_PARAMETER;
            goto    DownlevelDone;
        }

        //
        //  Generate the Correct KeyName from the Printer Name
        //

        DBGMSG( DBG_TRACE,(" pSpool->pName %ws pPrinterName %ws\n", pSpool->pName, pPrinterName));

        pKeyName = FormatPrinterForRegistryKey( pPrinterName, pScratch );
        wsprintf( pBuffer, pszRemoteRegistryPrinters, pKeyName );

        //  Because there is no EnumPrinterData downlevel we are forced to open the remote registry
        //  for LocalSpl and use the registry RegEnumValue to read through the printer data
        //  values.

        ReturnValue = RegConnectRegistry( pMachineName, HKEY_LOCAL_MACHINE, &hkMachine);

        if (ReturnValue != ERROR_SUCCESS) {
            DBGMSG( DBG_WARNING, ("RemoteEnumPrinterData RegConnectRegistry error %d\n",GetLastError()));
            goto    DownlevelDone;
        }

        ReturnValue = RegOpenKeyEx(hkMachine, pBuffer, 0, KEY_READ, &hkDownlevel);

        if ( ReturnValue != ERROR_SUCCESS ) {

            DBGMSG( DBG_WARNING, ("RemoteEnumPrinterData RegOpenKeyEx %ws error %d\n", pBuffer, ReturnValue ));
            goto    DownlevelDone;
        }

        // Get the max sizes
        if (!cbValueName && !cbData) {
            ReturnValue = RegQueryInfoKey(  hkDownlevel,    // Key
                                            NULL,           // lpClass
                                            NULL,           // lpcbClass
                                            NULL,           // lpReserved
                                            NULL,           // lpcSubKeys
                                            NULL,           // lpcbMaxSubKeyLen
                                            NULL,           // lpcbMaxClassLen
                                            NULL,           // lpcValues
                                            pcbValueName,   // lpcbMaxValueNameLen
                                            pcbData,        // lpcbMaxValueLen
                                            NULL,           // lpcbSecurityDescriptor
                                            NULL            // lpftLastWriteTime
                                        );

            *pcbValueName = (*pcbValueName + 1)*sizeof(WCHAR);

        } else {   // Do an enum

            *pcbValueName = cbValueName/sizeof(WCHAR);
            *pcbData = cbData;
            ReturnValue = RegEnumValue( hkDownlevel,
                                        dwIndex,
                                        pValueName,
                                        pcbValueName,
                                        NULL,
                                        pType,
                                        pData,
                                        pcbData
                                      );
            *pcbValueName = (*pcbValueName + 1)*sizeof(WCHAR);
        }

DownlevelDone:

        FreeSplMem(pBuffer);
        FreeSplStr(pScratch);
        FreeSplMem(pPrinter1);
        FreeSplStr(pMachineName);

        if (hkMachine != INVALID_HANDLE_VALUE)
            RegCloseKey(hkMachine);

        if (hkDownlevel != INVALID_HANDLE_VALUE)
            RegCloseKey(hkDownlevel);
    }

    return ReturnValue;
}


DWORD
RemoteEnumPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPBYTE   pEnumValues,
   DWORD    cbEnumValues,
   LPDWORD  pcbEnumValues,
   LPDWORD  pnEnumValues
)
{
    DWORD   ReturnValue = 0;
    DWORD   RpcReturnValue = 0;
    DWORD   i;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PPRINTER_ENUM_VALUES pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pEnumValues && !cbEnumValues)
            pEnumValues = (LPBYTE) &ReturnValue;


        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterDataEx(pSpool->RpcHandle,
                                                pKeyName,
                                                pEnumValues,
                                                cbEnumValues,
                                                pcbEnumValues,
                                                pnEnumValues);

            RpcReturnValue = ReturnValue;

            ReturnValue = UpdateBufferSize(PrinterEnumValuesFields,
                                           sizeof(PRINTER_ENUM_VALUES),
                                           pcbEnumValues,
                                           cbEnumValues,
                                           ReturnValue,
                                           pnEnumValues);

            //
            // When talking with a 32bit machine, the buffer could be big enough to acomodate
            // the data packed on 32bit boundaries but not big enough to expand it for 64bit.
            // In this case, UpdateBufferSize fails with ERROR_INSUFFICIENT_BUFFER which
            // is a valid error for all printing APIs but EnumPrinterDataEx.
            // SDK specifies that EnumPrinterDataEx should fail with ERROR_MORE_DATA in this case,
            // so here we go.
            //
            //
            if (RpcReturnValue == ERROR_SUCCESS &&
                ReturnValue == ERROR_INSUFFICIENT_BUFFER) {

                ReturnValue = ERROR_MORE_DATA;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept



        if (ReturnValue == ERROR_SUCCESS) {
            if (pEnumValues) {

                SIZE_T   ShrinkedSize = 0;
                SIZE_T   Difference = 0;

                if (GetShrinkedSize(PrinterEnumValuesFields, &ShrinkedSize)) {

                    //
                    // SplEnumPrinterDataEx ( in localspl.dll ) packs the data right after
                    // the end of array of PPRINTER_ENUM_VALUES structures. Our Marshalling
                    // code relies on the fact that there is enough unused space between the end of
                    // structure/array and the beginning of data to expand a 32bit flat structure to
                    // a 64 bit structure.For all other structures we pack data from end to beginning
                    // of buffer. localspl.dll could have been fixed to do the same thing, but Win2K
                    // servers would still have this problem.
                    // The fix is to still ask for bigger buffers for 64bit (UpdateBufferSize)
                    // and then move the chunk containing data inside the buffer so that it leaves
                    // space for structure to grow.
                    // On Win32 we don't do anything since ShrinkedSize is equal with sizeof(PRINTER_ENUM_VALUES).
                    //
                    MoveMemory((LPBYTE)pEnumValue + sizeof(PRINTER_ENUM_VALUES) * (*pnEnumValues),
                               (LPBYTE)pEnumValue + ShrinkedSize * (*pnEnumValues),
                               cbEnumValues - sizeof(PRINTER_ENUM_VALUES) * (*pnEnumValues));

                    //
                    // Difference is the number of bytes we moved data section inside pEnumValue buffer
                    // It should be 0 in Win32
                    //
                    Difference = (sizeof(PRINTER_ENUM_VALUES) - ShrinkedSize ) * (*pnEnumValues);

                    if(! MarshallUpStructuresArray((LPBYTE) pEnumValue, *pnEnumValues, PrinterEnumValuesFields,
                                                    sizeof(PRINTER_ENUM_VALUES), RPC_CALL) ) {
                        ReturnValue = GetLastError();
                    }

                    //
                    // We need to adjust the offsets with Difference inside structures since data got moved.
                    //
                    AdjustPointersInStructuresArray((LPBYTE) pEnumValue, *pnEnumValues, PrinterEnumValuesFields,
                                                    sizeof(PRINTER_ENUM_VALUES), Difference);

                } else {

                    ReturnValue = GetLastError();
                }

            }
        }
    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    return ReturnValue;
}



DWORD
RemoteEnumPrinterKey(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPWSTR   pSubkey,
   DWORD    cbSubkey,
   LPDWORD  pcbSubkey
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pSubkey && !cbSubkey)
            pSubkey = (LPWSTR) &ReturnValue;


        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterKey(pSpool->RpcHandle,
                                             pKeyName,
                                             pSubkey,
                                             cbSubkey,
                                             pcbSubkey
                                             );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    return ReturnValue;
}



DWORD
RemoteDeletePrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterData(pSpool->RpcHandle, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if ( ReturnValue == ERROR_SUCCESS )
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    return ReturnValue;
}


DWORD
RemoteDeletePrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterDataEx(pSpool->RpcHandle, pKeyName, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if ( ReturnValue == ERROR_SUCCESS )
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    return ReturnValue;
}


DWORD
RemoteDeletePrinterKey(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterKey(pSpool->RpcHandle, pKeyName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if ( ReturnValue == ERROR_SUCCESS )
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    return ReturnValue;
}



DWORD
SetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterData(pSpool->RpcHandle, pValueName, Type,
                                            pData, cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    //
    //  Make sure Driver Data Cache is consistent
    //


    if ( ReturnValue == ERROR_SUCCESS ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    return ReturnValue;
}


DWORD
RemoteSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterDataEx(  pSpool->RpcHandle,
                                                pKeyName,
                                                pValueName,
                                                Type,
                                                pData,
                                                cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }


    if ( ReturnValue == ERROR_SUCCESS ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    return ReturnValue;
}



BOOL
RemoteClosePrinter(
    HANDLE  hPrinter
)
{
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_OPEN_ERROR) {

        DBGMSG(DBG_WARNING, ("Closing dummy handle to %ws\n", pSpool->pName));

       EnterSplSem();

        FreepSpool( pSpool );

       LeaveSplSem();

        return TRUE;
    }

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            RpcClosePrinter(&pSpool->RpcHandle);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        } RpcEndExcept

        //
        // If we failed for some reason, then RpcClosePrinter did not
        // zero out the context handle.  Destroy it here.
        //
        if( pSpool->RpcHandle ){
            RpcSmDestroyClientContext( &pSpool->RpcHandle );
        }

        EnterSplSem();

         pSpool->RpcHandle = INVALID_HANDLE_VALUE;
         FreepSpool( pSpool );

        LeaveSplSem();

    } else

        return LMClosePrinter(hPrinter);

    return TRUE;
}

DWORD
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
)
{
    DWORD   ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if( pSpool->Status & WSPOOL_STATUS_NOTIFY ){
        DBGMSG( DBG_WARNING, ( "WPC: Already waiting.\n" ));
        SetLastError( ERROR_ALREADY_WAITING );
        return 0;
    }

    pSpool->Status |= WSPOOL_STATUS_NOTIFY;

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcWaitForPrinterChange(pSpool->RpcHandle, Flags, &Flags)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = Flags;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        ReturnValue = LMWaitForPrinterChange(hPrinter, Flags);
    }

    pSpool->Status &= ~WSPOOL_STATUS_NOTIFY;

    return ReturnValue;
}

BOOL
AddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER   FormContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        FormContainer.Level = Level;
        FormContainer.pData = pForm;

        RpcTryExcept {

            if (ReturnValue = RpcAddForm(pSpool->RpcHandle, (PFORM_CONTAINER)&FormContainer)) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }


    return ReturnValue;
}

BOOL
DeleteForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName
)
{
    BOOL  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcDeleteForm(pSpool->RpcHandle, pFormName)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }


    return ReturnValue;
}

BOOL
RemoteGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    SIZE_T   cbStruct;
    DWORD   cReturned = 1;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = FormInfo1Fields;
            cbStruct = sizeof(FORM_INFO_1);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        if (pForm)
            memset(pForm, 0, cbBuf);

        RpcTryExcept {

            if (ReturnValue = RpcGetForm(pSpool->RpcHandle, pFormName, Level, pForm, cbBuf,
                                         pcbNeeded) ) {

                ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             &cReturned);

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    ReturnValue = MarshallUpStructure(pForm, pFieldInfo, cbStruct, RPC_CALL);
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

BOOL
SetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER   FormContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        FormContainer.Level = Level;
        FormContainer.pData = pForm;

        RpcTryExcept {

            if (ReturnValue = RpcSetForm(pSpool->RpcHandle, pFormName,
                                    (PFORM_CONTAINER)&FormContainer)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }


    return ReturnValue;
}

BOOL
RemoteEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, cbStruct;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = FormInfo1Fields;
            cbStruct = sizeof(FORM_INFO_1);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (pForm)
                memset(pForm, 0, cbBuf);

            if (ReturnValue = RpcEnumForms(pSpool->RpcHandle, Level,
                                           pForm, cbBuf,
                                           pcbNeeded, pcReturned) ,

                ReturnValue = UpdateBufferSize(pFieldInfo,
                                               cbStruct,
                                               pcbNeeded,
                                               cbBuf,
                                               ReturnValue,
                                               pcReturned)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    if(! MarshallUpStructuresArray(pForm, *pcReturned, pFieldInfo,
                                                   cbStruct, RPC_CALL) ) {
                        return FALSE;
                    }

                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return (BOOL)ReturnValue;
}

BOOL
RemoteEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, cbStruct;
    FieldInfo *pFieldInfo;

    *pcReturned = 0;
    *pcbNeeded = 0;

    if (MyName(pName))
        return LMEnumPorts(pName, Level, pPort, cbBuf, pcbNeeded, pcReturned);

    if (MyUNCName(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = PortInfo1Fields;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pFieldInfo = PortInfo2Fields;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pPort)
            memset(pPort, 0, cbBuf);

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPorts(pName, Level, pPort,
                                         cbBuf, pcbNeeded,
                                         pcReturned ) ,

              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPort) {

                if(! MarshallUpStructuresArray( pPort, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
EnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitor,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, cbStruct;
    FieldInfo *pFieldInfo;

    *pcReturned = 0;
    *pcbNeeded = 0;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = MonitorInfo1Fields;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pFieldInfo = MonitorInfo2Fields;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pMonitor)
            memset(pMonitor, 0, cbBuf);

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumMonitors(pName, Level, pMonitor, cbBuf,
                                            pcbNeeded, pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pMonitor) {

                if(! MarshallUpStructuresArray( pMonitor, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
RemoteAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
)
{
    if (MyName(pName) || (VALIDATE_NAME(pName) && !MyUNCName(pName))) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
RemoteConfigurePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    if (MyName(pName) || (VALIDATE_NAME(pName) && !MyUNCName(pName))) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
RemoteDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    if (MyName(pName))
        return LMDeletePort(pName, hWnd, pPortName);

    if (MyName(pName) || (VALIDATE_NAME(pName) && !MyUNCName(pName))) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODE   pDevMode
)
{
    HANDLE  ReturnValue;
    DWORD   Error;
    DEVMODE_CONTAINER    DevModeContainer;
    HANDLE  hGdi;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        if (pDevMode)

            DevModeContainer.cbBuf = pDevMode->dmSize + pDevMode->dmDriverExtra;

        else

            DevModeContainer.cbBuf = 0;

        DevModeContainer.pDevMode = (LPBYTE)pDevMode;

        RpcTryExcept {

            if (Error = RpcCreatePrinterIC(pSpool->RpcHandle, &hGdi,
                                                 &DevModeContainer)) {

                SetLastError(Error);
                ReturnValue = FALSE;

            } else

                ReturnValue = hGdi;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {
        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    BOOL ReturnValue;

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcPlayGdiScriptOnPrinterIC(hPrinterIC, pIn, cIn,
                                                        pOut, cOut, ul)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
)
{
    BOOL    ReturnValue;

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrinterIC(&hPrinterIC)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

DWORD
PrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
AddMonitorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    BOOL  ReturnValue;
    MONITOR_CONTAINER   MonitorContainer;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    MonitorContainer.Level = Level;
    MonitorContainer.MonitorInfo.pMonitorInfo2 = (MONITOR_INFO_2 *)pMonitorInfo;

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddMonitor(pName, &MonitorContainer)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeleteMonitorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeleteMonitor(pName,
                                             pEnvironment,
                                             pMonitorName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrintProcessor(pName,
                                                    pEnvironment,
                                                    pPrintProcessorName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
GetPrintSystemVersion(
)
{
    DWORD Status;
    HKEY hKey;
    DWORD cbData;

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                          KEY_READ, &hKey);
    if (Status != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR, ("Cannot determine Print System Version Number\n"));
        return FALSE;
    }


    cbData = sizeof (cThisMinorVersion);
    if (RegQueryValueEx(hKey, szMinorVersion, NULL, NULL,
                    (LPBYTE)&cThisMinorVersion, &cbData)
                                            == ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("This Minor Version - %d\n", cThisMinorVersion));
    }

    RegCloseKey(hKey);

    return TRUE;
}



BOOL
RemoteAddPortEx(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
)
{
    DWORD   ReturnValue;
    PORT_CONTAINER PortContainer;
    PORT_VAR_CONTAINER PortVarContainer;
    PPORT_INFO_FF pPortInfoFF;
    PPORT_INFO_1 pPortInfo1;


    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    if (!lpBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (Level) {
    case (DWORD)-1:
        pPortInfoFF = (PPORT_INFO_FF)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfoFF = (PPORT_INFO_FF)pPortInfoFF;
        PortVarContainer.cbMonitorData = pPortInfoFF->cbMonitorData;
        PortVarContainer.pMonitorData = pPortInfoFF->pMonitorData;
        break;

    case 1:
        pPortInfo1 = (PPORT_INFO_1)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfo1 = (PPORT_INFO_1)pPortInfo1;
        PortVarContainer.cbMonitorData = 0;
        PortVarContainer.pMonitorData = NULL;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {
        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddPortEx(pName, (LPPORT_CONTAINER)&PortContainer,
                                         (LPPORT_VAR_CONTAINER)&PortVarContainer,
                                         lpMonitorName)) ) {

            SetLastError(ReturnValue);
            return FALSE;
        } else {
            return TRUE ;
        }
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        SetLastError(RpcExceptionCode());
        return  FALSE;

    } RpcEndExcept
}


BOOL
SetPort(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    )
{
    BOOL            ReturnValue = FALSE;
    PORT_CONTAINER  PortContainer;

    if ( !VALIDATE_NAME(pszName) || MyUNCName(pszName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (dwLevel) {

        case 3:
            PortContainer.Level                 = dwLevel;
            PortContainer.PortInfo.pPortInfo3   = (LPPORT_INFO_3W) pPortInfo;
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            goto Cleanup;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcSetPort(pszName, pszPortName, &PortContainer)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;
    } RpcEndExcept

Cleanup:
    return ReturnValue;
}

BOOL
RemoteXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus
)
{

    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hXcv;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pInputData && !cbInputData)
            pInputData = (PBYTE) &ReturnValue;

        if (!pOutputData && !cbOutputData)
            pOutputData = (PBYTE) &ReturnValue;


        RpcTryExcept {

            if (ReturnValue = RpcXcvData(   pSpool->RpcHandle,
                                            pszDataName,
                                            pInputData,
                                            cbInputData,
                                            pOutputData,
                                            cbOutputData,
                                            pcbOutputNeeded,
                                            pdwStatus)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

        if (!ReturnValue)
            DBGMSG(DBG_TRACE,("XcvData Exception: %d\n", GetLastError()));

    } else {

        SetLastError( ERROR_NOT_SUPPORTED );
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

DWORD
RemoteSendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    DWORD        dwRet   = ERROR_SUCCESS;
    PWSPOOL      pSpool  = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE)
    {

        RpcTryExcept
        {
            dwRet = RpcSendRecvBidiData(pSpool->RpcHandle,
                                        pAction,
                                        (PRPC_BIDI_REQUEST_CONTAINER)pReqData,
                                        (PRPC_BIDI_RESPONSE_CONTAINER*)ppResData);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            dwRet = RpcExceptionCode();
        }
        RpcEndExcept
    }
    else
    {
        dwRet = ERROR_NOT_SUPPORTED;
    }

    return (dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\debug.c ===
/*****************************************************************************\
* MODULE: debug.cxx
*
* Debugging routines.  This is only linked in on DEBUG builds.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation
* Copyright (C) 1996-1998 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifdef DEBUG

#include <windows.h>
#include "debug.h"

DWORD gdwDbgLevel = DBG_LEV_ALL;

VOID CDECL DbgMsgOut(
    LPCSTR lpszMsgFormat,
    ...)
{
    char szMsgText[DBG_MAX_TEXT];

    wvsprintf(szMsgText,
              lpszMsgFormat,
              (LPSTR)(((LPSTR)(&lpszMsgFormat)) + sizeof(lpszMsgFormat)));

    lstrcat(szMsgText, "\n");

    OutputDebugString(szMsgText);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\globals.h ===
/*****************************************************************************\
* MODULE: globals.h
*
* Global variables used throughout the library.
*
*
* Copyright (C) 1996-1998 Hewlett Packard Company.
* Copyright (C) 1996-1998 Microsoft Corporation.
*
* History:
*   16-Mar-1999 CHW         Created, Localized.
*
\*****************************************************************************/

extern HINSTANCE g_hInst;


extern char cszDll16             [];
extern char cszDll32             [];
extern char cszDataSection       [];
extern char cszDriverFile        [];
extern char cszDataFile          [];
extern char cszConfigFile        [];
extern char cszHelpFile          [];
extern char cszPrintProcessor    [];
extern char cszDefaultDataType   [];
extern char cszVendorInstaller   [];
extern char cszVendorSetup       [];
extern char cszRetryTimeout      [];
extern char cszNotSelectedTimeout[];
extern char cszNoTestPage        [];
extern char cszUniqueID          [];
extern char cszMsgSvr            [];
extern char cszWinspl16          [];
extern char cszBackslash         [];
extern char cszComma             [];
extern char cszSpace             [];
extern char cszNull              [];


// Localized strings from resource.
//
extern HANDLE hszDefaultPrintProcessor;
extern HANDLE hszMSDefaultDataType;
extern HANDLE hszDefaultColorPath;
extern HANDLE hszFileInUse;

extern LPSTR cszDefaultPrintProcessor;
extern LPSTR cszMSDefaultDataType;
extern LPSTR cszDefaultColorPath;
extern LPSTR cszFileInUse;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\globals.c ===
/*****************************************************************************\
* MODULE: globals.h
*
* Global variables used throughout the library.
*
*
* Copyright (C) 1996-1999 Hewlett Packard Company.
* Copyright (C) 1996-1999 Microsoft Corporation.
*
* History:
*   16-Mar-1999 CHW         Created, Localized.
*
\*****************************************************************************/

#include "wpnpin16.h"

// Global variables.
//
HINSTANCE g_hInst;


// Unlocalized strings.
//
char cszDll16             [] = "wpnpin16.dll";
char cszDll32             [] = "wpnpin32.dll";
char cszDataSection       [] = "DataSection";
char cszDriverFile        [] = "DriverFile";
char cszDataFile          [] = "DataFile";
char cszConfigFile        [] = "ConfigFile";
char cszHelpFile          [] = "HelpFile";
char cszPrintProcessor    [] = "PrintProcessor";
char cszDefaultDataType   [] = "DefaultDataType";
char cszVendorInstaller   [] = "VendorInstaller";
char cszVendorSetup       [] = "VendorSetup";
char cszRetryTimeout      [] = "RetryTimeout";
char cszNotSelectedTimeout[] = "NotSelectedTimeout";
char cszNoTestPage        [] = "NoTestPage";
char cszUniqueID          [] = "PrinterID";
char cszMsgSvr            [] = SZMESSAGESERVERCLASS;
char cszWinspl16          [] = "winspl16";
char cszBackslash         [] = "\\";
char cszComma             [] = ",";
char cszSpace             [] = " ";
char cszNull              [] = "";


// Localized strings from resource.
//
HANDLE hszDefaultPrintProcessor = NULL;
HANDLE hszMSDefaultDataType     = NULL;
HANDLE hszDefaultColorPath      = NULL;
HANDLE hszFileInUse             = NULL;

LPSTR  cszDefaultPrintProcessor = NULL;
LPSTR  cszMSDefaultDataType     = NULL;
LPSTR  cszDefaultColorPath      = NULL;
LPSTR  cszFileInUse             = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\debug.h ===
/*****************************************************************************\
* MODULE: debug.h
*
* Header file for (debug.cxx).
*
* Double braces are needed for output macros.
*
*     DBGMSG(DBG_LEV_ERROR, ("Error code %d", Error));
*
* This is because we can't use variable parameter lists in macros.
* The statement gets pre-processed to a semi-colon in non-debug mode.
*
* Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
* Setting the flag in the low word causes that level to be printed;
* setting the high word causes a break into the debugger.
* E.g. setting it to 0x00040006 will print out all warning and error
* messages, and break on errors.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation
* Copyright (C) 1996-1998 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifdef DEBUG

extern DWORD gdwDbgLevel;


// Maximum size of debug string
//
#define DBG_MAX_TEXT       256


// Debug output levels.  By masking in the various levels, you can receive
// all levels of output.
//
#define DBG_LEV_INFO       0x00000001
#define DBG_LEV_CALLTREE   0x00000002
#define DBG_LEV_WARN       0x00000004
#define DBG_LEV_ERROR      0x00000008
#define DBG_LEV_FATAL      0x00000010

#define DBG_LEV_ALL        0x0000001F


// Function prototype for debug-routine (debug.c)
//
VOID CDECL DbgMsgOut(
    LPCSTR lpszMsgFormat,
    ...);


// Handy macros for use throughout the source.
//
#define DBG_BREAKPOINT()          DebugBreak();
#define DBG_MSG(Lev, MsgArgs)     {if (Lev & gdwDbgLevel) {DbgMsgOut MsgArgs;}}
#define DBG_ASSERT(Expr, MsgArgs) {if (!Expr) {DbgMsgOut MsgArgs; DebugBreak();}}

#else

#define DBG_BREAKPOINT()
#define DBG_MSG(Lev, MsgArgs)
#define DBG_ASSERT(Expr, MsgArgs)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\resource.h ===
/***************************************************************************
  *
  * File Name: RESOURCE.H
  *
  * Copyright 1997 Hewlett-Packard Company.  
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: Resource identifiers for WPNPIN16.DLL
  *
  * Author:  Garth Schmeling
  *        
  *
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/


// Resource String Identifiers.
//
#define IDS_DEFAULT_PRINTPROCESSOR  801
#define IDS_DEFAULT_DATATYPE        802
#define IDS_COLOR_PATH              803
#define IDS_ERR_FILE_IN_USE			804
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\libentry.asm ===
;------------------------------------------------------------------------------
; LIBRARY INITIALIZATION/STARUP
;
;
; Copyright (C) 1990-1994 Microsoft Corp.
;
; segment: _TEXT (WINV16)
; created: 28-Mar-91 <chriswil>
; history: 28-Mar-91 <chriswil> created.
;
;------------------------------------------------------------------------------

.xlist
include cmacros.inc
?PLM=1
?WIN=1
memS EQU 1
assumes cs,CODE
.list

externFP <LocalInit>
externFP <UnlockSegment>
externFP <LibMain>
externCP <__acrtused>

sBegin  CODE
;------------------------------------------------------------------------------
; LIBRARY ENTRY-POINT - <DOS ONLY>
;   This routine is called to setup a dll upon entry.  It does the nifty
;   task of initializing a dll's heap and calls a standard entry routine.
;   When initializing a heap, windows locks the dataseg, so we must unlock
;   it ourselves.
;
;   Upon entry, Windows sets up the registers with particular values for
;   us to use in setting up a heap, and identifying a process.
;
;       DI - Instance handle of the module
;       DS - Segement address for the library data-seg
;       CX - Size of heap to initialize.
;       ES - Segment of command line arguments.
;       SI - Offset of command line arguments.
;
;
;
; created: 28-Mar-91 <chriswil>
; history: 28-Mar-91 <chriswil> created.
;
;------------------------------------------------------------------------------
cProc LoadLib,<FAR,PUBLIC>,<si,di>
cBegin
     jcxz NoHeap                        ; If Heap == 0, then we don't want one.

     xor ax,ax                          ; Clear return register
     push ds                            ; Setup stack for the call to the
     push ax                            ;   LocalInit() function.
     push cx                            ;
     call LocalInit                     ; Call LocalInit()
     or   ax,ax                         ; If LocalInit failed (0), then we
     jz   LoadLibDone;                  ;   return FALSE.
     push ds                            ; else we unlock the dataseg
     call UnlockSegment                 ;

NoHeap:

     push di                            ; Setup stack for the call to the
     push ds                            ;   LibMain() function.
     push es                            ;
     push si                            ;
     call LibMain                       ; Call LibMain()

LoadLibDone:                            ; Return AX to Windows

cEnd

sEnd CODE
end LoadLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\debug.cxx ===
/*****************************************************************************\
* MODULE: debug.cxx
*
* Debugging routines.  This is only linked in on DEBUG builds.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation.
* Copyright (C) 1996-1998 Hewlett Packard Company.
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifdef DEBUG

#include "libpriv.h"

DWORD gdwDbgLevel = DBG_LEV_ALL;

VOID CDECL DbgMsgOut(
    LPCTSTR lpszMsgFormat,
    ...)
{
    va_list pvParms;
    TCHAR   szMsgText[DBG_MAX_TEXT];

    va_start(pvParms, lpszMsgFormat);
    wvsprintf(szMsgText, lpszMsgFormat, pvParms);
    va_end(pvParms);

    lstrcat(szMsgText, g_szNewLine);

    OutputDebugString(szMsgText);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\makefile.inc ===
WOWINC = ..\wow\inc
WOWLIB = ..\wow\lib

PROJ        = wpnpin16
DEBUG       = 1
PROGTYPE    = 1
D_RCDEFINES =-DDEBUG
R_RCDEFINES =-DNDEBUG
PROJPATH    = win95\obj\i386

PATH=$(_NTDRIVE)$(_NTROOT)\private\tools16;$(PATH)

TOOLS16=$(_NTDRIVE)$(_NTROOT)\tools\tools16
CC16=$(TOOLS16)\cl16
CPP16=$(TOOLS16)\cl16
CXX16=$(TOOLS16)\cl16
RC16=$(TOOLS16)\rc16
MASM=$(TOOLS16)\masm
LINK16=$(TOOLS16)\link16

INCS = -I$(WOWINC) -I$(_NTDRIVE)$(_NTROOT)\public\sdk\inc -I..\inc

CFLAGS_D_WDLL = /nologo /G2sw /Zp1 /W3 /ALw /Od /Zd /DDEBUG /DNOPRSHT /FR
CFLAGS_R_WDLL = /nologo /G2sw /Zp1 /W3 /ALw /Ox /DNDEBUG /DNOPRSHT /FR
LFLAGS_D_WDLL = /NOLOGO /BATCH /NOD /NOE /PACKC:61440 /ALIGN:16 /MAP /CO ..\thunk\win95\obj\i386\thk16.obj
LFLAGS_R_WDLL = /NOLOGO /BATCH /NOD /NOE /PACKC:61440 /ALIGN:16 /MAP ..\thunk\win95\obj\i386\thk16.obj
LIBS_D_WDLL   = libw ldllcew setupx commdlg.lib olecli.lib olesvr.lib shell.lib lzexpand
LIBS_R_WDLL   = libw ldllcew setupx commdlg.lib olecli.lib olesvr.lib shell.lib lzexpand

RESFLAGS = /nologo
LIBS_EXT =

!if "$(DEBUG)" == "1"
CFLAGS    = $(CFLAGS_D_WDLL)
LFLAGS    = $(LFLAGS_D_WDLL)
LIBS      = $(LIBS_D_WDLL)
RCDEFINES = $(D_RCDEFINES)
!else
CFLAGS    = $(CFLAGS_R_WDLL)
LFLAGS    = $(LFLAGS_R_WDLL)
LIBS      = $(LIBS_R_WDLL)
RCDEFINES = $(R_RCDEFINES)
!endif


OBJS = $(PROJPATH)\wpnpin16.obj \
       $(PROJPATH)\debug.obj    \
       $(PROJPATH)\globals.obj  \
       $(PROJPATH)\libentry.obj

all: $(PROJPATH)\$(PROJ).dll

.asm{$(PROJPATH)}.obj:
    $(MASM) -w2 $(INCS) $(@B).asm, $*.obj;

.c{$(PROJPATH)}.obj:
    @set include=..\wow\inc;..\inc;$(_NTDRIVE)$(_NTROOT)\public\sdk\inc
    $(CC16) $(CFLAGS) /Fo$* /c $(*F).c

.rc{$(PROJPATH)}.res:
    $(RC16) $(INCS) $(RCDEFINES) -r -fo $*.res $(*F).rc


$(PROJPATH)\$(PROJ).dll:: $(OBJS) $(PROJPATH)\wpnpin16.res $(PROJ).def
        echo >NUL @<<$(PROJ).crf
$(OBJS)
$(PROJPATH)\$(PROJ).dll
$(PROJPATH)\$(PROJ).map
..\wow\lib\+
..\thunk\+
$(LIBS)
$(PROJ).def;
<<
        $(LINK16) $(LFLAGS) @$(PROJ).CRF
        $(RC16) $(RESFLAGS) $(PROJPATH)\WPNPIN16.RES $@
        implib /nowep $(PROJPATH)\$(PROJ).LIB $(PROJPATH)\$(PROJ).DLL
    mapsym -o $(PROJPATH)\$(PROJ).sym $(PROJPATH)\$(PROJ).map
    binplace -o $(ALT_PROJECT_TARGET) $@
    binplace -o $(ALT_PROJECT_TARGET)\symbols $(PROJPATH)\$(PROJ).sym
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\sources.inc ===
!IF 0
/*---------------------------------------------------------------------------*\
| MODULE: sources
|
|
| history:
|   15-Dec-1997 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
!ENDIF

TARGETNAME    =
TARGETTYPE    = NOTARGET
TARGETPATH    =
SOURCES       =
SOURCES_USED  = ..\sources.inc

!IF $(386)
NTTARGETFILE1 = buildall
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\win95\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
#***************************************************************************/

buildall:
    cd..   
    nmake /f makefile.inc ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)
    cd $(ALT_PROJECT_TARGET)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\wpnpin16.h ===
/***************************************************************************
  *
  * File Name: WPNPIN16.H
  *
  * Copyright 1997 Hewlett-Packard Company.  
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: Definitions and typedefs for WPNPIN16.DLL
  *
  * Author:  Garth Schmeling
  *        
  *
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/


#include <windows.h>
#include <string.h>
#include <lzexpand.h>
#include "globals.h"
#include "debug.h"


// definitions and typedefs in order to be able to 
// include prsht.h, setupx.h and lpsi.h
//
#define USECOMM
#define OEMRESOURCE
#define WINCAPI _cdecl

typedef DWORD HKEY;
typedef HKEY FAR * LPHKEY;
typedef BYTE FAR * LPBYTE;
typedef BYTE FAR * LPCBYTE;
typedef DWORD FAR* HPROPSHEETPAGE;

// must be defined before the #includes
//
#include <types.h>
#include <stat.h>
#include <direct.h>
#include <setupx.h>
#include "..\inc\lpsi.h"
#include "..\inc\hpmemory.h"
#include "..\inc\errormap.h"
#include "..\inc\msdefine.h"


#include "resource.h"

#define _MAX_RESBUF 128
#define _MAX_LINE	256

// types used by functions declared below
// must be defined after the #includes
//
typedef HINF	 *LPHINF;
typedef HINFLINE *LPHINFLINE;

typedef BOOL (FAR PASCAL* WEPPROC)(short);
typedef BOOL (WINAPI *LPQUEUEPROC)(LPSI, LPDRIVER_NODE);


// Declarations for functions exported by this 16-bit DLL
//
RETERR FAR PASCAL ParseINF16(LPSI lpsi);

BOOL FAR PASCAL thk_ThunkConnect16(LPSTR, LPSTR, WORD, DWORD);
BOOL FAR PASCAL DllEntryPoint(DWORD, WORD, WORD, WORD, DWORD, WORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\debug.h ===
/*****************************************************************************\
* MODULE: debug.h
*
* Header file for (debug.cxx).
*
* Double braces are needed for output macros.
*
*     DBGMSG(DBG_LEV_ERROR, ("Error code %d", Error));
*
* This is because we can't use variable parameter lists in macros.
* The statement gets pre-processed to a semi-colon in non-debug mode.
*
* Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
* Setting the flag in the low word causes that level to be printed;
* setting the high word causes a break into the debugger.
* E.g. setting it to 0x00040006 will print out all warning and error
* messages, and break on errors.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation.
* Copyright (C) 1996-1998 Hewlett Packard Company.
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifdef DEBUG

extern DWORD gdwDbgLevel;


// Maximum size of debug string
//
#define DBG_MAX_TEXT       256


// Debug output levels.  By masking in the various levels, you can receive
// all levels of output.
//
#define DBG_LEV_INFO       0x00000001
#define DBG_LEV_CALLTREE   0x00000002
#define DBG_LEV_WARN       0x00000004
#define DBG_LEV_ERROR      0x00000008
#define DBG_LEV_FATAL      0x00000010

#define DBG_LEV_ALL        0x0000001F


// Function prototype for debug-routine (debug.c)
//
VOID CDECL DbgMsgOut(
    LPCTSTR lpszMsgFormat,
    ...);


// Handy macros for use throughout the source.
//
#define DBG_BREAKPOINT()          DebugBreak();
#define DBG_MSG(Lev, MsgArgs)     {if (Lev & gdwDbgLevel) {DbgMsgOut MsgArgs;}}
#define DBG_ASSERT(Expr, MsgArgs) {if (!Expr) {DbgMsgOut MsgArgs; DebugBreak();}}

#else

#define DBG_BREAKPOINT()
#define DBG_MSG(Lev, MsgArgs)
#define DBG_ASSERT(Expr, MsgArgs)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll16\wpnpin16.c ===
/***************************************************************************
 *
 * File Name: WPNPIN16.C
 *
 * Copyright 1997 Hewlett-Packard Company.  
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho  83714
 *
 *   
 * Description: Source code for WPNPIN16.DLL
 *
 * Author:  Garth Schmeling
 *        
 *
 * Modification history:
 *
 * Date                Initials                Change description
 *
 * 10-10-97    GFS                             Initial checkin
 *
 *
 *
 ***************************************************************************/

#include "wpnpin16.h"

/*--------------- For Debug -------------------------*/
//#define GARTH_DEBUG 1


/*****************************************************************************\
* strFree
*
*   Free allocated string.
*
\*****************************************************************************/
VOID strFree(
    HANDLE hszStr,
    LPSTR  pszStr)
{
    if (hszStr && pszStr)
        GlobalUnlock(hszStr);

    if (hszStr)
        GlobalFree(hszStr);
}

/*****************************************************************************\
* strAlloc
*
*   Allocates a string from the heap.  This pointer must be freed with
*   a call to strFree().
*
\*****************************************************************************/
LPSTR strAlloc(
    LPHANDLE phSrc,
    LPCSTR   pszSrc)
{
    DWORD cbSize;
    LPSTR pszDst = NULL;


    *phSrc = NULL;
    cbSize = (pszSrc ? (lstrlen(pszSrc) + 1) : 0);


    if (cbSize && (*phSrc = GlobalAlloc(GPTR, cbSize))) {

        if (pszDst = (LPSTR)GlobalLock(*phSrc))
            lstrcpy(pszDst, pszSrc);
    }

    return pszDst;
}


/*****************************************************************************\
* strLoad
*
*   Get string from resource based upon the ID passed in.
*
\*****************************************************************************/
LPSTR strLoad(
    LPHANDLE phszStr,
    UINT     ids)
{
    char szStr[_MAX_RESBUF];


    if (LoadString(g_hInst, ids, szStr, sizeof(szStr)) == 0)
        szStr[0] = '\0';

    return strAlloc(phszStr, szStr);
}


/*****************************************************************************\
* InitStrings
*
*
\*****************************************************************************/
BOOL InitStrings(VOID)
{
    cszDefaultPrintProcessor = strLoad(&hszDefaultPrintProcessor, IDS_DEFAULT_PRINTPROCESSOR);
    cszMSDefaultDataType     = strLoad(&hszMSDefaultDataType    , IDS_DEFAULT_DATATYPE);
    cszDefaultColorPath      = strLoad(&hszDefaultColorPath     , IDS_COLOR_PATH);
    cszFileInUse             = strLoad(&hszFileInUse            , IDS_ERR_FILE_IN_USE);

    return (cszDefaultPrintProcessor &&
            cszMSDefaultDataType     &&
            cszDefaultColorPath      &&
            cszFileInUse);
}


/*****************************************************************************\
* FreeeStrings
*
*
\*****************************************************************************/
VOID FreeStrings(VOID)
{
    strFree(hszDefaultPrintProcessor, cszDefaultPrintProcessor);
    strFree(hszMSDefaultDataType    , cszMSDefaultDataType);
    strFree(hszDefaultColorPath     , cszDefaultColorPath);
    strFree(hszFileInUse            , cszFileInUse);
}


/*****************************************************************************\
* DllEntryPoint
*
*
\*****************************************************************************/
BOOL FAR PASCAL DllEntryPoint(
    DWORD dwReason,
	WORD  hInst,
	WORD  wDS,
	WORD  wHeapSize,
	DWORD dwReserved1,
	WORD  wReserved2)
{
    if (g_hInst == NULL) {

        g_hInst = (HINSTANCE)hInst;

        if (InitStrings() == FALSE)
            return FALSE;
    }

    return thk_ThunkConnect16(cszDll16, cszDll32, hInst, dwReason);
}


//-----------------------------------------------------------------------
// Function: lstrpbrk(lpSearch,lpTargets)
//
// Action: DBCS-aware version of strpbrk.
//
// Return: Pointer to the first character that in lpSearch that is also
//         in lpTargets. NULL if not found.
//
// Comment: Use nested loops to avoid allocating memory for DBCS stuff.
//-----------------------------------------------------------------------
LPSTR WINAPI lstrpbrk(LPSTR lpSearch,
					LPSTR lpTargets)
{
	LPSTR lpOneTarget;

	if (lpSearch AND lpTargets)
	{
		for (;
			 *lpSearch;
			 lpSearch=AnsiNext(lpSearch))
		{
			for (lpOneTarget=lpTargets;
				 *lpOneTarget;
				 lpOneTarget=AnsiNext(lpOneTarget))
			{
				if (*lpSearch==*lpOneTarget)
				{
					// First byte matches--see if we need to check
					// second byte
					if (IsDBCSLeadByte(*lpOneTarget))
					{
						if (*(lpSearch+1) == *(lpOneTarget+1))
							return lpSearch;
					}
					else
						return lpSearch;
				}
			}
		}
	}

	return NULL;
}



//-----------------------------------------------------------------------
// Function: lstrtok(lpSearch,lpTargets)
//
// Action: DBCS-aware version of strtok.
//
// Return: Pointer to next non-NULL token if found, NULL if not.
//-----------------------------------------------------------------------
LPSTR WINAPI lstrtok(LPSTR lpSearch,
					LPSTR lpTargets)
{
	static LPSTR lpLastSearch;
	LPSTR lpFound;
	LPSTR lpReturn=NULL;

	if (lpSearch)
		lpLastSearch=lpSearch;

	for (;
		 lpLastSearch AND *lpLastSearch;
		 lpLastSearch=AnsiNext(lpLastSearch))
	{
		// Skip leading white space
		while (' '==*lpLastSearch OR '\t'==*lpLastSearch)
			lpLastSearch++;

		if (lpFound=lstrpbrk(lpLastSearch,lpTargets))
		{
			if (lpFound==lpLastSearch)		 // Ignore NULL tokens
				continue;

			lpReturn=lpLastSearch;
			*lpFound='\0';
			lpLastSearch=lpFound+1;
			break;
		}
		else
		{
			lpReturn=lpLastSearch;
			lpLastSearch=NULL;
			break;
		}
	}

	return lpReturn;
}



//--------------------------------------------------------------------
// Function: FindCorrectSection(szInfFile,szManufacturer,szModel,szSection)
//
// Action: Find the install section in the inf file that corresponds 
//                 to the model name.  This may require several different approaches.
//                 Try the most likely first and then try others.  
//
// Side effect: Put the section name in szSection.
//
// Return: TRUE if the section was found, FALSE if not.
//         
//--------------------------------------------------------------------
BOOL WINAPI FindCorrectSection(
    LPSTR  szInfFile,
    LPSTR szManufacturer,
    LPSTR szModel,
    LPSTR szSection)
{
	HINF     hInf = 0;
	HINFLINE hInfLine = 0;
	int      i = 0;
	int      nCount = 0;
	int      nCopied = 0;
	int      nFields = 0;
	BOOL     bHaveManu = FALSE;
	char     lpszBuf[_MAX_LINE];
	char     lpszTemp[_MAX_LINE];
	char     lpszTemp2[_MAX_LINE];

	// Open the INF file.
	if (OK != IpOpen(szInfFile, &hInf))
	{
		return FALSE;
	}

	lstrcpy(lpszBuf, cszNull);
	lstrcpy(lpszTemp, cszNull);
	lstrcpy(lpszTemp2, cszNull);

	// Try # 1 to get the manufacturer's section name
	// Look for a section corresponding to the manufacturer's 
	// name.  Copy it to lpszBuf.  Open that section below.
	if (OK == IpFindFirstLine(hInf, szManufacturer, NULL, &hInfLine))
	{
		lstrcpy(lpszBuf, szManufacturer);
		bHaveManu = TRUE;

        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #1, Main [HP] Section"));

	} // Try # 1

	// Try # 2 to get the manufacturer's section name
	// Try the main [Manufacturer] section.
	// Cycle through each name expecting the name to be in the 
	// Strings section.
	if (!bHaveManu AND
		 (OK == IpFindFirstLine(hInf, "Manufacturer", NULL, &hInfLine)))
	{
		// Get the number of lines
		if (OK == IpGetLineCount(hInf, "Manufacturer", &nCount))
		{
			for (i = 0; i < nCount; i++)
			{
				lpszBuf[0] = '\0';
				lpszTemp[0] = '\0';     
				if (OK == IpGetStringField(hInf, hInfLine, 0, lpszTemp, _MAX_LINE, &nCopied))
				{
					GenFormStrWithoutPlaceHolders(lpszBuf,lpszTemp,hInf);

					// Garth: Use CompareString with the 
					// IGNORE_CASE, IGNORE_KANATYPE, and IGNORE_WIDTH flags
					if (lstrcmpi(szManufacturer, lpszBuf) == 0)
					{
						// We have found the manufacturer name, see if
						// there is a key on the right
						nFields = 0;
						if ( (OK == IpGetFieldCount(hInf, hInfLine, &nFields)) AND
							  (nFields > 0) )
						{
							if (OK == IpGetStringField(hInf, hInfLine, 1, lpszBuf, _MAX_LINE, &nCopied))
							{
								// There was a value on the right. It is stored in lpszBuf.
								// Just try to use it below as the name of the main section.

                                DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #2 Before NULL, lpszTemp = %s", lpszTemp));
                                DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : Manual Install = %s", lpszBuf));

								lpszTemp[0] = '\0';
							}
						}
						else
						{
							// There was no value on the right, use the name from
							// lpszTemp
							lpszBuf[0] = '\0';
							lstrcpy(lpszBuf, lpszTemp);

                            DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #3 Manual"));
						}

						bHaveManu = TRUE;
						break;
					}
				}

				if (OK != IpFindNextLine(hInf, &hInfLine))
				{
					break;
				}
			}
		}

	} // Try # 2


	// Try # 3 to get the manufacturer's section name
	// Try the main [Manufacturer] section.
	// The printer manufacturer name does not match the 
	// driver manufacturer name.  (IE Canon and Epson with GCA)
	// Check to see if there is only one name in the manufacturer section.
	if (!bHaveManu AND
		 (OK == IpFindFirstLine(hInf, "Manufacturer", NULL, &hInfLine)))
	{
		// Get the number of lines
		if (OK == IpGetLineCount(hInf, "Manufacturer", &nCount))
		{
			if (nCount IS 1)
			{
				// Only one line in manufaturer section.
				// This has to be our guy.
				// See if there is a key on the right
				nFields = 0;
				lpszBuf[0] = '\0';
				IpGetFieldCount(hInf, hInfLine, &nFields);

				if (nFields > 0)
				{
					if (OK == IpGetStringField(hInf, hInfLine, 1, lpszBuf, _MAX_LINE, &nCopied))
					{
						// There was a value on the right. It is stored in lpszBuf.
						// Try to use it below as the name of the main section.
                        //
                        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : Before NULL <%s>", lpszTemp));
                        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #4 One Manual <%s>", lpszBuf));

						lpszTemp[0] = '\0';
						bHaveManu = TRUE;
					}
				}
				else
				{
					// There was no value on the right.  Get the key on the left.
					if (OK == IpGetStringField(hInf, hInfLine, 0, lpszBuf, _MAX_LINE, &nCopied))
					{
						lpszTemp[0] = '\0';
						bHaveManu = TRUE;

                        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #6 One Manual"));
					}
				}
			}
		}

	} // Try # 3


	// Try # 4 to get the manufacturer's section name
	// Try a [PnP] section.
	if (!bHaveManu AND (OK == IpFindFirstLine(hInf, "PnP", NULL, &hInfLine)))
	{
		lpszBuf[0] = '\0';
		lstrcpy(lpszBuf, "PnP");
		bHaveManu = TRUE;

        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #6 [Pnp]"));

	} // Try # 4


	// Try # 6.  Get the install section associated with this
	// manufacturer and model.
	//
	// Look for a manufacturer's section with a profile key 
	// corresponding to the model name.  The first key on the RHS
	// should be the model section name.
    //
	if (bHaveManu AND (OK == IpFindFirstLine(hInf, lpszBuf, NULL, &hInfLine)))
	{
        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : Found first line <%s>", lpszBuf));
        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : Search for this model <%s>", szModel));

		lstrcpy(lpszTemp, cszNull);

		if (OK == IpGetProfileString(hInf,lpszBuf,szModel,lpszTemp,_MAX_LINE))
		{
            DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : Profile string before lstrtok"));

			lstrtok(lpszTemp, cszComma);

			// quick check of model section name
            //
			if (OK == IpFindFirstLine(hInf, lpszTemp, NULL, &hInfLine))
			{
				if (
					(OK == IpGetProfileString(hInf,lpszTemp,"CopyFiles",lpszTemp2,_MAX_LINE))
					OR (OK == IpGetProfileString(hInf,lpszTemp,"DataSection",lpszTemp2,_MAX_LINE))
					OR (OK == IpGetProfileString(hInf,lpszTemp,"DriverFile",lpszTemp2,_MAX_LINE))
					OR (OK == IpGetProfileString(hInf,lpszTemp,"DataFile",lpszTemp2,_MAX_LINE)))
				{
					lstrcpyn(szSection, lpszTemp, _MAX_PATH_);
					IpClose(hInf);

                    DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #7 Found Correct Section"));

					return TRUE;
				}


				// We have a bad INF file:
				// We have the manufacturer name and the model name and an
				// install section, but it doesn't have any of the keys we need.
				// bail.
                //
				IpClose(hInf);

                DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #8 Bad INF file"));

				return FALSE;
			}
		}


		// The model name doesn't appear as a profile string. 
		// Perhaps a variable from the Strings sections appears in its place.
		// Try that.
		if ( (OK == IpGetLineCount(hInf, lpszBuf, &nCount)) AND 
			  (OK == IpFindFirstLine(hInf, lpszBuf, NULL, &hInfLine)) )
		{
			for (i = 0; i < nCount; i++)
			{
				lstrcpy(lpszTemp, cszNull);     

				if (OK == IpGetStringField(hInf, hInfLine, 0, lpszTemp, _MAX_LINE, &nCopied))
				{
					GenFormStrWithoutPlaceHolders(lpszTemp2,lpszTemp,hInf);

                    DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : lpszTemp2=%s, lpszTemp=%s", lpszTemp2, lpszTemp));

					if (lstrcmpi(szModel, lpszTemp2) == 0)
					{
						// The model name has a string var on the left
						// Get field 1.  This is the install section name.
						if (OK == IpGetStringField(hInf, hInfLine, 1, lpszTemp, _MAX_LINE, &nCopied))
						{
                            DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : Before lstrtok comma"));

							lstrtok(lpszTemp, cszComma);

							// quick check of model section name
                            //
							if (OK == IpFindFirstLine(hInf, lpszTemp, NULL, &hInfLine))
							{
								if ((OK == IpGetProfileString(hInf,lpszTemp,"CopyFiles",lpszTemp2,_MAX_LINE))
									 OR (OK == IpGetProfileString(hInf,lpszTemp,"DataSection",lpszTemp2,_MAX_LINE))
									 OR (OK == IpGetProfileString(hInf,lpszTemp,"DriverFile",lpszTemp2,_MAX_LINE))
									 OR (OK == IpGetProfileString(hInf,lpszTemp,"DataFile",lpszTemp2,_MAX_LINE)))
								{
									lstrcpyn(szSection, lpszTemp, _MAX_PATH_);
									IpClose(hInf);

                                    DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #9 Strings Found Correct Section"));

									return TRUE;
								}


								// We have a bad INF file:
								// We have the manufacturer name and the model name and an
								// install section, but it doesn't have any of the keys we need.
								// bail.
                                //
								IpClose(hInf);

                                DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #10 Strings Bad INF File"));

								return FALSE;
							}
						}
					}
				}

				if (OK != IpFindNextLine(hInf, &hInfLine))
				{
					break;
				}
			}
		}


	} // Try # 6


	// Try # 7
	// Check to see if there is a valid InstallSection.
    //
	if (OK == IpFindFirstLine(hInf, "InstallSection", NULL, &hInfLine))
	{
		// quick check of InstallSection
		if (OK == IpFindFirstLine(hInf, "InstallSection", NULL, &hInfLine))
		{
			if ((OK == IpGetProfileString(hInf,"InstallSection","CopyFiles",lpszTemp2,_MAX_LINE))
				 OR (OK == IpGetProfileString(hInf,"InstallSection","DataSection",lpszTemp2,_MAX_LINE))
				 OR (OK == IpGetProfileString(hInf,"InstallSection","DriverFile",lpszTemp2,_MAX_LINE))
				 OR (OK == IpGetProfileString(hInf,"InstallSection","DataFile",lpszTemp2,_MAX_LINE)))
			{
				lstrcpyn(szSection, "InstallSection", _MAX_PATH_);
				IpClose(hInf);

				DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #11 Found correct InstallSection"));

				return TRUE;
			}
		}

	} // Try # 7


	// Try # 8.
	// Try the [Strings] section.
	if (OK == IpFindFirstLine(hInf, "Strings", NULL, &hInfLine))
	{
		// Get the number of lines
		if (OK == IpGetLineCount(hInf, "Strings", &nCount))
		{
			for (i = 0; i < nCount; i++)
			{
				lpszBuf[0] = '\0';
				lpszTemp[0] = '\0';     
				if (OK == IpGetStringField(hInf, hInfLine, 1, lpszTemp, _MAX_LINE, &nCopied))
				{
					// Garth: Use CompareString with the 
					// IGNORE_CASE, IGNORE_KANATYPE, and IGNORE_WIDTH flags
					if (lstrcmpi(szModel, lpszTemp) == 0)
					{
						// The model name has a string var on the left
						if (OK == IpGetStringField(hInf, hInfLine, 0, lpszBuf, _MAX_LINE, &nCopied))
						{
							// There was a value on the left, try to use it
							if (OK == IpFindFirstLine(hInf, lpszBuf, NULL, &hInfLine))
							{
								// quick check of Strings 
								if (OK == IpFindFirstLine(hInf, lpszBuf, NULL, &hInfLine))
								{
									if ((OK == IpGetProfileString(hInf,lpszBuf,"CopyFiles",lpszTemp2,_MAX_LINE))
										 OR (OK == IpGetProfileString(hInf,lpszBuf,"DataSection",lpszTemp2,_MAX_LINE))
										 OR (OK == IpGetProfileString(hInf,lpszBuf,"DriverFile",lpszTemp2,_MAX_LINE))
										 OR (OK == IpGetProfileString(hInf,lpszBuf,"DataFile",lpszTemp2,_MAX_LINE)))
									{
										lstrcpyn(szSection, lpszBuf, _MAX_PATH_);
										IpClose(hInf);

                                        DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #12 Found String = Model Section"));

										return TRUE;
									}
								}
							}
						}
					}
				}
			}
		}
	} // Try # 8


	// No more ideas, Give up.
    //
	IpClose(hInf);

    DBG_MSG(DBG_LEV_INFO, ("FindCorrectSection : #13 Failed to find section"));

	return FALSE;
}


//-----------------------------------------------------------------------
// Function: GetInfOption(hInf,lpszSection,bDataSection,bLocalize,
//                        lpszDataSection,lpszKeyName,lpszBuffer,wBufSize)
//
// Action: Get the specified keyword from the INF file. Look in the
//         appropriate section(s)
//
// Note:   Keys may always appear in lpszSection, and may appear in
//         lpszDataSection if bDataSection is TRUE. If the key appears
//         in both sections, the value from lpszSection takes precedence.
//
// Return: TRUE if we got the option, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL GetInfOption(HINF   hInf,
							LPSTR  lpszSection,
							BOOL   bDataSection,
							BOOL   bLocalize,
							LPSTR  lpszDataSection,
							LPSTR  lpszKeyName,
							LPSTR  lpszBuffer,
							WORD   wBufSize)
{
	LPSTR lpszTemp;
	BOOL  bAllocated;
	BOOL  bSuccess;

	if (bLocalize && wBufSize &&
		 (lpszTemp=(LPSTR)(HP_GLOBAL_ALLOC_DLL(max(wBufSize,_MAX_PATH_)))))
	{
		bAllocated=TRUE;
	}
	else
	{
		lpszTemp=lpszBuffer;
		bAllocated=FALSE;
	}

	if (OK == IpGetProfileString(hInf,lpszSection,lpszKeyName,lpszTemp,wBufSize))
	{
		bSuccess=TRUE;
	}
	else if (bDataSection && 
			(OK == IpGetProfileString(hInf,lpszDataSection,
					lpszKeyName,lpszTemp,wBufSize)))
	{
		bSuccess=TRUE;
	}
	else
		bSuccess=FALSE;

	if (bAllocated)
	{
		if (bSuccess)
			GenFormStrWithoutPlaceHolders(lpszBuffer,lpszTemp,hInf);

		HP_GLOBAL_FREE(lpszTemp);
	}

	return bSuccess;
}


//-----------------------------------------------------------------------
// Function: myatoi(pszInt)
//
// Yup, the first function that everyone writes!
//-----------------------------------------------------------------------
int WINAPI myatoi(
    LPSTR pszInt)
{
	int  nRet;
	char cSave;

	for (nRet = 0; ; ++pszInt) {

		if ((cSave = (*pszInt - (char)'0')) > 9)
			break;

		nRet = (nRet * 10) + cSave;
	}

	return nRet;
}


//------------------------------------------------------------------------
// Function: ZeroMem(lpData,wCount)
//
// Action: Zero-initialize wCount bytes at lpData (duh)
//
// Return: VOID
//------------------------------------------------------------------------
VOID WINAPI ZeroMem(LPVOID lpData,
						  WORD   wCount)
{
	LPBYTE lpBuf=(LPBYTE)lpData;

	while (wCount--)
	{
		*lpBuf='\0';
		lpBuf++;
	}
}


//--------------------------------------------------------------------
// Function: FlushCachedPrinterFiles(void)
//
// Action: Flush printer driver files that might be cached by the
//         system. Two caches exist--one maintained by USER, and one
//         maintained by winspl16.drv (for old drivers)
//
// Return: Void
//--------------------------------------------------------------------
VOID WINAPI FlushCachedPrinterFiles()
{
	HWND    hWndMsgSvr;
	HMODULE hModWinspl16;

	// Send a message to MSGSVR32 to flush the default printer's cached DC.
	if (hWndMsgSvr = FindWindow(cszMsgSvr, NULL))
		SendMessage(hWndMsgSvr, WM_USER+0x010A, 0, 0L);

	// If WINSPL16 is in memory, force it to flush its cache
	if (hModWinspl16 = GetModuleHandle(cszWinspl16))
	{
		WEPPROC fpWep;

		if (fpWep = (WEPPROC)GetProcAddress(hModWinspl16, "WEP"))
		{
			fpWep(0);
		}
	}
}


//------------------------------------------------------------------
// Function: RenameFailed(lpsi,lpFileSpec)
//
// Action: Handle the case where the rename failed. Give the user a
//         chance to close existing apps and shut down printers.
//
// Return: 0 if the file isn't loaded (use default handling)
//         VCPN_ABORT if file is in use & user cancelled
//         VCPN_RETRY if file is in use & user wants to retry
//------------------------------------------------------------------
LRESULT NEAR PASCAL RenameFailed(LPSI lpsi,
											LPVCPFILESPEC lpFileSpec)
{
	char szFile[_MAX_PATH_];

	if (vsmGetStringName(lpFileSpec->vhstrFileName,szFile,sizeof(szFile)) &&
		 GetModuleHandle(szFile))
	{
		char Message[_MAX_PATH_];


		// File is in use by the system--give the user the chance to shut
		// down existing applications, then continue.

		if ( LoadString(g_hInst, IDS_ERR_FILE_IN_USE, Message, _MAX_PATH_) IS 0)
		{
            DBG_MSG(DBG_LEV_INFO, ("RenameFailed : Could not load string, file in use"));

			lstrcpy(Message, cszFileInUse);
		}
		if (IDCANCEL IS MessageBox(NULL, Message, szFile,
											MB_ICONEXCLAMATION|MB_RETRYCANCEL|MB_DEFBUTTON2))
		{
			return VCPN_ABORT;
		}
		else
		{
			// Flush any cached printers & retry
			FlushCachedPrinterFiles();
			return VCPN_RETRY;
		}
	}

	return 0;
}


//------------------------------------------------------------------
// Function: MyVcpCallbackProc(lpvObj,uMsg,wParam,lParam,lparamRef)
//
// Action: This simply passes through to vcpUICallbackProc, with one
//         exception: If a file is in use in the system, we warn the
//         user and give them a chance to close existing apps.
//
// Return: Whatever RenameFailed or vcpUICallbackProc return.
//------------------------------------------------------------------
LRESULT CALLBACK MyVcpCallbackProc(LPVOID lpvObj,
											  UINT   uMsg,
											  WPARAM wParam,
											  LPARAM lParam,
											  LPSI   lpsi)
{
	LRESULT lResult = 0;

	if ((VCPM_FILERENAME + VCPM_ERRORDELTA) IS uMsg)
		lResult = RenameFailed(lpsi,(LPVCPFILESPEC)lpvObj);

	if (! lResult)
	{
		lResult = vcpUICallbackProc(lpvObj,uMsg,wParam,lParam,
											 (LPARAM)lpsi->lpVcpInfo);
	}

	return lResult;
}


//-------------------------------------------------------------------
// Function: OpenQueue(lpsi, lpVcpInfo, lpbOpened)
//
// Action: Initialize lpVcpInfo and open the queue. *lpbOpened reflects
//         whether or not we actually opened the queue.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------
BOOL NEAR PASCAL OpenQueue(LPSI        lpsi,
									LPVCPUIINFO lpVcpInfo,
									BOOL FAR   *lpbOpened)
{
	BOOL bSuccess = FALSE;

	// Initialize the structure
	ZeroMem(lpVcpInfo, sizeof(VCPUIINFO));

	lpVcpInfo->flags = VCPUI_CREATEPROGRESS;
	lpVcpInfo->hwndParent = NULL;

	lpsi->lpVcpInfo = (LPBYTE) lpVcpInfo;

	// Open the queue
	if (RET_OK IS VcpOpen((VIFPROC)MyVcpCallbackProc, (LPARAM)lpsi))
	{
		bSuccess = TRUE;
		*lpbOpened = TRUE;
	}
	else
	{
		// Couldn't open the queue, so clear lpVcpInfo
		lpsi->lpVcpInfo = NULL;
		*lpbOpened = FALSE;
	}

	return bSuccess;
}


//-------------------------------------------------------------------
// Function: GenInstallCallback(lpGenInfo,lpsi)
//
// Action: This gets called for each file to be queued. Add it to
//         the list identified by lpsi->lpFiles, then queue it
//         to be copied to the system directory
//
// Return: GENN_SKIP if it's a copy (we queue it ourselves), 
//         GENN_OK otherwise.
//-------------------------------------------------------------------
LRESULT WINAPI GenInstallCallback(LPGENCALLBACKINFO lpGenInfo,
											 LPSI lpsi)
{
	int wLength;
	int wMaxLength;
	int wChunk;

	if (GENO_COPYFILE != lpGenInfo->wOperation)
		return GENN_OK;

	// Save the dependent file in lpsi->lpFiles. wFilesAllocated and
	// wFilesUsed are used to keep track of memory usage.
	wLength = lstrlen(lpGenInfo->pszDstFileName);

	// Pad the length if it's going to LDID_COLOR
	if (LDID_COLOR IS lpGenInfo->ldidDst)
		wMaxLength = wLength + MAX_COLOR_PATH;
	else
		wMaxLength = wLength;

	wChunk = max(256,wMaxLength);

	// This is where we allocate lpFiles the first time
	if (! lpsi->lpFiles)
	{
		if (lpsi->lpFiles = (unsigned char *)HP_GLOBAL_ALLOC_DLL(wChunk))
		{
			lpsi->wFilesAllocated = wChunk;
		}
		else
		{
			return GENN_SKIP;
		}
	}

	// double NULL terminated
	if ((lpsi->wFilesUsed + wMaxLength + 2) > lpsi->wFilesAllocated)
	{
		LPSTR lpNew;

		lpNew = (unsigned char *)HP_GLOBAL_REALLOC_DLL(lpsi->lpFiles,
																	  lpsi->wFilesAllocated + wChunk, GMEM_ZEROINIT);

		if (lpNew)
		{
			lpsi->wFilesAllocated += wChunk;
			lpsi->lpFiles = (unsigned char *) lpNew;
		}
		else
		{
			return GENN_SKIP;
		}
	}

	// Add this file to the list && ensure that it's doubly-NULL
	// terminated. If it's going to LDID_COLOR, prepend "COLOR\"
	// to the string

	if (LDID_COLOR IS lpGenInfo->ldidDst)
	{
		char ColorPath[MAX_COLOR_PATH];
		if ( LoadString(g_hInst, IDS_COLOR_PATH, ColorPath, MAX_COLOR_PATH) IS 0)
		{
			strcpy(ColorPath, "COLOR\\");
		}

		strcpy((LPSTR)(lpsi->lpFiles + lpsi->wFilesUsed), ColorPath);
		lpsi->wFilesUsed += strlen(ColorPath);
	}

	strcpy((LPSTR)(lpsi->lpFiles + lpsi->wFilesUsed), lpGenInfo->pszDstFileName);
	lpsi->wFilesUsed += (wLength + 1);
	lpsi->lpFiles[lpsi->wFilesUsed] = '\0';

	return GENN_SKIP;
}



//-------------------------------------------------------------------
// Function: QueueNewInf(lpsi, lpdn)
//
// Action: Call GenInstallEx to queue up the files we need to copy.
//
// Return: TRUE if we should continue, FALSE if not.
//-------------------------------------------------------------------
BOOL WINAPI QueueNewInf(LPSI lpsi, LPDRIVER_NODE lpdn)
{
	if (lpdn)
	{
		return (RET_OK == GenInstallEx((HINF)lpsi->hModelInf,
												 lpdn->lpszSectionName, GENINSTALL_DO_FILES, NULL, 
												 (GENCALLBACKPROC)GenInstallCallback, (LPARAM)lpsi));
	}

	return FALSE;
}

//-------------------------------------------------------------------
// Function: CloseQueue(lpsi, bSuccessSoFar, bOpened)
// 
// Action: Close the VCP queue and report any errors to the user.
//         If bSuccessSoFar is FALSE, abandon the queue & return FALSE
//
// Return: TRUE if the copy was successful, FALSE if not.
//-------------------------------------------------------------------
BOOL NEAR PASCAL CloseQueue(LPSI lpsi,
									 BOOL bSuccessSoFar,
									 BOOL bOpened)
{
	BOOL   bSuccess = FALSE;

	if (! bOpened)
		bSuccess = bSuccessSoFar;
	else
	{
		if (! bSuccessSoFar)
			VcpClose(VCPFL_ABANDON, NULL);
		else if (lpsi->bDontQueueFiles)
		{
			VcpClose(VCPFL_ABANDON, NULL);
			bSuccess=TRUE;
		}

		// The queue is now closed, so clear lpsi->lpVcpInfo
		if (lpsi->lpVcpInfo)
			lpsi->lpVcpInfo = NULL;
	}

	return bSuccess;
}



//-----------------------------------------------------------------------
// Function: WrapVcpCopy(lpsi,lpfnQueueFunction,lpdn)
//
// Action: Wrap lpfnQueueFunction inside calls to open & close the
//         queue. If lpsi->bDontCopyFiles is TRUE, we'll close the
//         queue without copying anything.
//
// Return: TRUE if everything went smoothly, FALSE if not.
//-----------------------------------------------------------------------
BOOL WINAPI WrapVcpCopy(LPSI lpsi,
								LPQUEUEPROC lpfnQueueFunction,
								LPDRIVER_NODE lpdn)

{
	VCPUIINFO VcpInfo;
	BOOL      bSuccess=FALSE;
	BOOL      bOpened=FALSE;

	if (OpenQueue(lpsi, &VcpInfo, &bOpened))
	{
		BOOL bQueuedOK;

		bQueuedOK = lpfnQueueFunction(lpsi, lpdn);

		bSuccess = CloseQueue(lpsi, bQueuedOK, bOpened);
	}

	return bSuccess;
}


//--------------------------------------------------------------------
// Function: PrintLPSI(lpsi)
//
// Action: Print out the contents of the LPSI
//
// Side effect: None
//
// Return: VOID
//
//--------------------------------------------------------------------
VOID PrintLPSI(LPSI lpsi)
{
    DBG_MSG(DBG_LEV_INFO, ("LPSI : dwDriverVersion   : %#lX", (DWORD)lpsi->dwDriverVersion));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : dwUniqueID        : %d"  , lpsi->dwUniqueID));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : bNetPrinter       : %d"  , lpsi->bNetPrinter));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : wFilesUsed        : %d"  , lpsi->wFilesUsed));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : wFilesAllocated   : %d"  , lpsi->wFilesAllocated));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : wRetryTimeout     : %d"  , lpsi->wRetryTimeout));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : wDNSTimeout       : %d"  , lpsi->wDNSTimeout));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : bDontQueueFiles   : %d"  , lpsi->bDontQueueFiles));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : bNoTestPage       : %d"  , lpsi->bNoTestPage));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : hModelInf         : %0X" , lpsi->hModelInf));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : lpPrinterInfo2    : %d"  , lpsi->lpPrinterInfo2));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : lpDriverInfo3     : %d"  , lpsi->lpDriverInfo3));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szFriendly        : %s"  , lpsi->szFriendly));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szModel           : %s"  , lpsi->szModel));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szDefaultDataType : %s"  , lpsi->szDefaultDataType));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szBinName         : %s"  , lpsi->BinName));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szShareName       : %s"  , lpsi->ShareName));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : INFfileName       : %s"  , lpsi->INFfileName));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szPort            : %s"  , lpsi->szPort));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szDriverFile      : %s"  , lpsi->szDriverFile));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szDataFile        : %s"  , lpsi->szDataFile));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szConfigFile      : %s"  , lpsi->szConfigFile));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szHelpFile        : %s"  , lpsi->szHelpFile));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szPrintProcessor  : %s"  , lpsi->szPrintProcessor));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szVendorSetup     : %s"  , lpsi->szVendorSetup));
    DBG_MSG(DBG_LEV_INFO, ("LPSI : szVendorInstaller : %s"  , lpsi->szVendorInstaller));
}


//-----------------------------------------------------------------------
// Function: FindSelectedDriver(lpsi, lpdn)
//
// Action: Try to find the install section associated with the specified
//         model. If the currently selected driver matches the model, we
//         get all the required info from it.
//
// Note:   Upon entry
//                 lpdn->lpszSectionName
//                 has the name of the correct section in the INF file.
//
// Return: TRUE is successful, FALSE if not.
//-----------------------------------------------------------------------
BOOL WINAPI FindSelectedDriver(
    LPSI          lpsi,
    LPDRIVER_NODE lpdn)
{
	HINFLINE hInfDummy;
	HINF     myHINF;
	WORD     wTest;
	BOOL     bDataSection=FALSE;
	BOOL     bQueuedOK;
	char     szData[_MAX_PATH_];
	char     szTimeout[10];
	char     lpSection[_MAX_PATH_];

	// Extract all of our information from the INF file.
	// Open the INF file.
	if (OK != IpOpen(lpsi->INFfileName, &myHINF))
	{
		return FALSE;
	}

	lstrcpyn(lpSection, lpdn->lpszSectionName, _MAX_PATH_);

	if (OK != IpFindFirstLine(myHINF, lpSection, NULL, &hInfDummy))
	{
		IpClose(myHINF);
		return FALSE;
	}
	lpsi->hModelInf = (int) myHINF;

	// Build the dependent file list now.
	lpsi->bDontQueueFiles=TRUE;
	bQueuedOK = WrapVcpCopy(lpsi,QueueNewInf,lpdn);
	lpsi->bDontQueueFiles = FALSE;

	if (!bQueuedOK)
	{
		IpClose(myHINF);
		lpsi->hModelInf = 0;
		return FALSE;
	}


	if (!lpsi->wFilesUsed)
	{
		IpClose(myHINF);
		lpsi->hModelInf = 0;
		return FALSE;
	}

	// Check for a data section. If none is specified, then the
	// data section is the section associated with this device.
	// The DataSection key can only appear in the installer section
	// (for obvious reasons).
	bDataSection=GetInfOption(myHINF,lpSection,FALSE,FALSE,NULL,
									  cszDataSection,szData,sizeof(szData));

	// Don't change szData below this line! (It may contain the
	// data section name)

	// Get the driver name (default is the primary section name)
	if (!GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
							cszDriverFile,lpsi->szDriverFile,sizeof(lpsi->szDriverFile)))
	{
		lstrcpyn(lpsi->szDriverFile,lpSection,sizeof(lpsi->szDriverFile));
	}

	// Get the data file name (default is the primary section name)
	if (!GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
							cszDataFile,lpsi->szDataFile,sizeof(lpsi->szDataFile)))
	{
		lstrcpyn(lpsi->szDataFile,lpSection,sizeof(lpsi->szDataFile));
	}

	// Get the config file name (default is the driver name)
	if (!GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
							cszConfigFile,lpsi->szConfigFile,sizeof(lpsi->szConfigFile)))
	{
		lstrcpyn(lpsi->szConfigFile,lpsi->szDriverFile,
					sizeof(lpsi->szConfigFile));
	}

	// Get the help file (default is none)
	GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
					 cszHelpFile,lpsi->szHelpFile,sizeof(lpsi->szHelpFile));

	// Get the Print Processor (default comes from resources)
	if (!GetInfOption(myHINF,lpSection,bDataSection,TRUE,szData,
							cszPrintProcessor,lpsi->szPrintProcessor,
							sizeof(lpsi->szPrintProcessor)))
	{
		if (LoadString(g_hInst,IDS_DEFAULT_PRINTPROCESSOR,
							lpsi->szPrintProcessor,sizeof(lpsi->szPrintProcessor)) IS 0)
		{
            DBG_MSG(DBG_LEV_INFO, ("FindSelectedDriver : Could not load string, default print processor"));

			lstrcpy(lpsi->szPrintProcessor, cszDefaultPrintProcessor);
		}
	}

	// Get the Default Data Type (default comes from resources)
	if (!GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
							cszDefaultDataType,lpsi->szDefaultDataType,
							sizeof(lpsi->szDefaultDataType)))
	{
		if ( LoadString(g_hInst,IDS_DEFAULT_DATATYPE,
							 lpsi->szDefaultDataType,sizeof(lpsi->szDefaultDataType)) IS 0)
		{
            DBG_MSG(DBG_LEV_INFO, ("FindSelectedDriver : Could not load string, default data type"));

			lstrcpy(lpsi->szDefaultDataType, cszMSDefaultDataType);
		}
	}

	// Get the Vendor Setup (default is none)
	GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
					 cszVendorSetup,lpsi->szVendorSetup,sizeof(lpsi->szVendorSetup));

	// Get the Vendor Installer (default is none)
	GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
					 cszVendorInstaller,lpsi->szVendorInstaller,
					 sizeof(lpsi->szVendorInstaller));

	// Get the device timeouts (ClearPrinterInfo defaults to 15 & 45)
	if (GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
						  cszRetryTimeout,szTimeout,sizeof(szTimeout)))
	{
		if (wTest=myatoi(szTimeout))
			lpsi->wRetryTimeout=wTest;
	}

	if (GetInfOption(myHINF,lpSection,bDataSection,FALSE,szData,
						  cszNotSelectedTimeout,szTimeout,sizeof(szTimeout)))
	{
		if (wTest=myatoi(szTimeout))
			lpsi->wDNSTimeout=wTest;
	}

	// Decide whether or not we should use the test page. Test page is
	// skipped if the INF specifically requests it, if we have a
	// vendor-supplied DLL, or if the port is in conflict.
	if ( (lpsi->szVendorSetup[0]) ||
		 (lpsi->szVendorInstaller[0]) || 
		  GetInfOption(myHINF, lpSection, bDataSection, FALSE, szData,
			cszNoTestPage, szTimeout, sizeof(szTimeout)))
	{
		lpsi->bNoTestPage=TRUE;
	}

	IpClose(myHINF);
	lpsi->hModelInf = 0;

	return TRUE;
}


//--------------------------------------------------------------------
// Function: CreateDriverNode()
//
// Action: Create a driver node and initialize it..  
//
// Side effect: Allocates memory that must be freed by caller..
//
// Return: RET_OK on success.
//         
//--------------------------------------------------------------------
RETERR WINAPI CreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT     Rank,
    UINT     InfType,
    unsigned InfDate,
    LPCSTR   lpszDevDescription,
    LPCSTR   lpszDrvDescription,
    LPCSTR   lpszProviderName,
    LPCSTR   lpszMfgName,
    LPCSTR   lpszInfFileName,
    LPCSTR   lpszSectionName,
    DWORD    dwPrivateData)
{
	int   DrvDescLen = 0;
	int   DevDescLen = 0;
	int   SectionLen = 0;
	LPSTR lpszTemp;


	// Compute a allocate space for the variable part of the DRIVER node
    //
	DrvDescLen = lstrlen(lpszDrvDescription);
	DevDescLen = lstrlen(lpszDevDescription);
	SectionLen = lstrlen(lpszSectionName);

	*lplpdn = (LPDRIVER_NODE) HP_GLOBAL_ALLOC_DLL(sizeof(DRIVER_NODE) + 
					 DrvDescLen + DevDescLen + SectionLen + 
					 (2 * MAX_DEVICE_ID_LEN) + _MAX_PATH_ + NSTRINGS);

	if (*lplpdn == NULL)
	{
		return(ERR_DI_LOW_MEM);
	}
	else
	{
		(*lplpdn)->Rank    = Rank;
		(*lplpdn)->InfType = InfType;
		(*lplpdn)->InfDate = InfDate;

		// For compatibility copy the DevDescription into lpszDescription
		lpszTemp = (LPSTR)((DWORD)(*lplpdn) + sizeof(DRIVER_NODE));
		lstrcpy(lpszTemp, lpszDevDescription);
		(*lplpdn)->lpszDescription = lpszTemp;

		// New.  Copy the Drv description into the lpszDrvDescription
		lpszTemp = (LPSTR)((DWORD)(lpszTemp) + (DWORD)(DevDescLen + 1));
		lstrcpy(lpszTemp, lpszDevDescription);
		(*lplpdn)->lpszDrvDescription = lpszTemp;

		lpszTemp = (LPSTR)((DWORD)(lpszTemp) + (DWORD)(DrvDescLen + 1));
		lstrcpy(lpszTemp, lpszSectionName);
		(*lplpdn)->lpszSectionName = lpszTemp;

		// Init HardwareID and CompatIDs buffers to empty strings

		lpszTemp = (LPSTR)((DWORD)(lpszTemp) + (DWORD)(SectionLen + 1));
		*lpszTemp = '\0';
		(*lplpdn)->lpszHardwareID = lpszTemp;

		lpszTemp = (LPSTR)((DWORD)(lpszTemp) + (DWORD)(MAX_DEVICE_ID_LEN + 1));
		*lpszTemp = '\0';
		(*lplpdn)->lpszCompatIDs = lpszTemp;

		(*lplpdn)->atInfFileName = GlobalAddAtom(lpszInfFileName);

		if (lpszMfgName != NULL) {
			(*lplpdn)->atMfgName = GlobalAddAtom(lpszMfgName);
		}
		if (lpszProviderName != NULL) {
			(*lplpdn)->atProviderName = GlobalAddAtom(lpszProviderName);
		}

		return(RET_OK);
	}
}


//--------------------------------------------------------------------
//
// Function: HaveAllFiles(lpsi)
//
// Action: Do we have all printer driver dependent files in this directory?
//
// Return: TRUE if all found, FALSE if not
//
//--------------------------------------------------------------------
BOOL WINAPI HaveAllFiles(LPSI lpsi, LPSTR cszPath)
{
	int     result;
	LPSTR   lpThisFile;
	struct stat statBuf;
	char    fileSpec[_MAX_PATH_];
	BOOL    fileNotFound = FALSE;


	// Verify that all the dependent files are in the directory
	// pointed to by cszPath.
    //
	for (lpThisFile = (char *)lpsi->lpFiles; *lpThisFile; 
		 lpThisFile += (lstrlen(lpThisFile) + 1))
	{
		// Get data associated with file
		lstrcpy(fileSpec, cszPath);
		lstrcat(fileSpec, cszBackslash);
		lstrcat(fileSpec, lpThisFile);
		result = stat( fileSpec, (struct stat *)&statBuf);

		// Check if statistics are valid:
		if ( result ISNT 0 )
		{
            DBG_MSG(DBG_LEV_INFO, ("HaveAllFiles : File not found <%s>", fileSpec));

			fileNotFound = TRUE;
			break;
		}
	}

    return !fileNotFound;
}


//--------------------------------------------------------------------
//
// Function: CopyNeededFiles(lpsi, cszPath)
//
// Action: Copy all printer driver files for this printer from the 
//                      source directory to the requied printer driver directory.
//
// Return:      RET_OK on success.
//                      RET_FILE_COPY_ERROR is there is a file copy error
//
//--------------------------------------------------------------------
DWORD WINAPI CopyNeededFiles(LPSI lpsi, LPSTR cszPath)
{
	DWORD    dwResult = RET_OK;
    LONG     lResult;
    LPSTR    lpThisFile;
    OFSTRUCT ofStrSrc;
    OFSTRUCT ofStrDest;
    HFILE    hfSrcFile, hfDstFile;
    char     fileSource[_MAX_PATH_];
    char     fileDest[_MAX_PATH_];
    char     destDir[_MAX_PATH_];

    DBG_MSG(DBG_LEV_INFO, ("CopyNeededFiles : About to flush printer files"));

    lstrcpy(destDir, lpsi->szDriverDir);

    if (lstrcmpi(destDir, cszPath) IS 0) {

    // all required files are in the destination directory
        //
        return RET_OK;
    }

    // Flush any cached files the system may be holding
    //
    FlushCachedPrinterFiles();

    LZStart();

    for (lpThisFile = (char *)lpsi->lpFiles; *lpThisFile;
        lpThisFile += (lstrlen(lpThisFile) + 1)) {

        lstrcpy(fileSource, cszNull);
        lstrcat(fileSource, cszPath);
        lstrcat(fileSource, cszBackslash);
        lstrcat(fileSource, lpThisFile);

        lstrcpy(fileDest, cszNull);
        lstrcat(fileDest, destDir);
        lstrcat(fileDest, cszBackslash);
        lstrcat(fileDest, lpThisFile);

        lResult = -1;

		if (hfSrcFile = LZOpenFile(fileSource, &ofStrSrc, OF_READ)) {

		    if (hfDstFile = LZOpenFile(fileDest, &ofStrDest, OF_CREATE)) {
#if 0
                lResult = CopyLZFile(hfSrcFile, hfDstFile);
#else
                // Hack.  If spooler has a file locked, then this call
                // would fail resulting in the class-installer being called
                // to copy the files.  But for some reason, the class-installer
                // prompts a path-dialog wanting to know where the files
                // are.  Several attempts at fixing up the device-info
                // struct with path-information failed to remedy this
                // situation.  Therefore, for now, we will prevent this
                // CopyLZFile() from returning error to keep away from
                // the class-installer until this problem can be figured
                // out.
                //
                // See the caller of this routine to see how the class-
                // installer is called.
                //
	            CopyLZFile(hfSrcFile, hfDstFile);

                lResult = 0;
#endif
                LZClose(hfDstFile);

            } else {

                DBG_MSG(DBG_LEV_INFO, ("CopyNeededFiles : Could not create dst-file <%s>", fileDest));
            }

            LZClose(hfSrcFile);

        } else {

            DBG_MSG(DBG_LEV_INFO, ("CopyNeededFiles : Could not create src-file <%s>", fileSource));
        }

        if (lResult < 0) {

            dwResult = RET_FILE_COPY_ERROR;
            break;
        }
    }

    LZDone();

    return dwResult;
}



//--------------------------------------------------------------------
// Function: ParseINF16(LPSI)
//
// Action: Parse the INF file and store required info in LPSI.
//
// Return:      RET_OK on success.
//                      RET_SECT_NOT_FOUND if no install section for this model
//                      RET_DRIVER_NODE_ERROR if memory error
//                      RET_INVALID_INFFILE other problem with INF file
//         
//--------------------------------------------------------------------
RETERR FAR PASCAL ParseINF16(LPSI lpsi)
{
	RETERR			ret = RET_OK;
	LPDRIVER_NODE   lpdn = NULL;
	char			szManufacturer[_MAX_PATH_];
	char			szSection[_MAX_PATH_];
	char			cszPath[_MAX_PATH_];

	// Get the manufacturer
    //
	lstrcpyn(szManufacturer,lpsi->szModel,sizeof(szManufacturer));
	lstrtok(szManufacturer,cszSpace);

    DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : Search inf<%s> mfg<%s> model<%s>", lpsi->INFfileName, szManufacturer, lpsi->szModel));


	// Get the correct section name
	if (!FindCorrectSection(lpsi->INFfileName, szManufacturer, lpsi->szModel, szSection))
	{   
		if (lstrcmpi(szManufacturer, "HP") IS 0)
		{
			lstrcpy(szManufacturer, "Hewlett-Packard");

			if (!FindCorrectSection(lpsi->INFfileName, szManufacturer, lpsi->szModel, szSection))
			{
                DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : FindCorrectSection Failed"));

				return RET_SECT_NOT_FOUND;

			} else {

                DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : FindCorrectSection Succeeded"));
            }

		} else {

            DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : FindCorrectSection Failed"));

			return RET_SECT_NOT_FOUND;
		}

	} else {

        DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : FindCorrectSection Succeeded"));
	}


	// Create a driver node
    //
	if (RET_OK != CreateDriverNode(&lpdn,
                                   0,
                                   INFTYPE_TEXT,
                                   NULL,
                                   lpsi->szModel,
                                   cszNull,
                                   cszNull,
                                   szManufacturer,
                                   lpsi->INFfileName,
                                   szSection,
                                   0))
	{
        DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : CreateDriverNode Failed"));

		return RET_DRIVER_NODE_ERROR;

	} else {

        DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : CreateDriverNode Succeeded"));
	}


	// Find the selected driver and dependent files in the INF.  Store in lpsi.
    //
	if (! FindSelectedDriver(lpsi, lpdn)) {

        DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : FindSelectedDriver Failed"));

		if (lpdn->atInfFileName ISNT 0)
			GlobalDeleteAtom(lpdn->atInfFileName);
		if (lpdn->atMfgName ISNT 0)
			GlobalDeleteAtom(lpdn->atMfgName);
		if (lpdn->atProviderName ISNT 0)
			GlobalDeleteAtom(lpdn->atProviderName);

		HP_GLOBAL_FREE(lpdn);

		return RET_INVALID_INFFILE;

	} else {

        DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : FindSelectedDriver Succeeded"));
    }


	// If there is not a driver already installed for this printer,
	// Copy the driver files to the driver directory.
	if (lpsi->wCommand IS CMD_INSTALL_DRIVER)
	{

		if ( getcwd(cszPath, _MAX_PATH_) IS NULL)
			lstrcpy(cszPath, ".");

		if ((HaveAllFiles(lpsi, cszPath) IS TRUE)
			 AND
			 (CopyNeededFiles(lpsi, cszPath) IS RET_OK)
			)
		{
			// We have all the needed files in the directory pointed to by cszPath.
			// They have been copied to the printer driver directory.
			ret = RET_OK;

            DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : All files copied to final directory"));

		} else {

#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
			DEVICE_INFO             *lpdi;


			ret = DiCreateDeviceInfo(&lpdi,
                                     lpsi->szModel,
                                     0,
                                     HKEY_LOCAL_MACHINE,
                                     NULL,
							         "Printer",
                                     NULL);

			// Install the driver files.  This will only copy files that
			// need to be copied.
            //
			if (ret IS OK) {

				LPDRIVER_NODE oldDN = NULL;
				oldDN = lpdi->lpSelectedDriver;
				lpdi->lpSelectedDriver = lpdn;
				ret = DiCallClassInstaller(DIF_INSTALLDEVICEFILES, lpdi);
				lpdi->lpSelectedDriver = oldDN;
				oldDN = NULL;
				DiDestroyDeviceInfoList(lpdi);
				lpdi = NULL;
			}

			switch (ret) {

			case OK:
			case ERR_DI_NOFILECOPY:
				ret = RET_OK;
				break;
			case ERR_DI_USER_CANCEL:
				ret = RET_USER_CANCEL;
				break;
			case ERR_DI_LOW_MEM:
				ret = RET_ALLOC_ERR;
				break;
			case ERR_DI_BAD_INF:
				ret = RET_INVALID_INFFILE;
				break;

			case ERR_DI_INVALID_DEVICE_ID:
			case ERR_DI_INVALID_COMP_DEVICE_LIST:
			case ERR_DI_REG_API:							// Error returned by Reg API.
			case ERR_DI_BAD_DEV_INFO:						// Device Info struct invalid
			case ERR_DI_INVALID_CLASS_INSTALLER:			// Registry entry / DLL invalid
			case ERR_DI_DO_DEFAULT:							// Take default action
			case ERR_DI_BAD_CLASS_INFO:						// Class Info Struct invalid
			case ERR_DI_BAD_MOVEDEV_PARAMS:					// Bad Move Device Params struct
			case ERR_DI_NO_INF:								// No INF found on OEM disk
			case ERR_DI_BAD_PROPCHANGE_PARAMS:				// Bad property change param struct
			case ERR_DI_BAD_SELECTDEVICE_PARAMS:			// Bad Select Device Parameters
			case ERR_DI_BAD_REMOVEDEVICE_PARAMS:			// Bad Remove Device Parameters
			case ERR_DI_BAD_ENABLECLASS_PARAMS:				// Bad Enable Class Parameters
			case ERR_DI_FAIL_QUERY:							// Fail the Enable Class query
			case ERR_DI_API_ERROR:							// DI API called incorrectly
			case ERR_DI_BAD_PATH:							// An OEM path was specified incorrectly
			default:
				ret = RET_BROWSE_ERROR;
				break;
			}


            DBG_MSG(DBG_LEV_INFO, ("ParseINF16 : DiCallClassInstaller %s", (ret IS OK ? "succeded" : "failed")));
		}

	} // if wCommand IS CMD_INSTALL_DRIVER


	// We don't need the driver node anymore
	// Clean up and delete
    //
	if (lpdn->atInfFileName ISNT 0)
		GlobalDeleteAtom(lpdn->atInfFileName);
	if (lpdn->atMfgName ISNT 0)
		GlobalDeleteAtom(lpdn->atMfgName);
	if (lpdn->atProviderName ISNT 0)
		GlobalDeleteAtom(lpdn->atProviderName);
	HP_GLOBAL_FREE(lpdn);

	return ret;
}



/*****************************************************************************\
* LibMain
*
*   Entry-point initialization.
*
\*****************************************************************************/
#if 0
int CALLBACK LibMain(HANDLE hModule,
					 WORD   wDataSeg,
					 WORD   cbHeapSize,
					 LPSTR  lpszCmdLine)
{
	g_hInst = NULL;
	g_hInst = (HINSTANCE) hModule;
	return 1;
}

#else

BOOL FAR PASCAL LibMain(
    HANDLE hInst,
    int    nAttach,
    LPVOID pContext)
{
    if (g_hInst == NULL) {

        g_hInst = (HINSTANCE)hInst;

        if (InitStrings())
            return thk_ThunkConnect16(cszDll16, cszDll32, hInst, 1);

    }

    return FALSE;
}


#endif

/*****************************************************************************\
* Windows Exit Proceedure (WEP)
*
*
\*****************************************************************************/
int CALLBACK WEP(int exportType)
{
    FreeStrings();

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\dllini.cxx ===
/*****************************************************************************\
* MODULE: dllini.cxx
*
* Dll entry/exit routines.
*
*
* Copyright (C) 1997-1998 Hewlett-Packard Company.
* Copyright (C) 1997-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS         Created
*   22-Jun-1998 CHW         Cleaned
*
\*****************************************************************************/

#include "libpriv.h"

/*********************************************************** local routine ***\
* dll_ThunkError
*
*
\*****************************************************************************/
BOOL dll_ThunkError(VOID)
{
    LPTSTR pszMsg;
    int    nFmt;

    pszMsg = NULL;
    nFmt   = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           GetLastError(),
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPTSTR)&pszMsg,
                           0,
                           NULL);

    if (pszMsg && (nFmt > 0)) {

        // Display the string.
        //
        MessageBox(NULL, pszMsg, g_szMsgThunkFail, MB_OK | MB_ICONINFORMATION);


        // Free the buffer.
        //
        GlobalFree(pszMsg);
 	}

    return FALSE;
}


/*********************************************************** local routine ***\
* dll_ProcessAttach
*
*   Called when the process attaches to the dynalink.  This is the place
*   that is good to allocate global resouces.
*
\*****************************************************************************/
_inline BOOL dll_ProcessAttach(
    BOOL      bThk,
    HINSTANCE hModule)
{
    BOOL bRet;


    // Set the global hInstance.
    //
    g_hLibInst = hModule;
    bRet       = InitStrings();

    if (bRet && (bThk == FALSE))
        bRet = dll_ThunkError();

    return bRet;
}


/*********************************************************** local routine ***\
* dll_ProcessDetach
*
*   Called when a process detaches from the DLL.  This is only called once,
*   so all resources allocated on behalf of the dynalink are freed.
*
\*****************************************************************************/
_inline BOOL dll_ProcessDetach(
    BOOL      bThk,
    HINSTANCE hModule)
{
    if (bThk == FALSE)
        dll_ThunkError();

    FreeStrings();

    return TRUE;
}


/****************************************************** entry/exit routine ***\
* DllMain
*
*   This routine is called upon startup of the dynalink.  If all goes well
*   then return TRUE.  By returning FALSE you prevent the dynalink from
*   loading.
*
*   The parameters to this function double under DOS and NT. The meanings are
*   slightly different however.
*
*   Parameter       DOS                 NT
*   --------        -----------------   -------------
*   hHandle         Instance handle     Module handle (same as instance)
*   nAttach         Dynalink Data*Seg   Attach type.
*   pContext        Command Line args   pointer to context structur.
*
*
\*****************************************************************************/
BOOL APIENTRY DllMain(
    HINSTANCE hModule,
    int       nAttach,
    PCONTEXT  pContext)
{
    BOOL bRet;
    BOOL bThk;


    UNREFPARM(pContext);


    // Connect the thunk.
    //
    bThk = thk_ThunkConnect32(g_szDll16, g_szDll32, hModule, nAttach);

    switch (nAttach) {

    case DLL_PROCESS_ATTACH:
        bRet = dll_ProcessAttach(bThk, hModule);
        break;

    case DLL_PROCESS_DETACH:
        bRet = dll_ProcessDetach(bThk, hModule);
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        bRet = TRUE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\globals.h ===
/*****************************************************************************\
* MODULE: globals.h
*
* Global variables used throughout the library.
*
*
* Copyright (C) 1996-1998 Hewlett Packard Company.
* Copyright (C) 1996-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS         Initiated port from win95 to winNT
*   25-Jun-1998 CHW         Cleaned/localized.
*
\*****************************************************************************/

extern HINSTANCE g_hLibInst;

extern CONST TCHAR g_szEnvironment        [];
extern CONST TCHAR g_szDll16              [];
extern CONST TCHAR g_szDll32              [];
extern CONST TCHAR g_szNewLine            [];
extern CONST TCHAR g_szUniqueID           [];
extern CONST TCHAR g_szColorPath          [];
extern CONST TCHAR g_szBackslash          [];
extern CONST TCHAR g_szComma              [];
extern CONST TCHAR g_szSpace              [];
extern CONST TCHAR g_szNull               [];
extern CONST TCHAR g_szDot                [];

extern CONST CHAR g_szExtDevModePropSheet [];
extern CONST CHAR g_szExtDevMode          [];
extern CONST CHAR g_szDevMode             [];

extern LPTSTR g_szFmtName;
extern LPTSTR g_szMsgOptions;
extern LPTSTR g_szMsgThunkFail;
extern LPTSTR g_szPrinter;
extern LPTSTR g_szMsgExists;
extern LPTSTR g_szMsgOptCap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\libpriv.h ===
/*****************************************************************************\
* MODULE: libpriv.h
*
* The private header file for WPNPIN32.DLL. It contains internal
* routines which are called within the DLL.
*
*
* Copyright (C) 1996-1998 Hewlett Packard Company.
* Copyright (C) 1996-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS     Initial checkin
*   22-Jun-1998 CHW     Cleaned
*
\*****************************************************************************/

#ifndef _LIBPRIV_H
#define _LIBPRIV_H

#include <windows.h>
#include <winspool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <direct.h>
#include "wpnpin32.h"
#include "globals.h"
#include "resource.h"
#include "debug.h"
#include "mem.h"

//---------------------------------------------------------
// #includes from ..\inc directory
// (same for both 16 bit and 32 bit dlls)
//---------------------------------------------------------
#include <lpsi.h>
#include <errormap.h>
#include <hpmemory.h>

// Constants.
//
#define MAX_NAMES  100
#define ONE_SECOND ((DWORD)1000)
#define RES_BUFFER 128


//---------------------------------------------------------
// typedefs
//---------------------------------------------------------
typedef BOOL (FAR PASCAL* WEPPROC)(short);



#ifdef __cplusplus  // Place this here to prevent decorating
extern "C" {        // of symbols when doing C++ stuff.
#endif

RETERR FAR PASCAL ParseINF16(LPSI);
BOOL WINAPI       thk_ThunkConnect32(LPCTSTR, LPCTSTR, HINSTANCE, DWORD);
BOOL              InitStrings(VOID);
VOID              FreeStrings(VOID);

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif

#include <shlobj.h>

#ifdef __cplusplus  // Place this here to prevent decorating
extern "C" {        // of symbols when doing C++ stuff.
#endif

#define UNREFPARM(parm) (parm)

//---------------------------------------------------------
// Function Prototypes
//---------------------------------------------------------
int   GetCommandLineArgs(LPSI, LPCTSTR);
DWORD AddOnePrinter(LPSI, HWND);
UINT  prvMsgBox(HWND, LPCTSTR, UINT, UINT);


#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif

#endif // _LIBPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\libpriv.cxx ===
/*****************************************************************************\
* MODULE: libpriv.cxx
*
* Contains the source code for internal routines used throughout the library.
*
*
* Copyright (C) 1996-1998 Hewlett Packard Company.
* Copyright (C) 1996-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS     Initial checkin
*   10-Jun-1998 CHW     Cleaned.  Restructured.
*
\*****************************************************************************/

#include "libpriv.h"

#define strFree(pszStr) {if (pszStr) GlobalFree((HANDLE)pszStr);}

/*****************************************************************************\
* strAlloc
*
*   Allocates a string from the heap.  This pointer must be freed with
*   a call to strFree().
*
\*****************************************************************************/
LPTSTR strAlloc(
    LPCTSTR pszSrc)
{
    DWORD  cbSize;
    LPTSTR pszDst = NULL;


    cbSize = (pszSrc ? ((lstrlen(pszSrc) + 1) * sizeof(TCHAR)) : 0);

    if (cbSize) {

        if (pszDst = (LPTSTR)GlobalAlloc(GPTR, cbSize))
            CopyMemory(pszDst, pszSrc, cbSize);
    }

    return pszDst;
}


/*****************************************************************************\
* strLoad
*
*   Get string from resource based upon the ID passed in.
*
\*****************************************************************************/
LPTSTR strLoad(
    UINT ids)
{
    char szStr[RES_BUFFER];


    if (LoadString(g_hLibInst, ids, szStr, sizeof(szStr)) == 0)
        szStr[0] = TEXT('\0');

    return strAlloc(szStr);
}


/*****************************************************************************\
* InitStrings
*
*
\*****************************************************************************/
BOOL InitStrings(VOID)
{
    g_szFmtName      = strLoad(IDS_FMTNAME);
    g_szMsgOptions   = strLoad(IDS_MSG_OPTIONS);
    g_szMsgThunkFail = strLoad(IDS_THUNK32FAIL);
    g_szPrinter      = strLoad(IDS_PRINTER);
    g_szMsgExists    = strLoad(IDS_ALREADY_EXISTS);
    g_szMsgOptCap    = strLoad(IDS_MSG_OPTCAP);

    return (g_szFmtName       &&
            g_szMsgOptions    &&
            g_szMsgThunkFail  &&
            g_szPrinter       &&
            g_szMsgExists     &&
            g_szMsgOptCap
           );
}


/*****************************************************************************\
* FreeeStrings
*
*
\*****************************************************************************/
VOID FreeStrings(VOID)
{
    strFree(g_szFmtName);
    strFree(g_szMsgOptions);
    strFree(g_szMsgThunkFail);
    strFree(g_szPrinter);
    strFree(g_szMsgExists);
    strFree(g_szMsgOptCap);
}


/*****************************************************************************\
* prv_StrChr
*
* Looks for the first location where (c) resides.
*
\*****************************************************************************/
LPTSTR prv_StrChr(
    LPCTSTR cs,
    TCHAR   c)
{
    while (*cs != TEXT('\0')) {

        if (*cs == c)
            return (LPTSTR)cs;

        cs++;
    }

    // Fail to find c in cs.
    //
    return NULL;
}


/****************************************************************************\
* prv_CheesyHash
*
* Hash function to convert a string to dword representation.
*
\****************************************************************************/
DWORD prv_CheesyHash(
    LPCTSTR lpszIn)
{
    LPDWORD lpdwIn;
    DWORD   cbLeft;
    DWORD   dwTmp;
    DWORD   dwRet = 0;


    if (lpszIn && (cbLeft = (lstrlen(lpszIn) * sizeof(TCHAR)))) {

        // Process in DWORDs as long as possible
        //
        for (lpdwIn = (LPDWORD)lpszIn; cbLeft > sizeof(DWORD); cbLeft -= sizeof(DWORD)) {

            dwRet ^= *lpdwIn++;
        }


        // Process bytes for whatever's left of the string.
        //
        if (cbLeft) {

            for (dwTmp = 0, lpszIn = (LPTSTR)lpdwIn; *lpszIn; lpszIn++) {

                dwTmp |= (DWORD)(TCHAR)(*lpszIn);
                dwTmp <<= 8;
            }

            dwRet ^= dwTmp;
        }
    }

    return dwRet;
}


/*****************************************************************************\
* prv_ParseHostShare
*
* Parses the FriendlyName (http://host/printers/share/.printer) into its
* Host/Share components.
*
* This routine returns allocated pointers that must be freed by the caller.
*
\*****************************************************************************/
BOOL prv_ParseHostShare(
    LPCTSTR lpszFriendly,
    LPTSTR  *lpszHost,
    LPTSTR  *lpszShare)
{
    LPTSTR lpszPrt;
    LPTSTR lpszTmp;
    LPTSTR lpszPos;
    BOOL   bRet = FALSE;


    // Initialize the return buffers to NULL.
    //
    *lpszHost  = NULL;
    *lpszShare = NULL;


    // Parse the host-name and the share name.  The (lpszFriendly) is
    // currently in the format of http://host[:portnumber]/share.  We will
    // parse this from left->right since the share-name can be a path (we
    // wouldn't really know the exact length).  However, we do know the
    // location for the host-name, and anything after that should be
    // the share-name.
    //
    // First find the ':'.  The host-name should begin two "//" after
    // that.
    //
    if (lpszPrt = memAllocStr(lpszFriendly)) {

        if (lpszPos = prv_StrChr(lpszPrt, TEXT(':'))) {

            lpszPos++;
            lpszPos++;
            lpszPos++;


            // Get past the host.
            //
            if (lpszTmp = prv_StrChr(lpszPos, TEXT('/'))) {

                // HostName (includes http).
                //
                *lpszTmp = TEXT('\0');
                *lpszHost = memAllocStr(lpszPrt);
                *lpszTmp = TEXT('/');


                // ShareName.
                //
                if (lpszPos = prv_StrChr(++lpszTmp, TEXT('/'))) {

                    lpszPos++;

                    if (lpszTmp = prv_StrChr(lpszPos, TEXT('/'))) {

                        *lpszTmp = TEXT('\0');
                        *lpszShare = memAllocStr(lpszPos);
                        *lpszTmp = TEXT('/');

                        bRet = TRUE;

                    } else {

                        goto BadFmt;
                    }

                } else {

                    goto BadFmt;
                }

            } else {

                goto BadFmt;
            }

        } else {

BadFmt:
            DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32 : prv_ParseHostShare - Invalid name <%s>"), lpszFriendly));

            if (*lpszHost)
                memFreeStr(*lpszHost);

            if (*lpszShare)
                memFreeStr(*lpszShare);

            *lpszHost  = NULL;
            *lpszShare = NULL;
        }

        memFreeStr(lpszPrt);
    }

    return bRet;
}


/****************************************************************************\
* prv_StrPBrk
*
* DBCS-Aware version of strpbrk.
*
* NOTE: If this is ever converted/compiled as unicode, then this function
*       is broken.  It would need to be unicode-aware.
*
*       26-Jun-1998 : ChrisWil
*
\****************************************************************************/
LPTSTR prv_StrPBrk(
    LPCTSTR lpszSrch,
    LPCTSTR lpszTrgt)
{
    LPTSTR lpszPtr;


    if (lpszSrch && lpszTrgt) {

        for( ; *lpszSrch; lpszSrch = AnsiNext(lpszSrch)) {

            for (lpszPtr = (LPTSTR)lpszTrgt; *lpszPtr; lpszPtr = AnsiNext(lpszPtr)) {

                if (*lpszSrch == *lpszPtr) {

                    // First byte matches--see if we need to check
                    // second byte
                    //
                    if (IsDBCSLeadByte(*lpszPtr)) {

                        if(*(lpszSrch + 1) == *(lpszPtr + 1))
                            return (LPTSTR)lpszSrch;

                    } else {

                        return (LPTSTR)lpszSrch;
                    }
                }
            }
        }
    }

    return NULL;
}


/****************************************************************************\
* prv_BuildUniqueID
*
* Create a unique ID based on lpszModel/lpszPort/Timer.
*
\****************************************************************************/
DWORD prv_BuildUniqueID(
    LPCTSTR lpszModel,
    LPCTSTR lpszPort)
{
    return ((prv_CheesyHash(lpszModel) ^ prv_CheesyHash(lpszPort)) ^ GetTickCount());
}


/****************************************************************************\
* prv_IsNameInUse
*
* Return whether the name is already in use by the print-subsystem.
*
\****************************************************************************/
BOOL prv_IsNameInUse(
    LPCTSTR lpszName)
{
    HANDLE hPrinter;


    if (OpenPrinter((LPTSTR)lpszName, &hPrinter, NULL)) {

        ClosePrinter(hPrinter);

        return TRUE;
    }

    return FALSE;
}


/****************************************************************************\
* prv_CreateUniqueName
*
* Create a unique friendly name for this printer.  If (idx) is 0, then
* copy the name from the base to the (lpszDst).  Otherwise, play some
* games with truncating the name so it will fit.
*
\****************************************************************************/
BOOL prv_CreateUniqueName(
    LPTSTR  lpszDst,
    LPCTSTR lpszBaseName,
    DWORD   idx)
{
    TCHAR szBaseName[_MAX_NAME_];
    int   nFormatLength;
    BOOL  bSuccess = FALSE;

    if (idx) {

        // Create a unique friendly name for each instance.
        // Start with:
        // "%s %d"               After LoadMessage
        // "Short Model Name 2"  After wsprintf	or
        // "Very very long long Model Nam 2" After wsprintf
        //
        // Since wsprintf has no concept of limiting the string size,
        // truncate the model name (in a DBCS-aware fashion) to
        // the appropriate size, so the whole string fits in _MAX_NAME_ bytes.
        // This may cause some name truncation, but only in cases where
        // the model name is extremely long.

        // nFormatLength is length of string without the model name.
        // If wInstance is < 10, format length is 2 (space + digit).
        // If wInstance is < 100, format length is 3.  Else format
        // length is 4.  Add 1 to compensate for the terminating NULL,
        // which is counted in the total buffer length, but not the string
        // length,
        //
        if (idx < 10) {

            nFormatLength =  9 + 1;

        } else if (idx < 100) {

            nFormatLength = 10 + 1;

        } else {

            nFormatLength = 11 + 1;
        }


        // Truncate the base name, if necessary,
        // then build the output string.
        //
        lstrcpyn(szBaseName, lpszBaseName, sizeof(szBaseName) - nFormatLength);


        // there is already a copy 1 (undecorated base name)
        //
        wsprintf(lpszDst, g_szFmtName, (LPTSTR)szBaseName, (int)idx + 1);
        bSuccess = TRUE;

    } else {

        lstrcpyn(lpszDst, lpszBaseName, _MAX_NAME_);

        bSuccess = TRUE;
    }

    return bSuccess;
}


/****************************************************************************\
* prv_FindUniqueName
*
* Find a unique name that isn't already in use by the print subsystem.
* Base the name on the friendly name and an instance count.
*
* This will alter the lpszFriendly; even if function fails.
*
\****************************************************************************/
BOOL prv_FindUniqueName(
    LPTSTR lpszFriendly)
{

    // Since our http:// name is too long for W95, we're going
    // to try basing our name off of the model-name.
    //
    // 28-Jun-1998 : ChrisWil

    DWORD idx;
    TCHAR *pszBase = NULL;
    BOOL  bRes     = FALSE;
     
    
    pszBase = memAllocStr( lpszFriendly );
    if (!pszBase) 
    {
        goto Cleanup;
    }


    // Iterate until we have found a unique name we can use.
    //
    for (idx = 0; idx < MAX_NAMES; idx++) {

        prv_CreateUniqueName(lpszFriendly, pszBase, idx);

        if (!prv_IsNameInUse(lpszFriendly))
        {
            bRes = TRUE;
            goto Cleanup;
        }
    }

Cleanup:

    if (pszBase) 
    {
        memFreeStr( pszBase );
    }
    return bRes;
}


/****************************************************************************\
* prv_IsThisDriverInstalled
*
* Get the list of all installed printer drivers, and check to see
* if the current driver is in the list. If the driver is already
* installed, ask the user if we should keep the old one or install
* over the top of it.
*
* returns: RET_OK               : OK.
*          RET_ALLOC_ERROR      : Out of memory.
*          RET_DRIVER_NOT_FOUND : Can't find driver.
*
\****************************************************************************/
DWORD prv_IsThisDriverInstalled(
    LPSI lpsi)
{
    DWORD           cbNeed;
    DWORD           cbSize;
    DWORD           cDrvs;
    DWORD           i;
    BOOL            bRet;
    int             iRes;
    LPDRIVER_INFO_1 lpdi1;
    DWORD           dwRet = RET_DRIVER_NOT_FOUND;


    // Get the size necessary to store the drivers.
    //
    cbSize = 0;
    cDrvs  = 0;
    EnumPrinterDrivers((LPTSTR)NULL,
                       (LPTSTR)NULL,
                       1,
                       NULL,
                       0,
                       &cbSize,
                       &cDrvs);


    // If we have drivers, then we can look for our installed driver.
    //
    if (cbSize && (lpdi1 = (LPDRIVER_INFO_1)memAlloc(cbSize))) {

       	bRet = EnumPrinterDrivers(NULL,
                                  NULL,
                                  1,
                                  (LPBYTE)lpdi1,
                                  cbSize,
                                  &cbNeed,
                                  &cDrvs);

        if (bRet) {

            for (i = 0; i < cDrvs; i++) {

                if (lstrcmpi(lpsi->szModel, lpdi1[i].pName) == 0) {

                    dwRet = RET_DRIVER_FOUND;
                    break;
                }
       		}
       	}


        // Free up our allocated buffer.
        //
       	memFree(lpdi1, cbSize);


        // If found, then we need to request from the user whether
        // to replace the driver.
        //
       	if (dwRet == RET_DRIVER_FOUND) {

       		iRes = MessageBox(NULL,
                              g_szMsgExists,
                              lpsi->szModel,
                              MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1);

       		if (iRes == IDNO)
       			dwRet = RET_DRIVER_NOT_FOUND;
            else
                dwRet = RET_OK;
        }
    }

    return dwRet;
}



/****************************************************************************\
* prv_BuildPrinterInfo
*
* Allocate and/or initialize a PRINTER_INFO_2 structure from LPSI.  Store
* the pointer in lpsi->lpPrinterInfo2.
*
* returns: RET_OK          : OK.
*          RET_ALLOC_ERROR : Out of memory.
*
\****************************************************************************/
DWORD prv_BuildPrinterInfo(
    LPSI lpsi)
{
    LPPRINTER_INFO_2 lppi2;


    // This code path is always executed just before we call
    // AddPrinter. Fill in anything we don't already have.
    //
    // Allocate memory if we need it.
    //
	if (lpsi->lpPrinterInfo2 == NULL) {

		lpsi->lpPrinterInfo2 = (LPBYTE)memAlloc(sizeof(PRINTER_INFO_2));
	}


    // Fill in the lppi2.
    //
    if (lppi2 = (LPPRINTER_INFO_2)lpsi->lpPrinterInfo2) {

        lppi2->pPrinterName    = lpsi->szFriendly;
        lppi2->pPortName       = lpsi->szPort;
        lppi2->pDriverName     = lpsi->szModel;
        lppi2->pPrintProcessor = lpsi->szPrintProcessor;
        lppi2->pDatatype       = lpsi->szDefaultDataType;
        lppi2->Priority        = DEF_PRIORITY;
        lppi2->Attributes      = 0;


        // Slow Machine?
        //
        if (0x0002 & GetSystemMetrics(SM_SLOWMACHINE))
            lppi2->Attributes |= PRINTER_ATTRIBUTE_QUEUED;


        // Point & Print case--make sure that the devmode we use to
        // add the printer locally contains the local friendly name
        // and not the friendly name it had on the server
        //
        if (lppi2->pDevMode) {

            lstrcpyn((LPSTR)lppi2->pDevMode->dmDeviceName,
                     lpsi->szFriendly,
                     sizeof(lppi2->pDevMode->dmDeviceName));
        }

    } else {

        return RET_ALLOC_ERR;
    }

    return RET_OK;
}


/****************************************************************************\
* prv_InstallPrinter
*
* Install the printer identified by LPSI.  If the printer exists, then
* call SetPrinter().  Otherwise, call AddPrinter().
*
* returns: RET_OK                : OK.
*          RET_ALLOC_ERROR       : Out of memory.
*          RET_ADD_PRINTER_ERROR : Can't add printer.
*
\****************************************************************************/
DWORD prv_InstallPrinter(
    LPSI lpsi)
{
    DWORD            dwRet;
    PRINTER_INFO_5   pi5;
    LPPRINTER_INFO_2 lppi2 = NULL;
    HANDLE           hPrinter = NULL;
    BOOL             bRes = FALSE;


    // BuildPrinterInfo will allocate an lppi2 and attach it to lpsi
    //
    if ((dwRet = prv_BuildPrinterInfo(lpsi)) == RET_OK) {

        lppi2    = (LPPRINTER_INFO_2)lpsi->lpPrinterInfo2;
		dwRet    = RET_ADD_PRINTER_ERROR;
        hPrinter = AddPrinter(NULL, 2, (LPBYTE)lppi2);

        DBG_ASSERT((hPrinter != NULL), (TEXT("WPNPIN32: prv_InstallPrinter - Failed AddPrinter")));
    }


    if (hPrinter) {

        // Set the transmission & retry timeouts--remember that the
        // subsystem values are in milliseconds!
        //
        ZeroMemory(&pi5, sizeof(PRINTER_INFO_5));
        pi5.pPrinterName             = lpsi->szFriendly;
        pi5.DeviceNotSelectedTimeout = lpsi->wDNSTimeout * ONE_SECOND;
        pi5.TransmissionRetryTimeout = lpsi->wRetryTimeout * ONE_SECOND;
        pi5.pPortName                = lppi2->pPortName;
        pi5.Attributes               = lppi2->Attributes;

        SetPrinter(hPrinter, 5, (LPBYTE)&pi5, 0);


        // Set the printer's unique ID so we can delete it correctly later
        //
        if (lpsi->dwUniqueID = prv_BuildUniqueID(lpsi->szModel, lpsi->szPort)) {

            SetPrinterData(hPrinter,
                           (LPTSTR)g_szUniqueID,
                           REG_BINARY,
                           (LPBYTE)&lpsi->dwUniqueID,
                           sizeof(DWORD));
        }

        ClosePrinter(hPrinter);

		dwRet = RET_OK;
    }


    // We don't need lpPrinterInfo2 anymore.
    //
    if (lpsi->lpPrinterInfo2) {

        memFree(lpsi->lpPrinterInfo2, sizeof(PRINTER_INFO_2));
        lpsi->lpPrinterInfo2 = NULL;
	}


    // We don't need lpDriverInfo3 anymore
    //
    if (lpsi->lpDriverInfo3) {

        memFree(lpsi->lpDriverInfo3, memGetSize(lpsi->lpDriverInfo3));
        lpsi->lpDriverInfo3 = NULL;
    }

    return dwRet;
}


/****************************************************************************\
* prv_BuildDriverInfo
*
* Allocate and initialize a DRIVER_INFO_3 for lpsi.
* driver dependent files be copied to the printer-driver-directory.
*
\****************************************************************************/
BOOL prv_BuildDriverInfo(
    LPSI lpsi)
{
    LPDRIVER_INFO_3 lpdi3;


    // This code path is always executed before we call AddPrinterDriver.
    // Set up any data that we don't already have. We always work with
    // a DRIVER_INFO_3 on this pass.
    //
    // Allocate memory, if we need it.
    //
    if (lpsi->lpDriverInfo3 == NULL) {

        lpsi->lpDriverInfo3 = (LPBYTE)memAlloc(sizeof(DRIVER_INFO_3));
    }


    // Fill in the lpdi3;
    //
    if (lpdi3 = (LPDRIVER_INFO_3)lpsi->lpDriverInfo3) {

        lpdi3->cVersion         = (DWORD)lpsi->dwDriverVersion;
        lpdi3->pName            = lpsi->szModel;
        lpdi3->pEnvironment     = (LPTSTR)g_szEnvironment;
        lpdi3->pDriverPath      = lpsi->szDriverFile;
        lpdi3->pDataFile        = lpsi->szDataFile;
        lpdi3->pConfigFile      = lpsi->szConfigFile;
        lpdi3->pHelpFile        = lpsi->szHelpFile;
        lpdi3->pDefaultDataType = lpsi->szDefaultDataType;

        if (lpsi->wFilesUsed && lpsi->lpFiles)
            lpdi3->pDependentFiles = (LPSTR)lpsi->lpFiles;
        else
            lpdi3->pDependentFiles = NULL;
    }

    return (lpsi->lpDriverInfo3 ? TRUE : FALSE);
}


/****************************************************************************\
* prv_InstallPrinProcessor
*
* Copy the print processor file associated with this driver
* into the print processor directory and then add it to the
* print sub-system.  Do not overwrite an existing print
* processor of the same name.
*
\****************************************************************************/
DWORD prv_InstallPrintProcessor(
    LPSI  lpsi,
    LPCTSTR pszPath)
{
    DWORD  dwRet = RET_OK;

    LPTSTR lpPrintProcessorDLL;
    DWORD  pcbNeeded;
    TCHAR  buf[_MAX_PATH_];

    TCHAR  *pszBuf     = NULL;
    TCHAR  *pszTemp    = NULL;
    int    cbLength    = 0;
    int    cbBufLength = 0;


    // Add the print processor if required
    //
    if (lpPrintProcessorDLL = prv_StrPBrk(lpsi->szPrintProcessor, g_szComma)) {

        *lpPrintProcessorDLL++ = TEXT('\0');
        lstrcpy(buf, g_szNull);

        cbLength = lstrlen(pszPath) + lstrlen(g_szBackslash) + lstrlen(lpPrintProcessorDLL) + 1;
        if (cbLength) 
        {
            pszTemp = memAlloc( cbLength * sizeof(TCHAR) ); 
        }
        if (!pszTemp) 
        {
            dwRet = RET_ALLOC_ERR;
            goto Cleanup;
        }


        // get the source file
        //
        lstrcpy(pszTemp, pszPath);
        lstrcat(pszTemp, g_szBackslash);
        lstrcat(pszTemp, lpPrintProcessorDLL);


        // The DLL must be in the PrintProcessorDirectory
        //
        GetPrintProcessorDirectory(NULL,
                                   NULL,
                                   1,
                                   (LPBYTE)buf,
                                   sizeof(buf),
                                   &pcbNeeded);

        cbBufLength = lstrlen(buf) + lstrlen(g_szBackslash) + lstrlen(lpPrintProcessorDLL) + 1;
        if (cbBufLength) 
        {
            pszBuf = memAlloc( cbBufLength * sizeof(TCHAR) );
        }
        if (!pszBuf) 
        {
            dwRet = RET_ALLOC_ERR;
            goto Cleanup;
        }
        lstrcpy(pszBuf, buf);
		lstrcat(pszBuf, g_szBackslash);
		lstrcat(pszBuf, lpPrintProcessorDLL);

        // Copy the file, but don't overwrite an existing copy of it
        //
		CopyFile(lpPrintProcessorDLL, pszBuf, TRUE);

        AddPrintProcessor(NULL,
                          (LPTSTR)g_szEnvironment,
                          lpPrintProcessorDLL,
                          lpsi->szPrintProcessor);

	} else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("WPNPIN32 : No PrintProcessor to add")));
    }

Cleanup:

    if (pszTemp) 
    {
        memFree(pszTemp, cbLength * sizeof(TCHAR) );
    }
    if (pszBuf) 
    {
        memFree(pszBuf, cbBufLength * sizeof(TCHAR) );
    }
	return dwRet;
}


/****************************************************************************\
* prv_GetDriverVersion
*
* Confirm that the driver identified in lpsi is indeed a
* valid printer driver, and determine which version it
* is. Leave the driver loaded for performance reasons
* (since it will get loaded at least twice more).
*
\****************************************************************************/
DWORD prv_GetDriverVersion(
    LPSI   lpsi,
    LPTSTR pszPath)
{
    UINT      wOldErrorMode;
    HINSTANCE hDrv     = NULL;
    TCHAR     *pszTemp = NULL;
    INT       cbLength = 0;
    DWORD     idError  = RET_INVALID_DLL;


    wOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);

    cbLength = lstrlen(pszPath);
    if (cbLength > 0) {

        cbLength += lstrlen(g_szBackslash) + lstrlen(lpsi->szDriverFile) + 1;
        pszTemp   = memAlloc( cbLength * sizeof(TCHAR));
        if (!pszTemp) 
        {
            idError = RET_ALLOC_ERR;
            goto Cleanup;
        }

        lstrcpy(pszTemp, pszPath);
        lstrcat(pszTemp, g_szBackslash);
        lstrcat(pszTemp, lpsi->szDriverFile);

    } else {

        cbLength  = lstrlen(lpsi->szDriverFile) + 1;
        pszTemp   = memAlloc( cbLength * sizeof(TCHAR));
        if (!pszTemp) 
        {
            idError = RET_ALLOC_ERR;
            goto Cleanup;
        }
        lstrcpy(pszTemp, lpsi->szDriverFile);
    }


    // Load the library.
    //
    hDrv = LoadLibrary(pszTemp);
    SetErrorMode(wOldErrorMode);

    if (hDrv) {

        // We successfully loaded the DLL, now we want to confirm that it's
        // a printer driver and get its version. We get ourselves into
        // all sorts of trouble by calling into the driver before it's
        // actually installed, so simply key off the exported functions.
        //
		idError = RET_OK;

        if (GetProcAddress(hDrv, g_szExtDevModePropSheet)) {

            lpsi->dwDriverVersion = 0x0400;

        } else if (GetProcAddress(hDrv, g_szExtDevMode)) {

            lpsi->dwDriverVersion = 0x0300;

        } else if (GetProcAddress(hDrv, g_szDevMode)) {

            lpsi->dwDriverVersion = 0x0200;

        } else {

            lpsi->dwDriverVersion = 0x0000;

            idError = RET_INVALID_PRINTER_DRIVER;
        }

        FreeLibrary(hDrv);
    }
	
Cleanup:

    if (pszTemp) 
    {
        memFree(pszTemp, cbLength * sizeof(TCHAR));
    }
	return idError;
}


/****************************************************************************\
* prv_UpdateICM
*
* Add color profiles to the registry.
*
\****************************************************************************/
BOOL prv_UpdateICM(
    LPTSTR lpFiles)
{
    TCHAR  szPath[_MAX_PATH_];
    TCHAR  szColor[RES_BUFFER];
    UINT   wLength;
    UINT   wColorLength;
    LPTSTR lpTemp = szPath;
    LPTSTR lpLast = NULL;
    BOOL   bReturn = FALSE;


    // Nothing to do if the dependent file list is NULL or empty
    //
    if (lpFiles && *lpFiles) {

        // Add any color profiles that are referenced by this device.
        // First, get the system directory & make sure that it ends
        // in a backslash
        //
        wLength = GetSystemDirectory(szPath, sizeof(szPath));

        while (lpLast = prv_StrPBrk(lpTemp, g_szBackslash)) {

            lpTemp = lpLast + 1;

            if (*lpTemp == TEXT('\0'))
                break;
        }

        if (!lpLast) {

            lstrcat(szPath, g_szBackslash);
            wLength++;
        }

        lpLast = szPath + wLength;

        // Get the comparison string for the path.
        //
        if (!LoadString(g_hLibInst, IDS_COLOR_PATH, szColor, RES_BUFFER)) {

            lstrcpy(szColor, g_szColorPath);
        }

        wColorLength = lstrlen(szColor);

        lpTemp = lpFiles;


        // Now walk down the list of files & compare the beginning of the
        // string to "COLOR\\". If it matches, assume that this is a color
        // profile and notify the system that it's changing.
        //
        while (*lpTemp) {

            UINT wTempLength = lstrlen(lpTemp);

            if (wTempLength > wColorLength) {

                BYTE bOldByte = lpTemp[wColorLength];
                int  nMatch;

                lpTemp[wColorLength] = TEXT('\0');
                nMatch = lstrcmpi(lpTemp, szColor);
                lpTemp[wColorLength] = bOldByte;

                if (!nMatch) {

                    lstrcpy(lpLast, lpTemp);
                    bReturn |= UpdateICMRegKey(0, 0, szPath, ICM_ADDPROFILE);
                }
            }

            lpTemp += (wTempLength+1);
        }
    }

    return bReturn;
}


/****************************************************************************\
* prv_InstallPrinterDriver
*
* Install a printer-driver into the subsystem.  This requires that all
* driver dependent files be copied to the printer-driver-directory.
*
*
* returns: RET_OK           : OK.
*          RET_USER_CANCEL  : User cancelled driver install.
*          RET_BROWSE_ERROR : User hits cancel key in browse dialog.
*
\****************************************************************************/
DWORD prv_InstallPrinterDriver(
    LPSI lpsi,
    HWND hWnd)
{
    BOOL  bSuccess = FALSE;
    DWORD dwResult = RET_OK;
    CHAR  szPath[_MAX_PATH_];


    if (lpsi->wCommand == CMD_INSTALL_DRIVER) {

        // Get the driver version
        //
        if ( _getcwd(szPath, _MAX_PATH_) == NULL)
            lstrcpy(szPath, ".");

        lpsi->dwDriverVersion = 0;
        dwResult = prv_GetDriverVersion(lpsi, szPath);

        if (dwResult != RET_OK) {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("WPNPIN32 : prv_GetDriverVersion Failed")));

            // The AddPrinterDriver code will check the version
            // number. I think.
            //
            lpsi->dwDriverVersion = 0x0400;
        }


        // Install the printprocessor if one is provided.
        //
        prv_InstallPrintProcessor(lpsi, szPath);


        // Build the driver-info.
        //
        if (prv_BuildDriverInfo(lpsi)) {

            if (!(bSuccess = AddPrinterDriver(NULL, 3, lpsi->lpDriverInfo3))) {

                if (ERROR_PRINTER_DRIVER_ALREADY_INSTALLED == GetLastError()) {

                    bSuccess = TRUE;
                }
            }
        }

        if (bSuccess) {

            prv_UpdateICM(((LPDRIVER_INFO_3)(lpsi->lpDriverInfo3))->pDependentFiles);
        }
    }

    return RET_OK;
}


/*****************************************************************************\
* GetCommandLineArgs(LPSI, LPCTSTR)
*
* Parse the DAT file to retrieve Web PnP Install options.
*
* LPCWSTR is the name of the dat file.  The dat file contains:
*
* /i
* /x  Web Print calls
* /b  Printer name    lpsi*>szFriendly
* /f  inf file        lpsi*>INFfileName
* /r  Port name       lpsi*>szPort
* /m  Printer model   lpsi*>szModel
* /n  Share name      lpsi*>ShareName
* /a  Bin file        lpsi*>BinName
*
\*****************************************************************************/
int GetCommandLineArgs(
    LPSI    lpsi,
    LPCTSTR lpDatFile)
{
    int    i;
    int    count = 0;
    DWORD  bytesRead = 0;
    LPTSTR lpstrCmd;
    HANDLE hFile = NULL;
    WCHAR  wideBuf[1024];
    TCHAR  buf[1024];
    UCHAR  ch;


    DBG_MSG(DBG_LEV_INFO, (TEXT("The File to be Read - %s"), lpDatFile));


	hFile = CreateFile(lpDatFile,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);

	if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE))
		return 0;

    i = ReadFile(hFile, (LPVOID)wideBuf, sizeof(wideBuf), &bytesRead, NULL);

	CloseHandle(hFile);

    if ( i == 0 || bytesRead == 0 )
        return 0;

    DBG_MSG(DBG_LEV_INFO, (TEXT("Number bytes read - %lu"), bytesRead));

    // convert wide buffer to MBCS
    //
    lstrcpy(buf, g_szNull);


    i = WideCharToMultiByte(CP_ACP,
                            0,
                            wideBuf,
                            -1,
                            buf,
                            sizeof(buf),
                            NULL,
                            NULL);

    if (i == 0) {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("WPNPIN32: ParseCmdLineArgs: Faild MBCS convert")));

        return 0;    // 0 args parsed
    }


    // Our dat-file is in unicode format, so we need to skip over the FFFE
    // signature at the beginning of the file.
    //
    lpstrCmd = buf;
    ch = *lpstrCmd++;
    ch = *lpstrCmd++;

    //  skip over any white space
    //
    while (isspace(ch))
        ch = *lpstrCmd++;

    DBG_MSG(DBG_LEV_INFO, (TEXT("UCHAR N: %#X"), ch));

    //  process each switch character '/' or '-' as encountered
    //
    while (ch == TEXT('/') || ch == TEXT('-')) {

        ch = (UCHAR)tolower(*lpstrCmd++);

        //  process multiple switch characters as needed
        //
        switch (ch) {

        case TEXT('a'):    // .bin file name
			ch = *lpstrCmd++;
            //  skip over any following white space
            while (isspace(ch)) {
                ch = *lpstrCmd++;
            }

            if (ch != TEXT('"')) {

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid BinFile Name (/a)")));

                return RET_INVALID_DAT_FILE;

            } else {

                // skip over quote
                ch = *lpstrCmd++;

                // copy the name
                i = 0;
                while (ch != TEXT('"') && ch != TEXT('\0')) {
                    lpsi->BinName[i++] = ch;
                    ch = *lpstrCmd++;
                }
                lpsi->BinName[i] = TEXT('\0');
                if (ch != TEXT('\0'))
                    ch = *lpstrCmd++;

                count++;
            }
            break;

        case TEXT('b'):  // printer name

            ch = *lpstrCmd++;
            //  skip over any following white space
            while (isspace(ch)) {
                ch = *lpstrCmd++;
            }

            if (ch != TEXT('"'))  {

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid Printer Name (/b)")));

                return RET_INVALID_DAT_FILE;

             } else {

                // skip over quote
                ch = *lpstrCmd++;

                // copy the name
                i = 0;
                while (ch != TEXT('"') && ch != TEXT('\0')) {
                    lpsi->szFriendly[i++] = ch;
                    ch = *lpstrCmd++;
                }
                lpsi->szFriendly[i] = TEXT('\0');
                if (ch != TEXT('\0'))
                    ch = *lpstrCmd++;

                count++;
            }
            break;

        case TEXT('f'):        // INF file name
            ch = *lpstrCmd++;
            //  skip over any following white space
            while (isspace(ch)) {
                ch = *lpstrCmd++;
            }

            if (ch != TEXT('"')) {

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid InfFile Name (/f)")));

                return RET_INVALID_DAT_FILE;

            } else {

				// skip over quote
				ch = *lpstrCmd++;

				// copy the name
				i = 0;
				while (ch != TEXT('"') && ch != TEXT('\0'))
				{
					lpsi->INFfileName[i++] = ch;
					ch = *lpstrCmd++;
				}
				lpsi->INFfileName[i] = TEXT('\0');
				if (ch != '\0')
					ch = *lpstrCmd++;

				count++;
			}
			break;

		case TEXT('i'):        // unknown
				ch = *lpstrCmd++;		// 'f'
				if (ch != TEXT('\0'))
					ch = *lpstrCmd++;	// space
				count++;
			break;

		case TEXT('m'):        // printer model
			ch = *lpstrCmd++;
			//  skip over any following white space
			while (isspace(ch)) {
				ch = *lpstrCmd++;
			}

			if (ch != '"') {

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid PrinterModel Name (/m)")));

				return RET_INVALID_DAT_FILE;

			} else {

				// skip over quote
				ch = *lpstrCmd++;

				// 	copy the name
				i = 0;
				while (ch != TEXT('"') && ch != TEXT('\0'))
				{
					lpsi->szModel[i++] = ch;
					ch = *lpstrCmd++;
				}
				lpsi->szModel[i] = TEXT('\0');
				if (ch != TEXT('\0'))
					ch = *lpstrCmd++;

				count++;
			}
			break;

		case TEXT('n'):        // share name
			ch = *lpstrCmd++;
			//  skip over any following white space
			while (isspace(ch)) {
				ch = *lpstrCmd++;
			}

			if (ch != TEXT('"')) {

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid Share Name (/n)")));

				return RET_INVALID_DAT_FILE;

			} else {

				// skip over quote
				ch = *lpstrCmd++;

				// 	copy the name
				i = 0;
				while (ch != TEXT('"') && ch != TEXT('\0'))
				{
					lpsi->ShareName[i++] = ch;
					ch = *lpstrCmd++;
				}
				lpsi->ShareName[i] = TEXT('\0');
				if (ch != TEXT('\0'))
					ch = *lpstrCmd++;

				count++;
			}
			break;

		case TEXT('r'):        // port name
			ch = *lpstrCmd++;
			//  skip over any following white space
			while (isspace(ch)) {
				ch = *lpstrCmd++;
			}

			if (ch != TEXT('"')) {

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid Port Name (/r)")));

				return RET_INVALID_DAT_FILE;

			} else {

				// skip over quote
				ch = *lpstrCmd++;

				// 	copy the name
				i = 0;
				while (ch != TEXT('"') && ch != TEXT('\0'))
				{
					lpsi->szPort[i++] = ch;
					ch = *lpstrCmd++;
				}
				lpsi->szPort[i] = TEXT('\0');
				if (ch != TEXT('\0'))
					ch = *lpstrCmd++;

				count++;
			}
			break;

		case TEXT('x'):       // unknown
				ch = *lpstrCmd++;
				count++;
			break;

		case TEXT('?'):        // help
				MessageBox(NULL, g_szMsgOptions, g_szMsgOptCap, MB_OK);
			break;

		default:		/* invalid option */

                DBG_MSG(DBG_LEV_WARN, (TEXT("WPNPIN32: Args - Invalid Option")));

			break;

        } //switch

        while (isspace(ch))
            ch = *lpstrCmd++;

	} // while / or -

    return count;
}


/****************************************************************************\
* PrintLPSI
*
* Print out the contents of the LPSI structure.
*
\****************************************************************************/
VOID prv_PrintLPSI(
    LPSI lpsi)
{
    DBG_MSG(DBG_LEV_INFO, (TEXT("LPSI Structure Dump")));
    DBG_MSG(DBG_LEV_INFO, (TEXT("-------------------")));
    DBG_MSG(DBG_LEV_INFO, (TEXT("dwDriverVersion   : %#lX"), lpsi->dwDriverVersion  ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("dwUniqueID        : %d")  , lpsi->dwUniqueID       ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("bNetPrinter       : %d")  , lpsi->bNetPrinter      ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("wFilesUsed        : %d")  , lpsi->wFilesUsed       ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("wFilesAllocated   : %d")  , lpsi->wFilesAllocated  ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("wRetryTimeout     : %d")  , lpsi->wRetryTimeout    ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("wDNSTimeout       : %d")  , lpsi->wDNSTimeout      ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("bDontQueueFiles   : %d")  , lpsi->bDontQueueFiles  ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("bNoTestPage       : %d")  , lpsi->bNoTestPage      ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("hModelInf         : %d")  , lpsi->hModelInf        ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("lpPrinterInfo2    : %d")  , lpsi->lpPrinterInfo2   ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("lpDriverInfo3     : %d")  , lpsi->lpDriverInfo3    ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szFriendly        : %s")  , lpsi->szFriendly       ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szModel           : %s")  , lpsi->szModel          ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szDefaultDataType : %s")  , lpsi->szDefaultDataType));
    DBG_MSG(DBG_LEV_INFO, (TEXT("BinName           : %s")  , lpsi->BinName          ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("ShareName         : %s")  , lpsi->ShareName        ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("INFfileName       : %s")  , lpsi->INFfileName      ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szPort            : %s")  , lpsi->szPort           ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szDriverFile      : %s")  , lpsi->szDriverFile     ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szDataFile        : %s")  , lpsi->szDataFile       ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szConfigFile      : %s")  , lpsi->szConfigFile     ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szHelpFile        : %s")  , lpsi->szHelpFile       ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szPrintProcessor  : %s")  , lpsi->szPrintProcessor ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szVendorSetup     : %s")  , lpsi->szVendorSetup    ));
    DBG_MSG(DBG_LEV_INFO, (TEXT("szVendorInstaller : %s")  , lpsi->szVendorInstaller));

#if 0

    DWORD cch;
    PTSTR pszFile;

    DBG_MSG(DBG_LEV_INFO, (TEXT("Files:")));
    DBG_MSG(DBG_LEV_INFO, (TEXT("------")));

    for (cch = 0, pszFile = lpsi->lpFiles; *pszFile; pszFile += cch)
        DBG_MSG(DBG_LEV_INFO, (TEXT("%s"), pszFile);

#endif

}


/****************************************************************************\
* AddOnePrinter
*
* Add a single printer (including the driver and print-processor).
*
\****************************************************************************/
DWORD AddOnePrinter(
    LPSI lpsi,
    HWND hWnd)
{
    DWORD dwResult = RET_OK;
    DWORD cbNeeded;
    TCHAR ch;
    TCHAR srcINF[_MAX_PATH_];


#if 1 // Since our http:// name is too long for W95, we're going
      // to try basing our name off of the model-name.
      //
      // 28-Jun-1998 : ChrisWil

    lstrcpy(lpsi->szFriendly, lpsi->szModel);
#endif

    // Build a unique-name from the friendly-name.
    //
    if (prv_FindUniqueName(lpsi->szFriendly)) {

        // Determine if we need to add a new driver.  If there is already a
        // driver for this printer, ask if the user wants to re-install or
        // use the old one.
        //
        if ((dwResult = prv_IsThisDriverInstalled(lpsi)) == RET_OK) {

            lpsi->wCommand = 0;

        } else if (dwResult == RET_DRIVER_NOT_FOUND) {

            // Set it up to install the printer driver.
            //
            lpsi->wCommand = CMD_INSTALL_DRIVER;
            dwResult       = RET_OK;

            DBG_MSG(DBG_LEV_INFO, (TEXT("WPNPIN32 : AddOnePrinter - Driver Will be installed")));
       	}


       	// We need info about the driver even if we don't plan to
        // install/re-install it
        //
       	if (dwResult == RET_OK) {

       		// Get current directory and prepend to INF file name
            //
       		if ( _getcwd(srcINF, _MAX_PATH_) == NULL)
       			lstrcpy(srcINF, g_szDot);

       		lstrcat(srcINF, g_szBackslash);
       		lstrcat(srcINF, lpsi->INFfileName);
       		lstrcpy(lpsi->INFfileName, srcINF);

       		// Get the Printer driver directory and store in lpsi->szRes
       		// This is used for copying the files
            //
            GetPrinterDriverDirectory(NULL,
                                      NULL,
                                      1,
                                      (LPBYTE)lpsi->szDriverDir,
                                      sizeof(lpsi->szDriverDir),
                                      &cbNeeded);


       		// Parse the INF file and store info in lpsi.  This will
       		// add the driver to the print subsystem.
            //
            if ((dwResult = ParseINF16(lpsi)) != RET_OK) {

                DBG_MSG(DBG_LEV_ERROR, (TEXT("WPNPIN32 : ParseINF16 - Failed")));
            }
       	}


        // Install the printer-driver.  This routine will verify if the
        // (lpsi->wCommand indicates whether the driver should be installed.
        //
       	if (dwResult == RET_OK)
            dwResult = prv_InstallPrinterDriver(lpsi, hWnd);


       	// Install the Printer.
        //
       	if (dwResult == RET_OK)
       		dwResult = prv_InstallPrinter(lpsi);

	} else {

       DBG_MSG(DBG_LEV_ERROR, (TEXT("WPNPIN32 : AddOnePrinter : UniqueName failure")));

       dwResult = RET_NO_UNIQUE_NAME;
    }


    // Debug output of LPSI.
    //
	prv_PrintLPSI(lpsi);


	// Clean up memory.
    //
	if (lpsi->lpPrinterInfo2) {

		memFree(lpsi->lpPrinterInfo2, memGetSize(lpsi->lpPrinterInfo2));
		lpsi->lpPrinterInfo2 = NULL;
	}

	if (lpsi->lpDriverInfo3) {

		memFree(lpsi->lpDriverInfo3, memGetSize(lpsi->lpDriverInfo3));
		lpsi->lpDriverInfo3 = NULL;
	}

	if (lpsi->lpFiles) {

		HP_GLOBAL_FREE(lpsi->lpFiles);
		lpsi->lpFiles = NULL;
	}

	if (lpsi->lpVcpInfo) {

		HP_GLOBAL_FREE(lpsi->lpVcpInfo);
		lpsi->lpVcpInfo = NULL;
	}

    return dwResult;
}


/*****************************************************************************\
* prvMsgBox
*
* Displays a string-id in a messagebox.
*
\*****************************************************************************/
UINT prvMsgBox(
    HWND    hWnd,
    LPCTSTR lpszCap,
    UINT    idTxt,
    UINT    fMB)
{
    LPTSTR pszTxt;
    UINT   uRet = 0;

    if (pszTxt = strLoad(idTxt)) {

        uRet = MessageBox(hWnd, pszTxt, lpszCap, fMB);

        strFree(pszTxt);
    }

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\resource.h ===
/*****************************************************************************\
* MODULE: resource.h
*
* Resource string identifiers.
*
*
* Copyright (C) 1997-1998 Hewlett-Packard Company.
* Copyright (C) 1997-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS     Initial checkin
*   22-Jun-1998 CHW     Cleaned
*
\*****************************************************************************/

// Resource String Identifiers.
//
#define IDS_COLOR_PATH              704
#define IDS_ALREADY_EXISTS          705
#define IDS_ERR_COPYFAILURE         706
#define IDS_BROWSE_FOR_DRV          707
#define IDS_USER_CANCEL             708
#define IDS_BROWSE_ERR              709
#define IDS_INSTALLED_DRIVER        710
#define IDS_ALLOC_ERR               711
#define IDS_PRINTER                 712
#define IDS_OK                      713
#define IDS_INVALID_INFFILE         714
#define IDS_NO_UNIQUE_NAME          715
#define IDS_FILE_COPY_ERROR         716
#define IDS_ADD_PRINTER_ERROR       717
#define IDS_INVALID_DAT_FILE        718
#define IDS_DEFAULT_ERROR           719
#define IDS_THUNK32FAIL             720
#define IDS_FMTNAME                 721
#define IDS_MSG_OPTIONS             722
#define IDS_MSG_OPTCAP              723
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\mem.h ===
/*****************************************************************************\
* MODULE: mem.h
*
* Header file for memory handling routines (mem.cxx).
*
*
* Copyright (C) 1996-1998 Microsoft Corporation.
* Copyright (C) 1996-1998 Hewlett Packard Company.
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

/*-----------------------------------*\
| Constants
\*-----------------------------------*/
#define DEADBEEF      0xdeadbeef                    // Tail Marker.
#define MAPMEM        ((HANDLE)-1)                  // File-Map-Memory.
#define MEM_HEADSIZE  (4 * sizeof(DWORD))           //
#define MEM_TAILSIZE  (1 * sizeof(DWORD))           //
#define MEM_SIZE      (MEM_HEADSIZE + MEM_TAILSIZE) //


/*-----------------------------------*\
| MEMHEAD Structure
\*-----------------------------------*/
typedef struct _MEMHEAD {

    struct _MEMHEAD *pmPrev;    // Reference to previous mem-block (dbg-only).
    struct _MEMHEAD *pmNext;    // Reference to next mem-block     (dbg-only).
    DWORD           dwTag;      // Memory Tag.
    DWORD           cbSize;     // size of block allocated (non-aligned size).
    PVOID           pvMem[1];   // Start of user-addressable memory.

} MEMHEAD;
typedef MEMHEAD      *PMEMHEAD;
typedef MEMHEAD NEAR *NPMEMHEAD;
typedef MEMHEAD FAR  *LPMEMHEAD;


/*-----------------------------------*\
| MEMTAIL Structure
\*-----------------------------------*/
typedef struct _MEMTAIL {

    DWORD dwSignature;

} MEMTAIL;
typedef MEMTAIL      *PMEMTAIL;
typedef MEMTAIL NEAR *NPMEMTAIL;
typedef MEMTAIL FAR  *LPMEMTAIL;

/*-----------------------------------*\
| memAlignSize
\*-----------------------------------*/
_inline BOOL memAlignSize(
    DWORD cbSize)
{
    return ((cbSize & 3) ? (cbSize + (sizeof(DWORD) - (cbSize & 3))) : cbSize);
}

PVOID memAlloc(
    UINT cbSize);

BOOL memFree(
    PVOID  pMem,
    UINT   cbSize);

UINT memGetSize(
    PVOID pMem);

VOID memCopy(
    PSTR *ppDst,
    PSTR pSrc,
    UINT cbSize,
    PSTR *ppBuf);

PTSTR memAllocStr(
    LPCTSTR lpszStr);

BOOL memFreeStr(
   PTSTR lpszStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\globals.cxx ===
/*****************************************************************************\
* MODULE: globals.h
*
* Global variables used throughout the library.
*
*
* Copyright (C) 1996-1998 Hewlett Packard Company.
* Copyright (C) 1996-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS         Initiated port from win95 to winNT
*   25-Jun-1998 CHW         Cleaned/localized.
*
\*****************************************************************************/

#include "libpriv.h"

HINSTANCE g_hLibInst;


// Constant strings.
//
CONST TCHAR g_szEnvironment        [] = TEXT("Windows 4.0");
CONST TCHAR g_szDll16              [] = TEXT("wpnpin16.dll");
CONST TCHAR g_szDll32              [] = TEXT("wpnpin32.dll");
CONST TCHAR g_szNewLine            [] = TEXT("\n");
CONST TCHAR g_szUniqueID           [] = TEXT("PrinterID");
CONST TCHAR g_szColorPath          [] = TEXT("COLOR\\");
CONST TCHAR g_szBackslash          [] = TEXT("\\");
CONST TCHAR g_szComma              [] = TEXT(",");
CONST TCHAR g_szSpace              [] = TEXT(" ");
CONST TCHAR g_szNull               [] = TEXT("");
CONST TCHAR g_szDot                [] = TEXT(".");

CONST CHAR g_szExtDevModePropSheet [] = "EXTDEVICEMODEPROPSHEET";
CONST CHAR g_szExtDevMode          [] = "EXTDEVICEMODE";
CONST CHAR g_szDevMode             [] = "DEVICEMODE";


// Localizable strings.
//
LPTSTR g_szFmtName      = NULL;
LPTSTR g_szMsgOptions   = NULL;
LPTSTR g_szMsgThunkFail = NULL;
LPTSTR g_szPrinter      = NULL;
LPTSTR g_szMsgExists    = NULL;
LPTSTR g_szMsgOptCap    = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\mem.cxx ===
/*****************************************************************************\
* MODULE: mem.cxx
*
* Memory management routines.  These routines provide head/tail checking
* to verify memory corruption problems.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation.
* Copyright (C) 1996-1998 Hewlett Packard Company.
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include <windows.h>
#include "libpriv.h"

/*********************************************************** local routine ***\
* mem_StrSize
*
*   Returns size of string.
*
\*****************************************************************************/
_inline DWORD mem_StrSize(
    PCTSTR pszStr)
{
    return (pszStr ? ((lstrlen(pszStr) + 1) * sizeof(TCHAR)) : 0);
}


/*********************************************************** local routine ***\
* mem_HeadPtr
*
*   Returns the pointer to the head-block.  This needs to decrement enough
*   to account for the extra information stored at the head.
*
\*****************************************************************************/
_inline PMEMHEAD mem_HeadPtr(
    PVOID pvMem)
{
    return (PMEMHEAD)(pvMem ? (((PBYTE)pvMem) - MEM_HEADSIZE) : NULL);
}


/*********************************************************** local routine ***\
* mem_TailPtr
*
*   Returns the pointer to the tail-block.  This requires the aligned-size
*   to retrieve the offset.
*
\*****************************************************************************/
_inline PMEMTAIL mem_TailPtr(
    PMEMHEAD pmh,
    DWORD    cbAlign)
{
    return (PMEMTAIL)((PBYTE)pmh + cbAlign - MEM_TAILSIZE);
}

#ifdef DEBUG

PMEMHEAD g_pmHead = NULL;

/*********************************************************** local routine ***\
* mem_InsPtr
*
*   Inserts the pointer into our list for tracking allocations.
*
\*****************************************************************************/
_inline VOID mem_InsPtr(
    PMEMHEAD pmHead)
{
    if (g_pmHead) {

        g_pmHead->pmPrev = pmHead;
        pmHead->pmNext   = g_pmHead;

    } else {

        pmHead->pmNext = NULL;
    }

    g_pmHead = pmHead;
}


/*********************************************************** local routine ***\
* mem_DelPtr
*
*   Removes the pointer from our list of tracked allocations.
|
\*****************************************************************************/
_inline VOID mem_DelPtr(
    PMEMHEAD pmHead)
{
    PMEMHEAD pmPtr;


    if (pmHead->pmNext) {

        pmPtr         = pmHead->pmNext;
        pmPtr->pmPrev = pmHead->pmPrev;
    }

    if (pmHead->pmPrev) {

        pmPtr         = pmHead->pmPrev;
        pmPtr->pmNext = pmHead->pmNext;

    } else {

        g_pmHead = pmHead->pmNext;
    }
}


/*****************************************************************************\
* _mem_validate (Local Routine)
*
* Checks memory blocks allocated by memAlloc. These blocks contain
* debugging information that helps to check for pointer overruns and
* underruns.
*
* Returns a pointer to the memory header.  Otherwise, we return NULL.
*
\*****************************************************************************/
PMEMHEAD _mem_validate(
    PVOID pvMem,
    UINT  cbSize)
{
    DWORD    cbAlign;
    PMEMHEAD pmHead;
    PMEMTAIL pmTail;
    PMEMHEAD pmRet = NULL;


    // Retrieve the head-pointer.
    //
    if (pmHead = mem_HeadPtr(pvMem)) {

        // Calculate the "real" size of our allocated block and round it
        // up to an even number of DWORD blocks.
        //
        cbAlign = memAlignSize(cbSize + MEM_SIZE);


        // Get the tail location.
        //
        pmTail = mem_TailPtr(pmHead, cbAlign);


        // Compare the values that memAlloc stored at the beginning
        // and end of the block
        //
        if ((pmHead->cbSize == cbSize) && (pmTail->dwSignature == DEADBEEF))
            pmRet = pmHead;


        // Assert if errors.
        //
        DBG_ASSERT((pmHead->cbSize == cbSize), (TEXT("Err : _mem_validate: Bad Size at %08lX"), pvMem));
        DBG_ASSERT((pmTail->dwSignature == DEADBEEF), (TEXT("Err : _mem_validate: Block Corruption at %08lX"), pvMem));

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _mem_validate: Bad Pointer")));
    }

    return pmRet;
}

#else

/*********************************************************** local routine ***\
* Non-Debug Mappings.
*
*   On non-debug builds, we will just return the most efficient values.
*
\*****************************************************************************/
#define mem_InsPtr(pmHead)           {}
#define mem_DelPtr(pmHead)           {}
#define _mem_validate(pvMem, cbSize)  mem_HeadPtr(pvMem)

#endif

/*****************************************************************************\
* memAlloc
*
*
\*****************************************************************************/
PVOID memAlloc(
    UINT cbSize)
{
    PMEMHEAD pmHead;
    PMEMTAIL pmTail;
    DWORD    cbAlign;


    // The size of this memory-block will include header-information.  So,
    // we will add the header-size and align our memory on DWORD boundries.
    //
    cbAlign = memAlignSize(cbSize + MEM_SIZE);


    // Attempt to allocate the memory.  Proceed to setup
    // the memory block.
    //
    if (pmHead = (PMEMHEAD)GlobalAlloc(GPTR, cbAlign)) {

        pmTail = mem_TailPtr(pmHead, cbAlign);


        // Zero the memory-block so that we're dealing with
        // a clean contiguous array.
        //
        ZeroMemory((PVOID)pmHead, cbAlign);


        // Set up header/tail-information.  This contains the requested
        // size of the memory-block.  Increment the block so we return
        // the next available memory for the caller to use.
        //
        pmTail->dwSignature = DEADBEEF;
        pmHead->dwTag       = 0;
        pmHead->cbSize      = cbSize;
        pmHead->pmPrev      = NULL;
        pmHead->pmNext      = NULL;

        mem_InsPtr(pmHead);

    } else {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return (pmHead ? pmHead->pvMem : NULL);
}


/*****************************************************************************\
* memFree
*
*
\*****************************************************************************/
BOOL memFree(
    PVOID pvMem,
    UINT  cbSize)
{
    PMEMHEAD pmHead;
    BOOL     bRet = FALSE;


    // Try to at least make sure it's our memory and that no pointers have
    // gone astray in it.
    //
    if (pmHead = _mem_validate(pvMem, cbSize)) {

        mem_DelPtr(pmHead);

        bRet = (GlobalFree((PVOID)pmHead) == NULL);
    }

    return bRet;
}


/*****************************************************************************\
* memCopy
*
* Copies a block of memory into a Win32 format buffer -- a structure at the
* front of the buffer and strings packed into the end.
*
* On entry, *buf should point to the last available byte in the buffer.
*
\*****************************************************************************/
VOID memCopy(
    PSTR *ppDst,
    PSTR pSrc,
    UINT cbSize,
    PSTR *ppBuf)
{

    if (pSrc != NULL) {

        // Place bytes at end of buffer.
        //
        (*ppBuf) -= cbSize + 1;

        memcpy(*ppBuf, pSrc, cbSize);


        // Place buffer address in structure and save pointer to new
        // last available byte.
        //
        *ppDst = *ppBuf;

        (*ppBuf)--;

    } else {

        *ppDst = NULL;
    }
}


/*****************************************************************************\
* memGetSize
*
* Returns the size of a block of memory that was allocated with memAlloc().
*
\*****************************************************************************/
UINT memGetSize(
    PVOID pvMem)
{
    PMEMHEAD pmHead;

    return ((pmHead = mem_HeadPtr(pvMem)) ? pmHead->cbSize : 0);
}


/*****************************************************************************\
* memAllocStr
*
* Allocates local memory to store the specified string.  This takes in a
* (lpszStr) which is copied to the new memory.
*
\*****************************************************************************/
PTSTR memAllocStr(
    LPCTSTR lpszStr)
{
   PTSTR pMem;

   if (lpszStr == NULL)
      return NULL;

   if (pMem = (PTSTR)memAlloc(mem_StrSize(lpszStr))) {

      if (!lstrcpy((LPTSTR)pMem, lpszStr)) {
          memFreeStr (pMem);
          pMem = NULL;
      }
   }

   return pMem;
}


/*****************************************************************************\
* memFreeStr
*
* Frees the memory allocated by memAllocStr.
*
\*****************************************************************************/
BOOL memFreeStr(
   PTSTR pszStr)
{
   return memFree(pszStr, memGetSize(pszStr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\wpnpin32.cxx ===
/*****************************************************************************\
* MODULE: wpnpin32.cxx
*
* Entry/Exit routines for the library.
*
* Routines
* --------
* PrintUIEntryW
* PrintUIEntryA
*
*
* Copyright (C) 1997-1998 Hewlett-Packard Company.
* Copyright (C) 1997-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS     Initial checkin
*   23-Oct-1997 GFS     Modified PrintUIEntry to PrintUIEntryW
*   22-Jun-1998 CHW     Cleaned
*
\*****************************************************************************/

#include "libpriv.h"

/*****************************************************************************\
* PrintUIEntryW (Unicode)
*
*
\*****************************************************************************/
DLLEXPORT DWORD WINAPI PrintUIEntryW(
    HWND      hWnd,
    HINSTANCE hInstance,
    LPCWSTR   lpwszCmdDat,
    int       nShow)
{
    DWORD dwRet;
    int   cbSize = 0;
    LPSTR lpszCmdDat = NULL;

    cbSize = WideCharToMultiByte(CP_ACP,
                                 0,
                                 lpwszCmdDat,
                                 -1,
                                 lpszCmdDat,
                                 cbSize,
                                 NULL,
                                 NULL);


    if (lpszCmdDat = (LPSTR)memAlloc(cbSize)) {
        
        if (WideCharToMultiByte(CP_ACP,
                            0,
                            lpwszCmdDat,
                            -1,
                            lpszCmdDat,
                            cbSize,
                            NULL,
                            NULL)) {

            dwRet = PrintUIEntryA(hWnd, hInstance, lpszCmdDat, nShow);

        } else {

            dwRet = E_FAIL;
        }

        memFree(lpszCmdDat, cbSize);

    } else {

        dwRet = ERROR_OUTOFMEMORY;
    }


    // Set lasterror and return error.
    //
    SetLastError(dwRet);

    return dwRet;
}


/*****************************************************************************\
* PrintUIEntryA (Ansi)
*
*
\*****************************************************************************/
DLLEXPORT DWORD WINAPI PrintUIEntryA(
    HWND      hWnd,
    HINSTANCE hInstance,
    LPCSTR    lpszCmdDat,
    int       nShow)
{
    DWORD dwResult;
    UINT  idTxt;
    UINT  fMB;
    int   nArgs;
    DWORD dwRet;
    LPSI  lpsi;
    TCHAR *pszCap     = NULL;
    INT   cbStrLength = 0;


    // lop off the offending '@' at beginning of name.
    //
    lpszCmdDat++;


    // Create a SETUPINFO structure and proceed to the
    // installation.
    //
    if (lpsi = (LPSI)memAlloc(sizeof(SETUPINFO))) {

        // Parse command-line args into the (lpsi) structure.  The
        // return of this function will return the number of arguments
        // encountered.
        //
        nArgs = GetCommandLineArgs(lpsi, lpszCmdDat);


        // Add the printer.  This launches the whole process.
        //
        dwResult = (nArgs == 8 ? AddOnePrinter(lpsi, hWnd) : RET_INVALID_DAT_FILE);

        cbStrLength = lstrlen( lpsi->szFriendly ) + 1;
        pszCap = (TCHAR *)memAlloc( cbStrLength * sizeof(TCHAR) );
        if (pszCap) 
        {
            if (cbStrLength > 1) 
            {
                // Put the friendly-name as our caption.
                //
                lstrcpy( pszCap, lpsi->szFriendly );
                *(pszCap + lstrlen(pszCap) * sizeof(TCHAR)) = TEXT('\0');
            }
            else
            {
                *pszCap = TEXT('\0');
            }
        }


        // Clean up memory not cleaned up in AddPrinter
        //
        memFree(lpsi, sizeof(SETUPINFO));

        lpsi = NULL;

    } else {

        if (g_szPrinter) 
        {
            cbStrLength = lstrlen(g_szPrinter);
        }
        cbStrLength += 1;
        pszCap = memAlloc(cbStrLength * sizeof(TCHAR));
        if (pszCap) 
        {
            if (cbStrLength > 1) 
            {
                lstrcpy(pszCap, g_szPrinter);
            }
            else
            {
                *pszCap = TEXT('\0');
            }
        }
        dwResult = RET_ALLOC_ERR;
    }


    // This what we'll return to the caller.
    //
    dwRet = (dwResult == RET_OK ? ERROR_SUCCESS : E_FAIL);


    // Give the caller a message indicating the status of the
    // printer install.
    //
    switch (dwResult) {

    case RET_OK:
        idTxt = IDS_OK;
        fMB   = MB_OK | MB_ICONASTERISK;
        break;

    case RET_ALLOC_ERR:
    case RET_DRIVER_NODE_ERROR:
        idTxt = IDS_ALLOC_ERR;
        fMB   = MB_OK | MB_ICONEXCLAMATION;
        break;

    case RET_INVALID_INFFILE:
    case RET_SECT_NOT_FOUND:
    case RET_INVALID_PRINTER_DRIVER:
    case RET_INVALID_DLL:
    case RET_DRIVER_NOT_FOUND:
    case RET_DRIVER_FOUND:
        idTxt = IDS_INVALID_INFFILE;
        fMB   = MB_OK | MB_ICONEXCLAMATION;
        break;

    case RET_NO_UNIQUE_NAME:
        idTxt = IDS_NO_UNIQUE_NAME;
        fMB   = MB_OK | MB_ICONSTOP;
        break;

    case RET_USER_CANCEL:
        idTxt = IDS_USER_CANCEL;
        fMB   = MB_OK | MB_ICONEXCLAMATION;
        break;

    case RET_FILE_COPY_ERROR:
        idTxt = IDS_FILE_COPY_ERROR;
        fMB   = MB_OK | MB_ICONHAND;
        break;

    case RET_ADD_PRINTER_ERROR:
        idTxt = IDS_ADD_PRINTER_ERROR;
        fMB   = MB_OK | MB_ICONERROR;
        break;

    case RET_BROWSE_ERROR:
        idTxt = IDS_BROWSE_ERR;
        fMB   = MB_OK | MB_ICONERROR;
        break;

    case RET_INVALID_DAT_FILE:
        idTxt = IDS_INVALID_DAT_FILE;
        fMB   = MB_OK | MB_ICONERROR;
        break;

    default:
        idTxt = IDS_DEFAULT_ERROR;
        fMB   = MB_OK | MB_ICONERROR;
        break;
    }

    // Display the messagebox.
    //
    prvMsgBox(hWnd, szCap, idTxt, fMB);

    if (pszCap) 
    {
        memFree( pszCap, cbStrLength * sizeof(TCHAR) );
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\sources.inc ===
!IF 0
/*---------------------------------------------------------------------------*\
| MODULE: sources
|
|   This file is used by the BUILD executable for constructing the wpnpin32
|   dynalink.  This file is only used for NT 32bit systems.
|
|   FLAGS
|   -----
|   USE_MSVCRT
|   USE_UNICODE = 1 for Unicode; = 0 for Win95
|
|
| Copyright (C) 1997-1999 Hewlett-Packard Company.
| Copyright (C) 1997-1999 Microsoft Corporation.
|
| history:
|   13-Aug-1997 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
!ENDIF

MAJORCOMP = windows
MINORCOMP = wpnpin32

TARGETNAME = wpnpin32
TARGETPATH = obj
TARGETTYPE = DYNLINK

USE_MSVCRT  = 1
USE_UNICODE = 0

!IF $(USE_UNICODE)
TARGETENTRY = DllMain
C_UNICODE   = -DUNICODE -D_UNICODE
!ELSE
TARGETENTRY = DllMain
C_UNICODE   =
!ENDIF

DLLDEF   = ..\wpnpin32.def
INCLUDES = $(BASEDIR)\public\sdk\inc;..\..\inc

SOURCES = ..\debug.cxx    \
          ..\mem.cxx      \
          ..\dllini.cxx   \
          ..\globals.cxx  \
          ..\libpriv.cxx  \
          ..\wpnpin32.cxx \
          ..\wpnpin32.rc


DLLBASE  = 0x40000000
DLLENTRY = $(TARGETENTRY)
LINKLIBS =                                          \
           ..\..\thunk\win95\obj\i386\thk32.obj     \
           $(SDK_LIB_PATH)\thunk32.lib  \
           $(LIB_PLATFORM_PATH)\*\kernel32.lib      \
           $(LIB_PLATFORM_PATH)\*\user32.lib        \
           ..\..\lib\gdi32.lib                      \
           $(LIB_PLATFORM_PATH)\*\shell32.lib       \
           $(LIB_PLATFORM_PATH)\*\winspool.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\exe\pch.h ===
#include <windows.h>
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdlib.h>
#include "wpnpinst.h"
#include "wincrypt.h"
#include "softpub.h"
#include "wintrust.h"
#include "fdi.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\dll32\wpnpin32.h ===
/*****************************************************************************\
* MODULE: wpnpin32.h
*
* Entry/Exit Routines for the library.
*
*
* Copyright (C) 1997-1998 Hewlett-Packard Company.
* Copyright (C) 1997-1998 Microsoft Corporation.
*
* History:
*   10-Oct-1997 GFS     Initial checkin
*   23-Oct-1997 GFS     Modified PrintUIEntry to PrintUIEntryW
*   22-Jun-1998 CHW     Cleaned
*
\*****************************************************************************/

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
extern "C" {        // when doing C++ stuff.
#endif              //

#define DLLEXPORT __declspec(dllexport)

/*-----------------------------------*\
| API Routines
\*-----------------------------------*/
DLLEXPORT DWORD WINAPI PrintUIEntryA(HWND, HINSTANCE, LPCSTR , int);
DLLEXPORT DWORD WINAPI PrintUIEntryW(HWND, HINSTANCE, LPCWSTR, int);

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif              //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\exe\sources.inc ===
!IF 0
/*---------------------------------------------------------------------------*\
| MODULE: sources
|
|   FLAGS
|   -----
|   USE_MSVCRT
|   USE_CHWDLL
|
|
| history:
|   29-Dec-1996 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
!ENDIF

MAJORCOMP = windows
MINORCOMP = wpnpinst

TARGETNAME  = wpnpinst
TARGETPATH  = obj
TARGETTYPE  = PROGRAM

USE_MSVCRT = 1

INCLUDES = $(BASEDIR)\public\sdk\inc

MSC_WARNING_LEVEL=/W3 /WX

SOURCES = wpnpinst.c \
          globals.c  \
          wpnpinst.rc

UMTYPE  = $(MAJORCOMP)
UMAPPL  = $(MINORCOMP)
UMENTRY = $(TARGETENTRY)
UMBASE  = 0x4000000
TARGETLIBS  = $(SDK_LIB_PATH)\winspool.lib  \
          $(SDK_LIB_PATH)\wintrust.lib  \
          $(SDK_LIB_PATH)\fdi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\exe\globals.c ===
/*----------------------------------------------------------------------------*\
| MODULE: GLOBALS.C
|
|   Global variables for wpnpinst program.
|
|   Copyright (C) 1997 Microsoft
|   Copyright (C) 1997 Hewlett Packard
|
| history:
|   26-Aug-1997 <rbkunz> Created
|
\*----------------------------------------------------------------------------*/
#include "pch.h"

HINSTANCE  g_hInstance;

// Misc Character constants
//
CONST TCHAR g_chBackslash   = TEXT('\\');
CONST TCHAR g_chDot         = TEXT('.');
CONST TCHAR g_chDoubleQuote = TEXT('\"');


//
//
CONST TCHAR g_szDotEXE[]  = TEXT(".EXE");
CONST TCHAR g_szDotDLL[]  = TEXT(".DLL");
CONST TCHAR g_szFNFmt []  = TEXT("%1\\%2");
CONST TCHAR g_szTNFmt []  = TEXT("~WP");


// Wide Char parm string to pass to PrintUIEntryW
//
CONST WCHAR g_wszParmString[] = L"@cab_ipp.dat";


// Module and entry point constants
//
CONST TCHAR g_szPrintUIMod   [] = TEXT("PRINTUI.DLL");
CONST TCHAR g_szPrintUIEquiv [] = TEXT("WPNPIN32.DLL");
CONST CHAR  g_szPrintUIEntryW[] = "PrintUIEntryW";


// Localizable Error Strings
//
LPTSTR g_szErrorFormat          = NULL;
LPTSTR g_szError                = NULL;
LPTSTR g_szEGeneric             = NULL;
LPTSTR g_szEBadCAB              = NULL;
LPTSTR g_szEInvalidParameter    = NULL;
LPTSTR g_szENoMemory            = NULL;
LPTSTR g_szEInvalidCABName      = NULL;
LPTSTR g_szENoDATFile           = NULL;
LPTSTR g_szECABExtract          = NULL;
LPTSTR g_szENoPrintUI           = NULL;
LPTSTR g_szENoPrintUIEntry      = NULL;
LPTSTR g_szEPrintUIEntryFail    = NULL;
LPTSTR g_szENotSupported        = NULL;

FAKEFILE g_FileTable[FILETABLESIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\exe\globals.h ===
/*----------------------------------------------------------------------------*\
| MODULE: globals.h
|
|   Globals header file.
|
|   Copyright (C) 1997 Microsoft
|   Copyright (C) 1997 Hewlett Packard
|
| history:
|   26-Aug-1997 <rbkunz> Created.
|
\*----------------------------------------------------------------------------*/

extern HINSTANCE g_hInstance;

// Misc Character constants
//
extern CONST TCHAR g_chBackslash;
extern CONST TCHAR g_chDot;
extern CONST TCHAR g_chDoubleQuote;

// Misc String Constants
//
extern CONST TCHAR g_szDotEXE[];
extern CONST TCHAR g_szDotDLL[];
extern CONST TCHAR g_szFNFmt [];
extern CONST TCHAR g_szTNFmt [];


// Wide char parm string to pass to PrintUIEntryW
//
extern CONST WCHAR g_wszParmString[];


// Module and entry point constants
//
extern CONST TCHAR g_szPrintUIMod   [];
extern CONST TCHAR g_szPrintUIEquiv [];
extern CONST CHAR  g_szPrintUIEntryW[];

// Error strings
//
extern LPTSTR g_szErrorFormat;
extern LPTSTR g_szError;
extern LPTSTR g_szEGeneric;
extern LPTSTR g_szEBadCAB;
extern LPTSTR g_szEInvalidParameter;
extern LPTSTR g_szENoMemory;
extern LPTSTR g_szEInvalidCABName;
extern LPTSTR g_szENoDATFile;
extern LPTSTR g_szECABExtract;
extern LPTSTR g_szEUserVerifyFail;
extern LPTSTR g_szENoPrintUI;
extern LPTSTR g_szENoPrintUIEntry;
extern LPTSTR g_szEPrintUIEntryFail;
extern LPTSTR g_szENotSupported;


// Error Return Codes
//
#define SUCCESS_EXITCODE            0xFFFFFFFF

#define ERR_NONE                    0x00000000
#define ERR_GENERIC                 0x80000000
#define ERR_AUTHENTICODE            0xC0000000

#define ERR_BAD_CAB                 0x80000001
#define ERR_INVALID_PARAMETER       0x80000002
#define ERR_NO_MEMORY               0x80000004
#define ERR_INVALID_CAB_NAME        0x80000008
#define ERR_NO_DAT_FILE             0x80000010
#define ERR_CAB_EXTRACT             0x80000020
#define ERR_NO_PRINTUI              0x80000040
#define ERR_NO_PRINTUIENTRY         0x80000080
#define ERR_PRINTUIENTRY_FAIL       0x80000100
#define ERR_PLATFORM_NOT_SUPPORTED  0x80000200

#define FILETABLESIZE               40

typedef struct _ERROR_MAPPING {
    DWORD    dwErrorCode;
    LPTSTR*  lpszError;
} ERROR_MAPPING, *LPERROR_MAPPING;

typedef struct _FAKEFILE {
    HANDLE      hFile;
    BOOL        bAvailable;
} FAKEFILE, *PFAKEFILE;

extern FAKEFILE g_FileTable[FILETABLESIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\exe\wpnpinst.c ===
/*---------------------------------------------------------------------------*\
| MODULE: WPNPINST.CXX
|
|   This is the main module for the WPNPINST application.
|
|   Copyright (C) 1997 Microsoft Corporation
|   Copyright (C) 1997 Hewlett Packard
|
| history:
|   25-Jul-1997 <rbkunz> Created.
|
\*---------------------------------------------------------------------------*/

#include "pch.h"
#include <tchar.h>

#define strFree(pszStr) {if (pszStr) GlobalFree((HANDLE)pszStr);}

/*****************************************************************************\
* strAlloc
*
*   Allocates a string from the heap.  This pointer must be freed with
*   a call to strFree().
*
\*****************************************************************************/
LPTSTR strAlloc(
    LPCTSTR pszSrc)
{
    DWORD  cbSize;
    LPTSTR pszDst = NULL;


    cbSize = (pszSrc ? ((lstrlen(pszSrc) + 1) * sizeof(TCHAR)) : 0);

    if (cbSize) {

        if (pszDst = (LPTSTR)GlobalAlloc(GPTR, cbSize))
            CopyMemory(pszDst, pszSrc, cbSize);
    }

    return pszDst;
}

/*****************************************************************************\
* strAllocAndCat
*
*   Allocates a string from the heap and concattenates another onto it.
*   This pointer must be freed with a call to strFree().
*
\*****************************************************************************/
LPTSTR strAllocAndCat(
    LPCTSTR pszSrc1,
    LPCTSTR pszSrc2)
{
    DWORD  cbSize;
    LPTSTR pszDst = NULL;


    cbSize = (pszSrc1 && pszSrc2 ? ((lstrlen(pszSrc1) + lstrlen(pszSrc2) + 1) * sizeof(TCHAR)) : 0);

    if (cbSize) {

        if (pszDst = (LPTSTR)GlobalAlloc(GPTR, cbSize)) {
            CopyMemory(pszDst, pszSrc1, cbSize);
            lstrcat( pszDst, pszSrc2 );
        }
    }

    return pszDst;
}


/*****************************************************************************\
* strLoad
*
*   Get string from resource based upon the ID passed in.
*
\*****************************************************************************/
LPTSTR strLoad(
    UINT ids)
{
    TCHAR szStr[MAX_RESBUF];


    if (LoadString(g_hInstance, ids, szStr, sizeof(szStr) / sizeof (TCHAR)) == 0)
        szStr[0] = TEXT('\0');

    return strAlloc(szStr);
}


/*****************************************************************************\
* InitStrings
*
*
\*****************************************************************************/
BOOL InitStrings(VOID)
{
    g_szErrorFormat       = strLoad(IDS_ERR_FORMAT);
    g_szError             = strLoad(IDS_ERR_ERROR);
    g_szEGeneric          = strLoad(IDS_ERR_GENERIC);
    g_szEBadCAB           = strLoad(IDS_ERR_BADCAB);
    g_szEInvalidParameter = strLoad(IDS_ERR_INVPARM);
    g_szENoMemory         = strLoad(IDS_ERR_NOMEM);
    g_szEInvalidCABName   = strLoad(IDS_ERR_INVNAME);
    g_szENoDATFile        = strLoad(IDS_ERR_NODAT);
    g_szECABExtract       = strLoad(IDS_ERR_CABFAIL);
    g_szENoPrintUI        = strLoad(IDS_ERR_NOPRTUI);
    g_szENoPrintUIEntry   = strLoad(IDS_ERR_PRTUIENTRY);
    g_szEPrintUIEntryFail = strLoad(IDS_ERR_PRTUIFAIL);
    g_szENotSupported     = strLoad(IDS_ERR_NOSUPPORT);


    return (g_szErrorFormat       &&
            g_szError             &&
            g_szEGeneric          &&
            g_szEBadCAB           &&
            g_szEInvalidParameter &&
            g_szENoMemory         &&
            g_szEInvalidCABName   &&
            g_szENoDATFile        &&
            g_szECABExtract       &&
            g_szENoPrintUI        &&
            g_szENoPrintUIEntry   &&
            g_szEPrintUIEntryFail &&
            g_szENotSupported
           );
}


/*****************************************************************************\
* FreeeStrings
*
*
\*****************************************************************************/
VOID FreeStrings(VOID)
{
    strFree(g_szErrorFormat);
    strFree(g_szError);
    strFree(g_szEGeneric);
    strFree(g_szEBadCAB);
    strFree(g_szEInvalidParameter);
    strFree(g_szENoMemory);
    strFree(g_szEInvalidCABName);
    strFree(g_szENoDATFile);
    strFree(g_szECABExtract);
    strFree(g_szENoPrintUI);
    strFree(g_szENoPrintUIEntry);
    strFree(g_szEPrintUIEntryFail);
    strFree(g_szENotSupported);
}


/*****************************************************************************\
*
* Win32Open (Local Routine)
*
* Translate a C-Runtime _open() call into appropriate Win32 CreateFile()
*
* NOTE:       Doesn't fully implement C-Runtime _open()
*             capability but it currently supports all callbacks
*             that FDI will give us
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\*****************************************************************************/
HANDLE Win32Open( LPCTSTR pszFile, int oflag, int pmode )
{
    HANDLE  FileHandle;
    BOOL    fExists     = FALSE;
    DWORD   fAccess;
    DWORD   fCreate;

    // NOTE: No Append Mode Support
    if (oflag & _O_APPEND)
        return INVALID_HANDLE_VALUE;

    // Set Read-Write Access
    if ((oflag & _O_RDWR) || (oflag & _O_WRONLY))
        fAccess = GENERIC_WRITE;
    else
        fAccess = GENERIC_READ;

     // Set Create Flags
    if (oflag & _O_CREAT)  {
        if (oflag & _O_EXCL)
            fCreate = CREATE_NEW;
        else if (oflag & _O_TRUNC)
            fCreate = CREATE_ALWAYS;
        else
            fCreate = OPEN_ALWAYS;
    } else {
        if (oflag & _O_TRUNC)
            fCreate = TRUNCATE_EXISTING;
        else
            fCreate = OPEN_EXISTING;
    }

    FileHandle = CreateFile( pszFile, fAccess, FILE_SHARE_READ, NULL, fCreate,
                             FILE_ATTRIBUTE_NORMAL, NULL );

    // NOTE:  Doesn't create directories like C runtime.
    // We don't need this capability for this app though.
    // All our directories will already exist

    return FileHandle;
}

/******************************************************************************\
*
* openfunc (Local Routine)
*
* Opens a file.  Used by FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
INT_PTR FAR DIAMONDAPI openfunc( CHAR FAR *pszFile, INT oflag, INT pmode ) {

    INT     rc;
    INT     i;

    // Find Available File Handle in Fake File Table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        if ( g_FileTable[i].bAvailable == TRUE ) {
            break;
        }
    }

    // Running out of file handles should never happen
    if ( i == FILETABLESIZE )  {
        rc = C_RUNTIME_IO_ERROR;
    }

#ifdef UNICODE

    {
        TCHAR uchFileName[_MAX_PATH] = {0};

        mbstowcs(uchFileName, pszFile, _MAX_PATH);

        g_FileTable[i].hFile = Win32Open(uchFileName, oflag, pmode );
    }

#else

    g_FileTable[i].hFile = Win32Open(pszFile, oflag, pmode );

#endif

    if ( g_FileTable[i].hFile != INVALID_HANDLE_VALUE )  {
        g_FileTable[i].bAvailable = FALSE;
        rc = i;
    } else {
        rc = C_RUNTIME_IO_ERROR;
    }
    return rc;
}

#ifdef UNICODE
/******************************************************************************\
*
* openfunc (Local Routine)
*
* Opens a file.  Used by FDINotify.
*
\******************************************************************************/
INT_PTR FAR DIAMONDAPI openfuncW( WCHAR FAR *pszFile, INT oflag, INT pmode ) {

    INT     rc;
    INT     i;

    // Find Available File Handle in Fake File Table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        if ( g_FileTable[i].bAvailable == TRUE ) {
            break;
        }
    }

    // Running out of file handles should never happen
    if ( i == FILETABLESIZE )  {
        rc = C_RUNTIME_IO_ERROR;
    }

    g_FileTable[i].hFile = Win32Open(pszFile, oflag, pmode );

    if ( g_FileTable[i].hFile != INVALID_HANDLE_VALUE )  {
        g_FileTable[i].bAvailable = FALSE;
        rc = i;
    } else {
        rc = C_RUNTIME_IO_ERROR;
    }
    return rc;
}
#endif

/******************************************************************************\
*
* closefunc (Local Routine)
*
* Closes a file.  Used by FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
INT FAR DIAMONDAPI closefunc( INT_PTR hf ) {

    INT rc;

    if ( CloseHandle( g_FileTable[hf].hFile ) )  {
        rc = 0;
        g_FileTable[hf].bAvailable = TRUE;
    } else  {
        rc = C_RUNTIME_IO_ERROR;
    }

    return rc;
}

/******************************************************************************\
*
* readfunc (Local Routine)
*
* Reads a file.  Used by FDI interface.
*
\******************************************************************************/
UINT FAR DIAMONDAPI readfunc( INT_PTR hf, PVOID pv, UINT cb ) {

    INT     rc;
    INT     cbRead;

    if ( ! ReadFile( g_FileTable[hf].hFile, pv, cb, (DWORD *) &cb, NULL ) ) {
        rc = C_RUNTIME_IO_ERROR;
    } else  {
        rc = cb;
    }

    return rc;
}


/******************************************************************************\
*
* writefunc (Local Routine)
*
* Writes a file.  Used by FDI interface
*
\******************************************************************************/
UINT FAR DIAMONDAPI writefunc( INT_PTR hf, PVOID pv, UINT cb ) {

    INT rc;

    if ( ! WriteFile( g_FileTable[hf].hFile, pv, cb, (DWORD *) &cb, NULL ) )  {
        rc = C_RUNTIME_IO_ERROR;
    } else  {
        rc = cb;
    }

    return rc;
}

/******************************************************************************\
*
* seekfunc (Local Routine)
*
* Repositions the file pointer.  Used by FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
LONG FAR DIAMONDAPI seekfunc( INT_PTR hf, LONG dist, INT seektype ) {

    LONG    rc;
    DWORD   dwResult;
    DWORD   W32seektype;

    switch (seektype) {
        case SEEK_SET:
            W32seektype = FILE_BEGIN;
            break;
        case SEEK_CUR:
            W32seektype = FILE_CURRENT;
            break;
        case SEEK_END:
            W32seektype = FILE_END;
            break;
    }

    dwResult = SetFilePointer(g_FileTable[hf].hFile, dist, NULL, W32seektype);

    if (dwResult == 0xFFFFFFFF) {
        rc = C_RUNTIME_SEEK_ERROR;
    }
    else
        rc = (LONG)dwResult;

    return rc;
}

/******************************************************************************\
*
* allocfunc (Local Routine)
*
* Allocates memory.  Used by FDI interface.
*
\******************************************************************************/
void HUGE * FAR DIAMONDAPI allocfunc(ULONG cb) {

    PVOID pv;

    pv = (PVOID) GlobalAlloc( GPTR, cb );
    return pv;
}

/******************************************************************************\
*
* freefunc (Local Routine)
*
* Frees memory.  Used by FDI interface.
*
\******************************************************************************/
void FAR DIAMONDAPI freefunc(void HUGE *pv) {

    GlobalFree( pv );
}

/******************************************************************************\
*
* AdjustFileTime (Local Routine)
*
* Sets file time.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
BOOL AdjustFileTime( INT_PTR hf, USHORT date, USHORT time )
{
    FILETIME    ft;
    FILETIME    ftUTC;

    if ( ! DosDateTimeToFileTime( date, time, &ft ) ) {
        return FALSE;
    }

    if ( ! LocalFileTimeToFileTime( &ft, &ftUTC ) ) {
        return FALSE;
    }

    if ( ! SetFileTime( g_FileTable[hf].hFile, &ftUTC, &ftUTC, &ftUTC ) ) {
        return FALSE;
    }

    return TRUE;
}


/******************************************************************************\
*
* Attr32FromAttrFAT (Local Routine)
*
* Translate FAT attributes to Win32 Attributes
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
DWORD Attr32FromAttrFAT( WORD attrMSDOS )
{
    //** Quick out for normal file special case
    if (attrMSDOS == _A_NORMAL) {
        return FILE_ATTRIBUTE_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!

    return attrMSDOS & (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}


/******************************************************************************\
*
* fdiNotify (Local Routine)
*
* Processes Notification messages from FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
INT_PTR FAR DIAMONDAPI fdiNotify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin) {

    INT_PTR     fh;                       // File Handle
    LPTSTR      lpszFile;                 // Current File
    PWPNPINFO   pInfo;                    // Pointer to a "Web-Point-N-Print" info structure
    INT_PTR     nReturn;
    DWORD       dwError;

    // The user-defined 'pv' is a pointer to our saved info
    pInfo = (PWPNPINFO)pfdin->pv;

    nReturn = 0;

    switch ( fdint )  {

        //*******************************************************************
        case fdintCABINET_INFO:
            nReturn = 0;
            break;

        //*******************************************************************
        case fdintCOPY_FILE:

            nReturn = C_RUNTIME_IO_ERROR;

            {

#ifdef UNICODE
                TCHAR uchFileName[_MAX_PATH] = {0};

                mbstowcs(uchFileName, pfdin->psz1, _MAX_PATH);

                if (NULL != (lpszFile = BuildFileName((LPCTSTR)pInfo->pTempDir, uchFileName))) {

                    fh = openfuncW( lpszFile, _O_BINARY | _O_TRUNC | _O_RDWR |
                                    _O_CREAT, _S_IREAD | _S_IWRITE );
#else
                if (NULL != (lpszFile = BuildFileName((LPCTSTR)pInfo->pTempDir, (LPCTSTR)pfdin->psz1))) {
                    fh = openfunc( lpszFile, _O_BINARY | _O_TRUNC | _O_RDWR |
                                   _O_CREAT, _S_IREAD | _S_IWRITE );
#endif
                    if (C_RUNTIME_IO_ERROR != fh) {

                        if (AddFileToList(pInfo, lpszFile)) {
                            nReturn = fh;
                        }
                        else {
                            closefunc(fh);
                        }
                    }

                    GlobalFree(lpszFile);
                }
            }
            break;

        //*******************************************************************
        case fdintCLOSE_FILE_INFO:

            nReturn = C_RUNTIME_IO_ERROR;
            if (AdjustFileTime( pfdin->hf, pfdin->date, pfdin->time ) ) {

                closefunc( pfdin->hf );

                {
#ifdef UNICODE
                    TCHAR uchFileName[_MAX_PATH] = {0};

                    mbstowcs(uchFileName, pfdin->psz1, _MAX_PATH);
                    if (NULL != (lpszFile = BuildFileName((LPCTSTR)pInfo->pTempDir, uchFileName))) {
#else
                    if (NULL != (lpszFile = BuildFileName((LPCTSTR)pInfo->pTempDir, (LPCTSTR)pfdin->psz1))) {
#endif
                        if (SetFileAttributes( lpszFile, Attr32FromAttrFAT( pfdin->attribs ) ) ) {

                            nReturn = TRUE;
                        }

                        GlobalFree(lpszFile);
                    }
                }
            }
            break;

        //*******************************************************************
        case fdintPARTIAL_FILE:
            nReturn = 0;
            break;

        //*******************************************************************
        case fdintNEXT_CABINET:
            nReturn = 0;
            break;

        //*******************************************************************
        case fdintENUMERATE:
            nReturn = 0;
            break;

        //*******************************************************************
        default:
            break;
    }

    return nReturn;
}

/*****************************************************************************\
* GetCurDir
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPTSTR GetCurDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)GlobalAlloc(GPTR, (cbSize * sizeof(TCHAR)))))
        GetCurrentDirectory(cbSize, lpszDir);

    return lpszDir;
}


/*****************************************************************************\
* WCFromMB (Local Routine)
*
* This routine returns a buffer of wide-character representation of a
* ansi string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPWSTR WCFromMB(
    LPCSTR lpszStr)
{
    DWORD  cbSize;
    DWORD  dwChars;
    LPWSTR lpwszBuf = NULL;

    cbSize = 0;

    dwChars = (DWORD)MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        lpszStr,
                                        -1,
                                        lpwszBuf,
                                        (int)(cbSize / sizeof(WCHAR)));

    cbSize = dwChars * sizeof(WCHAR);

    if (cbSize && (lpwszBuf = (LPWSTR)GlobalAlloc(GPTR, cbSize)))
        MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            lpszStr,
                            -1,
                            lpwszBuf,
                            (int)(cbSize / sizeof(WCHAR)));

    return lpwszBuf;
}


/*****************************************************************************\
* WCFromTC (Local Routine)
*
* This routine returns a buffer of wide-character representation of a
* TCHAR string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPWSTR WCFromTC(
    LPCTSTR lpszStr)
{
    DWORD  cbSize;
    DWORD  dwChars;
    LPWSTR lpwszBuf = NULL;

    cbSize = 0;

#ifdef UNICODE

    return (LPWSTR) lpszStr;

#else

    return WCFromMB(lpszStr);

#endif

}

/******************************************************************************\
*
* BuildFileName (Local Routine)
*
* Concatenates a path and file to produce a full pathname.
*
\******************************************************************************/
LPTSTR BuildFileName(
    LPCTSTR lpszPath,
    LPCTSTR lpszName)
{
    BOOL bReturn = FALSE;
    LPTSTR lpszMessage = NULL;
    INT cch = 0;
    UINT_PTR Args[MAX_ARGS];

    // Calculate the size necessary to hold the full-path filename.
    //
    cch += (lpszPath ? lstrlen(lpszPath) : 0);
    cch += (lpszName ? lstrlen(lpszName) : 0);

    // Concatenate the path and file
    //
    if (lpszPath) {

        Args[0] = (UINT_PTR) lpszPath;
        Args[1] = (UINT_PTR) lpszName;
        Args[2] = 0;

        if (0 != (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                g_szFNFmt,
                                0,
                                0,
                                (LPTSTR)&lpszMessage,
                                0,
                                (va_list*)Args ))) {
            bReturn = TRUE;
        }
    }

    return lpszMessage;
}

/******************************************************************************\
*
* GetDirectory (Local Routine)
*
* Returns the directory portion of a full pathname.
*
\******************************************************************************/
LPTSTR GetDirectory(LPTSTR lpszFile, LPDWORD lpdwReturn) {

    LPTSTR lpszSlash;
    LPTSTR lpszDir;

    lpszSlash = _tcsrchr(lpszFile, g_chBackslash);

    if (lpszSlash != NULL) {

        if (NULL != (lpszDir = (LPTSTR)GlobalAlloc(GPTR, (lpszSlash - lpszFile + 2) * sizeof(TCHAR)))) {

            lstrcpyn(lpszDir, lpszFile, (UINT32)((UINT_PTR)lpszSlash - (UINT_PTR)lpszFile) / sizeof(TCHAR) + 2);
            *lpdwReturn = ERR_NONE;
            return lpszDir;
        }
        else {
            *lpdwReturn = ERR_NO_MEMORY;
        }
    }
    else {
        *lpdwReturn = ERR_INVALID_PARAMETER;
    }

    return NULL;
}

/******************************************************************************\
*
* GetName (Local Routine)
*
* Returns the filename portion of a full pathname.
*
\******************************************************************************/
LPTSTR GetName(LPTSTR lpszFile, LPDWORD lpdwReturn) {

    LPTSTR lpszSlash;
    LPTSTR lpszName;
    int    nLength;

    lpszSlash = _tcsrchr(lpszFile, g_chBackslash);

    if (lpszSlash != NULL) {

        nLength = lstrlen(lpszSlash);

        if (NULL != (lpszName = (LPTSTR)GlobalAlloc(GPTR, (nLength * sizeof(TCHAR))))) {

            lstrcpyn(lpszName, ++lpszSlash, nLength);

            *lpdwReturn = ERR_NONE;
            return lpszName;
        }
        else {
            *lpdwReturn = ERR_NO_MEMORY;
        }
    }
    else {
        *lpdwReturn = ERR_INVALID_PARAMETER;
    }

    return NULL;
}


/******************************************************************************\
*
* CreateTempDirectory (Local Routine)
*
* Creates a unique temp directory to extract files into.
*
\******************************************************************************/
LPTSTR CreateTempDirectory() {

    LPTSTR pReturnDir = NULL;
    LPTSTR pTempDir;
    LPTSTR pCurrDir;
    LPTSTR pWinDir;
    DWORD  dwRequired = 0;

    // Save the current directory in pCurrDir
    //
    if (dwRequired = GetCurrentDirectory(0, NULL)) {

        if (pCurrDir = (LPTSTR)GlobalAlloc(GPTR, dwRequired * sizeof(TCHAR))) {

            if (GetCurrentDirectory(dwRequired, pCurrDir) <= dwRequired) {

                // We need to set the current directory to something reasonable (something
                // besides the desktop), because GetTempPath() will use the current directory
                // if no TEMP or TMP variable is set.  This will ensure that a user that saves the
                // downloaded .wpnp cab file on the desktop and later runs it will not get the cab
                // files extracted to the desktop.
                //
                if (dwRequired = GetWindowsDirectory(NULL, 0)) {

                    if (pWinDir = (LPTSTR)GlobalAlloc(GPTR, dwRequired * sizeof(TCHAR))) {

                        if (GetWindowsDirectory(pWinDir, dwRequired) <= dwRequired) {

                            if (SetCurrentDirectory(pWinDir)) {

                                // Get the temp path, so we can create a temp directory
                                // to extract the cabinet file into
                                //
                                if (dwRequired = GetTempPath(0, NULL)) {

                                    if (pTempDir = (LPTSTR)GlobalAlloc(GPTR, dwRequired * sizeof(TCHAR))) {

                                        if (GetTempPath(dwRequired, pTempDir) <= dwRequired) {

                                            // Now create a unique temp file name.
                                            //
                                            if (pReturnDir = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH * sizeof(TCHAR))) {

                                                if (GetTempFileName(pTempDir, g_szTNFmt, 0, pReturnDir)) {

                                                    // But what we really needed was a directory, so delete the file (now that
                                                    // we know that we have a unique name) and create a directory with
                                                    // the same name as the file.
                                                    //
                                                    DeleteFile(pReturnDir);
                                                    if (!CreateDirectory(pReturnDir, NULL)) {
                                                        GlobalFree(pReturnDir);
                                                        pReturnDir = NULL;
                                                    }
                                                    // else We succeeded in creating the temp dir.
                                                    //
                                                }
                                                // else we can't create a temp directory...cleanup.
                                                //
                                                else {
                                                    GlobalFree(pReturnDir);
                                                    pReturnDir = NULL;
                                                }

                                            }
                                        }

                                        GlobalFree(pTempDir);
                                    }
                                }
                            }
                        }

                        GlobalFree(pWinDir);
                    }
                }

                // Restore saved current directory
                SetCurrentDirectory(pCurrDir);
            }

            GlobalFree(pCurrDir);
        }
    }

    return pReturnDir;
}



#if 0

// The following 4 functions #ifdef'ed out on 11/6/97 RK
// PrintUI will call SetupX Catalog Verification APIs
// We don't need to verify any more

/******************************************************************************\
*
* RemoveExecutableFiles (Local Routine)
*
* Deletes executable files in the file list.
*
\******************************************************************************/
BOOL RemoveExecutableFiles(PWPNPINFO pInfo) {

    PFILENODE pFileNode;

    pFileNode = pInfo->pFileList;
    while (pFileNode) {
        if (IsExecutableFile(pFileNode->pFileName)) {
            DeleteFile(pFileNode->pFileName);
        }
        pFileNode = pFileNode->pNextFile;
    }

    return TRUE;
}

/******************************************************************************\
*
* IsExecutableFile (Local Routine)
*
* Determines if a file is an executable module.
*
* NOTE:  Can we check the actual file rather than just the extension?
*
\******************************************************************************/
BOOL IsExecutableFile(LPTSTR pFile) {

    BOOL    bReturn = FALSE;
    LPTSTR  pTemp = NULL;


    if (NULL != (pTemp = _tcsrchr(pFile, g_chDot)) ) {
        if (!lstrcmpi(pTemp, g_szDotDLL) || !lstrcmpi(pTemp, g_szDotEXE)) {
            bReturn = TRUE;
        }
    }

    return bReturn;
}


/******************************************************************************\
*
* CheckFile (Local Routine)
*
* Does an Authenticode check on a file.
*
\******************************************************************************/
DWORD CheckFile(LPTSTR lpszFile, LPDWORD lpAuthError) {

    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    LPWSTR                  lpwszFileName;
    DWORD                   dwReturn;

    dwReturn = ERR_GENERIC;
    if (NULL != (lpwszFileName = WCFromTC(lpszFile))) {

        memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
        memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

        sWTD.cbStruct       = sizeof(WINTRUST_DATA);
        sWTD.dwUIChoice     = WTD_UI_ALL;
        sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
        sWTD.pFile          = &sWTFI;

        sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
        sWTFI.hFile         = NULL;

        sWTFI.pcwszFilePath = lpwszFileName;

        *lpAuthError = WinVerifyTrust(NULL, &gV2, &sWTD);

        dwReturn = ERR_NONE;
        GlobalFree(lpwszFileName);
    }
    else {
        dwReturn = ERR_NO_MEMORY;
    }

    return dwReturn;
}

/******************************************************************************\
*
* VerifyFiles (Local Routine)
*
* Does Authenticode verification on all executable files in the filelist.
*
\******************************************************************************/
DWORD VerifyFiles(PWPNPINFO pInfo, LPDWORD lpAuthError) {

    DWORD dwReturn;
    BOOL bContinue;
    PFILENODE pFileNode;

    pFileNode = pInfo->pFileList;
    bContinue = TRUE;

    dwReturn     = ERR_NONE;
    *lpAuthError = ERROR_SUCCESS;

    while (bContinue && pFileNode) {

        if (IsExecutableFile(pFileNode->pFileName)) {

            bContinue = FALSE;
            dwReturn = CheckFile(pFileNode->pFileName, lpAuthError);

            if (*lpAuthError == ERROR_SUCCESS) {
                bContinue = TRUE;
            }
            else {
                if (*lpAuthError == TRUST_E_SUBJECT_NOT_TRUSTED) {

                    // The user didn't accept the signed/unsigned files
                    // Delete the executable files here, so that the print wizard
                    // will prompt the user for the files instead of using the downloaded files.

                    RemoveExecutableFiles(pInfo);
                    *lpAuthError = ERROR_SUCCESS;
                }
                else {
                    dwReturn = ERR_AUTHENTICODE;
                }
            }
        }
        pFileNode = pFileNode->pNextFile;
    }

    return dwReturn;
}

#endif

/******************************************************************************\
*
* GetCABName (Local Routine)
*
* Parses the CAB name from the command line.
*
\******************************************************************************/
PTSTR GetCABName(PTSTR pCmdLine, LPDWORD lpdwReturn) {

    PTSTR pEnd = 0;
    PTSTR pPtr;
    PTSTR pName;

    pPtr = pCmdLine;

    if (pPtr) {

        if (*pPtr == g_chDoubleQuote) {
            pPtr++;
            pEnd = _tcschr(pPtr, g_chDoubleQuote);
            if (pEnd)
                *pEnd = 0;
        }

        // If we haven't found an End-Quote, treat it as the end of the string.
        if (pEnd == NULL)
            pEnd = pPtr + lstrlen(pPtr);


        if (pName = (PTSTR)GlobalAlloc(GPTR, (pEnd - pPtr + 1) * sizeof(TCHAR))) {
            lstrcpyn(pName, pPtr, (UINT32) (pEnd - pPtr + 1));
            *lpdwReturn = ERR_NONE;
        }
        else {
            *lpdwReturn = ERR_NO_MEMORY;
        }

        return pName;
    }
    else {
        *lpdwReturn = ERR_INVALID_PARAMETER;
    }

    return NULL;
}

/******************************************************************************\
*
* AddFileToList (Local Routine)
*
* Adds a file to the list of extracted files.
*
\******************************************************************************/
BOOL AddFileToList(PWPNPINFO pInfo, PTSTR lpszFile) {

    PFILENODE       pInsertHere;
    BOOL            bReturn;

    bReturn = FALSE;

    if (NULL == (pInfo->pFileList)) {

        if (NULL != (pInfo->pFileList = (PFILENODE)GlobalAlloc(GPTR, sizeof(FILENODE)))) {

            pInsertHere = pInfo->pFileList;
            pInsertHere->pNextFile = NULL;
            bReturn = TRUE;
        }
    }
    else {
        if (NULL != (pInsertHere = (PFILENODE)GlobalAlloc(GPTR, sizeof(FILENODE)))) {

            pInsertHere->pNextFile = pInfo->pFileList;
            pInfo->pFileList = pInsertHere;
            bReturn = TRUE;
        }
    }

    if (bReturn && (NULL != (pInsertHere->pFileName = (LPTSTR)GlobalAlloc(GPTR, (lstrlen(lpszFile) + 1) *sizeof(TCHAR))) ) ) {
        lstrcpyn(pInsertHere->pFileName, lpszFile, lstrlen(lpszFile) + 1);
        bReturn = TRUE;
    }
    else {
        bReturn = FALSE;
    }

    return bReturn;
}

/******************************************************************************\
*
* FreeFileList (Local Routine)
*
* Frees memory allocated for file list.
*
\******************************************************************************/
VOID CleanupFileList(PWPNPINFO pInfo) {

    PFILENODE       pCurrentNode, pNextNode;
    HANDLE          hFindFind;
    LPTSTR          lpstrPos;
    LPTSTR          lpstrTemp;
    WIN32_FIND_DATA FindData;

    pCurrentNode = pInfo->pFileList;

    // Erase all extracted files and cleanup our memory structure.
    while (pCurrentNode) {
        if (!DeleteFile(pCurrentNode->pFileName)) {
            // We might have renamed one of our original cat files to this name. So
            // look for poem*.cat in the same directory
            lpstrPos = _tcsrchr(pCurrentNode->pFileName, TEXT('\\') );

            if (lpstrPos) {
                lpstrPos[1] = TEXT('\0');

                // Now pCurrentNode->pFileName has our directory path
                lpstrTemp = strAllocAndCat( pCurrentNode->pFileName , TEXT("poem*.cat") );

                if (lpstrTemp) {
                    hFindFind = FindFirstFile( lpstrTemp , &FindData );

                    if (hFindFind != INVALID_HANDLE_VALUE) {
                        // Delete the file
                        DeleteFile( FindData.cFileName );
                        FindClose( hFindFind );
                    }

                    strFree( lpstrTemp );
                }
            }
        }
        pNextNode = pCurrentNode->pNextFile;
        GlobalFree(pCurrentNode);
        pCurrentNode = pNextNode;
    }

    pInfo->pFileList = NULL;
}

/******************************************************************************\
*
* Extract (Local Routine)
*
* Extracts all files from the CAB file and adds them to a file list.
*
\******************************************************************************/
BOOL Extract(PWPNPINFO pInfo) {

    HFDI hfdi;
    ERF  erf;
    INT  nError;
    BOOL bReturn;
    int  i;

    bReturn = FALSE;

    // Initialize file table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        g_FileTable[i].bAvailable = TRUE;
    }

    hfdi = FDICreate( allocfunc, freefunc, openfunc, readfunc, writefunc,
                      closefunc, seekfunc, cpu80386, &erf);
    if (NULL != hfdi){

#ifdef UNICODE
        char achCABName[_MAX_PATH]={0}, achCABDir[_MAX_DIR]={0};

        wcstombs(achCABName, pInfo->pCABName, sizeof(achCABName));
        wcstombs(achCABDir, pInfo->pCABDir, sizeof(achCABDir));

        if (0 != (nError = FDICopy(hfdi, achCABName, achCABDir, 0, fdiNotify, NULL, (LPVOID)(pInfo))))
#else
        if (0 != (nError = FDICopy(hfdi, pInfo->pCABName, pInfo->pCABDir, 0, fdiNotify, NULL, (LPVOID)(pInfo))))
#endif
            bReturn = TRUE;
        else {
            CleanupFileList(pInfo);
        }

        FDIDestroy(hfdi);
    }

    return bReturn;
}

/******************************************************************************\
*
* GetWPNPSetupLibName (Local Routine)
*
* Returns the name of the print wizard library (NT5 and above)
* or equivalent for older clients (NT4 and Win9x)
*
\******************************************************************************/
LPTSTR GetWPNPSetupLibName(LPDWORD lpdwReturn) {

    LPTSTR        lpszLibName;
    OSVERSIONINFO OSVersionInfo;

    *lpdwReturn = ERR_GENERIC;

    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&OSVersionInfo)) {

        switch (OSVersionInfo.dwPlatformId) {

            // NT clients
            case VER_PLATFORM_WIN32_NT:

                // NT 5 or better
                if (OSVersionInfo.dwMajorVersion >= NT_VER_5) {

                    *lpdwReturn = ERR_NONE;
                    return (LPTSTR)g_szPrintUIMod;
                }
                // NT 4 clients
                else if (OSVersionInfo.dwMajorVersion >= NT_VER_4) {

                    *lpdwReturn = ERR_NONE;
                    return (LPTSTR)g_szPrintUIEquiv;
                }
                // NT clients: ver < 4.0
                else {

                    *lpdwReturn = ERR_PLATFORM_NOT_SUPPORTED;
                    return NULL;
                }

            // Win9x clients
            case VER_PLATFORM_WIN32_WINDOWS:

                *lpdwReturn = ERR_NONE;
                return (LPTSTR)g_szPrintUIEquiv;

            // Other clients ?
            default:

                *lpdwReturn = ERR_PLATFORM_NOT_SUPPORTED;
                return NULL;
        }
    }

    return NULL;
}

/******************************************************************************\
*
* InvokePrintWizard (Local Routine)
*
* Calls the PrintWizard (or 9x/NT4 equivalent)
* for printer setup and installation.
*
\******************************************************************************/
DWORD InvokePrintWizard(PWPNPINFO pInfo, LPDWORD lpAuthError) {

    DWORD   dwReturn;
    DWORD   dwErr;
    LPTSTR  lpszSetupLibName;
    HMODULE hLibrary;
    FARPROC lpProc;

    // Get the name of the print wizard module
    //
    if (NULL != (lpszSetupLibName = GetWPNPSetupLibName(&dwReturn)) ) {

        // Load the print wizard module
        //
        if (NULL != (hLibrary = LoadLibrary(lpszSetupLibName)) ) {

            // Find the webpnp installation proc address
            //
            if (NULL != (lpProc = GetProcAddress(hLibrary, g_szPrintUIEntryW) ) ) {

                // Call the webpnp installation entry point with the correct parameters
                //
                if ((*lpAuthError) = (UINT32) (*lpProc)(NULL, g_hInstance, g_wszParmString, SW_SHOWDEFAULT))
                    dwReturn = ERR_AUTHENTICODE;
                else
                    dwReturn = ERR_NONE;

            } else {

                dwReturn = ERR_NO_PRINTUIENTRY;
            }

            FreeLibrary(hLibrary);

        } else {

            dwReturn = ERR_NO_PRINTUI;
        }
    }

    return dwReturn;
}

/******************************************************************************\
*
* WebPnPCABInstall (Local Routine)
*
* Takes a CAB file and does the driver extraction and printer installation.
*
\******************************************************************************/
DWORD WebPnPCABInstall(PTSTR pCABName, PDWORD lpAuthError)
{
    PTSTR        pFileList;
    PTSTR        pOldDir;
    PWPNPINFO   pInfo;
    DWORD       dwReturn = ERR_NONE;

    if (NULL != (pInfo = (PWPNPINFO)GlobalAlloc(GPTR, sizeof(WPNPINFO)))) {

        if (NULL != (pInfo->pFullCABPath = (PTSTR)GlobalAlloc(GPTR, (lstrlen(pCABName) + 1) * sizeof(TCHAR)))) {

            lstrcpy(pInfo->pFullCABPath, pCABName);

            if (pInfo->pCABDir = GetDirectory(pInfo->pFullCABPath, &dwReturn)) {

                if (pOldDir = GetCurDir()) {

                    if (pInfo->pTempDir = CreateTempDirectory() ) {

                        SetCurrentDirectory(pInfo->pTempDir);

                        if (pInfo->pCABName = GetName(pInfo->pFullCABPath, &dwReturn)) {

                            if (Extract(pInfo)) {

// Verification of files removed
//                            if (ERR_NONE == (dwReturn = VerifyFiles(pInfo, lpAuthError))) {

                                dwReturn = InvokePrintWizard(pInfo, lpAuthError);
//                            }

                                CleanupFileList(pInfo);

                            } else {

                                dwReturn = ERR_CAB_EXTRACT;
                            }

                            GlobalFree(pInfo->pCABName);
                        }

                        SetCurrentDirectory(pOldDir);
                        RemoveDirectory(pInfo->pTempDir);
                        GlobalFree(pInfo->pTempDir);
                    }

                    GlobalFree(pOldDir);
                }

                GlobalFree(pInfo->pCABDir);
            }

            GlobalFree(pInfo->pFullCABPath);

        } else {

            dwReturn = ERR_NO_MEMORY;
        }

        GlobalFree(pInfo);

    } else {

        dwReturn = ERR_NO_MEMORY;
    }

    return dwReturn;
}

/******************************************************************************\
*
* LookupErrorString (Local Routine)
*
* Returns an error string associated with dwErrorCode
*
\******************************************************************************/
LPCTSTR LookupErrorString(DWORD dwErrorCode) {

    int i;
    int nCount;


    static ERROR_MAPPING s_ErrorMap[] = {

        { ERR_NO_MEMORY,              &g_szENoMemory         },
        { ERR_BAD_CAB,                &g_szEBadCAB           },
        { ERR_INVALID_PARAMETER,      &g_szEInvalidParameter },
        { ERR_INVALID_CAB_NAME,       &g_szEInvalidCABName   },
        { ERR_CAB_EXTRACT,            &g_szECABExtract       },
        { ERR_NO_DAT_FILE,            &g_szENoDATFile        },
        { ERR_NO_PRINTUI,             &g_szENoPrintUI        },
        { ERR_NO_PRINTUIENTRY,        &g_szENoPrintUIEntry   },
        { ERR_PRINTUIENTRY_FAIL,      &g_szEPrintUIEntryFail },
        { ERR_PLATFORM_NOT_SUPPORTED, &g_szENotSupported     }
    };


    nCount = sizeof(s_ErrorMap) / sizeof(s_ErrorMap[0]);

    for (i=0; i < nCount; i++) {

        if (0 != ((s_ErrorMap[i].dwErrorCode) & dwErrorCode & ~(ERR_GENERIC)) )
            return *(s_ErrorMap[i].lpszError);
    }

    return g_szEGeneric;
}

/******************************************************************************\
*
* CheckErrors (Local Routine)
*
* Checks dwErrorCode for any error conditions
*
\******************************************************************************/
VOID CheckErrors(DWORD dwErrorCode, DWORD dwAuthError) {

    LPTSTR   lpszMessage = NULL;
    LPTSTR   lpszErrorString = NULL;
    BOOL     bAuthErrorAllocated;
    UINT_PTR Args[MAX_ARGS];

    bAuthErrorAllocated = FALSE;

    if (dwErrorCode != ERR_NONE) {

        // Check for Authenticode errors here
        if (dwErrorCode == ERR_AUTHENTICODE) {

            // Format the authenticode error message.
            // If the message can't be found in the system, use our generic error message
            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL, dwAuthError, 0, (LPTSTR)&lpszErrorString, 0, NULL)) {
                bAuthErrorAllocated = TRUE;
            }
            else {
                lpszErrorString = (LPTSTR)LookupErrorString(ERR_GENERIC);
            }
        }
        // If the error is not Authenticode, it must be ours.
        // Look it up in our error string table.
        else {
            lpszErrorString = (LPTSTR)LookupErrorString(dwErrorCode);
        }

        // Set up our arg list.
        Args[0] = (UINT_PTR) lpszErrorString;
        if (dwErrorCode == ERR_AUTHENTICODE) {
            Args[1] = dwAuthError;
        }
        else
            Args[1] = dwErrorCode;
        Args[2] = 0;

        // Format our error message and display it in a message box.
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          g_szErrorFormat, 0, 0, (LPTSTR)&lpszMessage, 0, (va_list*)Args )) {

            if (lpszMessage) {
                MessageBox(NULL, lpszMessage, g_szError, MB_ICONEXCLAMATION | MB_OK);

                // Free the buffer
                LocalFree(lpszMessage);
            }

        }

    }

    // Free up the Authenticode error string allocated for us by FormatMessage().
    if (bAuthErrorAllocated)
        LocalFree(lpszErrorString);
}

/******************************************************************************\
*
* WinMain
*
* Main entrypoint for the program.
*
\******************************************************************************/
INT WINAPI _tWinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPTSTR lpszCmdLine, INT nCmdShow)
{
    LPTSTR lpszCABName;
    DWORD  dwReturn    = ERR_NONE;
    DWORD  dwAuthError = ERROR_SUCCESS;

    g_hInstance = hInstance;

    if (InitStrings()) {

        if (NULL != (lpszCABName = GetCABName(lpszCmdLine, &dwReturn))) {

            dwReturn = WebPnPCABInstall(lpszCABName, &dwAuthError);
            GlobalFree(lpszCABName);
        }

#if 0
        // We disable the error since oleprn will
        // prompt users with the correct error
        //
        CheckErrors(dwReturn, dwAuthError);
#endif

        // Decide which error code we must return
        //
        if (dwReturn == ERR_NONE) {

            dwReturn = SUCCESS_EXITCODE;

        } else {

            if (dwReturn == ERR_AUTHENTICODE) {

                if (dwAuthError == ERROR_SUCCESS) {

                    dwReturn = SUCCESS_EXITCODE;

                } else {

                    dwReturn = dwAuthError;
                }
            }
        }

        FreeStrings();
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\exe\wpnpinst.h ===
/*---------------------------------------------------------------------------*\
| MODULE: wnpinstl.h
|
|   This is the main header module for the application.
|
|
| Copyright (C) 1997 Microsoft Corporation
| Copyright (C) 1997 Hewlett Pac